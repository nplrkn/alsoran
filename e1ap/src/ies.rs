// Autogenerated from E1AP-IEs.asn
#![allow(clippy::all)]
use super::common::*;
use asn1_per::{aper::*, *};
#[allow(unused_imports)]
use xxap::{GtpTunnel, PduSessionId, TransportLayerAddress};

// ActivityInformation
#[derive(Clone, Debug)]
pub enum ActivityInformation {
    DrbActivityList(DrbActivityList),
    PduSessionResourceActivityList(PduSessionResourceActivityList),
    UeActivity(UeActivity),
}

impl ActivityInformation {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_choice_idx(data, 0, 3, false)?;
        if extended {
            return Err(PerCodecError::new("CHOICE additions not implemented"));
        }
        match idx {
            0 => Ok(Self::DrbActivityList(DrbActivityList::decode(data)?)),
            1 => Ok(Self::PduSessionResourceActivityList(
                PduSessionResourceActivityList::decode(data)?,
            )),
            2 => Ok(Self::UeActivity(UeActivity::decode(data)?)),
            3 => {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _ = Criticality::decode(data)?;
                let _ = decode::decode_length_determinent(data, None, None, false)?;
                let result = match id {
                    x => Err(PerCodecError::new(format!("Unrecognised IE type {}", x))),
                };
                data.decode_align()?;
                result
            }
            _ => Err(PerCodecError::new("Unknown choice idx")),
        }
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        match self {
            Self::DrbActivityList(x) => {
                encode::encode_choice_idx(data, 0, 3, false, 0, false)?;
                x.encode(data)
            }
            Self::PduSessionResourceActivityList(x) => {
                encode::encode_choice_idx(data, 0, 3, false, 1, false)?;
                x.encode(data)
            }
            Self::UeActivity(x) => {
                encode::encode_choice_idx(data, 0, 3, false, 2, false)?;
                x.encode(data)
            }
        }
    }
}

impl PerCodec for ActivityInformation {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        ActivityInformation::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ActivityInformation");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ActivityInformation");
            e
        })
    }
}
// ActivityNotificationLevel
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum ActivityNotificationLevel {
    Drb,
    PduSession,
    Ue,
}

impl ActivityNotificationLevel {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(2), true)?;
        if extended {
            return Err(PerCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(data, Some(0), Some(2), true, *self as i128, false)
    }
}

impl PerCodec for ActivityNotificationLevel {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        ActivityNotificationLevel::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ActivityNotificationLevel");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ActivityNotificationLevel");
            e
        })
    }
}
// AdditionalHandoverInfo
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum AdditionalHandoverInfo {
    DiscardPdpcSn,
}

impl AdditionalHandoverInfo {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(0), true)?;
        if extended {
            return Err(PerCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(data, Some(0), Some(0), true, *self as i128, false)
    }
}

impl PerCodec for AdditionalHandoverInfo {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        AdditionalHandoverInfo::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("AdditionalHandoverInfo");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("AdditionalHandoverInfo");
            e
        })
    }
}
// AdditionalPdcPduplicationInformation
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum AdditionalPdcPduplicationInformation {
    Three,
    Four,
}

impl AdditionalPdcPduplicationInformation {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(1), true)?;
        if extended {
            return Err(PerCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(data, Some(0), Some(1), true, *self as i128, false)
    }
}

impl PerCodec for AdditionalPdcPduplicationInformation {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        AdditionalPdcPduplicationInformation::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("AdditionalPdcPduplicationInformation");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("AdditionalPdcPduplicationInformation");
            e
        })
    }
}
// AdditionalRrmPriorityIndex
#[derive(Clone, Debug)]
pub struct AdditionalRrmPriorityIndex(pub BitString);

impl AdditionalRrmPriorityIndex {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(decode::decode_bitstring(
            data,
            Some(32),
            Some(32),
            false,
        )?))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_bitstring(data, Some(32), Some(32), false, &self.0, false)
    }
}

impl PerCodec for AdditionalRrmPriorityIndex {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        AdditionalRrmPriorityIndex::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("AdditionalRrmPriorityIndex");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("AdditionalRrmPriorityIndex");
            e
        })
    }
}
// AveragingWindow
#[derive(Clone, Copy, Debug)]
pub struct AveragingWindow(pub u16);

impl AveragingWindow {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(
            decode::decode_integer(data, Some(0), Some(4095), true)?.0 as u16,
        ))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_integer(data, Some(0), Some(4095), true, self.0 as i128, false)
    }
}

impl PerCodec for AveragingWindow {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        AveragingWindow::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("AveragingWindow");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("AveragingWindow");
            e
        })
    }
}
// AlternativeQosParaSetList
#[derive(Clone, Debug)]
pub struct AlternativeQosParaSetList(pub NonEmpty<AlternativeQosParaSetItem>);

impl AlternativeQosParaSetList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(8), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(AlternativeQosParaSetItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(8), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for AlternativeQosParaSetList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        AlternativeQosParaSetList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("AlternativeQosParaSetList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("AlternativeQosParaSetList");
            e
        })
    }
}
// AlternativeQosParaSetItem
#[derive(Clone, Debug)]
pub struct AlternativeQosParaSetItem {
    pub alternative_qos_parameter_index: u8,
    pub guaranteed_flow_bit_rate_dl: Option<BitRate>,
    pub guaranteed_flow_bit_rate_ul: Option<BitRate>,
    pub packet_delay_budget: Option<PacketDelayBudget>,
    pub packet_error_rate: Option<PacketErrorRate>,
}

impl AlternativeQosParaSetItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 5)?;
        let alternative_qos_parameter_index =
            decode::decode_integer(data, Some(1), Some(8), true)?.0 as u8;
        let guaranteed_flow_bit_rate_dl = if optionals[0] {
            Some(BitRate::decode(data)?)
        } else {
            None
        };
        let guaranteed_flow_bit_rate_ul = if optionals[1] {
            Some(BitRate::decode(data)?)
        } else {
            None
        };
        let packet_delay_budget = if optionals[2] {
            Some(PacketDelayBudget::decode(data)?)
        } else {
            None
        };
        let packet_error_rate = if optionals[3] {
            Some(PacketErrorRate::decode(data)?)
        } else {
            None
        };

        // Process the extension container

        if optionals[4] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            alternative_qos_parameter_index,
            guaranteed_flow_bit_rate_dl,
            guaranteed_flow_bit_rate_ul,
            packet_delay_budget,
            packet_error_rate,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.guaranteed_flow_bit_rate_dl.is_some());
        optionals.push(self.guaranteed_flow_bit_rate_ul.is_some());
        optionals.push(self.packet_delay_budget.is_some());
        optionals.push(self.packet_error_rate.is_some());
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        encode::encode_integer(
            data,
            Some(1),
            Some(8),
            true,
            self.alternative_qos_parameter_index as i128,
            false,
        )?;
        if let Some(x) = &self.guaranteed_flow_bit_rate_dl {
            x.encode(data)?;
        }
        if let Some(x) = &self.guaranteed_flow_bit_rate_ul {
            x.encode(data)?;
        }
        if let Some(x) = &self.packet_delay_budget {
            x.encode(data)?;
        }
        if let Some(x) = &self.packet_error_rate {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl PerCodec for AlternativeQosParaSetItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        AlternativeQosParaSetItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("AlternativeQosParaSetItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("AlternativeQosParaSetItem");
            e
        })
    }
}
// BearerContextStatusChange
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum BearerContextStatusChange {
    Suspend,
    Resume,
}

impl BearerContextStatusChange {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(1), true)?;
        if extended {
            return Err(PerCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(data, Some(0), Some(1), true, *self as i128, false)
    }
}

impl PerCodec for BearerContextStatusChange {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        BearerContextStatusChange::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("BearerContextStatusChange");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("BearerContextStatusChange");
            e
        })
    }
}
// BitRate
#[derive(Clone, Copy, Debug)]
pub struct BitRate(pub u64);

impl BitRate {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(
            decode::decode_integer(data, Some(0), Some(4000000000000), true)?.0 as u64,
        ))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_integer(
            data,
            Some(0),
            Some(4000000000000),
            true,
            self.0 as i128,
            false,
        )
    }
}

impl PerCodec for BitRate {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        BitRate::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("BitRate");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("BitRate");
            e
        })
    }
}
// Cause
#[derive(Clone, Debug)]
pub enum Cause {
    RadioNetwork(CauseRadioNetwork),
    Transport(CauseTransport),
    Protocol(CauseProtocol),
    Misc(CauseMisc),
}

impl Cause {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_choice_idx(data, 0, 4, false)?;
        if extended {
            return Err(PerCodecError::new("CHOICE additions not implemented"));
        }
        match idx {
            0 => Ok(Self::RadioNetwork(CauseRadioNetwork::decode(data)?)),
            1 => Ok(Self::Transport(CauseTransport::decode(data)?)),
            2 => Ok(Self::Protocol(CauseProtocol::decode(data)?)),
            3 => Ok(Self::Misc(CauseMisc::decode(data)?)),
            4 => {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _ = Criticality::decode(data)?;
                let _ = decode::decode_length_determinent(data, None, None, false)?;
                let result = match id {
                    x => Err(PerCodecError::new(format!("Unrecognised IE type {}", x))),
                };
                data.decode_align()?;
                result
            }
            _ => Err(PerCodecError::new("Unknown choice idx")),
        }
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        match self {
            Self::RadioNetwork(x) => {
                encode::encode_choice_idx(data, 0, 4, false, 0, false)?;
                x.encode(data)
            }
            Self::Transport(x) => {
                encode::encode_choice_idx(data, 0, 4, false, 1, false)?;
                x.encode(data)
            }
            Self::Protocol(x) => {
                encode::encode_choice_idx(data, 0, 4, false, 2, false)?;
                x.encode(data)
            }
            Self::Misc(x) => {
                encode::encode_choice_idx(data, 0, 4, false, 3, false)?;
                x.encode(data)
            }
        }
    }
}

impl PerCodec for Cause {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Cause::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("Cause");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("Cause");
            e
        })
    }
}
// CauseMisc
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum CauseMisc {
    ControlProcessingOverload,
    NotEnoughUserPlaneProcessingResources,
    HardwareFailure,
    OmIntervention,
    Unspecified,
}

impl CauseMisc {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(4), true)?;
        if extended {
            return Err(PerCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(data, Some(0), Some(4), true, *self as i128, false)
    }
}

impl PerCodec for CauseMisc {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        CauseMisc::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CauseMisc");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CauseMisc");
            e
        })
    }
}
// CauseProtocol
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum CauseProtocol {
    TransferSyntaxError,
    AbstractSyntaxErrorReject,
    AbstractSyntaxErrorIgnoreAndNotify,
    MessageNotCompatibleWithReceiverState,
    SemanticError,
    AbstractSyntaxErrorFalselyConstructedMessage,
    Unspecified,
}

impl CauseProtocol {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(6), true)?;
        if extended {
            return Err(PerCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(data, Some(0), Some(6), true, *self as i128, false)
    }
}

impl PerCodec for CauseProtocol {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        CauseProtocol::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CauseProtocol");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CauseProtocol");
            e
        })
    }
}
// CauseRadioNetwork
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum CauseRadioNetwork {
    Unspecified,
    UnknownOrAlreadyAllocatedGnbCuCpUeE1apId,
    UnknownOrAlreadyAllocatedGnbCuUpUeE1apId,
    UnknownOrInconsistentPairOfUeE1apId,
    InteractionWithOtherProcedure,
    PpdcpCountWrapAround,
    NotSupportedQciValue,
    NotSupported5qiValue,
    EncryptionAlgorithmsNotSupported,
    IntegrityProtectionAlgorithmsNotSupported,
    UpIntegrityProtectionNotPossible,
    UpConfidentialityProtectionNotPossible,
    MultiplePduSessionIdInstances,
    UnknownPduSessionId,
    MultipleQosFlowIdInstances,
    UnknownQosFlowId,
    MultipleDrbIdInstances,
    UnknownDrbId,
    InvalidQosCombination,
    ProcedureCancelled,
    NormalRelease,
    NoRadioResourcesAvailable,
    ActionDesirableForRadioReasons,
    ResourcesNotAvailableForTheSlice,
    PdcpConfigurationNotSupported,
}

impl CauseRadioNetwork {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(24), true)?;
        if extended {
            return Err(PerCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(data, Some(0), Some(24), true, *self as i128, false)
    }
}

impl PerCodec for CauseRadioNetwork {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        CauseRadioNetwork::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CauseRadioNetwork");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CauseRadioNetwork");
            e
        })
    }
}
// CauseTransport
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum CauseTransport {
    Unspecified,
    TransportResourceUnavailable,
}

impl CauseTransport {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(1), true)?;
        if extended {
            return Err(PerCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(data, Some(0), Some(1), true, *self as i128, false)
    }
}

impl PerCodec for CauseTransport {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        CauseTransport::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CauseTransport");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CauseTransport");
            e
        })
    }
}
// CellGroupInformation
#[derive(Clone, Debug)]
pub struct CellGroupInformation(pub NonEmpty<CellGroupInformationItem>);

impl CellGroupInformation {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(4), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(CellGroupInformationItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(4), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for CellGroupInformation {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        CellGroupInformation::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CellGroupInformation");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CellGroupInformation");
            e
        })
    }
}
// CellGroupInformationItem
#[derive(Clone, Debug)]
pub struct CellGroupInformationItem {
    pub cell_group_id: CellGroupId,
    pub ul_configuration: Option<UlConfiguration>,
    pub dl_tx_stop: Option<DlTxStop>,
    pub rat_type: Option<RatType>,
    pub number_of_tunnels: Option<NumberOfTunnels>,
}

impl CellGroupInformationItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 4)?;
        let cell_group_id = CellGroupId::decode(data)?;
        let ul_configuration = if optionals[0] {
            Some(UlConfiguration::decode(data)?)
        } else {
            None
        };
        let dl_tx_stop = if optionals[1] {
            Some(DlTxStop::decode(data)?)
        } else {
            None
        };
        let rat_type = if optionals[2] {
            Some(RatType::decode(data)?)
        } else {
            None
        };

        // Process the extension container
        let mut number_of_tunnels: Option<NumberOfTunnels> = None;

        if optionals[3] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    127 => number_of_tunnels = Some(NumberOfTunnels::decode(data)?),
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            cell_group_id,
            ul_configuration,
            dl_tx_stop,
            rat_type,
            number_of_tunnels,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();
        if let Some(x) = &self.number_of_tunnels {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 127, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        let mut optionals = BitString::new();
        optionals.push(self.ul_configuration.is_some());
        optionals.push(self.dl_tx_stop.is_some());
        optionals.push(self.rat_type.is_some());
        optionals.push(num_ies != 0);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.cell_group_id.encode(data)?;
        if let Some(x) = &self.ul_configuration {
            x.encode(data)?;
        }
        if let Some(x) = &self.dl_tx_stop {
            x.encode(data)?;
        }
        if let Some(x) = &self.rat_type {
            x.encode(data)?;
        }
        if num_ies != 0 {
            encode::encode_length_determinent(data, Some(1), Some(65535), false, num_ies)?;
            data.append_aligned(ies);
        }
        Ok(())
    }
}

impl PerCodec for CellGroupInformationItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        CellGroupInformationItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CellGroupInformationItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CellGroupInformationItem");
            e
        })
    }
}
// CellGroupId
#[derive(Clone, Copy, Debug)]
pub struct CellGroupId(pub u8);

impl CellGroupId {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(
            decode::decode_integer(data, Some(0), Some(3), true)?.0 as u8,
        ))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_integer(data, Some(0), Some(3), true, self.0 as i128, false)
    }
}

impl PerCodec for CellGroupId {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        CellGroupId::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CellGroupId");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CellGroupId");
            e
        })
    }
}
// ChoInitiation
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum ChoInitiation {
    True,
}

impl ChoInitiation {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(0), true)?;
        if extended {
            return Err(PerCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(data, Some(0), Some(0), true, *self as i128, false)
    }
}

impl PerCodec for ChoInitiation {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        ChoInitiation::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ChoInitiation");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ChoInitiation");
            e
        })
    }
}
// NumberOfTunnels
#[derive(Clone, Copy, Debug)]
pub struct NumberOfTunnels(pub u8);

impl NumberOfTunnels {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(
            decode::decode_integer(data, Some(1), Some(4), true)?.0 as u8,
        ))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_integer(data, Some(1), Some(4), true, self.0 as i128, false)
    }
}

impl PerCodec for NumberOfTunnels {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        NumberOfTunnels::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NumberOfTunnels");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NumberOfTunnels");
            e
        })
    }
}
// CipheringAlgorithm
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum CipheringAlgorithm {
    Nea0,
    C128Nea1,
    C128Nea2,
    C128Nea3,
}

impl CipheringAlgorithm {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(3), true)?;
        if extended {
            return Err(PerCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(data, Some(0), Some(3), true, *self as i128, false)
    }
}

impl PerCodec for CipheringAlgorithm {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        CipheringAlgorithm::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CipheringAlgorithm");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CipheringAlgorithm");
            e
        })
    }
}
// CnSupport
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum CnSupport {
    CEpc,
    C5gc,
    Both,
}

impl CnSupport {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(2), true)?;
        if extended {
            return Err(PerCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(data, Some(0), Some(2), true, *self as i128, false)
    }
}

impl PerCodec for CnSupport {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        CnSupport::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CnSupport");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CnSupport");
            e
        })
    }
}
// CommonNetworkInstance
#[derive(Clone, Debug)]
pub struct CommonNetworkInstance(pub Vec<u8>);

impl CommonNetworkInstance {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(decode::decode_octetstring(data, None, None, false)?))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_octetstring(data, None, None, false, &self.0, false)
    }
}

impl PerCodec for CommonNetworkInstance {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        CommonNetworkInstance::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CommonNetworkInstance");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CommonNetworkInstance");
            e
        })
    }
}
// ConfidentialityProtectionIndication
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum ConfidentialityProtectionIndication {
    Required,
    Preferred,
    NotNeeded,
}

impl ConfidentialityProtectionIndication {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(2), true)?;
        if extended {
            return Err(PerCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(data, Some(0), Some(2), true, *self as i128, false)
    }
}

impl PerCodec for ConfidentialityProtectionIndication {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        ConfidentialityProtectionIndication::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ConfidentialityProtectionIndication");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ConfidentialityProtectionIndication");
            e
        })
    }
}
// ConfidentialityProtectionResult
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum ConfidentialityProtectionResult {
    Performed,
    NotPerformed,
}

impl ConfidentialityProtectionResult {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(1), true)?;
        if extended {
            return Err(PerCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(data, Some(0), Some(1), true, *self as i128, false)
    }
}

impl PerCodec for ConfidentialityProtectionResult {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        ConfidentialityProtectionResult::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ConfidentialityProtectionResult");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ConfidentialityProtectionResult");
            e
        })
    }
}
// CpTnlInformation
#[derive(Clone, Debug)]
pub enum CpTnlInformation {
    EndpointIpAddress(TransportLayerAddress),
    EndpointIpAddressAndPort(EndpointIpAddressAndPort),
}

impl CpTnlInformation {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_choice_idx(data, 0, 1, false)?;
        if extended {
            return Err(PerCodecError::new("CHOICE additions not implemented"));
        }
        match idx {
            0 => Ok(Self::EndpointIpAddress(TransportLayerAddress::decode(
                data,
            )?)),
            1 => {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _ = Criticality::decode(data)?;
                let _ = decode::decode_length_determinent(data, None, None, false)?;
                let result = match id {
                    74 => Ok(Self::EndpointIpAddressAndPort(
                        EndpointIpAddressAndPort::decode(data)?,
                    )),
                    x => Err(PerCodecError::new(format!("Unrecognised IE type {}", x))),
                };
                data.decode_align()?;
                result
            }
            _ => Err(PerCodecError::new("Unknown choice idx")),
        }
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        match self {
            Self::EndpointIpAddress(x) => {
                encode::encode_choice_idx(data, 0, 1, false, 0, false)?;
                x.encode(data)
            }
            Self::EndpointIpAddressAndPort(x) => {
                encode::encode_choice_idx(data, 0, 1, false, 1, false)?;
                encode::encode_integer(data, Some(0), Some(65535), false, 74, false)?;
                Criticality::Reject.encode(data)?;
                let ie = &mut Allocator::new_codec_data();
                x.encode(ie)?;
                encode::encode_length_determinent(data, None, None, false, ie.length_in_bytes())?;
                Ok(data.append_aligned(ie))
            }
        }
    }
}

impl PerCodec for CpTnlInformation {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        CpTnlInformation::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CpTnlInformation");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CpTnlInformation");
            e
        })
    }
}
// CriticalityDiagnostics
#[derive(Clone, Debug)]
pub struct CriticalityDiagnostics {
    pub procedure_code: Option<ProcedureCode>,
    pub triggering_message: Option<TriggeringMessage>,
    pub procedure_criticality: Option<Criticality>,
    pub transaction_id: Option<TransactionId>,
    pub i_es_criticality_diagnostics: Option<CriticalityDiagnosticsIeList>,
}

impl CriticalityDiagnostics {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 6)?;
        let procedure_code = if optionals[0] {
            Some(ProcedureCode::decode(data)?)
        } else {
            None
        };
        let triggering_message = if optionals[1] {
            Some(TriggeringMessage::decode(data)?)
        } else {
            None
        };
        let procedure_criticality = if optionals[2] {
            Some(Criticality::decode(data)?)
        } else {
            None
        };
        let transaction_id = if optionals[3] {
            Some(TransactionId::decode(data)?)
        } else {
            None
        };
        let i_es_criticality_diagnostics = if optionals[4] {
            Some(CriticalityDiagnosticsIeList::decode(data)?)
        } else {
            None
        };

        // Process the extension container

        if optionals[5] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            procedure_code,
            triggering_message,
            procedure_criticality,
            transaction_id,
            i_es_criticality_diagnostics,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.procedure_code.is_some());
        optionals.push(self.triggering_message.is_some());
        optionals.push(self.procedure_criticality.is_some());
        optionals.push(self.transaction_id.is_some());
        optionals.push(self.i_es_criticality_diagnostics.is_some());
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        if let Some(x) = &self.procedure_code {
            x.encode(data)?;
        }
        if let Some(x) = &self.triggering_message {
            x.encode(data)?;
        }
        if let Some(x) = &self.procedure_criticality {
            x.encode(data)?;
        }
        if let Some(x) = &self.transaction_id {
            x.encode(data)?;
        }
        if let Some(x) = &self.i_es_criticality_diagnostics {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl PerCodec for CriticalityDiagnostics {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        CriticalityDiagnostics::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CriticalityDiagnostics");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CriticalityDiagnostics");
            e
        })
    }
}
// CriticalityDiagnosticsIeList
#[derive(Clone, Debug)]
pub struct CriticalityDiagnosticsIeList(pub NonEmpty<CriticalityDiagnosticsIeList1>);

impl CriticalityDiagnosticsIeList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(256), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(CriticalityDiagnosticsIeList1::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(256), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for CriticalityDiagnosticsIeList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        CriticalityDiagnosticsIeList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CriticalityDiagnosticsIeList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CriticalityDiagnosticsIeList");
            e
        })
    }
}
// DapsRequestInfo
#[derive(Clone, Debug)]
pub struct DapsRequestInfo {
    pub daps_indicator: DapsIndicator,
}

impl DapsRequestInfo {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let daps_indicator = DapsIndicator::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self { daps_indicator })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.daps_indicator.encode(data)?;

        Ok(())
    }
}

impl PerCodec for DapsRequestInfo {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        DapsRequestInfo::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DapsRequestInfo");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DapsRequestInfo");
            e
        })
    }
}
// DataForwardingInformationRequest
#[derive(Clone, Debug)]
pub struct DataForwardingInformationRequest {
    pub data_forwarding_request: DataForwardingRequest,
    pub qos_flows_forwarded_on_fwd_tunnels: Option<QosFlowMappingList>,
}

impl DataForwardingInformationRequest {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 2)?;
        let data_forwarding_request = DataForwardingRequest::decode(data)?;
        let qos_flows_forwarded_on_fwd_tunnels = if optionals[0] {
            Some(QosFlowMappingList::decode(data)?)
        } else {
            None
        };

        // Process the extension container

        if optionals[1] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            data_forwarding_request,
            qos_flows_forwarded_on_fwd_tunnels,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.qos_flows_forwarded_on_fwd_tunnels.is_some());
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.data_forwarding_request.encode(data)?;
        if let Some(x) = &self.qos_flows_forwarded_on_fwd_tunnels {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl PerCodec for DataForwardingInformationRequest {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        DataForwardingInformationRequest::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DataForwardingInformationRequest");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DataForwardingInformationRequest");
            e
        })
    }
}
// DataForwardingInformation
#[derive(Clone, Debug)]
pub struct DataForwardingInformation {
    pub ul_data_forwarding: Option<UpTnlInformation>,
    pub dl_data_forwarding: Option<UpTnlInformation>,
    pub data_forwardingto_ng_ran_qos_flow_information_list:
        Option<DataForwardingtoNgRanQosFlowInformationList>,
}

impl DataForwardingInformation {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 3)?;
        let ul_data_forwarding = if optionals[0] {
            Some(UpTnlInformation::decode(data)?)
        } else {
            None
        };
        let dl_data_forwarding = if optionals[1] {
            Some(UpTnlInformation::decode(data)?)
        } else {
            None
        };

        // Process the extension container
        let mut data_forwardingto_ng_ran_qos_flow_information_list: Option<
            DataForwardingtoNgRanQosFlowInformationList,
        > = None;

        if optionals[2] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    136 => {
                        data_forwardingto_ng_ran_qos_flow_information_list =
                            Some(DataForwardingtoNgRanQosFlowInformationList::decode(data)?)
                    }
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            ul_data_forwarding,
            dl_data_forwarding,
            data_forwardingto_ng_ran_qos_flow_information_list,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();
        if let Some(x) = &self.data_forwardingto_ng_ran_qos_flow_information_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 136, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        let mut optionals = BitString::new();
        optionals.push(self.ul_data_forwarding.is_some());
        optionals.push(self.dl_data_forwarding.is_some());
        optionals.push(num_ies != 0);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        if let Some(x) = &self.ul_data_forwarding {
            x.encode(data)?;
        }
        if let Some(x) = &self.dl_data_forwarding {
            x.encode(data)?;
        }
        if num_ies != 0 {
            encode::encode_length_determinent(data, Some(1), Some(65535), false, num_ies)?;
            data.append_aligned(ies);
        }
        Ok(())
    }
}

impl PerCodec for DataForwardingInformation {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        DataForwardingInformation::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DataForwardingInformation");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DataForwardingInformation");
            e
        })
    }
}
// DataForwardingRequest
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum DataForwardingRequest {
    Ul,
    Dl,
    Both,
}

impl DataForwardingRequest {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(2), true)?;
        if extended {
            return Err(PerCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(data, Some(0), Some(2), true, *self as i128, false)
    }
}

impl PerCodec for DataForwardingRequest {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        DataForwardingRequest::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DataForwardingRequest");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DataForwardingRequest");
            e
        })
    }
}
// DataForwardingtoEutranInformationList
#[derive(Clone, Debug)]
pub struct DataForwardingtoEutranInformationList(
    pub NonEmpty<DataForwardingtoEutranInformationListItem>,
);

impl DataForwardingtoEutranInformationList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(256), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(DataForwardingtoEutranInformationListItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(256), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for DataForwardingtoEutranInformationList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        DataForwardingtoEutranInformationList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DataForwardingtoEutranInformationList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DataForwardingtoEutranInformationList");
            e
        })
    }
}
// DataForwardingtoEutranInformationListItem
#[derive(Clone, Debug)]
pub struct DataForwardingtoEutranInformationListItem {
    pub data_forwarding_tunnel_information: UpTnlInformation,
    pub qos_flows_to_be_forwarded_list: QosFlowsToBeForwardedList,
}

impl DataForwardingtoEutranInformationListItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let data_forwarding_tunnel_information = UpTnlInformation::decode(data)?;
        let qos_flows_to_be_forwarded_list = QosFlowsToBeForwardedList::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            data_forwarding_tunnel_information,
            qos_flows_to_be_forwarded_list,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.data_forwarding_tunnel_information.encode(data)?;
        self.qos_flows_to_be_forwarded_list.encode(data)?;

        Ok(())
    }
}

impl PerCodec for DataForwardingtoEutranInformationListItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        DataForwardingtoEutranInformationListItem::decode_inner(data).map_err(
            |mut e: PerCodecError| {
                e.push_context("DataForwardingtoEutranInformationListItem");
                e
            },
        )
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DataForwardingtoEutranInformationListItem");
            e
        })
    }
}
// DataUsagePerPduSessionReport
#[derive(Clone, Debug)]
pub struct DataUsagePerPduSessionReport {
    pub secondary_rat_type: SecondaryRatType,
    pub pdu_session_timed_report_list: NonEmpty<MrdcDataUsageReportItem>,
}

impl DataUsagePerPduSessionReport {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let secondary_rat_type = SecondaryRatType::decode(data)?;
        let pdu_session_timed_report_list = {
            let length = decode::decode_length_determinent(data, Some(1), Some(2), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(MrdcDataUsageReportItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        };

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            secondary_rat_type,
            pdu_session_timed_report_list,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.secondary_rat_type.encode(data)?;
        encode::encode_length_determinent(
            data,
            Some(1),
            Some(2),
            false,
            self.pdu_session_timed_report_list.len(),
        )?;
        for x in &self.pdu_session_timed_report_list {
            x.encode(data)?;
        }
        Ok(())?;

        Ok(())
    }
}

impl PerCodec for DataUsagePerPduSessionReport {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        DataUsagePerPduSessionReport::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DataUsagePerPduSessionReport");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DataUsagePerPduSessionReport");
            e
        })
    }
}
// DataUsagePerQosFlowList
#[derive(Clone, Debug)]
pub struct DataUsagePerQosFlowList(pub NonEmpty<DataUsagePerQosFlowItem>);

impl DataUsagePerQosFlowList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(64), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(DataUsagePerQosFlowItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(64), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for DataUsagePerQosFlowList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        DataUsagePerQosFlowList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DataUsagePerQosFlowList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DataUsagePerQosFlowList");
            e
        })
    }
}
// DataUsagePerQosFlowItem
#[derive(Clone, Debug)]
pub struct DataUsagePerQosFlowItem {
    pub qos_flow_identifier: QosFlowIdentifier,
    pub secondary_rat_type: SecondaryRatType1,
    pub qos_flow_timed_report_list: NonEmpty<MrdcDataUsageReportItem>,
}

impl DataUsagePerQosFlowItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let qos_flow_identifier = QosFlowIdentifier::decode(data)?;
        let secondary_rat_type = SecondaryRatType1::decode(data)?;
        let qos_flow_timed_report_list = {
            let length = decode::decode_length_determinent(data, Some(1), Some(2), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(MrdcDataUsageReportItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        };

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            qos_flow_identifier,
            secondary_rat_type,
            qos_flow_timed_report_list,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.qos_flow_identifier.encode(data)?;
        self.secondary_rat_type.encode(data)?;
        encode::encode_length_determinent(
            data,
            Some(1),
            Some(2),
            false,
            self.qos_flow_timed_report_list.len(),
        )?;
        for x in &self.qos_flow_timed_report_list {
            x.encode(data)?;
        }
        Ok(())?;

        Ok(())
    }
}

impl PerCodec for DataUsagePerQosFlowItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        DataUsagePerQosFlowItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DataUsagePerQosFlowItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DataUsagePerQosFlowItem");
            e
        })
    }
}
// DataUsageReportList
#[derive(Clone, Debug)]
pub struct DataUsageReportList(pub NonEmpty<DataUsageReportItem>);

impl DataUsageReportList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(32), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(DataUsageReportItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(32), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for DataUsageReportList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        DataUsageReportList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DataUsageReportList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DataUsageReportList");
            e
        })
    }
}
// DataUsageReportItem
#[derive(Clone, Debug)]
pub struct DataUsageReportItem {
    pub drb_id: DrbId,
    pub rat_type: RatType,
    pub drb_usage_report_list: DrbUsageReportList,
}

impl DataUsageReportItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let drb_id = DrbId::decode(data)?;
        let rat_type = RatType::decode(data)?;
        let drb_usage_report_list = DrbUsageReportList::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            drb_id,
            rat_type,
            drb_usage_report_list,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.drb_id.encode(data)?;
        self.rat_type.encode(data)?;
        self.drb_usage_report_list.encode(data)?;

        Ok(())
    }
}

impl PerCodec for DataUsageReportItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        DataUsageReportItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DataUsageReportItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DataUsageReportItem");
            e
        })
    }
}
// DefaultDrb
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum DefaultDrb {
    True,
    False,
}

impl DefaultDrb {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(1), true)?;
        if extended {
            return Err(PerCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(data, Some(0), Some(1), true, *self as i128, false)
    }
}

impl PerCodec for DefaultDrb {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        DefaultDrb::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DefaultDrb");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DefaultDrb");
            e
        })
    }
}
// DirectForwardingPathAvailability
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum DirectForwardingPathAvailability {
    InterSystemDirectPathAvailable,
}

impl DirectForwardingPathAvailability {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(0), true)?;
        if extended {
            return Err(PerCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(data, Some(0), Some(0), true, *self as i128, false)
    }
}

impl PerCodec for DirectForwardingPathAvailability {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        DirectForwardingPathAvailability::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DirectForwardingPathAvailability");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DirectForwardingPathAvailability");
            e
        })
    }
}
// DiscardTimer
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum DiscardTimer {
    Ms10,
    Ms20,
    Ms30,
    Ms40,
    Ms50,
    Ms60,
    Ms75,
    Ms100,
    Ms150,
    Ms200,
    Ms250,
    Ms300,
    Ms500,
    Ms750,
    Ms1500,
    Infinity,
}

impl DiscardTimer {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(15), false)?;
        if extended {
            return Err(PerCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(data, Some(0), Some(15), false, *self as i128, false)
    }
}

impl PerCodec for DiscardTimer {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        DiscardTimer::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DiscardTimer");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DiscardTimer");
            e
        })
    }
}
// DlDiscarding
#[derive(Clone, Debug)]
pub struct DlDiscarding {
    pub dl_discarding_count_val: PdcpCount,
}

impl DlDiscarding {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, false, 1)?;
        let dl_discarding_count_val = PdcpCount::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            dl_discarding_count_val,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, false, &optionals, false)?;
        self.dl_discarding_count_val.encode(data)?;

        Ok(())
    }
}

impl PerCodec for DlDiscarding {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        DlDiscarding::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DlDiscarding");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DlDiscarding");
            e
        })
    }
}
// DlUpTnlAddressToUpdateItem
#[derive(Clone, Debug)]
pub struct DlUpTnlAddressToUpdateItem {
    pub old_tnl_adress: TransportLayerAddress,
    pub new_tnl_adress: TransportLayerAddress,
}

impl DlUpTnlAddressToUpdateItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let old_tnl_adress = TransportLayerAddress::decode(data)?;
        let new_tnl_adress = TransportLayerAddress::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            old_tnl_adress,
            new_tnl_adress,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.old_tnl_adress.encode(data)?;
        self.new_tnl_adress.encode(data)?;

        Ok(())
    }
}

impl PerCodec for DlUpTnlAddressToUpdateItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        DlUpTnlAddressToUpdateItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DlUpTnlAddressToUpdateItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DlUpTnlAddressToUpdateItem");
            e
        })
    }
}
// DlTxStop
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum DlTxStop {
    Stop,
    Resume,
}

impl DlTxStop {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(1), true)?;
        if extended {
            return Err(PerCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(data, Some(0), Some(1), true, *self as i128, false)
    }
}

impl PerCodec for DlTxStop {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        DlTxStop::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DlTxStop");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DlTxStop");
            e
        })
    }
}
// DrbActivity
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum DrbActivity {
    Active,
    NotActive,
}

impl DrbActivity {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(1), true)?;
        if extended {
            return Err(PerCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(data, Some(0), Some(1), true, *self as i128, false)
    }
}

impl PerCodec for DrbActivity {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        DrbActivity::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DrbActivity");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DrbActivity");
            e
        })
    }
}
// DrbActivityList
#[derive(Clone, Debug)]
pub struct DrbActivityList(pub NonEmpty<DrbActivityItem>);

impl DrbActivityList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(32), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(DrbActivityItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(32), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for DrbActivityList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        DrbActivityList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DrbActivityList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DrbActivityList");
            e
        })
    }
}
// DrbActivityItem
#[derive(Clone, Debug)]
pub struct DrbActivityItem {
    pub drb_id: DrbId,
    pub drb_activity: DrbActivity,
}

impl DrbActivityItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let drb_id = DrbId::decode(data)?;
        let drb_activity = DrbActivity::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            drb_id,
            drb_activity,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.drb_id.encode(data)?;
        self.drb_activity.encode(data)?;

        Ok(())
    }
}

impl PerCodec for DrbActivityItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        DrbActivityItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DrbActivityItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DrbActivityItem");
            e
        })
    }
}
// DrbConfirmModifiedListEutran
#[derive(Clone, Debug)]
pub struct DrbConfirmModifiedListEutran(pub NonEmpty<DrbConfirmModifiedItemEutran>);

impl DrbConfirmModifiedListEutran {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(32), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(DrbConfirmModifiedItemEutran::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(32), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for DrbConfirmModifiedListEutran {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        DrbConfirmModifiedListEutran::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DrbConfirmModifiedListEutran");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DrbConfirmModifiedListEutran");
            e
        })
    }
}
// DrbConfirmModifiedItemEutran
#[derive(Clone, Debug)]
pub struct DrbConfirmModifiedItemEutran {
    pub drb_id: DrbId,
    pub cell_group_information: Option<CellGroupInformation>,
}

impl DrbConfirmModifiedItemEutran {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 2)?;
        let drb_id = DrbId::decode(data)?;
        let cell_group_information = if optionals[0] {
            Some(CellGroupInformation::decode(data)?)
        } else {
            None
        };

        // Process the extension container

        if optionals[1] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            drb_id,
            cell_group_information,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.cell_group_information.is_some());
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.drb_id.encode(data)?;
        if let Some(x) = &self.cell_group_information {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl PerCodec for DrbConfirmModifiedItemEutran {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        DrbConfirmModifiedItemEutran::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DrbConfirmModifiedItemEutran");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DrbConfirmModifiedItemEutran");
            e
        })
    }
}
// DrbConfirmModifiedListNgRan
#[derive(Clone, Debug)]
pub struct DrbConfirmModifiedListNgRan(pub NonEmpty<DrbConfirmModifiedItemNgRan>);

impl DrbConfirmModifiedListNgRan {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(32), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(DrbConfirmModifiedItemNgRan::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(32), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for DrbConfirmModifiedListNgRan {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        DrbConfirmModifiedListNgRan::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DrbConfirmModifiedListNgRan");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DrbConfirmModifiedListNgRan");
            e
        })
    }
}
// DrbConfirmModifiedItemNgRan
#[derive(Clone, Debug)]
pub struct DrbConfirmModifiedItemNgRan {
    pub drb_id: DrbId,
    pub cell_group_information: Option<CellGroupInformation>,
}

impl DrbConfirmModifiedItemNgRan {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 2)?;
        let drb_id = DrbId::decode(data)?;
        let cell_group_information = if optionals[0] {
            Some(CellGroupInformation::decode(data)?)
        } else {
            None
        };

        // Process the extension container

        if optionals[1] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            drb_id,
            cell_group_information,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.cell_group_information.is_some());
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.drb_id.encode(data)?;
        if let Some(x) = &self.cell_group_information {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl PerCodec for DrbConfirmModifiedItemNgRan {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        DrbConfirmModifiedItemNgRan::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DrbConfirmModifiedItemNgRan");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DrbConfirmModifiedItemNgRan");
            e
        })
    }
}
// DrbFailedListEutran
#[derive(Clone, Debug)]
pub struct DrbFailedListEutran(pub NonEmpty<DrbFailedItemEutran>);

impl DrbFailedListEutran {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(32), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(DrbFailedItemEutran::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(32), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for DrbFailedListEutran {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        DrbFailedListEutran::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DrbFailedListEutran");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DrbFailedListEutran");
            e
        })
    }
}
// DrbFailedItemEutran
#[derive(Clone, Debug)]
pub struct DrbFailedItemEutran {
    pub drb_id: DrbId,
    pub cause: Cause,
}

impl DrbFailedItemEutran {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let drb_id = DrbId::decode(data)?;
        let cause = Cause::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self { drb_id, cause })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.drb_id.encode(data)?;
        self.cause.encode(data)?;

        Ok(())
    }
}

impl PerCodec for DrbFailedItemEutran {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        DrbFailedItemEutran::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DrbFailedItemEutran");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DrbFailedItemEutran");
            e
        })
    }
}
// DrbFailedModListEutran
#[derive(Clone, Debug)]
pub struct DrbFailedModListEutran(pub NonEmpty<DrbFailedModItemEutran>);

impl DrbFailedModListEutran {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(32), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(DrbFailedModItemEutran::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(32), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for DrbFailedModListEutran {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        DrbFailedModListEutran::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DrbFailedModListEutran");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DrbFailedModListEutran");
            e
        })
    }
}
// DrbFailedModItemEutran
#[derive(Clone, Debug)]
pub struct DrbFailedModItemEutran {
    pub drb_id: DrbId,
    pub cause: Cause,
}

impl DrbFailedModItemEutran {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let drb_id = DrbId::decode(data)?;
        let cause = Cause::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self { drb_id, cause })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.drb_id.encode(data)?;
        self.cause.encode(data)?;

        Ok(())
    }
}

impl PerCodec for DrbFailedModItemEutran {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        DrbFailedModItemEutran::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DrbFailedModItemEutran");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DrbFailedModItemEutran");
            e
        })
    }
}
// DrbFailedListNgRan
#[derive(Clone, Debug)]
pub struct DrbFailedListNgRan(pub NonEmpty<DrbFailedItemNgRan>);

impl DrbFailedListNgRan {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(32), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(DrbFailedItemNgRan::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(32), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for DrbFailedListNgRan {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        DrbFailedListNgRan::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DrbFailedListNgRan");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DrbFailedListNgRan");
            e
        })
    }
}
// DrbFailedItemNgRan
#[derive(Clone, Debug)]
pub struct DrbFailedItemNgRan {
    pub drb_id: DrbId,
    pub cause: Cause,
}

impl DrbFailedItemNgRan {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let drb_id = DrbId::decode(data)?;
        let cause = Cause::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self { drb_id, cause })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.drb_id.encode(data)?;
        self.cause.encode(data)?;

        Ok(())
    }
}

impl PerCodec for DrbFailedItemNgRan {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        DrbFailedItemNgRan::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DrbFailedItemNgRan");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DrbFailedItemNgRan");
            e
        })
    }
}
// DrbFailedModListNgRan
#[derive(Clone, Debug)]
pub struct DrbFailedModListNgRan(pub NonEmpty<DrbFailedModItemNgRan>);

impl DrbFailedModListNgRan {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(32), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(DrbFailedModItemNgRan::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(32), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for DrbFailedModListNgRan {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        DrbFailedModListNgRan::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DrbFailedModListNgRan");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DrbFailedModListNgRan");
            e
        })
    }
}
// DrbFailedModItemNgRan
#[derive(Clone, Debug)]
pub struct DrbFailedModItemNgRan {
    pub drb_id: DrbId,
    pub cause: Cause,
}

impl DrbFailedModItemNgRan {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let drb_id = DrbId::decode(data)?;
        let cause = Cause::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self { drb_id, cause })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.drb_id.encode(data)?;
        self.cause.encode(data)?;

        Ok(())
    }
}

impl PerCodec for DrbFailedModItemNgRan {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        DrbFailedModItemNgRan::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DrbFailedModItemNgRan");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DrbFailedModItemNgRan");
            e
        })
    }
}
// DrbFailedToModifyListEutran
#[derive(Clone, Debug)]
pub struct DrbFailedToModifyListEutran(pub NonEmpty<DrbFailedToModifyItemEutran>);

impl DrbFailedToModifyListEutran {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(32), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(DrbFailedToModifyItemEutran::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(32), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for DrbFailedToModifyListEutran {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        DrbFailedToModifyListEutran::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DrbFailedToModifyListEutran");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DrbFailedToModifyListEutran");
            e
        })
    }
}
// DrbFailedToModifyItemEutran
#[derive(Clone, Debug)]
pub struct DrbFailedToModifyItemEutran {
    pub drb_id: DrbId,
    pub cause: Cause,
}

impl DrbFailedToModifyItemEutran {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let drb_id = DrbId::decode(data)?;
        let cause = Cause::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self { drb_id, cause })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.drb_id.encode(data)?;
        self.cause.encode(data)?;

        Ok(())
    }
}

impl PerCodec for DrbFailedToModifyItemEutran {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        DrbFailedToModifyItemEutran::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DrbFailedToModifyItemEutran");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DrbFailedToModifyItemEutran");
            e
        })
    }
}
// DrbFailedToModifyListNgRan
#[derive(Clone, Debug)]
pub struct DrbFailedToModifyListNgRan(pub NonEmpty<DrbFailedToModifyItemNgRan>);

impl DrbFailedToModifyListNgRan {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(32), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(DrbFailedToModifyItemNgRan::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(32), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for DrbFailedToModifyListNgRan {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        DrbFailedToModifyListNgRan::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DrbFailedToModifyListNgRan");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DrbFailedToModifyListNgRan");
            e
        })
    }
}
// DrbFailedToModifyItemNgRan
#[derive(Clone, Debug)]
pub struct DrbFailedToModifyItemNgRan {
    pub drb_id: DrbId,
    pub cause: Cause,
}

impl DrbFailedToModifyItemNgRan {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let drb_id = DrbId::decode(data)?;
        let cause = Cause::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self { drb_id, cause })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.drb_id.encode(data)?;
        self.cause.encode(data)?;

        Ok(())
    }
}

impl PerCodec for DrbFailedToModifyItemNgRan {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        DrbFailedToModifyItemNgRan::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DrbFailedToModifyItemNgRan");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DrbFailedToModifyItemNgRan");
            e
        })
    }
}
// DrbId
#[derive(Clone, Copy, Debug)]
pub struct DrbId(pub u8);

impl DrbId {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(
            decode::decode_integer(data, Some(1), Some(32), true)?.0 as u8,
        ))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_integer(data, Some(1), Some(32), true, self.0 as i128, false)
    }
}

impl PerCodec for DrbId {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        DrbId::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DrbId");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DrbId");
            e
        })
    }
}
// DrbMeasurementResultsInformationList
#[derive(Clone, Debug)]
pub struct DrbMeasurementResultsInformationList(pub NonEmpty<DrbMeasurementResultsInformationItem>);

impl DrbMeasurementResultsInformationList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(32), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(DrbMeasurementResultsInformationItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(32), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for DrbMeasurementResultsInformationList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        DrbMeasurementResultsInformationList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DrbMeasurementResultsInformationList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DrbMeasurementResultsInformationList");
            e
        })
    }
}
// DrbMeasurementResultsInformationItem
#[derive(Clone, Debug)]
pub struct DrbMeasurementResultsInformationItem {
    pub drb_id: DrbId,
    pub ul_d1_result: Option<u16>,
}

impl DrbMeasurementResultsInformationItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 2)?;
        let drb_id = DrbId::decode(data)?;
        let ul_d1_result = if optionals[0] {
            Some(decode::decode_integer(data, Some(0), Some(10000), true)?.0 as u16)
        } else {
            None
        };

        // Process the extension container

        if optionals[1] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            drb_id,
            ul_d1_result,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.ul_d1_result.is_some());
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.drb_id.encode(data)?;
        if let Some(x) = &self.ul_d1_result {
            encode::encode_integer(data, Some(0), Some(10000), true, *x as i128, false)?;
        }

        Ok(())
    }
}

impl PerCodec for DrbMeasurementResultsInformationItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        DrbMeasurementResultsInformationItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DrbMeasurementResultsInformationItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DrbMeasurementResultsInformationItem");
            e
        })
    }
}
// DrbModifiedListEutran
#[derive(Clone, Debug)]
pub struct DrbModifiedListEutran(pub NonEmpty<DrbModifiedItemEutran>);

impl DrbModifiedListEutran {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(32), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(DrbModifiedItemEutran::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(32), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for DrbModifiedListEutran {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        DrbModifiedListEutran::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DrbModifiedListEutran");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DrbModifiedListEutran");
            e
        })
    }
}
// DrbModifiedItemEutran
#[derive(Clone, Debug)]
pub struct DrbModifiedItemEutran {
    pub drb_id: DrbId,
    pub s1_dl_up_tnl_information: Option<UpTnlInformation>,
    pub pdcp_sn_status_information: Option<PdcpSnStatusInformation>,
    pub ul_up_transport_parameters: Option<UpParameters>,
}

impl DrbModifiedItemEutran {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 4)?;
        let drb_id = DrbId::decode(data)?;
        let s1_dl_up_tnl_information = if optionals[0] {
            Some(UpTnlInformation::decode(data)?)
        } else {
            None
        };
        let pdcp_sn_status_information = if optionals[1] {
            Some(PdcpSnStatusInformation::decode(data)?)
        } else {
            None
        };
        let ul_up_transport_parameters = if optionals[2] {
            Some(UpParameters::decode(data)?)
        } else {
            None
        };

        // Process the extension container

        if optionals[3] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            drb_id,
            s1_dl_up_tnl_information,
            pdcp_sn_status_information,
            ul_up_transport_parameters,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.s1_dl_up_tnl_information.is_some());
        optionals.push(self.pdcp_sn_status_information.is_some());
        optionals.push(self.ul_up_transport_parameters.is_some());
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.drb_id.encode(data)?;
        if let Some(x) = &self.s1_dl_up_tnl_information {
            x.encode(data)?;
        }
        if let Some(x) = &self.pdcp_sn_status_information {
            x.encode(data)?;
        }
        if let Some(x) = &self.ul_up_transport_parameters {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl PerCodec for DrbModifiedItemEutran {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        DrbModifiedItemEutran::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DrbModifiedItemEutran");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DrbModifiedItemEutran");
            e
        })
    }
}
// DrbModifiedListNgRan
#[derive(Clone, Debug)]
pub struct DrbModifiedListNgRan(pub NonEmpty<DrbModifiedItemNgRan>);

impl DrbModifiedListNgRan {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(32), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(DrbModifiedItemNgRan::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(32), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for DrbModifiedListNgRan {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        DrbModifiedListNgRan::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DrbModifiedListNgRan");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DrbModifiedListNgRan");
            e
        })
    }
}
// DrbModifiedItemNgRan
#[derive(Clone, Debug)]
pub struct DrbModifiedItemNgRan {
    pub drb_id: DrbId,
    pub ul_up_transport_parameters: Option<UpParameters>,
    pub pdcp_sn_status_information: Option<PdcpSnStatusInformation>,
    pub flow_setup_list: Option<QosFlowList>,
    pub flow_failed_list: Option<QosFlowFailedList>,
    pub early_forwarding_count_info: Option<EarlyForwardingCountInfo>,
    pub old_qos_flow_map_ul_endmarkerexpected: Option<QosFlowList>,
}

impl DrbModifiedItemNgRan {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 5)?;
        let drb_id = DrbId::decode(data)?;
        let ul_up_transport_parameters = if optionals[0] {
            Some(UpParameters::decode(data)?)
        } else {
            None
        };
        let pdcp_sn_status_information = if optionals[1] {
            Some(PdcpSnStatusInformation::decode(data)?)
        } else {
            None
        };
        let flow_setup_list = if optionals[2] {
            Some(QosFlowList::decode(data)?)
        } else {
            None
        };
        let flow_failed_list = if optionals[3] {
            Some(QosFlowFailedList::decode(data)?)
        } else {
            None
        };

        // Process the extension container
        let mut early_forwarding_count_info: Option<EarlyForwardingCountInfo> = None;
        let mut old_qos_flow_map_ul_endmarkerexpected: Option<QosFlowList> = None;

        if optionals[4] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    123 => {
                        early_forwarding_count_info = Some(EarlyForwardingCountInfo::decode(data)?)
                    }
                    71 => old_qos_flow_map_ul_endmarkerexpected = Some(QosFlowList::decode(data)?),
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            drb_id,
            ul_up_transport_parameters,
            pdcp_sn_status_information,
            flow_setup_list,
            flow_failed_list,
            early_forwarding_count_info,
            old_qos_flow_map_ul_endmarkerexpected,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();
        if let Some(x) = &self.early_forwarding_count_info {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 123, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.old_qos_flow_map_ul_endmarkerexpected {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 71, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        let mut optionals = BitString::new();
        optionals.push(self.ul_up_transport_parameters.is_some());
        optionals.push(self.pdcp_sn_status_information.is_some());
        optionals.push(self.flow_setup_list.is_some());
        optionals.push(self.flow_failed_list.is_some());
        optionals.push(num_ies != 0);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.drb_id.encode(data)?;
        if let Some(x) = &self.ul_up_transport_parameters {
            x.encode(data)?;
        }
        if let Some(x) = &self.pdcp_sn_status_information {
            x.encode(data)?;
        }
        if let Some(x) = &self.flow_setup_list {
            x.encode(data)?;
        }
        if let Some(x) = &self.flow_failed_list {
            x.encode(data)?;
        }
        if num_ies != 0 {
            encode::encode_length_determinent(data, Some(1), Some(65535), false, num_ies)?;
            data.append_aligned(ies);
        }
        Ok(())
    }
}

impl PerCodec for DrbModifiedItemNgRan {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        DrbModifiedItemNgRan::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DrbModifiedItemNgRan");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DrbModifiedItemNgRan");
            e
        })
    }
}
// DrbRemovedItem
#[derive(Clone, Debug)]
pub struct DrbRemovedItem {
    pub drb_id: DrbId,
    pub drb_released_in_session: Option<DrbReleasedInSession>,
    pub drb_accumulated_session_time: Option<[u8; 5]>,
    pub qos_flow_removed_list: Option<NonEmpty<QosFlowRemovedItem>>,
}

impl DrbRemovedItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 4)?;
        let drb_id = DrbId::decode(data)?;
        let drb_released_in_session = if optionals[0] {
            Some(DrbReleasedInSession::decode(data)?)
        } else {
            None
        };
        let drb_accumulated_session_time = if optionals[1] {
            Some(
                decode::decode_octetstring(data, Some(5), Some(5), false)?
                    .try_into()
                    .unwrap(),
            )
        } else {
            None
        };
        let qos_flow_removed_list = if optionals[2] {
            Some({
                let length = decode::decode_length_determinent(data, Some(1), Some(64), false)?;
                let mut items = vec![];
                for _ in 0..length {
                    items.push(QosFlowRemovedItem::decode(data)?);
                }
                NonEmpty::from_vec(items).unwrap()
            })
        } else {
            None
        };

        // Process the extension container

        if optionals[3] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            drb_id,
            drb_released_in_session,
            drb_accumulated_session_time,
            qos_flow_removed_list,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.drb_released_in_session.is_some());
        optionals.push(self.drb_accumulated_session_time.is_some());
        optionals.push(self.qos_flow_removed_list.is_some());
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.drb_id.encode(data)?;
        if let Some(x) = &self.drb_released_in_session {
            x.encode(data)?;
        }
        if let Some(x) = &self.drb_accumulated_session_time {
            encode::encode_octetstring(data, Some(5), Some(5), false, &(*x).into(), false)?;
        }
        if let Some(x) = &self.qos_flow_removed_list {
            encode::encode_length_determinent(data, Some(1), Some(64), false, x.len())?;
            for x in *&x {
                x.encode(data)?;
            }
            Ok(())?;
        }

        Ok(())
    }
}

impl PerCodec for DrbRemovedItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        DrbRemovedItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DrbRemovedItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DrbRemovedItem");
            e
        })
    }
}
// DrbRequiredToModifyListEutran
#[derive(Clone, Debug)]
pub struct DrbRequiredToModifyListEutran(pub NonEmpty<DrbRequiredToModifyItemEutran>);

impl DrbRequiredToModifyListEutran {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(32), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(DrbRequiredToModifyItemEutran::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(32), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for DrbRequiredToModifyListEutran {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        DrbRequiredToModifyListEutran::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DrbRequiredToModifyListEutran");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DrbRequiredToModifyListEutran");
            e
        })
    }
}
// DrbRequiredToModifyItemEutran
#[derive(Clone, Debug)]
pub struct DrbRequiredToModifyItemEutran {
    pub drb_id: DrbId,
    pub s1_dl_up_tnl_information: Option<UpTnlInformation>,
    pub gnb_cu_up_cell_group_related_configuration: Option<GnbCuUpCellGroupRelatedConfiguration>,
    pub cause: Option<Cause>,
}

impl DrbRequiredToModifyItemEutran {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 4)?;
        let drb_id = DrbId::decode(data)?;
        let s1_dl_up_tnl_information = if optionals[0] {
            Some(UpTnlInformation::decode(data)?)
        } else {
            None
        };
        let gnb_cu_up_cell_group_related_configuration = if optionals[1] {
            Some(GnbCuUpCellGroupRelatedConfiguration::decode(data)?)
        } else {
            None
        };
        let cause = if optionals[2] {
            Some(Cause::decode(data)?)
        } else {
            None
        };

        // Process the extension container

        if optionals[3] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            drb_id,
            s1_dl_up_tnl_information,
            gnb_cu_up_cell_group_related_configuration,
            cause,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.s1_dl_up_tnl_information.is_some());
        optionals.push(self.gnb_cu_up_cell_group_related_configuration.is_some());
        optionals.push(self.cause.is_some());
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.drb_id.encode(data)?;
        if let Some(x) = &self.s1_dl_up_tnl_information {
            x.encode(data)?;
        }
        if let Some(x) = &self.gnb_cu_up_cell_group_related_configuration {
            x.encode(data)?;
        }
        if let Some(x) = &self.cause {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl PerCodec for DrbRequiredToModifyItemEutran {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        DrbRequiredToModifyItemEutran::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DrbRequiredToModifyItemEutran");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DrbRequiredToModifyItemEutran");
            e
        })
    }
}
// DrbRequiredToModifyListNgRan
#[derive(Clone, Debug)]
pub struct DrbRequiredToModifyListNgRan(pub NonEmpty<DrbRequiredToModifyItemNgRan>);

impl DrbRequiredToModifyListNgRan {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(32), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(DrbRequiredToModifyItemNgRan::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(32), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for DrbRequiredToModifyListNgRan {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        DrbRequiredToModifyListNgRan::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DrbRequiredToModifyListNgRan");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DrbRequiredToModifyListNgRan");
            e
        })
    }
}
// DrbRequiredToModifyItemNgRan
#[derive(Clone, Debug)]
pub struct DrbRequiredToModifyItemNgRan {
    pub drb_id: DrbId,
    pub gnb_cu_up_cell_group_related_configuration: Option<GnbCuUpCellGroupRelatedConfiguration>,
    pub flow_to_remove: Option<QosFlowList>,
    pub cause: Option<Cause>,
}

impl DrbRequiredToModifyItemNgRan {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 4)?;
        let drb_id = DrbId::decode(data)?;
        let gnb_cu_up_cell_group_related_configuration = if optionals[0] {
            Some(GnbCuUpCellGroupRelatedConfiguration::decode(data)?)
        } else {
            None
        };
        let flow_to_remove = if optionals[1] {
            Some(QosFlowList::decode(data)?)
        } else {
            None
        };
        let cause = if optionals[2] {
            Some(Cause::decode(data)?)
        } else {
            None
        };

        // Process the extension container

        if optionals[3] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            drb_id,
            gnb_cu_up_cell_group_related_configuration,
            flow_to_remove,
            cause,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.gnb_cu_up_cell_group_related_configuration.is_some());
        optionals.push(self.flow_to_remove.is_some());
        optionals.push(self.cause.is_some());
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.drb_id.encode(data)?;
        if let Some(x) = &self.gnb_cu_up_cell_group_related_configuration {
            x.encode(data)?;
        }
        if let Some(x) = &self.flow_to_remove {
            x.encode(data)?;
        }
        if let Some(x) = &self.cause {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl PerCodec for DrbRequiredToModifyItemNgRan {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        DrbRequiredToModifyItemNgRan::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DrbRequiredToModifyItemNgRan");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DrbRequiredToModifyItemNgRan");
            e
        })
    }
}
// DrbSetupListEutran
#[derive(Clone, Debug)]
pub struct DrbSetupListEutran(pub NonEmpty<DrbSetupItemEutran>);

impl DrbSetupListEutran {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(32), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(DrbSetupItemEutran::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(32), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for DrbSetupListEutran {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        DrbSetupListEutran::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DrbSetupListEutran");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DrbSetupListEutran");
            e
        })
    }
}
// DrbSetupItemEutran
#[derive(Clone, Debug)]
pub struct DrbSetupItemEutran {
    pub drb_id: DrbId,
    pub s1_dl_up_tnl_information: UpTnlInformation,
    pub data_forwarding_information_response: Option<DataForwardingInformation>,
    pub ul_up_transport_parameters: UpParameters,
    pub s1_dl_up_unchanged: Option<S1DlUpUnchanged>,
}

impl DrbSetupItemEutran {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 3)?;
        let drb_id = DrbId::decode(data)?;
        let s1_dl_up_tnl_information = UpTnlInformation::decode(data)?;
        let data_forwarding_information_response = if optionals[0] {
            Some(DataForwardingInformation::decode(data)?)
        } else {
            None
        };
        let ul_up_transport_parameters = UpParameters::decode(data)?;
        let s1_dl_up_unchanged = if optionals[1] {
            Some(S1DlUpUnchanged::decode(data)?)
        } else {
            None
        };

        // Process the extension container

        if optionals[2] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            drb_id,
            s1_dl_up_tnl_information,
            data_forwarding_information_response,
            ul_up_transport_parameters,
            s1_dl_up_unchanged,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.data_forwarding_information_response.is_some());
        optionals.push(self.s1_dl_up_unchanged.is_some());
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.drb_id.encode(data)?;
        self.s1_dl_up_tnl_information.encode(data)?;
        if let Some(x) = &self.data_forwarding_information_response {
            x.encode(data)?;
        }
        self.ul_up_transport_parameters.encode(data)?;
        if let Some(x) = &self.s1_dl_up_unchanged {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl PerCodec for DrbSetupItemEutran {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        DrbSetupItemEutran::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DrbSetupItemEutran");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DrbSetupItemEutran");
            e
        })
    }
}
// DrbSetupModListEutran
#[derive(Clone, Debug)]
pub struct DrbSetupModListEutran(pub NonEmpty<DrbSetupModItemEutran>);

impl DrbSetupModListEutran {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(32), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(DrbSetupModItemEutran::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(32), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for DrbSetupModListEutran {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        DrbSetupModListEutran::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DrbSetupModListEutran");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DrbSetupModListEutran");
            e
        })
    }
}
// DrbSetupModItemEutran
#[derive(Clone, Debug)]
pub struct DrbSetupModItemEutran {
    pub drb_id: DrbId,
    pub s1_dl_up_tnl_information: UpTnlInformation,
    pub data_forwarding_information_response: Option<DataForwardingInformation>,
    pub ul_up_transport_parameters: UpParameters,
}

impl DrbSetupModItemEutran {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 2)?;
        let drb_id = DrbId::decode(data)?;
        let s1_dl_up_tnl_information = UpTnlInformation::decode(data)?;
        let data_forwarding_information_response = if optionals[0] {
            Some(DataForwardingInformation::decode(data)?)
        } else {
            None
        };
        let ul_up_transport_parameters = UpParameters::decode(data)?;

        // Process the extension container

        if optionals[1] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            drb_id,
            s1_dl_up_tnl_information,
            data_forwarding_information_response,
            ul_up_transport_parameters,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.data_forwarding_information_response.is_some());
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.drb_id.encode(data)?;
        self.s1_dl_up_tnl_information.encode(data)?;
        if let Some(x) = &self.data_forwarding_information_response {
            x.encode(data)?;
        }
        self.ul_up_transport_parameters.encode(data)?;

        Ok(())
    }
}

impl PerCodec for DrbSetupModItemEutran {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        DrbSetupModItemEutran::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DrbSetupModItemEutran");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DrbSetupModItemEutran");
            e
        })
    }
}
// DrbSetupListNgRan
#[derive(Clone, Debug)]
pub struct DrbSetupListNgRan(pub NonEmpty<DrbSetupItemNgRan>);

impl DrbSetupListNgRan {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(32), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(DrbSetupItemNgRan::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(32), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for DrbSetupListNgRan {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        DrbSetupListNgRan::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DrbSetupListNgRan");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DrbSetupListNgRan");
            e
        })
    }
}
// DrbSetupItemNgRan
#[derive(Clone, Debug)]
pub struct DrbSetupItemNgRan {
    pub drb_id: DrbId,
    pub drb_data_forwarding_information_response: Option<DataForwardingInformation>,
    pub ul_up_transport_parameters: UpParameters,
    pub flow_setup_list: QosFlowList,
    pub flow_failed_list: Option<QosFlowFailedList>,
}

impl DrbSetupItemNgRan {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 3)?;
        let drb_id = DrbId::decode(data)?;
        let drb_data_forwarding_information_response = if optionals[0] {
            Some(DataForwardingInformation::decode(data)?)
        } else {
            None
        };
        let ul_up_transport_parameters = UpParameters::decode(data)?;
        let flow_setup_list = QosFlowList::decode(data)?;
        let flow_failed_list = if optionals[1] {
            Some(QosFlowFailedList::decode(data)?)
        } else {
            None
        };

        // Process the extension container

        if optionals[2] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            drb_id,
            drb_data_forwarding_information_response,
            ul_up_transport_parameters,
            flow_setup_list,
            flow_failed_list,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.drb_data_forwarding_information_response.is_some());
        optionals.push(self.flow_failed_list.is_some());
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.drb_id.encode(data)?;
        if let Some(x) = &self.drb_data_forwarding_information_response {
            x.encode(data)?;
        }
        self.ul_up_transport_parameters.encode(data)?;
        self.flow_setup_list.encode(data)?;
        if let Some(x) = &self.flow_failed_list {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl PerCodec for DrbSetupItemNgRan {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        DrbSetupItemNgRan::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DrbSetupItemNgRan");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DrbSetupItemNgRan");
            e
        })
    }
}
// DrbSetupModListNgRan
#[derive(Clone, Debug)]
pub struct DrbSetupModListNgRan(pub NonEmpty<DrbSetupModItemNgRan>);

impl DrbSetupModListNgRan {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(32), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(DrbSetupModItemNgRan::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(32), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for DrbSetupModListNgRan {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        DrbSetupModListNgRan::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DrbSetupModListNgRan");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DrbSetupModListNgRan");
            e
        })
    }
}
// DrbSetupModItemNgRan
#[derive(Clone, Debug)]
pub struct DrbSetupModItemNgRan {
    pub drb_id: DrbId,
    pub drb_data_forwarding_information_response: Option<DataForwardingInformation>,
    pub ul_up_transport_parameters: UpParameters,
    pub flow_setup_list: QosFlowList,
    pub flow_failed_list: Option<QosFlowFailedList>,
}

impl DrbSetupModItemNgRan {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 3)?;
        let drb_id = DrbId::decode(data)?;
        let drb_data_forwarding_information_response = if optionals[0] {
            Some(DataForwardingInformation::decode(data)?)
        } else {
            None
        };
        let ul_up_transport_parameters = UpParameters::decode(data)?;
        let flow_setup_list = QosFlowList::decode(data)?;
        let flow_failed_list = if optionals[1] {
            Some(QosFlowFailedList::decode(data)?)
        } else {
            None
        };

        // Process the extension container

        if optionals[2] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            drb_id,
            drb_data_forwarding_information_response,
            ul_up_transport_parameters,
            flow_setup_list,
            flow_failed_list,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.drb_data_forwarding_information_response.is_some());
        optionals.push(self.flow_failed_list.is_some());
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.drb_id.encode(data)?;
        if let Some(x) = &self.drb_data_forwarding_information_response {
            x.encode(data)?;
        }
        self.ul_up_transport_parameters.encode(data)?;
        self.flow_setup_list.encode(data)?;
        if let Some(x) = &self.flow_failed_list {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl PerCodec for DrbSetupModItemNgRan {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        DrbSetupModItemNgRan::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DrbSetupModItemNgRan");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DrbSetupModItemNgRan");
            e
        })
    }
}
// DrbStatusItem
#[derive(Clone, Debug)]
pub struct DrbStatusItem {
    pub drb_id: DrbId,
    pub pdcp_dl_count: Option<PdcpCount>,
    pub pdcp_ul_count: Option<PdcpCount>,
}

impl DrbStatusItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 3)?;
        let drb_id = DrbId::decode(data)?;
        let pdcp_dl_count = if optionals[0] {
            Some(PdcpCount::decode(data)?)
        } else {
            None
        };
        let pdcp_ul_count = if optionals[1] {
            Some(PdcpCount::decode(data)?)
        } else {
            None
        };

        // Process the extension container

        if optionals[2] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            drb_id,
            pdcp_dl_count,
            pdcp_ul_count,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.pdcp_dl_count.is_some());
        optionals.push(self.pdcp_ul_count.is_some());
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.drb_id.encode(data)?;
        if let Some(x) = &self.pdcp_dl_count {
            x.encode(data)?;
        }
        if let Some(x) = &self.pdcp_ul_count {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl PerCodec for DrbStatusItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        DrbStatusItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DrbStatusItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DrbStatusItem");
            e
        })
    }
}
// DrbsSubjectToCounterCheckListEutran
#[derive(Clone, Debug)]
pub struct DrbsSubjectToCounterCheckListEutran(pub NonEmpty<DrbsSubjectToCounterCheckItemEutran>);

impl DrbsSubjectToCounterCheckListEutran {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(32), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(DrbsSubjectToCounterCheckItemEutran::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(32), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for DrbsSubjectToCounterCheckListEutran {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        DrbsSubjectToCounterCheckListEutran::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DrbsSubjectToCounterCheckListEutran");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DrbsSubjectToCounterCheckListEutran");
            e
        })
    }
}
// DrbsSubjectToCounterCheckItemEutran
#[derive(Clone, Debug)]
pub struct DrbsSubjectToCounterCheckItemEutran {
    pub drb_id: DrbId,
    pub pdcp_ul_count: PdcpCount,
    pub pdcp_dl_count: PdcpCount,
}

impl DrbsSubjectToCounterCheckItemEutran {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let drb_id = DrbId::decode(data)?;
        let pdcp_ul_count = PdcpCount::decode(data)?;
        let pdcp_dl_count = PdcpCount::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            drb_id,
            pdcp_ul_count,
            pdcp_dl_count,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.drb_id.encode(data)?;
        self.pdcp_ul_count.encode(data)?;
        self.pdcp_dl_count.encode(data)?;

        Ok(())
    }
}

impl PerCodec for DrbsSubjectToCounterCheckItemEutran {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        DrbsSubjectToCounterCheckItemEutran::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DrbsSubjectToCounterCheckItemEutran");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DrbsSubjectToCounterCheckItemEutran");
            e
        })
    }
}
// DrbsSubjectToCounterCheckListNgRan
#[derive(Clone, Debug)]
pub struct DrbsSubjectToCounterCheckListNgRan(pub NonEmpty<DrbsSubjectToCounterCheckItemNgRan>);

impl DrbsSubjectToCounterCheckListNgRan {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(32), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(DrbsSubjectToCounterCheckItemNgRan::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(32), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for DrbsSubjectToCounterCheckListNgRan {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        DrbsSubjectToCounterCheckListNgRan::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DrbsSubjectToCounterCheckListNgRan");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DrbsSubjectToCounterCheckListNgRan");
            e
        })
    }
}
// DrbsSubjectToCounterCheckItemNgRan
#[derive(Clone, Debug)]
pub struct DrbsSubjectToCounterCheckItemNgRan {
    pub pdu_session_id: PduSessionId,
    pub drb_id: DrbId,
    pub pdcp_ul_count: PdcpCount,
    pub pdcp_dl_count: PdcpCount,
}

impl DrbsSubjectToCounterCheckItemNgRan {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let pdu_session_id = PduSessionId::decode(data)?;
        let drb_id = DrbId::decode(data)?;
        let pdcp_ul_count = PdcpCount::decode(data)?;
        let pdcp_dl_count = PdcpCount::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            pdu_session_id,
            drb_id,
            pdcp_ul_count,
            pdcp_dl_count,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.pdu_session_id.encode(data)?;
        self.drb_id.encode(data)?;
        self.pdcp_ul_count.encode(data)?;
        self.pdcp_dl_count.encode(data)?;

        Ok(())
    }
}

impl PerCodec for DrbsSubjectToCounterCheckItemNgRan {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        DrbsSubjectToCounterCheckItemNgRan::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DrbsSubjectToCounterCheckItemNgRan");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DrbsSubjectToCounterCheckItemNgRan");
            e
        })
    }
}
// DrbsSubjectToEarlyForwardingList
#[derive(Clone, Debug)]
pub struct DrbsSubjectToEarlyForwardingList(pub NonEmpty<DrbsSubjectToEarlyForwardingItem>);

impl DrbsSubjectToEarlyForwardingList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(32), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(DrbsSubjectToEarlyForwardingItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(32), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for DrbsSubjectToEarlyForwardingList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        DrbsSubjectToEarlyForwardingList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DrbsSubjectToEarlyForwardingList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DrbsSubjectToEarlyForwardingList");
            e
        })
    }
}
// DrbsSubjectToEarlyForwardingItem
#[derive(Clone, Debug)]
pub struct DrbsSubjectToEarlyForwardingItem {
    pub drb_id: DrbId,
    pub dl_count_value: PdcpCount,
}

impl DrbsSubjectToEarlyForwardingItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let drb_id = DrbId::decode(data)?;
        let dl_count_value = PdcpCount::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            drb_id,
            dl_count_value,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.drb_id.encode(data)?;
        self.dl_count_value.encode(data)?;

        Ok(())
    }
}

impl PerCodec for DrbsSubjectToEarlyForwardingItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        DrbsSubjectToEarlyForwardingItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DrbsSubjectToEarlyForwardingItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DrbsSubjectToEarlyForwardingItem");
            e
        })
    }
}
// DrbToModifyListEutran
#[derive(Clone, Debug)]
pub struct DrbToModifyListEutran(pub NonEmpty<DrbToModifyItemEutran>);

impl DrbToModifyListEutran {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(32), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(DrbToModifyItemEutran::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(32), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for DrbToModifyListEutran {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        DrbToModifyListEutran::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DrbToModifyListEutran");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DrbToModifyListEutran");
            e
        })
    }
}
// DrbToModifyItemEutran
#[derive(Clone, Debug)]
pub struct DrbToModifyItemEutran {
    pub drb_id: DrbId,
    pub pdcp_configuration: Option<PdcpConfiguration>,
    pub eutran_qos: Option<EutranQos>,
    pub s1_ul_up_tnl_information: Option<UpTnlInformation>,
    pub data_forwarding_information: Option<DataForwardingInformation>,
    pub pdcp_sn_status_request: Option<PdcpSnStatusRequest>,
    pub pdcp_sn_status_information: Option<PdcpSnStatusInformation>,
    pub dl_up_parameters: Option<UpParameters>,
    pub cell_group_to_add: Option<CellGroupInformation>,
    pub cell_group_to_modify: Option<CellGroupInformation>,
    pub cell_group_to_remove: Option<CellGroupInformation>,
    pub drb_inactivity_timer: Option<InactivityTimer>,
}

impl DrbToModifyItemEutran {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 12)?;
        let drb_id = DrbId::decode(data)?;
        let pdcp_configuration = if optionals[0] {
            Some(PdcpConfiguration::decode(data)?)
        } else {
            None
        };
        let eutran_qos = if optionals[1] {
            Some(EutranQos::decode(data)?)
        } else {
            None
        };
        let s1_ul_up_tnl_information = if optionals[2] {
            Some(UpTnlInformation::decode(data)?)
        } else {
            None
        };
        let data_forwarding_information = if optionals[3] {
            Some(DataForwardingInformation::decode(data)?)
        } else {
            None
        };
        let pdcp_sn_status_request = if optionals[4] {
            Some(PdcpSnStatusRequest::decode(data)?)
        } else {
            None
        };
        let pdcp_sn_status_information = if optionals[5] {
            Some(PdcpSnStatusInformation::decode(data)?)
        } else {
            None
        };
        let dl_up_parameters = if optionals[6] {
            Some(UpParameters::decode(data)?)
        } else {
            None
        };
        let cell_group_to_add = if optionals[7] {
            Some(CellGroupInformation::decode(data)?)
        } else {
            None
        };
        let cell_group_to_modify = if optionals[8] {
            Some(CellGroupInformation::decode(data)?)
        } else {
            None
        };
        let cell_group_to_remove = if optionals[9] {
            Some(CellGroupInformation::decode(data)?)
        } else {
            None
        };
        let drb_inactivity_timer = if optionals[10] {
            Some(InactivityTimer::decode(data)?)
        } else {
            None
        };

        // Process the extension container

        if optionals[11] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            drb_id,
            pdcp_configuration,
            eutran_qos,
            s1_ul_up_tnl_information,
            data_forwarding_information,
            pdcp_sn_status_request,
            pdcp_sn_status_information,
            dl_up_parameters,
            cell_group_to_add,
            cell_group_to_modify,
            cell_group_to_remove,
            drb_inactivity_timer,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.pdcp_configuration.is_some());
        optionals.push(self.eutran_qos.is_some());
        optionals.push(self.s1_ul_up_tnl_information.is_some());
        optionals.push(self.data_forwarding_information.is_some());
        optionals.push(self.pdcp_sn_status_request.is_some());
        optionals.push(self.pdcp_sn_status_information.is_some());
        optionals.push(self.dl_up_parameters.is_some());
        optionals.push(self.cell_group_to_add.is_some());
        optionals.push(self.cell_group_to_modify.is_some());
        optionals.push(self.cell_group_to_remove.is_some());
        optionals.push(self.drb_inactivity_timer.is_some());
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.drb_id.encode(data)?;
        if let Some(x) = &self.pdcp_configuration {
            x.encode(data)?;
        }
        if let Some(x) = &self.eutran_qos {
            x.encode(data)?;
        }
        if let Some(x) = &self.s1_ul_up_tnl_information {
            x.encode(data)?;
        }
        if let Some(x) = &self.data_forwarding_information {
            x.encode(data)?;
        }
        if let Some(x) = &self.pdcp_sn_status_request {
            x.encode(data)?;
        }
        if let Some(x) = &self.pdcp_sn_status_information {
            x.encode(data)?;
        }
        if let Some(x) = &self.dl_up_parameters {
            x.encode(data)?;
        }
        if let Some(x) = &self.cell_group_to_add {
            x.encode(data)?;
        }
        if let Some(x) = &self.cell_group_to_modify {
            x.encode(data)?;
        }
        if let Some(x) = &self.cell_group_to_remove {
            x.encode(data)?;
        }
        if let Some(x) = &self.drb_inactivity_timer {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl PerCodec for DrbToModifyItemEutran {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        DrbToModifyItemEutran::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DrbToModifyItemEutran");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DrbToModifyItemEutran");
            e
        })
    }
}
// DrbToModifyListNgRan
#[derive(Clone, Debug)]
pub struct DrbToModifyListNgRan(pub NonEmpty<DrbToModifyItemNgRan>);

impl DrbToModifyListNgRan {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(32), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(DrbToModifyItemNgRan::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(32), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for DrbToModifyListNgRan {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        DrbToModifyListNgRan::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DrbToModifyListNgRan");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DrbToModifyListNgRan");
            e
        })
    }
}
// DrbToModifyItemNgRan
#[derive(Clone, Debug)]
pub struct DrbToModifyItemNgRan {
    pub drb_id: DrbId,
    pub sdap_configuration: Option<SdapConfiguration>,
    pub pdcp_configuration: Option<PdcpConfiguration>,
    pub drb_data_forwarding_information: Option<DataForwardingInformation>,
    pub pdcp_sn_status_request: Option<PdcpSnStatusRequest>,
    pub pdcp_sn_status_information: Option<PdcpSnStatusInformation>,
    pub dl_up_parameters: Option<UpParameters>,
    pub cell_group_to_add: Option<CellGroupInformation>,
    pub cell_group_to_modify: Option<CellGroupInformation>,
    pub cell_group_to_remove: Option<CellGroupInformation>,
    pub flow_mapping_information: Option<QosFlowQosParameterList>,
    pub drb_inactivity_timer: Option<InactivityTimer>,
    pub old_qos_flow_map_ul_endmarkerexpected: Option<QosFlowList>,
    pub drb_qos: Option<QosFlowLevelQosParameters>,
    pub early_forwarding_count_req: Option<EarlyForwardingCountReq>,
    pub early_forwarding_count_info: Option<EarlyForwardingCountInfo>,
}

impl DrbToModifyItemNgRan {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 12)?;
        let drb_id = DrbId::decode(data)?;
        let sdap_configuration = if optionals[0] {
            Some(SdapConfiguration::decode(data)?)
        } else {
            None
        };
        let pdcp_configuration = if optionals[1] {
            Some(PdcpConfiguration::decode(data)?)
        } else {
            None
        };
        let drb_data_forwarding_information = if optionals[2] {
            Some(DataForwardingInformation::decode(data)?)
        } else {
            None
        };
        let pdcp_sn_status_request = if optionals[3] {
            Some(PdcpSnStatusRequest::decode(data)?)
        } else {
            None
        };
        let pdcp_sn_status_information = if optionals[4] {
            Some(PdcpSnStatusInformation::decode(data)?)
        } else {
            None
        };
        let dl_up_parameters = if optionals[5] {
            Some(UpParameters::decode(data)?)
        } else {
            None
        };
        let cell_group_to_add = if optionals[6] {
            Some(CellGroupInformation::decode(data)?)
        } else {
            None
        };
        let cell_group_to_modify = if optionals[7] {
            Some(CellGroupInformation::decode(data)?)
        } else {
            None
        };
        let cell_group_to_remove = if optionals[8] {
            Some(CellGroupInformation::decode(data)?)
        } else {
            None
        };
        let flow_mapping_information = if optionals[9] {
            Some(QosFlowQosParameterList::decode(data)?)
        } else {
            None
        };
        let drb_inactivity_timer = if optionals[10] {
            Some(InactivityTimer::decode(data)?)
        } else {
            None
        };

        // Process the extension container
        let mut old_qos_flow_map_ul_endmarkerexpected: Option<QosFlowList> = None;
        let mut drb_qos: Option<QosFlowLevelQosParameters> = None;
        let mut early_forwarding_count_req: Option<EarlyForwardingCountReq> = None;
        let mut early_forwarding_count_info: Option<EarlyForwardingCountInfo> = None;

        if optionals[11] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    71 => old_qos_flow_map_ul_endmarkerexpected = Some(QosFlowList::decode(data)?),
                    72 => drb_qos = Some(QosFlowLevelQosParameters::decode(data)?),
                    122 => {
                        early_forwarding_count_req = Some(EarlyForwardingCountReq::decode(data)?)
                    }
                    123 => {
                        early_forwarding_count_info = Some(EarlyForwardingCountInfo::decode(data)?)
                    }
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            drb_id,
            sdap_configuration,
            pdcp_configuration,
            drb_data_forwarding_information,
            pdcp_sn_status_request,
            pdcp_sn_status_information,
            dl_up_parameters,
            cell_group_to_add,
            cell_group_to_modify,
            cell_group_to_remove,
            flow_mapping_information,
            drb_inactivity_timer,
            old_qos_flow_map_ul_endmarkerexpected,
            drb_qos,
            early_forwarding_count_req,
            early_forwarding_count_info,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();
        if let Some(x) = &self.old_qos_flow_map_ul_endmarkerexpected {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 71, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.drb_qos {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 72, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.early_forwarding_count_req {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 122, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.early_forwarding_count_info {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 123, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        let mut optionals = BitString::new();
        optionals.push(self.sdap_configuration.is_some());
        optionals.push(self.pdcp_configuration.is_some());
        optionals.push(self.drb_data_forwarding_information.is_some());
        optionals.push(self.pdcp_sn_status_request.is_some());
        optionals.push(self.pdcp_sn_status_information.is_some());
        optionals.push(self.dl_up_parameters.is_some());
        optionals.push(self.cell_group_to_add.is_some());
        optionals.push(self.cell_group_to_modify.is_some());
        optionals.push(self.cell_group_to_remove.is_some());
        optionals.push(self.flow_mapping_information.is_some());
        optionals.push(self.drb_inactivity_timer.is_some());
        optionals.push(num_ies != 0);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.drb_id.encode(data)?;
        if let Some(x) = &self.sdap_configuration {
            x.encode(data)?;
        }
        if let Some(x) = &self.pdcp_configuration {
            x.encode(data)?;
        }
        if let Some(x) = &self.drb_data_forwarding_information {
            x.encode(data)?;
        }
        if let Some(x) = &self.pdcp_sn_status_request {
            x.encode(data)?;
        }
        if let Some(x) = &self.pdcp_sn_status_information {
            x.encode(data)?;
        }
        if let Some(x) = &self.dl_up_parameters {
            x.encode(data)?;
        }
        if let Some(x) = &self.cell_group_to_add {
            x.encode(data)?;
        }
        if let Some(x) = &self.cell_group_to_modify {
            x.encode(data)?;
        }
        if let Some(x) = &self.cell_group_to_remove {
            x.encode(data)?;
        }
        if let Some(x) = &self.flow_mapping_information {
            x.encode(data)?;
        }
        if let Some(x) = &self.drb_inactivity_timer {
            x.encode(data)?;
        }
        if num_ies != 0 {
            encode::encode_length_determinent(data, Some(1), Some(65535), false, num_ies)?;
            data.append_aligned(ies);
        }
        Ok(())
    }
}

impl PerCodec for DrbToModifyItemNgRan {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        DrbToModifyItemNgRan::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DrbToModifyItemNgRan");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DrbToModifyItemNgRan");
            e
        })
    }
}
// DrbToRemoveListEutran
#[derive(Clone, Debug)]
pub struct DrbToRemoveListEutran(pub NonEmpty<DrbToRemoveItemEutran>);

impl DrbToRemoveListEutran {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(32), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(DrbToRemoveItemEutran::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(32), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for DrbToRemoveListEutran {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        DrbToRemoveListEutran::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DrbToRemoveListEutran");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DrbToRemoveListEutran");
            e
        })
    }
}
// DrbToRemoveItemEutran
#[derive(Clone, Debug)]
pub struct DrbToRemoveItemEutran {
    pub drb_id: DrbId,
}

impl DrbToRemoveItemEutran {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let drb_id = DrbId::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self { drb_id })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.drb_id.encode(data)?;

        Ok(())
    }
}

impl PerCodec for DrbToRemoveItemEutran {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        DrbToRemoveItemEutran::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DrbToRemoveItemEutran");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DrbToRemoveItemEutran");
            e
        })
    }
}
// DrbRequiredToRemoveListEutran
#[derive(Clone, Debug)]
pub struct DrbRequiredToRemoveListEutran(pub NonEmpty<DrbRequiredToRemoveItemEutran>);

impl DrbRequiredToRemoveListEutran {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(32), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(DrbRequiredToRemoveItemEutran::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(32), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for DrbRequiredToRemoveListEutran {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        DrbRequiredToRemoveListEutran::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DrbRequiredToRemoveListEutran");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DrbRequiredToRemoveListEutran");
            e
        })
    }
}
// DrbRequiredToRemoveItemEutran
#[derive(Clone, Debug)]
pub struct DrbRequiredToRemoveItemEutran {
    pub drb_id: DrbId,
    pub cause: Cause,
}

impl DrbRequiredToRemoveItemEutran {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let drb_id = DrbId::decode(data)?;
        let cause = Cause::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self { drb_id, cause })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.drb_id.encode(data)?;
        self.cause.encode(data)?;

        Ok(())
    }
}

impl PerCodec for DrbRequiredToRemoveItemEutran {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        DrbRequiredToRemoveItemEutran::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DrbRequiredToRemoveItemEutran");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DrbRequiredToRemoveItemEutran");
            e
        })
    }
}
// DrbToRemoveListNgRan
#[derive(Clone, Debug)]
pub struct DrbToRemoveListNgRan(pub NonEmpty<DrbToRemoveItemNgRan>);

impl DrbToRemoveListNgRan {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(32), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(DrbToRemoveItemNgRan::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(32), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for DrbToRemoveListNgRan {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        DrbToRemoveListNgRan::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DrbToRemoveListNgRan");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DrbToRemoveListNgRan");
            e
        })
    }
}
// DrbToRemoveItemNgRan
#[derive(Clone, Debug)]
pub struct DrbToRemoveItemNgRan {
    pub drb_id: DrbId,
}

impl DrbToRemoveItemNgRan {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let drb_id = DrbId::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self { drb_id })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.drb_id.encode(data)?;

        Ok(())
    }
}

impl PerCodec for DrbToRemoveItemNgRan {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        DrbToRemoveItemNgRan::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DrbToRemoveItemNgRan");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DrbToRemoveItemNgRan");
            e
        })
    }
}
// DrbRequiredToRemoveListNgRan
#[derive(Clone, Debug)]
pub struct DrbRequiredToRemoveListNgRan(pub NonEmpty<DrbRequiredToRemoveItemNgRan>);

impl DrbRequiredToRemoveListNgRan {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(32), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(DrbRequiredToRemoveItemNgRan::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(32), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for DrbRequiredToRemoveListNgRan {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        DrbRequiredToRemoveListNgRan::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DrbRequiredToRemoveListNgRan");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DrbRequiredToRemoveListNgRan");
            e
        })
    }
}
// DrbRequiredToRemoveItemNgRan
#[derive(Clone, Debug)]
pub struct DrbRequiredToRemoveItemNgRan {
    pub drb_id: DrbId,
    pub cause: Cause,
}

impl DrbRequiredToRemoveItemNgRan {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let drb_id = DrbId::decode(data)?;
        let cause = Cause::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self { drb_id, cause })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.drb_id.encode(data)?;
        self.cause.encode(data)?;

        Ok(())
    }
}

impl PerCodec for DrbRequiredToRemoveItemNgRan {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        DrbRequiredToRemoveItemNgRan::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DrbRequiredToRemoveItemNgRan");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DrbRequiredToRemoveItemNgRan");
            e
        })
    }
}
// DrbToSetupListEutran
#[derive(Clone, Debug)]
pub struct DrbToSetupListEutran(pub NonEmpty<DrbToSetupItemEutran>);

impl DrbToSetupListEutran {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(32), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(DrbToSetupItemEutran::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(32), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for DrbToSetupListEutran {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        DrbToSetupListEutran::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DrbToSetupListEutran");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DrbToSetupListEutran");
            e
        })
    }
}
// DrbToSetupItemEutran
#[derive(Clone, Debug)]
pub struct DrbToSetupItemEutran {
    pub drb_id: DrbId,
    pub pdcp_configuration: PdcpConfiguration,
    pub eutran_qos: EutranQos,
    pub s1_ul_up_tnl_information: UpTnlInformation,
    pub data_forwarding_information_request: Option<DataForwardingInformationRequest>,
    pub cell_group_information: CellGroupInformation,
    pub dl_up_parameters: Option<UpParameters>,
    pub drb_inactivity_timer: Option<InactivityTimer>,
    pub existing_allocated_s1_dl_up_tnl_info: Option<UpTnlInformation>,
}

impl DrbToSetupItemEutran {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 5)?;
        let drb_id = DrbId::decode(data)?;
        let pdcp_configuration = PdcpConfiguration::decode(data)?;
        let eutran_qos = EutranQos::decode(data)?;
        let s1_ul_up_tnl_information = UpTnlInformation::decode(data)?;
        let data_forwarding_information_request = if optionals[0] {
            Some(DataForwardingInformationRequest::decode(data)?)
        } else {
            None
        };
        let cell_group_information = CellGroupInformation::decode(data)?;
        let dl_up_parameters = if optionals[1] {
            Some(UpParameters::decode(data)?)
        } else {
            None
        };
        let drb_inactivity_timer = if optionals[2] {
            Some(InactivityTimer::decode(data)?)
        } else {
            None
        };
        let existing_allocated_s1_dl_up_tnl_info = if optionals[3] {
            Some(UpTnlInformation::decode(data)?)
        } else {
            None
        };

        // Process the extension container

        if optionals[4] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            drb_id,
            pdcp_configuration,
            eutran_qos,
            s1_ul_up_tnl_information,
            data_forwarding_information_request,
            cell_group_information,
            dl_up_parameters,
            drb_inactivity_timer,
            existing_allocated_s1_dl_up_tnl_info,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.data_forwarding_information_request.is_some());
        optionals.push(self.dl_up_parameters.is_some());
        optionals.push(self.drb_inactivity_timer.is_some());
        optionals.push(self.existing_allocated_s1_dl_up_tnl_info.is_some());
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.drb_id.encode(data)?;
        self.pdcp_configuration.encode(data)?;
        self.eutran_qos.encode(data)?;
        self.s1_ul_up_tnl_information.encode(data)?;
        if let Some(x) = &self.data_forwarding_information_request {
            x.encode(data)?;
        }
        self.cell_group_information.encode(data)?;
        if let Some(x) = &self.dl_up_parameters {
            x.encode(data)?;
        }
        if let Some(x) = &self.drb_inactivity_timer {
            x.encode(data)?;
        }
        if let Some(x) = &self.existing_allocated_s1_dl_up_tnl_info {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl PerCodec for DrbToSetupItemEutran {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        DrbToSetupItemEutran::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DrbToSetupItemEutran");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DrbToSetupItemEutran");
            e
        })
    }
}
// DrbToSetupModListEutran
#[derive(Clone, Debug)]
pub struct DrbToSetupModListEutran(pub NonEmpty<DrbToSetupModItemEutran>);

impl DrbToSetupModListEutran {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(32), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(DrbToSetupModItemEutran::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(32), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for DrbToSetupModListEutran {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        DrbToSetupModListEutran::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DrbToSetupModListEutran");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DrbToSetupModListEutran");
            e
        })
    }
}
// DrbToSetupModItemEutran
#[derive(Clone, Debug)]
pub struct DrbToSetupModItemEutran {
    pub drb_id: DrbId,
    pub pdcp_configuration: PdcpConfiguration,
    pub eutran_qos: EutranQos,
    pub s1_ul_up_tnl_information: UpTnlInformation,
    pub data_forwarding_information_request: Option<DataForwardingInformationRequest>,
    pub cell_group_information: CellGroupInformation,
    pub dl_up_parameters: Option<UpParameters>,
    pub drb_inactivity_timer: Option<InactivityTimer>,
}

impl DrbToSetupModItemEutran {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 4)?;
        let drb_id = DrbId::decode(data)?;
        let pdcp_configuration = PdcpConfiguration::decode(data)?;
        let eutran_qos = EutranQos::decode(data)?;
        let s1_ul_up_tnl_information = UpTnlInformation::decode(data)?;
        let data_forwarding_information_request = if optionals[0] {
            Some(DataForwardingInformationRequest::decode(data)?)
        } else {
            None
        };
        let cell_group_information = CellGroupInformation::decode(data)?;
        let dl_up_parameters = if optionals[1] {
            Some(UpParameters::decode(data)?)
        } else {
            None
        };
        let drb_inactivity_timer = if optionals[2] {
            Some(InactivityTimer::decode(data)?)
        } else {
            None
        };

        // Process the extension container

        if optionals[3] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            drb_id,
            pdcp_configuration,
            eutran_qos,
            s1_ul_up_tnl_information,
            data_forwarding_information_request,
            cell_group_information,
            dl_up_parameters,
            drb_inactivity_timer,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.data_forwarding_information_request.is_some());
        optionals.push(self.dl_up_parameters.is_some());
        optionals.push(self.drb_inactivity_timer.is_some());
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.drb_id.encode(data)?;
        self.pdcp_configuration.encode(data)?;
        self.eutran_qos.encode(data)?;
        self.s1_ul_up_tnl_information.encode(data)?;
        if let Some(x) = &self.data_forwarding_information_request {
            x.encode(data)?;
        }
        self.cell_group_information.encode(data)?;
        if let Some(x) = &self.dl_up_parameters {
            x.encode(data)?;
        }
        if let Some(x) = &self.drb_inactivity_timer {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl PerCodec for DrbToSetupModItemEutran {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        DrbToSetupModItemEutran::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DrbToSetupModItemEutran");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DrbToSetupModItemEutran");
            e
        })
    }
}
// DrbToSetupListNgRan
#[derive(Clone, Debug)]
pub struct DrbToSetupListNgRan(pub NonEmpty<DrbToSetupItemNgRan>);

impl DrbToSetupListNgRan {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(32), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(DrbToSetupItemNgRan::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(32), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for DrbToSetupListNgRan {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        DrbToSetupListNgRan::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DrbToSetupListNgRan");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DrbToSetupListNgRan");
            e
        })
    }
}
// DrbToSetupItemNgRan
#[derive(Clone, Debug)]
pub struct DrbToSetupItemNgRan {
    pub drb_id: DrbId,
    pub sdap_configuration: SdapConfiguration,
    pub pdcp_configuration: PdcpConfiguration,
    pub cell_group_information: CellGroupInformation,
    pub qos_flow_information_to_be_setup: QosFlowQosParameterList,
    pub drb_data_forwarding_information_request: Option<DataForwardingInformationRequest>,
    pub drb_inactivity_timer: Option<InactivityTimer>,
    pub pdcp_sn_status_information: Option<PdcpSnStatusInformation>,
    pub drb_qos: Option<QosFlowLevelQosParameters>,
    pub daps_request_info: Option<DapsRequestInfo>,
    pub ignore_mapping_rule_indication: Option<IgnoreMappingRuleIndication>,
}

impl DrbToSetupItemNgRan {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 4)?;
        let drb_id = DrbId::decode(data)?;
        let sdap_configuration = SdapConfiguration::decode(data)?;
        let pdcp_configuration = PdcpConfiguration::decode(data)?;
        let cell_group_information = CellGroupInformation::decode(data)?;
        let qos_flow_information_to_be_setup = QosFlowQosParameterList::decode(data)?;
        let drb_data_forwarding_information_request = if optionals[0] {
            Some(DataForwardingInformationRequest::decode(data)?)
        } else {
            None
        };
        let drb_inactivity_timer = if optionals[1] {
            Some(InactivityTimer::decode(data)?)
        } else {
            None
        };
        let pdcp_sn_status_information = if optionals[2] {
            Some(PdcpSnStatusInformation::decode(data)?)
        } else {
            None
        };

        // Process the extension container
        let mut drb_qos: Option<QosFlowLevelQosParameters> = None;
        let mut daps_request_info: Option<DapsRequestInfo> = None;
        let mut ignore_mapping_rule_indication: Option<IgnoreMappingRuleIndication> = None;

        if optionals[3] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    72 => drb_qos = Some(QosFlowLevelQosParameters::decode(data)?),
                    120 => daps_request_info = Some(DapsRequestInfo::decode(data)?),
                    138 => {
                        ignore_mapping_rule_indication =
                            Some(IgnoreMappingRuleIndication::decode(data)?)
                    }
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            drb_id,
            sdap_configuration,
            pdcp_configuration,
            cell_group_information,
            qos_flow_information_to_be_setup,
            drb_data_forwarding_information_request,
            drb_inactivity_timer,
            pdcp_sn_status_information,
            drb_qos,
            daps_request_info,
            ignore_mapping_rule_indication,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();
        if let Some(x) = &self.drb_qos {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 72, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.daps_request_info {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 120, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.ignore_mapping_rule_indication {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 138, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        let mut optionals = BitString::new();
        optionals.push(self.drb_data_forwarding_information_request.is_some());
        optionals.push(self.drb_inactivity_timer.is_some());
        optionals.push(self.pdcp_sn_status_information.is_some());
        optionals.push(num_ies != 0);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.drb_id.encode(data)?;
        self.sdap_configuration.encode(data)?;
        self.pdcp_configuration.encode(data)?;
        self.cell_group_information.encode(data)?;
        self.qos_flow_information_to_be_setup.encode(data)?;
        if let Some(x) = &self.drb_data_forwarding_information_request {
            x.encode(data)?;
        }
        if let Some(x) = &self.drb_inactivity_timer {
            x.encode(data)?;
        }
        if let Some(x) = &self.pdcp_sn_status_information {
            x.encode(data)?;
        }
        if num_ies != 0 {
            encode::encode_length_determinent(data, Some(1), Some(65535), false, num_ies)?;
            data.append_aligned(ies);
        }
        Ok(())
    }
}

impl PerCodec for DrbToSetupItemNgRan {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        DrbToSetupItemNgRan::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DrbToSetupItemNgRan");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DrbToSetupItemNgRan");
            e
        })
    }
}
// DrbToSetupModListNgRan
#[derive(Clone, Debug)]
pub struct DrbToSetupModListNgRan(pub NonEmpty<DrbToSetupModItemNgRan>);

impl DrbToSetupModListNgRan {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(32), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(DrbToSetupModItemNgRan::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(32), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for DrbToSetupModListNgRan {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        DrbToSetupModListNgRan::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DrbToSetupModListNgRan");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DrbToSetupModListNgRan");
            e
        })
    }
}
// DrbToSetupModItemNgRan
#[derive(Clone, Debug)]
pub struct DrbToSetupModItemNgRan {
    pub drb_id: DrbId,
    pub sdap_configuration: SdapConfiguration,
    pub pdcp_configuration: PdcpConfiguration,
    pub cell_group_information: CellGroupInformation,
    pub flow_mapping_information: QosFlowQosParameterList,
    pub drb_data_forwarding_information_request: Option<DataForwardingInformationRequest>,
    pub drb_inactivity_timer: Option<InactivityTimer>,
    pub pdcp_sn_status_information: Option<PdcpSnStatusInformation>,
    pub drb_qos: Option<QosFlowLevelQosParameters>,
    pub ignore_mapping_rule_indication: Option<IgnoreMappingRuleIndication>,
    pub daps_request_info: Option<DapsRequestInfo>,
}

impl DrbToSetupModItemNgRan {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 4)?;
        let drb_id = DrbId::decode(data)?;
        let sdap_configuration = SdapConfiguration::decode(data)?;
        let pdcp_configuration = PdcpConfiguration::decode(data)?;
        let cell_group_information = CellGroupInformation::decode(data)?;
        let flow_mapping_information = QosFlowQosParameterList::decode(data)?;
        let drb_data_forwarding_information_request = if optionals[0] {
            Some(DataForwardingInformationRequest::decode(data)?)
        } else {
            None
        };
        let drb_inactivity_timer = if optionals[1] {
            Some(InactivityTimer::decode(data)?)
        } else {
            None
        };
        let pdcp_sn_status_information = if optionals[2] {
            Some(PdcpSnStatusInformation::decode(data)?)
        } else {
            None
        };

        // Process the extension container
        let mut drb_qos: Option<QosFlowLevelQosParameters> = None;
        let mut ignore_mapping_rule_indication: Option<IgnoreMappingRuleIndication> = None;
        let mut daps_request_info: Option<DapsRequestInfo> = None;

        if optionals[3] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    72 => drb_qos = Some(QosFlowLevelQosParameters::decode(data)?),
                    138 => {
                        ignore_mapping_rule_indication =
                            Some(IgnoreMappingRuleIndication::decode(data)?)
                    }
                    120 => daps_request_info = Some(DapsRequestInfo::decode(data)?),
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            drb_id,
            sdap_configuration,
            pdcp_configuration,
            cell_group_information,
            flow_mapping_information,
            drb_data_forwarding_information_request,
            drb_inactivity_timer,
            pdcp_sn_status_information,
            drb_qos,
            ignore_mapping_rule_indication,
            daps_request_info,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();
        if let Some(x) = &self.drb_qos {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 72, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.ignore_mapping_rule_indication {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 138, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.daps_request_info {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 120, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        let mut optionals = BitString::new();
        optionals.push(self.drb_data_forwarding_information_request.is_some());
        optionals.push(self.drb_inactivity_timer.is_some());
        optionals.push(self.pdcp_sn_status_information.is_some());
        optionals.push(num_ies != 0);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.drb_id.encode(data)?;
        self.sdap_configuration.encode(data)?;
        self.pdcp_configuration.encode(data)?;
        self.cell_group_information.encode(data)?;
        self.flow_mapping_information.encode(data)?;
        if let Some(x) = &self.drb_data_forwarding_information_request {
            x.encode(data)?;
        }
        if let Some(x) = &self.drb_inactivity_timer {
            x.encode(data)?;
        }
        if let Some(x) = &self.pdcp_sn_status_information {
            x.encode(data)?;
        }
        if num_ies != 0 {
            encode::encode_length_determinent(data, Some(1), Some(65535), false, num_ies)?;
            data.append_aligned(ies);
        }
        Ok(())
    }
}

impl PerCodec for DrbToSetupModItemNgRan {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        DrbToSetupModItemNgRan::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DrbToSetupModItemNgRan");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DrbToSetupModItemNgRan");
            e
        })
    }
}
// DrbUsageReportList
#[derive(Clone, Debug)]
pub struct DrbUsageReportList(pub NonEmpty<DrbUsageReportItem>);

impl DrbUsageReportList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(2), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(DrbUsageReportItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(2), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for DrbUsageReportList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        DrbUsageReportList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DrbUsageReportList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DrbUsageReportList");
            e
        })
    }
}
// DrbUsageReportItem
#[derive(Clone, Debug)]
pub struct DrbUsageReportItem {
    pub start_time_stamp: [u8; 4],
    pub end_time_stamp: [u8; 4],
    pub usage_count_ul: u64,
    pub usage_count_dl: u64,
}

impl DrbUsageReportItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let start_time_stamp = decode::decode_octetstring(data, Some(4), Some(4), false)?
            .try_into()
            .unwrap();
        let end_time_stamp = decode::decode_octetstring(data, Some(4), Some(4), false)?
            .try_into()
            .unwrap();
        let usage_count_ul = decode::decode_integer(data, Some(0), None, false)?.0 as u64;
        let usage_count_dl = decode::decode_integer(data, Some(0), None, false)?.0 as u64;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            start_time_stamp,
            end_time_stamp,
            usage_count_ul,
            usage_count_dl,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        encode::encode_octetstring(
            data,
            Some(4),
            Some(4),
            false,
            &(self.start_time_stamp).into(),
            false,
        )?;
        encode::encode_octetstring(
            data,
            Some(4),
            Some(4),
            false,
            &(self.end_time_stamp).into(),
            false,
        )?;
        encode::encode_integer(
            data,
            Some(0),
            None,
            false,
            self.usage_count_ul as i128,
            false,
        )?;
        encode::encode_integer(
            data,
            Some(0),
            None,
            false,
            self.usage_count_dl as i128,
            false,
        )?;

        Ok(())
    }
}

impl PerCodec for DrbUsageReportItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        DrbUsageReportItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DrbUsageReportItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DrbUsageReportItem");
            e
        })
    }
}
// DuplicationActivation
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum DuplicationActivation {
    Active,
    Inactive,
}

impl DuplicationActivation {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(1), true)?;
        if extended {
            return Err(PerCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(data, Some(0), Some(1), true, *self as i128, false)
    }
}

impl PerCodec for DuplicationActivation {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        DuplicationActivation::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DuplicationActivation");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DuplicationActivation");
            e
        })
    }
}
// Dynamic5qiDescriptor
#[derive(Clone, Debug)]
pub struct Dynamic5qiDescriptor {
    pub qos_priority_level: QosPriorityLevel,
    pub packet_delay_budget: PacketDelayBudget,
    pub packet_error_rate: PacketErrorRate,
    pub five_qi: Option<u8>,
    pub delay_critical: Option<DelayCritical>,
    pub averaging_window: Option<AveragingWindow>,
    pub max_data_burst_volume: Option<MaxDataBurstVolume>,
    pub extended_packet_delay_budget: Option<ExtendedPacketDelayBudget>,
    pub cn_packet_delay_budget_downlink: Option<ExtendedPacketDelayBudget>,
    pub cn_packet_delay_budget_uplink: Option<ExtendedPacketDelayBudget>,
}

impl Dynamic5qiDescriptor {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, false, 5)?;
        let qos_priority_level = QosPriorityLevel::decode(data)?;
        let packet_delay_budget = PacketDelayBudget::decode(data)?;
        let packet_error_rate = PacketErrorRate::decode(data)?;
        let five_qi = if optionals[0] {
            Some(decode::decode_integer(data, Some(0), Some(255), true)?.0 as u8)
        } else {
            None
        };
        let delay_critical = if optionals[1] {
            Some(DelayCritical::decode(data)?)
        } else {
            None
        };
        let averaging_window = if optionals[2] {
            Some(AveragingWindow::decode(data)?)
        } else {
            None
        };
        let max_data_burst_volume = if optionals[3] {
            Some(MaxDataBurstVolume::decode(data)?)
        } else {
            None
        };

        // Process the extension container
        let mut extended_packet_delay_budget: Option<ExtendedPacketDelayBudget> = None;
        let mut cn_packet_delay_budget_downlink: Option<ExtendedPacketDelayBudget> = None;
        let mut cn_packet_delay_budget_uplink: Option<ExtendedPacketDelayBudget> = None;

        if optionals[4] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    103 => {
                        extended_packet_delay_budget =
                            Some(ExtendedPacketDelayBudget::decode(data)?)
                    }
                    101 => {
                        cn_packet_delay_budget_downlink =
                            Some(ExtendedPacketDelayBudget::decode(data)?)
                    }
                    102 => {
                        cn_packet_delay_budget_uplink =
                            Some(ExtendedPacketDelayBudget::decode(data)?)
                    }
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            qos_priority_level,
            packet_delay_budget,
            packet_error_rate,
            five_qi,
            delay_critical,
            averaging_window,
            max_data_burst_volume,
            extended_packet_delay_budget,
            cn_packet_delay_budget_downlink,
            cn_packet_delay_budget_uplink,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();
        if let Some(x) = &self.extended_packet_delay_budget {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 103, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.cn_packet_delay_budget_downlink {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 101, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.cn_packet_delay_budget_uplink {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 102, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        let mut optionals = BitString::new();
        optionals.push(self.five_qi.is_some());
        optionals.push(self.delay_critical.is_some());
        optionals.push(self.averaging_window.is_some());
        optionals.push(self.max_data_burst_volume.is_some());
        optionals.push(num_ies != 0);

        encode::encode_sequence_header(data, false, &optionals, false)?;
        self.qos_priority_level.encode(data)?;
        self.packet_delay_budget.encode(data)?;
        self.packet_error_rate.encode(data)?;
        if let Some(x) = &self.five_qi {
            encode::encode_integer(data, Some(0), Some(255), true, *x as i128, false)?;
        }
        if let Some(x) = &self.delay_critical {
            x.encode(data)?;
        }
        if let Some(x) = &self.averaging_window {
            x.encode(data)?;
        }
        if let Some(x) = &self.max_data_burst_volume {
            x.encode(data)?;
        }
        if num_ies != 0 {
            encode::encode_length_determinent(data, Some(1), Some(65535), false, num_ies)?;
            data.append_aligned(ies);
        }
        Ok(())
    }
}

impl PerCodec for Dynamic5qiDescriptor {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Dynamic5qiDescriptor::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("Dynamic5qiDescriptor");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("Dynamic5qiDescriptor");
            e
        })
    }
}
// DataDiscardRequired
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum DataDiscardRequired {
    Required,
}

impl DataDiscardRequired {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(0), true)?;
        if extended {
            return Err(PerCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(data, Some(0), Some(0), true, *self as i128, false)
    }
}

impl PerCodec for DataDiscardRequired {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        DataDiscardRequired::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DataDiscardRequired");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DataDiscardRequired");
            e
        })
    }
}
// EarlyForwardingCountInfo
#[derive(Clone, Debug)]
pub enum EarlyForwardingCountInfo {
    FirstDlCount(FirstDlCount),
    DlDiscardingCount(DlDiscarding),
}

impl EarlyForwardingCountInfo {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_choice_idx(data, 0, 2, false)?;
        if extended {
            return Err(PerCodecError::new("CHOICE additions not implemented"));
        }
        match idx {
            0 => Ok(Self::FirstDlCount(FirstDlCount::decode(data)?)),
            1 => Ok(Self::DlDiscardingCount(DlDiscarding::decode(data)?)),
            2 => {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _ = Criticality::decode(data)?;
                let _ = decode::decode_length_determinent(data, None, None, false)?;
                let result = match id {
                    x => Err(PerCodecError::new(format!("Unrecognised IE type {}", x))),
                };
                data.decode_align()?;
                result
            }
            _ => Err(PerCodecError::new("Unknown choice idx")),
        }
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        match self {
            Self::FirstDlCount(x) => {
                encode::encode_choice_idx(data, 0, 2, false, 0, false)?;
                x.encode(data)
            }
            Self::DlDiscardingCount(x) => {
                encode::encode_choice_idx(data, 0, 2, false, 1, false)?;
                x.encode(data)
            }
        }
    }
}

impl PerCodec for EarlyForwardingCountInfo {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        EarlyForwardingCountInfo::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("EarlyForwardingCountInfo");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("EarlyForwardingCountInfo");
            e
        })
    }
}
// EarlyForwardingCountReq
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum EarlyForwardingCountReq {
    FirstDlCount,
    DlDiscarding,
}

impl EarlyForwardingCountReq {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(1), true)?;
        if extended {
            return Err(PerCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(data, Some(0), Some(1), true, *self as i128, false)
    }
}

impl PerCodec for EarlyForwardingCountReq {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        EarlyForwardingCountReq::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("EarlyForwardingCountReq");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("EarlyForwardingCountReq");
            e
        })
    }
}
// EhcCommonParameters
#[derive(Clone, Debug)]
pub struct EhcCommonParameters {
    pub ehc_cid_length: EhcCidLength,
}

impl EhcCommonParameters {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, false, 1)?;
        let ehc_cid_length = EhcCidLength::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self { ehc_cid_length })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, false, &optionals, false)?;
        self.ehc_cid_length.encode(data)?;

        Ok(())
    }
}

impl PerCodec for EhcCommonParameters {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        EhcCommonParameters::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("EhcCommonParameters");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("EhcCommonParameters");
            e
        })
    }
}
// EhcDownlinkParameters
#[derive(Clone, Debug)]
pub struct EhcDownlinkParameters {
    pub drb_continue_ehc_dl: DrbContinueEhcDl,
    pub max_cidehc_dl: Option<MaxCidehcDl>,
}

impl EhcDownlinkParameters {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, false, 1)?;
        let drb_continue_ehc_dl = DrbContinueEhcDl::decode(data)?;

        // Process the extension container
        let mut max_cidehc_dl: Option<MaxCidehcDl> = None;

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    137 => max_cidehc_dl = Some(MaxCidehcDl::decode(data)?),
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            drb_continue_ehc_dl,
            max_cidehc_dl,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();
        if let Some(x) = &self.max_cidehc_dl {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 137, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        let mut optionals = BitString::new();
        optionals.push(num_ies != 0);

        encode::encode_sequence_header(data, false, &optionals, false)?;
        self.drb_continue_ehc_dl.encode(data)?;
        if num_ies != 0 {
            encode::encode_length_determinent(data, Some(1), Some(65535), false, num_ies)?;
            data.append_aligned(ies);
        }
        Ok(())
    }
}

impl PerCodec for EhcDownlinkParameters {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        EhcDownlinkParameters::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("EhcDownlinkParameters");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("EhcDownlinkParameters");
            e
        })
    }
}
// EhcUplinkParameters
#[derive(Clone, Debug)]
pub struct EhcUplinkParameters {
    pub drb_continue_ehc_ul: DrbContinueEhcUl,
}

impl EhcUplinkParameters {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, false, 1)?;
        let drb_continue_ehc_ul = DrbContinueEhcUl::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            drb_continue_ehc_ul,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, false, &optionals, false)?;
        self.drb_continue_ehc_ul.encode(data)?;

        Ok(())
    }
}

impl PerCodec for EhcUplinkParameters {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        EhcUplinkParameters::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("EhcUplinkParameters");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("EhcUplinkParameters");
            e
        })
    }
}
// EhcParameters
#[derive(Clone, Debug)]
pub struct EhcParameters {
    pub ehc_common: EhcCommonParameters,
    pub ehc_downlink: Option<EhcDownlinkParameters>,
    pub ehc_uplink: Option<EhcUplinkParameters>,
}

impl EhcParameters {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, false, 3)?;
        let ehc_common = EhcCommonParameters::decode(data)?;
        let ehc_downlink = if optionals[0] {
            Some(EhcDownlinkParameters::decode(data)?)
        } else {
            None
        };
        let ehc_uplink = if optionals[1] {
            Some(EhcUplinkParameters::decode(data)?)
        } else {
            None
        };

        // Process the extension container

        if optionals[2] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            ehc_common,
            ehc_downlink,
            ehc_uplink,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.ehc_downlink.is_some());
        optionals.push(self.ehc_uplink.is_some());
        optionals.push(false);

        encode::encode_sequence_header(data, false, &optionals, false)?;
        self.ehc_common.encode(data)?;
        if let Some(x) = &self.ehc_downlink {
            x.encode(data)?;
        }
        if let Some(x) = &self.ehc_uplink {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl PerCodec for EhcParameters {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        EhcParameters::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("EhcParameters");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("EhcParameters");
            e
        })
    }
}
// EncryptionKey
#[derive(Clone, Debug)]
pub struct EncryptionKey(pub Vec<u8>);

impl EncryptionKey {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(decode::decode_octetstring(data, None, None, false)?))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_octetstring(data, None, None, false, &self.0, false)
    }
}

impl PerCodec for EncryptionKey {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        EncryptionKey::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("EncryptionKey");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("EncryptionKey");
            e
        })
    }
}
// EndpointIpAddressAndPort
#[derive(Clone, Debug)]
pub struct EndpointIpAddressAndPort {
    pub endpoint_ip_address: TransportLayerAddress,
    pub port_number: PortNumber,
}

impl EndpointIpAddressAndPort {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, false, 1)?;
        let endpoint_ip_address = TransportLayerAddress::decode(data)?;
        let port_number = PortNumber::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            endpoint_ip_address,
            port_number,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, false, &optionals, false)?;
        self.endpoint_ip_address.encode(data)?;
        self.port_number.encode(data)?;

        Ok(())
    }
}

impl PerCodec for EndpointIpAddressAndPort {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        EndpointIpAddressAndPort::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("EndpointIpAddressAndPort");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("EndpointIpAddressAndPort");
            e
        })
    }
}
// EutranAllocationAndRetentionPriority
#[derive(Clone, Debug)]
pub struct EutranAllocationAndRetentionPriority {
    pub priority_level: PriorityLevel,
    pub pre_emption_capability: PreEmptionCapability,
    pub pre_emption_vulnerability: PreEmptionVulnerability,
}

impl EutranAllocationAndRetentionPriority {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let priority_level = PriorityLevel::decode(data)?;
        let pre_emption_capability = PreEmptionCapability::decode(data)?;
        let pre_emption_vulnerability = PreEmptionVulnerability::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            priority_level,
            pre_emption_capability,
            pre_emption_vulnerability,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.priority_level.encode(data)?;
        self.pre_emption_capability.encode(data)?;
        self.pre_emption_vulnerability.encode(data)?;

        Ok(())
    }
}

impl PerCodec for EutranAllocationAndRetentionPriority {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        EutranAllocationAndRetentionPriority::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("EutranAllocationAndRetentionPriority");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("EutranAllocationAndRetentionPriority");
            e
        })
    }
}
// ExtendedPacketDelayBudget
#[derive(Clone, Copy, Debug)]
pub struct ExtendedPacketDelayBudget(pub u16);

impl ExtendedPacketDelayBudget {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(
            decode::decode_integer(data, Some(1), Some(65535), true)?.0 as u16,
        ))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_integer(data, Some(1), Some(65535), true, self.0 as i128, false)
    }
}

impl PerCodec for ExtendedPacketDelayBudget {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        ExtendedPacketDelayBudget::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ExtendedPacketDelayBudget");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ExtendedPacketDelayBudget");
            e
        })
    }
}
// EutranQosSupportList
#[derive(Clone, Debug)]
pub struct EutranQosSupportList(pub NonEmpty<EutranQosSupportItem>);

impl EutranQosSupportList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(256), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(EutranQosSupportItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(256), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for EutranQosSupportList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        EutranQosSupportList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("EutranQosSupportList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("EutranQosSupportList");
            e
        })
    }
}
// EutranQosSupportItem
#[derive(Clone, Debug)]
pub struct EutranQosSupportItem {
    pub eutran_qos: EutranQos,
}

impl EutranQosSupportItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, false, 1)?;
        let eutran_qos = EutranQos::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self { eutran_qos })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, false, &optionals, false)?;
        self.eutran_qos.encode(data)?;

        Ok(())
    }
}

impl PerCodec for EutranQosSupportItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        EutranQosSupportItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("EutranQosSupportItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("EutranQosSupportItem");
            e
        })
    }
}
// EutranQos
#[derive(Clone, Debug)]
pub struct EutranQos {
    pub qci: Qci,
    pub eutran_allocation_and_retention_priority: EutranAllocationAndRetentionPriority,
    pub gbr_qos_information: Option<GbrQosInformation>,
}

impl EutranQos {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 2)?;
        let qci = Qci::decode(data)?;
        let eutran_allocation_and_retention_priority =
            EutranAllocationAndRetentionPriority::decode(data)?;
        let gbr_qos_information = if optionals[0] {
            Some(GbrQosInformation::decode(data)?)
        } else {
            None
        };

        // Process the extension container

        if optionals[1] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            qci,
            eutran_allocation_and_retention_priority,
            gbr_qos_information,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.gbr_qos_information.is_some());
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.qci.encode(data)?;
        self.eutran_allocation_and_retention_priority.encode(data)?;
        if let Some(x) = &self.gbr_qos_information {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl PerCodec for EutranQos {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        EutranQos::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("EutranQos");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("EutranQos");
            e
        })
    }
}
// ExtendedSliceSupportList
#[derive(Clone, Debug)]
pub struct ExtendedSliceSupportList(pub NonEmpty<SliceSupportItem>);

impl ExtendedSliceSupportList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(SliceSupportItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(65535), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for ExtendedSliceSupportList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        ExtendedSliceSupportList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ExtendedSliceSupportList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ExtendedSliceSupportList");
            e
        })
    }
}
// FirstDlCount
#[derive(Clone, Debug)]
pub struct FirstDlCount {
    pub first_dl_count_val: PdcpCount,
}

impl FirstDlCount {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, false, 1)?;
        let first_dl_count_val = PdcpCount::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self { first_dl_count_val })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, false, &optionals, false)?;
        self.first_dl_count_val.encode(data)?;

        Ok(())
    }
}

impl PerCodec for FirstDlCount {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        FirstDlCount::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("FirstDlCount");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("FirstDlCount");
            e
        })
    }
}
// GnbCuCpName
#[derive(Clone, Debug)]
pub struct GnbCuCpName(pub String);

impl GnbCuCpName {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(decode::decode_printable_string(
            data,
            Some(1),
            Some(150),
            true,
        )?))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_printable_string(data, Some(1), Some(150), true, &self.0, false)
    }
}

impl PerCodec for GnbCuCpName {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        GnbCuCpName::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("GnbCuCpName");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("GnbCuCpName");
            e
        })
    }
}
// ExtendedGnbCuCpName
#[derive(Clone, Debug)]
pub struct ExtendedGnbCuCpName {
    pub gnb_cu_cp_name_visible_string: Option<GnbCuCpNameVisibleString>,
    pub gnb_cu_cp_name_utf8_string: Option<GnbCuCpNameUtf8String>,
}

impl ExtendedGnbCuCpName {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 3)?;
        let gnb_cu_cp_name_visible_string = if optionals[0] {
            Some(GnbCuCpNameVisibleString::decode(data)?)
        } else {
            None
        };
        let gnb_cu_cp_name_utf8_string = if optionals[1] {
            Some(GnbCuCpNameUtf8String::decode(data)?)
        } else {
            None
        };

        // Process the extension container

        if optionals[2] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            gnb_cu_cp_name_visible_string,
            gnb_cu_cp_name_utf8_string,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.gnb_cu_cp_name_visible_string.is_some());
        optionals.push(self.gnb_cu_cp_name_utf8_string.is_some());
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        if let Some(x) = &self.gnb_cu_cp_name_visible_string {
            x.encode(data)?;
        }
        if let Some(x) = &self.gnb_cu_cp_name_utf8_string {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl PerCodec for ExtendedGnbCuCpName {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        ExtendedGnbCuCpName::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ExtendedGnbCuCpName");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ExtendedGnbCuCpName");
            e
        })
    }
}
// GnbCuCpNameVisibleString
#[derive(Clone, Debug)]
pub struct GnbCuCpNameVisibleString(pub String);

impl GnbCuCpNameVisibleString {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(decode::decode_visible_string(
            data,
            Some(1),
            Some(150),
            true,
        )?))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_visible_string(data, Some(1), Some(150), true, &self.0, false)
    }
}

impl PerCodec for GnbCuCpNameVisibleString {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        GnbCuCpNameVisibleString::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("GnbCuCpNameVisibleString");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("GnbCuCpNameVisibleString");
            e
        })
    }
}
// GnbCuCpNameUtf8String
#[derive(Clone, Debug)]
pub struct GnbCuCpNameUtf8String(pub String);

impl GnbCuCpNameUtf8String {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(decode::decode_utf8_string(
            data,
            Some(1),
            Some(150),
            true,
        )?))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_utf8_string(data, Some(1), Some(150), true, &self.0, false)
    }
}

impl PerCodec for GnbCuCpNameUtf8String {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        GnbCuCpNameUtf8String::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("GnbCuCpNameUtf8String");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("GnbCuCpNameUtf8String");
            e
        })
    }
}
// GnbCuCpUeE1apId
#[derive(Clone, Copy, Debug)]
pub struct GnbCuCpUeE1apId(pub u32);

impl GnbCuCpUeE1apId {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(
            decode::decode_integer(data, Some(0), Some(4294967295), false)?.0 as u32,
        ))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_integer(
            data,
            Some(0),
            Some(4294967295),
            false,
            self.0 as i128,
            false,
        )
    }
}

impl PerCodec for GnbCuCpUeE1apId {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        GnbCuCpUeE1apId::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("GnbCuCpUeE1apId");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("GnbCuCpUeE1apId");
            e
        })
    }
}
// GnbCuUpCapacity
#[derive(Clone, Copy, Debug)]
pub struct GnbCuUpCapacity(pub u8);

impl GnbCuUpCapacity {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(
            decode::decode_integer(data, Some(0), Some(255), false)?.0 as u8,
        ))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_integer(data, Some(0), Some(255), false, self.0 as i128, false)
    }
}

impl PerCodec for GnbCuUpCapacity {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        GnbCuUpCapacity::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("GnbCuUpCapacity");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("GnbCuUpCapacity");
            e
        })
    }
}
// GnbCuUpCellGroupRelatedConfiguration
#[derive(Clone, Debug)]
pub struct GnbCuUpCellGroupRelatedConfiguration(
    pub NonEmpty<GnbCuUpCellGroupRelatedConfigurationItem>,
);

impl GnbCuUpCellGroupRelatedConfiguration {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(8), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(GnbCuUpCellGroupRelatedConfigurationItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(8), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for GnbCuUpCellGroupRelatedConfiguration {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        GnbCuUpCellGroupRelatedConfiguration::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("GnbCuUpCellGroupRelatedConfiguration");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("GnbCuUpCellGroupRelatedConfiguration");
            e
        })
    }
}
// GnbCuUpCellGroupRelatedConfigurationItem
#[derive(Clone, Debug)]
pub struct GnbCuUpCellGroupRelatedConfigurationItem {
    pub cell_group_id: CellGroupId,
    pub up_tnl_information: UpTnlInformation,
    pub ul_configuration: Option<UlConfiguration>,
}

impl GnbCuUpCellGroupRelatedConfigurationItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, false, 2)?;
        let cell_group_id = CellGroupId::decode(data)?;
        let up_tnl_information = UpTnlInformation::decode(data)?;
        let ul_configuration = if optionals[0] {
            Some(UlConfiguration::decode(data)?)
        } else {
            None
        };

        // Process the extension container

        if optionals[1] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            cell_group_id,
            up_tnl_information,
            ul_configuration,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.ul_configuration.is_some());
        optionals.push(false);

        encode::encode_sequence_header(data, false, &optionals, false)?;
        self.cell_group_id.encode(data)?;
        self.up_tnl_information.encode(data)?;
        if let Some(x) = &self.ul_configuration {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl PerCodec for GnbCuUpCellGroupRelatedConfigurationItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        GnbCuUpCellGroupRelatedConfigurationItem::decode_inner(data).map_err(
            |mut e: PerCodecError| {
                e.push_context("GnbCuUpCellGroupRelatedConfigurationItem");
                e
            },
        )
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("GnbCuUpCellGroupRelatedConfigurationItem");
            e
        })
    }
}
// GnbCuUpId
#[derive(Clone, Copy, Debug)]
pub struct GnbCuUpId(pub u64);

impl GnbCuUpId {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(
            decode::decode_integer(data, Some(0), Some(68719476735), false)?.0 as u64,
        ))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_integer(
            data,
            Some(0),
            Some(68719476735),
            false,
            self.0 as i128,
            false,
        )
    }
}

impl PerCodec for GnbCuUpId {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        GnbCuUpId::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("GnbCuUpId");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("GnbCuUpId");
            e
        })
    }
}
// GnbCuUpName
#[derive(Clone, Debug)]
pub struct GnbCuUpName(pub String);

impl GnbCuUpName {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(decode::decode_printable_string(
            data,
            Some(1),
            Some(150),
            true,
        )?))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_printable_string(data, Some(1), Some(150), true, &self.0, false)
    }
}

impl PerCodec for GnbCuUpName {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        GnbCuUpName::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("GnbCuUpName");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("GnbCuUpName");
            e
        })
    }
}
// ExtendedGnbCuUpName
#[derive(Clone, Debug)]
pub struct ExtendedGnbCuUpName {
    pub gnb_cu_up_name_visible_string: Option<GnbCuUpNameVisibleString>,
    pub gnb_cu_up_name_utf8_string: Option<GnbCuUpNameUtf8String>,
}

impl ExtendedGnbCuUpName {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 3)?;
        let gnb_cu_up_name_visible_string = if optionals[0] {
            Some(GnbCuUpNameVisibleString::decode(data)?)
        } else {
            None
        };
        let gnb_cu_up_name_utf8_string = if optionals[1] {
            Some(GnbCuUpNameUtf8String::decode(data)?)
        } else {
            None
        };

        // Process the extension container

        if optionals[2] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            gnb_cu_up_name_visible_string,
            gnb_cu_up_name_utf8_string,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.gnb_cu_up_name_visible_string.is_some());
        optionals.push(self.gnb_cu_up_name_utf8_string.is_some());
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        if let Some(x) = &self.gnb_cu_up_name_visible_string {
            x.encode(data)?;
        }
        if let Some(x) = &self.gnb_cu_up_name_utf8_string {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl PerCodec for ExtendedGnbCuUpName {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        ExtendedGnbCuUpName::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ExtendedGnbCuUpName");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ExtendedGnbCuUpName");
            e
        })
    }
}
// GnbCuUpNameVisibleString
#[derive(Clone, Debug)]
pub struct GnbCuUpNameVisibleString(pub String);

impl GnbCuUpNameVisibleString {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(decode::decode_visible_string(
            data,
            Some(1),
            Some(150),
            true,
        )?))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_visible_string(data, Some(1), Some(150), true, &self.0, false)
    }
}

impl PerCodec for GnbCuUpNameVisibleString {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        GnbCuUpNameVisibleString::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("GnbCuUpNameVisibleString");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("GnbCuUpNameVisibleString");
            e
        })
    }
}
// GnbCuUpNameUtf8String
#[derive(Clone, Debug)]
pub struct GnbCuUpNameUtf8String(pub String);

impl GnbCuUpNameUtf8String {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(decode::decode_utf8_string(
            data,
            Some(1),
            Some(150),
            true,
        )?))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_utf8_string(data, Some(1), Some(150), true, &self.0, false)
    }
}

impl PerCodec for GnbCuUpNameUtf8String {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        GnbCuUpNameUtf8String::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("GnbCuUpNameUtf8String");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("GnbCuUpNameUtf8String");
            e
        })
    }
}
// GnbCuUpUeE1apId
#[derive(Clone, Copy, Debug)]
pub struct GnbCuUpUeE1apId(pub u32);

impl GnbCuUpUeE1apId {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(
            decode::decode_integer(data, Some(0), Some(4294967295), false)?.0 as u32,
        ))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_integer(
            data,
            Some(0),
            Some(4294967295),
            false,
            self.0 as i128,
            false,
        )
    }
}

impl PerCodec for GnbCuUpUeE1apId {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        GnbCuUpUeE1apId::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("GnbCuUpUeE1apId");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("GnbCuUpUeE1apId");
            e
        })
    }
}
// GnbCuCpTnlaSetupItem
#[derive(Clone, Debug)]
pub struct GnbCuCpTnlaSetupItem {
    pub tnl_association_transport_layer_address: CpTnlInformation,
}

impl GnbCuCpTnlaSetupItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let tnl_association_transport_layer_address = CpTnlInformation::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            tnl_association_transport_layer_address,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.tnl_association_transport_layer_address.encode(data)?;

        Ok(())
    }
}

impl PerCodec for GnbCuCpTnlaSetupItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        GnbCuCpTnlaSetupItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("GnbCuCpTnlaSetupItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("GnbCuCpTnlaSetupItem");
            e
        })
    }
}
// GnbCuCpTnlaFailedToSetupItem
#[derive(Clone, Debug)]
pub struct GnbCuCpTnlaFailedToSetupItem {
    pub tnl_association_transport_layer_address: CpTnlInformation,
    pub cause: Cause,
}

impl GnbCuCpTnlaFailedToSetupItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, false, 1)?;
        let tnl_association_transport_layer_address = CpTnlInformation::decode(data)?;
        let cause = Cause::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            tnl_association_transport_layer_address,
            cause,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, false, &optionals, false)?;
        self.tnl_association_transport_layer_address.encode(data)?;
        self.cause.encode(data)?;

        Ok(())
    }
}

impl PerCodec for GnbCuCpTnlaFailedToSetupItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        GnbCuCpTnlaFailedToSetupItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("GnbCuCpTnlaFailedToSetupItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("GnbCuCpTnlaFailedToSetupItem");
            e
        })
    }
}
// GnbCuCpTnlaToAddItem
#[derive(Clone, Debug)]
pub struct GnbCuCpTnlaToAddItem {
    pub tnl_association_transport_layer_address: CpTnlInformation,
    pub tnl_association_usage: TnlAssociationUsage,
}

impl GnbCuCpTnlaToAddItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, false, 1)?;
        let tnl_association_transport_layer_address = CpTnlInformation::decode(data)?;
        let tnl_association_usage = TnlAssociationUsage::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            tnl_association_transport_layer_address,
            tnl_association_usage,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, false, &optionals, false)?;
        self.tnl_association_transport_layer_address.encode(data)?;
        self.tnl_association_usage.encode(data)?;

        Ok(())
    }
}

impl PerCodec for GnbCuCpTnlaToAddItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        GnbCuCpTnlaToAddItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("GnbCuCpTnlaToAddItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("GnbCuCpTnlaToAddItem");
            e
        })
    }
}
// GnbCuCpTnlaToRemoveItem
#[derive(Clone, Debug)]
pub struct GnbCuCpTnlaToRemoveItem {
    pub tnl_association_transport_layer_address: CpTnlInformation,
    pub tnl_association_transport_layer_address_gnb_cu_up: Option<CpTnlInformation>,
}

impl GnbCuCpTnlaToRemoveItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, false, 1)?;
        let tnl_association_transport_layer_address = CpTnlInformation::decode(data)?;

        // Process the extension container
        let mut tnl_association_transport_layer_address_gnb_cu_up: Option<CpTnlInformation> = None;

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    75 => {
                        tnl_association_transport_layer_address_gnb_cu_up =
                            Some(CpTnlInformation::decode(data)?)
                    }
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            tnl_association_transport_layer_address,
            tnl_association_transport_layer_address_gnb_cu_up,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();
        if let Some(x) = &self.tnl_association_transport_layer_address_gnb_cu_up {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 75, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        let mut optionals = BitString::new();
        optionals.push(num_ies != 0);

        encode::encode_sequence_header(data, false, &optionals, false)?;
        self.tnl_association_transport_layer_address.encode(data)?;
        if num_ies != 0 {
            encode::encode_length_determinent(data, Some(1), Some(65535), false, num_ies)?;
            data.append_aligned(ies);
        }
        Ok(())
    }
}

impl PerCodec for GnbCuCpTnlaToRemoveItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        GnbCuCpTnlaToRemoveItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("GnbCuCpTnlaToRemoveItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("GnbCuCpTnlaToRemoveItem");
            e
        })
    }
}
// GnbCuCpTnlaToUpdateItem
#[derive(Clone, Debug)]
pub struct GnbCuCpTnlaToUpdateItem {
    pub tnl_association_transport_layer_address: CpTnlInformation,
    pub tnl_association_usage: Option<TnlAssociationUsage>,
}

impl GnbCuCpTnlaToUpdateItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, false, 2)?;
        let tnl_association_transport_layer_address = CpTnlInformation::decode(data)?;
        let tnl_association_usage = if optionals[0] {
            Some(TnlAssociationUsage::decode(data)?)
        } else {
            None
        };

        // Process the extension container

        if optionals[1] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            tnl_association_transport_layer_address,
            tnl_association_usage,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.tnl_association_usage.is_some());
        optionals.push(false);

        encode::encode_sequence_header(data, false, &optionals, false)?;
        self.tnl_association_transport_layer_address.encode(data)?;
        if let Some(x) = &self.tnl_association_usage {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl PerCodec for GnbCuCpTnlaToUpdateItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        GnbCuCpTnlaToUpdateItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("GnbCuCpTnlaToUpdateItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("GnbCuCpTnlaToUpdateItem");
            e
        })
    }
}
// GnbCuUpTnlaToRemoveItem
#[derive(Clone, Debug)]
pub struct GnbCuUpTnlaToRemoveItem {
    pub tnl_association_transport_layer_address: CpTnlInformation,
    pub tnl_association_transport_layer_address_gnb_cu_cp: Option<CpTnlInformation>,
}

impl GnbCuUpTnlaToRemoveItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, false, 2)?;
        let tnl_association_transport_layer_address = CpTnlInformation::decode(data)?;
        let tnl_association_transport_layer_address_gnb_cu_cp = if optionals[0] {
            Some(CpTnlInformation::decode(data)?)
        } else {
            None
        };

        // Process the extension container

        if optionals[1] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            tnl_association_transport_layer_address,
            tnl_association_transport_layer_address_gnb_cu_cp,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(
            self.tnl_association_transport_layer_address_gnb_cu_cp
                .is_some(),
        );
        optionals.push(false);

        encode::encode_sequence_header(data, false, &optionals, false)?;
        self.tnl_association_transport_layer_address.encode(data)?;
        if let Some(x) = &self.tnl_association_transport_layer_address_gnb_cu_cp {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl PerCodec for GnbCuUpTnlaToRemoveItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        GnbCuUpTnlaToRemoveItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("GnbCuUpTnlaToRemoveItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("GnbCuUpTnlaToRemoveItem");
            e
        })
    }
}
// GbrQosInformation
#[derive(Clone, Debug)]
pub struct GbrQosInformation {
    pub e_rab_maximum_bitrate_dl: BitRate,
    pub e_rab_maximum_bitrate_ul: BitRate,
    pub e_rab_guaranteed_bitrate_dl: BitRate,
    pub e_rab_guaranteed_bitrate_ul: BitRate,
}

impl GbrQosInformation {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let e_rab_maximum_bitrate_dl = BitRate::decode(data)?;
        let e_rab_maximum_bitrate_ul = BitRate::decode(data)?;
        let e_rab_guaranteed_bitrate_dl = BitRate::decode(data)?;
        let e_rab_guaranteed_bitrate_ul = BitRate::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            e_rab_maximum_bitrate_dl,
            e_rab_maximum_bitrate_ul,
            e_rab_guaranteed_bitrate_dl,
            e_rab_guaranteed_bitrate_ul,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.e_rab_maximum_bitrate_dl.encode(data)?;
        self.e_rab_maximum_bitrate_ul.encode(data)?;
        self.e_rab_guaranteed_bitrate_dl.encode(data)?;
        self.e_rab_guaranteed_bitrate_ul.encode(data)?;

        Ok(())
    }
}

impl PerCodec for GbrQosInformation {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        GbrQosInformation::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("GbrQosInformation");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("GbrQosInformation");
            e
        })
    }
}
// GbrQosFlowInformation
#[derive(Clone, Debug)]
pub struct GbrQosFlowInformation {
    pub max_flow_bit_rate_downlink: BitRate,
    pub max_flow_bit_rate_uplink: BitRate,
    pub guaranteed_flow_bit_rate_downlink: BitRate,
    pub guaranteed_flow_bit_rate_uplink: BitRate,
    pub max_packet_loss_rate_downlink: Option<MaxPacketLossRate>,
    pub max_packet_loss_rate_uplink: Option<MaxPacketLossRate>,
    pub alternative_qos_para_set_list: Option<AlternativeQosParaSetList>,
}

impl GbrQosFlowInformation {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 3)?;
        let max_flow_bit_rate_downlink = BitRate::decode(data)?;
        let max_flow_bit_rate_uplink = BitRate::decode(data)?;
        let guaranteed_flow_bit_rate_downlink = BitRate::decode(data)?;
        let guaranteed_flow_bit_rate_uplink = BitRate::decode(data)?;
        let max_packet_loss_rate_downlink = if optionals[0] {
            Some(MaxPacketLossRate::decode(data)?)
        } else {
            None
        };
        let max_packet_loss_rate_uplink = if optionals[1] {
            Some(MaxPacketLossRate::decode(data)?)
        } else {
            None
        };

        // Process the extension container
        let mut alternative_qos_para_set_list: Option<AlternativeQosParaSetList> = None;

        if optionals[2] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    124 => {
                        alternative_qos_para_set_list =
                            Some(AlternativeQosParaSetList::decode(data)?)
                    }
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            max_flow_bit_rate_downlink,
            max_flow_bit_rate_uplink,
            guaranteed_flow_bit_rate_downlink,
            guaranteed_flow_bit_rate_uplink,
            max_packet_loss_rate_downlink,
            max_packet_loss_rate_uplink,
            alternative_qos_para_set_list,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();
        if let Some(x) = &self.alternative_qos_para_set_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 124, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        let mut optionals = BitString::new();
        optionals.push(self.max_packet_loss_rate_downlink.is_some());
        optionals.push(self.max_packet_loss_rate_uplink.is_some());
        optionals.push(num_ies != 0);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.max_flow_bit_rate_downlink.encode(data)?;
        self.max_flow_bit_rate_uplink.encode(data)?;
        self.guaranteed_flow_bit_rate_downlink.encode(data)?;
        self.guaranteed_flow_bit_rate_uplink.encode(data)?;
        if let Some(x) = &self.max_packet_loss_rate_downlink {
            x.encode(data)?;
        }
        if let Some(x) = &self.max_packet_loss_rate_uplink {
            x.encode(data)?;
        }
        if num_ies != 0 {
            encode::encode_length_determinent(data, Some(1), Some(65535), false, num_ies)?;
            data.append_aligned(ies);
        }
        Ok(())
    }
}

impl PerCodec for GbrQosFlowInformation {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        GbrQosFlowInformation::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("GbrQosFlowInformation");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("GbrQosFlowInformation");
            e
        })
    }
}
// GtptlAs
#[derive(Clone, Debug)]
pub struct GtptlAs(pub NonEmpty<GtptlaItem>);

impl GtptlAs {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(16), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(GtptlaItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(16), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for GtptlAs {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        GtptlAs::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("GtptlAs");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("GtptlAs");
            e
        })
    }
}
// GtptlaItem
#[derive(Clone, Debug)]
pub struct GtptlaItem {
    pub gtp_transport_layer_addresses: TransportLayerAddress,
}

impl GtptlaItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let gtp_transport_layer_addresses = TransportLayerAddress::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            gtp_transport_layer_addresses,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.gtp_transport_layer_addresses.encode(data)?;

        Ok(())
    }
}

impl PerCodec for GtptlaItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        GtptlaItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("GtptlaItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("GtptlaItem");
            e
        })
    }
}
// GnbCuUpOverloadInformation
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum GnbCuUpOverloadInformation {
    Overloaded,
    NotOverloaded,
}

impl GnbCuUpOverloadInformation {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(1), false)?;
        if extended {
            return Err(PerCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(data, Some(0), Some(1), false, *self as i128, false)
    }
}

impl PerCodec for GnbCuUpOverloadInformation {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        GnbCuUpOverloadInformation::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("GnbCuUpOverloadInformation");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("GnbCuUpOverloadInformation");
            e
        })
    }
}
// GnbDuId
#[derive(Clone, Copy, Debug)]
pub struct GnbDuId(pub u64);

impl GnbDuId {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(
            decode::decode_integer(data, Some(0), Some(68719476735), false)?.0 as u64,
        ))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_integer(
            data,
            Some(0),
            Some(68719476735),
            false,
            self.0 as i128,
            false,
        )
    }
}

impl PerCodec for GnbDuId {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        GnbDuId::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("GnbDuId");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("GnbDuId");
            e
        })
    }
}
// Hfn
#[derive(Clone, Copy, Debug)]
pub struct Hfn(pub u32);

impl Hfn {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(
            decode::decode_integer(data, Some(0), Some(4294967295), false)?.0 as u32,
        ))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_integer(
            data,
            Some(0),
            Some(4294967295),
            false,
            self.0 as i128,
            false,
        )
    }
}

impl PerCodec for Hfn {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Hfn::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("Hfn");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("Hfn");
            e
        })
    }
}
// HwCapacityIndicator
#[derive(Clone, Debug)]
pub struct HwCapacityIndicator {
    pub offered_throughput: u32,
    pub available_throughput: u8,
}

impl HwCapacityIndicator {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let offered_throughput =
            decode::decode_integer(data, Some(1), Some(16777216), true)?.0 as u32;
        let available_throughput = decode::decode_integer(data, Some(0), Some(100), true)?.0 as u8;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            offered_throughput,
            available_throughput,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        encode::encode_integer(
            data,
            Some(1),
            Some(16777216),
            true,
            self.offered_throughput as i128,
            false,
        )?;
        encode::encode_integer(
            data,
            Some(0),
            Some(100),
            true,
            self.available_throughput as i128,
            false,
        )?;

        Ok(())
    }
}

impl PerCodec for HwCapacityIndicator {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        HwCapacityIndicator::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("HwCapacityIndicator");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("HwCapacityIndicator");
            e
        })
    }
}
// IgnoreMappingRuleIndication
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum IgnoreMappingRuleIndication {
    True,
}

impl IgnoreMappingRuleIndication {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(0), true)?;
        if extended {
            return Err(PerCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(data, Some(0), Some(0), true, *self as i128, false)
    }
}

impl PerCodec for IgnoreMappingRuleIndication {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        IgnoreMappingRuleIndication::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("IgnoreMappingRuleIndication");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("IgnoreMappingRuleIndication");
            e
        })
    }
}
// IntegrityProtectionIndication
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum IntegrityProtectionIndication {
    Required,
    Preferred,
    NotNeeded,
}

impl IntegrityProtectionIndication {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(2), true)?;
        if extended {
            return Err(PerCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(data, Some(0), Some(2), true, *self as i128, false)
    }
}

impl PerCodec for IntegrityProtectionIndication {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        IntegrityProtectionIndication::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("IntegrityProtectionIndication");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("IntegrityProtectionIndication");
            e
        })
    }
}
// IntegrityProtectionAlgorithm
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum IntegrityProtectionAlgorithm {
    Nia0,
    I128Nia1,
    I128Nia2,
    I128Nia3,
}

impl IntegrityProtectionAlgorithm {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(3), true)?;
        if extended {
            return Err(PerCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(data, Some(0), Some(3), true, *self as i128, false)
    }
}

impl PerCodec for IntegrityProtectionAlgorithm {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        IntegrityProtectionAlgorithm::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("IntegrityProtectionAlgorithm");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("IntegrityProtectionAlgorithm");
            e
        })
    }
}
// IntegrityProtectionKey
#[derive(Clone, Debug)]
pub struct IntegrityProtectionKey(pub Vec<u8>);

impl IntegrityProtectionKey {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(decode::decode_octetstring(data, None, None, false)?))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_octetstring(data, None, None, false, &self.0, false)
    }
}

impl PerCodec for IntegrityProtectionKey {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        IntegrityProtectionKey::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("IntegrityProtectionKey");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("IntegrityProtectionKey");
            e
        })
    }
}
// IntegrityProtectionResult
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum IntegrityProtectionResult {
    Performed,
    NotPerformed,
}

impl IntegrityProtectionResult {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(1), true)?;
        if extended {
            return Err(PerCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(data, Some(0), Some(1), true, *self as i128, false)
    }
}

impl PerCodec for IntegrityProtectionResult {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        IntegrityProtectionResult::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("IntegrityProtectionResult");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("IntegrityProtectionResult");
            e
        })
    }
}
// InactivityTimer
#[derive(Clone, Copy, Debug)]
pub struct InactivityTimer(pub u16);

impl InactivityTimer {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(
            decode::decode_integer(data, Some(1), Some(7200), true)?.0 as u16,
        ))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_integer(data, Some(1), Some(7200), true, self.0 as i128, false)
    }
}

impl PerCodec for InactivityTimer {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        InactivityTimer::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("InactivityTimer");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("InactivityTimer");
            e
        })
    }
}
// InterfacesToTrace
#[derive(Clone, Debug)]
pub struct InterfacesToTrace(pub BitString);

impl InterfacesToTrace {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(decode::decode_bitstring(
            data,
            Some(8),
            Some(8),
            false,
        )?))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_bitstring(data, Some(8), Some(8), false, &self.0, false)
    }
}

impl PerCodec for InterfacesToTrace {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        InterfacesToTrace::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("InterfacesToTrace");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("InterfacesToTrace");
            e
        })
    }
}
// ImmediateMdt
#[derive(Clone, Debug)]
pub struct ImmediateMdt {
    pub measurements_to_activate: MeasurementsToActivate,
    pub measurement_four: Option<M4Configuration>,
    pub measurement_six: Option<M6Configuration>,
    pub measurement_seven: Option<M7Configuration>,
}

impl ImmediateMdt {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 4)?;
        let measurements_to_activate = MeasurementsToActivate::decode(data)?;
        let measurement_four = if optionals[0] {
            Some(M4Configuration::decode(data)?)
        } else {
            None
        };
        let measurement_six = if optionals[1] {
            Some(M6Configuration::decode(data)?)
        } else {
            None
        };
        let measurement_seven = if optionals[2] {
            Some(M7Configuration::decode(data)?)
        } else {
            None
        };

        // Process the extension container

        if optionals[3] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            measurements_to_activate,
            measurement_four,
            measurement_six,
            measurement_seven,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.measurement_four.is_some());
        optionals.push(self.measurement_six.is_some());
        optionals.push(self.measurement_seven.is_some());
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.measurements_to_activate.encode(data)?;
        if let Some(x) = &self.measurement_four {
            x.encode(data)?;
        }
        if let Some(x) = &self.measurement_six {
            x.encode(data)?;
        }
        if let Some(x) = &self.measurement_seven {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl PerCodec for ImmediateMdt {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        ImmediateMdt::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ImmediateMdt");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ImmediateMdt");
            e
        })
    }
}
// LinksToLog
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum LinksToLog {
    Uplink,
    Downlink,
    BothUplinkAndDownlink,
}

impl LinksToLog {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(2), true)?;
        if extended {
            return Err(PerCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(data, Some(0), Some(2), true, *self as i128, false)
    }
}

impl PerCodec for LinksToLog {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        LinksToLog::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("LinksToLog");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("LinksToLog");
            e
        })
    }
}
// MaxDataBurstVolume
#[derive(Clone, Copy, Debug)]
pub struct MaxDataBurstVolume(pub i128);

impl MaxDataBurstVolume {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(
            decode::decode_integer(data, Some(0), Some(4095), true)?.0,
        ))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_integer(data, Some(0), Some(4095), true, self.0, false)
    }
}

impl PerCodec for MaxDataBurstVolume {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        MaxDataBurstVolume::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MaxDataBurstVolume");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MaxDataBurstVolume");
            e
        })
    }
}
// MaximumIPdatarate
#[derive(Clone, Debug)]
pub struct MaximumIPdatarate {
    pub max_i_prate: MaxIPrate,
}

impl MaximumIPdatarate {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let max_i_prate = MaxIPrate::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self { max_i_prate })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.max_i_prate.encode(data)?;

        Ok(())
    }
}

impl PerCodec for MaximumIPdatarate {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        MaximumIPdatarate::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MaximumIPdatarate");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MaximumIPdatarate");
            e
        })
    }
}
// MaxIPrate
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum MaxIPrate {
    Bitrate64kbs,
    MaxUeRate,
}

impl MaxIPrate {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(1), true)?;
        if extended {
            return Err(PerCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(data, Some(0), Some(1), true, *self as i128, false)
    }
}

impl PerCodec for MaxIPrate {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        MaxIPrate::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MaxIPrate");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MaxIPrate");
            e
        })
    }
}
// MaxPacketLossRate
#[derive(Clone, Copy, Debug)]
pub struct MaxPacketLossRate(pub u16);

impl MaxPacketLossRate {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(
            decode::decode_integer(data, Some(0), Some(1000), true)?.0 as u16,
        ))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_integer(data, Some(0), Some(1000), true, self.0 as i128, false)
    }
}

impl PerCodec for MaxPacketLossRate {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        MaxPacketLossRate::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MaxPacketLossRate");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MaxPacketLossRate");
            e
        })
    }
}
// MaxCidehcDl
#[derive(Clone, Copy, Debug)]
pub struct MaxCidehcDl(pub u16);

impl MaxCidehcDl {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(
            decode::decode_integer(data, Some(1), Some(32767), true)?.0 as u16,
        ))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_integer(data, Some(1), Some(32767), true, self.0 as i128, false)
    }
}

impl PerCodec for MaxCidehcDl {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        MaxCidehcDl::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MaxCidehcDl");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MaxCidehcDl");
            e
        })
    }
}
// MrdcDataUsageReportItem
#[derive(Clone, Debug)]
pub struct MrdcDataUsageReportItem {
    pub start_time_stamp: [u8; 4],
    pub end_time_stamp: [u8; 4],
    pub usage_count_ul: u64,
    pub usage_count_dl: u64,
}

impl MrdcDataUsageReportItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let start_time_stamp = decode::decode_octetstring(data, Some(4), Some(4), false)?
            .try_into()
            .unwrap();
        let end_time_stamp = decode::decode_octetstring(data, Some(4), Some(4), false)?
            .try_into()
            .unwrap();
        let usage_count_ul = decode::decode_integer(data, Some(0), None, false)?.0 as u64;
        let usage_count_dl = decode::decode_integer(data, Some(0), None, false)?.0 as u64;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            start_time_stamp,
            end_time_stamp,
            usage_count_ul,
            usage_count_dl,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        encode::encode_octetstring(
            data,
            Some(4),
            Some(4),
            false,
            &(self.start_time_stamp).into(),
            false,
        )?;
        encode::encode_octetstring(
            data,
            Some(4),
            Some(4),
            false,
            &(self.end_time_stamp).into(),
            false,
        )?;
        encode::encode_integer(
            data,
            Some(0),
            None,
            false,
            self.usage_count_ul as i128,
            false,
        )?;
        encode::encode_integer(
            data,
            Some(0),
            None,
            false,
            self.usage_count_dl as i128,
            false,
        )?;

        Ok(())
    }
}

impl PerCodec for MrdcDataUsageReportItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        MrdcDataUsageReportItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MrdcDataUsageReportItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MrdcDataUsageReportItem");
            e
        })
    }
}
// MrdcUsageInformation
#[derive(Clone, Debug)]
pub struct MrdcUsageInformation {
    pub data_usage_per_pdu_session_report: Option<DataUsagePerPduSessionReport>,
    pub data_usage_per_qos_flow_list: Option<DataUsagePerQosFlowList>,
}

impl MrdcUsageInformation {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 3)?;
        let data_usage_per_pdu_session_report = if optionals[0] {
            Some(DataUsagePerPduSessionReport::decode(data)?)
        } else {
            None
        };
        let data_usage_per_qos_flow_list = if optionals[1] {
            Some(DataUsagePerQosFlowList::decode(data)?)
        } else {
            None
        };

        // Process the extension container

        if optionals[2] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            data_usage_per_pdu_session_report,
            data_usage_per_qos_flow_list,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.data_usage_per_pdu_session_report.is_some());
        optionals.push(self.data_usage_per_qos_flow_list.is_some());
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        if let Some(x) = &self.data_usage_per_pdu_session_report {
            x.encode(data)?;
        }
        if let Some(x) = &self.data_usage_per_qos_flow_list {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl PerCodec for MrdcUsageInformation {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        MrdcUsageInformation::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MrdcUsageInformation");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MrdcUsageInformation");
            e
        })
    }
}
// M4Configuration
#[derive(Clone, Debug)]
pub struct M4Configuration {
    pub m4period: M4period,
    pub m4_links_to_log: LinksToLog,
}

impl M4Configuration {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let m4period = M4period::decode(data)?;
        let m4_links_to_log = LinksToLog::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            m4period,
            m4_links_to_log,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.m4period.encode(data)?;
        self.m4_links_to_log.encode(data)?;

        Ok(())
    }
}

impl PerCodec for M4Configuration {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        M4Configuration::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("M4Configuration");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("M4Configuration");
            e
        })
    }
}
// M4period
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum M4period {
    Ms1024,
    Ms2048,
    Ms5120,
    Ms10240,
    Min1,
}

impl M4period {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(4), true)?;
        if extended {
            return Err(PerCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(data, Some(0), Some(4), true, *self as i128, false)
    }
}

impl PerCodec for M4period {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        M4period::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("M4period");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("M4period");
            e
        })
    }
}
// M6Configuration
#[derive(Clone, Debug)]
pub struct M6Configuration {
    pub m6report_interval: M6reportInterval,
    pub m6_links_to_log: LinksToLog,
}

impl M6Configuration {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let m6report_interval = M6reportInterval::decode(data)?;
        let m6_links_to_log = LinksToLog::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            m6report_interval,
            m6_links_to_log,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.m6report_interval.encode(data)?;
        self.m6_links_to_log.encode(data)?;

        Ok(())
    }
}

impl PerCodec for M6Configuration {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        M6Configuration::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("M6Configuration");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("M6Configuration");
            e
        })
    }
}
// M6reportInterval
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum M6reportInterval {
    Ms120,
    Ms240,
    Ms480,
    Ms640,
    Ms1024,
    Ms2048,
    Ms5120,
    Ms10240,
    Ms20480,
    Ms40960,
    Min1,
    Min6,
    Min12,
    Min30,
}

impl M6reportInterval {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(13), true)?;
        if extended {
            return Err(PerCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(data, Some(0), Some(13), true, *self as i128, false)
    }
}

impl PerCodec for M6reportInterval {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        M6reportInterval::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("M6reportInterval");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("M6reportInterval");
            e
        })
    }
}
// M7Configuration
#[derive(Clone, Debug)]
pub struct M7Configuration {
    pub m7period: M7period,
    pub m7_links_to_log: LinksToLog,
}

impl M7Configuration {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let m7period = M7period::decode(data)?;
        let m7_links_to_log = LinksToLog::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            m7period,
            m7_links_to_log,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.m7period.encode(data)?;
        self.m7_links_to_log.encode(data)?;

        Ok(())
    }
}

impl PerCodec for M7Configuration {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        M7Configuration::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("M7Configuration");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("M7Configuration");
            e
        })
    }
}
// M7period
#[derive(Clone, Copy, Debug)]
pub struct M7period(pub u8);

impl M7period {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(
            decode::decode_integer(data, Some(1), Some(60), true)?.0 as u8,
        ))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_integer(data, Some(1), Some(60), true, self.0 as i128, false)
    }
}

impl PerCodec for M7period {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        M7period::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("M7period");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("M7period");
            e
        })
    }
}
// MdtActivation
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum MdtActivation {
    ImmediateMdtOnly,
    ImmediateMdtAndTrace,
}

impl MdtActivation {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(1), true)?;
        if extended {
            return Err(PerCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(data, Some(0), Some(1), true, *self as i128, false)
    }
}

impl PerCodec for MdtActivation {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        MdtActivation::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MdtActivation");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MdtActivation");
            e
        })
    }
}
// MdtConfiguration
#[derive(Clone, Debug)]
pub struct MdtConfiguration {
    pub mdt_activation: MdtActivation,
    pub mdt_mode: MdtMode,
}

impl MdtConfiguration {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let mdt_activation = MdtActivation::decode(data)?;
        let mdt_mode = MdtMode::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            mdt_activation,
            mdt_mode,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.mdt_activation.encode(data)?;
        self.mdt_mode.encode(data)?;

        Ok(())
    }
}

impl PerCodec for MdtConfiguration {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        MdtConfiguration::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MdtConfiguration");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MdtConfiguration");
            e
        })
    }
}
// MdtMode
#[derive(Clone, Debug)]
pub enum MdtMode {
    ImmediateMdt(ImmediateMdt),
}

impl MdtMode {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_choice_idx(data, 0, 1, false)?;
        if extended {
            return Err(PerCodecError::new("CHOICE additions not implemented"));
        }
        match idx {
            0 => Ok(Self::ImmediateMdt(ImmediateMdt::decode(data)?)),
            1 => {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _ = Criticality::decode(data)?;
                let _ = decode::decode_length_determinent(data, None, None, false)?;
                let result = match id {
                    x => Err(PerCodecError::new(format!("Unrecognised IE type {}", x))),
                };
                data.decode_align()?;
                result
            }
            _ => Err(PerCodecError::new("Unknown choice idx")),
        }
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        match self {
            Self::ImmediateMdt(x) => {
                encode::encode_choice_idx(data, 0, 1, false, 0, false)?;
                x.encode(data)
            }
        }
    }
}

impl PerCodec for MdtMode {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        MdtMode::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MdtMode");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MdtMode");
            e
        })
    }
}
// MeasurementsToActivate
#[derive(Clone, Debug)]
pub struct MeasurementsToActivate(pub BitString);

impl MeasurementsToActivate {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(decode::decode_bitstring(
            data,
            Some(8),
            Some(8),
            false,
        )?))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_bitstring(data, Some(8), Some(8), false, &self.0, false)
    }
}

impl PerCodec for MeasurementsToActivate {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        MeasurementsToActivate::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MeasurementsToActivate");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MeasurementsToActivate");
            e
        })
    }
}
// MdtPlmnList
#[derive(Clone, Debug)]
pub struct MdtPlmnList(pub NonEmpty<PlmnIdentity>);

impl MdtPlmnList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(16), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(PlmnIdentity::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(16), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for MdtPlmnList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        MdtPlmnList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MdtPlmnList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MdtPlmnList");
            e
        })
    }
}
// NetworkInstance
#[derive(Clone, Copy, Debug)]
pub struct NetworkInstance(pub u16);

impl NetworkInstance {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(
            decode::decode_integer(data, Some(1), Some(256), true)?.0 as u16,
        ))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_integer(data, Some(1), Some(256), true, self.0 as i128, false)
    }
}

impl PerCodec for NetworkInstance {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        NetworkInstance::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NetworkInstance");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NetworkInstance");
            e
        })
    }
}
// NewUlTnlInformationRequired
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum NewUlTnlInformationRequired {
    Required,
}

impl NewUlTnlInformationRequired {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(0), true)?;
        if extended {
            return Err(PerCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(data, Some(0), Some(0), true, *self as i128, false)
    }
}

impl PerCodec for NewUlTnlInformationRequired {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        NewUlTnlInformationRequired::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NewUlTnlInformationRequired");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NewUlTnlInformationRequired");
            e
        })
    }
}
// NgranAllocationAndRetentionPriority
#[derive(Clone, Debug)]
pub struct NgranAllocationAndRetentionPriority {
    pub priority_level: PriorityLevel,
    pub pre_emption_capability: PreEmptionCapability,
    pub pre_emption_vulnerability: PreEmptionVulnerability,
}

impl NgranAllocationAndRetentionPriority {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, false, 1)?;
        let priority_level = PriorityLevel::decode(data)?;
        let pre_emption_capability = PreEmptionCapability::decode(data)?;
        let pre_emption_vulnerability = PreEmptionVulnerability::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            priority_level,
            pre_emption_capability,
            pre_emption_vulnerability,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, false, &optionals, false)?;
        self.priority_level.encode(data)?;
        self.pre_emption_capability.encode(data)?;
        self.pre_emption_vulnerability.encode(data)?;

        Ok(())
    }
}

impl PerCodec for NgranAllocationAndRetentionPriority {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        NgranAllocationAndRetentionPriority::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NgranAllocationAndRetentionPriority");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NgranAllocationAndRetentionPriority");
            e
        })
    }
}
// NgRanQosSupportList
#[derive(Clone, Debug)]
pub struct NgRanQosSupportList(pub NonEmpty<NgRanQosSupportItem>);

impl NgRanQosSupportList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(256), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(NgRanQosSupportItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(256), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for NgRanQosSupportList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        NgRanQosSupportList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NgRanQosSupportList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NgRanQosSupportList");
            e
        })
    }
}
// NgRanQosSupportItem
#[derive(Clone, Debug)]
pub struct NgRanQosSupportItem {
    pub non_dynamic_5qi_descriptor: NonDynamic5qiDescriptor,
}

impl NgRanQosSupportItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, false, 1)?;
        let non_dynamic_5qi_descriptor = NonDynamic5qiDescriptor::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            non_dynamic_5qi_descriptor,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, false, &optionals, false)?;
        self.non_dynamic_5qi_descriptor.encode(data)?;

        Ok(())
    }
}

impl PerCodec for NgRanQosSupportItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        NgRanQosSupportItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NgRanQosSupportItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NgRanQosSupportItem");
            e
        })
    }
}
// Nid
#[derive(Clone, Debug)]
pub struct Nid(pub BitString);

impl Nid {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(decode::decode_bitstring(
            data,
            Some(44),
            Some(44),
            false,
        )?))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_bitstring(data, Some(44), Some(44), false, &self.0, false)
    }
}

impl PerCodec for Nid {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Nid::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("Nid");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("Nid");
            e
        })
    }
}
// NonDynamic5qiDescriptor
#[derive(Clone, Debug)]
pub struct NonDynamic5qiDescriptor {
    pub five_qi: u8,
    pub qos_priority_level: Option<QosPriorityLevel>,
    pub averaging_window: Option<AveragingWindow>,
    pub max_data_burst_volume: Option<MaxDataBurstVolume>,
    pub cn_packet_delay_budget_downlink: Option<ExtendedPacketDelayBudget>,
    pub cn_packet_delay_budget_uplink: Option<ExtendedPacketDelayBudget>,
}

impl NonDynamic5qiDescriptor {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, false, 4)?;
        let five_qi = decode::decode_integer(data, Some(0), Some(255), true)?.0 as u8;
        let qos_priority_level = if optionals[0] {
            Some(QosPriorityLevel::decode(data)?)
        } else {
            None
        };
        let averaging_window = if optionals[1] {
            Some(AveragingWindow::decode(data)?)
        } else {
            None
        };
        let max_data_burst_volume = if optionals[2] {
            Some(MaxDataBurstVolume::decode(data)?)
        } else {
            None
        };

        // Process the extension container
        let mut cn_packet_delay_budget_downlink: Option<ExtendedPacketDelayBudget> = None;
        let mut cn_packet_delay_budget_uplink: Option<ExtendedPacketDelayBudget> = None;

        if optionals[3] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    101 => {
                        cn_packet_delay_budget_downlink =
                            Some(ExtendedPacketDelayBudget::decode(data)?)
                    }
                    102 => {
                        cn_packet_delay_budget_uplink =
                            Some(ExtendedPacketDelayBudget::decode(data)?)
                    }
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            five_qi,
            qos_priority_level,
            averaging_window,
            max_data_burst_volume,
            cn_packet_delay_budget_downlink,
            cn_packet_delay_budget_uplink,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();
        if let Some(x) = &self.cn_packet_delay_budget_downlink {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 101, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.cn_packet_delay_budget_uplink {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 102, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        let mut optionals = BitString::new();
        optionals.push(self.qos_priority_level.is_some());
        optionals.push(self.averaging_window.is_some());
        optionals.push(self.max_data_burst_volume.is_some());
        optionals.push(num_ies != 0);

        encode::encode_sequence_header(data, false, &optionals, false)?;
        encode::encode_integer(data, Some(0), Some(255), true, self.five_qi as i128, false)?;
        if let Some(x) = &self.qos_priority_level {
            x.encode(data)?;
        }
        if let Some(x) = &self.averaging_window {
            x.encode(data)?;
        }
        if let Some(x) = &self.max_data_burst_volume {
            x.encode(data)?;
        }
        if num_ies != 0 {
            encode::encode_length_determinent(data, Some(1), Some(65535), false, num_ies)?;
            data.append_aligned(ies);
        }
        Ok(())
    }
}

impl PerCodec for NonDynamic5qiDescriptor {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        NonDynamic5qiDescriptor::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NonDynamic5qiDescriptor");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NonDynamic5qiDescriptor");
            e
        })
    }
}
// NpnSupportInfo
#[derive(Clone, Debug)]
pub enum NpnSupportInfo {
    Snpn(NpnSupportInfoSnpn),
}

impl NpnSupportInfo {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_choice_idx(data, 0, 1, false)?;
        if extended {
            return Err(PerCodecError::new("CHOICE additions not implemented"));
        }
        match idx {
            0 => Ok(Self::Snpn(NpnSupportInfoSnpn::decode(data)?)),
            1 => {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _ = Criticality::decode(data)?;
                let _ = decode::decode_length_determinent(data, None, None, false)?;
                let result = match id {
                    x => Err(PerCodecError::new(format!("Unrecognised IE type {}", x))),
                };
                data.decode_align()?;
                result
            }
            _ => Err(PerCodecError::new("Unknown choice idx")),
        }
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        match self {
            Self::Snpn(x) => {
                encode::encode_choice_idx(data, 0, 1, false, 0, false)?;
                x.encode(data)
            }
        }
    }
}

impl PerCodec for NpnSupportInfo {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        NpnSupportInfo::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NpnSupportInfo");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NpnSupportInfo");
            e
        })
    }
}
// NpnSupportInfoSnpn
#[derive(Clone, Debug)]
pub struct NpnSupportInfoSnpn {
    pub nid: Nid,
}

impl NpnSupportInfoSnpn {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, false, 1)?;
        let nid = Nid::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self { nid })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, false, &optionals, false)?;
        self.nid.encode(data)?;

        Ok(())
    }
}

impl PerCodec for NpnSupportInfoSnpn {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        NpnSupportInfoSnpn::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NpnSupportInfoSnpn");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NpnSupportInfoSnpn");
            e
        })
    }
}
// NpnContextInfo
#[derive(Clone, Debug)]
pub enum NpnContextInfo {
    Snpn(NpnContextInfoSnpn),
}

impl NpnContextInfo {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_choice_idx(data, 0, 1, false)?;
        if extended {
            return Err(PerCodecError::new("CHOICE additions not implemented"));
        }
        match idx {
            0 => Ok(Self::Snpn(NpnContextInfoSnpn::decode(data)?)),
            1 => {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _ = Criticality::decode(data)?;
                let _ = decode::decode_length_determinent(data, None, None, false)?;
                let result = match id {
                    x => Err(PerCodecError::new(format!("Unrecognised IE type {}", x))),
                };
                data.decode_align()?;
                result
            }
            _ => Err(PerCodecError::new("Unknown choice idx")),
        }
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        match self {
            Self::Snpn(x) => {
                encode::encode_choice_idx(data, 0, 1, false, 0, false)?;
                x.encode(data)
            }
        }
    }
}

impl PerCodec for NpnContextInfo {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        NpnContextInfo::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NpnContextInfo");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NpnContextInfo");
            e
        })
    }
}
// NpnContextInfoSnpn
#[derive(Clone, Debug)]
pub struct NpnContextInfoSnpn {
    pub nid: Nid,
}

impl NpnContextInfoSnpn {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, false, 1)?;
        let nid = Nid::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self { nid })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, false, &optionals, false)?;
        self.nid.encode(data)?;

        Ok(())
    }
}

impl PerCodec for NpnContextInfoSnpn {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        NpnContextInfoSnpn::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NpnContextInfoSnpn");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NpnContextInfoSnpn");
            e
        })
    }
}
// NrCellIdentity
#[derive(Clone, Debug)]
pub struct NrCellIdentity(pub BitString);

impl NrCellIdentity {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(decode::decode_bitstring(
            data,
            Some(36),
            Some(36),
            false,
        )?))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_bitstring(data, Some(36), Some(36), false, &self.0, false)
    }
}

impl PerCodec for NrCellIdentity {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        NrCellIdentity::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NrCellIdentity");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NrCellIdentity");
            e
        })
    }
}
// NrCgi
#[derive(Clone, Debug)]
pub struct NrCgi {
    pub plmn_identity: PlmnIdentity,
    pub nr_cell_identity: NrCellIdentity,
}

impl NrCgi {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, false, 1)?;
        let plmn_identity = PlmnIdentity::decode(data)?;
        let nr_cell_identity = NrCellIdentity::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            plmn_identity,
            nr_cell_identity,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, false, &optionals, false)?;
        self.plmn_identity.encode(data)?;
        self.nr_cell_identity.encode(data)?;

        Ok(())
    }
}

impl PerCodec for NrCgi {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        NrCgi::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NrCgi");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NrCgi");
            e
        })
    }
}
// NrCgiSupportList
#[derive(Clone, Debug)]
pub struct NrCgiSupportList(pub NonEmpty<NrCgiSupportItem>);

impl NrCgiSupportList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(512), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(NrCgiSupportItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(512), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for NrCgiSupportList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        NrCgiSupportList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NrCgiSupportList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NrCgiSupportList");
            e
        })
    }
}
// NrCgiSupportItem
#[derive(Clone, Debug)]
pub struct NrCgiSupportItem {
    pub nr_cgi: NrCgi,
}

impl NrCgiSupportItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, false, 1)?;
        let nr_cgi = NrCgi::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self { nr_cgi })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, false, &optionals, false)?;
        self.nr_cgi.encode(data)?;

        Ok(())
    }
}

impl PerCodec for NrCgiSupportItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        NrCgiSupportItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NrCgiSupportItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NrCgiSupportItem");
            e
        })
    }
}
// ExtendedNrCgiSupportList
#[derive(Clone, Debug)]
pub struct ExtendedNrCgiSupportList(pub NonEmpty<ExtendedNrCgiSupportItem>);

impl ExtendedNrCgiSupportList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(16384), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(ExtendedNrCgiSupportItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(16384), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for ExtendedNrCgiSupportList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        ExtendedNrCgiSupportList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ExtendedNrCgiSupportList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ExtendedNrCgiSupportList");
            e
        })
    }
}
// ExtendedNrCgiSupportItem
#[derive(Clone, Debug)]
pub struct ExtendedNrCgiSupportItem {
    pub nr_cgi: NrCgi,
}

impl ExtendedNrCgiSupportItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, false, 1)?;
        let nr_cgi = NrCgi::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self { nr_cgi })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, false, &optionals, false)?;
        self.nr_cgi.encode(data)?;

        Ok(())
    }
}

impl PerCodec for ExtendedNrCgiSupportItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        ExtendedNrCgiSupportItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ExtendedNrCgiSupportItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ExtendedNrCgiSupportItem");
            e
        })
    }
}
// OutOfOrderDelivery
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum OutOfOrderDelivery {
    True,
}

impl OutOfOrderDelivery {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(0), true)?;
        if extended {
            return Err(PerCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(data, Some(0), Some(0), true, *self as i128, false)
    }
}

impl PerCodec for OutOfOrderDelivery {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        OutOfOrderDelivery::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("OutOfOrderDelivery");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("OutOfOrderDelivery");
            e
        })
    }
}
// PacketDelayBudget
#[derive(Clone, Copy, Debug)]
pub struct PacketDelayBudget(pub u16);

impl PacketDelayBudget {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(
            decode::decode_integer(data, Some(0), Some(1023), true)?.0 as u16,
        ))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_integer(data, Some(0), Some(1023), true, self.0 as i128, false)
    }
}

impl PerCodec for PacketDelayBudget {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PacketDelayBudget::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PacketDelayBudget");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PacketDelayBudget");
            e
        })
    }
}
// PacketErrorRate
#[derive(Clone, Debug)]
pub struct PacketErrorRate {
    pub per_scalar: PerScalar,
    pub per_exponent: PerExponent,
}

impl PacketErrorRate {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let per_scalar = PerScalar::decode(data)?;
        let per_exponent = PerExponent::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            per_scalar,
            per_exponent,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.per_scalar.encode(data)?;
        self.per_exponent.encode(data)?;

        Ok(())
    }
}

impl PerCodec for PacketErrorRate {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PacketErrorRate::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PacketErrorRate");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PacketErrorRate");
            e
        })
    }
}
// PerScalar
#[derive(Clone, Copy, Debug)]
pub struct PerScalar(pub u8);

impl PerScalar {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(
            decode::decode_integer(data, Some(0), Some(9), true)?.0 as u8,
        ))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_integer(data, Some(0), Some(9), true, self.0 as i128, false)
    }
}

impl PerCodec for PerScalar {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PerScalar::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PerScalar");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PerScalar");
            e
        })
    }
}
// PerExponent
#[derive(Clone, Copy, Debug)]
pub struct PerExponent(pub u8);

impl PerExponent {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(
            decode::decode_integer(data, Some(0), Some(9), true)?.0 as u8,
        ))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_integer(data, Some(0), Some(9), true, self.0 as i128, false)
    }
}

impl PerCodec for PerExponent {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PerExponent::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PerExponent");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PerExponent");
            e
        })
    }
}
// PdcpConfiguration
#[derive(Clone, Debug)]
pub struct PdcpConfiguration {
    pub pdcp_sn_size_ul: PdcpSnSize,
    pub pdcp_sn_size_dl: PdcpSnSize,
    pub rlc_mode: RlcMode,
    pub rohc_parameters: Option<RohcParameters>,
    pub t_reordering_timer: Option<TReorderingTimer>,
    pub discard_timer: Option<DiscardTimer>,
    pub ul_data_split_threshold: Option<UlDataSplitThreshold>,
    pub pdcp_duplication: Option<PdcpDuplication>,
    pub pdcp_reestablishment: Option<PdcpReestablishment>,
    pub pdcp_data_recovery: Option<PdcpDataRecovery>,
    pub duplication_activation: Option<DuplicationActivation>,
    pub out_of_order_delivery: Option<OutOfOrderDelivery>,
    pub pdcp_status_report_indication: Option<PdcpStatusReportIndication>,
    pub additional_pdc_pduplication_information: Option<AdditionalPdcPduplicationInformation>,
    pub ehc_parameters: Option<EhcParameters>,
}

impl PdcpConfiguration {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 10)?;
        let pdcp_sn_size_ul = PdcpSnSize::decode(data)?;
        let pdcp_sn_size_dl = PdcpSnSize::decode(data)?;
        let rlc_mode = RlcMode::decode(data)?;
        let rohc_parameters = if optionals[0] {
            Some(RohcParameters::decode(data)?)
        } else {
            None
        };
        let t_reordering_timer = if optionals[1] {
            Some(TReorderingTimer::decode(data)?)
        } else {
            None
        };
        let discard_timer = if optionals[2] {
            Some(DiscardTimer::decode(data)?)
        } else {
            None
        };
        let ul_data_split_threshold = if optionals[3] {
            Some(UlDataSplitThreshold::decode(data)?)
        } else {
            None
        };
        let pdcp_duplication = if optionals[4] {
            Some(PdcpDuplication::decode(data)?)
        } else {
            None
        };
        let pdcp_reestablishment = if optionals[5] {
            Some(PdcpReestablishment::decode(data)?)
        } else {
            None
        };
        let pdcp_data_recovery = if optionals[6] {
            Some(PdcpDataRecovery::decode(data)?)
        } else {
            None
        };
        let duplication_activation = if optionals[7] {
            Some(DuplicationActivation::decode(data)?)
        } else {
            None
        };
        let out_of_order_delivery = if optionals[8] {
            Some(OutOfOrderDelivery::decode(data)?)
        } else {
            None
        };

        // Process the extension container
        let mut pdcp_status_report_indication: Option<PdcpStatusReportIndication> = None;
        let mut additional_pdc_pduplication_information: Option<
            AdditionalPdcPduplicationInformation,
        > = None;
        let mut ehc_parameters: Option<EhcParameters> = None;

        if optionals[9] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    88 => {
                        pdcp_status_report_indication =
                            Some(PdcpStatusReportIndication::decode(data)?)
                    }
                    104 => {
                        additional_pdc_pduplication_information =
                            Some(AdditionalPdcPduplicationInformation::decode(data)?)
                    }
                    118 => ehc_parameters = Some(EhcParameters::decode(data)?),
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            pdcp_sn_size_ul,
            pdcp_sn_size_dl,
            rlc_mode,
            rohc_parameters,
            t_reordering_timer,
            discard_timer,
            ul_data_split_threshold,
            pdcp_duplication,
            pdcp_reestablishment,
            pdcp_data_recovery,
            duplication_activation,
            out_of_order_delivery,
            pdcp_status_report_indication,
            additional_pdc_pduplication_information,
            ehc_parameters,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();
        if let Some(x) = &self.pdcp_status_report_indication {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 88, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.additional_pdc_pduplication_information {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 104, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.ehc_parameters {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 118, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        let mut optionals = BitString::new();
        optionals.push(self.rohc_parameters.is_some());
        optionals.push(self.t_reordering_timer.is_some());
        optionals.push(self.discard_timer.is_some());
        optionals.push(self.ul_data_split_threshold.is_some());
        optionals.push(self.pdcp_duplication.is_some());
        optionals.push(self.pdcp_reestablishment.is_some());
        optionals.push(self.pdcp_data_recovery.is_some());
        optionals.push(self.duplication_activation.is_some());
        optionals.push(self.out_of_order_delivery.is_some());
        optionals.push(num_ies != 0);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.pdcp_sn_size_ul.encode(data)?;
        self.pdcp_sn_size_dl.encode(data)?;
        self.rlc_mode.encode(data)?;
        if let Some(x) = &self.rohc_parameters {
            x.encode(data)?;
        }
        if let Some(x) = &self.t_reordering_timer {
            x.encode(data)?;
        }
        if let Some(x) = &self.discard_timer {
            x.encode(data)?;
        }
        if let Some(x) = &self.ul_data_split_threshold {
            x.encode(data)?;
        }
        if let Some(x) = &self.pdcp_duplication {
            x.encode(data)?;
        }
        if let Some(x) = &self.pdcp_reestablishment {
            x.encode(data)?;
        }
        if let Some(x) = &self.pdcp_data_recovery {
            x.encode(data)?;
        }
        if let Some(x) = &self.duplication_activation {
            x.encode(data)?;
        }
        if let Some(x) = &self.out_of_order_delivery {
            x.encode(data)?;
        }
        if num_ies != 0 {
            encode::encode_length_determinent(data, Some(1), Some(65535), false, num_ies)?;
            data.append_aligned(ies);
        }
        Ok(())
    }
}

impl PerCodec for PdcpConfiguration {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PdcpConfiguration::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PdcpConfiguration");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PdcpConfiguration");
            e
        })
    }
}
// PdcpCount
#[derive(Clone, Debug)]
pub struct PdcpCount {
    pub pdcp_sn: PdcpSn,
    pub hfn: Hfn,
}

impl PdcpCount {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let pdcp_sn = PdcpSn::decode(data)?;
        let hfn = Hfn::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self { pdcp_sn, hfn })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.pdcp_sn.encode(data)?;
        self.hfn.encode(data)?;

        Ok(())
    }
}

impl PerCodec for PdcpCount {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PdcpCount::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PdcpCount");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PdcpCount");
            e
        })
    }
}
// PdcpSnStatusRequest
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum PdcpSnStatusRequest {
    Requested,
}

impl PdcpSnStatusRequest {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(0), true)?;
        if extended {
            return Err(PerCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(data, Some(0), Some(0), true, *self as i128, false)
    }
}

impl PerCodec for PdcpSnStatusRequest {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PdcpSnStatusRequest::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PdcpSnStatusRequest");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PdcpSnStatusRequest");
            e
        })
    }
}
// PdcpDataRecovery
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum PdcpDataRecovery {
    True,
}

impl PdcpDataRecovery {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(0), true)?;
        if extended {
            return Err(PerCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(data, Some(0), Some(0), true, *self as i128, false)
    }
}

impl PerCodec for PdcpDataRecovery {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PdcpDataRecovery::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PdcpDataRecovery");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PdcpDataRecovery");
            e
        })
    }
}
// PdcpDuplication
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum PdcpDuplication {
    True,
}

impl PdcpDuplication {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(0), true)?;
        if extended {
            return Err(PerCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(data, Some(0), Some(0), true, *self as i128, false)
    }
}

impl PerCodec for PdcpDuplication {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PdcpDuplication::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PdcpDuplication");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PdcpDuplication");
            e
        })
    }
}
// PdcpReestablishment
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum PdcpReestablishment {
    True,
}

impl PdcpReestablishment {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(0), true)?;
        if extended {
            return Err(PerCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(data, Some(0), Some(0), true, *self as i128, false)
    }
}

impl PerCodec for PdcpReestablishment {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PdcpReestablishment::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PdcpReestablishment");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PdcpReestablishment");
            e
        })
    }
}
// PduSessionResourceDataUsageList
#[derive(Clone, Debug)]
pub struct PduSessionResourceDataUsageList(pub NonEmpty<PduSessionResourceDataUsageItem>);

impl PduSessionResourceDataUsageList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(256), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(PduSessionResourceDataUsageItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(256), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for PduSessionResourceDataUsageList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PduSessionResourceDataUsageList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PduSessionResourceDataUsageList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PduSessionResourceDataUsageList");
            e
        })
    }
}
// PduSessionResourceDataUsageItem
#[derive(Clone, Debug)]
pub struct PduSessionResourceDataUsageItem {
    pub pdu_session_id: PduSessionId,
    pub mrdc_usage_information: MrdcUsageInformation,
}

impl PduSessionResourceDataUsageItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let pdu_session_id = PduSessionId::decode(data)?;
        let mrdc_usage_information = MrdcUsageInformation::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            pdu_session_id,
            mrdc_usage_information,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.pdu_session_id.encode(data)?;
        self.mrdc_usage_information.encode(data)?;

        Ok(())
    }
}

impl PerCodec for PduSessionResourceDataUsageItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PduSessionResourceDataUsageItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PduSessionResourceDataUsageItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PduSessionResourceDataUsageItem");
            e
        })
    }
}
// PdcpSn
#[derive(Clone, Copy, Debug)]
pub struct PdcpSn(pub u32);

impl PdcpSn {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(
            decode::decode_integer(data, Some(0), Some(262143), false)?.0 as u32,
        ))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_integer(data, Some(0), Some(262143), false, self.0 as i128, false)
    }
}

impl PerCodec for PdcpSn {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PdcpSn::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PdcpSn");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PdcpSn");
            e
        })
    }
}
// PdcpSnSize
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum PdcpSnSize {
    S12,
    S18,
}

impl PdcpSnSize {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(1), true)?;
        if extended {
            return Err(PerCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(data, Some(0), Some(1), true, *self as i128, false)
    }
}

impl PerCodec for PdcpSnSize {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PdcpSnSize::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PdcpSnSize");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PdcpSnSize");
            e
        })
    }
}
// PdcpSnStatusInformation
#[derive(Clone, Debug)]
pub struct PdcpSnStatusInformation {
    pub pdcp_status_transfer_ul: DrbBStatusTransfer,
    pub pdcp_status_transfer_dl: PdcpCount,
}

impl PdcpSnStatusInformation {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let pdcp_status_transfer_ul = DrbBStatusTransfer::decode(data)?;
        let pdcp_status_transfer_dl = PdcpCount::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            pdcp_status_transfer_ul,
            pdcp_status_transfer_dl,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.pdcp_status_transfer_ul.encode(data)?;
        self.pdcp_status_transfer_dl.encode(data)?;

        Ok(())
    }
}

impl PerCodec for PdcpSnStatusInformation {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PdcpSnStatusInformation::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PdcpSnStatusInformation");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PdcpSnStatusInformation");
            e
        })
    }
}
// PdcpStatusReportIndication
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum PdcpStatusReportIndication {
    Downlink,
    Uplink,
    Both,
}

impl PdcpStatusReportIndication {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(2), true)?;
        if extended {
            return Err(PerCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(data, Some(0), Some(2), true, *self as i128, false)
    }
}

impl PerCodec for PdcpStatusReportIndication {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PdcpStatusReportIndication::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PdcpStatusReportIndication");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PdcpStatusReportIndication");
            e
        })
    }
}
// DrbBStatusTransfer
#[derive(Clone, Debug)]
pub struct DrbBStatusTransfer {
    pub receive_statusof_pdcps_du: Option<BitString>,
    pub count_value: PdcpCount,
}

impl DrbBStatusTransfer {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 2)?;
        let receive_statusof_pdcps_du = if optionals[0] {
            Some(decode::decode_bitstring(
                data,
                Some(1),
                Some(131072),
                false,
            )?)
        } else {
            None
        };
        let count_value = PdcpCount::decode(data)?;

        // Process the extension container

        if optionals[1] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            receive_statusof_pdcps_du,
            count_value,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.receive_statusof_pdcps_du.is_some());
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        if let Some(x) = &self.receive_statusof_pdcps_du {
            encode::encode_bitstring(data, Some(1), Some(131072), false, &x, false)?;
        }
        self.count_value.encode(data)?;

        Ok(())
    }
}

impl PerCodec for DrbBStatusTransfer {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        DrbBStatusTransfer::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DrbBStatusTransfer");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DrbBStatusTransfer");
            e
        })
    }
}
// PduSessionResourceActivity
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum PduSessionResourceActivity {
    Active,
    NotActive,
}

impl PduSessionResourceActivity {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(1), true)?;
        if extended {
            return Err(PerCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(data, Some(0), Some(1), true, *self as i128, false)
    }
}

impl PerCodec for PduSessionResourceActivity {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PduSessionResourceActivity::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PduSessionResourceActivity");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PduSessionResourceActivity");
            e
        })
    }
}
// PduSessionResourceActivityList
#[derive(Clone, Debug)]
pub struct PduSessionResourceActivityList(pub NonEmpty<PduSessionResourceActivityItem>);

impl PduSessionResourceActivityList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(256), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(PduSessionResourceActivityItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(256), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for PduSessionResourceActivityList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PduSessionResourceActivityList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PduSessionResourceActivityList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PduSessionResourceActivityList");
            e
        })
    }
}
// PduSessionResourceActivityItem
#[derive(Clone, Debug)]
pub struct PduSessionResourceActivityItem {
    pub pdu_session_id: PduSessionId,
    pub pdu_session_resource_activity: PduSessionResourceActivity,
}

impl PduSessionResourceActivityItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let pdu_session_id = PduSessionId::decode(data)?;
        let pdu_session_resource_activity = PduSessionResourceActivity::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            pdu_session_id,
            pdu_session_resource_activity,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.pdu_session_id.encode(data)?;
        self.pdu_session_resource_activity.encode(data)?;

        Ok(())
    }
}

impl PerCodec for PduSessionResourceActivityItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PduSessionResourceActivityItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PduSessionResourceActivityItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PduSessionResourceActivityItem");
            e
        })
    }
}
// PduSessionResourceConfirmModifiedList
#[derive(Clone, Debug)]
pub struct PduSessionResourceConfirmModifiedList(
    pub NonEmpty<PduSessionResourceConfirmModifiedItem>,
);

impl PduSessionResourceConfirmModifiedList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(256), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(PduSessionResourceConfirmModifiedItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(256), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for PduSessionResourceConfirmModifiedList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PduSessionResourceConfirmModifiedList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PduSessionResourceConfirmModifiedList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PduSessionResourceConfirmModifiedList");
            e
        })
    }
}
// PduSessionResourceConfirmModifiedItem
#[derive(Clone, Debug)]
pub struct PduSessionResourceConfirmModifiedItem {
    pub pdu_session_id: PduSessionId,
    pub drb_confirm_modified_list_ng_ran: Option<DrbConfirmModifiedListNgRan>,
}

impl PduSessionResourceConfirmModifiedItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 2)?;
        let pdu_session_id = PduSessionId::decode(data)?;
        let drb_confirm_modified_list_ng_ran = if optionals[0] {
            Some(DrbConfirmModifiedListNgRan::decode(data)?)
        } else {
            None
        };

        // Process the extension container

        if optionals[1] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            pdu_session_id,
            drb_confirm_modified_list_ng_ran,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.drb_confirm_modified_list_ng_ran.is_some());
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.pdu_session_id.encode(data)?;
        if let Some(x) = &self.drb_confirm_modified_list_ng_ran {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl PerCodec for PduSessionResourceConfirmModifiedItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PduSessionResourceConfirmModifiedItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PduSessionResourceConfirmModifiedItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PduSessionResourceConfirmModifiedItem");
            e
        })
    }
}
// PduSessionResourceFailedList
#[derive(Clone, Debug)]
pub struct PduSessionResourceFailedList(pub NonEmpty<PduSessionResourceFailedItem>);

impl PduSessionResourceFailedList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(256), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(PduSessionResourceFailedItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(256), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for PduSessionResourceFailedList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PduSessionResourceFailedList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PduSessionResourceFailedList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PduSessionResourceFailedList");
            e
        })
    }
}
// PduSessionResourceFailedItem
#[derive(Clone, Debug)]
pub struct PduSessionResourceFailedItem {
    pub pdu_session_id: PduSessionId,
    pub cause: Cause,
}

impl PduSessionResourceFailedItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let pdu_session_id = PduSessionId::decode(data)?;
        let cause = Cause::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            pdu_session_id,
            cause,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.pdu_session_id.encode(data)?;
        self.cause.encode(data)?;

        Ok(())
    }
}

impl PerCodec for PduSessionResourceFailedItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PduSessionResourceFailedItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PduSessionResourceFailedItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PduSessionResourceFailedItem");
            e
        })
    }
}
// PduSessionResourceFailedModList
#[derive(Clone, Debug)]
pub struct PduSessionResourceFailedModList(pub NonEmpty<PduSessionResourceFailedModItem>);

impl PduSessionResourceFailedModList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(256), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(PduSessionResourceFailedModItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(256), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for PduSessionResourceFailedModList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PduSessionResourceFailedModList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PduSessionResourceFailedModList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PduSessionResourceFailedModList");
            e
        })
    }
}
// PduSessionResourceFailedModItem
#[derive(Clone, Debug)]
pub struct PduSessionResourceFailedModItem {
    pub pdu_session_id: PduSessionId,
    pub cause: Cause,
}

impl PduSessionResourceFailedModItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let pdu_session_id = PduSessionId::decode(data)?;
        let cause = Cause::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            pdu_session_id,
            cause,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.pdu_session_id.encode(data)?;
        self.cause.encode(data)?;

        Ok(())
    }
}

impl PerCodec for PduSessionResourceFailedModItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PduSessionResourceFailedModItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PduSessionResourceFailedModItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PduSessionResourceFailedModItem");
            e
        })
    }
}
// PduSessionResourceFailedToModifyList
#[derive(Clone, Debug)]
pub struct PduSessionResourceFailedToModifyList(pub NonEmpty<PduSessionResourceFailedToModifyItem>);

impl PduSessionResourceFailedToModifyList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(256), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(PduSessionResourceFailedToModifyItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(256), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for PduSessionResourceFailedToModifyList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PduSessionResourceFailedToModifyList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PduSessionResourceFailedToModifyList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PduSessionResourceFailedToModifyList");
            e
        })
    }
}
// PduSessionResourceFailedToModifyItem
#[derive(Clone, Debug)]
pub struct PduSessionResourceFailedToModifyItem {
    pub pdu_session_id: PduSessionId,
    pub cause: Cause,
}

impl PduSessionResourceFailedToModifyItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let pdu_session_id = PduSessionId::decode(data)?;
        let cause = Cause::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            pdu_session_id,
            cause,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.pdu_session_id.encode(data)?;
        self.cause.encode(data)?;

        Ok(())
    }
}

impl PerCodec for PduSessionResourceFailedToModifyItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PduSessionResourceFailedToModifyItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PduSessionResourceFailedToModifyItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PduSessionResourceFailedToModifyItem");
            e
        })
    }
}
// PduSessionResourceModifiedList
#[derive(Clone, Debug)]
pub struct PduSessionResourceModifiedList(pub NonEmpty<PduSessionResourceModifiedItem>);

impl PduSessionResourceModifiedList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(256), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(PduSessionResourceModifiedItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(256), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for PduSessionResourceModifiedList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PduSessionResourceModifiedList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PduSessionResourceModifiedList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PduSessionResourceModifiedList");
            e
        })
    }
}
// PduSessionResourceModifiedItem
#[derive(Clone, Debug)]
pub struct PduSessionResourceModifiedItem {
    pub pdu_session_id: PduSessionId,
    pub ng_dl_up_tnl_information: Option<UpTnlInformation>,
    pub security_result: Option<SecurityResult>,
    pub pdu_session_data_forwarding_information_response: Option<DataForwardingInformation>,
    pub drb_setup_list_ng_ran: Option<DrbSetupListNgRan>,
    pub drb_failed_list_ng_ran: Option<DrbFailedListNgRan>,
    pub drb_modified_list_ng_ran: Option<DrbModifiedListNgRan>,
    pub drb_failed_to_modify_list_ng_ran: Option<DrbFailedToModifyListNgRan>,
    pub redundant_n_g_dl_up_tnl_information: Option<UpTnlInformation>,
}

impl PduSessionResourceModifiedItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 8)?;
        let pdu_session_id = PduSessionId::decode(data)?;
        let ng_dl_up_tnl_information = if optionals[0] {
            Some(UpTnlInformation::decode(data)?)
        } else {
            None
        };
        let security_result = if optionals[1] {
            Some(SecurityResult::decode(data)?)
        } else {
            None
        };
        let pdu_session_data_forwarding_information_response = if optionals[2] {
            Some(DataForwardingInformation::decode(data)?)
        } else {
            None
        };
        let drb_setup_list_ng_ran = if optionals[3] {
            Some(DrbSetupListNgRan::decode(data)?)
        } else {
            None
        };
        let drb_failed_list_ng_ran = if optionals[4] {
            Some(DrbFailedListNgRan::decode(data)?)
        } else {
            None
        };
        let drb_modified_list_ng_ran = if optionals[5] {
            Some(DrbModifiedListNgRan::decode(data)?)
        } else {
            None
        };
        let drb_failed_to_modify_list_ng_ran = if optionals[6] {
            Some(DrbFailedToModifyListNgRan::decode(data)?)
        } else {
            None
        };

        // Process the extension container
        let mut redundant_n_g_dl_up_tnl_information: Option<UpTnlInformation> = None;

        if optionals[7] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    98 => {
                        redundant_n_g_dl_up_tnl_information = Some(UpTnlInformation::decode(data)?)
                    }
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            pdu_session_id,
            ng_dl_up_tnl_information,
            security_result,
            pdu_session_data_forwarding_information_response,
            drb_setup_list_ng_ran,
            drb_failed_list_ng_ran,
            drb_modified_list_ng_ran,
            drb_failed_to_modify_list_ng_ran,
            redundant_n_g_dl_up_tnl_information,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();
        if let Some(x) = &self.redundant_n_g_dl_up_tnl_information {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 98, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        let mut optionals = BitString::new();
        optionals.push(self.ng_dl_up_tnl_information.is_some());
        optionals.push(self.security_result.is_some());
        optionals.push(
            self.pdu_session_data_forwarding_information_response
                .is_some(),
        );
        optionals.push(self.drb_setup_list_ng_ran.is_some());
        optionals.push(self.drb_failed_list_ng_ran.is_some());
        optionals.push(self.drb_modified_list_ng_ran.is_some());
        optionals.push(self.drb_failed_to_modify_list_ng_ran.is_some());
        optionals.push(num_ies != 0);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.pdu_session_id.encode(data)?;
        if let Some(x) = &self.ng_dl_up_tnl_information {
            x.encode(data)?;
        }
        if let Some(x) = &self.security_result {
            x.encode(data)?;
        }
        if let Some(x) = &self.pdu_session_data_forwarding_information_response {
            x.encode(data)?;
        }
        if let Some(x) = &self.drb_setup_list_ng_ran {
            x.encode(data)?;
        }
        if let Some(x) = &self.drb_failed_list_ng_ran {
            x.encode(data)?;
        }
        if let Some(x) = &self.drb_modified_list_ng_ran {
            x.encode(data)?;
        }
        if let Some(x) = &self.drb_failed_to_modify_list_ng_ran {
            x.encode(data)?;
        }
        if num_ies != 0 {
            encode::encode_length_determinent(data, Some(1), Some(65535), false, num_ies)?;
            data.append_aligned(ies);
        }
        Ok(())
    }
}

impl PerCodec for PduSessionResourceModifiedItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PduSessionResourceModifiedItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PduSessionResourceModifiedItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PduSessionResourceModifiedItem");
            e
        })
    }
}
// PduSessionResourceRequiredToModifyList
#[derive(Clone, Debug)]
pub struct PduSessionResourceRequiredToModifyList(
    pub NonEmpty<PduSessionResourceRequiredToModifyItem>,
);

impl PduSessionResourceRequiredToModifyList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(256), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(PduSessionResourceRequiredToModifyItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(256), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for PduSessionResourceRequiredToModifyList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PduSessionResourceRequiredToModifyList::decode_inner(data).map_err(
            |mut e: PerCodecError| {
                e.push_context("PduSessionResourceRequiredToModifyList");
                e
            },
        )
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PduSessionResourceRequiredToModifyList");
            e
        })
    }
}
// PduSessionResourceRequiredToModifyItem
#[derive(Clone, Debug)]
pub struct PduSessionResourceRequiredToModifyItem {
    pub pdu_session_id: PduSessionId,
    pub ng_dl_up_tnl_information: Option<UpTnlInformation>,
    pub drb_required_to_modify_list_ng_ran: Option<DrbRequiredToModifyListNgRan>,
    pub drb_required_to_remove_list_ng_ran: Option<DrbRequiredToRemoveListNgRan>,
    pub redundant_n_g_dl_up_tnl_information: Option<UpTnlInformation>,
}

impl PduSessionResourceRequiredToModifyItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 4)?;
        let pdu_session_id = PduSessionId::decode(data)?;
        let ng_dl_up_tnl_information = if optionals[0] {
            Some(UpTnlInformation::decode(data)?)
        } else {
            None
        };
        let drb_required_to_modify_list_ng_ran = if optionals[1] {
            Some(DrbRequiredToModifyListNgRan::decode(data)?)
        } else {
            None
        };
        let drb_required_to_remove_list_ng_ran = if optionals[2] {
            Some(DrbRequiredToRemoveListNgRan::decode(data)?)
        } else {
            None
        };

        // Process the extension container
        let mut redundant_n_g_dl_up_tnl_information: Option<UpTnlInformation> = None;

        if optionals[3] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    98 => {
                        redundant_n_g_dl_up_tnl_information = Some(UpTnlInformation::decode(data)?)
                    }
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            pdu_session_id,
            ng_dl_up_tnl_information,
            drb_required_to_modify_list_ng_ran,
            drb_required_to_remove_list_ng_ran,
            redundant_n_g_dl_up_tnl_information,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();
        if let Some(x) = &self.redundant_n_g_dl_up_tnl_information {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 98, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        let mut optionals = BitString::new();
        optionals.push(self.ng_dl_up_tnl_information.is_some());
        optionals.push(self.drb_required_to_modify_list_ng_ran.is_some());
        optionals.push(self.drb_required_to_remove_list_ng_ran.is_some());
        optionals.push(num_ies != 0);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.pdu_session_id.encode(data)?;
        if let Some(x) = &self.ng_dl_up_tnl_information {
            x.encode(data)?;
        }
        if let Some(x) = &self.drb_required_to_modify_list_ng_ran {
            x.encode(data)?;
        }
        if let Some(x) = &self.drb_required_to_remove_list_ng_ran {
            x.encode(data)?;
        }
        if num_ies != 0 {
            encode::encode_length_determinent(data, Some(1), Some(65535), false, num_ies)?;
            data.append_aligned(ies);
        }
        Ok(())
    }
}

impl PerCodec for PduSessionResourceRequiredToModifyItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PduSessionResourceRequiredToModifyItem::decode_inner(data).map_err(
            |mut e: PerCodecError| {
                e.push_context("PduSessionResourceRequiredToModifyItem");
                e
            },
        )
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PduSessionResourceRequiredToModifyItem");
            e
        })
    }
}
// PduSessionResourceSetupList
#[derive(Clone, Debug)]
pub struct PduSessionResourceSetupList(pub NonEmpty<PduSessionResourceSetupItem>);

impl PduSessionResourceSetupList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(256), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(PduSessionResourceSetupItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(256), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for PduSessionResourceSetupList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PduSessionResourceSetupList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PduSessionResourceSetupList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PduSessionResourceSetupList");
            e
        })
    }
}
// PduSessionResourceSetupItem
#[derive(Clone, Debug)]
pub struct PduSessionResourceSetupItem {
    pub pdu_session_id: PduSessionId,
    pub security_result: Option<SecurityResult>,
    pub ng_dl_up_tnl_information: UpTnlInformation,
    pub pdu_session_data_forwarding_information_response: Option<DataForwardingInformation>,
    pub ng_dl_up_unchanged: Option<NgDlUpUnchanged>,
    pub drb_setup_list_ng_ran: DrbSetupListNgRan,
    pub drb_failed_list_ng_ran: Option<DrbFailedListNgRan>,
    pub redundant_n_g_dl_up_tnl_information: Option<UpTnlInformation>,
    pub redundant_pdu_session_information_used: Option<RedundantPduSessionInformation>,
}

impl PduSessionResourceSetupItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 5)?;
        let pdu_session_id = PduSessionId::decode(data)?;
        let security_result = if optionals[0] {
            Some(SecurityResult::decode(data)?)
        } else {
            None
        };
        let ng_dl_up_tnl_information = UpTnlInformation::decode(data)?;
        let pdu_session_data_forwarding_information_response = if optionals[1] {
            Some(DataForwardingInformation::decode(data)?)
        } else {
            None
        };
        let ng_dl_up_unchanged = if optionals[2] {
            Some(NgDlUpUnchanged::decode(data)?)
        } else {
            None
        };
        let drb_setup_list_ng_ran = DrbSetupListNgRan::decode(data)?;
        let drb_failed_list_ng_ran = if optionals[3] {
            Some(DrbFailedListNgRan::decode(data)?)
        } else {
            None
        };

        // Process the extension container
        let mut redundant_n_g_dl_up_tnl_information: Option<UpTnlInformation> = None;
        let mut redundant_pdu_session_information_used: Option<RedundantPduSessionInformation> =
            None;

        if optionals[4] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    98 => {
                        redundant_n_g_dl_up_tnl_information = Some(UpTnlInformation::decode(data)?)
                    }
                    106 => {
                        redundant_pdu_session_information_used =
                            Some(RedundantPduSessionInformation::decode(data)?)
                    }
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            pdu_session_id,
            security_result,
            ng_dl_up_tnl_information,
            pdu_session_data_forwarding_information_response,
            ng_dl_up_unchanged,
            drb_setup_list_ng_ran,
            drb_failed_list_ng_ran,
            redundant_n_g_dl_up_tnl_information,
            redundant_pdu_session_information_used,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();
        if let Some(x) = &self.redundant_n_g_dl_up_tnl_information {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 98, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.redundant_pdu_session_information_used {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 106, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        let mut optionals = BitString::new();
        optionals.push(self.security_result.is_some());
        optionals.push(
            self.pdu_session_data_forwarding_information_response
                .is_some(),
        );
        optionals.push(self.ng_dl_up_unchanged.is_some());
        optionals.push(self.drb_failed_list_ng_ran.is_some());
        optionals.push(num_ies != 0);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.pdu_session_id.encode(data)?;
        if let Some(x) = &self.security_result {
            x.encode(data)?;
        }
        self.ng_dl_up_tnl_information.encode(data)?;
        if let Some(x) = &self.pdu_session_data_forwarding_information_response {
            x.encode(data)?;
        }
        if let Some(x) = &self.ng_dl_up_unchanged {
            x.encode(data)?;
        }
        self.drb_setup_list_ng_ran.encode(data)?;
        if let Some(x) = &self.drb_failed_list_ng_ran {
            x.encode(data)?;
        }
        if num_ies != 0 {
            encode::encode_length_determinent(data, Some(1), Some(65535), false, num_ies)?;
            data.append_aligned(ies);
        }
        Ok(())
    }
}

impl PerCodec for PduSessionResourceSetupItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PduSessionResourceSetupItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PduSessionResourceSetupItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PduSessionResourceSetupItem");
            e
        })
    }
}
// PduSessionResourceSetupModList
#[derive(Clone, Debug)]
pub struct PduSessionResourceSetupModList(pub NonEmpty<PduSessionResourceSetupModItem>);

impl PduSessionResourceSetupModList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(256), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(PduSessionResourceSetupModItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(256), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for PduSessionResourceSetupModList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PduSessionResourceSetupModList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PduSessionResourceSetupModList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PduSessionResourceSetupModList");
            e
        })
    }
}
// PduSessionResourceSetupModItem
#[derive(Clone, Debug)]
pub struct PduSessionResourceSetupModItem {
    pub pdu_session_id: PduSessionId,
    pub security_result: Option<SecurityResult>,
    pub ng_dl_up_tnl_information: UpTnlInformation,
    pub pdu_session_data_forwarding_information_response: Option<DataForwardingInformation>,
    pub drb_setup_mod_list_ng_ran: DrbSetupModListNgRan,
    pub drb_failed_mod_list_ng_ran: Option<DrbFailedModListNgRan>,
    pub redundant_n_g_dl_up_tnl_information: Option<UpTnlInformation>,
}

impl PduSessionResourceSetupModItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 4)?;
        let pdu_session_id = PduSessionId::decode(data)?;
        let security_result = if optionals[0] {
            Some(SecurityResult::decode(data)?)
        } else {
            None
        };
        let ng_dl_up_tnl_information = UpTnlInformation::decode(data)?;
        let pdu_session_data_forwarding_information_response = if optionals[1] {
            Some(DataForwardingInformation::decode(data)?)
        } else {
            None
        };
        let drb_setup_mod_list_ng_ran = DrbSetupModListNgRan::decode(data)?;
        let drb_failed_mod_list_ng_ran = if optionals[2] {
            Some(DrbFailedModListNgRan::decode(data)?)
        } else {
            None
        };

        // Process the extension container
        let mut redundant_n_g_dl_up_tnl_information: Option<UpTnlInformation> = None;

        if optionals[3] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    98 => {
                        redundant_n_g_dl_up_tnl_information = Some(UpTnlInformation::decode(data)?)
                    }
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            pdu_session_id,
            security_result,
            ng_dl_up_tnl_information,
            pdu_session_data_forwarding_information_response,
            drb_setup_mod_list_ng_ran,
            drb_failed_mod_list_ng_ran,
            redundant_n_g_dl_up_tnl_information,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();
        if let Some(x) = &self.redundant_n_g_dl_up_tnl_information {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 98, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        let mut optionals = BitString::new();
        optionals.push(self.security_result.is_some());
        optionals.push(
            self.pdu_session_data_forwarding_information_response
                .is_some(),
        );
        optionals.push(self.drb_failed_mod_list_ng_ran.is_some());
        optionals.push(num_ies != 0);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.pdu_session_id.encode(data)?;
        if let Some(x) = &self.security_result {
            x.encode(data)?;
        }
        self.ng_dl_up_tnl_information.encode(data)?;
        if let Some(x) = &self.pdu_session_data_forwarding_information_response {
            x.encode(data)?;
        }
        self.drb_setup_mod_list_ng_ran.encode(data)?;
        if let Some(x) = &self.drb_failed_mod_list_ng_ran {
            x.encode(data)?;
        }
        if num_ies != 0 {
            encode::encode_length_determinent(data, Some(1), Some(65535), false, num_ies)?;
            data.append_aligned(ies);
        }
        Ok(())
    }
}

impl PerCodec for PduSessionResourceSetupModItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PduSessionResourceSetupModItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PduSessionResourceSetupModItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PduSessionResourceSetupModItem");
            e
        })
    }
}
// PduSessionResourceToModifyList
#[derive(Clone, Debug)]
pub struct PduSessionResourceToModifyList(pub NonEmpty<PduSessionResourceToModifyItem>);

impl PduSessionResourceToModifyList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(256), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(PduSessionResourceToModifyItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(256), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for PduSessionResourceToModifyList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PduSessionResourceToModifyList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PduSessionResourceToModifyList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PduSessionResourceToModifyList");
            e
        })
    }
}
// PduSessionResourceToModifyItem
#[derive(Clone, Debug)]
pub struct PduSessionResourceToModifyItem {
    pub pdu_session_id: PduSessionId,
    pub security_indication: Option<SecurityIndication>,
    pub pdu_session_resource_dl_ambr: Option<BitRate>,
    pub ng_ul_up_tnl_information: Option<UpTnlInformation>,
    pub pdu_session_data_forwarding_information_request: Option<DataForwardingInformationRequest>,
    pub pdu_session_data_forwarding_information: Option<DataForwardingInformation>,
    pub pdu_session_inactivity_timer: Option<InactivityTimer>,
    pub network_instance: Option<NetworkInstance>,
    pub drb_to_setup_list_ng_ran: Option<DrbToSetupListNgRan>,
    pub drb_to_modify_list_ng_ran: Option<DrbToModifyListNgRan>,
    pub drb_to_remove_list_ng_ran: Option<DrbToRemoveListNgRan>,
    pub snssai: Option<Snssai>,
    pub common_network_instance: Option<CommonNetworkInstance>,
    pub redundant_n_g_ul_up_tnl_information: Option<UpTnlInformation>,
    pub redundant_common_network_instance: Option<CommonNetworkInstance>,
    pub data_forwardingto_eutran_information_list: Option<DataForwardingtoEutranInformationList>,
}

impl PduSessionResourceToModifyItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 11)?;
        let pdu_session_id = PduSessionId::decode(data)?;
        let security_indication = if optionals[0] {
            Some(SecurityIndication::decode(data)?)
        } else {
            None
        };
        let pdu_session_resource_dl_ambr = if optionals[1] {
            Some(BitRate::decode(data)?)
        } else {
            None
        };
        let ng_ul_up_tnl_information = if optionals[2] {
            Some(UpTnlInformation::decode(data)?)
        } else {
            None
        };
        let pdu_session_data_forwarding_information_request = if optionals[3] {
            Some(DataForwardingInformationRequest::decode(data)?)
        } else {
            None
        };
        let pdu_session_data_forwarding_information = if optionals[4] {
            Some(DataForwardingInformation::decode(data)?)
        } else {
            None
        };
        let pdu_session_inactivity_timer = if optionals[5] {
            Some(InactivityTimer::decode(data)?)
        } else {
            None
        };
        let network_instance = if optionals[6] {
            Some(NetworkInstance::decode(data)?)
        } else {
            None
        };
        let drb_to_setup_list_ng_ran = if optionals[7] {
            Some(DrbToSetupListNgRan::decode(data)?)
        } else {
            None
        };
        let drb_to_modify_list_ng_ran = if optionals[8] {
            Some(DrbToModifyListNgRan::decode(data)?)
        } else {
            None
        };
        let drb_to_remove_list_ng_ran = if optionals[9] {
            Some(DrbToRemoveListNgRan::decode(data)?)
        } else {
            None
        };

        // Process the extension container
        let mut snssai: Option<Snssai> = None;
        let mut common_network_instance: Option<CommonNetworkInstance> = None;
        let mut redundant_n_g_ul_up_tnl_information: Option<UpTnlInformation> = None;
        let mut redundant_common_network_instance: Option<CommonNetworkInstance> = None;
        let mut data_forwardingto_eutran_information_list: Option<
            DataForwardingtoEutranInformationList,
        > = None;

        if optionals[10] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    69 => snssai = Some(Snssai::decode(data)?),
                    78 => common_network_instance = Some(CommonNetworkInstance::decode(data)?),
                    97 => {
                        redundant_n_g_ul_up_tnl_information = Some(UpTnlInformation::decode(data)?)
                    }
                    96 => {
                        redundant_common_network_instance =
                            Some(CommonNetworkInstance::decode(data)?)
                    }
                    131 => {
                        data_forwardingto_eutran_information_list =
                            Some(DataForwardingtoEutranInformationList::decode(data)?)
                    }
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            pdu_session_id,
            security_indication,
            pdu_session_resource_dl_ambr,
            ng_ul_up_tnl_information,
            pdu_session_data_forwarding_information_request,
            pdu_session_data_forwarding_information,
            pdu_session_inactivity_timer,
            network_instance,
            drb_to_setup_list_ng_ran,
            drb_to_modify_list_ng_ran,
            drb_to_remove_list_ng_ran,
            snssai,
            common_network_instance,
            redundant_n_g_ul_up_tnl_information,
            redundant_common_network_instance,
            data_forwardingto_eutran_information_list,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();
        if let Some(x) = &self.snssai {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 69, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.common_network_instance {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 78, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.redundant_n_g_ul_up_tnl_information {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 97, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.redundant_common_network_instance {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 96, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.data_forwardingto_eutran_information_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 131, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        let mut optionals = BitString::new();
        optionals.push(self.security_indication.is_some());
        optionals.push(self.pdu_session_resource_dl_ambr.is_some());
        optionals.push(self.ng_ul_up_tnl_information.is_some());
        optionals.push(
            self.pdu_session_data_forwarding_information_request
                .is_some(),
        );
        optionals.push(self.pdu_session_data_forwarding_information.is_some());
        optionals.push(self.pdu_session_inactivity_timer.is_some());
        optionals.push(self.network_instance.is_some());
        optionals.push(self.drb_to_setup_list_ng_ran.is_some());
        optionals.push(self.drb_to_modify_list_ng_ran.is_some());
        optionals.push(self.drb_to_remove_list_ng_ran.is_some());
        optionals.push(num_ies != 0);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.pdu_session_id.encode(data)?;
        if let Some(x) = &self.security_indication {
            x.encode(data)?;
        }
        if let Some(x) = &self.pdu_session_resource_dl_ambr {
            x.encode(data)?;
        }
        if let Some(x) = &self.ng_ul_up_tnl_information {
            x.encode(data)?;
        }
        if let Some(x) = &self.pdu_session_data_forwarding_information_request {
            x.encode(data)?;
        }
        if let Some(x) = &self.pdu_session_data_forwarding_information {
            x.encode(data)?;
        }
        if let Some(x) = &self.pdu_session_inactivity_timer {
            x.encode(data)?;
        }
        if let Some(x) = &self.network_instance {
            x.encode(data)?;
        }
        if let Some(x) = &self.drb_to_setup_list_ng_ran {
            x.encode(data)?;
        }
        if let Some(x) = &self.drb_to_modify_list_ng_ran {
            x.encode(data)?;
        }
        if let Some(x) = &self.drb_to_remove_list_ng_ran {
            x.encode(data)?;
        }
        if num_ies != 0 {
            encode::encode_length_determinent(data, Some(1), Some(65535), false, num_ies)?;
            data.append_aligned(ies);
        }
        Ok(())
    }
}

impl PerCodec for PduSessionResourceToModifyItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PduSessionResourceToModifyItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PduSessionResourceToModifyItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PduSessionResourceToModifyItem");
            e
        })
    }
}
// PduSessionResourceToRemoveList
#[derive(Clone, Debug)]
pub struct PduSessionResourceToRemoveList(pub NonEmpty<PduSessionResourceToRemoveItem>);

impl PduSessionResourceToRemoveList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(256), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(PduSessionResourceToRemoveItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(256), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for PduSessionResourceToRemoveList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PduSessionResourceToRemoveList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PduSessionResourceToRemoveList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PduSessionResourceToRemoveList");
            e
        })
    }
}
// PduSessionResourceToRemoveItem
#[derive(Clone, Debug)]
pub struct PduSessionResourceToRemoveItem {
    pub pdu_session_id: PduSessionId,
    pub cause: Option<Cause>,
}

impl PduSessionResourceToRemoveItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let pdu_session_id = PduSessionId::decode(data)?;

        // Process the extension container
        let mut cause: Option<Cause> = None;

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    0 => cause = Some(Cause::decode(data)?),
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            pdu_session_id,
            cause,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();
        if let Some(x) = &self.cause {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 0, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        let mut optionals = BitString::new();
        optionals.push(num_ies != 0);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.pdu_session_id.encode(data)?;
        if num_ies != 0 {
            encode::encode_length_determinent(data, Some(1), Some(65535), false, num_ies)?;
            data.append_aligned(ies);
        }
        Ok(())
    }
}

impl PerCodec for PduSessionResourceToRemoveItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PduSessionResourceToRemoveItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PduSessionResourceToRemoveItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PduSessionResourceToRemoveItem");
            e
        })
    }
}
// PduSessionResourceToSetupList
#[derive(Clone, Debug)]
pub struct PduSessionResourceToSetupList(pub NonEmpty<PduSessionResourceToSetupItem>);

impl PduSessionResourceToSetupList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(256), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(PduSessionResourceToSetupItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(256), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for PduSessionResourceToSetupList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PduSessionResourceToSetupList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PduSessionResourceToSetupList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PduSessionResourceToSetupList");
            e
        })
    }
}
// PduSessionResourceToSetupItem
#[derive(Clone, Debug)]
pub struct PduSessionResourceToSetupItem {
    pub pdu_session_id: PduSessionId,
    pub pdu_session_type: PduSessionType,
    pub snssai: Snssai,
    pub security_indication: SecurityIndication,
    pub pdu_session_resource_dl_ambr: Option<BitRate>,
    pub ng_ul_up_tnl_information: UpTnlInformation,
    pub pdu_session_data_forwarding_information_request: Option<DataForwardingInformationRequest>,
    pub pdu_session_inactivity_timer: Option<InactivityTimer>,
    pub existing_allocated_ng_dl_up_tnl_info: Option<UpTnlInformation>,
    pub network_instance: Option<NetworkInstance>,
    pub drb_to_setup_list_ng_ran: DrbToSetupListNgRan,
    pub common_network_instance: Option<CommonNetworkInstance>,
    pub redundant_n_g_ul_up_tnl_information: Option<UpTnlInformation>,
    pub redundant_common_network_instance: Option<CommonNetworkInstance>,
    pub redundant_pdu_session_information: Option<RedundantPduSessionInformation>,
}

impl PduSessionResourceToSetupItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 6)?;
        let pdu_session_id = PduSessionId::decode(data)?;
        let pdu_session_type = PduSessionType::decode(data)?;
        let snssai = Snssai::decode(data)?;
        let security_indication = SecurityIndication::decode(data)?;
        let pdu_session_resource_dl_ambr = if optionals[0] {
            Some(BitRate::decode(data)?)
        } else {
            None
        };
        let ng_ul_up_tnl_information = UpTnlInformation::decode(data)?;
        let pdu_session_data_forwarding_information_request = if optionals[1] {
            Some(DataForwardingInformationRequest::decode(data)?)
        } else {
            None
        };
        let pdu_session_inactivity_timer = if optionals[2] {
            Some(InactivityTimer::decode(data)?)
        } else {
            None
        };
        let existing_allocated_ng_dl_up_tnl_info = if optionals[3] {
            Some(UpTnlInformation::decode(data)?)
        } else {
            None
        };
        let network_instance = if optionals[4] {
            Some(NetworkInstance::decode(data)?)
        } else {
            None
        };
        let drb_to_setup_list_ng_ran = DrbToSetupListNgRan::decode(data)?;

        // Process the extension container
        let mut common_network_instance: Option<CommonNetworkInstance> = None;
        let mut redundant_n_g_ul_up_tnl_information: Option<UpTnlInformation> = None;
        let mut redundant_common_network_instance: Option<CommonNetworkInstance> = None;
        let mut redundant_pdu_session_information: Option<RedundantPduSessionInformation> = None;

        if optionals[5] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    78 => common_network_instance = Some(CommonNetworkInstance::decode(data)?),
                    97 => {
                        redundant_n_g_ul_up_tnl_information = Some(UpTnlInformation::decode(data)?)
                    }
                    96 => {
                        redundant_common_network_instance =
                            Some(CommonNetworkInstance::decode(data)?)
                    }
                    105 => {
                        redundant_pdu_session_information =
                            Some(RedundantPduSessionInformation::decode(data)?)
                    }
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            pdu_session_id,
            pdu_session_type,
            snssai,
            security_indication,
            pdu_session_resource_dl_ambr,
            ng_ul_up_tnl_information,
            pdu_session_data_forwarding_information_request,
            pdu_session_inactivity_timer,
            existing_allocated_ng_dl_up_tnl_info,
            network_instance,
            drb_to_setup_list_ng_ran,
            common_network_instance,
            redundant_n_g_ul_up_tnl_information,
            redundant_common_network_instance,
            redundant_pdu_session_information,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();
        if let Some(x) = &self.common_network_instance {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 78, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.redundant_n_g_ul_up_tnl_information {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 97, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.redundant_common_network_instance {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 96, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.redundant_pdu_session_information {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 105, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        let mut optionals = BitString::new();
        optionals.push(self.pdu_session_resource_dl_ambr.is_some());
        optionals.push(
            self.pdu_session_data_forwarding_information_request
                .is_some(),
        );
        optionals.push(self.pdu_session_inactivity_timer.is_some());
        optionals.push(self.existing_allocated_ng_dl_up_tnl_info.is_some());
        optionals.push(self.network_instance.is_some());
        optionals.push(num_ies != 0);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.pdu_session_id.encode(data)?;
        self.pdu_session_type.encode(data)?;
        self.snssai.encode(data)?;
        self.security_indication.encode(data)?;
        if let Some(x) = &self.pdu_session_resource_dl_ambr {
            x.encode(data)?;
        }
        self.ng_ul_up_tnl_information.encode(data)?;
        if let Some(x) = &self.pdu_session_data_forwarding_information_request {
            x.encode(data)?;
        }
        if let Some(x) = &self.pdu_session_inactivity_timer {
            x.encode(data)?;
        }
        if let Some(x) = &self.existing_allocated_ng_dl_up_tnl_info {
            x.encode(data)?;
        }
        if let Some(x) = &self.network_instance {
            x.encode(data)?;
        }
        self.drb_to_setup_list_ng_ran.encode(data)?;
        if num_ies != 0 {
            encode::encode_length_determinent(data, Some(1), Some(65535), false, num_ies)?;
            data.append_aligned(ies);
        }
        Ok(())
    }
}

impl PerCodec for PduSessionResourceToSetupItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PduSessionResourceToSetupItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PduSessionResourceToSetupItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PduSessionResourceToSetupItem");
            e
        })
    }
}
// PduSessionResourceToSetupModList
#[derive(Clone, Debug)]
pub struct PduSessionResourceToSetupModList(pub NonEmpty<PduSessionResourceToSetupModItem>);

impl PduSessionResourceToSetupModList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(256), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(PduSessionResourceToSetupModItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(256), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for PduSessionResourceToSetupModList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PduSessionResourceToSetupModList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PduSessionResourceToSetupModList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PduSessionResourceToSetupModList");
            e
        })
    }
}
// PduSessionResourceToSetupModItem
#[derive(Clone, Debug)]
pub struct PduSessionResourceToSetupModItem {
    pub pdu_session_id: PduSessionId,
    pub pdu_session_type: PduSessionType,
    pub snssai: Snssai,
    pub security_indication: SecurityIndication,
    pub pdu_session_resource_ambr: Option<BitRate>,
    pub ng_ul_up_tnl_information: UpTnlInformation,
    pub pdu_session_data_forwarding_information_request: Option<DataForwardingInformationRequest>,
    pub pdu_session_inactivity_timer: Option<InactivityTimer>,
    pub drb_to_setup_mod_list_ng_ran: DrbToSetupModListNgRan,
    pub network_instance: Option<NetworkInstance>,
    pub common_network_instance: Option<CommonNetworkInstance>,
    pub redundant_n_g_ul_up_tnl_information: Option<UpTnlInformation>,
    pub redundant_common_network_instance: Option<CommonNetworkInstance>,
}

impl PduSessionResourceToSetupModItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 4)?;
        let pdu_session_id = PduSessionId::decode(data)?;
        let pdu_session_type = PduSessionType::decode(data)?;
        let snssai = Snssai::decode(data)?;
        let security_indication = SecurityIndication::decode(data)?;
        let pdu_session_resource_ambr = if optionals[0] {
            Some(BitRate::decode(data)?)
        } else {
            None
        };
        let ng_ul_up_tnl_information = UpTnlInformation::decode(data)?;
        let pdu_session_data_forwarding_information_request = if optionals[1] {
            Some(DataForwardingInformationRequest::decode(data)?)
        } else {
            None
        };
        let pdu_session_inactivity_timer = if optionals[2] {
            Some(InactivityTimer::decode(data)?)
        } else {
            None
        };
        let drb_to_setup_mod_list_ng_ran = DrbToSetupModListNgRan::decode(data)?;

        // Process the extension container
        let mut network_instance: Option<NetworkInstance> = None;
        let mut common_network_instance: Option<CommonNetworkInstance> = None;
        let mut redundant_n_g_ul_up_tnl_information: Option<UpTnlInformation> = None;
        let mut redundant_common_network_instance: Option<CommonNetworkInstance> = None;

        if optionals[3] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    79 => network_instance = Some(NetworkInstance::decode(data)?),
                    78 => common_network_instance = Some(CommonNetworkInstance::decode(data)?),
                    97 => {
                        redundant_n_g_ul_up_tnl_information = Some(UpTnlInformation::decode(data)?)
                    }
                    96 => {
                        redundant_common_network_instance =
                            Some(CommonNetworkInstance::decode(data)?)
                    }
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            pdu_session_id,
            pdu_session_type,
            snssai,
            security_indication,
            pdu_session_resource_ambr,
            ng_ul_up_tnl_information,
            pdu_session_data_forwarding_information_request,
            pdu_session_inactivity_timer,
            drb_to_setup_mod_list_ng_ran,
            network_instance,
            common_network_instance,
            redundant_n_g_ul_up_tnl_information,
            redundant_common_network_instance,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();
        if let Some(x) = &self.network_instance {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 79, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.common_network_instance {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 78, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.redundant_n_g_ul_up_tnl_information {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 97, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.redundant_common_network_instance {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 96, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        let mut optionals = BitString::new();
        optionals.push(self.pdu_session_resource_ambr.is_some());
        optionals.push(
            self.pdu_session_data_forwarding_information_request
                .is_some(),
        );
        optionals.push(self.pdu_session_inactivity_timer.is_some());
        optionals.push(num_ies != 0);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.pdu_session_id.encode(data)?;
        self.pdu_session_type.encode(data)?;
        self.snssai.encode(data)?;
        self.security_indication.encode(data)?;
        if let Some(x) = &self.pdu_session_resource_ambr {
            x.encode(data)?;
        }
        self.ng_ul_up_tnl_information.encode(data)?;
        if let Some(x) = &self.pdu_session_data_forwarding_information_request {
            x.encode(data)?;
        }
        if let Some(x) = &self.pdu_session_inactivity_timer {
            x.encode(data)?;
        }
        self.drb_to_setup_mod_list_ng_ran.encode(data)?;
        if num_ies != 0 {
            encode::encode_length_determinent(data, Some(1), Some(65535), false, num_ies)?;
            data.append_aligned(ies);
        }
        Ok(())
    }
}

impl PerCodec for PduSessionResourceToSetupModItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PduSessionResourceToSetupModItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PduSessionResourceToSetupModItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PduSessionResourceToSetupModItem");
            e
        })
    }
}
// PduSessionToNotifyList
#[derive(Clone, Debug)]
pub struct PduSessionToNotifyList(pub NonEmpty<PduSessionToNotifyItem>);

impl PduSessionToNotifyList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(256), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(PduSessionToNotifyItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(256), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for PduSessionToNotifyList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PduSessionToNotifyList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PduSessionToNotifyList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PduSessionToNotifyList");
            e
        })
    }
}
// PduSessionToNotifyItem
#[derive(Clone, Debug)]
pub struct PduSessionToNotifyItem {
    pub pdu_session_id: PduSessionId,
    pub qos_flow_list: QosFlowList,
}

impl PduSessionToNotifyItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let pdu_session_id = PduSessionId::decode(data)?;
        let qos_flow_list = QosFlowList::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            pdu_session_id,
            qos_flow_list,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.pdu_session_id.encode(data)?;
        self.qos_flow_list.encode(data)?;

        Ok(())
    }
}

impl PerCodec for PduSessionToNotifyItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PduSessionToNotifyItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PduSessionToNotifyItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PduSessionToNotifyItem");
            e
        })
    }
}
// PduSessionType
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum PduSessionType {
    Ipv4,
    Ipv6,
    Ipv4v6,
    Ethernet,
    Unstructured,
}

impl PduSessionType {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(4), true)?;
        if extended {
            return Err(PerCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(data, Some(0), Some(4), true, *self as i128, false)
    }
}

impl PerCodec for PduSessionType {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PduSessionType::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PduSessionType");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PduSessionType");
            e
        })
    }
}
// PlmnIdentity
#[derive(Clone, Debug)]
pub struct PlmnIdentity(pub [u8; 3]);

impl PlmnIdentity {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(
            decode::decode_octetstring(data, Some(3), Some(3), false)?
                .try_into()
                .unwrap(),
        ))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_octetstring(data, Some(3), Some(3), false, &(self.0).into(), false)
    }
}

impl PerCodec for PlmnIdentity {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PlmnIdentity::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PlmnIdentity");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PlmnIdentity");
            e
        })
    }
}
// PortNumber
#[derive(Clone, Debug)]
pub struct PortNumber(pub BitString);

impl PortNumber {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(decode::decode_bitstring(
            data,
            Some(16),
            Some(16),
            false,
        )?))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_bitstring(data, Some(16), Some(16), false, &self.0, false)
    }
}

impl PerCodec for PortNumber {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PortNumber::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PortNumber");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PortNumber");
            e
        })
    }
}
// Ppi
#[derive(Clone, Copy, Debug)]
pub struct Ppi(pub u8);

impl Ppi {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(
            decode::decode_integer(data, Some(0), Some(7), true)?.0 as u8,
        ))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_integer(data, Some(0), Some(7), true, self.0 as i128, false)
    }
}

impl PerCodec for Ppi {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ppi::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("Ppi");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("Ppi");
            e
        })
    }
}
// PriorityLevel
#[derive(Clone, Copy, Debug)]
pub struct PriorityLevel(pub u8);

impl PriorityLevel {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(
            decode::decode_integer(data, Some(0), Some(15), false)?.0 as u8,
        ))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_integer(data, Some(0), Some(15), false, self.0 as i128, false)
    }
}

impl PerCodec for PriorityLevel {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PriorityLevel::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PriorityLevel");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PriorityLevel");
            e
        })
    }
}
// PreEmptionCapability
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum PreEmptionCapability {
    ShallNotTriggerPreEmption,
    MayTriggerPreEmption,
}

impl PreEmptionCapability {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(1), false)?;
        if extended {
            return Err(PerCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(data, Some(0), Some(1), false, *self as i128, false)
    }
}

impl PerCodec for PreEmptionCapability {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PreEmptionCapability::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PreEmptionCapability");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PreEmptionCapability");
            e
        })
    }
}
// PreEmptionVulnerability
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum PreEmptionVulnerability {
    NotPreEmptable,
    PreEmptable,
}

impl PreEmptionVulnerability {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(1), false)?;
        if extended {
            return Err(PerCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(data, Some(0), Some(1), false, *self as i128, false)
    }
}

impl PerCodec for PreEmptionVulnerability {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PreEmptionVulnerability::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PreEmptionVulnerability");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PreEmptionVulnerability");
            e
        })
    }
}
// PrivacyIndicator
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum PrivacyIndicator {
    ImmediateMdt,
    LoggedMdt,
}

impl PrivacyIndicator {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(1), true)?;
        if extended {
            return Err(PerCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(data, Some(0), Some(1), true, *self as i128, false)
    }
}

impl PerCodec for PrivacyIndicator {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PrivacyIndicator::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PrivacyIndicator");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PrivacyIndicator");
            e
        })
    }
}
// Qci
#[derive(Clone, Copy, Debug)]
pub struct Qci(pub u8);

impl Qci {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(
            decode::decode_integer(data, Some(0), Some(255), false)?.0 as u8,
        ))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_integer(data, Some(0), Some(255), false, self.0 as i128, false)
    }
}

impl PerCodec for Qci {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Qci::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("Qci");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("Qci");
            e
        })
    }
}
// QosCharacteristics
#[derive(Clone, Debug)]
pub enum QosCharacteristics {
    NonDynamic5qi(NonDynamic5qiDescriptor),
    Dynamic5qi(Dynamic5qiDescriptor),
}

impl QosCharacteristics {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_choice_idx(data, 0, 2, false)?;
        if extended {
            return Err(PerCodecError::new("CHOICE additions not implemented"));
        }
        match idx {
            0 => Ok(Self::NonDynamic5qi(NonDynamic5qiDescriptor::decode(data)?)),
            1 => Ok(Self::Dynamic5qi(Dynamic5qiDescriptor::decode(data)?)),
            2 => {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _ = Criticality::decode(data)?;
                let _ = decode::decode_length_determinent(data, None, None, false)?;
                let result = match id {
                    x => Err(PerCodecError::new(format!("Unrecognised IE type {}", x))),
                };
                data.decode_align()?;
                result
            }
            _ => Err(PerCodecError::new("Unknown choice idx")),
        }
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        match self {
            Self::NonDynamic5qi(x) => {
                encode::encode_choice_idx(data, 0, 2, false, 0, false)?;
                x.encode(data)
            }
            Self::Dynamic5qi(x) => {
                encode::encode_choice_idx(data, 0, 2, false, 1, false)?;
                x.encode(data)
            }
        }
    }
}

impl PerCodec for QosCharacteristics {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        QosCharacteristics::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("QosCharacteristics");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("QosCharacteristics");
            e
        })
    }
}
// QosFlowIdentifier
#[derive(Clone, Copy, Debug)]
pub struct QosFlowIdentifier(pub u8);

impl QosFlowIdentifier {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(
            decode::decode_integer(data, Some(0), Some(63), false)?.0 as u8,
        ))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_integer(data, Some(0), Some(63), false, self.0 as i128, false)
    }
}

impl PerCodec for QosFlowIdentifier {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        QosFlowIdentifier::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("QosFlowIdentifier");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("QosFlowIdentifier");
            e
        })
    }
}
// QosFlowList
#[derive(Clone, Debug)]
pub struct QosFlowList(pub NonEmpty<QosFlowItem>);

impl QosFlowList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(64), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(QosFlowItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(64), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for QosFlowList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        QosFlowList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("QosFlowList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("QosFlowList");
            e
        })
    }
}
// QosFlowItem
#[derive(Clone, Debug)]
pub struct QosFlowItem {
    pub qos_flow_identifier: QosFlowIdentifier,
    pub qos_flow_mapping_indication: Option<QosFlowMappingIndication>,
}

impl QosFlowItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let qos_flow_identifier = QosFlowIdentifier::decode(data)?;

        // Process the extension container
        let mut qos_flow_mapping_indication: Option<QosFlowMappingIndication> = None;

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    80 => {
                        qos_flow_mapping_indication = Some(QosFlowMappingIndication::decode(data)?)
                    }
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            qos_flow_identifier,
            qos_flow_mapping_indication,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();
        if let Some(x) = &self.qos_flow_mapping_indication {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 80, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        let mut optionals = BitString::new();
        optionals.push(num_ies != 0);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.qos_flow_identifier.encode(data)?;
        if num_ies != 0 {
            encode::encode_length_determinent(data, Some(1), Some(65535), false, num_ies)?;
            data.append_aligned(ies);
        }
        Ok(())
    }
}

impl PerCodec for QosFlowItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        QosFlowItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("QosFlowItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("QosFlowItem");
            e
        })
    }
}
// QosFlowFailedList
#[derive(Clone, Debug)]
pub struct QosFlowFailedList(pub NonEmpty<QosFlowFailedItem>);

impl QosFlowFailedList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(64), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(QosFlowFailedItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(64), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for QosFlowFailedList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        QosFlowFailedList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("QosFlowFailedList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("QosFlowFailedList");
            e
        })
    }
}
// QosFlowFailedItem
#[derive(Clone, Debug)]
pub struct QosFlowFailedItem {
    pub qos_flow_identifier: QosFlowIdentifier,
    pub cause: Cause,
}

impl QosFlowFailedItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let qos_flow_identifier = QosFlowIdentifier::decode(data)?;
        let cause = Cause::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            qos_flow_identifier,
            cause,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.qos_flow_identifier.encode(data)?;
        self.cause.encode(data)?;

        Ok(())
    }
}

impl PerCodec for QosFlowFailedItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        QosFlowFailedItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("QosFlowFailedItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("QosFlowFailedItem");
            e
        })
    }
}
// QosFlowMappingList
#[derive(Clone, Debug)]
pub struct QosFlowMappingList(pub NonEmpty<QosFlowMappingItem>);

impl QosFlowMappingList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(64), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(QosFlowMappingItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(64), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for QosFlowMappingList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        QosFlowMappingList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("QosFlowMappingList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("QosFlowMappingList");
            e
        })
    }
}
// QosFlowMappingItem
#[derive(Clone, Debug)]
pub struct QosFlowMappingItem {
    pub qos_flow_identifier: QosFlowIdentifier,
    pub qos_flow_mapping_indication: Option<QosFlowMappingIndication>,
}

impl QosFlowMappingItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 2)?;
        let qos_flow_identifier = QosFlowIdentifier::decode(data)?;
        let qos_flow_mapping_indication = if optionals[0] {
            Some(QosFlowMappingIndication::decode(data)?)
        } else {
            None
        };

        // Process the extension container

        if optionals[1] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            qos_flow_identifier,
            qos_flow_mapping_indication,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.qos_flow_mapping_indication.is_some());
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.qos_flow_identifier.encode(data)?;
        if let Some(x) = &self.qos_flow_mapping_indication {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl PerCodec for QosFlowMappingItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        QosFlowMappingItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("QosFlowMappingItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("QosFlowMappingItem");
            e
        })
    }
}
// QosFlowMappingIndication
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum QosFlowMappingIndication {
    Ul,
    Dl,
}

impl QosFlowMappingIndication {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(1), true)?;
        if extended {
            return Err(PerCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(data, Some(0), Some(1), true, *self as i128, false)
    }
}

impl PerCodec for QosFlowMappingIndication {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        QosFlowMappingIndication::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("QosFlowMappingIndication");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("QosFlowMappingIndication");
            e
        })
    }
}
// QosParametersSupportList
#[derive(Clone, Debug)]
pub struct QosParametersSupportList {
    pub eutran_qos_support_list: Option<EutranQosSupportList>,
    pub ng_ran_qos_support_list: Option<NgRanQosSupportList>,
}

impl QosParametersSupportList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 3)?;
        let eutran_qos_support_list = if optionals[0] {
            Some(EutranQosSupportList::decode(data)?)
        } else {
            None
        };
        let ng_ran_qos_support_list = if optionals[1] {
            Some(NgRanQosSupportList::decode(data)?)
        } else {
            None
        };

        // Process the extension container

        if optionals[2] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            eutran_qos_support_list,
            ng_ran_qos_support_list,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.eutran_qos_support_list.is_some());
        optionals.push(self.ng_ran_qos_support_list.is_some());
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        if let Some(x) = &self.eutran_qos_support_list {
            x.encode(data)?;
        }
        if let Some(x) = &self.ng_ran_qos_support_list {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl PerCodec for QosParametersSupportList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        QosParametersSupportList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("QosParametersSupportList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("QosParametersSupportList");
            e
        })
    }
}
// QosPriorityLevel
#[derive(Clone, Copy, Debug)]
pub struct QosPriorityLevel(pub u8);

impl QosPriorityLevel {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(
            decode::decode_integer(data, Some(0), Some(127), true)?.0 as u8,
        ))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_integer(data, Some(0), Some(127), true, self.0 as i128, false)
    }
}

impl PerCodec for QosPriorityLevel {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        QosPriorityLevel::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("QosPriorityLevel");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("QosPriorityLevel");
            e
        })
    }
}
// QosFlowQosParameterList
#[derive(Clone, Debug)]
pub struct QosFlowQosParameterList(pub NonEmpty<QosFlowQosParameterItem>);

impl QosFlowQosParameterList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(64), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(QosFlowQosParameterItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(64), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for QosFlowQosParameterList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        QosFlowQosParameterList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("QosFlowQosParameterList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("QosFlowQosParameterList");
            e
        })
    }
}
// QosFlowQosParameterItem
#[derive(Clone, Debug)]
pub struct QosFlowQosParameterItem {
    pub qos_flow_identifier: QosFlowIdentifier,
    pub qos_flow_level_qos_parameters: QosFlowLevelQosParameters,
    pub qos_flow_mapping_indication: Option<QosFlowMappingIndication>,
    pub redundant_qos_flow_indicator: Option<RedundantQosFlowIndicator>,
    pub tsc_traffic_characteristics: Option<TscTrafficCharacteristics>,
}

impl QosFlowQosParameterItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 2)?;
        let qos_flow_identifier = QosFlowIdentifier::decode(data)?;
        let qos_flow_level_qos_parameters = QosFlowLevelQosParameters::decode(data)?;
        let qos_flow_mapping_indication = if optionals[0] {
            Some(QosFlowMappingIndication::decode(data)?)
        } else {
            None
        };

        // Process the extension container
        let mut redundant_qos_flow_indicator: Option<RedundantQosFlowIndicator> = None;
        let mut tsc_traffic_characteristics: Option<TscTrafficCharacteristics> = None;

        if optionals[1] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    99 => {
                        redundant_qos_flow_indicator =
                            Some(RedundantQosFlowIndicator::decode(data)?)
                    }
                    100 => {
                        tsc_traffic_characteristics = Some(TscTrafficCharacteristics::decode(data)?)
                    }
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            qos_flow_identifier,
            qos_flow_level_qos_parameters,
            qos_flow_mapping_indication,
            redundant_qos_flow_indicator,
            tsc_traffic_characteristics,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();
        if let Some(x) = &self.redundant_qos_flow_indicator {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 99, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.tsc_traffic_characteristics {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 100, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        let mut optionals = BitString::new();
        optionals.push(self.qos_flow_mapping_indication.is_some());
        optionals.push(num_ies != 0);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.qos_flow_identifier.encode(data)?;
        self.qos_flow_level_qos_parameters.encode(data)?;
        if let Some(x) = &self.qos_flow_mapping_indication {
            x.encode(data)?;
        }
        if num_ies != 0 {
            encode::encode_length_determinent(data, Some(1), Some(65535), false, num_ies)?;
            data.append_aligned(ies);
        }
        Ok(())
    }
}

impl PerCodec for QosFlowQosParameterItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        QosFlowQosParameterItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("QosFlowQosParameterItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("QosFlowQosParameterItem");
            e
        })
    }
}
// QosFlowLevelQosParameters
#[derive(Clone, Debug)]
pub struct QosFlowLevelQosParameters {
    pub qos_characteristics: QosCharacteristics,
    pub ngran_allocation_retention_priority: NgranAllocationAndRetentionPriority,
    pub gbr_qos_flow_information: Option<GbrQosFlowInformation>,
    pub reflective_qos_attribute: Option<ReflectiveQosAttribute>,
    pub additional_qos_information: Option<AdditionalQosInformation>,
    pub paging_policy_indicator: Option<u8>,
    pub reflective_qos_indicator: Option<ReflectiveQosIndicator>,
    pub qos_monitoring_request: Option<QosMonitoringRequest>,
    pub mcg_offered_gbr_qos_flow_info: Option<GbrQosFlowInformation>,
    pub qos_monitoring_reporting_frequency: Option<QosMonitoringReportingFrequency>,
    pub qos_monitoring_disabled: Option<QosMonitoringDisabled>,
}

impl QosFlowLevelQosParameters {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, false, 6)?;
        let qos_characteristics = QosCharacteristics::decode(data)?;
        let ngran_allocation_retention_priority =
            NgranAllocationAndRetentionPriority::decode(data)?;
        let gbr_qos_flow_information = if optionals[0] {
            Some(GbrQosFlowInformation::decode(data)?)
        } else {
            None
        };
        let reflective_qos_attribute = if optionals[1] {
            Some(ReflectiveQosAttribute::decode(data)?)
        } else {
            None
        };
        let additional_qos_information = if optionals[2] {
            Some(AdditionalQosInformation::decode(data)?)
        } else {
            None
        };
        let paging_policy_indicator = if optionals[3] {
            Some(decode::decode_integer(data, Some(1), Some(8), true)?.0 as u8)
        } else {
            None
        };
        let reflective_qos_indicator = if optionals[4] {
            Some(ReflectiveQosIndicator::decode(data)?)
        } else {
            None
        };

        // Process the extension container
        let mut qos_monitoring_request: Option<QosMonitoringRequest> = None;
        let mut mcg_offered_gbr_qos_flow_info: Option<GbrQosFlowInformation> = None;
        let mut qos_monitoring_reporting_frequency: Option<QosMonitoringReportingFrequency> = None;
        let mut qos_monitoring_disabled: Option<QosMonitoringDisabled> = None;

        if optionals[5] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    87 => qos_monitoring_request = Some(QosMonitoringRequest::decode(data)?),
                    126 => {
                        mcg_offered_gbr_qos_flow_info = Some(GbrQosFlowInformation::decode(data)?)
                    }
                    132 => {
                        qos_monitoring_reporting_frequency =
                            Some(QosMonitoringReportingFrequency::decode(data)?)
                    }
                    133 => qos_monitoring_disabled = Some(QosMonitoringDisabled::decode(data)?),
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            qos_characteristics,
            ngran_allocation_retention_priority,
            gbr_qos_flow_information,
            reflective_qos_attribute,
            additional_qos_information,
            paging_policy_indicator,
            reflective_qos_indicator,
            qos_monitoring_request,
            mcg_offered_gbr_qos_flow_info,
            qos_monitoring_reporting_frequency,
            qos_monitoring_disabled,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();
        if let Some(x) = &self.qos_monitoring_request {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 87, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.mcg_offered_gbr_qos_flow_info {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 126, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.qos_monitoring_reporting_frequency {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 132, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.qos_monitoring_disabled {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 133, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        let mut optionals = BitString::new();
        optionals.push(self.gbr_qos_flow_information.is_some());
        optionals.push(self.reflective_qos_attribute.is_some());
        optionals.push(self.additional_qos_information.is_some());
        optionals.push(self.paging_policy_indicator.is_some());
        optionals.push(self.reflective_qos_indicator.is_some());
        optionals.push(num_ies != 0);

        encode::encode_sequence_header(data, false, &optionals, false)?;
        self.qos_characteristics.encode(data)?;
        self.ngran_allocation_retention_priority.encode(data)?;
        if let Some(x) = &self.gbr_qos_flow_information {
            x.encode(data)?;
        }
        if let Some(x) = &self.reflective_qos_attribute {
            x.encode(data)?;
        }
        if let Some(x) = &self.additional_qos_information {
            x.encode(data)?;
        }
        if let Some(x) = &self.paging_policy_indicator {
            encode::encode_integer(data, Some(1), Some(8), true, *x as i128, false)?;
        }
        if let Some(x) = &self.reflective_qos_indicator {
            x.encode(data)?;
        }
        if num_ies != 0 {
            encode::encode_length_determinent(data, Some(1), Some(65535), false, num_ies)?;
            data.append_aligned(ies);
        }
        Ok(())
    }
}

impl PerCodec for QosFlowLevelQosParameters {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        QosFlowLevelQosParameters::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("QosFlowLevelQosParameters");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("QosFlowLevelQosParameters");
            e
        })
    }
}
// QosMonitoringRequest
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum QosMonitoringRequest {
    Ul,
    Dl,
    Both,
}

impl QosMonitoringRequest {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(2), false)?;
        if extended {
            return Err(PerCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(data, Some(0), Some(2), false, *self as i128, false)
    }
}

impl PerCodec for QosMonitoringRequest {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        QosMonitoringRequest::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("QosMonitoringRequest");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("QosMonitoringRequest");
            e
        })
    }
}
// QosMonitoringReportingFrequency
#[derive(Clone, Copy, Debug)]
pub struct QosMonitoringReportingFrequency(pub u16);

impl QosMonitoringReportingFrequency {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(
            decode::decode_integer(data, Some(1), Some(1800), true)?.0 as u16,
        ))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_integer(data, Some(1), Some(1800), true, self.0 as i128, false)
    }
}

impl PerCodec for QosMonitoringReportingFrequency {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        QosMonitoringReportingFrequency::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("QosMonitoringReportingFrequency");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("QosMonitoringReportingFrequency");
            e
        })
    }
}
// QosMonitoringDisabled
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum QosMonitoringDisabled {
    True,
}

impl QosMonitoringDisabled {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(0), true)?;
        if extended {
            return Err(PerCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(data, Some(0), Some(0), true, *self as i128, false)
    }
}

impl PerCodec for QosMonitoringDisabled {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        QosMonitoringDisabled::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("QosMonitoringDisabled");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("QosMonitoringDisabled");
            e
        })
    }
}
// QosFlowRemovedItem
#[derive(Clone, Debug)]
pub struct QosFlowRemovedItem {
    pub qos_flow_identifier: QosFlowIdentifier,
    pub qos_flow_released_in_session: Option<QosFlowReleasedInSession>,
    pub qos_flow_accumulated_session_time: Option<[u8; 5]>,
}

impl QosFlowRemovedItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 3)?;
        let qos_flow_identifier = QosFlowIdentifier::decode(data)?;
        let qos_flow_released_in_session = if optionals[0] {
            Some(QosFlowReleasedInSession::decode(data)?)
        } else {
            None
        };
        let qos_flow_accumulated_session_time = if optionals[1] {
            Some(
                decode::decode_octetstring(data, Some(5), Some(5), false)?
                    .try_into()
                    .unwrap(),
            )
        } else {
            None
        };

        // Process the extension container

        if optionals[2] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            qos_flow_identifier,
            qos_flow_released_in_session,
            qos_flow_accumulated_session_time,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.qos_flow_released_in_session.is_some());
        optionals.push(self.qos_flow_accumulated_session_time.is_some());
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.qos_flow_identifier.encode(data)?;
        if let Some(x) = &self.qos_flow_released_in_session {
            x.encode(data)?;
        }
        if let Some(x) = &self.qos_flow_accumulated_session_time {
            encode::encode_octetstring(data, Some(5), Some(5), false, &(*x).into(), false)?;
        }

        Ok(())
    }
}

impl PerCodec for QosFlowRemovedItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        QosFlowRemovedItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("QosFlowRemovedItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("QosFlowRemovedItem");
            e
        })
    }
}
// QosFlowsToBeForwardedList
#[derive(Clone, Debug)]
pub struct QosFlowsToBeForwardedList(pub NonEmpty<QosFlowsToBeForwardedItem>);

impl QosFlowsToBeForwardedList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(64), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(QosFlowsToBeForwardedItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(64), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for QosFlowsToBeForwardedList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        QosFlowsToBeForwardedList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("QosFlowsToBeForwardedList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("QosFlowsToBeForwardedList");
            e
        })
    }
}
// QosFlowsToBeForwardedItem
#[derive(Clone, Debug)]
pub struct QosFlowsToBeForwardedItem {
    pub qos_flow_identifier: QosFlowIdentifier,
}

impl QosFlowsToBeForwardedItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let qos_flow_identifier = QosFlowIdentifier::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            qos_flow_identifier,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.qos_flow_identifier.encode(data)?;

        Ok(())
    }
}

impl PerCodec for QosFlowsToBeForwardedItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        QosFlowsToBeForwardedItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("QosFlowsToBeForwardedItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("QosFlowsToBeForwardedItem");
            e
        })
    }
}
// QosMappingInformation
#[derive(Clone, Debug)]
pub struct QosMappingInformation {
    pub dscp: Option<BitString>,
    pub flow_label: Option<BitString>,
}

impl QosMappingInformation {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 2)?;
        let dscp = if optionals[0] {
            Some(decode::decode_bitstring(data, Some(6), Some(6), false)?)
        } else {
            None
        };
        let flow_label = if optionals[1] {
            Some(decode::decode_bitstring(data, Some(20), Some(20), false)?)
        } else {
            None
        };

        Ok(Self { dscp, flow_label })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.dscp.is_some());
        optionals.push(self.flow_label.is_some());

        encode::encode_sequence_header(data, true, &optionals, false)?;
        if let Some(x) = &self.dscp {
            encode::encode_bitstring(data, Some(6), Some(6), false, &x, false)?;
        }
        if let Some(x) = &self.flow_label {
            encode::encode_bitstring(data, Some(20), Some(20), false, &x, false)?;
        }

        Ok(())
    }
}

impl PerCodec for QosMappingInformation {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        QosMappingInformation::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("QosMappingInformation");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("QosMappingInformation");
            e
        })
    }
}
// DataForwardingtoNgRanQosFlowInformationList
#[derive(Clone, Debug)]
pub struct DataForwardingtoNgRanQosFlowInformationList(
    pub NonEmpty<DataForwardingtoNgRanQosFlowInformationListItem>,
);

impl DataForwardingtoNgRanQosFlowInformationList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(64), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(DataForwardingtoNgRanQosFlowInformationListItem::decode(
                    data,
                )?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(64), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for DataForwardingtoNgRanQosFlowInformationList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        DataForwardingtoNgRanQosFlowInformationList::decode_inner(data).map_err(
            |mut e: PerCodecError| {
                e.push_context("DataForwardingtoNgRanQosFlowInformationList");
                e
            },
        )
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DataForwardingtoNgRanQosFlowInformationList");
            e
        })
    }
}
// DataForwardingtoNgRanQosFlowInformationListItem
#[derive(Clone, Debug)]
pub struct DataForwardingtoNgRanQosFlowInformationListItem {
    pub qos_flow_identifier: QosFlowIdentifier,
}

impl DataForwardingtoNgRanQosFlowInformationListItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let qos_flow_identifier = QosFlowIdentifier::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            qos_flow_identifier,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.qos_flow_identifier.encode(data)?;

        Ok(())
    }
}

impl PerCodec for DataForwardingtoNgRanQosFlowInformationListItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        DataForwardingtoNgRanQosFlowInformationListItem::decode_inner(data).map_err(
            |mut e: PerCodecError| {
                e.push_context("DataForwardingtoNgRanQosFlowInformationListItem");
                e
            },
        )
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DataForwardingtoNgRanQosFlowInformationListItem");
            e
        })
    }
}
// RanUeId
#[derive(Clone, Debug)]
pub struct RanUeId(pub [u8; 8]);

impl RanUeId {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(
            decode::decode_octetstring(data, Some(8), Some(8), false)?
                .try_into()
                .unwrap(),
        ))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_octetstring(data, Some(8), Some(8), false, &(self.0).into(), false)
    }
}

impl PerCodec for RanUeId {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        RanUeId::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("RanUeId");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("RanUeId");
            e
        })
    }
}
// RatType
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum RatType {
    EUtra,
    Nr,
}

impl RatType {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(1), true)?;
        if extended {
            return Err(PerCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(data, Some(0), Some(1), true, *self as i128, false)
    }
}

impl PerCodec for RatType {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        RatType::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("RatType");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("RatType");
            e
        })
    }
}
// RedundantQosFlowIndicator
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum RedundantQosFlowIndicator {
    True,
    False,
}

impl RedundantQosFlowIndicator {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(1), false)?;
        if extended {
            return Err(PerCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(data, Some(0), Some(1), false, *self as i128, false)
    }
}

impl PerCodec for RedundantQosFlowIndicator {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        RedundantQosFlowIndicator::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("RedundantQosFlowIndicator");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("RedundantQosFlowIndicator");
            e
        })
    }
}
// RedundantPduSessionInformation
#[derive(Clone, Debug)]
pub struct RedundantPduSessionInformation {
    pub rsn: Rsn,
}

impl RedundantPduSessionInformation {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let rsn = Rsn::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self { rsn })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.rsn.encode(data)?;

        Ok(())
    }
}

impl PerCodec for RedundantPduSessionInformation {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        RedundantPduSessionInformation::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("RedundantPduSessionInformation");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("RedundantPduSessionInformation");
            e
        })
    }
}
// Rsn
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum Rsn {
    V1,
    V2,
}

impl Rsn {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(1), true)?;
        if extended {
            return Err(PerCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(data, Some(0), Some(1), true, *self as i128, false)
    }
}

impl PerCodec for Rsn {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Rsn::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("Rsn");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("Rsn");
            e
        })
    }
}
// RetainabilityMeasurementsInfo
#[derive(Clone, Debug)]
pub struct RetainabilityMeasurementsInfo(pub NonEmpty<DrbRemovedItem>);

impl RetainabilityMeasurementsInfo {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(32), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(DrbRemovedItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(32), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for RetainabilityMeasurementsInfo {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        RetainabilityMeasurementsInfo::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("RetainabilityMeasurementsInfo");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("RetainabilityMeasurementsInfo");
            e
        })
    }
}
// RegistrationRequest
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum RegistrationRequest {
    Start,
    Stop,
}

impl RegistrationRequest {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(1), true)?;
        if extended {
            return Err(PerCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(data, Some(0), Some(1), true, *self as i128, false)
    }
}

impl PerCodec for RegistrationRequest {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        RegistrationRequest::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("RegistrationRequest");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("RegistrationRequest");
            e
        })
    }
}
// ReportCharacteristics
#[derive(Clone, Debug)]
pub struct ReportCharacteristics(pub BitString);

impl ReportCharacteristics {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(decode::decode_bitstring(
            data,
            Some(36),
            Some(36),
            false,
        )?))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_bitstring(data, Some(36), Some(36), false, &self.0, false)
    }
}

impl PerCodec for ReportCharacteristics {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        ReportCharacteristics::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ReportCharacteristics");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ReportCharacteristics");
            e
        })
    }
}
// ReportingPeriodicity
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum ReportingPeriodicity {
    Ms500,
    Ms1000,
    Ms2000,
    Ms5000,
    Ms10000,
    Ms20000,
    Ms30000,
    Ms40000,
    Ms50000,
    Ms60000,
    Ms70000,
    Ms80000,
    Ms90000,
    Ms100000,
    Ms110000,
    Ms120000,
}

impl ReportingPeriodicity {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(15), true)?;
        if extended {
            return Err(PerCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(data, Some(0), Some(15), true, *self as i128, false)
    }
}

impl PerCodec for ReportingPeriodicity {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        ReportingPeriodicity::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ReportingPeriodicity");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ReportingPeriodicity");
            e
        })
    }
}
// RlcMode
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum RlcMode {
    RlcTm,
    RlcAm,
    RlcUmBidirectional,
    RlcUmUnidirectionalUl,
    RlcUmUnidirectionalDl,
}

impl RlcMode {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(4), true)?;
        if extended {
            return Err(PerCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(data, Some(0), Some(4), true, *self as i128, false)
    }
}

impl PerCodec for RlcMode {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        RlcMode::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("RlcMode");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("RlcMode");
            e
        })
    }
}
// RohcParameters
#[derive(Clone, Debug)]
pub enum RohcParameters {
    Rohc(Rohc),
    UPlinkOnlyRohc(UplinkOnlyRohc),
}

impl RohcParameters {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_choice_idx(data, 0, 2, false)?;
        if extended {
            return Err(PerCodecError::new("CHOICE additions not implemented"));
        }
        match idx {
            0 => Ok(Self::Rohc(Rohc::decode(data)?)),
            1 => Ok(Self::UPlinkOnlyRohc(UplinkOnlyRohc::decode(data)?)),
            2 => {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _ = Criticality::decode(data)?;
                let _ = decode::decode_length_determinent(data, None, None, false)?;
                let result = match id {
                    x => Err(PerCodecError::new(format!("Unrecognised IE type {}", x))),
                };
                data.decode_align()?;
                result
            }
            _ => Err(PerCodecError::new("Unknown choice idx")),
        }
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        match self {
            Self::Rohc(x) => {
                encode::encode_choice_idx(data, 0, 2, false, 0, false)?;
                x.encode(data)
            }
            Self::UPlinkOnlyRohc(x) => {
                encode::encode_choice_idx(data, 0, 2, false, 1, false)?;
                x.encode(data)
            }
        }
    }
}

impl PerCodec for RohcParameters {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        RohcParameters::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("RohcParameters");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("RohcParameters");
            e
        })
    }
}
// Rohc
#[derive(Clone, Debug)]
pub struct Rohc {
    pub max_cid: u16,
    pub rohc_profiles: u16,
    pub continue_rohc: Option<ContinueRohc>,
}

impl Rohc {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, false, 2)?;
        let max_cid = decode::decode_integer(data, Some(0), Some(16383), true)?.0 as u16;
        let rohc_profiles = decode::decode_integer(data, Some(0), Some(511), true)?.0 as u16;
        let continue_rohc = if optionals[0] {
            Some(ContinueRohc::decode(data)?)
        } else {
            None
        };

        // Process the extension container

        if optionals[1] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            max_cid,
            rohc_profiles,
            continue_rohc,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.continue_rohc.is_some());
        optionals.push(false);

        encode::encode_sequence_header(data, false, &optionals, false)?;
        encode::encode_integer(
            data,
            Some(0),
            Some(16383),
            true,
            self.max_cid as i128,
            false,
        )?;
        encode::encode_integer(
            data,
            Some(0),
            Some(511),
            true,
            self.rohc_profiles as i128,
            false,
        )?;
        if let Some(x) = &self.continue_rohc {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl PerCodec for Rohc {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Rohc::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("Rohc");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("Rohc");
            e
        })
    }
}
// SecurityAlgorithm
#[derive(Clone, Debug)]
pub struct SecurityAlgorithm {
    pub ciphering_algorithm: CipheringAlgorithm,
    pub integrity_protection_algorithm: Option<IntegrityProtectionAlgorithm>,
}

impl SecurityAlgorithm {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 2)?;
        let ciphering_algorithm = CipheringAlgorithm::decode(data)?;
        let integrity_protection_algorithm = if optionals[0] {
            Some(IntegrityProtectionAlgorithm::decode(data)?)
        } else {
            None
        };

        // Process the extension container

        if optionals[1] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            ciphering_algorithm,
            integrity_protection_algorithm,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.integrity_protection_algorithm.is_some());
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.ciphering_algorithm.encode(data)?;
        if let Some(x) = &self.integrity_protection_algorithm {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl PerCodec for SecurityAlgorithm {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        SecurityAlgorithm::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SecurityAlgorithm");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SecurityAlgorithm");
            e
        })
    }
}
// SecurityIndication
#[derive(Clone, Debug)]
pub struct SecurityIndication {
    pub integrity_protection_indication: IntegrityProtectionIndication,
    pub confidentiality_protection_indication: ConfidentialityProtectionIndication,
    pub maximum_i_pdatarate: Option<MaximumIPdatarate>,
}

impl SecurityIndication {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 2)?;
        let integrity_protection_indication = IntegrityProtectionIndication::decode(data)?;
        let confidentiality_protection_indication =
            ConfidentialityProtectionIndication::decode(data)?;
        let maximum_i_pdatarate = if optionals[0] {
            Some(MaximumIPdatarate::decode(data)?)
        } else {
            None
        };

        // Process the extension container

        if optionals[1] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            integrity_protection_indication,
            confidentiality_protection_indication,
            maximum_i_pdatarate,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.maximum_i_pdatarate.is_some());
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.integrity_protection_indication.encode(data)?;
        self.confidentiality_protection_indication.encode(data)?;
        if let Some(x) = &self.maximum_i_pdatarate {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl PerCodec for SecurityIndication {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        SecurityIndication::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SecurityIndication");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SecurityIndication");
            e
        })
    }
}
// SecurityInformation
#[derive(Clone, Debug)]
pub struct SecurityInformation {
    pub security_algorithm: SecurityAlgorithm,
    pub up_securitykey: UpSecuritykey,
}

impl SecurityInformation {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let security_algorithm = SecurityAlgorithm::decode(data)?;
        let up_securitykey = UpSecuritykey::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            security_algorithm,
            up_securitykey,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.security_algorithm.encode(data)?;
        self.up_securitykey.encode(data)?;

        Ok(())
    }
}

impl PerCodec for SecurityInformation {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        SecurityInformation::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SecurityInformation");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SecurityInformation");
            e
        })
    }
}
// SecurityResult
#[derive(Clone, Debug)]
pub struct SecurityResult {
    pub integrity_protection_result: IntegrityProtectionResult,
    pub confidentiality_protection_result: ConfidentialityProtectionResult,
}

impl SecurityResult {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let integrity_protection_result = IntegrityProtectionResult::decode(data)?;
        let confidentiality_protection_result = ConfidentialityProtectionResult::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            integrity_protection_result,
            confidentiality_protection_result,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.integrity_protection_result.encode(data)?;
        self.confidentiality_protection_result.encode(data)?;

        Ok(())
    }
}

impl PerCodec for SecurityResult {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        SecurityResult::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SecurityResult");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SecurityResult");
            e
        })
    }
}
// SliceSupportList
#[derive(Clone, Debug)]
pub struct SliceSupportList(pub NonEmpty<SliceSupportItem>);

impl SliceSupportList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(1024), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(SliceSupportItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(1024), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for SliceSupportList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        SliceSupportList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SliceSupportList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SliceSupportList");
            e
        })
    }
}
// SliceSupportItem
#[derive(Clone, Debug)]
pub struct SliceSupportItem {
    pub snssai: Snssai,
}

impl SliceSupportItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, false, 1)?;
        let snssai = Snssai::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self { snssai })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, false, &optionals, false)?;
        self.snssai.encode(data)?;

        Ok(())
    }
}

impl PerCodec for SliceSupportItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        SliceSupportItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SliceSupportItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SliceSupportItem");
            e
        })
    }
}
// Snssai
#[derive(Clone, Debug)]
pub struct Snssai {
    pub sst: [u8; 1],
    pub sd: Option<[u8; 3]>,
}

impl Snssai {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 2)?;
        let sst = decode::decode_octetstring(data, Some(1), Some(1), false)?
            .try_into()
            .unwrap();
        let sd = if optionals[0] {
            Some(
                decode::decode_octetstring(data, Some(3), Some(3), false)?
                    .try_into()
                    .unwrap(),
            )
        } else {
            None
        };

        // Process the extension container

        if optionals[1] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self { sst, sd })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.sd.is_some());
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        encode::encode_octetstring(data, Some(1), Some(1), false, &(self.sst).into(), false)?;
        if let Some(x) = &self.sd {
            encode::encode_octetstring(data, Some(3), Some(3), false, &(*x).into(), false)?;
        }

        Ok(())
    }
}

impl PerCodec for Snssai {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Snssai::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("Snssai");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("Snssai");
            e
        })
    }
}
// SdapConfiguration
#[derive(Clone, Debug)]
pub struct SdapConfiguration {
    pub default_drb: DefaultDrb,
    pub sdap_header_ul: SdapHeaderUl,
    pub sdap_header_dl: SdapHeaderDl,
}

impl SdapConfiguration {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let default_drb = DefaultDrb::decode(data)?;
        let sdap_header_ul = SdapHeaderUl::decode(data)?;
        let sdap_header_dl = SdapHeaderDl::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            default_drb,
            sdap_header_ul,
            sdap_header_dl,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.default_drb.encode(data)?;
        self.sdap_header_ul.encode(data)?;
        self.sdap_header_dl.encode(data)?;

        Ok(())
    }
}

impl PerCodec for SdapConfiguration {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        SdapConfiguration::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SdapConfiguration");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SdapConfiguration");
            e
        })
    }
}
// SdapHeaderDl
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum SdapHeaderDl {
    Present,
    Absent,
}

impl SdapHeaderDl {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(1), true)?;
        if extended {
            return Err(PerCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(data, Some(0), Some(1), true, *self as i128, false)
    }
}

impl PerCodec for SdapHeaderDl {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        SdapHeaderDl::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SdapHeaderDl");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SdapHeaderDl");
            e
        })
    }
}
// SdapHeaderUl
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum SdapHeaderUl {
    Present,
    Absent,
}

impl SdapHeaderUl {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(1), true)?;
        if extended {
            return Err(PerCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(data, Some(0), Some(1), true, *self as i128, false)
    }
}

impl PerCodec for SdapHeaderUl {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        SdapHeaderUl::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SdapHeaderUl");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SdapHeaderUl");
            e
        })
    }
}
// SubscriberProfileIDforRfp
#[derive(Clone, Copy, Debug)]
pub struct SubscriberProfileIDforRfp(pub u16);

impl SubscriberProfileIDforRfp {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(
            decode::decode_integer(data, Some(1), Some(256), true)?.0 as u16,
        ))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_integer(data, Some(1), Some(256), true, self.0 as i128, false)
    }
}

impl PerCodec for SubscriberProfileIDforRfp {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        SubscriberProfileIDforRfp::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SubscriberProfileIDforRfp");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SubscriberProfileIDforRfp");
            e
        })
    }
}
// TimeToWait
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum TimeToWait {
    V1s,
    V2s,
    V5s,
    V10s,
    V20s,
    V60s,
}

impl TimeToWait {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(5), true)?;
        if extended {
            return Err(PerCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(data, Some(0), Some(5), true, *self as i128, false)
    }
}

impl PerCodec for TimeToWait {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        TimeToWait::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TimeToWait");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TimeToWait");
            e
        })
    }
}
// TnlAssociationUsage
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum TnlAssociationUsage {
    Ue,
    NonUe,
    Both,
}

impl TnlAssociationUsage {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(2), true)?;
        if extended {
            return Err(PerCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(data, Some(0), Some(2), true, *self as i128, false)
    }
}

impl PerCodec for TnlAssociationUsage {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        TnlAssociationUsage::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TnlAssociationUsage");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TnlAssociationUsage");
            e
        })
    }
}
// TnlAvailableCapacityIndicator
#[derive(Clone, Debug)]
pub struct TnlAvailableCapacityIndicator {
    pub dl_tnl_offered_capacity: u32,
    pub dl_tnl_available_capacity: u8,
    pub ul_tnl_offered_capacity: u32,
    pub ul_tnl_available_capacity: u8,
}

impl TnlAvailableCapacityIndicator {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let dl_tnl_offered_capacity =
            decode::decode_integer(data, Some(0), Some(16777216), true)?.0 as u32;
        let dl_tnl_available_capacity =
            decode::decode_integer(data, Some(0), Some(100), true)?.0 as u8;
        let ul_tnl_offered_capacity =
            decode::decode_integer(data, Some(0), Some(16777216), true)?.0 as u32;
        let ul_tnl_available_capacity =
            decode::decode_integer(data, Some(0), Some(100), true)?.0 as u8;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            dl_tnl_offered_capacity,
            dl_tnl_available_capacity,
            ul_tnl_offered_capacity,
            ul_tnl_available_capacity,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        encode::encode_integer(
            data,
            Some(0),
            Some(16777216),
            true,
            self.dl_tnl_offered_capacity as i128,
            false,
        )?;
        encode::encode_integer(
            data,
            Some(0),
            Some(100),
            true,
            self.dl_tnl_available_capacity as i128,
            false,
        )?;
        encode::encode_integer(
            data,
            Some(0),
            Some(16777216),
            true,
            self.ul_tnl_offered_capacity as i128,
            false,
        )?;
        encode::encode_integer(
            data,
            Some(0),
            Some(100),
            true,
            self.ul_tnl_available_capacity as i128,
            false,
        )?;

        Ok(())
    }
}

impl PerCodec for TnlAvailableCapacityIndicator {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        TnlAvailableCapacityIndicator::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TnlAvailableCapacityIndicator");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TnlAvailableCapacityIndicator");
            e
        })
    }
}
// TscTrafficCharacteristics
#[derive(Clone, Debug)]
pub struct TscTrafficCharacteristics {
    pub tsc_traffic_characteristics_ul: Option<TscTrafficInformation>,
    pub tsc_traffic_characteristics_dl: Option<TscTrafficInformation>,
}

impl TscTrafficCharacteristics {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, false, 3)?;
        let tsc_traffic_characteristics_ul = if optionals[0] {
            Some(TscTrafficInformation::decode(data)?)
        } else {
            None
        };
        let tsc_traffic_characteristics_dl = if optionals[1] {
            Some(TscTrafficInformation::decode(data)?)
        } else {
            None
        };

        // Process the extension container

        if optionals[2] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            tsc_traffic_characteristics_ul,
            tsc_traffic_characteristics_dl,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.tsc_traffic_characteristics_ul.is_some());
        optionals.push(self.tsc_traffic_characteristics_dl.is_some());
        optionals.push(false);

        encode::encode_sequence_header(data, false, &optionals, false)?;
        if let Some(x) = &self.tsc_traffic_characteristics_ul {
            x.encode(data)?;
        }
        if let Some(x) = &self.tsc_traffic_characteristics_dl {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl PerCodec for TscTrafficCharacteristics {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        TscTrafficCharacteristics::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TscTrafficCharacteristics");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TscTrafficCharacteristics");
            e
        })
    }
}
// TscTrafficInformation
#[derive(Clone, Debug)]
pub struct TscTrafficInformation {
    pub periodicity: Periodicity,
    pub burst_arrival_time: Option<BurstArrivalTime>,
}

impl TscTrafficInformation {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, false, 2)?;
        let periodicity = Periodicity::decode(data)?;
        let burst_arrival_time = if optionals[0] {
            Some(BurstArrivalTime::decode(data)?)
        } else {
            None
        };

        // Process the extension container

        if optionals[1] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            periodicity,
            burst_arrival_time,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.burst_arrival_time.is_some());
        optionals.push(false);

        encode::encode_sequence_header(data, false, &optionals, false)?;
        self.periodicity.encode(data)?;
        if let Some(x) = &self.burst_arrival_time {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl PerCodec for TscTrafficInformation {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        TscTrafficInformation::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TscTrafficInformation");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TscTrafficInformation");
            e
        })
    }
}
// Periodicity
#[derive(Clone, Copy, Debug)]
pub struct Periodicity(pub u32);

impl Periodicity {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(
            decode::decode_integer(data, Some(1), Some(640000), true)?.0 as u32,
        ))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_integer(data, Some(1), Some(640000), true, self.0 as i128, false)
    }
}

impl PerCodec for Periodicity {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Periodicity::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("Periodicity");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("Periodicity");
            e
        })
    }
}
// BurstArrivalTime
#[derive(Clone, Debug)]
pub struct BurstArrivalTime(pub Vec<u8>);

impl BurstArrivalTime {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(decode::decode_octetstring(data, None, None, false)?))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_octetstring(data, None, None, false, &self.0, false)
    }
}

impl PerCodec for BurstArrivalTime {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        BurstArrivalTime::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("BurstArrivalTime");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("BurstArrivalTime");
            e
        })
    }
}
// TraceActivation
#[derive(Clone, Debug)]
pub struct TraceActivation {
    pub trace_id: TraceId,
    pub interfaces_to_trace: InterfacesToTrace,
    pub trace_depth: TraceDepth,
    pub trace_collection_entity_ip_address: TransportLayerAddress,
    pub mdt_configuration: Option<MdtConfiguration>,
    pub trace_collection_entity_uri: Option<UrIaddress>,
}

impl TraceActivation {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let trace_id = TraceId::decode(data)?;
        let interfaces_to_trace = InterfacesToTrace::decode(data)?;
        let trace_depth = TraceDepth::decode(data)?;
        let trace_collection_entity_ip_address = TransportLayerAddress::decode(data)?;

        // Process the extension container
        let mut mdt_configuration: Option<MdtConfiguration> = None;
        let mut trace_collection_entity_uri: Option<UrIaddress> = None;

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    112 => mdt_configuration = Some(MdtConfiguration::decode(data)?),
                    116 => trace_collection_entity_uri = Some(UrIaddress::decode(data)?),
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            trace_id,
            interfaces_to_trace,
            trace_depth,
            trace_collection_entity_ip_address,
            mdt_configuration,
            trace_collection_entity_uri,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();
        if let Some(x) = &self.mdt_configuration {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 112, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.trace_collection_entity_uri {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 116, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        let mut optionals = BitString::new();
        optionals.push(num_ies != 0);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.trace_id.encode(data)?;
        self.interfaces_to_trace.encode(data)?;
        self.trace_depth.encode(data)?;
        self.trace_collection_entity_ip_address.encode(data)?;
        if num_ies != 0 {
            encode::encode_length_determinent(data, Some(1), Some(65535), false, num_ies)?;
            data.append_aligned(ies);
        }
        Ok(())
    }
}

impl PerCodec for TraceActivation {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        TraceActivation::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TraceActivation");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TraceActivation");
            e
        })
    }
}
// TraceDepth
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum TraceDepth {
    Minimum,
    Medium,
    Maximum,
    MinimumWithoutVendorSpecificExtension,
    MediumWithoutVendorSpecificExtension,
    MaximumWithoutVendorSpecificExtension,
}

impl TraceDepth {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(5), true)?;
        if extended {
            return Err(PerCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(data, Some(0), Some(5), true, *self as i128, false)
    }
}

impl PerCodec for TraceDepth {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        TraceDepth::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TraceDepth");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TraceDepth");
            e
        })
    }
}
// TraceId
#[derive(Clone, Debug)]
pub struct TraceId(pub [u8; 8]);

impl TraceId {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(
            decode::decode_octetstring(data, Some(8), Some(8), false)?
                .try_into()
                .unwrap(),
        ))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_octetstring(data, Some(8), Some(8), false, &(self.0).into(), false)
    }
}

impl PerCodec for TraceId {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        TraceId::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TraceId");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TraceId");
            e
        })
    }
}
// TransactionId
#[derive(Clone, Copy, Debug)]
pub struct TransactionId(pub u8);

impl TransactionId {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(
            decode::decode_integer(data, Some(0), Some(255), true)?.0 as u8,
        ))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_integer(data, Some(0), Some(255), true, self.0 as i128, false)
    }
}

impl PerCodec for TransactionId {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        TransactionId::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TransactionId");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TransactionId");
            e
        })
    }
}
// TReordering
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum TReordering {
    Ms0,
    Ms1,
    Ms2,
    Ms4,
    Ms5,
    Ms8,
    Ms10,
    Ms15,
    Ms20,
    Ms30,
    Ms40,
    Ms50,
    Ms60,
    Ms80,
    Ms100,
    Ms120,
    Ms140,
    Ms160,
    Ms180,
    Ms200,
    Ms220,
    Ms240,
    Ms260,
    Ms280,
    Ms300,
    Ms500,
    Ms750,
    Ms1000,
    Ms1250,
    Ms1500,
    Ms1750,
    Ms2000,
    Ms2250,
    Ms2500,
    Ms2750,
    Ms3000,
}

impl TReordering {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(35), true)?;
        if extended {
            return Err(PerCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(data, Some(0), Some(35), true, *self as i128, false)
    }
}

impl PerCodec for TReordering {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        TReordering::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TReordering");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TReordering");
            e
        })
    }
}
// TReorderingTimer
#[derive(Clone, Debug)]
pub struct TReorderingTimer {
    pub t_reordering: TReordering,
}

impl TReorderingTimer {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let t_reordering = TReordering::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self { t_reordering })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.t_reordering.encode(data)?;

        Ok(())
    }
}

impl PerCodec for TReorderingTimer {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        TReorderingTimer::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TReorderingTimer");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TReorderingTimer");
            e
        })
    }
}
// TypeOfError
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum TypeOfError {
    NotUnderstood,
    Missing,
}

impl TypeOfError {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(1), true)?;
        if extended {
            return Err(PerCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(data, Some(0), Some(1), true, *self as i128, false)
    }
}

impl PerCodec for TypeOfError {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        TypeOfError::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TypeOfError");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TypeOfError");
            e
        })
    }
}
// TransportLayerAddressInfo
#[derive(Clone, Debug)]
pub struct TransportLayerAddressInfo {
    pub transport_up_layer_addresses_info_to_add_list:
        Option<TransportUpLayerAddressesInfoToAddList>,
    pub transport_up_layer_addresses_info_to_remove_list:
        Option<TransportUpLayerAddressesInfoToRemoveList>,
}

impl TransportLayerAddressInfo {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 3)?;
        let transport_up_layer_addresses_info_to_add_list = if optionals[0] {
            Some(TransportUpLayerAddressesInfoToAddList::decode(data)?)
        } else {
            None
        };
        let transport_up_layer_addresses_info_to_remove_list = if optionals[1] {
            Some(TransportUpLayerAddressesInfoToRemoveList::decode(data)?)
        } else {
            None
        };

        // Process the extension container

        if optionals[2] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            transport_up_layer_addresses_info_to_add_list,
            transport_up_layer_addresses_info_to_remove_list,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.transport_up_layer_addresses_info_to_add_list.is_some());
        optionals.push(
            self.transport_up_layer_addresses_info_to_remove_list
                .is_some(),
        );
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        if let Some(x) = &self.transport_up_layer_addresses_info_to_add_list {
            x.encode(data)?;
        }
        if let Some(x) = &self.transport_up_layer_addresses_info_to_remove_list {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl PerCodec for TransportLayerAddressInfo {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        TransportLayerAddressInfo::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TransportLayerAddressInfo");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TransportLayerAddressInfo");
            e
        })
    }
}
// TransportUpLayerAddressesInfoToAddList
#[derive(Clone, Debug)]
pub struct TransportUpLayerAddressesInfoToAddList(
    pub NonEmpty<TransportUpLayerAddressesInfoToAddItem>,
);

impl TransportUpLayerAddressesInfoToAddList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(16), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(TransportUpLayerAddressesInfoToAddItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(16), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for TransportUpLayerAddressesInfoToAddList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        TransportUpLayerAddressesInfoToAddList::decode_inner(data).map_err(
            |mut e: PerCodecError| {
                e.push_context("TransportUpLayerAddressesInfoToAddList");
                e
            },
        )
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TransportUpLayerAddressesInfoToAddList");
            e
        })
    }
}
// TransportUpLayerAddressesInfoToAddItem
#[derive(Clone, Debug)]
pub struct TransportUpLayerAddressesInfoToAddItem {
    pub ip_sec_transport_layer_address: TransportLayerAddress,
    pub gtp_transport_layer_addresses_to_add: Option<GtptlAs>,
}

impl TransportUpLayerAddressesInfoToAddItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 2)?;
        let ip_sec_transport_layer_address = TransportLayerAddress::decode(data)?;
        let gtp_transport_layer_addresses_to_add = if optionals[0] {
            Some(GtptlAs::decode(data)?)
        } else {
            None
        };

        // Process the extension container

        if optionals[1] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            ip_sec_transport_layer_address,
            gtp_transport_layer_addresses_to_add,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.gtp_transport_layer_addresses_to_add.is_some());
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.ip_sec_transport_layer_address.encode(data)?;
        if let Some(x) = &self.gtp_transport_layer_addresses_to_add {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl PerCodec for TransportUpLayerAddressesInfoToAddItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        TransportUpLayerAddressesInfoToAddItem::decode_inner(data).map_err(
            |mut e: PerCodecError| {
                e.push_context("TransportUpLayerAddressesInfoToAddItem");
                e
            },
        )
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TransportUpLayerAddressesInfoToAddItem");
            e
        })
    }
}
// TransportUpLayerAddressesInfoToRemoveList
#[derive(Clone, Debug)]
pub struct TransportUpLayerAddressesInfoToRemoveList(
    pub NonEmpty<TransportUpLayerAddressesInfoToRemoveItem>,
);

impl TransportUpLayerAddressesInfoToRemoveList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(16), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(TransportUpLayerAddressesInfoToRemoveItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(16), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for TransportUpLayerAddressesInfoToRemoveList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        TransportUpLayerAddressesInfoToRemoveList::decode_inner(data).map_err(
            |mut e: PerCodecError| {
                e.push_context("TransportUpLayerAddressesInfoToRemoveList");
                e
            },
        )
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TransportUpLayerAddressesInfoToRemoveList");
            e
        })
    }
}
// TransportUpLayerAddressesInfoToRemoveItem
#[derive(Clone, Debug)]
pub struct TransportUpLayerAddressesInfoToRemoveItem {
    pub ip_sec_transport_layer_address: TransportLayerAddress,
    pub gtp_transport_layer_addresses_to_remove: Option<GtptlAs>,
}

impl TransportUpLayerAddressesInfoToRemoveItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 2)?;
        let ip_sec_transport_layer_address = TransportLayerAddress::decode(data)?;
        let gtp_transport_layer_addresses_to_remove = if optionals[0] {
            Some(GtptlAs::decode(data)?)
        } else {
            None
        };

        // Process the extension container

        if optionals[1] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            ip_sec_transport_layer_address,
            gtp_transport_layer_addresses_to_remove,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.gtp_transport_layer_addresses_to_remove.is_some());
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.ip_sec_transport_layer_address.encode(data)?;
        if let Some(x) = &self.gtp_transport_layer_addresses_to_remove {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl PerCodec for TransportUpLayerAddressesInfoToRemoveItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        TransportUpLayerAddressesInfoToRemoveItem::decode_inner(data).map_err(
            |mut e: PerCodecError| {
                e.push_context("TransportUpLayerAddressesInfoToRemoveItem");
                e
            },
        )
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TransportUpLayerAddressesInfoToRemoveItem");
            e
        })
    }
}
// UeActivity
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum UeActivity {
    Active,
    NotActive,
}

impl UeActivity {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(1), true)?;
        if extended {
            return Err(PerCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(data, Some(0), Some(1), true, *self as i128, false)
    }
}

impl PerCodec for UeActivity {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        UeActivity::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UeActivity");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UeActivity");
            e
        })
    }
}
// UeAssociatedLogicalE1ConnectionItem
#[derive(Clone, Debug)]
pub struct UeAssociatedLogicalE1ConnectionItem {
    pub gnb_cu_cp_ue_e1ap_id: Option<GnbCuCpUeE1apId>,
    pub gnb_cu_up_ue_e1ap_id: Option<GnbCuUpUeE1apId>,
}

impl UeAssociatedLogicalE1ConnectionItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 3)?;
        let gnb_cu_cp_ue_e1ap_id = if optionals[0] {
            Some(GnbCuCpUeE1apId::decode(data)?)
        } else {
            None
        };
        let gnb_cu_up_ue_e1ap_id = if optionals[1] {
            Some(GnbCuUpUeE1apId::decode(data)?)
        } else {
            None
        };

        // Process the extension container

        if optionals[2] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            gnb_cu_cp_ue_e1ap_id,
            gnb_cu_up_ue_e1ap_id,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.gnb_cu_cp_ue_e1ap_id.is_some());
        optionals.push(self.gnb_cu_up_ue_e1ap_id.is_some());
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        if let Some(x) = &self.gnb_cu_cp_ue_e1ap_id {
            x.encode(data)?;
        }
        if let Some(x) = &self.gnb_cu_up_ue_e1ap_id {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl PerCodec for UeAssociatedLogicalE1ConnectionItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        UeAssociatedLogicalE1ConnectionItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UeAssociatedLogicalE1ConnectionItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UeAssociatedLogicalE1ConnectionItem");
            e
        })
    }
}
// UlConfiguration
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum UlConfiguration {
    NoData,
    Shared,
    Only,
}

impl UlConfiguration {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(2), true)?;
        if extended {
            return Err(PerCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(data, Some(0), Some(2), true, *self as i128, false)
    }
}

impl PerCodec for UlConfiguration {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        UlConfiguration::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UlConfiguration");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UlConfiguration");
            e
        })
    }
}
// UlUpTnlAddressToUpdateItem
#[derive(Clone, Debug)]
pub struct UlUpTnlAddressToUpdateItem {
    pub old_tnl_adress: TransportLayerAddress,
    pub new_tnl_adress: TransportLayerAddress,
}

impl UlUpTnlAddressToUpdateItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let old_tnl_adress = TransportLayerAddress::decode(data)?;
        let new_tnl_adress = TransportLayerAddress::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            old_tnl_adress,
            new_tnl_adress,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.old_tnl_adress.encode(data)?;
        self.new_tnl_adress.encode(data)?;

        Ok(())
    }
}

impl PerCodec for UlUpTnlAddressToUpdateItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        UlUpTnlAddressToUpdateItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UlUpTnlAddressToUpdateItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UlUpTnlAddressToUpdateItem");
            e
        })
    }
}
// UlDataSplitThreshold
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum UlDataSplitThreshold {
    B0,
    B100,
    B200,
    B400,
    B800,
    B1600,
    B3200,
    B6400,
    B12800,
    B25600,
    B51200,
    B102400,
    B204800,
    B409600,
    B819200,
    B1228800,
    B1638400,
    B2457600,
    B3276800,
    B4096000,
    B4915200,
    B5734400,
    B6553600,
    Infinity,
}

impl UlDataSplitThreshold {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(23), true)?;
        if extended {
            return Err(PerCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(data, Some(0), Some(23), true, *self as i128, false)
    }
}

impl PerCodec for UlDataSplitThreshold {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        UlDataSplitThreshold::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UlDataSplitThreshold");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UlDataSplitThreshold");
            e
        })
    }
}
// UpParameters
#[derive(Clone, Debug)]
pub struct UpParameters(pub NonEmpty<UpParametersItem>);

impl UpParameters {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(8), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(UpParametersItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(8), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for UpParameters {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        UpParameters::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UpParameters");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UpParameters");
            e
        })
    }
}
// UpParametersItem
#[derive(Clone, Debug)]
pub struct UpParametersItem {
    pub up_tnl_information: UpTnlInformation,
    pub cell_group_id: CellGroupId,
    pub qos_mapping_information: Option<QosMappingInformation>,
}

impl UpParametersItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let up_tnl_information = UpTnlInformation::decode(data)?;
        let cell_group_id = CellGroupId::decode(data)?;

        // Process the extension container
        let mut qos_mapping_information: Option<QosMappingInformation> = None;

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    107 => qos_mapping_information = Some(QosMappingInformation::decode(data)?),
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            up_tnl_information,
            cell_group_id,
            qos_mapping_information,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();
        if let Some(x) = &self.qos_mapping_information {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 107, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        let mut optionals = BitString::new();
        optionals.push(num_ies != 0);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.up_tnl_information.encode(data)?;
        self.cell_group_id.encode(data)?;
        if num_ies != 0 {
            encode::encode_length_determinent(data, Some(1), Some(65535), false, num_ies)?;
            data.append_aligned(ies);
        }
        Ok(())
    }
}

impl PerCodec for UpParametersItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        UpParametersItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UpParametersItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UpParametersItem");
            e
        })
    }
}
// UpSecuritykey
#[derive(Clone, Debug)]
pub struct UpSecuritykey {
    pub encryption_key: EncryptionKey,
    pub integrity_protection_key: Option<IntegrityProtectionKey>,
}

impl UpSecuritykey {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 2)?;
        let encryption_key = EncryptionKey::decode(data)?;
        let integrity_protection_key = if optionals[0] {
            Some(IntegrityProtectionKey::decode(data)?)
        } else {
            None
        };

        // Process the extension container

        if optionals[1] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            encryption_key,
            integrity_protection_key,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.integrity_protection_key.is_some());
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.encryption_key.encode(data)?;
        if let Some(x) = &self.integrity_protection_key {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl PerCodec for UpSecuritykey {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        UpSecuritykey::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UpSecuritykey");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UpSecuritykey");
            e
        })
    }
}
// UpTnlInformation
#[derive(Clone, Debug)]
pub enum UpTnlInformation {
    GtpTunnel(GtpTunnel),
}

impl UpTnlInformation {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_choice_idx(data, 0, 1, false)?;
        if extended {
            return Err(PerCodecError::new("CHOICE additions not implemented"));
        }
        match idx {
            0 => Ok(Self::GtpTunnel(GtpTunnel::decode(data)?)),
            1 => {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _ = Criticality::decode(data)?;
                let _ = decode::decode_length_determinent(data, None, None, false)?;
                let result = match id {
                    x => Err(PerCodecError::new(format!("Unrecognised IE type {}", x))),
                };
                data.decode_align()?;
                result
            }
            _ => Err(PerCodecError::new("Unknown choice idx")),
        }
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        match self {
            Self::GtpTunnel(x) => {
                encode::encode_choice_idx(data, 0, 1, false, 0, false)?;
                x.encode(data)
            }
        }
    }
}

impl PerCodec for UpTnlInformation {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        UpTnlInformation::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UpTnlInformation");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UpTnlInformation");
            e
        })
    }
}
// UplinkOnlyRohc
#[derive(Clone, Debug)]
pub struct UplinkOnlyRohc {
    pub max_cid: u16,
    pub rohc_profiles: u16,
    pub continue_rohc: Option<ContinueRohc1>,
}

impl UplinkOnlyRohc {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, false, 2)?;
        let max_cid = decode::decode_integer(data, Some(0), Some(16383), true)?.0 as u16;
        let rohc_profiles = decode::decode_integer(data, Some(0), Some(511), true)?.0 as u16;
        let continue_rohc = if optionals[0] {
            Some(ContinueRohc1::decode(data)?)
        } else {
            None
        };

        // Process the extension container

        if optionals[1] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            max_cid,
            rohc_profiles,
            continue_rohc,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.continue_rohc.is_some());
        optionals.push(false);

        encode::encode_sequence_header(data, false, &optionals, false)?;
        encode::encode_integer(
            data,
            Some(0),
            Some(16383),
            true,
            self.max_cid as i128,
            false,
        )?;
        encode::encode_integer(
            data,
            Some(0),
            Some(511),
            true,
            self.rohc_profiles as i128,
            false,
        )?;
        if let Some(x) = &self.continue_rohc {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl PerCodec for UplinkOnlyRohc {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        UplinkOnlyRohc::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UplinkOnlyRohc");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UplinkOnlyRohc");
            e
        })
    }
}
// UrIaddress
#[derive(Clone, Debug)]
pub struct UrIaddress(pub String);

impl UrIaddress {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(decode::decode_visible_string(
            data, None, None, false,
        )?))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_visible_string(data, None, None, false, &self.0, false)
    }
}

impl PerCodec for UrIaddress {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        UrIaddress::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UrIaddress");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UrIaddress");
            e
        })
    }
}
// CriticalityDiagnosticsIeList1
#[derive(Clone, Debug)]
pub struct CriticalityDiagnosticsIeList1 {
    pub ie_criticality: Criticality,
    pub ie_id: ProtocolIeId,
    pub type_of_error: TypeOfError,
}

impl CriticalityDiagnosticsIeList1 {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let ie_criticality = Criticality::decode(data)?;
        let ie_id = ProtocolIeId::decode(data)?;
        let type_of_error = TypeOfError::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            ie_criticality,
            ie_id,
            type_of_error,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.ie_criticality.encode(data)?;
        self.ie_id.encode(data)?;
        self.type_of_error.encode(data)?;

        Ok(())
    }
}

impl PerCodec for CriticalityDiagnosticsIeList1 {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        CriticalityDiagnosticsIeList1::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CriticalityDiagnosticsIeList1");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CriticalityDiagnosticsIeList1");
            e
        })
    }
}
// DapsIndicator
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum DapsIndicator {
    DapsHoRequired,
}

impl DapsIndicator {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(0), true)?;
        if extended {
            return Err(PerCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(data, Some(0), Some(0), true, *self as i128, false)
    }
}

impl PerCodec for DapsIndicator {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        DapsIndicator::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DapsIndicator");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DapsIndicator");
            e
        })
    }
}
// SecondaryRatType
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum SecondaryRatType {
    Nr,
    EUtra,
}

impl SecondaryRatType {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(1), true)?;
        if extended {
            return Err(PerCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(data, Some(0), Some(1), true, *self as i128, false)
    }
}

impl PerCodec for SecondaryRatType {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        SecondaryRatType::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SecondaryRatType");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SecondaryRatType");
            e
        })
    }
}
// SecondaryRatType1
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum SecondaryRatType1 {
    Nr,
    EUtra,
}

impl SecondaryRatType1 {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(1), true)?;
        if extended {
            return Err(PerCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(data, Some(0), Some(1), true, *self as i128, false)
    }
}

impl PerCodec for SecondaryRatType1 {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        SecondaryRatType1::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SecondaryRatType1");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SecondaryRatType1");
            e
        })
    }
}
// DrbReleasedInSession
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum DrbReleasedInSession {
    ReleasedInSession,
    NotReleasedInSession,
}

impl DrbReleasedInSession {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(1), true)?;
        if extended {
            return Err(PerCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(data, Some(0), Some(1), true, *self as i128, false)
    }
}

impl PerCodec for DrbReleasedInSession {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        DrbReleasedInSession::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DrbReleasedInSession");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DrbReleasedInSession");
            e
        })
    }
}
// S1DlUpUnchanged
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum S1DlUpUnchanged {
    True,
}

impl S1DlUpUnchanged {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(0), true)?;
        if extended {
            return Err(PerCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(data, Some(0), Some(0), true, *self as i128, false)
    }
}

impl PerCodec for S1DlUpUnchanged {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        S1DlUpUnchanged::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("S1DlUpUnchanged");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("S1DlUpUnchanged");
            e
        })
    }
}
// DelayCritical
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum DelayCritical {
    DelayCritical,
    NonDelayCritical,
}

impl DelayCritical {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(1), false)?;
        if extended {
            return Err(PerCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(data, Some(0), Some(1), false, *self as i128, false)
    }
}

impl PerCodec for DelayCritical {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        DelayCritical::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DelayCritical");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DelayCritical");
            e
        })
    }
}
// EhcCidLength
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum EhcCidLength {
    Bits7,
    Bits15,
}

impl EhcCidLength {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(1), true)?;
        if extended {
            return Err(PerCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(data, Some(0), Some(1), true, *self as i128, false)
    }
}

impl PerCodec for EhcCidLength {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        EhcCidLength::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("EhcCidLength");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("EhcCidLength");
            e
        })
    }
}
// DrbContinueEhcDl
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum DrbContinueEhcDl {
    True,
}

impl DrbContinueEhcDl {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(0), true)?;
        if extended {
            return Err(PerCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(data, Some(0), Some(0), true, *self as i128, false)
    }
}

impl PerCodec for DrbContinueEhcDl {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        DrbContinueEhcDl::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DrbContinueEhcDl");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DrbContinueEhcDl");
            e
        })
    }
}
// DrbContinueEhcUl
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum DrbContinueEhcUl {
    True,
}

impl DrbContinueEhcUl {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(0), true)?;
        if extended {
            return Err(PerCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(data, Some(0), Some(0), true, *self as i128, false)
    }
}

impl PerCodec for DrbContinueEhcUl {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        DrbContinueEhcUl::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DrbContinueEhcUl");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DrbContinueEhcUl");
            e
        })
    }
}
// NgDlUpUnchanged
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum NgDlUpUnchanged {
    True,
}

impl NgDlUpUnchanged {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(0), true)?;
        if extended {
            return Err(PerCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(data, Some(0), Some(0), true, *self as i128, false)
    }
}

impl PerCodec for NgDlUpUnchanged {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        NgDlUpUnchanged::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NgDlUpUnchanged");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NgDlUpUnchanged");
            e
        })
    }
}
// ReflectiveQosAttribute
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum ReflectiveQosAttribute {
    SubjectTo,
}

impl ReflectiveQosAttribute {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(0), true)?;
        if extended {
            return Err(PerCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(data, Some(0), Some(0), true, *self as i128, false)
    }
}

impl PerCodec for ReflectiveQosAttribute {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        ReflectiveQosAttribute::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ReflectiveQosAttribute");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ReflectiveQosAttribute");
            e
        })
    }
}
// AdditionalQosInformation
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum AdditionalQosInformation {
    MoreLikely,
}

impl AdditionalQosInformation {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(0), true)?;
        if extended {
            return Err(PerCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(data, Some(0), Some(0), true, *self as i128, false)
    }
}

impl PerCodec for AdditionalQosInformation {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        AdditionalQosInformation::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("AdditionalQosInformation");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("AdditionalQosInformation");
            e
        })
    }
}
// ReflectiveQosIndicator
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum ReflectiveQosIndicator {
    Enabled,
}

impl ReflectiveQosIndicator {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(0), true)?;
        if extended {
            return Err(PerCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(data, Some(0), Some(0), true, *self as i128, false)
    }
}

impl PerCodec for ReflectiveQosIndicator {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        ReflectiveQosIndicator::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ReflectiveQosIndicator");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ReflectiveQosIndicator");
            e
        })
    }
}
// QosFlowReleasedInSession
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum QosFlowReleasedInSession {
    ReleasedInSession,
    NotReleasedInSession,
}

impl QosFlowReleasedInSession {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(1), true)?;
        if extended {
            return Err(PerCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(data, Some(0), Some(1), true, *self as i128, false)
    }
}

impl PerCodec for QosFlowReleasedInSession {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        QosFlowReleasedInSession::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("QosFlowReleasedInSession");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("QosFlowReleasedInSession");
            e
        })
    }
}
// ContinueRohc
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum ContinueRohc {
    True,
}

impl ContinueRohc {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(0), true)?;
        if extended {
            return Err(PerCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(data, Some(0), Some(0), true, *self as i128, false)
    }
}

impl PerCodec for ContinueRohc {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        ContinueRohc::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ContinueRohc");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ContinueRohc");
            e
        })
    }
}
// ContinueRohc1
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum ContinueRohc1 {
    True,
}

impl ContinueRohc1 {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(0), true)?;
        if extended {
            return Err(PerCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(data, Some(0), Some(0), true, *self as i128, false)
    }
}

impl PerCodec for ContinueRohc1 {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        ContinueRohc1::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ContinueRohc1");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ContinueRohc1");
            e
        })
    }
}
