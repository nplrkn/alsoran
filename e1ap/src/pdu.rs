// Autogenerated from E1AP-PDU-Contents.asn
#![allow(clippy::all)]
use super::common::*;
use super::ies::*;
use asn1_per::{aper::*, *};
#[allow(unused_imports)]
use xxap::{GtpTunnel, PduSessionId, TransportLayerAddress};

// Reset
#[derive(Clone, Debug)]
pub struct Reset {
    pub transaction_id: TransactionId,
    pub cause: Cause,
    pub reset_type: ResetType,
}

impl Reset {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let _ = decode::decode_sequence_header(data, true, 0)?;
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut transaction_id: Option<TransactionId> = None;
        let mut cause: Option<Cause> = None;
        let mut reset_type: Option<ResetType> = None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                57 => transaction_id = Some(TransactionId::decode(data)?),
                0 => cause = Some(Cause::decode(data)?),
                4 => reset_type = Some(ResetType::decode(data)?),
                x => return Err(PerCodecError::new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        let transaction_id = transaction_id.ok_or(PerCodecError::new(format!(
            "Missing mandatory IE transaction_id"
        )))?;
        let cause = cause.ok_or(PerCodecError::new(format!("Missing mandatory IE cause")))?;
        let reset_type = reset_type.ok_or(PerCodecError::new(format!(
            "Missing mandatory IE reset_type"
        )))?;
        Ok(Self {
            transaction_id,
            cause,
            reset_type,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        let ie = &mut Allocator::new_codec_data();
        self.transaction_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 57, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.cause.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 0, false)?;
        Criticality::Ignore.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.reset_type.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 4, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        encode::encode_sequence_header(data, true, &BitString::new(), false)?;
        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for Reset {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Reset::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("Reset");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("Reset");
            e
        })
    }
}
// ResetType
#[derive(Clone, Debug)]
pub enum ResetType {
    E1Interface(ResetAll),
    PartOfE1Interface(UeAssociatedLogicalE1ConnectionListRes),
}

impl ResetType {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_choice_idx(data, 0, 2, false)?;
        if extended {
            return Err(PerCodecError::new("CHOICE additions not implemented"));
        }
        match idx {
            0 => Ok(Self::E1Interface(ResetAll::decode(data)?)),
            1 => Ok(Self::PartOfE1Interface(
                UeAssociatedLogicalE1ConnectionListRes::decode(data)?,
            )),
            2 => {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _ = Criticality::decode(data)?;
                let _ = decode::decode_length_determinent(data, None, None, false)?;
                let result = match id {
                    x => Err(PerCodecError::new(format!("Unrecognised IE type {}", x))),
                };
                data.decode_align()?;
                result
            }
            _ => Err(PerCodecError::new("Unknown choice idx")),
        }
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        match self {
            Self::E1Interface(x) => {
                encode::encode_choice_idx(data, 0, 2, false, 0, false)?;
                x.encode(data)
            }
            Self::PartOfE1Interface(x) => {
                encode::encode_choice_idx(data, 0, 2, false, 1, false)?;
                x.encode(data)
            }
        }
    }
}

impl PerCodec for ResetType {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        ResetType::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ResetType");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ResetType");
            e
        })
    }
}
// ResetAll
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum ResetAll {
    ResetAll,
}

impl ResetAll {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(0), true)?;
        if extended {
            return Err(PerCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(data, Some(0), Some(0), true, *self as i128, false)
    }
}

impl PerCodec for ResetAll {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        ResetAll::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ResetAll");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ResetAll");
            e
        })
    }
}
// UeAssociatedLogicalE1ConnectionListRes
#[derive(Clone, Debug)]
pub struct UeAssociatedLogicalE1ConnectionListRes(
    pub NonEmpty<UeAssociatedLogicalE1ConnectionItem>,
);

impl UeAssociatedLogicalE1ConnectionListRes {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(65536), false)?;
            let mut items = vec![];
            for _ in 0..length {
                let _ = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _ = Criticality::decode(data)?;
                let _ = decode::decode_length_determinent(data, None, None, false)?;
                items.push(UeAssociatedLogicalE1ConnectionItem::decode(data)?);
                data.decode_align()?;
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(65536), false, self.0.len())?;
        for x in &self.0 {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(data, Some(0), Some(65535), false, 5, false)?;
            Criticality::Reject.encode(data)?;
            encode::encode_length_determinent(data, None, None, false, ie.length_in_bytes())?;
            data.append_aligned(ie);
        }
        Ok(())
    }
}

impl PerCodec for UeAssociatedLogicalE1ConnectionListRes {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        UeAssociatedLogicalE1ConnectionListRes::decode_inner(data).map_err(
            |mut e: PerCodecError| {
                e.push_context("UeAssociatedLogicalE1ConnectionListRes");
                e
            },
        )
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UeAssociatedLogicalE1ConnectionListRes");
            e
        })
    }
}
// ResetAcknowledge
#[derive(Clone, Debug)]
pub struct ResetAcknowledge {
    pub transaction_id: TransactionId,
    pub ue_associated_logical_e1_connection_list_res_ack:
        Option<UeAssociatedLogicalE1ConnectionListResAck>,
    pub criticality_diagnostics: Option<CriticalityDiagnostics>,
}

impl ResetAcknowledge {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let _ = decode::decode_sequence_header(data, true, 0)?;
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut transaction_id: Option<TransactionId> = None;
        let mut ue_associated_logical_e1_connection_list_res_ack: Option<
            UeAssociatedLogicalE1ConnectionListResAck,
        > = None;
        let mut criticality_diagnostics: Option<CriticalityDiagnostics> = None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                57 => transaction_id = Some(TransactionId::decode(data)?),
                6 => {
                    ue_associated_logical_e1_connection_list_res_ack =
                        Some(UeAssociatedLogicalE1ConnectionListResAck::decode(data)?)
                }
                1 => criticality_diagnostics = Some(CriticalityDiagnostics::decode(data)?),
                x => return Err(PerCodecError::new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        let transaction_id = transaction_id.ok_or(PerCodecError::new(format!(
            "Missing mandatory IE transaction_id"
        )))?;
        Ok(Self {
            transaction_id,
            ue_associated_logical_e1_connection_list_res_ack,
            criticality_diagnostics,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        let ie = &mut Allocator::new_codec_data();
        self.transaction_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 57, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        if let Some(x) = &self.ue_associated_logical_e1_connection_list_res_ack {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 6, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.criticality_diagnostics {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 1, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        encode::encode_sequence_header(data, true, &BitString::new(), false)?;
        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for ResetAcknowledge {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        ResetAcknowledge::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ResetAcknowledge");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ResetAcknowledge");
            e
        })
    }
}
// UeAssociatedLogicalE1ConnectionListResAck
#[derive(Clone, Debug)]
pub struct UeAssociatedLogicalE1ConnectionListResAck(
    pub NonEmpty<UeAssociatedLogicalE1ConnectionItem>,
);

impl UeAssociatedLogicalE1ConnectionListResAck {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(65536), false)?;
            let mut items = vec![];
            for _ in 0..length {
                let _ = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _ = Criticality::decode(data)?;
                let _ = decode::decode_length_determinent(data, None, None, false)?;
                items.push(UeAssociatedLogicalE1ConnectionItem::decode(data)?);
                data.decode_align()?;
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(65536), false, self.0.len())?;
        for x in &self.0 {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(data, Some(0), Some(65535), false, 5, false)?;
            Criticality::Ignore.encode(data)?;
            encode::encode_length_determinent(data, None, None, false, ie.length_in_bytes())?;
            data.append_aligned(ie);
        }
        Ok(())
    }
}

impl PerCodec for UeAssociatedLogicalE1ConnectionListResAck {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        UeAssociatedLogicalE1ConnectionListResAck::decode_inner(data).map_err(
            |mut e: PerCodecError| {
                e.push_context("UeAssociatedLogicalE1ConnectionListResAck");
                e
            },
        )
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UeAssociatedLogicalE1ConnectionListResAck");
            e
        })
    }
}
// ErrorIndication
#[derive(Clone, Debug)]
pub struct ErrorIndication {
    pub transaction_id: TransactionId,
    pub gnb_cu_cp_ue_e1ap_id: Option<GnbCuCpUeE1apId>,
    pub gnb_cu_up_ue_e1ap_id: Option<GnbCuUpUeE1apId>,
    pub cause: Option<Cause>,
    pub criticality_diagnostics: Option<CriticalityDiagnostics>,
}

impl ErrorIndication {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let _ = decode::decode_sequence_header(data, true, 0)?;
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut transaction_id: Option<TransactionId> = None;
        let mut gnb_cu_cp_ue_e1ap_id: Option<GnbCuCpUeE1apId> = None;
        let mut gnb_cu_up_ue_e1ap_id: Option<GnbCuUpUeE1apId> = None;
        let mut cause: Option<Cause> = None;
        let mut criticality_diagnostics: Option<CriticalityDiagnostics> = None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                57 => transaction_id = Some(TransactionId::decode(data)?),
                2 => gnb_cu_cp_ue_e1ap_id = Some(GnbCuCpUeE1apId::decode(data)?),
                3 => gnb_cu_up_ue_e1ap_id = Some(GnbCuUpUeE1apId::decode(data)?),
                0 => cause = Some(Cause::decode(data)?),
                1 => criticality_diagnostics = Some(CriticalityDiagnostics::decode(data)?),
                x => return Err(PerCodecError::new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        let transaction_id = transaction_id.ok_or(PerCodecError::new(format!(
            "Missing mandatory IE transaction_id"
        )))?;
        Ok(Self {
            transaction_id,
            gnb_cu_cp_ue_e1ap_id,
            gnb_cu_up_ue_e1ap_id,
            cause,
            criticality_diagnostics,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        let ie = &mut Allocator::new_codec_data();
        self.transaction_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 57, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        if let Some(x) = &self.gnb_cu_cp_ue_e1ap_id {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 2, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.gnb_cu_up_ue_e1ap_id {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 3, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.cause {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 0, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.criticality_diagnostics {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 1, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        encode::encode_sequence_header(data, true, &BitString::new(), false)?;
        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for ErrorIndication {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        ErrorIndication::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ErrorIndication");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ErrorIndication");
            e
        })
    }
}
// GnbCuUpE1SetupRequest
#[derive(Clone, Debug)]
pub struct GnbCuUpE1SetupRequest {
    pub transaction_id: TransactionId,
    pub gnb_cu_up_id: GnbCuUpId,
    pub gnb_cu_up_name: Option<GnbCuUpName>,
    pub cn_support: CnSupport,
    pub supported_plmns: SupportedPlmnsList,
    pub gnb_cu_up_capacity: Option<GnbCuUpCapacity>,
    pub transport_layer_address_info: Option<TransportLayerAddressInfo>,
    pub extended_gnb_cu_up_name: Option<ExtendedGnbCuUpName>,
}

impl GnbCuUpE1SetupRequest {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let _ = decode::decode_sequence_header(data, true, 0)?;
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut transaction_id: Option<TransactionId> = None;
        let mut gnb_cu_up_id: Option<GnbCuUpId> = None;
        let mut gnb_cu_up_name: Option<GnbCuUpName> = None;
        let mut cn_support: Option<CnSupport> = None;
        let mut supported_plmns: Option<SupportedPlmnsList> = None;
        let mut gnb_cu_up_capacity: Option<GnbCuUpCapacity> = None;
        let mut transport_layer_address_info: Option<TransportLayerAddressInfo> = None;
        let mut extended_gnb_cu_up_name: Option<ExtendedGnbCuUpName> = None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                57 => transaction_id = Some(TransactionId::decode(data)?),
                7 => gnb_cu_up_id = Some(GnbCuUpId::decode(data)?),
                8 => gnb_cu_up_name = Some(GnbCuUpName::decode(data)?),
                10 => cn_support = Some(CnSupport::decode(data)?),
                11 => supported_plmns = Some(SupportedPlmnsList::decode(data)?),
                64 => gnb_cu_up_capacity = Some(GnbCuUpCapacity::decode(data)?),
                86 => transport_layer_address_info = Some(TransportLayerAddressInfo::decode(data)?),
                130 => extended_gnb_cu_up_name = Some(ExtendedGnbCuUpName::decode(data)?),
                x => return Err(PerCodecError::new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        let transaction_id = transaction_id.ok_or(PerCodecError::new(format!(
            "Missing mandatory IE transaction_id"
        )))?;
        let gnb_cu_up_id = gnb_cu_up_id.ok_or(PerCodecError::new(format!(
            "Missing mandatory IE gnb_cu_up_id"
        )))?;
        let cn_support = cn_support.ok_or(PerCodecError::new(format!(
            "Missing mandatory IE cn_support"
        )))?;
        let supported_plmns = supported_plmns.ok_or(PerCodecError::new(format!(
            "Missing mandatory IE supported_plmns"
        )))?;
        Ok(Self {
            transaction_id,
            gnb_cu_up_id,
            gnb_cu_up_name,
            cn_support,
            supported_plmns,
            gnb_cu_up_capacity,
            transport_layer_address_info,
            extended_gnb_cu_up_name,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        let ie = &mut Allocator::new_codec_data();
        self.transaction_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 57, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.gnb_cu_up_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 7, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        if let Some(x) = &self.gnb_cu_up_name {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 8, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        let ie = &mut Allocator::new_codec_data();
        self.cn_support.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 10, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.supported_plmns.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 11, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        if let Some(x) = &self.gnb_cu_up_capacity {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 64, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.transport_layer_address_info {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 86, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.extended_gnb_cu_up_name {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 130, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        encode::encode_sequence_header(data, true, &BitString::new(), false)?;
        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for GnbCuUpE1SetupRequest {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        GnbCuUpE1SetupRequest::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("GnbCuUpE1SetupRequest");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("GnbCuUpE1SetupRequest");
            e
        })
    }
}
// SupportedPlmnsList
#[derive(Clone, Debug)]
pub struct SupportedPlmnsList(pub NonEmpty<SupportedPlmnsItem>);

impl SupportedPlmnsList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(12), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(SupportedPlmnsItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(12), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for SupportedPlmnsList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        SupportedPlmnsList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SupportedPlmnsList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SupportedPlmnsList");
            e
        })
    }
}
// SupportedPlmnsItem
#[derive(Clone, Debug)]
pub struct SupportedPlmnsItem {
    pub plmn_identity: PlmnIdentity,
    pub slice_support_list: Option<SliceSupportList>,
    pub nr_cgi_support_list: Option<NrCgiSupportList>,
    pub qos_parameters_support_list: Option<QosParametersSupportList>,
    pub npn_support_info: Option<NpnSupportInfo>,
    pub extended_slice_support_list: Option<ExtendedSliceSupportList>,
    pub extended_nr_cgi_support_list: Option<ExtendedNrCgiSupportList>,
}

impl SupportedPlmnsItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 4)?;
        let plmn_identity = PlmnIdentity::decode(data)?;
        let slice_support_list = if optionals[0] {
            Some(SliceSupportList::decode(data)?)
        } else {
            None
        };
        let nr_cgi_support_list = if optionals[1] {
            Some(NrCgiSupportList::decode(data)?)
        } else {
            None
        };
        let qos_parameters_support_list = if optionals[2] {
            Some(QosParametersSupportList::decode(data)?)
        } else {
            None
        };

        // Process the extension container
        let mut npn_support_info: Option<NpnSupportInfo> = None;
        let mut extended_slice_support_list: Option<ExtendedSliceSupportList> = None;
        let mut extended_nr_cgi_support_list: Option<ExtendedNrCgiSupportList> = None;

        if optionals[3] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    110 => npn_support_info = Some(NpnSupportInfo::decode(data)?),
                    125 => {
                        extended_slice_support_list = Some(ExtendedSliceSupportList::decode(data)?)
                    }
                    135 => {
                        extended_nr_cgi_support_list = Some(ExtendedNrCgiSupportList::decode(data)?)
                    }
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            plmn_identity,
            slice_support_list,
            nr_cgi_support_list,
            qos_parameters_support_list,
            npn_support_info,
            extended_slice_support_list,
            extended_nr_cgi_support_list,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();
        if let Some(x) = &self.npn_support_info {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 110, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.extended_slice_support_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 125, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.extended_nr_cgi_support_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 135, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        let mut optionals = BitString::new();
        optionals.push(self.slice_support_list.is_some());
        optionals.push(self.nr_cgi_support_list.is_some());
        optionals.push(self.qos_parameters_support_list.is_some());
        optionals.push(num_ies != 0);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.plmn_identity.encode(data)?;
        if let Some(x) = &self.slice_support_list {
            x.encode(data)?;
        }
        if let Some(x) = &self.nr_cgi_support_list {
            x.encode(data)?;
        }
        if let Some(x) = &self.qos_parameters_support_list {
            x.encode(data)?;
        }
        if num_ies != 0 {
            encode::encode_length_determinent(data, Some(1), Some(65535), false, num_ies)?;
            data.append_aligned(ies);
        }
        Ok(())
    }
}

impl PerCodec for SupportedPlmnsItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        SupportedPlmnsItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SupportedPlmnsItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SupportedPlmnsItem");
            e
        })
    }
}
// GnbCuUpE1SetupResponse
#[derive(Clone, Debug)]
pub struct GnbCuUpE1SetupResponse {
    pub transaction_id: TransactionId,
    pub gnb_cu_cp_name: Option<GnbCuCpName>,
    pub transport_layer_address_info: Option<TransportLayerAddressInfo>,
    pub extended_gnb_cu_cp_name: Option<ExtendedGnbCuCpName>,
}

impl GnbCuUpE1SetupResponse {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let _ = decode::decode_sequence_header(data, true, 0)?;
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut transaction_id: Option<TransactionId> = None;
        let mut gnb_cu_cp_name: Option<GnbCuCpName> = None;
        let mut transport_layer_address_info: Option<TransportLayerAddressInfo> = None;
        let mut extended_gnb_cu_cp_name: Option<ExtendedGnbCuCpName> = None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                57 => transaction_id = Some(TransactionId::decode(data)?),
                9 => gnb_cu_cp_name = Some(GnbCuCpName::decode(data)?),
                86 => transport_layer_address_info = Some(TransportLayerAddressInfo::decode(data)?),
                129 => extended_gnb_cu_cp_name = Some(ExtendedGnbCuCpName::decode(data)?),
                x => return Err(PerCodecError::new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        let transaction_id = transaction_id.ok_or(PerCodecError::new(format!(
            "Missing mandatory IE transaction_id"
        )))?;
        Ok(Self {
            transaction_id,
            gnb_cu_cp_name,
            transport_layer_address_info,
            extended_gnb_cu_cp_name,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        let ie = &mut Allocator::new_codec_data();
        self.transaction_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 57, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        if let Some(x) = &self.gnb_cu_cp_name {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 9, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.transport_layer_address_info {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 86, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.extended_gnb_cu_cp_name {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 129, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        encode::encode_sequence_header(data, true, &BitString::new(), false)?;
        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for GnbCuUpE1SetupResponse {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        GnbCuUpE1SetupResponse::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("GnbCuUpE1SetupResponse");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("GnbCuUpE1SetupResponse");
            e
        })
    }
}
// GnbCuUpE1SetupFailure
#[derive(Clone, Debug)]
pub struct GnbCuUpE1SetupFailure {
    pub transaction_id: TransactionId,
    pub cause: Cause,
    pub time_to_wait: Option<TimeToWait>,
    pub criticality_diagnostics: Option<CriticalityDiagnostics>,
}

impl GnbCuUpE1SetupFailure {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let _ = decode::decode_sequence_header(data, true, 0)?;
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut transaction_id: Option<TransactionId> = None;
        let mut cause: Option<Cause> = None;
        let mut time_to_wait: Option<TimeToWait> = None;
        let mut criticality_diagnostics: Option<CriticalityDiagnostics> = None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                57 => transaction_id = Some(TransactionId::decode(data)?),
                0 => cause = Some(Cause::decode(data)?),
                12 => time_to_wait = Some(TimeToWait::decode(data)?),
                1 => criticality_diagnostics = Some(CriticalityDiagnostics::decode(data)?),
                x => return Err(PerCodecError::new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        let transaction_id = transaction_id.ok_or(PerCodecError::new(format!(
            "Missing mandatory IE transaction_id"
        )))?;
        let cause = cause.ok_or(PerCodecError::new(format!("Missing mandatory IE cause")))?;
        Ok(Self {
            transaction_id,
            cause,
            time_to_wait,
            criticality_diagnostics,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        let ie = &mut Allocator::new_codec_data();
        self.transaction_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 57, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.cause.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 0, false)?;
        Criticality::Ignore.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        if let Some(x) = &self.time_to_wait {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 12, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.criticality_diagnostics {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 1, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        encode::encode_sequence_header(data, true, &BitString::new(), false)?;
        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for GnbCuUpE1SetupFailure {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        GnbCuUpE1SetupFailure::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("GnbCuUpE1SetupFailure");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("GnbCuUpE1SetupFailure");
            e
        })
    }
}
// GnbCuCpE1SetupRequest
#[derive(Clone, Debug)]
pub struct GnbCuCpE1SetupRequest {
    pub transaction_id: TransactionId,
    pub gnb_cu_cp_name: Option<GnbCuCpName>,
    pub transport_layer_address_info: Option<TransportLayerAddressInfo>,
    pub extended_gnb_cu_cp_name: Option<ExtendedGnbCuCpName>,
}

impl GnbCuCpE1SetupRequest {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let _ = decode::decode_sequence_header(data, true, 0)?;
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut transaction_id: Option<TransactionId> = None;
        let mut gnb_cu_cp_name: Option<GnbCuCpName> = None;
        let mut transport_layer_address_info: Option<TransportLayerAddressInfo> = None;
        let mut extended_gnb_cu_cp_name: Option<ExtendedGnbCuCpName> = None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                57 => transaction_id = Some(TransactionId::decode(data)?),
                9 => gnb_cu_cp_name = Some(GnbCuCpName::decode(data)?),
                86 => transport_layer_address_info = Some(TransportLayerAddressInfo::decode(data)?),
                129 => extended_gnb_cu_cp_name = Some(ExtendedGnbCuCpName::decode(data)?),
                x => return Err(PerCodecError::new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        let transaction_id = transaction_id.ok_or(PerCodecError::new(format!(
            "Missing mandatory IE transaction_id"
        )))?;
        Ok(Self {
            transaction_id,
            gnb_cu_cp_name,
            transport_layer_address_info,
            extended_gnb_cu_cp_name,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        let ie = &mut Allocator::new_codec_data();
        self.transaction_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 57, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        if let Some(x) = &self.gnb_cu_cp_name {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 9, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.transport_layer_address_info {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 86, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.extended_gnb_cu_cp_name {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 129, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        encode::encode_sequence_header(data, true, &BitString::new(), false)?;
        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for GnbCuCpE1SetupRequest {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        GnbCuCpE1SetupRequest::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("GnbCuCpE1SetupRequest");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("GnbCuCpE1SetupRequest");
            e
        })
    }
}
// GnbCuCpE1SetupResponse
#[derive(Clone, Debug)]
pub struct GnbCuCpE1SetupResponse {
    pub transaction_id: TransactionId,
    pub gnb_cu_up_id: GnbCuUpId,
    pub gnb_cu_up_name: Option<GnbCuUpName>,
    pub cn_support: CnSupport,
    pub supported_plmns: SupportedPlmnsList,
    pub gnb_cu_up_capacity: Option<GnbCuUpCapacity>,
    pub transport_layer_address_info: Option<TransportLayerAddressInfo>,
    pub extended_gnb_cu_up_name: Option<ExtendedGnbCuUpName>,
}

impl GnbCuCpE1SetupResponse {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let _ = decode::decode_sequence_header(data, true, 0)?;
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut transaction_id: Option<TransactionId> = None;
        let mut gnb_cu_up_id: Option<GnbCuUpId> = None;
        let mut gnb_cu_up_name: Option<GnbCuUpName> = None;
        let mut cn_support: Option<CnSupport> = None;
        let mut supported_plmns: Option<SupportedPlmnsList> = None;
        let mut gnb_cu_up_capacity: Option<GnbCuUpCapacity> = None;
        let mut transport_layer_address_info: Option<TransportLayerAddressInfo> = None;
        let mut extended_gnb_cu_up_name: Option<ExtendedGnbCuUpName> = None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                57 => transaction_id = Some(TransactionId::decode(data)?),
                7 => gnb_cu_up_id = Some(GnbCuUpId::decode(data)?),
                8 => gnb_cu_up_name = Some(GnbCuUpName::decode(data)?),
                10 => cn_support = Some(CnSupport::decode(data)?),
                11 => supported_plmns = Some(SupportedPlmnsList::decode(data)?),
                64 => gnb_cu_up_capacity = Some(GnbCuUpCapacity::decode(data)?),
                86 => transport_layer_address_info = Some(TransportLayerAddressInfo::decode(data)?),
                130 => extended_gnb_cu_up_name = Some(ExtendedGnbCuUpName::decode(data)?),
                x => return Err(PerCodecError::new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        let transaction_id = transaction_id.ok_or(PerCodecError::new(format!(
            "Missing mandatory IE transaction_id"
        )))?;
        let gnb_cu_up_id = gnb_cu_up_id.ok_or(PerCodecError::new(format!(
            "Missing mandatory IE gnb_cu_up_id"
        )))?;
        let cn_support = cn_support.ok_or(PerCodecError::new(format!(
            "Missing mandatory IE cn_support"
        )))?;
        let supported_plmns = supported_plmns.ok_or(PerCodecError::new(format!(
            "Missing mandatory IE supported_plmns"
        )))?;
        Ok(Self {
            transaction_id,
            gnb_cu_up_id,
            gnb_cu_up_name,
            cn_support,
            supported_plmns,
            gnb_cu_up_capacity,
            transport_layer_address_info,
            extended_gnb_cu_up_name,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        let ie = &mut Allocator::new_codec_data();
        self.transaction_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 57, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.gnb_cu_up_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 7, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        if let Some(x) = &self.gnb_cu_up_name {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 8, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        let ie = &mut Allocator::new_codec_data();
        self.cn_support.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 10, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.supported_plmns.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 11, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        if let Some(x) = &self.gnb_cu_up_capacity {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 64, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.transport_layer_address_info {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 86, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.extended_gnb_cu_up_name {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 130, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        encode::encode_sequence_header(data, true, &BitString::new(), false)?;
        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for GnbCuCpE1SetupResponse {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        GnbCuCpE1SetupResponse::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("GnbCuCpE1SetupResponse");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("GnbCuCpE1SetupResponse");
            e
        })
    }
}
// GnbCuCpE1SetupFailure
#[derive(Clone, Debug)]
pub struct GnbCuCpE1SetupFailure {
    pub transaction_id: TransactionId,
    pub cause: Cause,
    pub time_to_wait: Option<TimeToWait>,
    pub criticality_diagnostics: Option<CriticalityDiagnostics>,
}

impl GnbCuCpE1SetupFailure {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let _ = decode::decode_sequence_header(data, true, 0)?;
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut transaction_id: Option<TransactionId> = None;
        let mut cause: Option<Cause> = None;
        let mut time_to_wait: Option<TimeToWait> = None;
        let mut criticality_diagnostics: Option<CriticalityDiagnostics> = None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                57 => transaction_id = Some(TransactionId::decode(data)?),
                0 => cause = Some(Cause::decode(data)?),
                12 => time_to_wait = Some(TimeToWait::decode(data)?),
                1 => criticality_diagnostics = Some(CriticalityDiagnostics::decode(data)?),
                x => return Err(PerCodecError::new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        let transaction_id = transaction_id.ok_or(PerCodecError::new(format!(
            "Missing mandatory IE transaction_id"
        )))?;
        let cause = cause.ok_or(PerCodecError::new(format!("Missing mandatory IE cause")))?;
        Ok(Self {
            transaction_id,
            cause,
            time_to_wait,
            criticality_diagnostics,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        let ie = &mut Allocator::new_codec_data();
        self.transaction_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 57, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.cause.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 0, false)?;
        Criticality::Ignore.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        if let Some(x) = &self.time_to_wait {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 12, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.criticality_diagnostics {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 1, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        encode::encode_sequence_header(data, true, &BitString::new(), false)?;
        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for GnbCuCpE1SetupFailure {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        GnbCuCpE1SetupFailure::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("GnbCuCpE1SetupFailure");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("GnbCuCpE1SetupFailure");
            e
        })
    }
}
// GnbCuUpConfigurationUpdate
#[derive(Clone, Debug)]
pub struct GnbCuUpConfigurationUpdate {
    pub transaction_id: TransactionId,
    pub gnb_cu_up_id: GnbCuUpId,
    pub gnb_cu_up_name: Option<GnbCuUpName>,
    pub supported_plmns: Option<SupportedPlmnsList>,
    pub gnb_cu_up_capacity: Option<GnbCuUpCapacity>,
    pub gnb_cu_up_tnla_to_remove_list: Option<GnbCuUpTnlaToRemoveList>,
    pub transport_layer_address_info: Option<TransportLayerAddressInfo>,
    pub extended_gnb_cu_up_name: Option<ExtendedGnbCuUpName>,
}

impl GnbCuUpConfigurationUpdate {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let _ = decode::decode_sequence_header(data, true, 0)?;
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut transaction_id: Option<TransactionId> = None;
        let mut gnb_cu_up_id: Option<GnbCuUpId> = None;
        let mut gnb_cu_up_name: Option<GnbCuUpName> = None;
        let mut supported_plmns: Option<SupportedPlmnsList> = None;
        let mut gnb_cu_up_capacity: Option<GnbCuUpCapacity> = None;
        let mut gnb_cu_up_tnla_to_remove_list: Option<GnbCuUpTnlaToRemoveList> = None;
        let mut transport_layer_address_info: Option<TransportLayerAddressInfo> = None;
        let mut extended_gnb_cu_up_name: Option<ExtendedGnbCuUpName> = None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                57 => transaction_id = Some(TransactionId::decode(data)?),
                7 => gnb_cu_up_id = Some(GnbCuUpId::decode(data)?),
                8 => gnb_cu_up_name = Some(GnbCuUpName::decode(data)?),
                11 => supported_plmns = Some(SupportedPlmnsList::decode(data)?),
                64 => gnb_cu_up_capacity = Some(GnbCuUpCapacity::decode(data)?),
                73 => gnb_cu_up_tnla_to_remove_list = Some(GnbCuUpTnlaToRemoveList::decode(data)?),
                86 => transport_layer_address_info = Some(TransportLayerAddressInfo::decode(data)?),
                130 => extended_gnb_cu_up_name = Some(ExtendedGnbCuUpName::decode(data)?),
                x => return Err(PerCodecError::new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        let transaction_id = transaction_id.ok_or(PerCodecError::new(format!(
            "Missing mandatory IE transaction_id"
        )))?;
        let gnb_cu_up_id = gnb_cu_up_id.ok_or(PerCodecError::new(format!(
            "Missing mandatory IE gnb_cu_up_id"
        )))?;
        Ok(Self {
            transaction_id,
            gnb_cu_up_id,
            gnb_cu_up_name,
            supported_plmns,
            gnb_cu_up_capacity,
            gnb_cu_up_tnla_to_remove_list,
            transport_layer_address_info,
            extended_gnb_cu_up_name,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        let ie = &mut Allocator::new_codec_data();
        self.transaction_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 57, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.gnb_cu_up_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 7, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        if let Some(x) = &self.gnb_cu_up_name {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 8, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.supported_plmns {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 11, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.gnb_cu_up_capacity {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 64, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.gnb_cu_up_tnla_to_remove_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 73, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.transport_layer_address_info {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 86, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.extended_gnb_cu_up_name {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 130, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        encode::encode_sequence_header(data, true, &BitString::new(), false)?;
        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for GnbCuUpConfigurationUpdate {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        GnbCuUpConfigurationUpdate::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("GnbCuUpConfigurationUpdate");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("GnbCuUpConfigurationUpdate");
            e
        })
    }
}
// GnbCuUpTnlaToRemoveList
#[derive(Clone, Debug)]
pub struct GnbCuUpTnlaToRemoveList(pub NonEmpty<GnbCuUpTnlaToRemoveItem>);

impl GnbCuUpTnlaToRemoveList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(32), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(GnbCuUpTnlaToRemoveItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(32), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for GnbCuUpTnlaToRemoveList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        GnbCuUpTnlaToRemoveList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("GnbCuUpTnlaToRemoveList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("GnbCuUpTnlaToRemoveList");
            e
        })
    }
}
// GnbCuUpConfigurationUpdateAcknowledge
#[derive(Clone, Debug)]
pub struct GnbCuUpConfigurationUpdateAcknowledge {
    pub transaction_id: TransactionId,
    pub criticality_diagnostics: Option<CriticalityDiagnostics>,
    pub transport_layer_address_info: Option<TransportLayerAddressInfo>,
}

impl GnbCuUpConfigurationUpdateAcknowledge {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let _ = decode::decode_sequence_header(data, true, 0)?;
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut transaction_id: Option<TransactionId> = None;
        let mut criticality_diagnostics: Option<CriticalityDiagnostics> = None;
        let mut transport_layer_address_info: Option<TransportLayerAddressInfo> = None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                57 => transaction_id = Some(TransactionId::decode(data)?),
                1 => criticality_diagnostics = Some(CriticalityDiagnostics::decode(data)?),
                86 => transport_layer_address_info = Some(TransportLayerAddressInfo::decode(data)?),
                x => return Err(PerCodecError::new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        let transaction_id = transaction_id.ok_or(PerCodecError::new(format!(
            "Missing mandatory IE transaction_id"
        )))?;
        Ok(Self {
            transaction_id,
            criticality_diagnostics,
            transport_layer_address_info,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        let ie = &mut Allocator::new_codec_data();
        self.transaction_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 57, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        if let Some(x) = &self.criticality_diagnostics {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 1, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.transport_layer_address_info {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 86, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        encode::encode_sequence_header(data, true, &BitString::new(), false)?;
        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for GnbCuUpConfigurationUpdateAcknowledge {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        GnbCuUpConfigurationUpdateAcknowledge::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("GnbCuUpConfigurationUpdateAcknowledge");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("GnbCuUpConfigurationUpdateAcknowledge");
            e
        })
    }
}
// GnbCuUpConfigurationUpdateFailure
#[derive(Clone, Debug)]
pub struct GnbCuUpConfigurationUpdateFailure {
    pub transaction_id: TransactionId,
    pub cause: Cause,
    pub time_to_wait: Option<TimeToWait>,
    pub criticality_diagnostics: Option<CriticalityDiagnostics>,
}

impl GnbCuUpConfigurationUpdateFailure {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let _ = decode::decode_sequence_header(data, true, 0)?;
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut transaction_id: Option<TransactionId> = None;
        let mut cause: Option<Cause> = None;
        let mut time_to_wait: Option<TimeToWait> = None;
        let mut criticality_diagnostics: Option<CriticalityDiagnostics> = None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                57 => transaction_id = Some(TransactionId::decode(data)?),
                0 => cause = Some(Cause::decode(data)?),
                12 => time_to_wait = Some(TimeToWait::decode(data)?),
                1 => criticality_diagnostics = Some(CriticalityDiagnostics::decode(data)?),
                x => return Err(PerCodecError::new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        let transaction_id = transaction_id.ok_or(PerCodecError::new(format!(
            "Missing mandatory IE transaction_id"
        )))?;
        let cause = cause.ok_or(PerCodecError::new(format!("Missing mandatory IE cause")))?;
        Ok(Self {
            transaction_id,
            cause,
            time_to_wait,
            criticality_diagnostics,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        let ie = &mut Allocator::new_codec_data();
        self.transaction_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 57, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.cause.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 0, false)?;
        Criticality::Ignore.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        if let Some(x) = &self.time_to_wait {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 12, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.criticality_diagnostics {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 1, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        encode::encode_sequence_header(data, true, &BitString::new(), false)?;
        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for GnbCuUpConfigurationUpdateFailure {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        GnbCuUpConfigurationUpdateFailure::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("GnbCuUpConfigurationUpdateFailure");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("GnbCuUpConfigurationUpdateFailure");
            e
        })
    }
}
// GnbCuCpConfigurationUpdate
#[derive(Clone, Debug)]
pub struct GnbCuCpConfigurationUpdate {
    pub transaction_id: TransactionId,
    pub gnb_cu_cp_name: Option<GnbCuCpName>,
    pub gnb_cu_cp_tnla_to_add_list: Option<GnbCuCpTnlaToAddList>,
    pub gnb_cu_cp_tnla_to_remove_list: Option<GnbCuCpTnlaToRemoveList>,
    pub gnb_cu_cp_tnla_to_update_list: Option<GnbCuCpTnlaToUpdateList>,
    pub transport_layer_address_info: Option<TransportLayerAddressInfo>,
    pub extended_gnb_cu_cp_name: Option<ExtendedGnbCuCpName>,
}

impl GnbCuCpConfigurationUpdate {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let _ = decode::decode_sequence_header(data, true, 0)?;
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut transaction_id: Option<TransactionId> = None;
        let mut gnb_cu_cp_name: Option<GnbCuCpName> = None;
        let mut gnb_cu_cp_tnla_to_add_list: Option<GnbCuCpTnlaToAddList> = None;
        let mut gnb_cu_cp_tnla_to_remove_list: Option<GnbCuCpTnlaToRemoveList> = None;
        let mut gnb_cu_cp_tnla_to_update_list: Option<GnbCuCpTnlaToUpdateList> = None;
        let mut transport_layer_address_info: Option<TransportLayerAddressInfo> = None;
        let mut extended_gnb_cu_cp_name: Option<ExtendedGnbCuCpName> = None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                57 => transaction_id = Some(TransactionId::decode(data)?),
                9 => gnb_cu_cp_name = Some(GnbCuCpName::decode(data)?),
                27 => gnb_cu_cp_tnla_to_add_list = Some(GnbCuCpTnlaToAddList::decode(data)?),
                28 => gnb_cu_cp_tnla_to_remove_list = Some(GnbCuCpTnlaToRemoveList::decode(data)?),
                29 => gnb_cu_cp_tnla_to_update_list = Some(GnbCuCpTnlaToUpdateList::decode(data)?),
                86 => transport_layer_address_info = Some(TransportLayerAddressInfo::decode(data)?),
                129 => extended_gnb_cu_cp_name = Some(ExtendedGnbCuCpName::decode(data)?),
                x => return Err(PerCodecError::new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        let transaction_id = transaction_id.ok_or(PerCodecError::new(format!(
            "Missing mandatory IE transaction_id"
        )))?;
        Ok(Self {
            transaction_id,
            gnb_cu_cp_name,
            gnb_cu_cp_tnla_to_add_list,
            gnb_cu_cp_tnla_to_remove_list,
            gnb_cu_cp_tnla_to_update_list,
            transport_layer_address_info,
            extended_gnb_cu_cp_name,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        let ie = &mut Allocator::new_codec_data();
        self.transaction_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 57, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        if let Some(x) = &self.gnb_cu_cp_name {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 9, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.gnb_cu_cp_tnla_to_add_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 27, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.gnb_cu_cp_tnla_to_remove_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 28, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.gnb_cu_cp_tnla_to_update_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 29, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.transport_layer_address_info {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 86, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.extended_gnb_cu_cp_name {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 129, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        encode::encode_sequence_header(data, true, &BitString::new(), false)?;
        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for GnbCuCpConfigurationUpdate {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        GnbCuCpConfigurationUpdate::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("GnbCuCpConfigurationUpdate");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("GnbCuCpConfigurationUpdate");
            e
        })
    }
}
// GnbCuCpTnlaToAddList
#[derive(Clone, Debug)]
pub struct GnbCuCpTnlaToAddList(pub NonEmpty<GnbCuCpTnlaToAddItem>);

impl GnbCuCpTnlaToAddList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(32), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(GnbCuCpTnlaToAddItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(32), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for GnbCuCpTnlaToAddList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        GnbCuCpTnlaToAddList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("GnbCuCpTnlaToAddList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("GnbCuCpTnlaToAddList");
            e
        })
    }
}
// GnbCuCpTnlaToRemoveList
#[derive(Clone, Debug)]
pub struct GnbCuCpTnlaToRemoveList(pub NonEmpty<GnbCuCpTnlaToRemoveItem>);

impl GnbCuCpTnlaToRemoveList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(32), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(GnbCuCpTnlaToRemoveItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(32), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for GnbCuCpTnlaToRemoveList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        GnbCuCpTnlaToRemoveList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("GnbCuCpTnlaToRemoveList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("GnbCuCpTnlaToRemoveList");
            e
        })
    }
}
// GnbCuCpTnlaToUpdateList
#[derive(Clone, Debug)]
pub struct GnbCuCpTnlaToUpdateList(pub NonEmpty<GnbCuCpTnlaToUpdateItem>);

impl GnbCuCpTnlaToUpdateList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(32), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(GnbCuCpTnlaToUpdateItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(32), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for GnbCuCpTnlaToUpdateList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        GnbCuCpTnlaToUpdateList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("GnbCuCpTnlaToUpdateList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("GnbCuCpTnlaToUpdateList");
            e
        })
    }
}
// GnbCuCpConfigurationUpdateAcknowledge
#[derive(Clone, Debug)]
pub struct GnbCuCpConfigurationUpdateAcknowledge {
    pub transaction_id: TransactionId,
    pub criticality_diagnostics: Option<CriticalityDiagnostics>,
    pub gnb_cu_cp_tnla_setup_list: Option<GnbCuCpTnlaSetupList>,
    pub gnb_cu_cp_tnla_failed_to_setup_list: Option<GnbCuCpTnlaFailedToSetupList>,
    pub transport_layer_address_info: Option<TransportLayerAddressInfo>,
}

impl GnbCuCpConfigurationUpdateAcknowledge {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let _ = decode::decode_sequence_header(data, true, 0)?;
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut transaction_id: Option<TransactionId> = None;
        let mut criticality_diagnostics: Option<CriticalityDiagnostics> = None;
        let mut gnb_cu_cp_tnla_setup_list: Option<GnbCuCpTnlaSetupList> = None;
        let mut gnb_cu_cp_tnla_failed_to_setup_list: Option<GnbCuCpTnlaFailedToSetupList> = None;
        let mut transport_layer_address_info: Option<TransportLayerAddressInfo> = None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                57 => transaction_id = Some(TransactionId::decode(data)?),
                1 => criticality_diagnostics = Some(CriticalityDiagnostics::decode(data)?),
                30 => gnb_cu_cp_tnla_setup_list = Some(GnbCuCpTnlaSetupList::decode(data)?),
                31 => {
                    gnb_cu_cp_tnla_failed_to_setup_list =
                        Some(GnbCuCpTnlaFailedToSetupList::decode(data)?)
                }
                86 => transport_layer_address_info = Some(TransportLayerAddressInfo::decode(data)?),
                x => return Err(PerCodecError::new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        let transaction_id = transaction_id.ok_or(PerCodecError::new(format!(
            "Missing mandatory IE transaction_id"
        )))?;
        Ok(Self {
            transaction_id,
            criticality_diagnostics,
            gnb_cu_cp_tnla_setup_list,
            gnb_cu_cp_tnla_failed_to_setup_list,
            transport_layer_address_info,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        let ie = &mut Allocator::new_codec_data();
        self.transaction_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 57, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        if let Some(x) = &self.criticality_diagnostics {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 1, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.gnb_cu_cp_tnla_setup_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 30, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.gnb_cu_cp_tnla_failed_to_setup_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 31, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.transport_layer_address_info {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 86, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        encode::encode_sequence_header(data, true, &BitString::new(), false)?;
        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for GnbCuCpConfigurationUpdateAcknowledge {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        GnbCuCpConfigurationUpdateAcknowledge::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("GnbCuCpConfigurationUpdateAcknowledge");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("GnbCuCpConfigurationUpdateAcknowledge");
            e
        })
    }
}
// GnbCuCpTnlaSetupList
#[derive(Clone, Debug)]
pub struct GnbCuCpTnlaSetupList(pub NonEmpty<GnbCuCpTnlaSetupItem>);

impl GnbCuCpTnlaSetupList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(32), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(GnbCuCpTnlaSetupItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(32), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for GnbCuCpTnlaSetupList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        GnbCuCpTnlaSetupList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("GnbCuCpTnlaSetupList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("GnbCuCpTnlaSetupList");
            e
        })
    }
}
// GnbCuCpTnlaFailedToSetupList
#[derive(Clone, Debug)]
pub struct GnbCuCpTnlaFailedToSetupList(pub NonEmpty<GnbCuCpTnlaFailedToSetupItem>);

impl GnbCuCpTnlaFailedToSetupList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(32), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(GnbCuCpTnlaFailedToSetupItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(32), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for GnbCuCpTnlaFailedToSetupList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        GnbCuCpTnlaFailedToSetupList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("GnbCuCpTnlaFailedToSetupList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("GnbCuCpTnlaFailedToSetupList");
            e
        })
    }
}
// GnbCuCpConfigurationUpdateFailure
#[derive(Clone, Debug)]
pub struct GnbCuCpConfigurationUpdateFailure {
    pub transaction_id: TransactionId,
    pub cause: Cause,
    pub time_to_wait: Option<TimeToWait>,
    pub criticality_diagnostics: Option<CriticalityDiagnostics>,
}

impl GnbCuCpConfigurationUpdateFailure {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let _ = decode::decode_sequence_header(data, true, 0)?;
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut transaction_id: Option<TransactionId> = None;
        let mut cause: Option<Cause> = None;
        let mut time_to_wait: Option<TimeToWait> = None;
        let mut criticality_diagnostics: Option<CriticalityDiagnostics> = None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                57 => transaction_id = Some(TransactionId::decode(data)?),
                0 => cause = Some(Cause::decode(data)?),
                12 => time_to_wait = Some(TimeToWait::decode(data)?),
                1 => criticality_diagnostics = Some(CriticalityDiagnostics::decode(data)?),
                x => return Err(PerCodecError::new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        let transaction_id = transaction_id.ok_or(PerCodecError::new(format!(
            "Missing mandatory IE transaction_id"
        )))?;
        let cause = cause.ok_or(PerCodecError::new(format!("Missing mandatory IE cause")))?;
        Ok(Self {
            transaction_id,
            cause,
            time_to_wait,
            criticality_diagnostics,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        let ie = &mut Allocator::new_codec_data();
        self.transaction_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 57, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.cause.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 0, false)?;
        Criticality::Ignore.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        if let Some(x) = &self.time_to_wait {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 12, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.criticality_diagnostics {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 1, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        encode::encode_sequence_header(data, true, &BitString::new(), false)?;
        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for GnbCuCpConfigurationUpdateFailure {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        GnbCuCpConfigurationUpdateFailure::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("GnbCuCpConfigurationUpdateFailure");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("GnbCuCpConfigurationUpdateFailure");
            e
        })
    }
}
// E1ReleaseRequest
#[derive(Clone, Debug)]
pub struct E1ReleaseRequest {
    pub transaction_id: TransactionId,
    pub cause: Cause,
}

impl E1ReleaseRequest {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let _ = decode::decode_sequence_header(data, true, 0)?;
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut transaction_id: Option<TransactionId> = None;
        let mut cause: Option<Cause> = None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                57 => transaction_id = Some(TransactionId::decode(data)?),
                0 => cause = Some(Cause::decode(data)?),
                x => return Err(PerCodecError::new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        let transaction_id = transaction_id.ok_or(PerCodecError::new(format!(
            "Missing mandatory IE transaction_id"
        )))?;
        let cause = cause.ok_or(PerCodecError::new(format!("Missing mandatory IE cause")))?;
        Ok(Self {
            transaction_id,
            cause,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        let ie = &mut Allocator::new_codec_data();
        self.transaction_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 57, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.cause.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 0, false)?;
        Criticality::Ignore.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        encode::encode_sequence_header(data, true, &BitString::new(), false)?;
        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for E1ReleaseRequest {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        E1ReleaseRequest::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("E1ReleaseRequest");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("E1ReleaseRequest");
            e
        })
    }
}
// E1ReleaseResponse
#[derive(Clone, Debug)]
pub struct E1ReleaseResponse {
    pub transaction_id: TransactionId,
}

impl E1ReleaseResponse {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let _ = decode::decode_sequence_header(data, true, 0)?;
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut transaction_id: Option<TransactionId> = None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                57 => transaction_id = Some(TransactionId::decode(data)?),
                x => return Err(PerCodecError::new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        let transaction_id = transaction_id.ok_or(PerCodecError::new(format!(
            "Missing mandatory IE transaction_id"
        )))?;
        Ok(Self { transaction_id })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        let ie = &mut Allocator::new_codec_data();
        self.transaction_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 57, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        encode::encode_sequence_header(data, true, &BitString::new(), false)?;
        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for E1ReleaseResponse {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        E1ReleaseResponse::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("E1ReleaseResponse");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("E1ReleaseResponse");
            e
        })
    }
}
// BearerContextSetupRequest
#[derive(Clone, Debug)]
pub struct BearerContextSetupRequest {
    pub gnb_cu_cp_ue_e1ap_id: GnbCuCpUeE1apId,
    pub security_information: SecurityInformation,
    pub ue_dl_aggregate_maximum_bit_rate: BitRate,
    pub ue_dl_maximum_integrity_protected_data_rate: Option<BitRate>,
    pub serving_plmn: PlmnIdentity,
    pub activity_notification_level: ActivityNotificationLevel,
    pub ue_inactivity_timer: Option<InactivityTimer>,
    pub bearer_context_status_change: Option<BearerContextStatusChange>,
    pub system_bearer_context_setup_request: SystemBearerContextSetupRequest,
    pub ran_ue_id: Option<RanUeId>,
    pub gnb_du_id: Option<GnbDuId>,
    pub trace_activation: Option<TraceActivation>,
    pub npn_context_info: Option<NpnContextInfo>,
    pub management_based_mdt_plmn_list: Option<MdtPlmnList>,
    pub cho_initiation: Option<ChoInitiation>,
    pub additional_handover_info: Option<AdditionalHandoverInfo>,
    pub direct_forwarding_path_availability: Option<DirectForwardingPathAvailability>,
    pub gnb_cu_up_ue_e1ap_id: Option<GnbCuUpUeE1apId>,
}

impl BearerContextSetupRequest {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let _ = decode::decode_sequence_header(data, true, 0)?;
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut gnb_cu_cp_ue_e1ap_id: Option<GnbCuCpUeE1apId> = None;
        let mut security_information: Option<SecurityInformation> = None;
        let mut ue_dl_aggregate_maximum_bit_rate: Option<BitRate> = None;
        let mut ue_dl_maximum_integrity_protected_data_rate: Option<BitRate> = None;
        let mut serving_plmn: Option<PlmnIdentity> = None;
        let mut activity_notification_level: Option<ActivityNotificationLevel> = None;
        let mut ue_inactivity_timer: Option<InactivityTimer> = None;
        let mut bearer_context_status_change: Option<BearerContextStatusChange> = None;
        let mut system_bearer_context_setup_request: Option<SystemBearerContextSetupRequest> = None;
        let mut ran_ue_id: Option<RanUeId> = None;
        let mut gnb_du_id: Option<GnbDuId> = None;
        let mut trace_activation: Option<TraceActivation> = None;
        let mut npn_context_info: Option<NpnContextInfo> = None;
        let mut management_based_mdt_plmn_list: Option<MdtPlmnList> = None;
        let mut cho_initiation: Option<ChoInitiation> = None;
        let mut additional_handover_info: Option<AdditionalHandoverInfo> = None;
        let mut direct_forwarding_path_availability: Option<DirectForwardingPathAvailability> =
            None;
        let mut gnb_cu_up_ue_e1ap_id: Option<GnbCuUpUeE1apId> = None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                2 => gnb_cu_cp_ue_e1ap_id = Some(GnbCuCpUeE1apId::decode(data)?),
                13 => security_information = Some(SecurityInformation::decode(data)?),
                14 => ue_dl_aggregate_maximum_bit_rate = Some(BitRate::decode(data)?),
                66 => ue_dl_maximum_integrity_protected_data_rate = Some(BitRate::decode(data)?),
                58 => serving_plmn = Some(PlmnIdentity::decode(data)?),
                23 => activity_notification_level = Some(ActivityNotificationLevel::decode(data)?),
                59 => ue_inactivity_timer = Some(InactivityTimer::decode(data)?),
                17 => bearer_context_status_change = Some(BearerContextStatusChange::decode(data)?),
                15 => {
                    system_bearer_context_setup_request =
                        Some(SystemBearerContextSetupRequest::decode(data)?)
                }
                76 => ran_ue_id = Some(RanUeId::decode(data)?),
                77 => gnb_du_id = Some(GnbDuId::decode(data)?),
                81 => trace_activation = Some(TraceActivation::decode(data)?),
                111 => npn_context_info = Some(NpnContextInfo::decode(data)?),
                113 => management_based_mdt_plmn_list = Some(MdtPlmnList::decode(data)?),
                121 => cho_initiation = Some(ChoInitiation::decode(data)?),
                134 => additional_handover_info = Some(AdditionalHandoverInfo::decode(data)?),
                139 => {
                    direct_forwarding_path_availability =
                        Some(DirectForwardingPathAvailability::decode(data)?)
                }
                3 => gnb_cu_up_ue_e1ap_id = Some(GnbCuUpUeE1apId::decode(data)?),
                x => return Err(PerCodecError::new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        let gnb_cu_cp_ue_e1ap_id = gnb_cu_cp_ue_e1ap_id.ok_or(PerCodecError::new(format!(
            "Missing mandatory IE gnb_cu_cp_ue_e1ap_id"
        )))?;
        let security_information = security_information.ok_or(PerCodecError::new(format!(
            "Missing mandatory IE security_information"
        )))?;
        let ue_dl_aggregate_maximum_bit_rate =
            ue_dl_aggregate_maximum_bit_rate.ok_or(PerCodecError::new(format!(
                "Missing mandatory IE ue_dl_aggregate_maximum_bit_rate"
            )))?;
        let serving_plmn = serving_plmn.ok_or(PerCodecError::new(format!(
            "Missing mandatory IE serving_plmn"
        )))?;
        let activity_notification_level = activity_notification_level.ok_or(PerCodecError::new(
            format!("Missing mandatory IE activity_notification_level"),
        ))?;
        let system_bearer_context_setup_request =
            system_bearer_context_setup_request.ok_or(PerCodecError::new(format!(
                "Missing mandatory IE system_bearer_context_setup_request"
            )))?;
        Ok(Self {
            gnb_cu_cp_ue_e1ap_id,
            security_information,
            ue_dl_aggregate_maximum_bit_rate,
            ue_dl_maximum_integrity_protected_data_rate,
            serving_plmn,
            activity_notification_level,
            ue_inactivity_timer,
            bearer_context_status_change,
            system_bearer_context_setup_request,
            ran_ue_id,
            gnb_du_id,
            trace_activation,
            npn_context_info,
            management_based_mdt_plmn_list,
            cho_initiation,
            additional_handover_info,
            direct_forwarding_path_availability,
            gnb_cu_up_ue_e1ap_id,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        let ie = &mut Allocator::new_codec_data();
        self.gnb_cu_cp_ue_e1ap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 2, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.security_information.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 13, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.ue_dl_aggregate_maximum_bit_rate.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 14, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        if let Some(x) = &self.ue_dl_maximum_integrity_protected_data_rate {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 66, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        let ie = &mut Allocator::new_codec_data();
        self.serving_plmn.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 58, false)?;
        Criticality::Ignore.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.activity_notification_level.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 23, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        if let Some(x) = &self.ue_inactivity_timer {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 59, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.bearer_context_status_change {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 17, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        let ie = &mut Allocator::new_codec_data();
        self.system_bearer_context_setup_request.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 15, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        if let Some(x) = &self.ran_ue_id {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 76, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.gnb_du_id {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 77, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.trace_activation {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 81, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.npn_context_info {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 111, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.management_based_mdt_plmn_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 113, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.cho_initiation {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 121, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.additional_handover_info {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 134, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.direct_forwarding_path_availability {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 139, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.gnb_cu_up_ue_e1ap_id {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 3, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        encode::encode_sequence_header(data, true, &BitString::new(), false)?;
        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for BearerContextSetupRequest {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        BearerContextSetupRequest::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("BearerContextSetupRequest");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("BearerContextSetupRequest");
            e
        })
    }
}
// SystemBearerContextSetupRequest
#[derive(Clone, Debug)]
pub enum SystemBearerContextSetupRequest {
    EutranBearerContextSetupRequest(EutranBearerContextSetupRequest),
    NgRanBearerContextSetupRequest(NgRanBearerContextSetupRequest),
}

impl SystemBearerContextSetupRequest {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_choice_idx(data, 0, 2, false)?;
        if extended {
            return Err(PerCodecError::new("CHOICE additions not implemented"));
        }
        match idx {
            0 => Ok(Self::EutranBearerContextSetupRequest(
                EutranBearerContextSetupRequest::decode(data)?,
            )),
            1 => Ok(Self::NgRanBearerContextSetupRequest(
                NgRanBearerContextSetupRequest::decode(data)?,
            )),
            2 => {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _ = Criticality::decode(data)?;
                let _ = decode::decode_length_determinent(data, None, None, false)?;
                let result = match id {
                    x => Err(PerCodecError::new(format!("Unrecognised IE type {}", x))),
                };
                data.decode_align()?;
                result
            }
            _ => Err(PerCodecError::new("Unknown choice idx")),
        }
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        match self {
            Self::EutranBearerContextSetupRequest(x) => {
                encode::encode_choice_idx(data, 0, 2, false, 0, false)?;
                x.encode(data)
            }
            Self::NgRanBearerContextSetupRequest(x) => {
                encode::encode_choice_idx(data, 0, 2, false, 1, false)?;
                x.encode(data)
            }
        }
    }
}

impl PerCodec for SystemBearerContextSetupRequest {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        SystemBearerContextSetupRequest::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SystemBearerContextSetupRequest");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SystemBearerContextSetupRequest");
            e
        })
    }
}
// BearerContextSetupResponse
#[derive(Clone, Debug)]
pub struct BearerContextSetupResponse {
    pub gnb_cu_cp_ue_e1ap_id: GnbCuCpUeE1apId,
    pub gnb_cu_up_ue_e1ap_id: GnbCuUpUeE1apId,
    pub system_bearer_context_setup_response: SystemBearerContextSetupResponse,
}

impl BearerContextSetupResponse {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let _ = decode::decode_sequence_header(data, true, 0)?;
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut gnb_cu_cp_ue_e1ap_id: Option<GnbCuCpUeE1apId> = None;
        let mut gnb_cu_up_ue_e1ap_id: Option<GnbCuUpUeE1apId> = None;
        let mut system_bearer_context_setup_response: Option<SystemBearerContextSetupResponse> =
            None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                2 => gnb_cu_cp_ue_e1ap_id = Some(GnbCuCpUeE1apId::decode(data)?),
                3 => gnb_cu_up_ue_e1ap_id = Some(GnbCuUpUeE1apId::decode(data)?),
                16 => {
                    system_bearer_context_setup_response =
                        Some(SystemBearerContextSetupResponse::decode(data)?)
                }
                x => return Err(PerCodecError::new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        let gnb_cu_cp_ue_e1ap_id = gnb_cu_cp_ue_e1ap_id.ok_or(PerCodecError::new(format!(
            "Missing mandatory IE gnb_cu_cp_ue_e1ap_id"
        )))?;
        let gnb_cu_up_ue_e1ap_id = gnb_cu_up_ue_e1ap_id.ok_or(PerCodecError::new(format!(
            "Missing mandatory IE gnb_cu_up_ue_e1ap_id"
        )))?;
        let system_bearer_context_setup_response =
            system_bearer_context_setup_response.ok_or(PerCodecError::new(format!(
                "Missing mandatory IE system_bearer_context_setup_response"
            )))?;
        Ok(Self {
            gnb_cu_cp_ue_e1ap_id,
            gnb_cu_up_ue_e1ap_id,
            system_bearer_context_setup_response,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        let ie = &mut Allocator::new_codec_data();
        self.gnb_cu_cp_ue_e1ap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 2, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.gnb_cu_up_ue_e1ap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 3, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.system_bearer_context_setup_response.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 16, false)?;
        Criticality::Ignore.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        encode::encode_sequence_header(data, true, &BitString::new(), false)?;
        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for BearerContextSetupResponse {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        BearerContextSetupResponse::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("BearerContextSetupResponse");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("BearerContextSetupResponse");
            e
        })
    }
}
// SystemBearerContextSetupResponse
#[derive(Clone, Debug)]
pub enum SystemBearerContextSetupResponse {
    EutranBearerContextSetupResponse(EutranBearerContextSetupResponse),
    NgRanBearerContextSetupResponse(NgRanBearerContextSetupResponse),
}

impl SystemBearerContextSetupResponse {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_choice_idx(data, 0, 2, false)?;
        if extended {
            return Err(PerCodecError::new("CHOICE additions not implemented"));
        }
        match idx {
            0 => Ok(Self::EutranBearerContextSetupResponse(
                EutranBearerContextSetupResponse::decode(data)?,
            )),
            1 => Ok(Self::NgRanBearerContextSetupResponse(
                NgRanBearerContextSetupResponse::decode(data)?,
            )),
            2 => {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _ = Criticality::decode(data)?;
                let _ = decode::decode_length_determinent(data, None, None, false)?;
                let result = match id {
                    x => Err(PerCodecError::new(format!("Unrecognised IE type {}", x))),
                };
                data.decode_align()?;
                result
            }
            _ => Err(PerCodecError::new("Unknown choice idx")),
        }
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        match self {
            Self::EutranBearerContextSetupResponse(x) => {
                encode::encode_choice_idx(data, 0, 2, false, 0, false)?;
                x.encode(data)
            }
            Self::NgRanBearerContextSetupResponse(x) => {
                encode::encode_choice_idx(data, 0, 2, false, 1, false)?;
                x.encode(data)
            }
        }
    }
}

impl PerCodec for SystemBearerContextSetupResponse {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        SystemBearerContextSetupResponse::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SystemBearerContextSetupResponse");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SystemBearerContextSetupResponse");
            e
        })
    }
}
// BearerContextSetupFailure
#[derive(Clone, Debug)]
pub struct BearerContextSetupFailure {
    pub gnb_cu_cp_ue_e1ap_id: GnbCuCpUeE1apId,
    pub gnb_cu_up_ue_e1ap_id: Option<GnbCuUpUeE1apId>,
    pub cause: Cause,
    pub criticality_diagnostics: Option<CriticalityDiagnostics>,
}

impl BearerContextSetupFailure {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let _ = decode::decode_sequence_header(data, true, 0)?;
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut gnb_cu_cp_ue_e1ap_id: Option<GnbCuCpUeE1apId> = None;
        let mut gnb_cu_up_ue_e1ap_id: Option<GnbCuUpUeE1apId> = None;
        let mut cause: Option<Cause> = None;
        let mut criticality_diagnostics: Option<CriticalityDiagnostics> = None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                2 => gnb_cu_cp_ue_e1ap_id = Some(GnbCuCpUeE1apId::decode(data)?),
                3 => gnb_cu_up_ue_e1ap_id = Some(GnbCuUpUeE1apId::decode(data)?),
                0 => cause = Some(Cause::decode(data)?),
                1 => criticality_diagnostics = Some(CriticalityDiagnostics::decode(data)?),
                x => return Err(PerCodecError::new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        let gnb_cu_cp_ue_e1ap_id = gnb_cu_cp_ue_e1ap_id.ok_or(PerCodecError::new(format!(
            "Missing mandatory IE gnb_cu_cp_ue_e1ap_id"
        )))?;
        let cause = cause.ok_or(PerCodecError::new(format!("Missing mandatory IE cause")))?;
        Ok(Self {
            gnb_cu_cp_ue_e1ap_id,
            gnb_cu_up_ue_e1ap_id,
            cause,
            criticality_diagnostics,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        let ie = &mut Allocator::new_codec_data();
        self.gnb_cu_cp_ue_e1ap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 2, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        if let Some(x) = &self.gnb_cu_up_ue_e1ap_id {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 3, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        let ie = &mut Allocator::new_codec_data();
        self.cause.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 0, false)?;
        Criticality::Ignore.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        if let Some(x) = &self.criticality_diagnostics {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 1, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        encode::encode_sequence_header(data, true, &BitString::new(), false)?;
        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for BearerContextSetupFailure {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        BearerContextSetupFailure::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("BearerContextSetupFailure");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("BearerContextSetupFailure");
            e
        })
    }
}
// BearerContextModificationRequest
#[derive(Clone, Debug)]
pub struct BearerContextModificationRequest {
    pub gnb_cu_cp_ue_e1ap_id: GnbCuCpUeE1apId,
    pub gnb_cu_up_ue_e1ap_id: GnbCuUpUeE1apId,
    pub security_information: Option<SecurityInformation>,
    pub ue_dl_aggregate_maximum_bit_rate: Option<BitRate>,
    pub ue_dl_maximum_integrity_protected_data_rate: Option<BitRate>,
    pub bearer_context_status_change: Option<BearerContextStatusChange>,
    pub new_ul_tnl_information_required: Option<NewUlTnlInformationRequired>,
    pub ue_inactivity_timer: Option<InactivityTimer>,
    pub data_discard_required: Option<DataDiscardRequired>,
    pub system_bearer_context_modification_request: Option<SystemBearerContextModificationRequest>,
    pub ran_ue_id: Option<RanUeId>,
    pub gnb_du_id: Option<GnbDuId>,
    pub activity_notification_level: Option<ActivityNotificationLevel>,
}

impl BearerContextModificationRequest {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let _ = decode::decode_sequence_header(data, true, 0)?;
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut gnb_cu_cp_ue_e1ap_id: Option<GnbCuCpUeE1apId> = None;
        let mut gnb_cu_up_ue_e1ap_id: Option<GnbCuUpUeE1apId> = None;
        let mut security_information: Option<SecurityInformation> = None;
        let mut ue_dl_aggregate_maximum_bit_rate: Option<BitRate> = None;
        let mut ue_dl_maximum_integrity_protected_data_rate: Option<BitRate> = None;
        let mut bearer_context_status_change: Option<BearerContextStatusChange> = None;
        let mut new_ul_tnl_information_required: Option<NewUlTnlInformationRequired> = None;
        let mut ue_inactivity_timer: Option<InactivityTimer> = None;
        let mut data_discard_required: Option<DataDiscardRequired> = None;
        let mut system_bearer_context_modification_request: Option<
            SystemBearerContextModificationRequest,
        > = None;
        let mut ran_ue_id: Option<RanUeId> = None;
        let mut gnb_du_id: Option<GnbDuId> = None;
        let mut activity_notification_level: Option<ActivityNotificationLevel> = None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                2 => gnb_cu_cp_ue_e1ap_id = Some(GnbCuCpUeE1apId::decode(data)?),
                3 => gnb_cu_up_ue_e1ap_id = Some(GnbCuUpUeE1apId::decode(data)?),
                13 => security_information = Some(SecurityInformation::decode(data)?),
                14 => ue_dl_aggregate_maximum_bit_rate = Some(BitRate::decode(data)?),
                66 => ue_dl_maximum_integrity_protected_data_rate = Some(BitRate::decode(data)?),
                17 => bearer_context_status_change = Some(BearerContextStatusChange::decode(data)?),
                26 => {
                    new_ul_tnl_information_required =
                        Some(NewUlTnlInformationRequired::decode(data)?)
                }
                59 => ue_inactivity_timer = Some(InactivityTimer::decode(data)?),
                70 => data_discard_required = Some(DataDiscardRequired::decode(data)?),
                18 => {
                    system_bearer_context_modification_request =
                        Some(SystemBearerContextModificationRequest::decode(data)?)
                }
                76 => ran_ue_id = Some(RanUeId::decode(data)?),
                77 => gnb_du_id = Some(GnbDuId::decode(data)?),
                23 => activity_notification_level = Some(ActivityNotificationLevel::decode(data)?),
                x => return Err(PerCodecError::new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        let gnb_cu_cp_ue_e1ap_id = gnb_cu_cp_ue_e1ap_id.ok_or(PerCodecError::new(format!(
            "Missing mandatory IE gnb_cu_cp_ue_e1ap_id"
        )))?;
        let gnb_cu_up_ue_e1ap_id = gnb_cu_up_ue_e1ap_id.ok_or(PerCodecError::new(format!(
            "Missing mandatory IE gnb_cu_up_ue_e1ap_id"
        )))?;
        Ok(Self {
            gnb_cu_cp_ue_e1ap_id,
            gnb_cu_up_ue_e1ap_id,
            security_information,
            ue_dl_aggregate_maximum_bit_rate,
            ue_dl_maximum_integrity_protected_data_rate,
            bearer_context_status_change,
            new_ul_tnl_information_required,
            ue_inactivity_timer,
            data_discard_required,
            system_bearer_context_modification_request,
            ran_ue_id,
            gnb_du_id,
            activity_notification_level,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        let ie = &mut Allocator::new_codec_data();
        self.gnb_cu_cp_ue_e1ap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 2, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.gnb_cu_up_ue_e1ap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 3, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        if let Some(x) = &self.security_information {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 13, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.ue_dl_aggregate_maximum_bit_rate {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 14, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.ue_dl_maximum_integrity_protected_data_rate {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 66, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.bearer_context_status_change {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 17, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.new_ul_tnl_information_required {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 26, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.ue_inactivity_timer {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 59, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.data_discard_required {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 70, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.system_bearer_context_modification_request {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 18, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.ran_ue_id {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 76, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.gnb_du_id {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 77, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.activity_notification_level {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 23, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        encode::encode_sequence_header(data, true, &BitString::new(), false)?;
        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for BearerContextModificationRequest {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        BearerContextModificationRequest::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("BearerContextModificationRequest");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("BearerContextModificationRequest");
            e
        })
    }
}
// SystemBearerContextModificationRequest
#[derive(Clone, Debug)]
pub enum SystemBearerContextModificationRequest {
    EutranBearerContextModificationRequest(EutranBearerContextModificationRequest),
    NgRanBearerContextModificationRequest(NgRanBearerContextModificationRequest),
}

impl SystemBearerContextModificationRequest {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_choice_idx(data, 0, 2, false)?;
        if extended {
            return Err(PerCodecError::new("CHOICE additions not implemented"));
        }
        match idx {
            0 => Ok(Self::EutranBearerContextModificationRequest(
                EutranBearerContextModificationRequest::decode(data)?,
            )),
            1 => Ok(Self::NgRanBearerContextModificationRequest(
                NgRanBearerContextModificationRequest::decode(data)?,
            )),
            2 => {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _ = Criticality::decode(data)?;
                let _ = decode::decode_length_determinent(data, None, None, false)?;
                let result = match id {
                    x => Err(PerCodecError::new(format!("Unrecognised IE type {}", x))),
                };
                data.decode_align()?;
                result
            }
            _ => Err(PerCodecError::new("Unknown choice idx")),
        }
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        match self {
            Self::EutranBearerContextModificationRequest(x) => {
                encode::encode_choice_idx(data, 0, 2, false, 0, false)?;
                x.encode(data)
            }
            Self::NgRanBearerContextModificationRequest(x) => {
                encode::encode_choice_idx(data, 0, 2, false, 1, false)?;
                x.encode(data)
            }
        }
    }
}

impl PerCodec for SystemBearerContextModificationRequest {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        SystemBearerContextModificationRequest::decode_inner(data).map_err(
            |mut e: PerCodecError| {
                e.push_context("SystemBearerContextModificationRequest");
                e
            },
        )
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SystemBearerContextModificationRequest");
            e
        })
    }
}
// BearerContextModificationResponse
#[derive(Clone, Debug)]
pub struct BearerContextModificationResponse {
    pub gnb_cu_cp_ue_e1ap_id: GnbCuCpUeE1apId,
    pub gnb_cu_up_ue_e1ap_id: GnbCuUpUeE1apId,
    pub system_bearer_context_modification_response:
        Option<SystemBearerContextModificationResponse>,
}

impl BearerContextModificationResponse {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let _ = decode::decode_sequence_header(data, true, 0)?;
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut gnb_cu_cp_ue_e1ap_id: Option<GnbCuCpUeE1apId> = None;
        let mut gnb_cu_up_ue_e1ap_id: Option<GnbCuUpUeE1apId> = None;
        let mut system_bearer_context_modification_response: Option<
            SystemBearerContextModificationResponse,
        > = None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                2 => gnb_cu_cp_ue_e1ap_id = Some(GnbCuCpUeE1apId::decode(data)?),
                3 => gnb_cu_up_ue_e1ap_id = Some(GnbCuUpUeE1apId::decode(data)?),
                19 => {
                    system_bearer_context_modification_response =
                        Some(SystemBearerContextModificationResponse::decode(data)?)
                }
                x => return Err(PerCodecError::new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        let gnb_cu_cp_ue_e1ap_id = gnb_cu_cp_ue_e1ap_id.ok_or(PerCodecError::new(format!(
            "Missing mandatory IE gnb_cu_cp_ue_e1ap_id"
        )))?;
        let gnb_cu_up_ue_e1ap_id = gnb_cu_up_ue_e1ap_id.ok_or(PerCodecError::new(format!(
            "Missing mandatory IE gnb_cu_up_ue_e1ap_id"
        )))?;
        Ok(Self {
            gnb_cu_cp_ue_e1ap_id,
            gnb_cu_up_ue_e1ap_id,
            system_bearer_context_modification_response,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        let ie = &mut Allocator::new_codec_data();
        self.gnb_cu_cp_ue_e1ap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 2, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.gnb_cu_up_ue_e1ap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 3, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        if let Some(x) = &self.system_bearer_context_modification_response {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 19, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        encode::encode_sequence_header(data, true, &BitString::new(), false)?;
        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for BearerContextModificationResponse {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        BearerContextModificationResponse::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("BearerContextModificationResponse");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("BearerContextModificationResponse");
            e
        })
    }
}
// SystemBearerContextModificationResponse
#[derive(Clone, Debug)]
pub enum SystemBearerContextModificationResponse {
    EutranBearerContextModificationResponse(EutranBearerContextModificationResponse),
    NgRanBearerContextModificationResponse(NgRanBearerContextModificationResponse),
}

impl SystemBearerContextModificationResponse {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_choice_idx(data, 0, 2, false)?;
        if extended {
            return Err(PerCodecError::new("CHOICE additions not implemented"));
        }
        match idx {
            0 => Ok(Self::EutranBearerContextModificationResponse(
                EutranBearerContextModificationResponse::decode(data)?,
            )),
            1 => Ok(Self::NgRanBearerContextModificationResponse(
                NgRanBearerContextModificationResponse::decode(data)?,
            )),
            2 => {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _ = Criticality::decode(data)?;
                let _ = decode::decode_length_determinent(data, None, None, false)?;
                let result = match id {
                    x => Err(PerCodecError::new(format!("Unrecognised IE type {}", x))),
                };
                data.decode_align()?;
                result
            }
            _ => Err(PerCodecError::new("Unknown choice idx")),
        }
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        match self {
            Self::EutranBearerContextModificationResponse(x) => {
                encode::encode_choice_idx(data, 0, 2, false, 0, false)?;
                x.encode(data)
            }
            Self::NgRanBearerContextModificationResponse(x) => {
                encode::encode_choice_idx(data, 0, 2, false, 1, false)?;
                x.encode(data)
            }
        }
    }
}

impl PerCodec for SystemBearerContextModificationResponse {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        SystemBearerContextModificationResponse::decode_inner(data).map_err(
            |mut e: PerCodecError| {
                e.push_context("SystemBearerContextModificationResponse");
                e
            },
        )
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SystemBearerContextModificationResponse");
            e
        })
    }
}
// BearerContextModificationFailure
#[derive(Clone, Debug)]
pub struct BearerContextModificationFailure {
    pub gnb_cu_cp_ue_e1ap_id: GnbCuCpUeE1apId,
    pub gnb_cu_up_ue_e1ap_id: GnbCuUpUeE1apId,
    pub cause: Cause,
    pub criticality_diagnostics: Option<CriticalityDiagnostics>,
}

impl BearerContextModificationFailure {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let _ = decode::decode_sequence_header(data, true, 0)?;
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut gnb_cu_cp_ue_e1ap_id: Option<GnbCuCpUeE1apId> = None;
        let mut gnb_cu_up_ue_e1ap_id: Option<GnbCuUpUeE1apId> = None;
        let mut cause: Option<Cause> = None;
        let mut criticality_diagnostics: Option<CriticalityDiagnostics> = None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                2 => gnb_cu_cp_ue_e1ap_id = Some(GnbCuCpUeE1apId::decode(data)?),
                3 => gnb_cu_up_ue_e1ap_id = Some(GnbCuUpUeE1apId::decode(data)?),
                0 => cause = Some(Cause::decode(data)?),
                1 => criticality_diagnostics = Some(CriticalityDiagnostics::decode(data)?),
                x => return Err(PerCodecError::new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        let gnb_cu_cp_ue_e1ap_id = gnb_cu_cp_ue_e1ap_id.ok_or(PerCodecError::new(format!(
            "Missing mandatory IE gnb_cu_cp_ue_e1ap_id"
        )))?;
        let gnb_cu_up_ue_e1ap_id = gnb_cu_up_ue_e1ap_id.ok_or(PerCodecError::new(format!(
            "Missing mandatory IE gnb_cu_up_ue_e1ap_id"
        )))?;
        let cause = cause.ok_or(PerCodecError::new(format!("Missing mandatory IE cause")))?;
        Ok(Self {
            gnb_cu_cp_ue_e1ap_id,
            gnb_cu_up_ue_e1ap_id,
            cause,
            criticality_diagnostics,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        let ie = &mut Allocator::new_codec_data();
        self.gnb_cu_cp_ue_e1ap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 2, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.gnb_cu_up_ue_e1ap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 3, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.cause.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 0, false)?;
        Criticality::Ignore.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        if let Some(x) = &self.criticality_diagnostics {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 1, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        encode::encode_sequence_header(data, true, &BitString::new(), false)?;
        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for BearerContextModificationFailure {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        BearerContextModificationFailure::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("BearerContextModificationFailure");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("BearerContextModificationFailure");
            e
        })
    }
}
// BearerContextModificationRequired
#[derive(Clone, Debug)]
pub struct BearerContextModificationRequired {
    pub gnb_cu_cp_ue_e1ap_id: GnbCuCpUeE1apId,
    pub gnb_cu_up_ue_e1ap_id: GnbCuUpUeE1apId,
    pub system_bearer_context_modification_required: SystemBearerContextModificationRequired,
}

impl BearerContextModificationRequired {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let _ = decode::decode_sequence_header(data, true, 0)?;
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut gnb_cu_cp_ue_e1ap_id: Option<GnbCuCpUeE1apId> = None;
        let mut gnb_cu_up_ue_e1ap_id: Option<GnbCuUpUeE1apId> = None;
        let mut system_bearer_context_modification_required: Option<
            SystemBearerContextModificationRequired,
        > = None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                2 => gnb_cu_cp_ue_e1ap_id = Some(GnbCuCpUeE1apId::decode(data)?),
                3 => gnb_cu_up_ue_e1ap_id = Some(GnbCuUpUeE1apId::decode(data)?),
                21 => {
                    system_bearer_context_modification_required =
                        Some(SystemBearerContextModificationRequired::decode(data)?)
                }
                x => return Err(PerCodecError::new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        let gnb_cu_cp_ue_e1ap_id = gnb_cu_cp_ue_e1ap_id.ok_or(PerCodecError::new(format!(
            "Missing mandatory IE gnb_cu_cp_ue_e1ap_id"
        )))?;
        let gnb_cu_up_ue_e1ap_id = gnb_cu_up_ue_e1ap_id.ok_or(PerCodecError::new(format!(
            "Missing mandatory IE gnb_cu_up_ue_e1ap_id"
        )))?;
        let system_bearer_context_modification_required =
            system_bearer_context_modification_required.ok_or(PerCodecError::new(format!(
                "Missing mandatory IE system_bearer_context_modification_required"
            )))?;
        Ok(Self {
            gnb_cu_cp_ue_e1ap_id,
            gnb_cu_up_ue_e1ap_id,
            system_bearer_context_modification_required,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        let ie = &mut Allocator::new_codec_data();
        self.gnb_cu_cp_ue_e1ap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 2, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.gnb_cu_up_ue_e1ap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 3, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.system_bearer_context_modification_required
            .encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 21, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        encode::encode_sequence_header(data, true, &BitString::new(), false)?;
        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for BearerContextModificationRequired {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        BearerContextModificationRequired::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("BearerContextModificationRequired");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("BearerContextModificationRequired");
            e
        })
    }
}
// SystemBearerContextModificationRequired
#[derive(Clone, Debug)]
pub enum SystemBearerContextModificationRequired {
    EutranBearerContextModificationRequired(EutranBearerContextModificationRequired),
    NgRanBearerContextModificationRequired(NgRanBearerContextModificationRequired),
}

impl SystemBearerContextModificationRequired {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_choice_idx(data, 0, 2, false)?;
        if extended {
            return Err(PerCodecError::new("CHOICE additions not implemented"));
        }
        match idx {
            0 => Ok(Self::EutranBearerContextModificationRequired(
                EutranBearerContextModificationRequired::decode(data)?,
            )),
            1 => Ok(Self::NgRanBearerContextModificationRequired(
                NgRanBearerContextModificationRequired::decode(data)?,
            )),
            2 => {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _ = Criticality::decode(data)?;
                let _ = decode::decode_length_determinent(data, None, None, false)?;
                let result = match id {
                    x => Err(PerCodecError::new(format!("Unrecognised IE type {}", x))),
                };
                data.decode_align()?;
                result
            }
            _ => Err(PerCodecError::new("Unknown choice idx")),
        }
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        match self {
            Self::EutranBearerContextModificationRequired(x) => {
                encode::encode_choice_idx(data, 0, 2, false, 0, false)?;
                x.encode(data)
            }
            Self::NgRanBearerContextModificationRequired(x) => {
                encode::encode_choice_idx(data, 0, 2, false, 1, false)?;
                x.encode(data)
            }
        }
    }
}

impl PerCodec for SystemBearerContextModificationRequired {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        SystemBearerContextModificationRequired::decode_inner(data).map_err(
            |mut e: PerCodecError| {
                e.push_context("SystemBearerContextModificationRequired");
                e
            },
        )
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SystemBearerContextModificationRequired");
            e
        })
    }
}
// BearerContextModificationConfirm
#[derive(Clone, Debug)]
pub struct BearerContextModificationConfirm {
    pub gnb_cu_cp_ue_e1ap_id: GnbCuCpUeE1apId,
    pub gnb_cu_up_ue_e1ap_id: GnbCuUpUeE1apId,
    pub system_bearer_context_modification_confirm: Option<SystemBearerContextModificationConfirm>,
}

impl BearerContextModificationConfirm {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let _ = decode::decode_sequence_header(data, true, 0)?;
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut gnb_cu_cp_ue_e1ap_id: Option<GnbCuCpUeE1apId> = None;
        let mut gnb_cu_up_ue_e1ap_id: Option<GnbCuUpUeE1apId> = None;
        let mut system_bearer_context_modification_confirm: Option<
            SystemBearerContextModificationConfirm,
        > = None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                2 => gnb_cu_cp_ue_e1ap_id = Some(GnbCuCpUeE1apId::decode(data)?),
                3 => gnb_cu_up_ue_e1ap_id = Some(GnbCuUpUeE1apId::decode(data)?),
                20 => {
                    system_bearer_context_modification_confirm =
                        Some(SystemBearerContextModificationConfirm::decode(data)?)
                }
                x => return Err(PerCodecError::new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        let gnb_cu_cp_ue_e1ap_id = gnb_cu_cp_ue_e1ap_id.ok_or(PerCodecError::new(format!(
            "Missing mandatory IE gnb_cu_cp_ue_e1ap_id"
        )))?;
        let gnb_cu_up_ue_e1ap_id = gnb_cu_up_ue_e1ap_id.ok_or(PerCodecError::new(format!(
            "Missing mandatory IE gnb_cu_up_ue_e1ap_id"
        )))?;
        Ok(Self {
            gnb_cu_cp_ue_e1ap_id,
            gnb_cu_up_ue_e1ap_id,
            system_bearer_context_modification_confirm,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        let ie = &mut Allocator::new_codec_data();
        self.gnb_cu_cp_ue_e1ap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 2, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.gnb_cu_up_ue_e1ap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 3, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        if let Some(x) = &self.system_bearer_context_modification_confirm {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 20, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        encode::encode_sequence_header(data, true, &BitString::new(), false)?;
        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for BearerContextModificationConfirm {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        BearerContextModificationConfirm::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("BearerContextModificationConfirm");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("BearerContextModificationConfirm");
            e
        })
    }
}
// SystemBearerContextModificationConfirm
#[derive(Clone, Debug)]
pub enum SystemBearerContextModificationConfirm {
    EutranBearerContextModificationConfirm(EutranBearerContextModificationConfirm),
    NgRanBearerContextModificationConfirm(NgRanBearerContextModificationConfirm),
}

impl SystemBearerContextModificationConfirm {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_choice_idx(data, 0, 2, false)?;
        if extended {
            return Err(PerCodecError::new("CHOICE additions not implemented"));
        }
        match idx {
            0 => Ok(Self::EutranBearerContextModificationConfirm(
                EutranBearerContextModificationConfirm::decode(data)?,
            )),
            1 => Ok(Self::NgRanBearerContextModificationConfirm(
                NgRanBearerContextModificationConfirm::decode(data)?,
            )),
            2 => {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _ = Criticality::decode(data)?;
                let _ = decode::decode_length_determinent(data, None, None, false)?;
                let result = match id {
                    x => Err(PerCodecError::new(format!("Unrecognised IE type {}", x))),
                };
                data.decode_align()?;
                result
            }
            _ => Err(PerCodecError::new("Unknown choice idx")),
        }
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        match self {
            Self::EutranBearerContextModificationConfirm(x) => {
                encode::encode_choice_idx(data, 0, 2, false, 0, false)?;
                x.encode(data)
            }
            Self::NgRanBearerContextModificationConfirm(x) => {
                encode::encode_choice_idx(data, 0, 2, false, 1, false)?;
                x.encode(data)
            }
        }
    }
}

impl PerCodec for SystemBearerContextModificationConfirm {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        SystemBearerContextModificationConfirm::decode_inner(data).map_err(
            |mut e: PerCodecError| {
                e.push_context("SystemBearerContextModificationConfirm");
                e
            },
        )
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SystemBearerContextModificationConfirm");
            e
        })
    }
}
// BearerContextReleaseCommand
#[derive(Clone, Debug)]
pub struct BearerContextReleaseCommand {
    pub gnb_cu_cp_ue_e1ap_id: GnbCuCpUeE1apId,
    pub gnb_cu_up_ue_e1ap_id: GnbCuUpUeE1apId,
    pub cause: Cause,
}

impl BearerContextReleaseCommand {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let _ = decode::decode_sequence_header(data, true, 0)?;
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut gnb_cu_cp_ue_e1ap_id: Option<GnbCuCpUeE1apId> = None;
        let mut gnb_cu_up_ue_e1ap_id: Option<GnbCuUpUeE1apId> = None;
        let mut cause: Option<Cause> = None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                2 => gnb_cu_cp_ue_e1ap_id = Some(GnbCuCpUeE1apId::decode(data)?),
                3 => gnb_cu_up_ue_e1ap_id = Some(GnbCuUpUeE1apId::decode(data)?),
                0 => cause = Some(Cause::decode(data)?),
                x => return Err(PerCodecError::new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        let gnb_cu_cp_ue_e1ap_id = gnb_cu_cp_ue_e1ap_id.ok_or(PerCodecError::new(format!(
            "Missing mandatory IE gnb_cu_cp_ue_e1ap_id"
        )))?;
        let gnb_cu_up_ue_e1ap_id = gnb_cu_up_ue_e1ap_id.ok_or(PerCodecError::new(format!(
            "Missing mandatory IE gnb_cu_up_ue_e1ap_id"
        )))?;
        let cause = cause.ok_or(PerCodecError::new(format!("Missing mandatory IE cause")))?;
        Ok(Self {
            gnb_cu_cp_ue_e1ap_id,
            gnb_cu_up_ue_e1ap_id,
            cause,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        let ie = &mut Allocator::new_codec_data();
        self.gnb_cu_cp_ue_e1ap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 2, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.gnb_cu_up_ue_e1ap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 3, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.cause.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 0, false)?;
        Criticality::Ignore.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        encode::encode_sequence_header(data, true, &BitString::new(), false)?;
        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for BearerContextReleaseCommand {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        BearerContextReleaseCommand::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("BearerContextReleaseCommand");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("BearerContextReleaseCommand");
            e
        })
    }
}
// BearerContextReleaseComplete
#[derive(Clone, Debug)]
pub struct BearerContextReleaseComplete {
    pub gnb_cu_cp_ue_e1ap_id: GnbCuCpUeE1apId,
    pub gnb_cu_up_ue_e1ap_id: GnbCuUpUeE1apId,
    pub criticality_diagnostics: Option<CriticalityDiagnostics>,
    pub retainability_measurements_info: Option<RetainabilityMeasurementsInfo>,
}

impl BearerContextReleaseComplete {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let _ = decode::decode_sequence_header(data, true, 0)?;
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut gnb_cu_cp_ue_e1ap_id: Option<GnbCuCpUeE1apId> = None;
        let mut gnb_cu_up_ue_e1ap_id: Option<GnbCuUpUeE1apId> = None;
        let mut criticality_diagnostics: Option<CriticalityDiagnostics> = None;
        let mut retainability_measurements_info: Option<RetainabilityMeasurementsInfo> = None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                2 => gnb_cu_cp_ue_e1ap_id = Some(GnbCuCpUeE1apId::decode(data)?),
                3 => gnb_cu_up_ue_e1ap_id = Some(GnbCuUpUeE1apId::decode(data)?),
                1 => criticality_diagnostics = Some(CriticalityDiagnostics::decode(data)?),
                85 => {
                    retainability_measurements_info =
                        Some(RetainabilityMeasurementsInfo::decode(data)?)
                }
                x => return Err(PerCodecError::new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        let gnb_cu_cp_ue_e1ap_id = gnb_cu_cp_ue_e1ap_id.ok_or(PerCodecError::new(format!(
            "Missing mandatory IE gnb_cu_cp_ue_e1ap_id"
        )))?;
        let gnb_cu_up_ue_e1ap_id = gnb_cu_up_ue_e1ap_id.ok_or(PerCodecError::new(format!(
            "Missing mandatory IE gnb_cu_up_ue_e1ap_id"
        )))?;
        Ok(Self {
            gnb_cu_cp_ue_e1ap_id,
            gnb_cu_up_ue_e1ap_id,
            criticality_diagnostics,
            retainability_measurements_info,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        let ie = &mut Allocator::new_codec_data();
        self.gnb_cu_cp_ue_e1ap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 2, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.gnb_cu_up_ue_e1ap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 3, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        if let Some(x) = &self.criticality_diagnostics {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 1, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.retainability_measurements_info {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 85, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        encode::encode_sequence_header(data, true, &BitString::new(), false)?;
        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for BearerContextReleaseComplete {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        BearerContextReleaseComplete::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("BearerContextReleaseComplete");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("BearerContextReleaseComplete");
            e
        })
    }
}
// BearerContextReleaseRequest
#[derive(Clone, Debug)]
pub struct BearerContextReleaseRequest {
    pub gnb_cu_cp_ue_e1ap_id: GnbCuCpUeE1apId,
    pub gnb_cu_up_ue_e1ap_id: GnbCuUpUeE1apId,
    pub drb_status_list: Option<DrbStatusList>,
    pub cause: Cause,
}

impl BearerContextReleaseRequest {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let _ = decode::decode_sequence_header(data, true, 0)?;
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut gnb_cu_cp_ue_e1ap_id: Option<GnbCuCpUeE1apId> = None;
        let mut gnb_cu_up_ue_e1ap_id: Option<GnbCuUpUeE1apId> = None;
        let mut drb_status_list: Option<DrbStatusList> = None;
        let mut cause: Option<Cause> = None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                2 => gnb_cu_cp_ue_e1ap_id = Some(GnbCuCpUeE1apId::decode(data)?),
                3 => gnb_cu_up_ue_e1ap_id = Some(GnbCuUpUeE1apId::decode(data)?),
                22 => drb_status_list = Some(DrbStatusList::decode(data)?),
                0 => cause = Some(Cause::decode(data)?),
                x => return Err(PerCodecError::new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        let gnb_cu_cp_ue_e1ap_id = gnb_cu_cp_ue_e1ap_id.ok_or(PerCodecError::new(format!(
            "Missing mandatory IE gnb_cu_cp_ue_e1ap_id"
        )))?;
        let gnb_cu_up_ue_e1ap_id = gnb_cu_up_ue_e1ap_id.ok_or(PerCodecError::new(format!(
            "Missing mandatory IE gnb_cu_up_ue_e1ap_id"
        )))?;
        let cause = cause.ok_or(PerCodecError::new(format!("Missing mandatory IE cause")))?;
        Ok(Self {
            gnb_cu_cp_ue_e1ap_id,
            gnb_cu_up_ue_e1ap_id,
            drb_status_list,
            cause,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        let ie = &mut Allocator::new_codec_data();
        self.gnb_cu_cp_ue_e1ap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 2, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.gnb_cu_up_ue_e1ap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 3, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        if let Some(x) = &self.drb_status_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 22, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        let ie = &mut Allocator::new_codec_data();
        self.cause.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 0, false)?;
        Criticality::Ignore.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        encode::encode_sequence_header(data, true, &BitString::new(), false)?;
        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for BearerContextReleaseRequest {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        BearerContextReleaseRequest::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("BearerContextReleaseRequest");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("BearerContextReleaseRequest");
            e
        })
    }
}
// DrbStatusList
#[derive(Clone, Debug)]
pub struct DrbStatusList(pub NonEmpty<DrbStatusItem>);

impl DrbStatusList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(32), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(DrbStatusItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(32), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for DrbStatusList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        DrbStatusList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DrbStatusList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DrbStatusList");
            e
        })
    }
}
// BearerContextInactivityNotification
#[derive(Clone, Debug)]
pub struct BearerContextInactivityNotification {
    pub gnb_cu_cp_ue_e1ap_id: GnbCuCpUeE1apId,
    pub gnb_cu_up_ue_e1ap_id: GnbCuUpUeE1apId,
    pub activity_information: ActivityInformation,
}

impl BearerContextInactivityNotification {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let _ = decode::decode_sequence_header(data, true, 0)?;
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut gnb_cu_cp_ue_e1ap_id: Option<GnbCuCpUeE1apId> = None;
        let mut gnb_cu_up_ue_e1ap_id: Option<GnbCuUpUeE1apId> = None;
        let mut activity_information: Option<ActivityInformation> = None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                2 => gnb_cu_cp_ue_e1ap_id = Some(GnbCuCpUeE1apId::decode(data)?),
                3 => gnb_cu_up_ue_e1ap_id = Some(GnbCuUpUeE1apId::decode(data)?),
                24 => activity_information = Some(ActivityInformation::decode(data)?),
                x => return Err(PerCodecError::new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        let gnb_cu_cp_ue_e1ap_id = gnb_cu_cp_ue_e1ap_id.ok_or(PerCodecError::new(format!(
            "Missing mandatory IE gnb_cu_cp_ue_e1ap_id"
        )))?;
        let gnb_cu_up_ue_e1ap_id = gnb_cu_up_ue_e1ap_id.ok_or(PerCodecError::new(format!(
            "Missing mandatory IE gnb_cu_up_ue_e1ap_id"
        )))?;
        let activity_information = activity_information.ok_or(PerCodecError::new(format!(
            "Missing mandatory IE activity_information"
        )))?;
        Ok(Self {
            gnb_cu_cp_ue_e1ap_id,
            gnb_cu_up_ue_e1ap_id,
            activity_information,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        let ie = &mut Allocator::new_codec_data();
        self.gnb_cu_cp_ue_e1ap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 2, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.gnb_cu_up_ue_e1ap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 3, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.activity_information.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 24, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        encode::encode_sequence_header(data, true, &BitString::new(), false)?;
        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for BearerContextInactivityNotification {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        BearerContextInactivityNotification::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("BearerContextInactivityNotification");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("BearerContextInactivityNotification");
            e
        })
    }
}
// DlDataNotification
#[derive(Clone, Debug)]
pub struct DlDataNotification {
    pub gnb_cu_cp_ue_e1ap_id: GnbCuCpUeE1apId,
    pub gnb_cu_up_ue_e1ap_id: GnbCuUpUeE1apId,
    pub ppi: Option<Ppi>,
    pub pdu_session_to_notify_list: Option<PduSessionToNotifyList>,
}

impl DlDataNotification {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let _ = decode::decode_sequence_header(data, true, 0)?;
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut gnb_cu_cp_ue_e1ap_id: Option<GnbCuCpUeE1apId> = None;
        let mut gnb_cu_up_ue_e1ap_id: Option<GnbCuUpUeE1apId> = None;
        let mut ppi: Option<Ppi> = None;
        let mut pdu_session_to_notify_list: Option<PduSessionToNotifyList> = None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                2 => gnb_cu_cp_ue_e1ap_id = Some(GnbCuCpUeE1apId::decode(data)?),
                3 => gnb_cu_up_ue_e1ap_id = Some(GnbCuUpUeE1apId::decode(data)?),
                63 => ppi = Some(Ppi::decode(data)?),
                67 => pdu_session_to_notify_list = Some(PduSessionToNotifyList::decode(data)?),
                x => return Err(PerCodecError::new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        let gnb_cu_cp_ue_e1ap_id = gnb_cu_cp_ue_e1ap_id.ok_or(PerCodecError::new(format!(
            "Missing mandatory IE gnb_cu_cp_ue_e1ap_id"
        )))?;
        let gnb_cu_up_ue_e1ap_id = gnb_cu_up_ue_e1ap_id.ok_or(PerCodecError::new(format!(
            "Missing mandatory IE gnb_cu_up_ue_e1ap_id"
        )))?;
        Ok(Self {
            gnb_cu_cp_ue_e1ap_id,
            gnb_cu_up_ue_e1ap_id,
            ppi,
            pdu_session_to_notify_list,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        let ie = &mut Allocator::new_codec_data();
        self.gnb_cu_cp_ue_e1ap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 2, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.gnb_cu_up_ue_e1ap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 3, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        if let Some(x) = &self.ppi {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 63, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.pdu_session_to_notify_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 67, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        encode::encode_sequence_header(data, true, &BitString::new(), false)?;
        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for DlDataNotification {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        DlDataNotification::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DlDataNotification");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DlDataNotification");
            e
        })
    }
}
// UlDataNotification
#[derive(Clone, Debug)]
pub struct UlDataNotification {
    pub gnb_cu_cp_ue_e1ap_id: GnbCuCpUeE1apId,
    pub gnb_cu_up_ue_e1ap_id: GnbCuUpUeE1apId,
    pub pdu_session_to_notify_list: PduSessionToNotifyList,
}

impl UlDataNotification {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let _ = decode::decode_sequence_header(data, true, 0)?;
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut gnb_cu_cp_ue_e1ap_id: Option<GnbCuCpUeE1apId> = None;
        let mut gnb_cu_up_ue_e1ap_id: Option<GnbCuUpUeE1apId> = None;
        let mut pdu_session_to_notify_list: Option<PduSessionToNotifyList> = None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                2 => gnb_cu_cp_ue_e1ap_id = Some(GnbCuCpUeE1apId::decode(data)?),
                3 => gnb_cu_up_ue_e1ap_id = Some(GnbCuUpUeE1apId::decode(data)?),
                67 => pdu_session_to_notify_list = Some(PduSessionToNotifyList::decode(data)?),
                x => return Err(PerCodecError::new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        let gnb_cu_cp_ue_e1ap_id = gnb_cu_cp_ue_e1ap_id.ok_or(PerCodecError::new(format!(
            "Missing mandatory IE gnb_cu_cp_ue_e1ap_id"
        )))?;
        let gnb_cu_up_ue_e1ap_id = gnb_cu_up_ue_e1ap_id.ok_or(PerCodecError::new(format!(
            "Missing mandatory IE gnb_cu_up_ue_e1ap_id"
        )))?;
        let pdu_session_to_notify_list = pdu_session_to_notify_list.ok_or(PerCodecError::new(
            format!("Missing mandatory IE pdu_session_to_notify_list"),
        ))?;
        Ok(Self {
            gnb_cu_cp_ue_e1ap_id,
            gnb_cu_up_ue_e1ap_id,
            pdu_session_to_notify_list,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        let ie = &mut Allocator::new_codec_data();
        self.gnb_cu_cp_ue_e1ap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 2, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.gnb_cu_up_ue_e1ap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 3, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.pdu_session_to_notify_list.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 67, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        encode::encode_sequence_header(data, true, &BitString::new(), false)?;
        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for UlDataNotification {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        UlDataNotification::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UlDataNotification");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UlDataNotification");
            e
        })
    }
}
// DataUsageReport
#[derive(Clone, Debug)]
pub struct DataUsageReport {
    pub gnb_cu_cp_ue_e1ap_id: GnbCuCpUeE1apId,
    pub gnb_cu_up_ue_e1ap_id: GnbCuUpUeE1apId,
    pub data_usage_report_list: DataUsageReportList,
}

impl DataUsageReport {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let _ = decode::decode_sequence_header(data, true, 0)?;
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut gnb_cu_cp_ue_e1ap_id: Option<GnbCuCpUeE1apId> = None;
        let mut gnb_cu_up_ue_e1ap_id: Option<GnbCuUpUeE1apId> = None;
        let mut data_usage_report_list: Option<DataUsageReportList> = None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                2 => gnb_cu_cp_ue_e1ap_id = Some(GnbCuCpUeE1apId::decode(data)?),
                3 => gnb_cu_up_ue_e1ap_id = Some(GnbCuUpUeE1apId::decode(data)?),
                25 => data_usage_report_list = Some(DataUsageReportList::decode(data)?),
                x => return Err(PerCodecError::new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        let gnb_cu_cp_ue_e1ap_id = gnb_cu_cp_ue_e1ap_id.ok_or(PerCodecError::new(format!(
            "Missing mandatory IE gnb_cu_cp_ue_e1ap_id"
        )))?;
        let gnb_cu_up_ue_e1ap_id = gnb_cu_up_ue_e1ap_id.ok_or(PerCodecError::new(format!(
            "Missing mandatory IE gnb_cu_up_ue_e1ap_id"
        )))?;
        let data_usage_report_list = data_usage_report_list.ok_or(PerCodecError::new(format!(
            "Missing mandatory IE data_usage_report_list"
        )))?;
        Ok(Self {
            gnb_cu_cp_ue_e1ap_id,
            gnb_cu_up_ue_e1ap_id,
            data_usage_report_list,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        let ie = &mut Allocator::new_codec_data();
        self.gnb_cu_cp_ue_e1ap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 2, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.gnb_cu_up_ue_e1ap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 3, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.data_usage_report_list.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 25, false)?;
        Criticality::Ignore.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        encode::encode_sequence_header(data, true, &BitString::new(), false)?;
        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for DataUsageReport {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        DataUsageReport::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DataUsageReport");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DataUsageReport");
            e
        })
    }
}
// GnbCuUpCounterCheckRequest
#[derive(Clone, Debug)]
pub struct GnbCuUpCounterCheckRequest {
    pub gnb_cu_cp_ue_e1ap_id: GnbCuCpUeE1apId,
    pub gnb_cu_up_ue_e1ap_id: GnbCuUpUeE1apId,
    pub system_gnb_cu_up_counter_check_request: SystemGnbCuUpCounterCheckRequest,
}

impl GnbCuUpCounterCheckRequest {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let _ = decode::decode_sequence_header(data, true, 0)?;
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut gnb_cu_cp_ue_e1ap_id: Option<GnbCuCpUeE1apId> = None;
        let mut gnb_cu_up_ue_e1ap_id: Option<GnbCuUpUeE1apId> = None;
        let mut system_gnb_cu_up_counter_check_request: Option<SystemGnbCuUpCounterCheckRequest> =
            None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                2 => gnb_cu_cp_ue_e1ap_id = Some(GnbCuCpUeE1apId::decode(data)?),
                3 => gnb_cu_up_ue_e1ap_id = Some(GnbCuUpUeE1apId::decode(data)?),
                60 => {
                    system_gnb_cu_up_counter_check_request =
                        Some(SystemGnbCuUpCounterCheckRequest::decode(data)?)
                }
                x => return Err(PerCodecError::new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        let gnb_cu_cp_ue_e1ap_id = gnb_cu_cp_ue_e1ap_id.ok_or(PerCodecError::new(format!(
            "Missing mandatory IE gnb_cu_cp_ue_e1ap_id"
        )))?;
        let gnb_cu_up_ue_e1ap_id = gnb_cu_up_ue_e1ap_id.ok_or(PerCodecError::new(format!(
            "Missing mandatory IE gnb_cu_up_ue_e1ap_id"
        )))?;
        let system_gnb_cu_up_counter_check_request =
            system_gnb_cu_up_counter_check_request.ok_or(PerCodecError::new(format!(
                "Missing mandatory IE system_gnb_cu_up_counter_check_request"
            )))?;
        Ok(Self {
            gnb_cu_cp_ue_e1ap_id,
            gnb_cu_up_ue_e1ap_id,
            system_gnb_cu_up_counter_check_request,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        let ie = &mut Allocator::new_codec_data();
        self.gnb_cu_cp_ue_e1ap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 2, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.gnb_cu_up_ue_e1ap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 3, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.system_gnb_cu_up_counter_check_request.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 60, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        encode::encode_sequence_header(data, true, &BitString::new(), false)?;
        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for GnbCuUpCounterCheckRequest {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        GnbCuUpCounterCheckRequest::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("GnbCuUpCounterCheckRequest");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("GnbCuUpCounterCheckRequest");
            e
        })
    }
}
// SystemGnbCuUpCounterCheckRequest
#[derive(Clone, Debug)]
pub enum SystemGnbCuUpCounterCheckRequest {
    EutranGnbCuUpCounterCheckRequest(EutranGnbCuUpCounterCheckRequest),
    NgRanGnbCuUpCounterCheckRequest(NgRanGnbCuUpCounterCheckRequest),
}

impl SystemGnbCuUpCounterCheckRequest {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_choice_idx(data, 0, 2, false)?;
        if extended {
            return Err(PerCodecError::new("CHOICE additions not implemented"));
        }
        match idx {
            0 => Ok(Self::EutranGnbCuUpCounterCheckRequest(
                EutranGnbCuUpCounterCheckRequest::decode(data)?,
            )),
            1 => Ok(Self::NgRanGnbCuUpCounterCheckRequest(
                NgRanGnbCuUpCounterCheckRequest::decode(data)?,
            )),
            2 => {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _ = Criticality::decode(data)?;
                let _ = decode::decode_length_determinent(data, None, None, false)?;
                let result = match id {
                    x => Err(PerCodecError::new(format!("Unrecognised IE type {}", x))),
                };
                data.decode_align()?;
                result
            }
            _ => Err(PerCodecError::new("Unknown choice idx")),
        }
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        match self {
            Self::EutranGnbCuUpCounterCheckRequest(x) => {
                encode::encode_choice_idx(data, 0, 2, false, 0, false)?;
                x.encode(data)
            }
            Self::NgRanGnbCuUpCounterCheckRequest(x) => {
                encode::encode_choice_idx(data, 0, 2, false, 1, false)?;
                x.encode(data)
            }
        }
    }
}

impl PerCodec for SystemGnbCuUpCounterCheckRequest {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        SystemGnbCuUpCounterCheckRequest::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SystemGnbCuUpCounterCheckRequest");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SystemGnbCuUpCounterCheckRequest");
            e
        })
    }
}
// GnbCuUpStatusIndication
#[derive(Clone, Debug)]
pub struct GnbCuUpStatusIndication {
    pub transaction_id: TransactionId,
    pub gnb_cu_up_overload_information: GnbCuUpOverloadInformation,
}

impl GnbCuUpStatusIndication {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let _ = decode::decode_sequence_header(data, true, 0)?;
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut transaction_id: Option<TransactionId> = None;
        let mut gnb_cu_up_overload_information: Option<GnbCuUpOverloadInformation> = None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                57 => transaction_id = Some(TransactionId::decode(data)?),
                65 => {
                    gnb_cu_up_overload_information = Some(GnbCuUpOverloadInformation::decode(data)?)
                }
                x => return Err(PerCodecError::new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        let transaction_id = transaction_id.ok_or(PerCodecError::new(format!(
            "Missing mandatory IE transaction_id"
        )))?;
        let gnb_cu_up_overload_information =
            gnb_cu_up_overload_information.ok_or(PerCodecError::new(format!(
                "Missing mandatory IE gnb_cu_up_overload_information"
            )))?;
        Ok(Self {
            transaction_id,
            gnb_cu_up_overload_information,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        let ie = &mut Allocator::new_codec_data();
        self.transaction_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 57, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.gnb_cu_up_overload_information.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 65, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        encode::encode_sequence_header(data, true, &BitString::new(), false)?;
        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for GnbCuUpStatusIndication {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        GnbCuUpStatusIndication::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("GnbCuUpStatusIndication");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("GnbCuUpStatusIndication");
            e
        })
    }
}
// GnbCuCpMeasurementResultsInformation
#[derive(Clone, Debug)]
pub struct GnbCuCpMeasurementResultsInformation {
    pub gnb_cu_cp_ue_e1ap_id: GnbCuCpUeE1apId,
    pub gnb_cu_up_ue_e1ap_id: GnbCuUpUeE1apId,
    pub drb_measurement_results_information_list: DrbMeasurementResultsInformationList,
}

impl GnbCuCpMeasurementResultsInformation {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let _ = decode::decode_sequence_header(data, true, 0)?;
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut gnb_cu_cp_ue_e1ap_id: Option<GnbCuCpUeE1apId> = None;
        let mut gnb_cu_up_ue_e1ap_id: Option<GnbCuUpUeE1apId> = None;
        let mut drb_measurement_results_information_list: Option<
            DrbMeasurementResultsInformationList,
        > = None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                2 => gnb_cu_cp_ue_e1ap_id = Some(GnbCuCpUeE1apId::decode(data)?),
                3 => gnb_cu_up_ue_e1ap_id = Some(GnbCuUpUeE1apId::decode(data)?),
                128 => {
                    drb_measurement_results_information_list =
                        Some(DrbMeasurementResultsInformationList::decode(data)?)
                }
                x => return Err(PerCodecError::new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        let gnb_cu_cp_ue_e1ap_id = gnb_cu_cp_ue_e1ap_id.ok_or(PerCodecError::new(format!(
            "Missing mandatory IE gnb_cu_cp_ue_e1ap_id"
        )))?;
        let gnb_cu_up_ue_e1ap_id = gnb_cu_up_ue_e1ap_id.ok_or(PerCodecError::new(format!(
            "Missing mandatory IE gnb_cu_up_ue_e1ap_id"
        )))?;
        let drb_measurement_results_information_list = drb_measurement_results_information_list
            .ok_or(PerCodecError::new(format!(
                "Missing mandatory IE drb_measurement_results_information_list"
            )))?;
        Ok(Self {
            gnb_cu_cp_ue_e1ap_id,
            gnb_cu_up_ue_e1ap_id,
            drb_measurement_results_information_list,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        let ie = &mut Allocator::new_codec_data();
        self.gnb_cu_cp_ue_e1ap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 2, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.gnb_cu_up_ue_e1ap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 3, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.drb_measurement_results_information_list.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 128, false)?;
        Criticality::Ignore.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        encode::encode_sequence_header(data, true, &BitString::new(), false)?;
        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for GnbCuCpMeasurementResultsInformation {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        GnbCuCpMeasurementResultsInformation::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("GnbCuCpMeasurementResultsInformation");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("GnbCuCpMeasurementResultsInformation");
            e
        })
    }
}
// MrdcDataUsageReport
#[derive(Clone, Debug)]
pub struct MrdcDataUsageReport {
    pub gnb_cu_cp_ue_e1ap_id: GnbCuCpUeE1apId,
    pub gnb_cu_up_ue_e1ap_id: GnbCuUpUeE1apId,
    pub pdu_session_resource_data_usage_list: PduSessionResourceDataUsageList,
}

impl MrdcDataUsageReport {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let _ = decode::decode_sequence_header(data, true, 0)?;
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut gnb_cu_cp_ue_e1ap_id: Option<GnbCuCpUeE1apId> = None;
        let mut gnb_cu_up_ue_e1ap_id: Option<GnbCuUpUeE1apId> = None;
        let mut pdu_session_resource_data_usage_list: Option<PduSessionResourceDataUsageList> =
            None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                2 => gnb_cu_cp_ue_e1ap_id = Some(GnbCuCpUeE1apId::decode(data)?),
                3 => gnb_cu_up_ue_e1ap_id = Some(GnbCuUpUeE1apId::decode(data)?),
                68 => {
                    pdu_session_resource_data_usage_list =
                        Some(PduSessionResourceDataUsageList::decode(data)?)
                }
                x => return Err(PerCodecError::new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        let gnb_cu_cp_ue_e1ap_id = gnb_cu_cp_ue_e1ap_id.ok_or(PerCodecError::new(format!(
            "Missing mandatory IE gnb_cu_cp_ue_e1ap_id"
        )))?;
        let gnb_cu_up_ue_e1ap_id = gnb_cu_up_ue_e1ap_id.ok_or(PerCodecError::new(format!(
            "Missing mandatory IE gnb_cu_up_ue_e1ap_id"
        )))?;
        let pdu_session_resource_data_usage_list =
            pdu_session_resource_data_usage_list.ok_or(PerCodecError::new(format!(
                "Missing mandatory IE pdu_session_resource_data_usage_list"
            )))?;
        Ok(Self {
            gnb_cu_cp_ue_e1ap_id,
            gnb_cu_up_ue_e1ap_id,
            pdu_session_resource_data_usage_list,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        let ie = &mut Allocator::new_codec_data();
        self.gnb_cu_cp_ue_e1ap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 2, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.gnb_cu_up_ue_e1ap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 3, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.pdu_session_resource_data_usage_list.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 68, false)?;
        Criticality::Ignore.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        encode::encode_sequence_header(data, true, &BitString::new(), false)?;
        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for MrdcDataUsageReport {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        MrdcDataUsageReport::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MrdcDataUsageReport");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MrdcDataUsageReport");
            e
        })
    }
}
// TraceStart
#[derive(Clone, Debug)]
pub struct TraceStart {
    pub gnb_cu_cp_ue_e1ap_id: GnbCuCpUeE1apId,
    pub gnb_cu_up_ue_e1ap_id: GnbCuUpUeE1apId,
    pub trace_activation: TraceActivation,
}

impl TraceStart {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let _ = decode::decode_sequence_header(data, true, 0)?;
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut gnb_cu_cp_ue_e1ap_id: Option<GnbCuCpUeE1apId> = None;
        let mut gnb_cu_up_ue_e1ap_id: Option<GnbCuUpUeE1apId> = None;
        let mut trace_activation: Option<TraceActivation> = None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                2 => gnb_cu_cp_ue_e1ap_id = Some(GnbCuCpUeE1apId::decode(data)?),
                3 => gnb_cu_up_ue_e1ap_id = Some(GnbCuUpUeE1apId::decode(data)?),
                81 => trace_activation = Some(TraceActivation::decode(data)?),
                x => return Err(PerCodecError::new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        let gnb_cu_cp_ue_e1ap_id = gnb_cu_cp_ue_e1ap_id.ok_or(PerCodecError::new(format!(
            "Missing mandatory IE gnb_cu_cp_ue_e1ap_id"
        )))?;
        let gnb_cu_up_ue_e1ap_id = gnb_cu_up_ue_e1ap_id.ok_or(PerCodecError::new(format!(
            "Missing mandatory IE gnb_cu_up_ue_e1ap_id"
        )))?;
        let trace_activation = trace_activation.ok_or(PerCodecError::new(format!(
            "Missing mandatory IE trace_activation"
        )))?;
        Ok(Self {
            gnb_cu_cp_ue_e1ap_id,
            gnb_cu_up_ue_e1ap_id,
            trace_activation,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        let ie = &mut Allocator::new_codec_data();
        self.gnb_cu_cp_ue_e1ap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 2, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.gnb_cu_up_ue_e1ap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 3, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.trace_activation.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 81, false)?;
        Criticality::Ignore.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        encode::encode_sequence_header(data, true, &BitString::new(), false)?;
        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for TraceStart {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        TraceStart::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TraceStart");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TraceStart");
            e
        })
    }
}
// DeactivateTrace
#[derive(Clone, Debug)]
pub struct DeactivateTrace {
    pub gnb_cu_cp_ue_e1ap_id: GnbCuCpUeE1apId,
    pub gnb_cu_up_ue_e1ap_id: GnbCuUpUeE1apId,
    pub trace_id: TraceId,
}

impl DeactivateTrace {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let _ = decode::decode_sequence_header(data, true, 0)?;
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut gnb_cu_cp_ue_e1ap_id: Option<GnbCuCpUeE1apId> = None;
        let mut gnb_cu_up_ue_e1ap_id: Option<GnbCuUpUeE1apId> = None;
        let mut trace_id: Option<TraceId> = None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                2 => gnb_cu_cp_ue_e1ap_id = Some(GnbCuCpUeE1apId::decode(data)?),
                3 => gnb_cu_up_ue_e1ap_id = Some(GnbCuUpUeE1apId::decode(data)?),
                82 => trace_id = Some(TraceId::decode(data)?),
                x => return Err(PerCodecError::new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        let gnb_cu_cp_ue_e1ap_id = gnb_cu_cp_ue_e1ap_id.ok_or(PerCodecError::new(format!(
            "Missing mandatory IE gnb_cu_cp_ue_e1ap_id"
        )))?;
        let gnb_cu_up_ue_e1ap_id = gnb_cu_up_ue_e1ap_id.ok_or(PerCodecError::new(format!(
            "Missing mandatory IE gnb_cu_up_ue_e1ap_id"
        )))?;
        let trace_id =
            trace_id.ok_or(PerCodecError::new(format!("Missing mandatory IE trace_id")))?;
        Ok(Self {
            gnb_cu_cp_ue_e1ap_id,
            gnb_cu_up_ue_e1ap_id,
            trace_id,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        let ie = &mut Allocator::new_codec_data();
        self.gnb_cu_cp_ue_e1ap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 2, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.gnb_cu_up_ue_e1ap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 3, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.trace_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 82, false)?;
        Criticality::Ignore.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        encode::encode_sequence_header(data, true, &BitString::new(), false)?;
        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for DeactivateTrace {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        DeactivateTrace::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DeactivateTrace");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DeactivateTrace");
            e
        })
    }
}
// CellTrafficTrace
#[derive(Clone, Debug)]
pub struct CellTrafficTrace {
    pub gnb_cu_cp_ue_e1ap_id: GnbCuCpUeE1apId,
    pub gnb_cu_up_ue_e1ap_id: GnbCuUpUeE1apId,
    pub trace_id: TraceId,
    pub trace_collection_entity_ip_address: TransportLayerAddress,
    pub privacy_indicator: Option<PrivacyIndicator>,
    pub ur_iaddress: Option<UrIaddress>,
}

impl CellTrafficTrace {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let _ = decode::decode_sequence_header(data, true, 0)?;
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut gnb_cu_cp_ue_e1ap_id: Option<GnbCuCpUeE1apId> = None;
        let mut gnb_cu_up_ue_e1ap_id: Option<GnbCuUpUeE1apId> = None;
        let mut trace_id: Option<TraceId> = None;
        let mut trace_collection_entity_ip_address: Option<TransportLayerAddress> = None;
        let mut privacy_indicator: Option<PrivacyIndicator> = None;
        let mut ur_iaddress: Option<UrIaddress> = None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                2 => gnb_cu_cp_ue_e1ap_id = Some(GnbCuCpUeE1apId::decode(data)?),
                3 => gnb_cu_up_ue_e1ap_id = Some(GnbCuUpUeE1apId::decode(data)?),
                82 => trace_id = Some(TraceId::decode(data)?),
                114 => {
                    trace_collection_entity_ip_address = Some(TransportLayerAddress::decode(data)?)
                }
                115 => privacy_indicator = Some(PrivacyIndicator::decode(data)?),
                117 => ur_iaddress = Some(UrIaddress::decode(data)?),
                x => return Err(PerCodecError::new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        let gnb_cu_cp_ue_e1ap_id = gnb_cu_cp_ue_e1ap_id.ok_or(PerCodecError::new(format!(
            "Missing mandatory IE gnb_cu_cp_ue_e1ap_id"
        )))?;
        let gnb_cu_up_ue_e1ap_id = gnb_cu_up_ue_e1ap_id.ok_or(PerCodecError::new(format!(
            "Missing mandatory IE gnb_cu_up_ue_e1ap_id"
        )))?;
        let trace_id =
            trace_id.ok_or(PerCodecError::new(format!("Missing mandatory IE trace_id")))?;
        let trace_collection_entity_ip_address =
            trace_collection_entity_ip_address.ok_or(PerCodecError::new(format!(
                "Missing mandatory IE trace_collection_entity_ip_address"
            )))?;
        Ok(Self {
            gnb_cu_cp_ue_e1ap_id,
            gnb_cu_up_ue_e1ap_id,
            trace_id,
            trace_collection_entity_ip_address,
            privacy_indicator,
            ur_iaddress,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        let ie = &mut Allocator::new_codec_data();
        self.gnb_cu_cp_ue_e1ap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 2, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.gnb_cu_up_ue_e1ap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 3, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.trace_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 82, false)?;
        Criticality::Ignore.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.trace_collection_entity_ip_address.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 114, false)?;
        Criticality::Ignore.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        if let Some(x) = &self.privacy_indicator {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 115, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.ur_iaddress {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 117, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        encode::encode_sequence_header(data, true, &BitString::new(), false)?;
        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for CellTrafficTrace {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        CellTrafficTrace::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CellTrafficTrace");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CellTrafficTrace");
            e
        })
    }
}
// PrivateMessage
#[derive(Clone, Debug)]
pub struct PrivateMessage {}

impl PrivateMessage {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (_optionals, _extensions_present) = decode::decode_sequence_header(data, true, 0)?;

        Ok(Self {})
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let optionals = BitString::new();

        encode::encode_sequence_header(data, true, &optionals, false)?;

        Ok(())
    }
}

impl PerCodec for PrivateMessage {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PrivateMessage::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PrivateMessage");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PrivateMessage");
            e
        })
    }
}
// ResourceStatusRequest
#[derive(Clone, Debug)]
pub struct ResourceStatusRequest {
    pub transaction_id: TransactionId,
    pub gnb_cu_cp_measurement_id: u16,
    pub gnb_cu_up_measurement_id: Option<u16>,
    pub registration_request: RegistrationRequest,
    pub report_characteristics: Option<ReportCharacteristics>,
    pub reporting_periodicity: Option<ReportingPeriodicity>,
}

impl ResourceStatusRequest {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let _ = decode::decode_sequence_header(data, true, 0)?;
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut transaction_id: Option<TransactionId> = None;
        let mut gnb_cu_cp_measurement_id: Option<u16> = None;
        let mut gnb_cu_up_measurement_id: Option<u16> = None;
        let mut registration_request: Option<RegistrationRequest> = None;
        let mut report_characteristics: Option<ReportCharacteristics> = None;
        let mut reporting_periodicity: Option<ReportingPeriodicity> = None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                57 => transaction_id = Some(TransactionId::decode(data)?),
                89 => {
                    gnb_cu_cp_measurement_id =
                        Some(decode::decode_integer(data, Some(1), Some(4095), true)?.0 as u16)
                }
                90 => {
                    gnb_cu_up_measurement_id =
                        Some(decode::decode_integer(data, Some(1), Some(4095), true)?.0 as u16)
                }
                91 => registration_request = Some(RegistrationRequest::decode(data)?),
                92 => report_characteristics = Some(ReportCharacteristics::decode(data)?),
                93 => reporting_periodicity = Some(ReportingPeriodicity::decode(data)?),
                x => return Err(PerCodecError::new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        let transaction_id = transaction_id.ok_or(PerCodecError::new(format!(
            "Missing mandatory IE transaction_id"
        )))?;
        let gnb_cu_cp_measurement_id = gnb_cu_cp_measurement_id.ok_or(PerCodecError::new(
            format!("Missing mandatory IE gnb_cu_cp_measurement_id"),
        ))?;
        let registration_request = registration_request.ok_or(PerCodecError::new(format!(
            "Missing mandatory IE registration_request"
        )))?;
        Ok(Self {
            transaction_id,
            gnb_cu_cp_measurement_id,
            gnb_cu_up_measurement_id,
            registration_request,
            report_characteristics,
            reporting_periodicity,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        let ie = &mut Allocator::new_codec_data();
        self.transaction_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 57, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        encode::encode_integer(
            ie,
            Some(1),
            Some(4095),
            true,
            self.gnb_cu_cp_measurement_id as i128,
            false,
        )?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 89, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        if let Some(x) = &self.gnb_cu_up_measurement_id {
            let ie = &mut Allocator::new_codec_data();
            encode::encode_integer(ie, Some(1), Some(4095), true, *x as i128, false)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 90, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        let ie = &mut Allocator::new_codec_data();
        self.registration_request.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 91, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        if let Some(x) = &self.report_characteristics {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 92, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.reporting_periodicity {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 93, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        encode::encode_sequence_header(data, true, &BitString::new(), false)?;
        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for ResourceStatusRequest {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        ResourceStatusRequest::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ResourceStatusRequest");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ResourceStatusRequest");
            e
        })
    }
}
// ResourceStatusResponse
#[derive(Clone, Debug)]
pub struct ResourceStatusResponse {
    pub transaction_id: TransactionId,
    pub gnb_cu_cp_measurement_id: u16,
    pub gnb_cu_up_measurement_id: u16,
    pub criticality_diagnostics: Option<CriticalityDiagnostics>,
}

impl ResourceStatusResponse {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let _ = decode::decode_sequence_header(data, true, 0)?;
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut transaction_id: Option<TransactionId> = None;
        let mut gnb_cu_cp_measurement_id: Option<u16> = None;
        let mut gnb_cu_up_measurement_id: Option<u16> = None;
        let mut criticality_diagnostics: Option<CriticalityDiagnostics> = None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                57 => transaction_id = Some(TransactionId::decode(data)?),
                89 => {
                    gnb_cu_cp_measurement_id =
                        Some(decode::decode_integer(data, Some(1), Some(4095), true)?.0 as u16)
                }
                90 => {
                    gnb_cu_up_measurement_id =
                        Some(decode::decode_integer(data, Some(1), Some(4095), true)?.0 as u16)
                }
                1 => criticality_diagnostics = Some(CriticalityDiagnostics::decode(data)?),
                x => return Err(PerCodecError::new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        let transaction_id = transaction_id.ok_or(PerCodecError::new(format!(
            "Missing mandatory IE transaction_id"
        )))?;
        let gnb_cu_cp_measurement_id = gnb_cu_cp_measurement_id.ok_or(PerCodecError::new(
            format!("Missing mandatory IE gnb_cu_cp_measurement_id"),
        ))?;
        let gnb_cu_up_measurement_id = gnb_cu_up_measurement_id.ok_or(PerCodecError::new(
            format!("Missing mandatory IE gnb_cu_up_measurement_id"),
        ))?;
        Ok(Self {
            transaction_id,
            gnb_cu_cp_measurement_id,
            gnb_cu_up_measurement_id,
            criticality_diagnostics,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        let ie = &mut Allocator::new_codec_data();
        self.transaction_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 57, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        encode::encode_integer(
            ie,
            Some(1),
            Some(4095),
            true,
            self.gnb_cu_cp_measurement_id as i128,
            false,
        )?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 89, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        encode::encode_integer(
            ie,
            Some(1),
            Some(4095),
            true,
            self.gnb_cu_up_measurement_id as i128,
            false,
        )?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 90, false)?;
        Criticality::Ignore.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        if let Some(x) = &self.criticality_diagnostics {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 1, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        encode::encode_sequence_header(data, true, &BitString::new(), false)?;
        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for ResourceStatusResponse {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        ResourceStatusResponse::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ResourceStatusResponse");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ResourceStatusResponse");
            e
        })
    }
}
// ResourceStatusFailure
#[derive(Clone, Debug)]
pub struct ResourceStatusFailure {
    pub transaction_id: TransactionId,
    pub gnb_cu_cp_measurement_id: u16,
    pub gnb_cu_up_measurement_id: Option<u16>,
    pub cause: Cause,
    pub criticality_diagnostics: Option<CriticalityDiagnostics>,
}

impl ResourceStatusFailure {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let _ = decode::decode_sequence_header(data, true, 0)?;
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut transaction_id: Option<TransactionId> = None;
        let mut gnb_cu_cp_measurement_id: Option<u16> = None;
        let mut gnb_cu_up_measurement_id: Option<u16> = None;
        let mut cause: Option<Cause> = None;
        let mut criticality_diagnostics: Option<CriticalityDiagnostics> = None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                57 => transaction_id = Some(TransactionId::decode(data)?),
                89 => {
                    gnb_cu_cp_measurement_id =
                        Some(decode::decode_integer(data, Some(1), Some(4095), true)?.0 as u16)
                }
                90 => {
                    gnb_cu_up_measurement_id =
                        Some(decode::decode_integer(data, Some(1), Some(4095), true)?.0 as u16)
                }
                0 => cause = Some(Cause::decode(data)?),
                1 => criticality_diagnostics = Some(CriticalityDiagnostics::decode(data)?),
                x => return Err(PerCodecError::new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        let transaction_id = transaction_id.ok_or(PerCodecError::new(format!(
            "Missing mandatory IE transaction_id"
        )))?;
        let gnb_cu_cp_measurement_id = gnb_cu_cp_measurement_id.ok_or(PerCodecError::new(
            format!("Missing mandatory IE gnb_cu_cp_measurement_id"),
        ))?;
        let cause = cause.ok_or(PerCodecError::new(format!("Missing mandatory IE cause")))?;
        Ok(Self {
            transaction_id,
            gnb_cu_cp_measurement_id,
            gnb_cu_up_measurement_id,
            cause,
            criticality_diagnostics,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        let ie = &mut Allocator::new_codec_data();
        self.transaction_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 57, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        encode::encode_integer(
            ie,
            Some(1),
            Some(4095),
            true,
            self.gnb_cu_cp_measurement_id as i128,
            false,
        )?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 89, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        if let Some(x) = &self.gnb_cu_up_measurement_id {
            let ie = &mut Allocator::new_codec_data();
            encode::encode_integer(ie, Some(1), Some(4095), true, *x as i128, false)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 90, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        let ie = &mut Allocator::new_codec_data();
        self.cause.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 0, false)?;
        Criticality::Ignore.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        if let Some(x) = &self.criticality_diagnostics {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 1, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        encode::encode_sequence_header(data, true, &BitString::new(), false)?;
        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for ResourceStatusFailure {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        ResourceStatusFailure::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ResourceStatusFailure");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ResourceStatusFailure");
            e
        })
    }
}
// ResourceStatusUpdate
#[derive(Clone, Debug)]
pub struct ResourceStatusUpdate {
    pub transaction_id: TransactionId,
    pub gnb_cu_cp_measurement_id: u16,
    pub gnb_cu_up_measurement_id: Option<u16>,
    pub tnl_available_capacity_indicator: Option<TnlAvailableCapacityIndicator>,
    pub hw_capacity_indicator: HwCapacityIndicator,
}

impl ResourceStatusUpdate {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let _ = decode::decode_sequence_header(data, true, 0)?;
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut transaction_id: Option<TransactionId> = None;
        let mut gnb_cu_cp_measurement_id: Option<u16> = None;
        let mut gnb_cu_up_measurement_id: Option<u16> = None;
        let mut tnl_available_capacity_indicator: Option<TnlAvailableCapacityIndicator> = None;
        let mut hw_capacity_indicator: Option<HwCapacityIndicator> = None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                57 => transaction_id = Some(TransactionId::decode(data)?),
                89 => {
                    gnb_cu_cp_measurement_id =
                        Some(decode::decode_integer(data, Some(1), Some(4095), true)?.0 as u16)
                }
                90 => {
                    gnb_cu_up_measurement_id =
                        Some(decode::decode_integer(data, Some(1), Some(4095), true)?.0 as u16)
                }
                94 => {
                    tnl_available_capacity_indicator =
                        Some(TnlAvailableCapacityIndicator::decode(data)?)
                }
                95 => hw_capacity_indicator = Some(HwCapacityIndicator::decode(data)?),
                x => return Err(PerCodecError::new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        let transaction_id = transaction_id.ok_or(PerCodecError::new(format!(
            "Missing mandatory IE transaction_id"
        )))?;
        let gnb_cu_cp_measurement_id = gnb_cu_cp_measurement_id.ok_or(PerCodecError::new(
            format!("Missing mandatory IE gnb_cu_cp_measurement_id"),
        ))?;
        let hw_capacity_indicator = hw_capacity_indicator.ok_or(PerCodecError::new(format!(
            "Missing mandatory IE hw_capacity_indicator"
        )))?;
        Ok(Self {
            transaction_id,
            gnb_cu_cp_measurement_id,
            gnb_cu_up_measurement_id,
            tnl_available_capacity_indicator,
            hw_capacity_indicator,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        let ie = &mut Allocator::new_codec_data();
        self.transaction_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 57, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        encode::encode_integer(
            ie,
            Some(1),
            Some(4095),
            true,
            self.gnb_cu_cp_measurement_id as i128,
            false,
        )?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 89, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        if let Some(x) = &self.gnb_cu_up_measurement_id {
            let ie = &mut Allocator::new_codec_data();
            encode::encode_integer(ie, Some(1), Some(4095), true, *x as i128, false)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 90, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.tnl_available_capacity_indicator {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 94, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        let ie = &mut Allocator::new_codec_data();
        self.hw_capacity_indicator.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 95, false)?;
        Criticality::Ignore.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        encode::encode_sequence_header(data, true, &BitString::new(), false)?;
        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for ResourceStatusUpdate {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        ResourceStatusUpdate::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ResourceStatusUpdate");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ResourceStatusUpdate");
            e
        })
    }
}
// IabUpTnlAddressUpdate
#[derive(Clone, Debug)]
pub struct IabUpTnlAddressUpdate {
    pub transaction_id: TransactionId,
    pub dl_up_tnl_address_to_update_list: Option<DlUpTnlAddressToUpdateList>,
}

impl IabUpTnlAddressUpdate {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let _ = decode::decode_sequence_header(data, true, 0)?;
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut transaction_id: Option<TransactionId> = None;
        let mut dl_up_tnl_address_to_update_list: Option<DlUpTnlAddressToUpdateList> = None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                57 => transaction_id = Some(TransactionId::decode(data)?),
                108 => {
                    dl_up_tnl_address_to_update_list =
                        Some(DlUpTnlAddressToUpdateList::decode(data)?)
                }
                x => return Err(PerCodecError::new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        let transaction_id = transaction_id.ok_or(PerCodecError::new(format!(
            "Missing mandatory IE transaction_id"
        )))?;
        Ok(Self {
            transaction_id,
            dl_up_tnl_address_to_update_list,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        let ie = &mut Allocator::new_codec_data();
        self.transaction_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 57, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        if let Some(x) = &self.dl_up_tnl_address_to_update_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 108, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        encode::encode_sequence_header(data, true, &BitString::new(), false)?;
        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for IabUpTnlAddressUpdate {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        IabUpTnlAddressUpdate::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("IabUpTnlAddressUpdate");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("IabUpTnlAddressUpdate");
            e
        })
    }
}
// DlUpTnlAddressToUpdateList
#[derive(Clone, Debug)]
pub struct DlUpTnlAddressToUpdateList(pub NonEmpty<DlUpTnlAddressToUpdateItem>);

impl DlUpTnlAddressToUpdateList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(8), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(DlUpTnlAddressToUpdateItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(8), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for DlUpTnlAddressToUpdateList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        DlUpTnlAddressToUpdateList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DlUpTnlAddressToUpdateList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DlUpTnlAddressToUpdateList");
            e
        })
    }
}
// IabUpTnlAddressUpdateAcknowledge
#[derive(Clone, Debug)]
pub struct IabUpTnlAddressUpdateAcknowledge {
    pub transaction_id: TransactionId,
    pub criticality_diagnostics: Option<CriticalityDiagnostics>,
    pub ul_up_tnl_address_to_update_list: Option<UlUpTnlAddressToUpdateList>,
}

impl IabUpTnlAddressUpdateAcknowledge {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let _ = decode::decode_sequence_header(data, true, 0)?;
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut transaction_id: Option<TransactionId> = None;
        let mut criticality_diagnostics: Option<CriticalityDiagnostics> = None;
        let mut ul_up_tnl_address_to_update_list: Option<UlUpTnlAddressToUpdateList> = None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                57 => transaction_id = Some(TransactionId::decode(data)?),
                1 => criticality_diagnostics = Some(CriticalityDiagnostics::decode(data)?),
                109 => {
                    ul_up_tnl_address_to_update_list =
                        Some(UlUpTnlAddressToUpdateList::decode(data)?)
                }
                x => return Err(PerCodecError::new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        let transaction_id = transaction_id.ok_or(PerCodecError::new(format!(
            "Missing mandatory IE transaction_id"
        )))?;
        Ok(Self {
            transaction_id,
            criticality_diagnostics,
            ul_up_tnl_address_to_update_list,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        let ie = &mut Allocator::new_codec_data();
        self.transaction_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 57, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        if let Some(x) = &self.criticality_diagnostics {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 1, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.ul_up_tnl_address_to_update_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 109, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        encode::encode_sequence_header(data, true, &BitString::new(), false)?;
        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for IabUpTnlAddressUpdateAcknowledge {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        IabUpTnlAddressUpdateAcknowledge::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("IabUpTnlAddressUpdateAcknowledge");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("IabUpTnlAddressUpdateAcknowledge");
            e
        })
    }
}
// UlUpTnlAddressToUpdateList
#[derive(Clone, Debug)]
pub struct UlUpTnlAddressToUpdateList(pub NonEmpty<UlUpTnlAddressToUpdateItem>);

impl UlUpTnlAddressToUpdateList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(8), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(UlUpTnlAddressToUpdateItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(8), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for UlUpTnlAddressToUpdateList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        UlUpTnlAddressToUpdateList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UlUpTnlAddressToUpdateList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UlUpTnlAddressToUpdateList");
            e
        })
    }
}
// IabUpTnlAddressUpdateFailure
#[derive(Clone, Debug)]
pub struct IabUpTnlAddressUpdateFailure {
    pub transaction_id: TransactionId,
    pub cause: Cause,
    pub time_to_wait: Option<TimeToWait>,
    pub criticality_diagnostics: Option<CriticalityDiagnostics>,
}

impl IabUpTnlAddressUpdateFailure {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let _ = decode::decode_sequence_header(data, true, 0)?;
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut transaction_id: Option<TransactionId> = None;
        let mut cause: Option<Cause> = None;
        let mut time_to_wait: Option<TimeToWait> = None;
        let mut criticality_diagnostics: Option<CriticalityDiagnostics> = None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                57 => transaction_id = Some(TransactionId::decode(data)?),
                0 => cause = Some(Cause::decode(data)?),
                12 => time_to_wait = Some(TimeToWait::decode(data)?),
                1 => criticality_diagnostics = Some(CriticalityDiagnostics::decode(data)?),
                x => return Err(PerCodecError::new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        let transaction_id = transaction_id.ok_or(PerCodecError::new(format!(
            "Missing mandatory IE transaction_id"
        )))?;
        let cause = cause.ok_or(PerCodecError::new(format!("Missing mandatory IE cause")))?;
        Ok(Self {
            transaction_id,
            cause,
            time_to_wait,
            criticality_diagnostics,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        let ie = &mut Allocator::new_codec_data();
        self.transaction_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 57, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.cause.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 0, false)?;
        Criticality::Ignore.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        if let Some(x) = &self.time_to_wait {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 12, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.criticality_diagnostics {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 1, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        encode::encode_sequence_header(data, true, &BitString::new(), false)?;
        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for IabUpTnlAddressUpdateFailure {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        IabUpTnlAddressUpdateFailure::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("IabUpTnlAddressUpdateFailure");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("IabUpTnlAddressUpdateFailure");
            e
        })
    }
}
// EarlyForwardingSnTransfer
#[derive(Clone, Debug)]
pub struct EarlyForwardingSnTransfer {
    pub gnb_cu_cp_ue_e1ap_id: GnbCuCpUeE1apId,
    pub gnb_cu_up_ue_e1ap_id: GnbCuUpUeE1apId,
    pub drbs_subject_to_early_forwarding_list: DrbsSubjectToEarlyForwardingList,
}

impl EarlyForwardingSnTransfer {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let _ = decode::decode_sequence_header(data, true, 0)?;
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut gnb_cu_cp_ue_e1ap_id: Option<GnbCuCpUeE1apId> = None;
        let mut gnb_cu_up_ue_e1ap_id: Option<GnbCuUpUeE1apId> = None;
        let mut drbs_subject_to_early_forwarding_list: Option<DrbsSubjectToEarlyForwardingList> =
            None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                2 => gnb_cu_cp_ue_e1ap_id = Some(GnbCuCpUeE1apId::decode(data)?),
                3 => gnb_cu_up_ue_e1ap_id = Some(GnbCuUpUeE1apId::decode(data)?),
                119 => {
                    drbs_subject_to_early_forwarding_list =
                        Some(DrbsSubjectToEarlyForwardingList::decode(data)?)
                }
                x => return Err(PerCodecError::new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        let gnb_cu_cp_ue_e1ap_id = gnb_cu_cp_ue_e1ap_id.ok_or(PerCodecError::new(format!(
            "Missing mandatory IE gnb_cu_cp_ue_e1ap_id"
        )))?;
        let gnb_cu_up_ue_e1ap_id = gnb_cu_up_ue_e1ap_id.ok_or(PerCodecError::new(format!(
            "Missing mandatory IE gnb_cu_up_ue_e1ap_id"
        )))?;
        let drbs_subject_to_early_forwarding_list =
            drbs_subject_to_early_forwarding_list.ok_or(PerCodecError::new(format!(
                "Missing mandatory IE drbs_subject_to_early_forwarding_list"
            )))?;
        Ok(Self {
            gnb_cu_cp_ue_e1ap_id,
            gnb_cu_up_ue_e1ap_id,
            drbs_subject_to_early_forwarding_list,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        let ie = &mut Allocator::new_codec_data();
        self.gnb_cu_cp_ue_e1ap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 2, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.gnb_cu_up_ue_e1ap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 3, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.drbs_subject_to_early_forwarding_list.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 119, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        encode::encode_sequence_header(data, true, &BitString::new(), false)?;
        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for EarlyForwardingSnTransfer {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        EarlyForwardingSnTransfer::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("EarlyForwardingSnTransfer");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("EarlyForwardingSnTransfer");
            e
        })
    }
}
// EutranBearerContextSetupRequest
#[derive(Clone, Debug)]
pub struct EutranBearerContextSetupRequest {
    pub drb_to_setup_list_eutran: DrbToSetupListEutran,
    pub subscriber_profile_i_dfor_rfp: Option<SubscriberProfileIDforRfp>,
    pub additional_rrm_priority_index: Option<AdditionalRrmPriorityIndex>,
}

impl EutranBearerContextSetupRequest {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut drb_to_setup_list_eutran: Option<DrbToSetupListEutran> = None;
        let mut subscriber_profile_i_dfor_rfp: Option<SubscriberProfileIDforRfp> = None;
        let mut additional_rrm_priority_index: Option<AdditionalRrmPriorityIndex> = None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                32 => drb_to_setup_list_eutran = Some(DrbToSetupListEutran::decode(data)?),
                83 => {
                    subscriber_profile_i_dfor_rfp = Some(SubscriberProfileIDforRfp::decode(data)?)
                }
                84 => {
                    additional_rrm_priority_index = Some(AdditionalRrmPriorityIndex::decode(data)?)
                }
                x => return Err(PerCodecError::new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        let drb_to_setup_list_eutran = drb_to_setup_list_eutran.ok_or(PerCodecError::new(
            format!("Missing mandatory IE drb_to_setup_list_eutran"),
        ))?;
        Ok(Self {
            drb_to_setup_list_eutran,
            subscriber_profile_i_dfor_rfp,
            additional_rrm_priority_index,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        let ie = &mut Allocator::new_codec_data();
        self.drb_to_setup_list_eutran.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 32, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        if let Some(x) = &self.subscriber_profile_i_dfor_rfp {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 83, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.additional_rrm_priority_index {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 84, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for EutranBearerContextSetupRequest {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        EutranBearerContextSetupRequest::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("EutranBearerContextSetupRequest");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("EutranBearerContextSetupRequest");
            e
        })
    }
}
// NgRanBearerContextSetupRequest
#[derive(Clone, Debug)]
pub struct NgRanBearerContextSetupRequest {
    pub pdu_session_resource_to_setup_list: PduSessionResourceToSetupList,
}

impl NgRanBearerContextSetupRequest {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut pdu_session_resource_to_setup_list: Option<PduSessionResourceToSetupList> = None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                42 => {
                    pdu_session_resource_to_setup_list =
                        Some(PduSessionResourceToSetupList::decode(data)?)
                }
                x => return Err(PerCodecError::new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        let pdu_session_resource_to_setup_list =
            pdu_session_resource_to_setup_list.ok_or(PerCodecError::new(format!(
                "Missing mandatory IE pdu_session_resource_to_setup_list"
            )))?;
        Ok(Self {
            pdu_session_resource_to_setup_list,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        let ie = &mut Allocator::new_codec_data();
        self.pdu_session_resource_to_setup_list.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 42, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for NgRanBearerContextSetupRequest {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        NgRanBearerContextSetupRequest::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NgRanBearerContextSetupRequest");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NgRanBearerContextSetupRequest");
            e
        })
    }
}
// EutranBearerContextSetupResponse
#[derive(Clone, Debug)]
pub struct EutranBearerContextSetupResponse {
    pub drb_setup_list_eutran: DrbSetupListEutran,
    pub drb_failed_list_eutran: Option<DrbFailedListEutran>,
}

impl EutranBearerContextSetupResponse {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut drb_setup_list_eutran: Option<DrbSetupListEutran> = None;
        let mut drb_failed_list_eutran: Option<DrbFailedListEutran> = None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                37 => drb_setup_list_eutran = Some(DrbSetupListEutran::decode(data)?),
                38 => drb_failed_list_eutran = Some(DrbFailedListEutran::decode(data)?),
                x => return Err(PerCodecError::new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        let drb_setup_list_eutran = drb_setup_list_eutran.ok_or(PerCodecError::new(format!(
            "Missing mandatory IE drb_setup_list_eutran"
        )))?;
        Ok(Self {
            drb_setup_list_eutran,
            drb_failed_list_eutran,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        let ie = &mut Allocator::new_codec_data();
        self.drb_setup_list_eutran.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 37, false)?;
        Criticality::Ignore.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        if let Some(x) = &self.drb_failed_list_eutran {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 38, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for EutranBearerContextSetupResponse {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        EutranBearerContextSetupResponse::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("EutranBearerContextSetupResponse");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("EutranBearerContextSetupResponse");
            e
        })
    }
}
// NgRanBearerContextSetupResponse
#[derive(Clone, Debug)]
pub struct NgRanBearerContextSetupResponse {
    pub pdu_session_resource_setup_list: PduSessionResourceSetupList,
    pub pdu_session_resource_failed_list: Option<PduSessionResourceFailedList>,
}

impl NgRanBearerContextSetupResponse {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut pdu_session_resource_setup_list: Option<PduSessionResourceSetupList> = None;
        let mut pdu_session_resource_failed_list: Option<PduSessionResourceFailedList> = None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                46 => {
                    pdu_session_resource_setup_list =
                        Some(PduSessionResourceSetupList::decode(data)?)
                }
                47 => {
                    pdu_session_resource_failed_list =
                        Some(PduSessionResourceFailedList::decode(data)?)
                }
                x => return Err(PerCodecError::new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        let pdu_session_resource_setup_list =
            pdu_session_resource_setup_list.ok_or(PerCodecError::new(format!(
                "Missing mandatory IE pdu_session_resource_setup_list"
            )))?;
        Ok(Self {
            pdu_session_resource_setup_list,
            pdu_session_resource_failed_list,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        let ie = &mut Allocator::new_codec_data();
        self.pdu_session_resource_setup_list.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 46, false)?;
        Criticality::Ignore.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        if let Some(x) = &self.pdu_session_resource_failed_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 47, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for NgRanBearerContextSetupResponse {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        NgRanBearerContextSetupResponse::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NgRanBearerContextSetupResponse");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NgRanBearerContextSetupResponse");
            e
        })
    }
}
// EutranBearerContextModificationRequest
#[derive(Clone, Debug)]
pub struct EutranBearerContextModificationRequest {
    pub drb_to_setup_mod_list_eutran: Option<DrbToSetupModListEutran>,
    pub drb_to_modify_list_eutran: Option<DrbToModifyListEutran>,
    pub drb_to_remove_list_eutran: Option<DrbToRemoveListEutran>,
    pub subscriber_profile_i_dfor_rfp: Option<SubscriberProfileIDforRfp>,
    pub additional_rrm_priority_index: Option<AdditionalRrmPriorityIndex>,
}

impl EutranBearerContextModificationRequest {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut drb_to_setup_mod_list_eutran: Option<DrbToSetupModListEutran> = None;
        let mut drb_to_modify_list_eutran: Option<DrbToModifyListEutran> = None;
        let mut drb_to_remove_list_eutran: Option<DrbToRemoveListEutran> = None;
        let mut subscriber_profile_i_dfor_rfp: Option<SubscriberProfileIDforRfp> = None;
        let mut additional_rrm_priority_index: Option<AdditionalRrmPriorityIndex> = None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                51 => drb_to_setup_mod_list_eutran = Some(DrbToSetupModListEutran::decode(data)?),
                33 => drb_to_modify_list_eutran = Some(DrbToModifyListEutran::decode(data)?),
                34 => drb_to_remove_list_eutran = Some(DrbToRemoveListEutran::decode(data)?),
                83 => {
                    subscriber_profile_i_dfor_rfp = Some(SubscriberProfileIDforRfp::decode(data)?)
                }
                84 => {
                    additional_rrm_priority_index = Some(AdditionalRrmPriorityIndex::decode(data)?)
                }
                x => return Err(PerCodecError::new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        Ok(Self {
            drb_to_setup_mod_list_eutran,
            drb_to_modify_list_eutran,
            drb_to_remove_list_eutran,
            subscriber_profile_i_dfor_rfp,
            additional_rrm_priority_index,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        if let Some(x) = &self.drb_to_setup_mod_list_eutran {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 51, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.drb_to_modify_list_eutran {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 33, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.drb_to_remove_list_eutran {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 34, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.subscriber_profile_i_dfor_rfp {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 83, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.additional_rrm_priority_index {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 84, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for EutranBearerContextModificationRequest {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        EutranBearerContextModificationRequest::decode_inner(data).map_err(
            |mut e: PerCodecError| {
                e.push_context("EutranBearerContextModificationRequest");
                e
            },
        )
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("EutranBearerContextModificationRequest");
            e
        })
    }
}
// NgRanBearerContextModificationRequest
#[derive(Clone, Debug)]
pub struct NgRanBearerContextModificationRequest {
    pub pdu_session_resource_to_setup_mod_list: Option<PduSessionResourceToSetupModList>,
    pub pdu_session_resource_to_modify_list: Option<PduSessionResourceToModifyList>,
    pub pdu_session_resource_to_remove_list: Option<PduSessionResourceToRemoveList>,
}

impl NgRanBearerContextModificationRequest {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut pdu_session_resource_to_setup_mod_list: Option<PduSessionResourceToSetupModList> =
            None;
        let mut pdu_session_resource_to_modify_list: Option<PduSessionResourceToModifyList> = None;
        let mut pdu_session_resource_to_remove_list: Option<PduSessionResourceToRemoveList> = None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                56 => {
                    pdu_session_resource_to_setup_mod_list =
                        Some(PduSessionResourceToSetupModList::decode(data)?)
                }
                43 => {
                    pdu_session_resource_to_modify_list =
                        Some(PduSessionResourceToModifyList::decode(data)?)
                }
                44 => {
                    pdu_session_resource_to_remove_list =
                        Some(PduSessionResourceToRemoveList::decode(data)?)
                }
                x => return Err(PerCodecError::new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        Ok(Self {
            pdu_session_resource_to_setup_mod_list,
            pdu_session_resource_to_modify_list,
            pdu_session_resource_to_remove_list,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        if let Some(x) = &self.pdu_session_resource_to_setup_mod_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 56, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.pdu_session_resource_to_modify_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 43, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.pdu_session_resource_to_remove_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 44, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for NgRanBearerContextModificationRequest {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        NgRanBearerContextModificationRequest::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NgRanBearerContextModificationRequest");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NgRanBearerContextModificationRequest");
            e
        })
    }
}
// EutranBearerContextModificationResponse
#[derive(Clone, Debug)]
pub struct EutranBearerContextModificationResponse {
    pub drb_setup_mod_list_eutran: Option<DrbSetupModListEutran>,
    pub drb_failed_mod_list_eutran: Option<DrbFailedModListEutran>,
    pub drb_modified_list_eutran: Option<DrbModifiedListEutran>,
    pub drb_failed_to_modify_list_eutran: Option<DrbFailedToModifyListEutran>,
    pub retainability_measurements_info: Option<RetainabilityMeasurementsInfo>,
}

impl EutranBearerContextModificationResponse {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut drb_setup_mod_list_eutran: Option<DrbSetupModListEutran> = None;
        let mut drb_failed_mod_list_eutran: Option<DrbFailedModListEutran> = None;
        let mut drb_modified_list_eutran: Option<DrbModifiedListEutran> = None;
        let mut drb_failed_to_modify_list_eutran: Option<DrbFailedToModifyListEutran> = None;
        let mut retainability_measurements_info: Option<RetainabilityMeasurementsInfo> = None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                52 => drb_setup_mod_list_eutran = Some(DrbSetupModListEutran::decode(data)?),
                53 => drb_failed_mod_list_eutran = Some(DrbFailedModListEutran::decode(data)?),
                39 => drb_modified_list_eutran = Some(DrbModifiedListEutran::decode(data)?),
                40 => {
                    drb_failed_to_modify_list_eutran =
                        Some(DrbFailedToModifyListEutran::decode(data)?)
                }
                85 => {
                    retainability_measurements_info =
                        Some(RetainabilityMeasurementsInfo::decode(data)?)
                }
                x => return Err(PerCodecError::new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        Ok(Self {
            drb_setup_mod_list_eutran,
            drb_failed_mod_list_eutran,
            drb_modified_list_eutran,
            drb_failed_to_modify_list_eutran,
            retainability_measurements_info,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        if let Some(x) = &self.drb_setup_mod_list_eutran {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 52, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.drb_failed_mod_list_eutran {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 53, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.drb_modified_list_eutran {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 39, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.drb_failed_to_modify_list_eutran {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 40, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.retainability_measurements_info {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 85, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for EutranBearerContextModificationResponse {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        EutranBearerContextModificationResponse::decode_inner(data).map_err(
            |mut e: PerCodecError| {
                e.push_context("EutranBearerContextModificationResponse");
                e
            },
        )
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("EutranBearerContextModificationResponse");
            e
        })
    }
}
// NgRanBearerContextModificationResponse
#[derive(Clone, Debug)]
pub struct NgRanBearerContextModificationResponse {
    pub pdu_session_resource_setup_mod_list: Option<PduSessionResourceSetupModList>,
    pub pdu_session_resource_failed_mod_list: Option<PduSessionResourceFailedModList>,
    pub pdu_session_resource_modified_list: Option<PduSessionResourceModifiedList>,
    pub pdu_session_resource_failed_to_modify_list: Option<PduSessionResourceFailedToModifyList>,
    pub retainability_measurements_info: Option<RetainabilityMeasurementsInfo>,
}

impl NgRanBearerContextModificationResponse {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut pdu_session_resource_setup_mod_list: Option<PduSessionResourceSetupModList> = None;
        let mut pdu_session_resource_failed_mod_list: Option<PduSessionResourceFailedModList> =
            None;
        let mut pdu_session_resource_modified_list: Option<PduSessionResourceModifiedList> = None;
        let mut pdu_session_resource_failed_to_modify_list: Option<
            PduSessionResourceFailedToModifyList,
        > = None;
        let mut retainability_measurements_info: Option<RetainabilityMeasurementsInfo> = None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                54 => {
                    pdu_session_resource_setup_mod_list =
                        Some(PduSessionResourceSetupModList::decode(data)?)
                }
                55 => {
                    pdu_session_resource_failed_mod_list =
                        Some(PduSessionResourceFailedModList::decode(data)?)
                }
                48 => {
                    pdu_session_resource_modified_list =
                        Some(PduSessionResourceModifiedList::decode(data)?)
                }
                49 => {
                    pdu_session_resource_failed_to_modify_list =
                        Some(PduSessionResourceFailedToModifyList::decode(data)?)
                }
                85 => {
                    retainability_measurements_info =
                        Some(RetainabilityMeasurementsInfo::decode(data)?)
                }
                x => return Err(PerCodecError::new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        Ok(Self {
            pdu_session_resource_setup_mod_list,
            pdu_session_resource_failed_mod_list,
            pdu_session_resource_modified_list,
            pdu_session_resource_failed_to_modify_list,
            retainability_measurements_info,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        if let Some(x) = &self.pdu_session_resource_setup_mod_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 54, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.pdu_session_resource_failed_mod_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 55, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.pdu_session_resource_modified_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 48, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.pdu_session_resource_failed_to_modify_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 49, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.retainability_measurements_info {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 85, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for NgRanBearerContextModificationResponse {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        NgRanBearerContextModificationResponse::decode_inner(data).map_err(
            |mut e: PerCodecError| {
                e.push_context("NgRanBearerContextModificationResponse");
                e
            },
        )
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NgRanBearerContextModificationResponse");
            e
        })
    }
}
// EutranBearerContextModificationRequired
#[derive(Clone, Debug)]
pub struct EutranBearerContextModificationRequired {
    pub drb_required_to_modify_list_eutran: Option<DrbRequiredToModifyListEutran>,
    pub drb_required_to_remove_list_eutran: Option<DrbRequiredToRemoveListEutran>,
}

impl EutranBearerContextModificationRequired {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut drb_required_to_modify_list_eutran: Option<DrbRequiredToModifyListEutran> = None;
        let mut drb_required_to_remove_list_eutran: Option<DrbRequiredToRemoveListEutran> = None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                35 => {
                    drb_required_to_modify_list_eutran =
                        Some(DrbRequiredToModifyListEutran::decode(data)?)
                }
                36 => {
                    drb_required_to_remove_list_eutran =
                        Some(DrbRequiredToRemoveListEutran::decode(data)?)
                }
                x => return Err(PerCodecError::new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        Ok(Self {
            drb_required_to_modify_list_eutran,
            drb_required_to_remove_list_eutran,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        if let Some(x) = &self.drb_required_to_modify_list_eutran {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 35, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.drb_required_to_remove_list_eutran {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 36, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for EutranBearerContextModificationRequired {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        EutranBearerContextModificationRequired::decode_inner(data).map_err(
            |mut e: PerCodecError| {
                e.push_context("EutranBearerContextModificationRequired");
                e
            },
        )
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("EutranBearerContextModificationRequired");
            e
        })
    }
}
// NgRanBearerContextModificationRequired
#[derive(Clone, Debug)]
pub struct NgRanBearerContextModificationRequired {
    pub pdu_session_resource_required_to_modify_list:
        Option<PduSessionResourceRequiredToModifyList>,
    pub pdu_session_resource_to_remove_list: Option<PduSessionResourceToRemoveList>,
}

impl NgRanBearerContextModificationRequired {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut pdu_session_resource_required_to_modify_list: Option<
            PduSessionResourceRequiredToModifyList,
        > = None;
        let mut pdu_session_resource_to_remove_list: Option<PduSessionResourceToRemoveList> = None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                45 => {
                    pdu_session_resource_required_to_modify_list =
                        Some(PduSessionResourceRequiredToModifyList::decode(data)?)
                }
                44 => {
                    pdu_session_resource_to_remove_list =
                        Some(PduSessionResourceToRemoveList::decode(data)?)
                }
                x => return Err(PerCodecError::new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        Ok(Self {
            pdu_session_resource_required_to_modify_list,
            pdu_session_resource_to_remove_list,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        if let Some(x) = &self.pdu_session_resource_required_to_modify_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 45, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.pdu_session_resource_to_remove_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 44, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for NgRanBearerContextModificationRequired {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        NgRanBearerContextModificationRequired::decode_inner(data).map_err(
            |mut e: PerCodecError| {
                e.push_context("NgRanBearerContextModificationRequired");
                e
            },
        )
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NgRanBearerContextModificationRequired");
            e
        })
    }
}
// EutranBearerContextModificationConfirm
#[derive(Clone, Debug)]
pub struct EutranBearerContextModificationConfirm {
    pub drb_confirm_modified_list_eutran: Option<DrbConfirmModifiedListEutran>,
}

impl EutranBearerContextModificationConfirm {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut drb_confirm_modified_list_eutran: Option<DrbConfirmModifiedListEutran> = None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                41 => {
                    drb_confirm_modified_list_eutran =
                        Some(DrbConfirmModifiedListEutran::decode(data)?)
                }
                x => return Err(PerCodecError::new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        Ok(Self {
            drb_confirm_modified_list_eutran,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        if let Some(x) = &self.drb_confirm_modified_list_eutran {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 41, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for EutranBearerContextModificationConfirm {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        EutranBearerContextModificationConfirm::decode_inner(data).map_err(
            |mut e: PerCodecError| {
                e.push_context("EutranBearerContextModificationConfirm");
                e
            },
        )
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("EutranBearerContextModificationConfirm");
            e
        })
    }
}
// NgRanBearerContextModificationConfirm
#[derive(Clone, Debug)]
pub struct NgRanBearerContextModificationConfirm {
    pub pdu_session_resource_confirm_modified_list: Option<PduSessionResourceConfirmModifiedList>,
}

impl NgRanBearerContextModificationConfirm {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut pdu_session_resource_confirm_modified_list: Option<
            PduSessionResourceConfirmModifiedList,
        > = None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                50 => {
                    pdu_session_resource_confirm_modified_list =
                        Some(PduSessionResourceConfirmModifiedList::decode(data)?)
                }
                x => return Err(PerCodecError::new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        Ok(Self {
            pdu_session_resource_confirm_modified_list,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        if let Some(x) = &self.pdu_session_resource_confirm_modified_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 50, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for NgRanBearerContextModificationConfirm {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        NgRanBearerContextModificationConfirm::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NgRanBearerContextModificationConfirm");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NgRanBearerContextModificationConfirm");
            e
        })
    }
}
// EutranGnbCuUpCounterCheckRequest
#[derive(Clone, Debug)]
pub struct EutranGnbCuUpCounterCheckRequest {
    pub drbs_subject_to_counter_check_list_eutran: DrbsSubjectToCounterCheckListEutran,
}

impl EutranGnbCuUpCounterCheckRequest {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut drbs_subject_to_counter_check_list_eutran: Option<
            DrbsSubjectToCounterCheckListEutran,
        > = None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                61 => {
                    drbs_subject_to_counter_check_list_eutran =
                        Some(DrbsSubjectToCounterCheckListEutran::decode(data)?)
                }
                x => return Err(PerCodecError::new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        let drbs_subject_to_counter_check_list_eutran = drbs_subject_to_counter_check_list_eutran
            .ok_or(PerCodecError::new(format!(
            "Missing mandatory IE drbs_subject_to_counter_check_list_eutran"
        )))?;
        Ok(Self {
            drbs_subject_to_counter_check_list_eutran,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        let ie = &mut Allocator::new_codec_data();
        self.drbs_subject_to_counter_check_list_eutran.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 61, false)?;
        Criticality::Ignore.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for EutranGnbCuUpCounterCheckRequest {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        EutranGnbCuUpCounterCheckRequest::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("EutranGnbCuUpCounterCheckRequest");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("EutranGnbCuUpCounterCheckRequest");
            e
        })
    }
}
// NgRanGnbCuUpCounterCheckRequest
#[derive(Clone, Debug)]
pub struct NgRanGnbCuUpCounterCheckRequest {
    pub drbs_subject_to_counter_check_list_ng_ran: DrbsSubjectToCounterCheckListNgRan,
}

impl NgRanGnbCuUpCounterCheckRequest {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut drbs_subject_to_counter_check_list_ng_ran: Option<
            DrbsSubjectToCounterCheckListNgRan,
        > = None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                62 => {
                    drbs_subject_to_counter_check_list_ng_ran =
                        Some(DrbsSubjectToCounterCheckListNgRan::decode(data)?)
                }
                x => return Err(PerCodecError::new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        let drbs_subject_to_counter_check_list_ng_ran = drbs_subject_to_counter_check_list_ng_ran
            .ok_or(PerCodecError::new(format!(
            "Missing mandatory IE drbs_subject_to_counter_check_list_ng_ran"
        )))?;
        Ok(Self {
            drbs_subject_to_counter_check_list_ng_ran,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        let ie = &mut Allocator::new_codec_data();
        self.drbs_subject_to_counter_check_list_ng_ran.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 62, false)?;
        Criticality::Ignore.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for NgRanGnbCuUpCounterCheckRequest {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        NgRanGnbCuUpCounterCheckRequest::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NgRanGnbCuUpCounterCheckRequest");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NgRanGnbCuUpCounterCheckRequest");
            e
        })
    }
}
