// Autogenerated from NGAP-PDU-Descriptions.asn
use super::pdu::*;
use crate::common::Criticality;
use anyhow::Result;
use asn1_codecs::aper::{self, AperCodec, AperCodecData, AperCodecError};
use async_trait::async_trait;
use net::{AperSerde, Procedure, RequestError, RequestProvider};
use slog::Logger;

// NgapPdu
#[derive(Clone, Debug)]
pub enum NgapPdu {
    InitiatingMessage(InitiatingMessage),
    SuccessfulOutcome(SuccessfulOutcome),
    UnsuccessfulOutcome(UnsuccessfulOutcome),
}

impl NgapPdu {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (idx, extended) = aper::decode::decode_choice_idx(data, 0, 2, true)?;
        if extended {
            return Err(aper::AperCodecError::new(
                "CHOICE additions not implemented",
            ));
        }
        match idx {
            0 => Ok(Self::InitiatingMessage(InitiatingMessage::decode(data)?)),
            1 => Ok(Self::SuccessfulOutcome(SuccessfulOutcome::decode(data)?)),
            2 => Ok(Self::UnsuccessfulOutcome(UnsuccessfulOutcome::decode(
                data,
            )?)),
            _ => Err(AperCodecError::new("Unknown choice idx")),
        }
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        match self {
            Self::InitiatingMessage(x) => {
                aper::encode::encode_choice_idx(data, 0, 2, true, 0, false)?;
                x.encode(data)
            }
            Self::SuccessfulOutcome(x) => {
                aper::encode::encode_choice_idx(data, 0, 2, true, 1, false)?;
                x.encode(data)
            }
            Self::UnsuccessfulOutcome(x) => {
                aper::encode::encode_choice_idx(data, 0, 2, true, 2, false)?;
                x.encode(data)
            }
        }
    }
}

impl AperCodec for NgapPdu {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        NgapPdu::decode_inner(data).map_err(|e: AperCodecError| e.push_context("NgapPdu"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("NgapPdu"))
    }
}
pub struct AmfConfigurationUpdateProcedure {}

#[async_trait]
impl Procedure for AmfConfigurationUpdateProcedure {
    type TopPdu = NgapPdu;
    type Request = AmfConfigurationUpdate;
    type Success = AmfConfigurationUpdateAcknowledge;
    type Failure = AmfConfigurationUpdateFailure;
    const CODE: u8 = 0;

    async fn call_provider<T: RequestProvider<Self>>(
        provider: &T,
        req: AmfConfigurationUpdate,
        logger: &Logger,
    ) -> Option<NgapPdu> {
        match <T as RequestProvider<AmfConfigurationUpdateProcedure>>::request(
            provider, req, logger,
        )
        .await
        {
            Ok(x) => Some(NgapPdu::SuccessfulOutcome(
                SuccessfulOutcome::AmfConfigurationUpdateAcknowledge(x),
            )),
            Err(_) => todo!(),
        }
    }

    fn encode_request(r: Self::Request) -> Result<Vec<u8>, AperCodecError> {
        NgapPdu::InitiatingMessage(InitiatingMessage::AmfConfigurationUpdate(r)).into_bytes()
    }

    fn decode_response(bytes: &[u8]) -> Result<Self::Success, RequestError<Self::Failure>> {
        let response_pdu = Self::TopPdu::from_bytes(bytes)?;
        match response_pdu {
            NgapPdu::SuccessfulOutcome(SuccessfulOutcome::AmfConfigurationUpdateAcknowledge(x)) => {
                Ok(x)
            }
            NgapPdu::UnsuccessfulOutcome(UnsuccessfulOutcome::AmfConfigurationUpdateFailure(x)) => {
                Err(RequestError::UnsuccessfulOutcome(x))
            }
            _ => Err(RequestError::Other("Unexpected pdu contents".to_string())),
        }
    }
}

pub struct AmfcpRelocationIndicationProcedure {}

#[async_trait]
impl Procedure for AmfcpRelocationIndicationProcedure {
    type TopPdu = NgapPdu;
    type Request = AmfcpRelocationIndication;
    type Success = ();
    type Failure = ();
    const CODE: u8 = 64;

    async fn call_provider<T: RequestProvider<Self>>(
        provider: &T,
        req: AmfcpRelocationIndication,
        logger: &Logger,
    ) -> Option<NgapPdu> {
        match <T as RequestProvider<AmfcpRelocationIndicationProcedure>>::request(
            provider, req, logger,
        )
        .await
        {
            Ok(_) => None,
            Err(_) => todo!(),
        }
    }

    fn encode_request(r: Self::Request) -> Result<Vec<u8>, AperCodecError> {
        NgapPdu::InitiatingMessage(InitiatingMessage::AmfcpRelocationIndication(r)).into_bytes()
    }

    fn decode_response(_bytes: &[u8]) -> Result<Self::Success, RequestError<Self::Failure>> {
        Err(RequestError::Other(
            "No response is defined for AmfcpRelocationIndication!".to_string(),
        ))
    }
}

pub struct AmfStatusIndicationProcedure {}

#[async_trait]
impl Procedure for AmfStatusIndicationProcedure {
    type TopPdu = NgapPdu;
    type Request = AmfStatusIndication;
    type Success = ();
    type Failure = ();
    const CODE: u8 = 1;

    async fn call_provider<T: RequestProvider<Self>>(
        provider: &T,
        req: AmfStatusIndication,
        logger: &Logger,
    ) -> Option<NgapPdu> {
        match <T as RequestProvider<AmfStatusIndicationProcedure>>::request(provider, req, logger)
            .await
        {
            Ok(_) => None,
            Err(_) => todo!(),
        }
    }

    fn encode_request(r: Self::Request) -> Result<Vec<u8>, AperCodecError> {
        NgapPdu::InitiatingMessage(InitiatingMessage::AmfStatusIndication(r)).into_bytes()
    }

    fn decode_response(_bytes: &[u8]) -> Result<Self::Success, RequestError<Self::Failure>> {
        Err(RequestError::Other(
            "No response is defined for AmfStatusIndication!".to_string(),
        ))
    }
}

pub struct CellTrafficTraceProcedure {}

#[async_trait]
impl Procedure for CellTrafficTraceProcedure {
    type TopPdu = NgapPdu;
    type Request = CellTrafficTrace;
    type Success = ();
    type Failure = ();
    const CODE: u8 = 2;

    async fn call_provider<T: RequestProvider<Self>>(
        provider: &T,
        req: CellTrafficTrace,
        logger: &Logger,
    ) -> Option<NgapPdu> {
        match <T as RequestProvider<CellTrafficTraceProcedure>>::request(provider, req, logger)
            .await
        {
            Ok(_) => None,
            Err(_) => todo!(),
        }
    }

    fn encode_request(r: Self::Request) -> Result<Vec<u8>, AperCodecError> {
        NgapPdu::InitiatingMessage(InitiatingMessage::CellTrafficTrace(r)).into_bytes()
    }

    fn decode_response(_bytes: &[u8]) -> Result<Self::Success, RequestError<Self::Failure>> {
        Err(RequestError::Other(
            "No response is defined for CellTrafficTrace!".to_string(),
        ))
    }
}

pub struct ConnectionEstablishmentIndicationProcedure {}

#[async_trait]
impl Procedure for ConnectionEstablishmentIndicationProcedure {
    type TopPdu = NgapPdu;
    type Request = ConnectionEstablishmentIndication;
    type Success = ();
    type Failure = ();
    const CODE: u8 = 65;

    async fn call_provider<T: RequestProvider<Self>>(
        provider: &T,
        req: ConnectionEstablishmentIndication,
        logger: &Logger,
    ) -> Option<NgapPdu> {
        match <T as RequestProvider<ConnectionEstablishmentIndicationProcedure>>::request(
            provider, req, logger,
        )
        .await
        {
            Ok(_) => None,
            Err(_) => todo!(),
        }
    }

    fn encode_request(r: Self::Request) -> Result<Vec<u8>, AperCodecError> {
        NgapPdu::InitiatingMessage(InitiatingMessage::ConnectionEstablishmentIndication(r))
            .into_bytes()
    }

    fn decode_response(_bytes: &[u8]) -> Result<Self::Success, RequestError<Self::Failure>> {
        Err(RequestError::Other(
            "No response is defined for ConnectionEstablishmentIndication!".to_string(),
        ))
    }
}

pub struct DeactivateTraceProcedure {}

#[async_trait]
impl Procedure for DeactivateTraceProcedure {
    type TopPdu = NgapPdu;
    type Request = DeactivateTrace;
    type Success = ();
    type Failure = ();
    const CODE: u8 = 3;

    async fn call_provider<T: RequestProvider<Self>>(
        provider: &T,
        req: DeactivateTrace,
        logger: &Logger,
    ) -> Option<NgapPdu> {
        match <T as RequestProvider<DeactivateTraceProcedure>>::request(provider, req, logger).await
        {
            Ok(_) => None,
            Err(_) => todo!(),
        }
    }

    fn encode_request(r: Self::Request) -> Result<Vec<u8>, AperCodecError> {
        NgapPdu::InitiatingMessage(InitiatingMessage::DeactivateTrace(r)).into_bytes()
    }

    fn decode_response(_bytes: &[u8]) -> Result<Self::Success, RequestError<Self::Failure>> {
        Err(RequestError::Other(
            "No response is defined for DeactivateTrace!".to_string(),
        ))
    }
}

pub struct DownlinkNasTransportProcedure {}

#[async_trait]
impl Procedure for DownlinkNasTransportProcedure {
    type TopPdu = NgapPdu;
    type Request = DownlinkNasTransport;
    type Success = ();
    type Failure = ();
    const CODE: u8 = 4;

    async fn call_provider<T: RequestProvider<Self>>(
        provider: &T,
        req: DownlinkNasTransport,
        logger: &Logger,
    ) -> Option<NgapPdu> {
        match <T as RequestProvider<DownlinkNasTransportProcedure>>::request(provider, req, logger)
            .await
        {
            Ok(_) => None,
            Err(_) => todo!(),
        }
    }

    fn encode_request(r: Self::Request) -> Result<Vec<u8>, AperCodecError> {
        NgapPdu::InitiatingMessage(InitiatingMessage::DownlinkNasTransport(r)).into_bytes()
    }

    fn decode_response(_bytes: &[u8]) -> Result<Self::Success, RequestError<Self::Failure>> {
        Err(RequestError::Other(
            "No response is defined for DownlinkNasTransport!".to_string(),
        ))
    }
}

pub struct DownlinkNonUeAssociatedNrpPaTransportProcedure {}

#[async_trait]
impl Procedure for DownlinkNonUeAssociatedNrpPaTransportProcedure {
    type TopPdu = NgapPdu;
    type Request = DownlinkNonUeAssociatedNrpPaTransport;
    type Success = ();
    type Failure = ();
    const CODE: u8 = 5;

    async fn call_provider<T: RequestProvider<Self>>(
        provider: &T,
        req: DownlinkNonUeAssociatedNrpPaTransport,
        logger: &Logger,
    ) -> Option<NgapPdu> {
        match <T as RequestProvider<DownlinkNonUeAssociatedNrpPaTransportProcedure>>::request(
            provider, req, logger,
        )
        .await
        {
            Ok(_) => None,
            Err(_) => todo!(),
        }
    }

    fn encode_request(r: Self::Request) -> Result<Vec<u8>, AperCodecError> {
        NgapPdu::InitiatingMessage(InitiatingMessage::DownlinkNonUeAssociatedNrpPaTransport(r))
            .into_bytes()
    }

    fn decode_response(_bytes: &[u8]) -> Result<Self::Success, RequestError<Self::Failure>> {
        Err(RequestError::Other(
            "No response is defined for DownlinkNonUeAssociatedNrpPaTransport!".to_string(),
        ))
    }
}

pub struct DownlinkRanConfigurationTransferProcedure {}

#[async_trait]
impl Procedure for DownlinkRanConfigurationTransferProcedure {
    type TopPdu = NgapPdu;
    type Request = DownlinkRanConfigurationTransfer;
    type Success = ();
    type Failure = ();
    const CODE: u8 = 6;

    async fn call_provider<T: RequestProvider<Self>>(
        provider: &T,
        req: DownlinkRanConfigurationTransfer,
        logger: &Logger,
    ) -> Option<NgapPdu> {
        match <T as RequestProvider<DownlinkRanConfigurationTransferProcedure>>::request(
            provider, req, logger,
        )
        .await
        {
            Ok(_) => None,
            Err(_) => todo!(),
        }
    }

    fn encode_request(r: Self::Request) -> Result<Vec<u8>, AperCodecError> {
        NgapPdu::InitiatingMessage(InitiatingMessage::DownlinkRanConfigurationTransfer(r))
            .into_bytes()
    }

    fn decode_response(_bytes: &[u8]) -> Result<Self::Success, RequestError<Self::Failure>> {
        Err(RequestError::Other(
            "No response is defined for DownlinkRanConfigurationTransfer!".to_string(),
        ))
    }
}

pub struct DownlinkRanEarlyStatusTransferProcedure {}

#[async_trait]
impl Procedure for DownlinkRanEarlyStatusTransferProcedure {
    type TopPdu = NgapPdu;
    type Request = DownlinkRanEarlyStatusTransfer;
    type Success = ();
    type Failure = ();
    const CODE: u8 = 63;

    async fn call_provider<T: RequestProvider<Self>>(
        provider: &T,
        req: DownlinkRanEarlyStatusTransfer,
        logger: &Logger,
    ) -> Option<NgapPdu> {
        match <T as RequestProvider<DownlinkRanEarlyStatusTransferProcedure>>::request(
            provider, req, logger,
        )
        .await
        {
            Ok(_) => None,
            Err(_) => todo!(),
        }
    }

    fn encode_request(r: Self::Request) -> Result<Vec<u8>, AperCodecError> {
        NgapPdu::InitiatingMessage(InitiatingMessage::DownlinkRanEarlyStatusTransfer(r))
            .into_bytes()
    }

    fn decode_response(_bytes: &[u8]) -> Result<Self::Success, RequestError<Self::Failure>> {
        Err(RequestError::Other(
            "No response is defined for DownlinkRanEarlyStatusTransfer!".to_string(),
        ))
    }
}

pub struct DownlinkRanStatusTransferProcedure {}

#[async_trait]
impl Procedure for DownlinkRanStatusTransferProcedure {
    type TopPdu = NgapPdu;
    type Request = DownlinkRanStatusTransfer;
    type Success = ();
    type Failure = ();
    const CODE: u8 = 7;

    async fn call_provider<T: RequestProvider<Self>>(
        provider: &T,
        req: DownlinkRanStatusTransfer,
        logger: &Logger,
    ) -> Option<NgapPdu> {
        match <T as RequestProvider<DownlinkRanStatusTransferProcedure>>::request(
            provider, req, logger,
        )
        .await
        {
            Ok(_) => None,
            Err(_) => todo!(),
        }
    }

    fn encode_request(r: Self::Request) -> Result<Vec<u8>, AperCodecError> {
        NgapPdu::InitiatingMessage(InitiatingMessage::DownlinkRanStatusTransfer(r)).into_bytes()
    }

    fn decode_response(_bytes: &[u8]) -> Result<Self::Success, RequestError<Self::Failure>> {
        Err(RequestError::Other(
            "No response is defined for DownlinkRanStatusTransfer!".to_string(),
        ))
    }
}

pub struct DownlinkUeAssociatedNrpPaTransportProcedure {}

#[async_trait]
impl Procedure for DownlinkUeAssociatedNrpPaTransportProcedure {
    type TopPdu = NgapPdu;
    type Request = DownlinkUeAssociatedNrpPaTransport;
    type Success = ();
    type Failure = ();
    const CODE: u8 = 8;

    async fn call_provider<T: RequestProvider<Self>>(
        provider: &T,
        req: DownlinkUeAssociatedNrpPaTransport,
        logger: &Logger,
    ) -> Option<NgapPdu> {
        match <T as RequestProvider<DownlinkUeAssociatedNrpPaTransportProcedure>>::request(
            provider, req, logger,
        )
        .await
        {
            Ok(_) => None,
            Err(_) => todo!(),
        }
    }

    fn encode_request(r: Self::Request) -> Result<Vec<u8>, AperCodecError> {
        NgapPdu::InitiatingMessage(InitiatingMessage::DownlinkUeAssociatedNrpPaTransport(r))
            .into_bytes()
    }

    fn decode_response(_bytes: &[u8]) -> Result<Self::Success, RequestError<Self::Failure>> {
        Err(RequestError::Other(
            "No response is defined for DownlinkUeAssociatedNrpPaTransport!".to_string(),
        ))
    }
}

pub struct ErrorIndicationProcedure {}

#[async_trait]
impl Procedure for ErrorIndicationProcedure {
    type TopPdu = NgapPdu;
    type Request = ErrorIndication;
    type Success = ();
    type Failure = ();
    const CODE: u8 = 9;

    async fn call_provider<T: RequestProvider<Self>>(
        provider: &T,
        req: ErrorIndication,
        logger: &Logger,
    ) -> Option<NgapPdu> {
        match <T as RequestProvider<ErrorIndicationProcedure>>::request(provider, req, logger).await
        {
            Ok(_) => None,
            Err(_) => todo!(),
        }
    }

    fn encode_request(r: Self::Request) -> Result<Vec<u8>, AperCodecError> {
        NgapPdu::InitiatingMessage(InitiatingMessage::ErrorIndication(r)).into_bytes()
    }

    fn decode_response(_bytes: &[u8]) -> Result<Self::Success, RequestError<Self::Failure>> {
        Err(RequestError::Other(
            "No response is defined for ErrorIndication!".to_string(),
        ))
    }
}

pub struct HandoverCancelProcedure {}

#[async_trait]
impl Procedure for HandoverCancelProcedure {
    type TopPdu = NgapPdu;
    type Request = HandoverCancel;
    type Success = HandoverCancelAcknowledge;
    type Failure = ();
    const CODE: u8 = 10;

    async fn call_provider<T: RequestProvider<Self>>(
        provider: &T,
        req: HandoverCancel,
        logger: &Logger,
    ) -> Option<NgapPdu> {
        match <T as RequestProvider<HandoverCancelProcedure>>::request(provider, req, logger).await
        {
            Ok(x) => Some(NgapPdu::SuccessfulOutcome(
                SuccessfulOutcome::HandoverCancelAcknowledge(x),
            )),
            Err(_) => todo!(),
        }
    }

    fn encode_request(r: Self::Request) -> Result<Vec<u8>, AperCodecError> {
        NgapPdu::InitiatingMessage(InitiatingMessage::HandoverCancel(r)).into_bytes()
    }

    fn decode_response(bytes: &[u8]) -> Result<Self::Success, RequestError<Self::Failure>> {
        let response_pdu = Self::TopPdu::from_bytes(bytes)?;
        match response_pdu {
            NgapPdu::SuccessfulOutcome(SuccessfulOutcome::HandoverCancelAcknowledge(x)) => Ok(x),

            _ => Err(RequestError::Other("Unexpected pdu contents".to_string())),
        }
    }
}

pub struct HandoverNotificationProcedure {}

#[async_trait]
impl Procedure for HandoverNotificationProcedure {
    type TopPdu = NgapPdu;
    type Request = HandoverNotify;
    type Success = ();
    type Failure = ();
    const CODE: u8 = 11;

    async fn call_provider<T: RequestProvider<Self>>(
        provider: &T,
        req: HandoverNotify,
        logger: &Logger,
    ) -> Option<NgapPdu> {
        match <T as RequestProvider<HandoverNotificationProcedure>>::request(provider, req, logger)
            .await
        {
            Ok(_) => None,
            Err(_) => todo!(),
        }
    }

    fn encode_request(r: Self::Request) -> Result<Vec<u8>, AperCodecError> {
        NgapPdu::InitiatingMessage(InitiatingMessage::HandoverNotify(r)).into_bytes()
    }

    fn decode_response(_bytes: &[u8]) -> Result<Self::Success, RequestError<Self::Failure>> {
        Err(RequestError::Other(
            "No response is defined for HandoverNotify!".to_string(),
        ))
    }
}

pub struct HandoverPreparationProcedure {}

#[async_trait]
impl Procedure for HandoverPreparationProcedure {
    type TopPdu = NgapPdu;
    type Request = HandoverRequired;
    type Success = HandoverCommand;
    type Failure = HandoverPreparationFailure;
    const CODE: u8 = 12;

    async fn call_provider<T: RequestProvider<Self>>(
        provider: &T,
        req: HandoverRequired,
        logger: &Logger,
    ) -> Option<NgapPdu> {
        match <T as RequestProvider<HandoverPreparationProcedure>>::request(provider, req, logger)
            .await
        {
            Ok(x) => Some(NgapPdu::SuccessfulOutcome(
                SuccessfulOutcome::HandoverCommand(x),
            )),
            Err(_) => todo!(),
        }
    }

    fn encode_request(r: Self::Request) -> Result<Vec<u8>, AperCodecError> {
        NgapPdu::InitiatingMessage(InitiatingMessage::HandoverRequired(r)).into_bytes()
    }

    fn decode_response(bytes: &[u8]) -> Result<Self::Success, RequestError<Self::Failure>> {
        let response_pdu = Self::TopPdu::from_bytes(bytes)?;
        match response_pdu {
            NgapPdu::SuccessfulOutcome(SuccessfulOutcome::HandoverCommand(x)) => Ok(x),
            NgapPdu::UnsuccessfulOutcome(UnsuccessfulOutcome::HandoverPreparationFailure(x)) => {
                Err(RequestError::UnsuccessfulOutcome(x))
            }
            _ => Err(RequestError::Other("Unexpected pdu contents".to_string())),
        }
    }
}

pub struct HandoverResourceAllocationProcedure {}

#[async_trait]
impl Procedure for HandoverResourceAllocationProcedure {
    type TopPdu = NgapPdu;
    type Request = HandoverRequest;
    type Success = HandoverRequestAcknowledge;
    type Failure = HandoverFailure;
    const CODE: u8 = 13;

    async fn call_provider<T: RequestProvider<Self>>(
        provider: &T,
        req: HandoverRequest,
        logger: &Logger,
    ) -> Option<NgapPdu> {
        match <T as RequestProvider<HandoverResourceAllocationProcedure>>::request(
            provider, req, logger,
        )
        .await
        {
            Ok(x) => Some(NgapPdu::SuccessfulOutcome(
                SuccessfulOutcome::HandoverRequestAcknowledge(x),
            )),
            Err(_) => todo!(),
        }
    }

    fn encode_request(r: Self::Request) -> Result<Vec<u8>, AperCodecError> {
        NgapPdu::InitiatingMessage(InitiatingMessage::HandoverRequest(r)).into_bytes()
    }

    fn decode_response(bytes: &[u8]) -> Result<Self::Success, RequestError<Self::Failure>> {
        let response_pdu = Self::TopPdu::from_bytes(bytes)?;
        match response_pdu {
            NgapPdu::SuccessfulOutcome(SuccessfulOutcome::HandoverRequestAcknowledge(x)) => Ok(x),
            NgapPdu::UnsuccessfulOutcome(UnsuccessfulOutcome::HandoverFailure(x)) => {
                Err(RequestError::UnsuccessfulOutcome(x))
            }
            _ => Err(RequestError::Other("Unexpected pdu contents".to_string())),
        }
    }
}

pub struct HandoverSuccessProcedure {}

#[async_trait]
impl Procedure for HandoverSuccessProcedure {
    type TopPdu = NgapPdu;
    type Request = HandoverSuccess;
    type Success = ();
    type Failure = ();
    const CODE: u8 = 61;

    async fn call_provider<T: RequestProvider<Self>>(
        provider: &T,
        req: HandoverSuccess,
        logger: &Logger,
    ) -> Option<NgapPdu> {
        match <T as RequestProvider<HandoverSuccessProcedure>>::request(provider, req, logger).await
        {
            Ok(_) => None,
            Err(_) => todo!(),
        }
    }

    fn encode_request(r: Self::Request) -> Result<Vec<u8>, AperCodecError> {
        NgapPdu::InitiatingMessage(InitiatingMessage::HandoverSuccess(r)).into_bytes()
    }

    fn decode_response(_bytes: &[u8]) -> Result<Self::Success, RequestError<Self::Failure>> {
        Err(RequestError::Other(
            "No response is defined for HandoverSuccess!".to_string(),
        ))
    }
}

pub struct InitialContextSetupProcedure {}

#[async_trait]
impl Procedure for InitialContextSetupProcedure {
    type TopPdu = NgapPdu;
    type Request = InitialContextSetupRequest;
    type Success = InitialContextSetupResponse;
    type Failure = InitialContextSetupFailure;
    const CODE: u8 = 14;

    async fn call_provider<T: RequestProvider<Self>>(
        provider: &T,
        req: InitialContextSetupRequest,
        logger: &Logger,
    ) -> Option<NgapPdu> {
        match <T as RequestProvider<InitialContextSetupProcedure>>::request(provider, req, logger)
            .await
        {
            Ok(x) => Some(NgapPdu::SuccessfulOutcome(
                SuccessfulOutcome::InitialContextSetupResponse(x),
            )),
            Err(_) => todo!(),
        }
    }

    fn encode_request(r: Self::Request) -> Result<Vec<u8>, AperCodecError> {
        NgapPdu::InitiatingMessage(InitiatingMessage::InitialContextSetupRequest(r)).into_bytes()
    }

    fn decode_response(bytes: &[u8]) -> Result<Self::Success, RequestError<Self::Failure>> {
        let response_pdu = Self::TopPdu::from_bytes(bytes)?;
        match response_pdu {
            NgapPdu::SuccessfulOutcome(SuccessfulOutcome::InitialContextSetupResponse(x)) => Ok(x),
            NgapPdu::UnsuccessfulOutcome(UnsuccessfulOutcome::InitialContextSetupFailure(x)) => {
                Err(RequestError::UnsuccessfulOutcome(x))
            }
            _ => Err(RequestError::Other("Unexpected pdu contents".to_string())),
        }
    }
}

pub struct InitialUeMessageProcedure {}

#[async_trait]
impl Procedure for InitialUeMessageProcedure {
    type TopPdu = NgapPdu;
    type Request = InitialUeMessage;
    type Success = ();
    type Failure = ();
    const CODE: u8 = 15;

    async fn call_provider<T: RequestProvider<Self>>(
        provider: &T,
        req: InitialUeMessage,
        logger: &Logger,
    ) -> Option<NgapPdu> {
        match <T as RequestProvider<InitialUeMessageProcedure>>::request(provider, req, logger)
            .await
        {
            Ok(_) => None,
            Err(_) => todo!(),
        }
    }

    fn encode_request(r: Self::Request) -> Result<Vec<u8>, AperCodecError> {
        NgapPdu::InitiatingMessage(InitiatingMessage::InitialUeMessage(r)).into_bytes()
    }

    fn decode_response(_bytes: &[u8]) -> Result<Self::Success, RequestError<Self::Failure>> {
        Err(RequestError::Other(
            "No response is defined for InitialUeMessage!".to_string(),
        ))
    }
}

pub struct LocationReportProcedure {}

#[async_trait]
impl Procedure for LocationReportProcedure {
    type TopPdu = NgapPdu;
    type Request = LocationReport;
    type Success = ();
    type Failure = ();
    const CODE: u8 = 18;

    async fn call_provider<T: RequestProvider<Self>>(
        provider: &T,
        req: LocationReport,
        logger: &Logger,
    ) -> Option<NgapPdu> {
        match <T as RequestProvider<LocationReportProcedure>>::request(provider, req, logger).await
        {
            Ok(_) => None,
            Err(_) => todo!(),
        }
    }

    fn encode_request(r: Self::Request) -> Result<Vec<u8>, AperCodecError> {
        NgapPdu::InitiatingMessage(InitiatingMessage::LocationReport(r)).into_bytes()
    }

    fn decode_response(_bytes: &[u8]) -> Result<Self::Success, RequestError<Self::Failure>> {
        Err(RequestError::Other(
            "No response is defined for LocationReport!".to_string(),
        ))
    }
}

pub struct LocationReportingControlProcedure {}

#[async_trait]
impl Procedure for LocationReportingControlProcedure {
    type TopPdu = NgapPdu;
    type Request = LocationReportingControl;
    type Success = ();
    type Failure = ();
    const CODE: u8 = 16;

    async fn call_provider<T: RequestProvider<Self>>(
        provider: &T,
        req: LocationReportingControl,
        logger: &Logger,
    ) -> Option<NgapPdu> {
        match <T as RequestProvider<LocationReportingControlProcedure>>::request(
            provider, req, logger,
        )
        .await
        {
            Ok(_) => None,
            Err(_) => todo!(),
        }
    }

    fn encode_request(r: Self::Request) -> Result<Vec<u8>, AperCodecError> {
        NgapPdu::InitiatingMessage(InitiatingMessage::LocationReportingControl(r)).into_bytes()
    }

    fn decode_response(_bytes: &[u8]) -> Result<Self::Success, RequestError<Self::Failure>> {
        Err(RequestError::Other(
            "No response is defined for LocationReportingControl!".to_string(),
        ))
    }
}

pub struct LocationReportingFailureIndicationProcedure {}

#[async_trait]
impl Procedure for LocationReportingFailureIndicationProcedure {
    type TopPdu = NgapPdu;
    type Request = LocationReportingFailureIndication;
    type Success = ();
    type Failure = ();
    const CODE: u8 = 17;

    async fn call_provider<T: RequestProvider<Self>>(
        provider: &T,
        req: LocationReportingFailureIndication,
        logger: &Logger,
    ) -> Option<NgapPdu> {
        match <T as RequestProvider<LocationReportingFailureIndicationProcedure>>::request(
            provider, req, logger,
        )
        .await
        {
            Ok(_) => None,
            Err(_) => todo!(),
        }
    }

    fn encode_request(r: Self::Request) -> Result<Vec<u8>, AperCodecError> {
        NgapPdu::InitiatingMessage(InitiatingMessage::LocationReportingFailureIndication(r))
            .into_bytes()
    }

    fn decode_response(_bytes: &[u8]) -> Result<Self::Success, RequestError<Self::Failure>> {
        Err(RequestError::Other(
            "No response is defined for LocationReportingFailureIndication!".to_string(),
        ))
    }
}

pub struct NasNonDeliveryIndicationProcedure {}

#[async_trait]
impl Procedure for NasNonDeliveryIndicationProcedure {
    type TopPdu = NgapPdu;
    type Request = NasNonDeliveryIndication;
    type Success = ();
    type Failure = ();
    const CODE: u8 = 19;

    async fn call_provider<T: RequestProvider<Self>>(
        provider: &T,
        req: NasNonDeliveryIndication,
        logger: &Logger,
    ) -> Option<NgapPdu> {
        match <T as RequestProvider<NasNonDeliveryIndicationProcedure>>::request(
            provider, req, logger,
        )
        .await
        {
            Ok(_) => None,
            Err(_) => todo!(),
        }
    }

    fn encode_request(r: Self::Request) -> Result<Vec<u8>, AperCodecError> {
        NgapPdu::InitiatingMessage(InitiatingMessage::NasNonDeliveryIndication(r)).into_bytes()
    }

    fn decode_response(_bytes: &[u8]) -> Result<Self::Success, RequestError<Self::Failure>> {
        Err(RequestError::Other(
            "No response is defined for NasNonDeliveryIndication!".to_string(),
        ))
    }
}

pub struct NgResetProcedure {}

#[async_trait]
impl Procedure for NgResetProcedure {
    type TopPdu = NgapPdu;
    type Request = NgReset;
    type Success = NgResetAcknowledge;
    type Failure = ();
    const CODE: u8 = 20;

    async fn call_provider<T: RequestProvider<Self>>(
        provider: &T,
        req: NgReset,
        logger: &Logger,
    ) -> Option<NgapPdu> {
        match <T as RequestProvider<NgResetProcedure>>::request(provider, req, logger).await {
            Ok(x) => Some(NgapPdu::SuccessfulOutcome(
                SuccessfulOutcome::NgResetAcknowledge(x),
            )),
            Err(_) => todo!(),
        }
    }

    fn encode_request(r: Self::Request) -> Result<Vec<u8>, AperCodecError> {
        NgapPdu::InitiatingMessage(InitiatingMessage::NgReset(r)).into_bytes()
    }

    fn decode_response(bytes: &[u8]) -> Result<Self::Success, RequestError<Self::Failure>> {
        let response_pdu = Self::TopPdu::from_bytes(bytes)?;
        match response_pdu {
            NgapPdu::SuccessfulOutcome(SuccessfulOutcome::NgResetAcknowledge(x)) => Ok(x),

            _ => Err(RequestError::Other("Unexpected pdu contents".to_string())),
        }
    }
}

pub struct NgSetupProcedure {}

#[async_trait]
impl Procedure for NgSetupProcedure {
    type TopPdu = NgapPdu;
    type Request = NgSetupRequest;
    type Success = NgSetupResponse;
    type Failure = NgSetupFailure;
    const CODE: u8 = 21;

    async fn call_provider<T: RequestProvider<Self>>(
        provider: &T,
        req: NgSetupRequest,
        logger: &Logger,
    ) -> Option<NgapPdu> {
        match <T as RequestProvider<NgSetupProcedure>>::request(provider, req, logger).await {
            Ok(x) => Some(NgapPdu::SuccessfulOutcome(
                SuccessfulOutcome::NgSetupResponse(x),
            )),
            Err(_) => todo!(),
        }
    }

    fn encode_request(r: Self::Request) -> Result<Vec<u8>, AperCodecError> {
        NgapPdu::InitiatingMessage(InitiatingMessage::NgSetupRequest(r)).into_bytes()
    }

    fn decode_response(bytes: &[u8]) -> Result<Self::Success, RequestError<Self::Failure>> {
        let response_pdu = Self::TopPdu::from_bytes(bytes)?;
        match response_pdu {
            NgapPdu::SuccessfulOutcome(SuccessfulOutcome::NgSetupResponse(x)) => Ok(x),
            NgapPdu::UnsuccessfulOutcome(UnsuccessfulOutcome::NgSetupFailure(x)) => {
                Err(RequestError::UnsuccessfulOutcome(x))
            }
            _ => Err(RequestError::Other("Unexpected pdu contents".to_string())),
        }
    }
}

pub struct OverloadStartProcedure {}

#[async_trait]
impl Procedure for OverloadStartProcedure {
    type TopPdu = NgapPdu;
    type Request = OverloadStart;
    type Success = ();
    type Failure = ();
    const CODE: u8 = 22;

    async fn call_provider<T: RequestProvider<Self>>(
        provider: &T,
        req: OverloadStart,
        logger: &Logger,
    ) -> Option<NgapPdu> {
        match <T as RequestProvider<OverloadStartProcedure>>::request(provider, req, logger).await {
            Ok(_) => None,
            Err(_) => todo!(),
        }
    }

    fn encode_request(r: Self::Request) -> Result<Vec<u8>, AperCodecError> {
        NgapPdu::InitiatingMessage(InitiatingMessage::OverloadStart(r)).into_bytes()
    }

    fn decode_response(_bytes: &[u8]) -> Result<Self::Success, RequestError<Self::Failure>> {
        Err(RequestError::Other(
            "No response is defined for OverloadStart!".to_string(),
        ))
    }
}

pub struct OverloadStopProcedure {}

#[async_trait]
impl Procedure for OverloadStopProcedure {
    type TopPdu = NgapPdu;
    type Request = OverloadStop;
    type Success = ();
    type Failure = ();
    const CODE: u8 = 23;

    async fn call_provider<T: RequestProvider<Self>>(
        provider: &T,
        req: OverloadStop,
        logger: &Logger,
    ) -> Option<NgapPdu> {
        match <T as RequestProvider<OverloadStopProcedure>>::request(provider, req, logger).await {
            Ok(_) => None,
            Err(_) => todo!(),
        }
    }

    fn encode_request(r: Self::Request) -> Result<Vec<u8>, AperCodecError> {
        NgapPdu::InitiatingMessage(InitiatingMessage::OverloadStop(r)).into_bytes()
    }

    fn decode_response(_bytes: &[u8]) -> Result<Self::Success, RequestError<Self::Failure>> {
        Err(RequestError::Other(
            "No response is defined for OverloadStop!".to_string(),
        ))
    }
}

pub struct PagingProcedure {}

#[async_trait]
impl Procedure for PagingProcedure {
    type TopPdu = NgapPdu;
    type Request = Paging;
    type Success = ();
    type Failure = ();
    const CODE: u8 = 24;

    async fn call_provider<T: RequestProvider<Self>>(
        provider: &T,
        req: Paging,
        logger: &Logger,
    ) -> Option<NgapPdu> {
        match <T as RequestProvider<PagingProcedure>>::request(provider, req, logger).await {
            Ok(_) => None,
            Err(_) => todo!(),
        }
    }

    fn encode_request(r: Self::Request) -> Result<Vec<u8>, AperCodecError> {
        NgapPdu::InitiatingMessage(InitiatingMessage::Paging(r)).into_bytes()
    }

    fn decode_response(_bytes: &[u8]) -> Result<Self::Success, RequestError<Self::Failure>> {
        Err(RequestError::Other(
            "No response is defined for Paging!".to_string(),
        ))
    }
}

pub struct PathSwitchRequestProcedure {}

#[async_trait]
impl Procedure for PathSwitchRequestProcedure {
    type TopPdu = NgapPdu;
    type Request = PathSwitchRequest;
    type Success = PathSwitchRequestAcknowledge;
    type Failure = PathSwitchRequestFailure;
    const CODE: u8 = 25;

    async fn call_provider<T: RequestProvider<Self>>(
        provider: &T,
        req: PathSwitchRequest,
        logger: &Logger,
    ) -> Option<NgapPdu> {
        match <T as RequestProvider<PathSwitchRequestProcedure>>::request(provider, req, logger)
            .await
        {
            Ok(x) => Some(NgapPdu::SuccessfulOutcome(
                SuccessfulOutcome::PathSwitchRequestAcknowledge(x),
            )),
            Err(_) => todo!(),
        }
    }

    fn encode_request(r: Self::Request) -> Result<Vec<u8>, AperCodecError> {
        NgapPdu::InitiatingMessage(InitiatingMessage::PathSwitchRequest(r)).into_bytes()
    }

    fn decode_response(bytes: &[u8]) -> Result<Self::Success, RequestError<Self::Failure>> {
        let response_pdu = Self::TopPdu::from_bytes(bytes)?;
        match response_pdu {
            NgapPdu::SuccessfulOutcome(SuccessfulOutcome::PathSwitchRequestAcknowledge(x)) => Ok(x),
            NgapPdu::UnsuccessfulOutcome(UnsuccessfulOutcome::PathSwitchRequestFailure(x)) => {
                Err(RequestError::UnsuccessfulOutcome(x))
            }
            _ => Err(RequestError::Other("Unexpected pdu contents".to_string())),
        }
    }
}

pub struct PduSessionResourceModifyProcedure {}

#[async_trait]
impl Procedure for PduSessionResourceModifyProcedure {
    type TopPdu = NgapPdu;
    type Request = PduSessionResourceModifyRequest;
    type Success = PduSessionResourceModifyResponse;
    type Failure = ();
    const CODE: u8 = 26;

    async fn call_provider<T: RequestProvider<Self>>(
        provider: &T,
        req: PduSessionResourceModifyRequest,
        logger: &Logger,
    ) -> Option<NgapPdu> {
        match <T as RequestProvider<PduSessionResourceModifyProcedure>>::request(
            provider, req, logger,
        )
        .await
        {
            Ok(x) => Some(NgapPdu::SuccessfulOutcome(
                SuccessfulOutcome::PduSessionResourceModifyResponse(x),
            )),
            Err(_) => todo!(),
        }
    }

    fn encode_request(r: Self::Request) -> Result<Vec<u8>, AperCodecError> {
        NgapPdu::InitiatingMessage(InitiatingMessage::PduSessionResourceModifyRequest(r))
            .into_bytes()
    }

    fn decode_response(bytes: &[u8]) -> Result<Self::Success, RequestError<Self::Failure>> {
        let response_pdu = Self::TopPdu::from_bytes(bytes)?;
        match response_pdu {
            NgapPdu::SuccessfulOutcome(SuccessfulOutcome::PduSessionResourceModifyResponse(x)) => {
                Ok(x)
            }

            _ => Err(RequestError::Other("Unexpected pdu contents".to_string())),
        }
    }
}

pub struct PduSessionResourceModifyIndicationProcedure {}

#[async_trait]
impl Procedure for PduSessionResourceModifyIndicationProcedure {
    type TopPdu = NgapPdu;
    type Request = PduSessionResourceModifyIndication;
    type Success = PduSessionResourceModifyConfirm;
    type Failure = ();
    const CODE: u8 = 27;

    async fn call_provider<T: RequestProvider<Self>>(
        provider: &T,
        req: PduSessionResourceModifyIndication,
        logger: &Logger,
    ) -> Option<NgapPdu> {
        match <T as RequestProvider<PduSessionResourceModifyIndicationProcedure>>::request(
            provider, req, logger,
        )
        .await
        {
            Ok(x) => Some(NgapPdu::SuccessfulOutcome(
                SuccessfulOutcome::PduSessionResourceModifyConfirm(x),
            )),
            Err(_) => todo!(),
        }
    }

    fn encode_request(r: Self::Request) -> Result<Vec<u8>, AperCodecError> {
        NgapPdu::InitiatingMessage(InitiatingMessage::PduSessionResourceModifyIndication(r))
            .into_bytes()
    }

    fn decode_response(bytes: &[u8]) -> Result<Self::Success, RequestError<Self::Failure>> {
        let response_pdu = Self::TopPdu::from_bytes(bytes)?;
        match response_pdu {
            NgapPdu::SuccessfulOutcome(SuccessfulOutcome::PduSessionResourceModifyConfirm(x)) => {
                Ok(x)
            }

            _ => Err(RequestError::Other("Unexpected pdu contents".to_string())),
        }
    }
}

pub struct PduSessionResourceNotifyProcedure {}

#[async_trait]
impl Procedure for PduSessionResourceNotifyProcedure {
    type TopPdu = NgapPdu;
    type Request = PduSessionResourceNotify;
    type Success = ();
    type Failure = ();
    const CODE: u8 = 30;

    async fn call_provider<T: RequestProvider<Self>>(
        provider: &T,
        req: PduSessionResourceNotify,
        logger: &Logger,
    ) -> Option<NgapPdu> {
        match <T as RequestProvider<PduSessionResourceNotifyProcedure>>::request(
            provider, req, logger,
        )
        .await
        {
            Ok(_) => None,
            Err(_) => todo!(),
        }
    }

    fn encode_request(r: Self::Request) -> Result<Vec<u8>, AperCodecError> {
        NgapPdu::InitiatingMessage(InitiatingMessage::PduSessionResourceNotify(r)).into_bytes()
    }

    fn decode_response(_bytes: &[u8]) -> Result<Self::Success, RequestError<Self::Failure>> {
        Err(RequestError::Other(
            "No response is defined for PduSessionResourceNotify!".to_string(),
        ))
    }
}

pub struct PduSessionResourceReleaseProcedure {}

#[async_trait]
impl Procedure for PduSessionResourceReleaseProcedure {
    type TopPdu = NgapPdu;
    type Request = PduSessionResourceReleaseCommand;
    type Success = PduSessionResourceReleaseResponse;
    type Failure = ();
    const CODE: u8 = 28;

    async fn call_provider<T: RequestProvider<Self>>(
        provider: &T,
        req: PduSessionResourceReleaseCommand,
        logger: &Logger,
    ) -> Option<NgapPdu> {
        match <T as RequestProvider<PduSessionResourceReleaseProcedure>>::request(
            provider, req, logger,
        )
        .await
        {
            Ok(x) => Some(NgapPdu::SuccessfulOutcome(
                SuccessfulOutcome::PduSessionResourceReleaseResponse(x),
            )),
            Err(_) => todo!(),
        }
    }

    fn encode_request(r: Self::Request) -> Result<Vec<u8>, AperCodecError> {
        NgapPdu::InitiatingMessage(InitiatingMessage::PduSessionResourceReleaseCommand(r))
            .into_bytes()
    }

    fn decode_response(bytes: &[u8]) -> Result<Self::Success, RequestError<Self::Failure>> {
        let response_pdu = Self::TopPdu::from_bytes(bytes)?;
        match response_pdu {
            NgapPdu::SuccessfulOutcome(SuccessfulOutcome::PduSessionResourceReleaseResponse(x)) => {
                Ok(x)
            }

            _ => Err(RequestError::Other("Unexpected pdu contents".to_string())),
        }
    }
}

pub struct PduSessionResourceSetupProcedure {}

#[async_trait]
impl Procedure for PduSessionResourceSetupProcedure {
    type TopPdu = NgapPdu;
    type Request = PduSessionResourceSetupRequest;
    type Success = PduSessionResourceSetupResponse;
    type Failure = ();
    const CODE: u8 = 29;

    async fn call_provider<T: RequestProvider<Self>>(
        provider: &T,
        req: PduSessionResourceSetupRequest,
        logger: &Logger,
    ) -> Option<NgapPdu> {
        match <T as RequestProvider<PduSessionResourceSetupProcedure>>::request(
            provider, req, logger,
        )
        .await
        {
            Ok(x) => Some(NgapPdu::SuccessfulOutcome(
                SuccessfulOutcome::PduSessionResourceSetupResponse(x),
            )),
            Err(_) => todo!(),
        }
    }

    fn encode_request(r: Self::Request) -> Result<Vec<u8>, AperCodecError> {
        NgapPdu::InitiatingMessage(InitiatingMessage::PduSessionResourceSetupRequest(r))
            .into_bytes()
    }

    fn decode_response(bytes: &[u8]) -> Result<Self::Success, RequestError<Self::Failure>> {
        let response_pdu = Self::TopPdu::from_bytes(bytes)?;
        match response_pdu {
            NgapPdu::SuccessfulOutcome(SuccessfulOutcome::PduSessionResourceSetupResponse(x)) => {
                Ok(x)
            }

            _ => Err(RequestError::Other("Unexpected pdu contents".to_string())),
        }
    }
}

pub struct PwsCancelProcedure {}

#[async_trait]
impl Procedure for PwsCancelProcedure {
    type TopPdu = NgapPdu;
    type Request = PwsCancelRequest;
    type Success = PwsCancelResponse;
    type Failure = ();
    const CODE: u8 = 32;

    async fn call_provider<T: RequestProvider<Self>>(
        provider: &T,
        req: PwsCancelRequest,
        logger: &Logger,
    ) -> Option<NgapPdu> {
        match <T as RequestProvider<PwsCancelProcedure>>::request(provider, req, logger).await {
            Ok(x) => Some(NgapPdu::SuccessfulOutcome(
                SuccessfulOutcome::PwsCancelResponse(x),
            )),
            Err(_) => todo!(),
        }
    }

    fn encode_request(r: Self::Request) -> Result<Vec<u8>, AperCodecError> {
        NgapPdu::InitiatingMessage(InitiatingMessage::PwsCancelRequest(r)).into_bytes()
    }

    fn decode_response(bytes: &[u8]) -> Result<Self::Success, RequestError<Self::Failure>> {
        let response_pdu = Self::TopPdu::from_bytes(bytes)?;
        match response_pdu {
            NgapPdu::SuccessfulOutcome(SuccessfulOutcome::PwsCancelResponse(x)) => Ok(x),

            _ => Err(RequestError::Other("Unexpected pdu contents".to_string())),
        }
    }
}

pub struct PwsFailureIndicationProcedure {}

#[async_trait]
impl Procedure for PwsFailureIndicationProcedure {
    type TopPdu = NgapPdu;
    type Request = PwsFailureIndication;
    type Success = ();
    type Failure = ();
    const CODE: u8 = 33;

    async fn call_provider<T: RequestProvider<Self>>(
        provider: &T,
        req: PwsFailureIndication,
        logger: &Logger,
    ) -> Option<NgapPdu> {
        match <T as RequestProvider<PwsFailureIndicationProcedure>>::request(provider, req, logger)
            .await
        {
            Ok(_) => None,
            Err(_) => todo!(),
        }
    }

    fn encode_request(r: Self::Request) -> Result<Vec<u8>, AperCodecError> {
        NgapPdu::InitiatingMessage(InitiatingMessage::PwsFailureIndication(r)).into_bytes()
    }

    fn decode_response(_bytes: &[u8]) -> Result<Self::Success, RequestError<Self::Failure>> {
        Err(RequestError::Other(
            "No response is defined for PwsFailureIndication!".to_string(),
        ))
    }
}

pub struct PwsRestartIndicationProcedure {}

#[async_trait]
impl Procedure for PwsRestartIndicationProcedure {
    type TopPdu = NgapPdu;
    type Request = PwsRestartIndication;
    type Success = ();
    type Failure = ();
    const CODE: u8 = 34;

    async fn call_provider<T: RequestProvider<Self>>(
        provider: &T,
        req: PwsRestartIndication,
        logger: &Logger,
    ) -> Option<NgapPdu> {
        match <T as RequestProvider<PwsRestartIndicationProcedure>>::request(provider, req, logger)
            .await
        {
            Ok(_) => None,
            Err(_) => todo!(),
        }
    }

    fn encode_request(r: Self::Request) -> Result<Vec<u8>, AperCodecError> {
        NgapPdu::InitiatingMessage(InitiatingMessage::PwsRestartIndication(r)).into_bytes()
    }

    fn decode_response(_bytes: &[u8]) -> Result<Self::Success, RequestError<Self::Failure>> {
        Err(RequestError::Other(
            "No response is defined for PwsRestartIndication!".to_string(),
        ))
    }
}

pub struct RanConfigurationUpdateProcedure {}

#[async_trait]
impl Procedure for RanConfigurationUpdateProcedure {
    type TopPdu = NgapPdu;
    type Request = RanConfigurationUpdate;
    type Success = RanConfigurationUpdateAcknowledge;
    type Failure = RanConfigurationUpdateFailure;
    const CODE: u8 = 35;

    async fn call_provider<T: RequestProvider<Self>>(
        provider: &T,
        req: RanConfigurationUpdate,
        logger: &Logger,
    ) -> Option<NgapPdu> {
        match <T as RequestProvider<RanConfigurationUpdateProcedure>>::request(
            provider, req, logger,
        )
        .await
        {
            Ok(x) => Some(NgapPdu::SuccessfulOutcome(
                SuccessfulOutcome::RanConfigurationUpdateAcknowledge(x),
            )),
            Err(_) => todo!(),
        }
    }

    fn encode_request(r: Self::Request) -> Result<Vec<u8>, AperCodecError> {
        NgapPdu::InitiatingMessage(InitiatingMessage::RanConfigurationUpdate(r)).into_bytes()
    }

    fn decode_response(bytes: &[u8]) -> Result<Self::Success, RequestError<Self::Failure>> {
        let response_pdu = Self::TopPdu::from_bytes(bytes)?;
        match response_pdu {
            NgapPdu::SuccessfulOutcome(SuccessfulOutcome::RanConfigurationUpdateAcknowledge(x)) => {
                Ok(x)
            }
            NgapPdu::UnsuccessfulOutcome(UnsuccessfulOutcome::RanConfigurationUpdateFailure(x)) => {
                Err(RequestError::UnsuccessfulOutcome(x))
            }
            _ => Err(RequestError::Other("Unexpected pdu contents".to_string())),
        }
    }
}

pub struct RancpRelocationIndicationProcedure {}

#[async_trait]
impl Procedure for RancpRelocationIndicationProcedure {
    type TopPdu = NgapPdu;
    type Request = RancpRelocationIndication;
    type Success = ();
    type Failure = ();
    const CODE: u8 = 57;

    async fn call_provider<T: RequestProvider<Self>>(
        provider: &T,
        req: RancpRelocationIndication,
        logger: &Logger,
    ) -> Option<NgapPdu> {
        match <T as RequestProvider<RancpRelocationIndicationProcedure>>::request(
            provider, req, logger,
        )
        .await
        {
            Ok(_) => None,
            Err(_) => todo!(),
        }
    }

    fn encode_request(r: Self::Request) -> Result<Vec<u8>, AperCodecError> {
        NgapPdu::InitiatingMessage(InitiatingMessage::RancpRelocationIndication(r)).into_bytes()
    }

    fn decode_response(_bytes: &[u8]) -> Result<Self::Success, RequestError<Self::Failure>> {
        Err(RequestError::Other(
            "No response is defined for RancpRelocationIndication!".to_string(),
        ))
    }
}

pub struct RerouteNasRequestProcedure {}

#[async_trait]
impl Procedure for RerouteNasRequestProcedure {
    type TopPdu = NgapPdu;
    type Request = RerouteNasRequest;
    type Success = ();
    type Failure = ();
    const CODE: u8 = 36;

    async fn call_provider<T: RequestProvider<Self>>(
        provider: &T,
        req: RerouteNasRequest,
        logger: &Logger,
    ) -> Option<NgapPdu> {
        match <T as RequestProvider<RerouteNasRequestProcedure>>::request(provider, req, logger)
            .await
        {
            Ok(_) => None,
            Err(_) => todo!(),
        }
    }

    fn encode_request(r: Self::Request) -> Result<Vec<u8>, AperCodecError> {
        NgapPdu::InitiatingMessage(InitiatingMessage::RerouteNasRequest(r)).into_bytes()
    }

    fn decode_response(_bytes: &[u8]) -> Result<Self::Success, RequestError<Self::Failure>> {
        Err(RequestError::Other(
            "No response is defined for RerouteNasRequest!".to_string(),
        ))
    }
}

pub struct RetrieveUeInformationProcedure {}

#[async_trait]
impl Procedure for RetrieveUeInformationProcedure {
    type TopPdu = NgapPdu;
    type Request = RetrieveUeInformation;
    type Success = ();
    type Failure = ();
    const CODE: u8 = 55;

    async fn call_provider<T: RequestProvider<Self>>(
        provider: &T,
        req: RetrieveUeInformation,
        logger: &Logger,
    ) -> Option<NgapPdu> {
        match <T as RequestProvider<RetrieveUeInformationProcedure>>::request(provider, req, logger)
            .await
        {
            Ok(_) => None,
            Err(_) => todo!(),
        }
    }

    fn encode_request(r: Self::Request) -> Result<Vec<u8>, AperCodecError> {
        NgapPdu::InitiatingMessage(InitiatingMessage::RetrieveUeInformation(r)).into_bytes()
    }

    fn decode_response(_bytes: &[u8]) -> Result<Self::Success, RequestError<Self::Failure>> {
        Err(RequestError::Other(
            "No response is defined for RetrieveUeInformation!".to_string(),
        ))
    }
}

pub struct RrcInactiveTransitionReportProcedure {}

#[async_trait]
impl Procedure for RrcInactiveTransitionReportProcedure {
    type TopPdu = NgapPdu;
    type Request = RrcInactiveTransitionReport;
    type Success = ();
    type Failure = ();
    const CODE: u8 = 37;

    async fn call_provider<T: RequestProvider<Self>>(
        provider: &T,
        req: RrcInactiveTransitionReport,
        logger: &Logger,
    ) -> Option<NgapPdu> {
        match <T as RequestProvider<RrcInactiveTransitionReportProcedure>>::request(
            provider, req, logger,
        )
        .await
        {
            Ok(_) => None,
            Err(_) => todo!(),
        }
    }

    fn encode_request(r: Self::Request) -> Result<Vec<u8>, AperCodecError> {
        NgapPdu::InitiatingMessage(InitiatingMessage::RrcInactiveTransitionReport(r)).into_bytes()
    }

    fn decode_response(_bytes: &[u8]) -> Result<Self::Success, RequestError<Self::Failure>> {
        Err(RequestError::Other(
            "No response is defined for RrcInactiveTransitionReport!".to_string(),
        ))
    }
}

pub struct SecondaryRatDataUsageReportProcedure {}

#[async_trait]
impl Procedure for SecondaryRatDataUsageReportProcedure {
    type TopPdu = NgapPdu;
    type Request = SecondaryRatDataUsageReport;
    type Success = ();
    type Failure = ();
    const CODE: u8 = 52;

    async fn call_provider<T: RequestProvider<Self>>(
        provider: &T,
        req: SecondaryRatDataUsageReport,
        logger: &Logger,
    ) -> Option<NgapPdu> {
        match <T as RequestProvider<SecondaryRatDataUsageReportProcedure>>::request(
            provider, req, logger,
        )
        .await
        {
            Ok(_) => None,
            Err(_) => todo!(),
        }
    }

    fn encode_request(r: Self::Request) -> Result<Vec<u8>, AperCodecError> {
        NgapPdu::InitiatingMessage(InitiatingMessage::SecondaryRatDataUsageReport(r)).into_bytes()
    }

    fn decode_response(_bytes: &[u8]) -> Result<Self::Success, RequestError<Self::Failure>> {
        Err(RequestError::Other(
            "No response is defined for SecondaryRatDataUsageReport!".to_string(),
        ))
    }
}

pub struct TraceFailureIndicationProcedure {}

#[async_trait]
impl Procedure for TraceFailureIndicationProcedure {
    type TopPdu = NgapPdu;
    type Request = TraceFailureIndication;
    type Success = ();
    type Failure = ();
    const CODE: u8 = 38;

    async fn call_provider<T: RequestProvider<Self>>(
        provider: &T,
        req: TraceFailureIndication,
        logger: &Logger,
    ) -> Option<NgapPdu> {
        match <T as RequestProvider<TraceFailureIndicationProcedure>>::request(
            provider, req, logger,
        )
        .await
        {
            Ok(_) => None,
            Err(_) => todo!(),
        }
    }

    fn encode_request(r: Self::Request) -> Result<Vec<u8>, AperCodecError> {
        NgapPdu::InitiatingMessage(InitiatingMessage::TraceFailureIndication(r)).into_bytes()
    }

    fn decode_response(_bytes: &[u8]) -> Result<Self::Success, RequestError<Self::Failure>> {
        Err(RequestError::Other(
            "No response is defined for TraceFailureIndication!".to_string(),
        ))
    }
}

pub struct TraceStartProcedure {}

#[async_trait]
impl Procedure for TraceStartProcedure {
    type TopPdu = NgapPdu;
    type Request = TraceStart;
    type Success = ();
    type Failure = ();
    const CODE: u8 = 39;

    async fn call_provider<T: RequestProvider<Self>>(
        provider: &T,
        req: TraceStart,
        logger: &Logger,
    ) -> Option<NgapPdu> {
        match <T as RequestProvider<TraceStartProcedure>>::request(provider, req, logger).await {
            Ok(_) => None,
            Err(_) => todo!(),
        }
    }

    fn encode_request(r: Self::Request) -> Result<Vec<u8>, AperCodecError> {
        NgapPdu::InitiatingMessage(InitiatingMessage::TraceStart(r)).into_bytes()
    }

    fn decode_response(_bytes: &[u8]) -> Result<Self::Success, RequestError<Self::Failure>> {
        Err(RequestError::Other(
            "No response is defined for TraceStart!".to_string(),
        ))
    }
}

pub struct UeContextModificationProcedure {}

#[async_trait]
impl Procedure for UeContextModificationProcedure {
    type TopPdu = NgapPdu;
    type Request = UeContextModificationRequest;
    type Success = UeContextModificationResponse;
    type Failure = UeContextModificationFailure;
    const CODE: u8 = 40;

    async fn call_provider<T: RequestProvider<Self>>(
        provider: &T,
        req: UeContextModificationRequest,
        logger: &Logger,
    ) -> Option<NgapPdu> {
        match <T as RequestProvider<UeContextModificationProcedure>>::request(provider, req, logger)
            .await
        {
            Ok(x) => Some(NgapPdu::SuccessfulOutcome(
                SuccessfulOutcome::UeContextModificationResponse(x),
            )),
            Err(_) => todo!(),
        }
    }

    fn encode_request(r: Self::Request) -> Result<Vec<u8>, AperCodecError> {
        NgapPdu::InitiatingMessage(InitiatingMessage::UeContextModificationRequest(r)).into_bytes()
    }

    fn decode_response(bytes: &[u8]) -> Result<Self::Success, RequestError<Self::Failure>> {
        let response_pdu = Self::TopPdu::from_bytes(bytes)?;
        match response_pdu {
            NgapPdu::SuccessfulOutcome(SuccessfulOutcome::UeContextModificationResponse(x)) => {
                Ok(x)
            }
            NgapPdu::UnsuccessfulOutcome(UnsuccessfulOutcome::UeContextModificationFailure(x)) => {
                Err(RequestError::UnsuccessfulOutcome(x))
            }
            _ => Err(RequestError::Other("Unexpected pdu contents".to_string())),
        }
    }
}

pub struct UeContextReleaseProcedure {}

#[async_trait]
impl Procedure for UeContextReleaseProcedure {
    type TopPdu = NgapPdu;
    type Request = UeContextReleaseCommand;
    type Success = UeContextReleaseComplete;
    type Failure = ();
    const CODE: u8 = 41;

    async fn call_provider<T: RequestProvider<Self>>(
        provider: &T,
        req: UeContextReleaseCommand,
        logger: &Logger,
    ) -> Option<NgapPdu> {
        match <T as RequestProvider<UeContextReleaseProcedure>>::request(provider, req, logger)
            .await
        {
            Ok(x) => Some(NgapPdu::SuccessfulOutcome(
                SuccessfulOutcome::UeContextReleaseComplete(x),
            )),
            Err(_) => todo!(),
        }
    }

    fn encode_request(r: Self::Request) -> Result<Vec<u8>, AperCodecError> {
        NgapPdu::InitiatingMessage(InitiatingMessage::UeContextReleaseCommand(r)).into_bytes()
    }

    fn decode_response(bytes: &[u8]) -> Result<Self::Success, RequestError<Self::Failure>> {
        let response_pdu = Self::TopPdu::from_bytes(bytes)?;
        match response_pdu {
            NgapPdu::SuccessfulOutcome(SuccessfulOutcome::UeContextReleaseComplete(x)) => Ok(x),

            _ => Err(RequestError::Other("Unexpected pdu contents".to_string())),
        }
    }
}

pub struct UeContextReleaseRequestProcedure {}

#[async_trait]
impl Procedure for UeContextReleaseRequestProcedure {
    type TopPdu = NgapPdu;
    type Request = UeContextReleaseRequest;
    type Success = ();
    type Failure = ();
    const CODE: u8 = 42;

    async fn call_provider<T: RequestProvider<Self>>(
        provider: &T,
        req: UeContextReleaseRequest,
        logger: &Logger,
    ) -> Option<NgapPdu> {
        match <T as RequestProvider<UeContextReleaseRequestProcedure>>::request(
            provider, req, logger,
        )
        .await
        {
            Ok(_) => None,
            Err(_) => todo!(),
        }
    }

    fn encode_request(r: Self::Request) -> Result<Vec<u8>, AperCodecError> {
        NgapPdu::InitiatingMessage(InitiatingMessage::UeContextReleaseRequest(r)).into_bytes()
    }

    fn decode_response(_bytes: &[u8]) -> Result<Self::Success, RequestError<Self::Failure>> {
        Err(RequestError::Other(
            "No response is defined for UeContextReleaseRequest!".to_string(),
        ))
    }
}

pub struct UeContextResumeProcedure {}

#[async_trait]
impl Procedure for UeContextResumeProcedure {
    type TopPdu = NgapPdu;
    type Request = UeContextResumeRequest;
    type Success = UeContextResumeResponse;
    type Failure = UeContextResumeFailure;
    const CODE: u8 = 58;

    async fn call_provider<T: RequestProvider<Self>>(
        provider: &T,
        req: UeContextResumeRequest,
        logger: &Logger,
    ) -> Option<NgapPdu> {
        match <T as RequestProvider<UeContextResumeProcedure>>::request(provider, req, logger).await
        {
            Ok(x) => Some(NgapPdu::SuccessfulOutcome(
                SuccessfulOutcome::UeContextResumeResponse(x),
            )),
            Err(_) => todo!(),
        }
    }

    fn encode_request(r: Self::Request) -> Result<Vec<u8>, AperCodecError> {
        NgapPdu::InitiatingMessage(InitiatingMessage::UeContextResumeRequest(r)).into_bytes()
    }

    fn decode_response(bytes: &[u8]) -> Result<Self::Success, RequestError<Self::Failure>> {
        let response_pdu = Self::TopPdu::from_bytes(bytes)?;
        match response_pdu {
            NgapPdu::SuccessfulOutcome(SuccessfulOutcome::UeContextResumeResponse(x)) => Ok(x),
            NgapPdu::UnsuccessfulOutcome(UnsuccessfulOutcome::UeContextResumeFailure(x)) => {
                Err(RequestError::UnsuccessfulOutcome(x))
            }
            _ => Err(RequestError::Other("Unexpected pdu contents".to_string())),
        }
    }
}

pub struct UeContextSuspendProcedure {}

#[async_trait]
impl Procedure for UeContextSuspendProcedure {
    type TopPdu = NgapPdu;
    type Request = UeContextSuspendRequest;
    type Success = UeContextSuspendResponse;
    type Failure = UeContextSuspendFailure;
    const CODE: u8 = 59;

    async fn call_provider<T: RequestProvider<Self>>(
        provider: &T,
        req: UeContextSuspendRequest,
        logger: &Logger,
    ) -> Option<NgapPdu> {
        match <T as RequestProvider<UeContextSuspendProcedure>>::request(provider, req, logger)
            .await
        {
            Ok(x) => Some(NgapPdu::SuccessfulOutcome(
                SuccessfulOutcome::UeContextSuspendResponse(x),
            )),
            Err(_) => todo!(),
        }
    }

    fn encode_request(r: Self::Request) -> Result<Vec<u8>, AperCodecError> {
        NgapPdu::InitiatingMessage(InitiatingMessage::UeContextSuspendRequest(r)).into_bytes()
    }

    fn decode_response(bytes: &[u8]) -> Result<Self::Success, RequestError<Self::Failure>> {
        let response_pdu = Self::TopPdu::from_bytes(bytes)?;
        match response_pdu {
            NgapPdu::SuccessfulOutcome(SuccessfulOutcome::UeContextSuspendResponse(x)) => Ok(x),
            NgapPdu::UnsuccessfulOutcome(UnsuccessfulOutcome::UeContextSuspendFailure(x)) => {
                Err(RequestError::UnsuccessfulOutcome(x))
            }
            _ => Err(RequestError::Other("Unexpected pdu contents".to_string())),
        }
    }
}

pub struct UeInformationTransferProcedure {}

#[async_trait]
impl Procedure for UeInformationTransferProcedure {
    type TopPdu = NgapPdu;
    type Request = UeInformationTransfer;
    type Success = ();
    type Failure = ();
    const CODE: u8 = 56;

    async fn call_provider<T: RequestProvider<Self>>(
        provider: &T,
        req: UeInformationTransfer,
        logger: &Logger,
    ) -> Option<NgapPdu> {
        match <T as RequestProvider<UeInformationTransferProcedure>>::request(provider, req, logger)
            .await
        {
            Ok(_) => None,
            Err(_) => todo!(),
        }
    }

    fn encode_request(r: Self::Request) -> Result<Vec<u8>, AperCodecError> {
        NgapPdu::InitiatingMessage(InitiatingMessage::UeInformationTransfer(r)).into_bytes()
    }

    fn decode_response(_bytes: &[u8]) -> Result<Self::Success, RequestError<Self::Failure>> {
        Err(RequestError::Other(
            "No response is defined for UeInformationTransfer!".to_string(),
        ))
    }
}

pub struct UeRadioCapabilityCheckProcedure {}

#[async_trait]
impl Procedure for UeRadioCapabilityCheckProcedure {
    type TopPdu = NgapPdu;
    type Request = UeRadioCapabilityCheckRequest;
    type Success = UeRadioCapabilityCheckResponse;
    type Failure = ();
    const CODE: u8 = 43;

    async fn call_provider<T: RequestProvider<Self>>(
        provider: &T,
        req: UeRadioCapabilityCheckRequest,
        logger: &Logger,
    ) -> Option<NgapPdu> {
        match <T as RequestProvider<UeRadioCapabilityCheckProcedure>>::request(
            provider, req, logger,
        )
        .await
        {
            Ok(x) => Some(NgapPdu::SuccessfulOutcome(
                SuccessfulOutcome::UeRadioCapabilityCheckResponse(x),
            )),
            Err(_) => todo!(),
        }
    }

    fn encode_request(r: Self::Request) -> Result<Vec<u8>, AperCodecError> {
        NgapPdu::InitiatingMessage(InitiatingMessage::UeRadioCapabilityCheckRequest(r)).into_bytes()
    }

    fn decode_response(bytes: &[u8]) -> Result<Self::Success, RequestError<Self::Failure>> {
        let response_pdu = Self::TopPdu::from_bytes(bytes)?;
        match response_pdu {
            NgapPdu::SuccessfulOutcome(SuccessfulOutcome::UeRadioCapabilityCheckResponse(x)) => {
                Ok(x)
            }

            _ => Err(RequestError::Other("Unexpected pdu contents".to_string())),
        }
    }
}

pub struct UeRadioCapabilityIdMappingProcedure {}

#[async_trait]
impl Procedure for UeRadioCapabilityIdMappingProcedure {
    type TopPdu = NgapPdu;
    type Request = UeRadioCapabilityIdMappingRequest;
    type Success = UeRadioCapabilityIdMappingResponse;
    type Failure = ();
    const CODE: u8 = 60;

    async fn call_provider<T: RequestProvider<Self>>(
        provider: &T,
        req: UeRadioCapabilityIdMappingRequest,
        logger: &Logger,
    ) -> Option<NgapPdu> {
        match <T as RequestProvider<UeRadioCapabilityIdMappingProcedure>>::request(
            provider, req, logger,
        )
        .await
        {
            Ok(x) => Some(NgapPdu::SuccessfulOutcome(
                SuccessfulOutcome::UeRadioCapabilityIdMappingResponse(x),
            )),
            Err(_) => todo!(),
        }
    }

    fn encode_request(r: Self::Request) -> Result<Vec<u8>, AperCodecError> {
        NgapPdu::InitiatingMessage(InitiatingMessage::UeRadioCapabilityIdMappingRequest(r))
            .into_bytes()
    }

    fn decode_response(bytes: &[u8]) -> Result<Self::Success, RequestError<Self::Failure>> {
        let response_pdu = Self::TopPdu::from_bytes(bytes)?;
        match response_pdu {
            NgapPdu::SuccessfulOutcome(SuccessfulOutcome::UeRadioCapabilityIdMappingResponse(
                x,
            )) => Ok(x),

            _ => Err(RequestError::Other("Unexpected pdu contents".to_string())),
        }
    }
}

pub struct UeRadioCapabilityInfoIndicationProcedure {}

#[async_trait]
impl Procedure for UeRadioCapabilityInfoIndicationProcedure {
    type TopPdu = NgapPdu;
    type Request = UeRadioCapabilityInfoIndication;
    type Success = ();
    type Failure = ();
    const CODE: u8 = 44;

    async fn call_provider<T: RequestProvider<Self>>(
        provider: &T,
        req: UeRadioCapabilityInfoIndication,
        logger: &Logger,
    ) -> Option<NgapPdu> {
        match <T as RequestProvider<UeRadioCapabilityInfoIndicationProcedure>>::request(
            provider, req, logger,
        )
        .await
        {
            Ok(_) => None,
            Err(_) => todo!(),
        }
    }

    fn encode_request(r: Self::Request) -> Result<Vec<u8>, AperCodecError> {
        NgapPdu::InitiatingMessage(InitiatingMessage::UeRadioCapabilityInfoIndication(r))
            .into_bytes()
    }

    fn decode_response(_bytes: &[u8]) -> Result<Self::Success, RequestError<Self::Failure>> {
        Err(RequestError::Other(
            "No response is defined for UeRadioCapabilityInfoIndication!".to_string(),
        ))
    }
}

pub struct UetnlaBindingReleaseProcedure {}

#[async_trait]
impl Procedure for UetnlaBindingReleaseProcedure {
    type TopPdu = NgapPdu;
    type Request = UetnlaBindingReleaseRequest;
    type Success = ();
    type Failure = ();
    const CODE: u8 = 45;

    async fn call_provider<T: RequestProvider<Self>>(
        provider: &T,
        req: UetnlaBindingReleaseRequest,
        logger: &Logger,
    ) -> Option<NgapPdu> {
        match <T as RequestProvider<UetnlaBindingReleaseProcedure>>::request(provider, req, logger)
            .await
        {
            Ok(_) => None,
            Err(_) => todo!(),
        }
    }

    fn encode_request(r: Self::Request) -> Result<Vec<u8>, AperCodecError> {
        NgapPdu::InitiatingMessage(InitiatingMessage::UetnlaBindingReleaseRequest(r)).into_bytes()
    }

    fn decode_response(_bytes: &[u8]) -> Result<Self::Success, RequestError<Self::Failure>> {
        Err(RequestError::Other(
            "No response is defined for UetnlaBindingReleaseRequest!".to_string(),
        ))
    }
}

pub struct UplinkNasTransportProcedure {}

#[async_trait]
impl Procedure for UplinkNasTransportProcedure {
    type TopPdu = NgapPdu;
    type Request = UplinkNasTransport;
    type Success = ();
    type Failure = ();
    const CODE: u8 = 46;

    async fn call_provider<T: RequestProvider<Self>>(
        provider: &T,
        req: UplinkNasTransport,
        logger: &Logger,
    ) -> Option<NgapPdu> {
        match <T as RequestProvider<UplinkNasTransportProcedure>>::request(provider, req, logger)
            .await
        {
            Ok(_) => None,
            Err(_) => todo!(),
        }
    }

    fn encode_request(r: Self::Request) -> Result<Vec<u8>, AperCodecError> {
        NgapPdu::InitiatingMessage(InitiatingMessage::UplinkNasTransport(r)).into_bytes()
    }

    fn decode_response(_bytes: &[u8]) -> Result<Self::Success, RequestError<Self::Failure>> {
        Err(RequestError::Other(
            "No response is defined for UplinkNasTransport!".to_string(),
        ))
    }
}

pub struct UplinkNonUeAssociatedNrpPaTransportProcedure {}

#[async_trait]
impl Procedure for UplinkNonUeAssociatedNrpPaTransportProcedure {
    type TopPdu = NgapPdu;
    type Request = UplinkNonUeAssociatedNrpPaTransport;
    type Success = ();
    type Failure = ();
    const CODE: u8 = 47;

    async fn call_provider<T: RequestProvider<Self>>(
        provider: &T,
        req: UplinkNonUeAssociatedNrpPaTransport,
        logger: &Logger,
    ) -> Option<NgapPdu> {
        match <T as RequestProvider<UplinkNonUeAssociatedNrpPaTransportProcedure>>::request(
            provider, req, logger,
        )
        .await
        {
            Ok(_) => None,
            Err(_) => todo!(),
        }
    }

    fn encode_request(r: Self::Request) -> Result<Vec<u8>, AperCodecError> {
        NgapPdu::InitiatingMessage(InitiatingMessage::UplinkNonUeAssociatedNrpPaTransport(r))
            .into_bytes()
    }

    fn decode_response(_bytes: &[u8]) -> Result<Self::Success, RequestError<Self::Failure>> {
        Err(RequestError::Other(
            "No response is defined for UplinkNonUeAssociatedNrpPaTransport!".to_string(),
        ))
    }
}

pub struct UplinkRanConfigurationTransferProcedure {}

#[async_trait]
impl Procedure for UplinkRanConfigurationTransferProcedure {
    type TopPdu = NgapPdu;
    type Request = UplinkRanConfigurationTransfer;
    type Success = ();
    type Failure = ();
    const CODE: u8 = 48;

    async fn call_provider<T: RequestProvider<Self>>(
        provider: &T,
        req: UplinkRanConfigurationTransfer,
        logger: &Logger,
    ) -> Option<NgapPdu> {
        match <T as RequestProvider<UplinkRanConfigurationTransferProcedure>>::request(
            provider, req, logger,
        )
        .await
        {
            Ok(_) => None,
            Err(_) => todo!(),
        }
    }

    fn encode_request(r: Self::Request) -> Result<Vec<u8>, AperCodecError> {
        NgapPdu::InitiatingMessage(InitiatingMessage::UplinkRanConfigurationTransfer(r))
            .into_bytes()
    }

    fn decode_response(_bytes: &[u8]) -> Result<Self::Success, RequestError<Self::Failure>> {
        Err(RequestError::Other(
            "No response is defined for UplinkRanConfigurationTransfer!".to_string(),
        ))
    }
}

pub struct UplinkRanEarlyStatusTransferProcedure {}

#[async_trait]
impl Procedure for UplinkRanEarlyStatusTransferProcedure {
    type TopPdu = NgapPdu;
    type Request = UplinkRanEarlyStatusTransfer;
    type Success = ();
    type Failure = ();
    const CODE: u8 = 62;

    async fn call_provider<T: RequestProvider<Self>>(
        provider: &T,
        req: UplinkRanEarlyStatusTransfer,
        logger: &Logger,
    ) -> Option<NgapPdu> {
        match <T as RequestProvider<UplinkRanEarlyStatusTransferProcedure>>::request(
            provider, req, logger,
        )
        .await
        {
            Ok(_) => None,
            Err(_) => todo!(),
        }
    }

    fn encode_request(r: Self::Request) -> Result<Vec<u8>, AperCodecError> {
        NgapPdu::InitiatingMessage(InitiatingMessage::UplinkRanEarlyStatusTransfer(r)).into_bytes()
    }

    fn decode_response(_bytes: &[u8]) -> Result<Self::Success, RequestError<Self::Failure>> {
        Err(RequestError::Other(
            "No response is defined for UplinkRanEarlyStatusTransfer!".to_string(),
        ))
    }
}

pub struct UplinkRanStatusTransferProcedure {}

#[async_trait]
impl Procedure for UplinkRanStatusTransferProcedure {
    type TopPdu = NgapPdu;
    type Request = UplinkRanStatusTransfer;
    type Success = ();
    type Failure = ();
    const CODE: u8 = 49;

    async fn call_provider<T: RequestProvider<Self>>(
        provider: &T,
        req: UplinkRanStatusTransfer,
        logger: &Logger,
    ) -> Option<NgapPdu> {
        match <T as RequestProvider<UplinkRanStatusTransferProcedure>>::request(
            provider, req, logger,
        )
        .await
        {
            Ok(_) => None,
            Err(_) => todo!(),
        }
    }

    fn encode_request(r: Self::Request) -> Result<Vec<u8>, AperCodecError> {
        NgapPdu::InitiatingMessage(InitiatingMessage::UplinkRanStatusTransfer(r)).into_bytes()
    }

    fn decode_response(_bytes: &[u8]) -> Result<Self::Success, RequestError<Self::Failure>> {
        Err(RequestError::Other(
            "No response is defined for UplinkRanStatusTransfer!".to_string(),
        ))
    }
}

pub struct UplinkUeAssociatedNrpPaTransportProcedure {}

#[async_trait]
impl Procedure for UplinkUeAssociatedNrpPaTransportProcedure {
    type TopPdu = NgapPdu;
    type Request = UplinkUeAssociatedNrpPaTransport;
    type Success = ();
    type Failure = ();
    const CODE: u8 = 50;

    async fn call_provider<T: RequestProvider<Self>>(
        provider: &T,
        req: UplinkUeAssociatedNrpPaTransport,
        logger: &Logger,
    ) -> Option<NgapPdu> {
        match <T as RequestProvider<UplinkUeAssociatedNrpPaTransportProcedure>>::request(
            provider, req, logger,
        )
        .await
        {
            Ok(_) => None,
            Err(_) => todo!(),
        }
    }

    fn encode_request(r: Self::Request) -> Result<Vec<u8>, AperCodecError> {
        NgapPdu::InitiatingMessage(InitiatingMessage::UplinkUeAssociatedNrpPaTransport(r))
            .into_bytes()
    }

    fn decode_response(_bytes: &[u8]) -> Result<Self::Success, RequestError<Self::Failure>> {
        Err(RequestError::Other(
            "No response is defined for UplinkUeAssociatedNrpPaTransport!".to_string(),
        ))
    }
}

pub struct WriteReplaceWarningProcedure {}

#[async_trait]
impl Procedure for WriteReplaceWarningProcedure {
    type TopPdu = NgapPdu;
    type Request = WriteReplaceWarningRequest;
    type Success = WriteReplaceWarningResponse;
    type Failure = ();
    const CODE: u8 = 51;

    async fn call_provider<T: RequestProvider<Self>>(
        provider: &T,
        req: WriteReplaceWarningRequest,
        logger: &Logger,
    ) -> Option<NgapPdu> {
        match <T as RequestProvider<WriteReplaceWarningProcedure>>::request(provider, req, logger)
            .await
        {
            Ok(x) => Some(NgapPdu::SuccessfulOutcome(
                SuccessfulOutcome::WriteReplaceWarningResponse(x),
            )),
            Err(_) => todo!(),
        }
    }

    fn encode_request(r: Self::Request) -> Result<Vec<u8>, AperCodecError> {
        NgapPdu::InitiatingMessage(InitiatingMessage::WriteReplaceWarningRequest(r)).into_bytes()
    }

    fn decode_response(bytes: &[u8]) -> Result<Self::Success, RequestError<Self::Failure>> {
        let response_pdu = Self::TopPdu::from_bytes(bytes)?;
        match response_pdu {
            NgapPdu::SuccessfulOutcome(SuccessfulOutcome::WriteReplaceWarningResponse(x)) => Ok(x),

            _ => Err(RequestError::Other("Unexpected pdu contents".to_string())),
        }
    }
}

pub struct UplinkRimInformationTransferProcedure {}

#[async_trait]
impl Procedure for UplinkRimInformationTransferProcedure {
    type TopPdu = NgapPdu;
    type Request = UplinkRimInformationTransfer;
    type Success = ();
    type Failure = ();
    const CODE: u8 = 53;

    async fn call_provider<T: RequestProvider<Self>>(
        provider: &T,
        req: UplinkRimInformationTransfer,
        logger: &Logger,
    ) -> Option<NgapPdu> {
        match <T as RequestProvider<UplinkRimInformationTransferProcedure>>::request(
            provider, req, logger,
        )
        .await
        {
            Ok(_) => None,
            Err(_) => todo!(),
        }
    }

    fn encode_request(r: Self::Request) -> Result<Vec<u8>, AperCodecError> {
        NgapPdu::InitiatingMessage(InitiatingMessage::UplinkRimInformationTransfer(r)).into_bytes()
    }

    fn decode_response(_bytes: &[u8]) -> Result<Self::Success, RequestError<Self::Failure>> {
        Err(RequestError::Other(
            "No response is defined for UplinkRimInformationTransfer!".to_string(),
        ))
    }
}

pub struct DownlinkRimInformationTransferProcedure {}

#[async_trait]
impl Procedure for DownlinkRimInformationTransferProcedure {
    type TopPdu = NgapPdu;
    type Request = DownlinkRimInformationTransfer;
    type Success = ();
    type Failure = ();
    const CODE: u8 = 54;

    async fn call_provider<T: RequestProvider<Self>>(
        provider: &T,
        req: DownlinkRimInformationTransfer,
        logger: &Logger,
    ) -> Option<NgapPdu> {
        match <T as RequestProvider<DownlinkRimInformationTransferProcedure>>::request(
            provider, req, logger,
        )
        .await
        {
            Ok(_) => None,
            Err(_) => todo!(),
        }
    }

    fn encode_request(r: Self::Request) -> Result<Vec<u8>, AperCodecError> {
        NgapPdu::InitiatingMessage(InitiatingMessage::DownlinkRimInformationTransfer(r))
            .into_bytes()
    }

    fn decode_response(_bytes: &[u8]) -> Result<Self::Success, RequestError<Self::Failure>> {
        Err(RequestError::Other(
            "No response is defined for DownlinkRimInformationTransfer!".to_string(),
        ))
    }
}

#[derive(Clone, Debug)]
pub enum InitiatingMessage {
    AmfConfigurationUpdate(AmfConfigurationUpdate),
    AmfcpRelocationIndication(AmfcpRelocationIndication),
    AmfStatusIndication(AmfStatusIndication),
    CellTrafficTrace(CellTrafficTrace),
    ConnectionEstablishmentIndication(ConnectionEstablishmentIndication),
    DeactivateTrace(DeactivateTrace),
    DownlinkNasTransport(DownlinkNasTransport),
    DownlinkNonUeAssociatedNrpPaTransport(DownlinkNonUeAssociatedNrpPaTransport),
    DownlinkRanConfigurationTransfer(DownlinkRanConfigurationTransfer),
    DownlinkRanEarlyStatusTransfer(DownlinkRanEarlyStatusTransfer),
    DownlinkRanStatusTransfer(DownlinkRanStatusTransfer),
    DownlinkUeAssociatedNrpPaTransport(DownlinkUeAssociatedNrpPaTransport),
    ErrorIndication(ErrorIndication),
    HandoverCancel(HandoverCancel),
    HandoverNotify(HandoverNotify),
    HandoverRequired(HandoverRequired),
    HandoverRequest(HandoverRequest),
    HandoverSuccess(HandoverSuccess),
    InitialContextSetupRequest(InitialContextSetupRequest),
    InitialUeMessage(InitialUeMessage),
    LocationReport(LocationReport),
    LocationReportingControl(LocationReportingControl),
    LocationReportingFailureIndication(LocationReportingFailureIndication),
    NasNonDeliveryIndication(NasNonDeliveryIndication),
    NgReset(NgReset),
    NgSetupRequest(NgSetupRequest),
    OverloadStart(OverloadStart),
    OverloadStop(OverloadStop),
    Paging(Paging),
    PathSwitchRequest(PathSwitchRequest),
    PduSessionResourceModifyRequest(PduSessionResourceModifyRequest),
    PduSessionResourceModifyIndication(PduSessionResourceModifyIndication),
    PduSessionResourceNotify(PduSessionResourceNotify),
    PduSessionResourceReleaseCommand(PduSessionResourceReleaseCommand),
    PduSessionResourceSetupRequest(PduSessionResourceSetupRequest),
    PwsCancelRequest(PwsCancelRequest),
    PwsFailureIndication(PwsFailureIndication),
    PwsRestartIndication(PwsRestartIndication),
    RanConfigurationUpdate(RanConfigurationUpdate),
    RancpRelocationIndication(RancpRelocationIndication),
    RerouteNasRequest(RerouteNasRequest),
    RetrieveUeInformation(RetrieveUeInformation),
    RrcInactiveTransitionReport(RrcInactiveTransitionReport),
    SecondaryRatDataUsageReport(SecondaryRatDataUsageReport),
    TraceFailureIndication(TraceFailureIndication),
    TraceStart(TraceStart),
    UeContextModificationRequest(UeContextModificationRequest),
    UeContextReleaseCommand(UeContextReleaseCommand),
    UeContextReleaseRequest(UeContextReleaseRequest),
    UeContextResumeRequest(UeContextResumeRequest),
    UeContextSuspendRequest(UeContextSuspendRequest),
    UeInformationTransfer(UeInformationTransfer),
    UeRadioCapabilityCheckRequest(UeRadioCapabilityCheckRequest),
    UeRadioCapabilityIdMappingRequest(UeRadioCapabilityIdMappingRequest),
    UeRadioCapabilityInfoIndication(UeRadioCapabilityInfoIndication),
    UetnlaBindingReleaseRequest(UetnlaBindingReleaseRequest),
    UplinkNasTransport(UplinkNasTransport),
    UplinkNonUeAssociatedNrpPaTransport(UplinkNonUeAssociatedNrpPaTransport),
    UplinkRanConfigurationTransfer(UplinkRanConfigurationTransfer),
    UplinkRanEarlyStatusTransfer(UplinkRanEarlyStatusTransfer),
    UplinkRanStatusTransfer(UplinkRanStatusTransfer),
    UplinkUeAssociatedNrpPaTransport(UplinkUeAssociatedNrpPaTransport),
    WriteReplaceWarningRequest(WriteReplaceWarningRequest),
    UplinkRimInformationTransfer(UplinkRimInformationTransfer),
    DownlinkRimInformationTransfer(DownlinkRimInformationTransfer),
}

impl InitiatingMessage {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (id, _ext) = aper::decode::decode_integer(data, Some(0), Some(255), false)?;
        let _ = Criticality::decode(data)?;
        match id {
            0 => Ok(Self::AmfConfigurationUpdate(
                AmfConfigurationUpdate::decode(data)?,
            )),
            64 => Ok(Self::AmfcpRelocationIndication(
                AmfcpRelocationIndication::decode(data)?,
            )),
            1 => Ok(Self::AmfStatusIndication(AmfStatusIndication::decode(
                data,
            )?)),
            2 => Ok(Self::CellTrafficTrace(CellTrafficTrace::decode(data)?)),
            65 => Ok(Self::ConnectionEstablishmentIndication(
                ConnectionEstablishmentIndication::decode(data)?,
            )),
            3 => Ok(Self::DeactivateTrace(DeactivateTrace::decode(data)?)),
            4 => Ok(Self::DownlinkNasTransport(DownlinkNasTransport::decode(
                data,
            )?)),
            5 => Ok(Self::DownlinkNonUeAssociatedNrpPaTransport(
                DownlinkNonUeAssociatedNrpPaTransport::decode(data)?,
            )),
            6 => Ok(Self::DownlinkRanConfigurationTransfer(
                DownlinkRanConfigurationTransfer::decode(data)?,
            )),
            63 => Ok(Self::DownlinkRanEarlyStatusTransfer(
                DownlinkRanEarlyStatusTransfer::decode(data)?,
            )),
            7 => Ok(Self::DownlinkRanStatusTransfer(
                DownlinkRanStatusTransfer::decode(data)?,
            )),
            8 => Ok(Self::DownlinkUeAssociatedNrpPaTransport(
                DownlinkUeAssociatedNrpPaTransport::decode(data)?,
            )),
            9 => Ok(Self::ErrorIndication(ErrorIndication::decode(data)?)),
            10 => Ok(Self::HandoverCancel(HandoverCancel::decode(data)?)),
            11 => Ok(Self::HandoverNotify(HandoverNotify::decode(data)?)),
            12 => Ok(Self::HandoverRequired(HandoverRequired::decode(data)?)),
            13 => Ok(Self::HandoverRequest(HandoverRequest::decode(data)?)),
            61 => Ok(Self::HandoverSuccess(HandoverSuccess::decode(data)?)),
            14 => Ok(Self::InitialContextSetupRequest(
                InitialContextSetupRequest::decode(data)?,
            )),
            15 => Ok(Self::InitialUeMessage(InitialUeMessage::decode(data)?)),
            18 => Ok(Self::LocationReport(LocationReport::decode(data)?)),
            16 => Ok(Self::LocationReportingControl(
                LocationReportingControl::decode(data)?,
            )),
            17 => Ok(Self::LocationReportingFailureIndication(
                LocationReportingFailureIndication::decode(data)?,
            )),
            19 => Ok(Self::NasNonDeliveryIndication(
                NasNonDeliveryIndication::decode(data)?,
            )),
            20 => Ok(Self::NgReset(NgReset::decode(data)?)),
            21 => Ok(Self::NgSetupRequest(NgSetupRequest::decode(data)?)),
            22 => Ok(Self::OverloadStart(OverloadStart::decode(data)?)),
            23 => Ok(Self::OverloadStop(OverloadStop::decode(data)?)),
            24 => Ok(Self::Paging(Paging::decode(data)?)),
            25 => Ok(Self::PathSwitchRequest(PathSwitchRequest::decode(data)?)),
            26 => Ok(Self::PduSessionResourceModifyRequest(
                PduSessionResourceModifyRequest::decode(data)?,
            )),
            27 => Ok(Self::PduSessionResourceModifyIndication(
                PduSessionResourceModifyIndication::decode(data)?,
            )),
            30 => Ok(Self::PduSessionResourceNotify(
                PduSessionResourceNotify::decode(data)?,
            )),
            28 => Ok(Self::PduSessionResourceReleaseCommand(
                PduSessionResourceReleaseCommand::decode(data)?,
            )),
            29 => Ok(Self::PduSessionResourceSetupRequest(
                PduSessionResourceSetupRequest::decode(data)?,
            )),
            32 => Ok(Self::PwsCancelRequest(PwsCancelRequest::decode(data)?)),
            33 => Ok(Self::PwsFailureIndication(PwsFailureIndication::decode(
                data,
            )?)),
            34 => Ok(Self::PwsRestartIndication(PwsRestartIndication::decode(
                data,
            )?)),
            35 => Ok(Self::RanConfigurationUpdate(
                RanConfigurationUpdate::decode(data)?,
            )),
            57 => Ok(Self::RancpRelocationIndication(
                RancpRelocationIndication::decode(data)?,
            )),
            36 => Ok(Self::RerouteNasRequest(RerouteNasRequest::decode(data)?)),
            55 => Ok(Self::RetrieveUeInformation(RetrieveUeInformation::decode(
                data,
            )?)),
            37 => Ok(Self::RrcInactiveTransitionReport(
                RrcInactiveTransitionReport::decode(data)?,
            )),
            52 => Ok(Self::SecondaryRatDataUsageReport(
                SecondaryRatDataUsageReport::decode(data)?,
            )),
            38 => Ok(Self::TraceFailureIndication(
                TraceFailureIndication::decode(data)?,
            )),
            39 => Ok(Self::TraceStart(TraceStart::decode(data)?)),
            40 => Ok(Self::UeContextModificationRequest(
                UeContextModificationRequest::decode(data)?,
            )),
            41 => Ok(Self::UeContextReleaseCommand(
                UeContextReleaseCommand::decode(data)?,
            )),
            42 => Ok(Self::UeContextReleaseRequest(
                UeContextReleaseRequest::decode(data)?,
            )),
            58 => Ok(Self::UeContextResumeRequest(
                UeContextResumeRequest::decode(data)?,
            )),
            59 => Ok(Self::UeContextSuspendRequest(
                UeContextSuspendRequest::decode(data)?,
            )),
            56 => Ok(Self::UeInformationTransfer(UeInformationTransfer::decode(
                data,
            )?)),
            43 => Ok(Self::UeRadioCapabilityCheckRequest(
                UeRadioCapabilityCheckRequest::decode(data)?,
            )),
            60 => Ok(Self::UeRadioCapabilityIdMappingRequest(
                UeRadioCapabilityIdMappingRequest::decode(data)?,
            )),
            44 => Ok(Self::UeRadioCapabilityInfoIndication(
                UeRadioCapabilityInfoIndication::decode(data)?,
            )),
            45 => Ok(Self::UetnlaBindingReleaseRequest(
                UetnlaBindingReleaseRequest::decode(data)?,
            )),
            46 => Ok(Self::UplinkNasTransport(UplinkNasTransport::decode(data)?)),
            47 => Ok(Self::UplinkNonUeAssociatedNrpPaTransport(
                UplinkNonUeAssociatedNrpPaTransport::decode(data)?,
            )),
            48 => Ok(Self::UplinkRanConfigurationTransfer(
                UplinkRanConfigurationTransfer::decode(data)?,
            )),
            62 => Ok(Self::UplinkRanEarlyStatusTransfer(
                UplinkRanEarlyStatusTransfer::decode(data)?,
            )),
            49 => Ok(Self::UplinkRanStatusTransfer(
                UplinkRanStatusTransfer::decode(data)?,
            )),
            50 => Ok(Self::UplinkUeAssociatedNrpPaTransport(
                UplinkUeAssociatedNrpPaTransport::decode(data)?,
            )),
            51 => Ok(Self::WriteReplaceWarningRequest(
                WriteReplaceWarningRequest::decode(data)?,
            )),
            53 => Ok(Self::UplinkRimInformationTransfer(
                UplinkRimInformationTransfer::decode(data)?,
            )),
            54 => Ok(Self::DownlinkRimInformationTransfer(
                DownlinkRimInformationTransfer::decode(data)?,
            )),
            x => {
                return Err(aper::AperCodecError::new(format!(
                    "Unrecognised procedure code {}",
                    x
                )))
            }
        }
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        match self {
            Self::AmfConfigurationUpdate(x) => {
                aper::encode::encode_integer(data, Some(0), Some(255), false, 0, false)?;
                Criticality::Reject.encode(data)?;
                x.encode(data)?;
            }
            Self::AmfcpRelocationIndication(x) => {
                aper::encode::encode_integer(data, Some(0), Some(255), false, 64, false)?;
                Criticality::Reject.encode(data)?;
                x.encode(data)?;
            }
            Self::AmfStatusIndication(x) => {
                aper::encode::encode_integer(data, Some(0), Some(255), false, 1, false)?;
                Criticality::Ignore.encode(data)?;
                x.encode(data)?;
            }
            Self::CellTrafficTrace(x) => {
                aper::encode::encode_integer(data, Some(0), Some(255), false, 2, false)?;
                Criticality::Ignore.encode(data)?;
                x.encode(data)?;
            }
            Self::ConnectionEstablishmentIndication(x) => {
                aper::encode::encode_integer(data, Some(0), Some(255), false, 65, false)?;
                Criticality::Reject.encode(data)?;
                x.encode(data)?;
            }
            Self::DeactivateTrace(x) => {
                aper::encode::encode_integer(data, Some(0), Some(255), false, 3, false)?;
                Criticality::Ignore.encode(data)?;
                x.encode(data)?;
            }
            Self::DownlinkNasTransport(x) => {
                aper::encode::encode_integer(data, Some(0), Some(255), false, 4, false)?;
                Criticality::Ignore.encode(data)?;
                x.encode(data)?;
            }
            Self::DownlinkNonUeAssociatedNrpPaTransport(x) => {
                aper::encode::encode_integer(data, Some(0), Some(255), false, 5, false)?;
                Criticality::Ignore.encode(data)?;
                x.encode(data)?;
            }
            Self::DownlinkRanConfigurationTransfer(x) => {
                aper::encode::encode_integer(data, Some(0), Some(255), false, 6, false)?;
                Criticality::Ignore.encode(data)?;
                x.encode(data)?;
            }
            Self::DownlinkRanEarlyStatusTransfer(x) => {
                aper::encode::encode_integer(data, Some(0), Some(255), false, 63, false)?;
                Criticality::Ignore.encode(data)?;
                x.encode(data)?;
            }
            Self::DownlinkRanStatusTransfer(x) => {
                aper::encode::encode_integer(data, Some(0), Some(255), false, 7, false)?;
                Criticality::Ignore.encode(data)?;
                x.encode(data)?;
            }
            Self::DownlinkUeAssociatedNrpPaTransport(x) => {
                aper::encode::encode_integer(data, Some(0), Some(255), false, 8, false)?;
                Criticality::Ignore.encode(data)?;
                x.encode(data)?;
            }
            Self::ErrorIndication(x) => {
                aper::encode::encode_integer(data, Some(0), Some(255), false, 9, false)?;
                Criticality::Ignore.encode(data)?;
                x.encode(data)?;
            }
            Self::HandoverCancel(x) => {
                aper::encode::encode_integer(data, Some(0), Some(255), false, 10, false)?;
                Criticality::Reject.encode(data)?;
                x.encode(data)?;
            }
            Self::HandoverNotify(x) => {
                aper::encode::encode_integer(data, Some(0), Some(255), false, 11, false)?;
                Criticality::Ignore.encode(data)?;
                x.encode(data)?;
            }
            Self::HandoverRequired(x) => {
                aper::encode::encode_integer(data, Some(0), Some(255), false, 12, false)?;
                Criticality::Reject.encode(data)?;
                x.encode(data)?;
            }
            Self::HandoverRequest(x) => {
                aper::encode::encode_integer(data, Some(0), Some(255), false, 13, false)?;
                Criticality::Reject.encode(data)?;
                x.encode(data)?;
            }
            Self::HandoverSuccess(x) => {
                aper::encode::encode_integer(data, Some(0), Some(255), false, 61, false)?;
                Criticality::Ignore.encode(data)?;
                x.encode(data)?;
            }
            Self::InitialContextSetupRequest(x) => {
                aper::encode::encode_integer(data, Some(0), Some(255), false, 14, false)?;
                Criticality::Reject.encode(data)?;
                x.encode(data)?;
            }
            Self::InitialUeMessage(x) => {
                aper::encode::encode_integer(data, Some(0), Some(255), false, 15, false)?;
                Criticality::Ignore.encode(data)?;
                x.encode(data)?;
            }
            Self::LocationReport(x) => {
                aper::encode::encode_integer(data, Some(0), Some(255), false, 18, false)?;
                Criticality::Ignore.encode(data)?;
                x.encode(data)?;
            }
            Self::LocationReportingControl(x) => {
                aper::encode::encode_integer(data, Some(0), Some(255), false, 16, false)?;
                Criticality::Ignore.encode(data)?;
                x.encode(data)?;
            }
            Self::LocationReportingFailureIndication(x) => {
                aper::encode::encode_integer(data, Some(0), Some(255), false, 17, false)?;
                Criticality::Ignore.encode(data)?;
                x.encode(data)?;
            }
            Self::NasNonDeliveryIndication(x) => {
                aper::encode::encode_integer(data, Some(0), Some(255), false, 19, false)?;
                Criticality::Ignore.encode(data)?;
                x.encode(data)?;
            }
            Self::NgReset(x) => {
                aper::encode::encode_integer(data, Some(0), Some(255), false, 20, false)?;
                Criticality::Reject.encode(data)?;
                x.encode(data)?;
            }
            Self::NgSetupRequest(x) => {
                aper::encode::encode_integer(data, Some(0), Some(255), false, 21, false)?;
                Criticality::Reject.encode(data)?;
                x.encode(data)?;
            }
            Self::OverloadStart(x) => {
                aper::encode::encode_integer(data, Some(0), Some(255), false, 22, false)?;
                Criticality::Ignore.encode(data)?;
                x.encode(data)?;
            }
            Self::OverloadStop(x) => {
                aper::encode::encode_integer(data, Some(0), Some(255), false, 23, false)?;
                Criticality::Reject.encode(data)?;
                x.encode(data)?;
            }
            Self::Paging(x) => {
                aper::encode::encode_integer(data, Some(0), Some(255), false, 24, false)?;
                Criticality::Ignore.encode(data)?;
                x.encode(data)?;
            }
            Self::PathSwitchRequest(x) => {
                aper::encode::encode_integer(data, Some(0), Some(255), false, 25, false)?;
                Criticality::Reject.encode(data)?;
                x.encode(data)?;
            }
            Self::PduSessionResourceModifyRequest(x) => {
                aper::encode::encode_integer(data, Some(0), Some(255), false, 26, false)?;
                Criticality::Reject.encode(data)?;
                x.encode(data)?;
            }
            Self::PduSessionResourceModifyIndication(x) => {
                aper::encode::encode_integer(data, Some(0), Some(255), false, 27, false)?;
                Criticality::Reject.encode(data)?;
                x.encode(data)?;
            }
            Self::PduSessionResourceNotify(x) => {
                aper::encode::encode_integer(data, Some(0), Some(255), false, 30, false)?;
                Criticality::Ignore.encode(data)?;
                x.encode(data)?;
            }
            Self::PduSessionResourceReleaseCommand(x) => {
                aper::encode::encode_integer(data, Some(0), Some(255), false, 28, false)?;
                Criticality::Reject.encode(data)?;
                x.encode(data)?;
            }
            Self::PduSessionResourceSetupRequest(x) => {
                aper::encode::encode_integer(data, Some(0), Some(255), false, 29, false)?;
                Criticality::Reject.encode(data)?;
                x.encode(data)?;
            }
            Self::PwsCancelRequest(x) => {
                aper::encode::encode_integer(data, Some(0), Some(255), false, 32, false)?;
                Criticality::Reject.encode(data)?;
                x.encode(data)?;
            }
            Self::PwsFailureIndication(x) => {
                aper::encode::encode_integer(data, Some(0), Some(255), false, 33, false)?;
                Criticality::Ignore.encode(data)?;
                x.encode(data)?;
            }
            Self::PwsRestartIndication(x) => {
                aper::encode::encode_integer(data, Some(0), Some(255), false, 34, false)?;
                Criticality::Ignore.encode(data)?;
                x.encode(data)?;
            }
            Self::RanConfigurationUpdate(x) => {
                aper::encode::encode_integer(data, Some(0), Some(255), false, 35, false)?;
                Criticality::Reject.encode(data)?;
                x.encode(data)?;
            }
            Self::RancpRelocationIndication(x) => {
                aper::encode::encode_integer(data, Some(0), Some(255), false, 57, false)?;
                Criticality::Reject.encode(data)?;
                x.encode(data)?;
            }
            Self::RerouteNasRequest(x) => {
                aper::encode::encode_integer(data, Some(0), Some(255), false, 36, false)?;
                Criticality::Reject.encode(data)?;
                x.encode(data)?;
            }
            Self::RetrieveUeInformation(x) => {
                aper::encode::encode_integer(data, Some(0), Some(255), false, 55, false)?;
                Criticality::Reject.encode(data)?;
                x.encode(data)?;
            }
            Self::RrcInactiveTransitionReport(x) => {
                aper::encode::encode_integer(data, Some(0), Some(255), false, 37, false)?;
                Criticality::Ignore.encode(data)?;
                x.encode(data)?;
            }
            Self::SecondaryRatDataUsageReport(x) => {
                aper::encode::encode_integer(data, Some(0), Some(255), false, 52, false)?;
                Criticality::Ignore.encode(data)?;
                x.encode(data)?;
            }
            Self::TraceFailureIndication(x) => {
                aper::encode::encode_integer(data, Some(0), Some(255), false, 38, false)?;
                Criticality::Ignore.encode(data)?;
                x.encode(data)?;
            }
            Self::TraceStart(x) => {
                aper::encode::encode_integer(data, Some(0), Some(255), false, 39, false)?;
                Criticality::Ignore.encode(data)?;
                x.encode(data)?;
            }
            Self::UeContextModificationRequest(x) => {
                aper::encode::encode_integer(data, Some(0), Some(255), false, 40, false)?;
                Criticality::Reject.encode(data)?;
                x.encode(data)?;
            }
            Self::UeContextReleaseCommand(x) => {
                aper::encode::encode_integer(data, Some(0), Some(255), false, 41, false)?;
                Criticality::Reject.encode(data)?;
                x.encode(data)?;
            }
            Self::UeContextReleaseRequest(x) => {
                aper::encode::encode_integer(data, Some(0), Some(255), false, 42, false)?;
                Criticality::Ignore.encode(data)?;
                x.encode(data)?;
            }
            Self::UeContextResumeRequest(x) => {
                aper::encode::encode_integer(data, Some(0), Some(255), false, 58, false)?;
                Criticality::Reject.encode(data)?;
                x.encode(data)?;
            }
            Self::UeContextSuspendRequest(x) => {
                aper::encode::encode_integer(data, Some(0), Some(255), false, 59, false)?;
                Criticality::Reject.encode(data)?;
                x.encode(data)?;
            }
            Self::UeInformationTransfer(x) => {
                aper::encode::encode_integer(data, Some(0), Some(255), false, 56, false)?;
                Criticality::Reject.encode(data)?;
                x.encode(data)?;
            }
            Self::UeRadioCapabilityCheckRequest(x) => {
                aper::encode::encode_integer(data, Some(0), Some(255), false, 43, false)?;
                Criticality::Reject.encode(data)?;
                x.encode(data)?;
            }
            Self::UeRadioCapabilityIdMappingRequest(x) => {
                aper::encode::encode_integer(data, Some(0), Some(255), false, 60, false)?;
                Criticality::Reject.encode(data)?;
                x.encode(data)?;
            }
            Self::UeRadioCapabilityInfoIndication(x) => {
                aper::encode::encode_integer(data, Some(0), Some(255), false, 44, false)?;
                Criticality::Ignore.encode(data)?;
                x.encode(data)?;
            }
            Self::UetnlaBindingReleaseRequest(x) => {
                aper::encode::encode_integer(data, Some(0), Some(255), false, 45, false)?;
                Criticality::Ignore.encode(data)?;
                x.encode(data)?;
            }
            Self::UplinkNasTransport(x) => {
                aper::encode::encode_integer(data, Some(0), Some(255), false, 46, false)?;
                Criticality::Ignore.encode(data)?;
                x.encode(data)?;
            }
            Self::UplinkNonUeAssociatedNrpPaTransport(x) => {
                aper::encode::encode_integer(data, Some(0), Some(255), false, 47, false)?;
                Criticality::Ignore.encode(data)?;
                x.encode(data)?;
            }
            Self::UplinkRanConfigurationTransfer(x) => {
                aper::encode::encode_integer(data, Some(0), Some(255), false, 48, false)?;
                Criticality::Ignore.encode(data)?;
                x.encode(data)?;
            }
            Self::UplinkRanEarlyStatusTransfer(x) => {
                aper::encode::encode_integer(data, Some(0), Some(255), false, 62, false)?;
                Criticality::Reject.encode(data)?;
                x.encode(data)?;
            }
            Self::UplinkRanStatusTransfer(x) => {
                aper::encode::encode_integer(data, Some(0), Some(255), false, 49, false)?;
                Criticality::Ignore.encode(data)?;
                x.encode(data)?;
            }
            Self::UplinkUeAssociatedNrpPaTransport(x) => {
                aper::encode::encode_integer(data, Some(0), Some(255), false, 50, false)?;
                Criticality::Ignore.encode(data)?;
                x.encode(data)?;
            }
            Self::WriteReplaceWarningRequest(x) => {
                aper::encode::encode_integer(data, Some(0), Some(255), false, 51, false)?;
                Criticality::Reject.encode(data)?;
                x.encode(data)?;
            }
            Self::UplinkRimInformationTransfer(x) => {
                aper::encode::encode_integer(data, Some(0), Some(255), false, 53, false)?;
                Criticality::Ignore.encode(data)?;
                x.encode(data)?;
            }
            Self::DownlinkRimInformationTransfer(x) => {
                aper::encode::encode_integer(data, Some(0), Some(255), false, 54, false)?;
                Criticality::Ignore.encode(data)?;
                x.encode(data)?;
            }
        }
        Ok(())
    }
}

impl AperCodec for InitiatingMessage {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        InitiatingMessage::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("InitiatingMessage"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("InitiatingMessage"))
    }
}

#[derive(Clone, Debug)]
pub enum SuccessfulOutcome {
    AmfConfigurationUpdateAcknowledge(AmfConfigurationUpdateAcknowledge),
    HandoverCancelAcknowledge(HandoverCancelAcknowledge),
    HandoverCommand(HandoverCommand),
    HandoverRequestAcknowledge(HandoverRequestAcknowledge),
    InitialContextSetupResponse(InitialContextSetupResponse),
    NgResetAcknowledge(NgResetAcknowledge),
    NgSetupResponse(NgSetupResponse),
    PathSwitchRequestAcknowledge(PathSwitchRequestAcknowledge),
    PduSessionResourceModifyResponse(PduSessionResourceModifyResponse),
    PduSessionResourceModifyConfirm(PduSessionResourceModifyConfirm),
    PduSessionResourceReleaseResponse(PduSessionResourceReleaseResponse),
    PduSessionResourceSetupResponse(PduSessionResourceSetupResponse),
    PwsCancelResponse(PwsCancelResponse),
    RanConfigurationUpdateAcknowledge(RanConfigurationUpdateAcknowledge),
    UeContextModificationResponse(UeContextModificationResponse),
    UeContextReleaseComplete(UeContextReleaseComplete),
    UeContextResumeResponse(UeContextResumeResponse),
    UeContextSuspendResponse(UeContextSuspendResponse),
    UeRadioCapabilityCheckResponse(UeRadioCapabilityCheckResponse),
    UeRadioCapabilityIdMappingResponse(UeRadioCapabilityIdMappingResponse),
    WriteReplaceWarningResponse(WriteReplaceWarningResponse),
}

impl SuccessfulOutcome {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (id, _ext) = aper::decode::decode_integer(data, Some(0), Some(255), false)?;
        let _ = Criticality::decode(data)?;
        match id {
            0 => Ok(Self::AmfConfigurationUpdateAcknowledge(
                AmfConfigurationUpdateAcknowledge::decode(data)?,
            )),
            10 => Ok(Self::HandoverCancelAcknowledge(
                HandoverCancelAcknowledge::decode(data)?,
            )),
            12 => Ok(Self::HandoverCommand(HandoverCommand::decode(data)?)),
            13 => Ok(Self::HandoverRequestAcknowledge(
                HandoverRequestAcknowledge::decode(data)?,
            )),
            14 => Ok(Self::InitialContextSetupResponse(
                InitialContextSetupResponse::decode(data)?,
            )),
            20 => Ok(Self::NgResetAcknowledge(NgResetAcknowledge::decode(data)?)),
            21 => Ok(Self::NgSetupResponse(NgSetupResponse::decode(data)?)),
            25 => Ok(Self::PathSwitchRequestAcknowledge(
                PathSwitchRequestAcknowledge::decode(data)?,
            )),
            26 => Ok(Self::PduSessionResourceModifyResponse(
                PduSessionResourceModifyResponse::decode(data)?,
            )),
            27 => Ok(Self::PduSessionResourceModifyConfirm(
                PduSessionResourceModifyConfirm::decode(data)?,
            )),
            28 => Ok(Self::PduSessionResourceReleaseResponse(
                PduSessionResourceReleaseResponse::decode(data)?,
            )),
            29 => Ok(Self::PduSessionResourceSetupResponse(
                PduSessionResourceSetupResponse::decode(data)?,
            )),
            32 => Ok(Self::PwsCancelResponse(PwsCancelResponse::decode(data)?)),
            35 => Ok(Self::RanConfigurationUpdateAcknowledge(
                RanConfigurationUpdateAcknowledge::decode(data)?,
            )),
            40 => Ok(Self::UeContextModificationResponse(
                UeContextModificationResponse::decode(data)?,
            )),
            41 => Ok(Self::UeContextReleaseComplete(
                UeContextReleaseComplete::decode(data)?,
            )),
            58 => Ok(Self::UeContextResumeResponse(
                UeContextResumeResponse::decode(data)?,
            )),
            59 => Ok(Self::UeContextSuspendResponse(
                UeContextSuspendResponse::decode(data)?,
            )),
            43 => Ok(Self::UeRadioCapabilityCheckResponse(
                UeRadioCapabilityCheckResponse::decode(data)?,
            )),
            60 => Ok(Self::UeRadioCapabilityIdMappingResponse(
                UeRadioCapabilityIdMappingResponse::decode(data)?,
            )),
            51 => Ok(Self::WriteReplaceWarningResponse(
                WriteReplaceWarningResponse::decode(data)?,
            )),
            x => {
                return Err(aper::AperCodecError::new(format!(
                    "Unrecognised procedure code {}",
                    x
                )))
            }
        }
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        match self {
            Self::AmfConfigurationUpdateAcknowledge(x) => {
                aper::encode::encode_integer(data, Some(0), Some(255), false, 0, false)?;
                Criticality::Reject.encode(data)?;
                x.encode(data)?;
            }
            Self::HandoverCancelAcknowledge(x) => {
                aper::encode::encode_integer(data, Some(0), Some(255), false, 10, false)?;
                Criticality::Reject.encode(data)?;
                x.encode(data)?;
            }
            Self::HandoverCommand(x) => {
                aper::encode::encode_integer(data, Some(0), Some(255), false, 12, false)?;
                Criticality::Reject.encode(data)?;
                x.encode(data)?;
            }
            Self::HandoverRequestAcknowledge(x) => {
                aper::encode::encode_integer(data, Some(0), Some(255), false, 13, false)?;
                Criticality::Reject.encode(data)?;
                x.encode(data)?;
            }
            Self::InitialContextSetupResponse(x) => {
                aper::encode::encode_integer(data, Some(0), Some(255), false, 14, false)?;
                Criticality::Reject.encode(data)?;
                x.encode(data)?;
            }
            Self::NgResetAcknowledge(x) => {
                aper::encode::encode_integer(data, Some(0), Some(255), false, 20, false)?;
                Criticality::Reject.encode(data)?;
                x.encode(data)?;
            }
            Self::NgSetupResponse(x) => {
                aper::encode::encode_integer(data, Some(0), Some(255), false, 21, false)?;
                Criticality::Reject.encode(data)?;
                x.encode(data)?;
            }
            Self::PathSwitchRequestAcknowledge(x) => {
                aper::encode::encode_integer(data, Some(0), Some(255), false, 25, false)?;
                Criticality::Reject.encode(data)?;
                x.encode(data)?;
            }
            Self::PduSessionResourceModifyResponse(x) => {
                aper::encode::encode_integer(data, Some(0), Some(255), false, 26, false)?;
                Criticality::Reject.encode(data)?;
                x.encode(data)?;
            }
            Self::PduSessionResourceModifyConfirm(x) => {
                aper::encode::encode_integer(data, Some(0), Some(255), false, 27, false)?;
                Criticality::Reject.encode(data)?;
                x.encode(data)?;
            }
            Self::PduSessionResourceReleaseResponse(x) => {
                aper::encode::encode_integer(data, Some(0), Some(255), false, 28, false)?;
                Criticality::Reject.encode(data)?;
                x.encode(data)?;
            }
            Self::PduSessionResourceSetupResponse(x) => {
                aper::encode::encode_integer(data, Some(0), Some(255), false, 29, false)?;
                Criticality::Reject.encode(data)?;
                x.encode(data)?;
            }
            Self::PwsCancelResponse(x) => {
                aper::encode::encode_integer(data, Some(0), Some(255), false, 32, false)?;
                Criticality::Reject.encode(data)?;
                x.encode(data)?;
            }
            Self::RanConfigurationUpdateAcknowledge(x) => {
                aper::encode::encode_integer(data, Some(0), Some(255), false, 35, false)?;
                Criticality::Reject.encode(data)?;
                x.encode(data)?;
            }
            Self::UeContextModificationResponse(x) => {
                aper::encode::encode_integer(data, Some(0), Some(255), false, 40, false)?;
                Criticality::Reject.encode(data)?;
                x.encode(data)?;
            }
            Self::UeContextReleaseComplete(x) => {
                aper::encode::encode_integer(data, Some(0), Some(255), false, 41, false)?;
                Criticality::Reject.encode(data)?;
                x.encode(data)?;
            }
            Self::UeContextResumeResponse(x) => {
                aper::encode::encode_integer(data, Some(0), Some(255), false, 58, false)?;
                Criticality::Reject.encode(data)?;
                x.encode(data)?;
            }
            Self::UeContextSuspendResponse(x) => {
                aper::encode::encode_integer(data, Some(0), Some(255), false, 59, false)?;
                Criticality::Reject.encode(data)?;
                x.encode(data)?;
            }
            Self::UeRadioCapabilityCheckResponse(x) => {
                aper::encode::encode_integer(data, Some(0), Some(255), false, 43, false)?;
                Criticality::Reject.encode(data)?;
                x.encode(data)?;
            }
            Self::UeRadioCapabilityIdMappingResponse(x) => {
                aper::encode::encode_integer(data, Some(0), Some(255), false, 60, false)?;
                Criticality::Reject.encode(data)?;
                x.encode(data)?;
            }
            Self::WriteReplaceWarningResponse(x) => {
                aper::encode::encode_integer(data, Some(0), Some(255), false, 51, false)?;
                Criticality::Reject.encode(data)?;
                x.encode(data)?;
            }
        }
        Ok(())
    }
}

impl AperCodec for SuccessfulOutcome {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        SuccessfulOutcome::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("SuccessfulOutcome"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("SuccessfulOutcome"))
    }
}

#[derive(Clone, Debug)]
pub enum UnsuccessfulOutcome {
    AmfConfigurationUpdateFailure(AmfConfigurationUpdateFailure),
    HandoverPreparationFailure(HandoverPreparationFailure),
    HandoverFailure(HandoverFailure),
    InitialContextSetupFailure(InitialContextSetupFailure),
    NgSetupFailure(NgSetupFailure),
    PathSwitchRequestFailure(PathSwitchRequestFailure),
    RanConfigurationUpdateFailure(RanConfigurationUpdateFailure),
    UeContextModificationFailure(UeContextModificationFailure),
    UeContextResumeFailure(UeContextResumeFailure),
    UeContextSuspendFailure(UeContextSuspendFailure),
}

impl UnsuccessfulOutcome {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (id, _ext) = aper::decode::decode_integer(data, Some(0), Some(255), false)?;
        let _ = Criticality::decode(data)?;
        match id {
            0 => Ok(Self::AmfConfigurationUpdateFailure(
                AmfConfigurationUpdateFailure::decode(data)?,
            )),
            12 => Ok(Self::HandoverPreparationFailure(
                HandoverPreparationFailure::decode(data)?,
            )),
            13 => Ok(Self::HandoverFailure(HandoverFailure::decode(data)?)),
            14 => Ok(Self::InitialContextSetupFailure(
                InitialContextSetupFailure::decode(data)?,
            )),
            21 => Ok(Self::NgSetupFailure(NgSetupFailure::decode(data)?)),
            25 => Ok(Self::PathSwitchRequestFailure(
                PathSwitchRequestFailure::decode(data)?,
            )),
            35 => Ok(Self::RanConfigurationUpdateFailure(
                RanConfigurationUpdateFailure::decode(data)?,
            )),
            40 => Ok(Self::UeContextModificationFailure(
                UeContextModificationFailure::decode(data)?,
            )),
            58 => Ok(Self::UeContextResumeFailure(
                UeContextResumeFailure::decode(data)?,
            )),
            59 => Ok(Self::UeContextSuspendFailure(
                UeContextSuspendFailure::decode(data)?,
            )),
            x => {
                return Err(aper::AperCodecError::new(format!(
                    "Unrecognised procedure code {}",
                    x
                )))
            }
        }
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        match self {
            Self::AmfConfigurationUpdateFailure(x) => {
                aper::encode::encode_integer(data, Some(0), Some(255), false, 0, false)?;
                Criticality::Reject.encode(data)?;
                x.encode(data)?;
            }
            Self::HandoverPreparationFailure(x) => {
                aper::encode::encode_integer(data, Some(0), Some(255), false, 12, false)?;
                Criticality::Reject.encode(data)?;
                x.encode(data)?;
            }
            Self::HandoverFailure(x) => {
                aper::encode::encode_integer(data, Some(0), Some(255), false, 13, false)?;
                Criticality::Reject.encode(data)?;
                x.encode(data)?;
            }
            Self::InitialContextSetupFailure(x) => {
                aper::encode::encode_integer(data, Some(0), Some(255), false, 14, false)?;
                Criticality::Reject.encode(data)?;
                x.encode(data)?;
            }
            Self::NgSetupFailure(x) => {
                aper::encode::encode_integer(data, Some(0), Some(255), false, 21, false)?;
                Criticality::Reject.encode(data)?;
                x.encode(data)?;
            }
            Self::PathSwitchRequestFailure(x) => {
                aper::encode::encode_integer(data, Some(0), Some(255), false, 25, false)?;
                Criticality::Reject.encode(data)?;
                x.encode(data)?;
            }
            Self::RanConfigurationUpdateFailure(x) => {
                aper::encode::encode_integer(data, Some(0), Some(255), false, 35, false)?;
                Criticality::Reject.encode(data)?;
                x.encode(data)?;
            }
            Self::UeContextModificationFailure(x) => {
                aper::encode::encode_integer(data, Some(0), Some(255), false, 40, false)?;
                Criticality::Reject.encode(data)?;
                x.encode(data)?;
            }
            Self::UeContextResumeFailure(x) => {
                aper::encode::encode_integer(data, Some(0), Some(255), false, 58, false)?;
                Criticality::Reject.encode(data)?;
                x.encode(data)?;
            }
            Self::UeContextSuspendFailure(x) => {
                aper::encode::encode_integer(data, Some(0), Some(255), false, 59, false)?;
                Criticality::Reject.encode(data)?;
                x.encode(data)?;
            }
        }
        Ok(())
    }
}

impl AperCodec for UnsuccessfulOutcome {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        UnsuccessfulOutcome::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("UnsuccessfulOutcome"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("UnsuccessfulOutcome"))
    }
}
