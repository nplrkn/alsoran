// Autogenerated from NGAP-IEs.asn
#![allow(clippy::all)]
use super::common::*;
use asn1_per::{aper::*, *};
#[allow(unused_imports)]
use xxap::{GtpTunnel, PduSessionId, TransportLayerAddress};

// AdditionalDlUpTnlInformationForHoList
#[derive(Clone, Debug)]
pub struct AdditionalDlUpTnlInformationForHoList(
    pub NonEmpty<AdditionalDlUpTnlInformationForHoItem>,
);

impl AdditionalDlUpTnlInformationForHoList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(3), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(AdditionalDlUpTnlInformationForHoItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(3), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for AdditionalDlUpTnlInformationForHoList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        AdditionalDlUpTnlInformationForHoList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("AdditionalDlUpTnlInformationForHoList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("AdditionalDlUpTnlInformationForHoList");
            e
        })
    }
}
// AdditionalDlUpTnlInformationForHoItem
#[derive(Clone, Debug)]
pub struct AdditionalDlUpTnlInformationForHoItem {
    pub additional_dl_ngu_up_tnl_information: UpTransportLayerInformation,
    pub additional_qos_flow_setup_response_list: QosFlowListWithDataForwarding,
    pub additional_dl_forwarding_up_tnl_information: Option<UpTransportLayerInformation>,
    pub additional_redundant_dl_ngu_up_tnl_information: Option<UpTransportLayerInformation>,
}

impl AdditionalDlUpTnlInformationForHoItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 2)?;
        let additional_dl_ngu_up_tnl_information = UpTransportLayerInformation::decode(data)?;
        let additional_qos_flow_setup_response_list = QosFlowListWithDataForwarding::decode(data)?;
        let additional_dl_forwarding_up_tnl_information = if optionals[0] {
            Some(UpTransportLayerInformation::decode(data)?)
        } else {
            None
        };

        // Process the extension container
        let mut additional_redundant_dl_ngu_up_tnl_information: Option<
            UpTransportLayerInformation,
        > = None;

        if optionals[1] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    183 => {
                        additional_redundant_dl_ngu_up_tnl_information =
                            Some(UpTransportLayerInformation::decode(data)?)
                    }
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            additional_dl_ngu_up_tnl_information,
            additional_qos_flow_setup_response_list,
            additional_dl_forwarding_up_tnl_information,
            additional_redundant_dl_ngu_up_tnl_information,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();
        if let Some(x) = &self.additional_redundant_dl_ngu_up_tnl_information {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 183, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        let mut optionals = BitString::new();
        optionals.push(self.additional_dl_forwarding_up_tnl_information.is_some());
        optionals.push(num_ies != 0);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.additional_dl_ngu_up_tnl_information.encode(data)?;
        self.additional_qos_flow_setup_response_list.encode(data)?;
        if let Some(x) = &self.additional_dl_forwarding_up_tnl_information {
            x.encode(data)?;
        }
        if num_ies != 0 {
            encode::encode_length_determinent(data, Some(1), Some(65535), false, num_ies)?;
            data.append_aligned(ies);
        }
        Ok(())
    }
}

impl PerCodec for AdditionalDlUpTnlInformationForHoItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        AdditionalDlUpTnlInformationForHoItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("AdditionalDlUpTnlInformationForHoItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("AdditionalDlUpTnlInformationForHoItem");
            e
        })
    }
}
// AdditionalQosFlowInformation
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum AdditionalQosFlowInformation {
    MoreLikely,
}

impl AdditionalQosFlowInformation {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(0), true)?;
        if extended {
            return Err(PerCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(data, Some(0), Some(0), true, *self as i128, false)
    }
}

impl PerCodec for AdditionalQosFlowInformation {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        AdditionalQosFlowInformation::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("AdditionalQosFlowInformation");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("AdditionalQosFlowInformation");
            e
        })
    }
}
// AllocationAndRetentionPriority
#[derive(Clone, Debug)]
pub struct AllocationAndRetentionPriority {
    pub priority_level_arp: PriorityLevelArp,
    pub pre_emption_capability: PreEmptionCapability,
    pub pre_emption_vulnerability: PreEmptionVulnerability,
}

impl AllocationAndRetentionPriority {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let priority_level_arp = PriorityLevelArp::decode(data)?;
        let pre_emption_capability = PreEmptionCapability::decode(data)?;
        let pre_emption_vulnerability = PreEmptionVulnerability::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            priority_level_arp,
            pre_emption_capability,
            pre_emption_vulnerability,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.priority_level_arp.encode(data)?;
        self.pre_emption_capability.encode(data)?;
        self.pre_emption_vulnerability.encode(data)?;

        Ok(())
    }
}

impl PerCodec for AllocationAndRetentionPriority {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        AllocationAndRetentionPriority::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("AllocationAndRetentionPriority");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("AllocationAndRetentionPriority");
            e
        })
    }
}
// AllowedCagListPerPlmn
#[derive(Clone, Debug)]
pub struct AllowedCagListPerPlmn(pub NonEmpty<CagId>);

impl AllowedCagListPerPlmn {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(256), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(CagId::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(256), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for AllowedCagListPerPlmn {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        AllowedCagListPerPlmn::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("AllowedCagListPerPlmn");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("AllowedCagListPerPlmn");
            e
        })
    }
}
// AllowedNssai
#[derive(Clone, Debug)]
pub struct AllowedNssai(pub NonEmpty<AllowedNssaiItem>);

impl AllowedNssai {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(8), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(AllowedNssaiItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(8), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for AllowedNssai {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        AllowedNssai::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("AllowedNssai");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("AllowedNssai");
            e
        })
    }
}
// AllowedNssaiItem
#[derive(Clone, Debug)]
pub struct AllowedNssaiItem {
    pub snssai: Snssai,
}

impl AllowedNssaiItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let snssai = Snssai::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self { snssai })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.snssai.encode(data)?;

        Ok(())
    }
}

impl PerCodec for AllowedNssaiItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        AllowedNssaiItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("AllowedNssaiItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("AllowedNssaiItem");
            e
        })
    }
}
// AllowedPniNpnList
#[derive(Clone, Debug)]
pub struct AllowedPniNpnList(pub NonEmpty<AllowedPniNpnItem>);

impl AllowedPniNpnList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(16), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(AllowedPniNpnItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(16), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for AllowedPniNpnList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        AllowedPniNpnList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("AllowedPniNpnList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("AllowedPniNpnList");
            e
        })
    }
}
// AllowedPniNpnItem
#[derive(Clone, Debug)]
pub struct AllowedPniNpnItem {
    pub plmn_identity: PlmnIdentity,
    pub pni_npn_restricted: PniNpnRestricted,
    pub allowed_cag_list_per_plmn: AllowedCagListPerPlmn,
}

impl AllowedPniNpnItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let plmn_identity = PlmnIdentity::decode(data)?;
        let pni_npn_restricted = PniNpnRestricted::decode(data)?;
        let allowed_cag_list_per_plmn = AllowedCagListPerPlmn::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            plmn_identity,
            pni_npn_restricted,
            allowed_cag_list_per_plmn,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.plmn_identity.encode(data)?;
        self.pni_npn_restricted.encode(data)?;
        self.allowed_cag_list_per_plmn.encode(data)?;

        Ok(())
    }
}

impl PerCodec for AllowedPniNpnItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        AllowedPniNpnItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("AllowedPniNpnItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("AllowedPniNpnItem");
            e
        })
    }
}
// AllowedTaCs
#[derive(Clone, Debug)]
pub struct AllowedTaCs(pub NonEmpty<Tac>);

impl AllowedTaCs {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(16), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(Tac::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(16), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for AllowedTaCs {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        AllowedTaCs::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("AllowedTaCs");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("AllowedTaCs");
            e
        })
    }
}
// AlternativeQosParaSetIndex
#[derive(Clone, Copy, Debug)]
pub struct AlternativeQosParaSetIndex(pub u8);

impl AlternativeQosParaSetIndex {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(
            decode::decode_integer(data, Some(1), Some(8), true)?.0 as u8,
        ))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_integer(data, Some(1), Some(8), true, self.0 as i128, false)
    }
}

impl PerCodec for AlternativeQosParaSetIndex {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        AlternativeQosParaSetIndex::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("AlternativeQosParaSetIndex");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("AlternativeQosParaSetIndex");
            e
        })
    }
}
// AlternativeQosParaSetNotifyIndex
#[derive(Clone, Copy, Debug)]
pub struct AlternativeQosParaSetNotifyIndex(pub u8);

impl AlternativeQosParaSetNotifyIndex {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(
            decode::decode_integer(data, Some(0), Some(8), true)?.0 as u8,
        ))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_integer(data, Some(0), Some(8), true, self.0 as i128, false)
    }
}

impl PerCodec for AlternativeQosParaSetNotifyIndex {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        AlternativeQosParaSetNotifyIndex::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("AlternativeQosParaSetNotifyIndex");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("AlternativeQosParaSetNotifyIndex");
            e
        })
    }
}
// AlternativeQosParaSetList
#[derive(Clone, Debug)]
pub struct AlternativeQosParaSetList(pub NonEmpty<AlternativeQosParaSetItem>);

impl AlternativeQosParaSetList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(8), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(AlternativeQosParaSetItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(8), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for AlternativeQosParaSetList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        AlternativeQosParaSetList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("AlternativeQosParaSetList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("AlternativeQosParaSetList");
            e
        })
    }
}
// AlternativeQosParaSetItem
#[derive(Clone, Debug)]
pub struct AlternativeQosParaSetItem {
    pub alternative_qos_para_set_index: AlternativeQosParaSetIndex,
    pub guaranteed_flow_bit_rate_dl: Option<BitRate>,
    pub guaranteed_flow_bit_rate_ul: Option<BitRate>,
    pub packet_delay_budget: Option<PacketDelayBudget>,
    pub packet_error_rate: Option<PacketErrorRate>,
}

impl AlternativeQosParaSetItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 5)?;
        let alternative_qos_para_set_index = AlternativeQosParaSetIndex::decode(data)?;
        let guaranteed_flow_bit_rate_dl = if optionals[0] {
            Some(BitRate::decode(data)?)
        } else {
            None
        };
        let guaranteed_flow_bit_rate_ul = if optionals[1] {
            Some(BitRate::decode(data)?)
        } else {
            None
        };
        let packet_delay_budget = if optionals[2] {
            Some(PacketDelayBudget::decode(data)?)
        } else {
            None
        };
        let packet_error_rate = if optionals[3] {
            Some(PacketErrorRate::decode(data)?)
        } else {
            None
        };

        // Process the extension container

        if optionals[4] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            alternative_qos_para_set_index,
            guaranteed_flow_bit_rate_dl,
            guaranteed_flow_bit_rate_ul,
            packet_delay_budget,
            packet_error_rate,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.guaranteed_flow_bit_rate_dl.is_some());
        optionals.push(self.guaranteed_flow_bit_rate_ul.is_some());
        optionals.push(self.packet_delay_budget.is_some());
        optionals.push(self.packet_error_rate.is_some());
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.alternative_qos_para_set_index.encode(data)?;
        if let Some(x) = &self.guaranteed_flow_bit_rate_dl {
            x.encode(data)?;
        }
        if let Some(x) = &self.guaranteed_flow_bit_rate_ul {
            x.encode(data)?;
        }
        if let Some(x) = &self.packet_delay_budget {
            x.encode(data)?;
        }
        if let Some(x) = &self.packet_error_rate {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl PerCodec for AlternativeQosParaSetItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        AlternativeQosParaSetItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("AlternativeQosParaSetItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("AlternativeQosParaSetItem");
            e
        })
    }
}
// AmfName
#[derive(Clone, Debug)]
pub struct AmfName(pub String);

impl AmfName {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(decode::decode_printable_string(
            data,
            Some(1),
            Some(150),
            true,
        )?))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_printable_string(data, Some(1), Some(150), true, &self.0, false)
    }
}

impl PerCodec for AmfName {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        AmfName::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("AmfName");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("AmfName");
            e
        })
    }
}
// AmfNameVisibleString
#[derive(Clone, Debug)]
pub struct AmfNameVisibleString(pub String);

impl AmfNameVisibleString {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(decode::decode_visible_string(
            data,
            Some(1),
            Some(150),
            true,
        )?))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_visible_string(data, Some(1), Some(150), true, &self.0, false)
    }
}

impl PerCodec for AmfNameVisibleString {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        AmfNameVisibleString::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("AmfNameVisibleString");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("AmfNameVisibleString");
            e
        })
    }
}
// AmfNameUtf8String
#[derive(Clone, Debug)]
pub struct AmfNameUtf8String(pub String);

impl AmfNameUtf8String {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(decode::decode_utf8_string(
            data,
            Some(1),
            Some(150),
            true,
        )?))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_utf8_string(data, Some(1), Some(150), true, &self.0, false)
    }
}

impl PerCodec for AmfNameUtf8String {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        AmfNameUtf8String::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("AmfNameUtf8String");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("AmfNameUtf8String");
            e
        })
    }
}
// AmfPagingTarget
#[derive(Clone, Debug)]
pub enum AmfPagingTarget {
    GlobalRanNodeId(GlobalRanNodeId),
    Tai(Tai),
}

impl AmfPagingTarget {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_choice_idx(data, 0, 2, false)?;
        if extended {
            return Err(PerCodecError::new("CHOICE additions not implemented"));
        }
        match idx {
            0 => Ok(Self::GlobalRanNodeId(GlobalRanNodeId::decode(data)?)),
            1 => Ok(Self::Tai(Tai::decode(data)?)),
            2 => {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _ = Criticality::decode(data)?;
                let _ = decode::decode_length_determinent(data, None, None, false)?;
                let result = match id {
                    x => Err(PerCodecError::new(format!("Unrecognised IE type {}", x))),
                };
                data.decode_align()?;
                result
            }
            _ => Err(PerCodecError::new("Unknown choice idx")),
        }
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        match self {
            Self::GlobalRanNodeId(x) => {
                encode::encode_choice_idx(data, 0, 2, false, 0, false)?;
                x.encode(data)
            }
            Self::Tai(x) => {
                encode::encode_choice_idx(data, 0, 2, false, 1, false)?;
                x.encode(data)
            }
        }
    }
}

impl PerCodec for AmfPagingTarget {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        AmfPagingTarget::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("AmfPagingTarget");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("AmfPagingTarget");
            e
        })
    }
}
// AmfPointer
#[derive(Clone, Debug)]
pub struct AmfPointer(pub BitString);

impl AmfPointer {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(decode::decode_bitstring(
            data,
            Some(6),
            Some(6),
            false,
        )?))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_bitstring(data, Some(6), Some(6), false, &self.0, false)
    }
}

impl PerCodec for AmfPointer {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        AmfPointer::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("AmfPointer");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("AmfPointer");
            e
        })
    }
}
// AmfRegionId
#[derive(Clone, Debug)]
pub struct AmfRegionId(pub BitString);

impl AmfRegionId {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(decode::decode_bitstring(
            data,
            Some(8),
            Some(8),
            false,
        )?))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_bitstring(data, Some(8), Some(8), false, &self.0, false)
    }
}

impl PerCodec for AmfRegionId {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        AmfRegionId::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("AmfRegionId");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("AmfRegionId");
            e
        })
    }
}
// AmfSetId
#[derive(Clone, Debug)]
pub struct AmfSetId(pub BitString);

impl AmfSetId {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(decode::decode_bitstring(
            data,
            Some(10),
            Some(10),
            false,
        )?))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_bitstring(data, Some(10), Some(10), false, &self.0, false)
    }
}

impl PerCodec for AmfSetId {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        AmfSetId::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("AmfSetId");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("AmfSetId");
            e
        })
    }
}
// AmfTnlAssociationSetupList
#[derive(Clone, Debug)]
pub struct AmfTnlAssociationSetupList(pub NonEmpty<AmfTnlAssociationSetupItem>);

impl AmfTnlAssociationSetupList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(32), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(AmfTnlAssociationSetupItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(32), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for AmfTnlAssociationSetupList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        AmfTnlAssociationSetupList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("AmfTnlAssociationSetupList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("AmfTnlAssociationSetupList");
            e
        })
    }
}
// AmfTnlAssociationSetupItem
#[derive(Clone, Debug)]
pub struct AmfTnlAssociationSetupItem {
    pub amf_tnl_association_address: CpTransportLayerInformation,
}

impl AmfTnlAssociationSetupItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let amf_tnl_association_address = CpTransportLayerInformation::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            amf_tnl_association_address,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.amf_tnl_association_address.encode(data)?;

        Ok(())
    }
}

impl PerCodec for AmfTnlAssociationSetupItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        AmfTnlAssociationSetupItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("AmfTnlAssociationSetupItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("AmfTnlAssociationSetupItem");
            e
        })
    }
}
// AmfTnlAssociationToAddList
#[derive(Clone, Debug)]
pub struct AmfTnlAssociationToAddList(pub NonEmpty<AmfTnlAssociationToAddItem>);

impl AmfTnlAssociationToAddList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(32), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(AmfTnlAssociationToAddItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(32), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for AmfTnlAssociationToAddList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        AmfTnlAssociationToAddList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("AmfTnlAssociationToAddList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("AmfTnlAssociationToAddList");
            e
        })
    }
}
// AmfTnlAssociationToAddItem
#[derive(Clone, Debug)]
pub struct AmfTnlAssociationToAddItem {
    pub amf_tnl_association_address: CpTransportLayerInformation,
    pub tnl_association_usage: Option<TnlAssociationUsage>,
    pub tnl_address_weight_factor: TnlAddressWeightFactor,
}

impl AmfTnlAssociationToAddItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 2)?;
        let amf_tnl_association_address = CpTransportLayerInformation::decode(data)?;
        let tnl_association_usage = if optionals[0] {
            Some(TnlAssociationUsage::decode(data)?)
        } else {
            None
        };
        let tnl_address_weight_factor = TnlAddressWeightFactor::decode(data)?;

        // Process the extension container

        if optionals[1] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            amf_tnl_association_address,
            tnl_association_usage,
            tnl_address_weight_factor,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.tnl_association_usage.is_some());
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.amf_tnl_association_address.encode(data)?;
        if let Some(x) = &self.tnl_association_usage {
            x.encode(data)?;
        }
        self.tnl_address_weight_factor.encode(data)?;

        Ok(())
    }
}

impl PerCodec for AmfTnlAssociationToAddItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        AmfTnlAssociationToAddItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("AmfTnlAssociationToAddItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("AmfTnlAssociationToAddItem");
            e
        })
    }
}
// AmfTnlAssociationToRemoveList
#[derive(Clone, Debug)]
pub struct AmfTnlAssociationToRemoveList(pub NonEmpty<AmfTnlAssociationToRemoveItem>);

impl AmfTnlAssociationToRemoveList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(32), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(AmfTnlAssociationToRemoveItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(32), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for AmfTnlAssociationToRemoveList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        AmfTnlAssociationToRemoveList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("AmfTnlAssociationToRemoveList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("AmfTnlAssociationToRemoveList");
            e
        })
    }
}
// AmfTnlAssociationToRemoveItem
#[derive(Clone, Debug)]
pub struct AmfTnlAssociationToRemoveItem {
    pub amf_tnl_association_address: CpTransportLayerInformation,
    pub tnl_association_transport_layer_address_ngran: Option<CpTransportLayerInformation>,
}

impl AmfTnlAssociationToRemoveItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let amf_tnl_association_address = CpTransportLayerInformation::decode(data)?;

        // Process the extension container
        let mut tnl_association_transport_layer_address_ngran: Option<CpTransportLayerInformation> =
            None;

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    168 => {
                        tnl_association_transport_layer_address_ngran =
                            Some(CpTransportLayerInformation::decode(data)?)
                    }
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            amf_tnl_association_address,
            tnl_association_transport_layer_address_ngran,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();
        if let Some(x) = &self.tnl_association_transport_layer_address_ngran {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 168, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        let mut optionals = BitString::new();
        optionals.push(num_ies != 0);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.amf_tnl_association_address.encode(data)?;
        if num_ies != 0 {
            encode::encode_length_determinent(data, Some(1), Some(65535), false, num_ies)?;
            data.append_aligned(ies);
        }
        Ok(())
    }
}

impl PerCodec for AmfTnlAssociationToRemoveItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        AmfTnlAssociationToRemoveItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("AmfTnlAssociationToRemoveItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("AmfTnlAssociationToRemoveItem");
            e
        })
    }
}
// AmfTnlAssociationToUpdateList
#[derive(Clone, Debug)]
pub struct AmfTnlAssociationToUpdateList(pub NonEmpty<AmfTnlAssociationToUpdateItem>);

impl AmfTnlAssociationToUpdateList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(32), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(AmfTnlAssociationToUpdateItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(32), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for AmfTnlAssociationToUpdateList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        AmfTnlAssociationToUpdateList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("AmfTnlAssociationToUpdateList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("AmfTnlAssociationToUpdateList");
            e
        })
    }
}
// AmfTnlAssociationToUpdateItem
#[derive(Clone, Debug)]
pub struct AmfTnlAssociationToUpdateItem {
    pub amf_tnl_association_address: CpTransportLayerInformation,
    pub tnl_association_usage: Option<TnlAssociationUsage>,
    pub tnl_address_weight_factor: Option<TnlAddressWeightFactor>,
}

impl AmfTnlAssociationToUpdateItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 3)?;
        let amf_tnl_association_address = CpTransportLayerInformation::decode(data)?;
        let tnl_association_usage = if optionals[0] {
            Some(TnlAssociationUsage::decode(data)?)
        } else {
            None
        };
        let tnl_address_weight_factor = if optionals[1] {
            Some(TnlAddressWeightFactor::decode(data)?)
        } else {
            None
        };

        // Process the extension container

        if optionals[2] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            amf_tnl_association_address,
            tnl_association_usage,
            tnl_address_weight_factor,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.tnl_association_usage.is_some());
        optionals.push(self.tnl_address_weight_factor.is_some());
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.amf_tnl_association_address.encode(data)?;
        if let Some(x) = &self.tnl_association_usage {
            x.encode(data)?;
        }
        if let Some(x) = &self.tnl_address_weight_factor {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl PerCodec for AmfTnlAssociationToUpdateItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        AmfTnlAssociationToUpdateItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("AmfTnlAssociationToUpdateItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("AmfTnlAssociationToUpdateItem");
            e
        })
    }
}
// AmfUeNgapId
#[derive(Clone, Copy, Debug)]
pub struct AmfUeNgapId(pub u64);

impl AmfUeNgapId {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(
            decode::decode_integer(data, Some(0), Some(1099511627775), false)?.0 as u64,
        ))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_integer(
            data,
            Some(0),
            Some(1099511627775),
            false,
            self.0 as i128,
            false,
        )
    }
}

impl PerCodec for AmfUeNgapId {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        AmfUeNgapId::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("AmfUeNgapId");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("AmfUeNgapId");
            e
        })
    }
}
// AreaOfInterest
#[derive(Clone, Debug)]
pub struct AreaOfInterest {
    pub area_of_interest_tai_list: Option<AreaOfInterestTaiList>,
    pub area_of_interest_cell_list: Option<AreaOfInterestCellList>,
    pub area_of_interest_ran_node_list: Option<AreaOfInterestRanNodeList>,
}

impl AreaOfInterest {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 4)?;
        let area_of_interest_tai_list = if optionals[0] {
            Some(AreaOfInterestTaiList::decode(data)?)
        } else {
            None
        };
        let area_of_interest_cell_list = if optionals[1] {
            Some(AreaOfInterestCellList::decode(data)?)
        } else {
            None
        };
        let area_of_interest_ran_node_list = if optionals[2] {
            Some(AreaOfInterestRanNodeList::decode(data)?)
        } else {
            None
        };

        // Process the extension container

        if optionals[3] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            area_of_interest_tai_list,
            area_of_interest_cell_list,
            area_of_interest_ran_node_list,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.area_of_interest_tai_list.is_some());
        optionals.push(self.area_of_interest_cell_list.is_some());
        optionals.push(self.area_of_interest_ran_node_list.is_some());
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        if let Some(x) = &self.area_of_interest_tai_list {
            x.encode(data)?;
        }
        if let Some(x) = &self.area_of_interest_cell_list {
            x.encode(data)?;
        }
        if let Some(x) = &self.area_of_interest_ran_node_list {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl PerCodec for AreaOfInterest {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        AreaOfInterest::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("AreaOfInterest");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("AreaOfInterest");
            e
        })
    }
}
// AreaOfInterestCellList
#[derive(Clone, Debug)]
pub struct AreaOfInterestCellList(pub NonEmpty<AreaOfInterestCellItem>);

impl AreaOfInterestCellList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(256), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(AreaOfInterestCellItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(256), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for AreaOfInterestCellList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        AreaOfInterestCellList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("AreaOfInterestCellList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("AreaOfInterestCellList");
            e
        })
    }
}
// AreaOfInterestCellItem
#[derive(Clone, Debug)]
pub struct AreaOfInterestCellItem {
    pub ngran_cgi: NgranCgi,
}

impl AreaOfInterestCellItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let ngran_cgi = NgranCgi::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self { ngran_cgi })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.ngran_cgi.encode(data)?;

        Ok(())
    }
}

impl PerCodec for AreaOfInterestCellItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        AreaOfInterestCellItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("AreaOfInterestCellItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("AreaOfInterestCellItem");
            e
        })
    }
}
// AreaOfInterestList
#[derive(Clone, Debug)]
pub struct AreaOfInterestList(pub NonEmpty<AreaOfInterestItem>);

impl AreaOfInterestList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(64), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(AreaOfInterestItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(64), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for AreaOfInterestList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        AreaOfInterestList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("AreaOfInterestList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("AreaOfInterestList");
            e
        })
    }
}
// AreaOfInterestItem
#[derive(Clone, Debug)]
pub struct AreaOfInterestItem {
    pub area_of_interest: AreaOfInterest,
    pub location_reporting_reference_id: LocationReportingReferenceId,
}

impl AreaOfInterestItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let area_of_interest = AreaOfInterest::decode(data)?;
        let location_reporting_reference_id = LocationReportingReferenceId::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            area_of_interest,
            location_reporting_reference_id,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.area_of_interest.encode(data)?;
        self.location_reporting_reference_id.encode(data)?;

        Ok(())
    }
}

impl PerCodec for AreaOfInterestItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        AreaOfInterestItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("AreaOfInterestItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("AreaOfInterestItem");
            e
        })
    }
}
// AreaOfInterestRanNodeList
#[derive(Clone, Debug)]
pub struct AreaOfInterestRanNodeList(pub NonEmpty<AreaOfInterestRanNodeItem>);

impl AreaOfInterestRanNodeList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(64), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(AreaOfInterestRanNodeItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(64), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for AreaOfInterestRanNodeList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        AreaOfInterestRanNodeList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("AreaOfInterestRanNodeList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("AreaOfInterestRanNodeList");
            e
        })
    }
}
// AreaOfInterestRanNodeItem
#[derive(Clone, Debug)]
pub struct AreaOfInterestRanNodeItem {
    pub global_ran_node_id: GlobalRanNodeId,
}

impl AreaOfInterestRanNodeItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let global_ran_node_id = GlobalRanNodeId::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self { global_ran_node_id })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.global_ran_node_id.encode(data)?;

        Ok(())
    }
}

impl PerCodec for AreaOfInterestRanNodeItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        AreaOfInterestRanNodeItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("AreaOfInterestRanNodeItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("AreaOfInterestRanNodeItem");
            e
        })
    }
}
// AreaOfInterestTaiList
#[derive(Clone, Debug)]
pub struct AreaOfInterestTaiList(pub NonEmpty<AreaOfInterestTaiItem>);

impl AreaOfInterestTaiList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(16), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(AreaOfInterestTaiItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(16), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for AreaOfInterestTaiList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        AreaOfInterestTaiList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("AreaOfInterestTaiList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("AreaOfInterestTaiList");
            e
        })
    }
}
// AreaOfInterestTaiItem
#[derive(Clone, Debug)]
pub struct AreaOfInterestTaiItem {
    pub tai: Tai,
}

impl AreaOfInterestTaiItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let tai = Tai::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self { tai })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.tai.encode(data)?;

        Ok(())
    }
}

impl PerCodec for AreaOfInterestTaiItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        AreaOfInterestTaiItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("AreaOfInterestTaiItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("AreaOfInterestTaiItem");
            e
        })
    }
}
// AssistanceDataForPaging
#[derive(Clone, Debug)]
pub struct AssistanceDataForPaging {
    pub assistance_data_for_recommended_cells: Option<AssistanceDataForRecommendedCells>,
    pub paging_attempt_information: Option<PagingAttemptInformation>,
    pub npn_paging_assistance_information: Option<NpnPagingAssistanceInformation>,
    pub paging_assis_datafor_c_ecapab_ue: Option<PagingAssisDataforCEcapabUe>,
}

impl AssistanceDataForPaging {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 3)?;
        let assistance_data_for_recommended_cells = if optionals[0] {
            Some(AssistanceDataForRecommendedCells::decode(data)?)
        } else {
            None
        };
        let paging_attempt_information = if optionals[1] {
            Some(PagingAttemptInformation::decode(data)?)
        } else {
            None
        };

        // Process the extension container
        let mut npn_paging_assistance_information: Option<NpnPagingAssistanceInformation> = None;
        let mut paging_assis_datafor_c_ecapab_ue: Option<PagingAssisDataforCEcapabUe> = None;

        if optionals[2] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    260 => {
                        npn_paging_assistance_information =
                            Some(NpnPagingAssistanceInformation::decode(data)?)
                    }
                    207 => {
                        paging_assis_datafor_c_ecapab_ue =
                            Some(PagingAssisDataforCEcapabUe::decode(data)?)
                    }
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            assistance_data_for_recommended_cells,
            paging_attempt_information,
            npn_paging_assistance_information,
            paging_assis_datafor_c_ecapab_ue,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();
        if let Some(x) = &self.npn_paging_assistance_information {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 260, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.paging_assis_datafor_c_ecapab_ue {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 207, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        let mut optionals = BitString::new();
        optionals.push(self.assistance_data_for_recommended_cells.is_some());
        optionals.push(self.paging_attempt_information.is_some());
        optionals.push(num_ies != 0);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        if let Some(x) = &self.assistance_data_for_recommended_cells {
            x.encode(data)?;
        }
        if let Some(x) = &self.paging_attempt_information {
            x.encode(data)?;
        }
        if num_ies != 0 {
            encode::encode_length_determinent(data, Some(1), Some(65535), false, num_ies)?;
            data.append_aligned(ies);
        }
        Ok(())
    }
}

impl PerCodec for AssistanceDataForPaging {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        AssistanceDataForPaging::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("AssistanceDataForPaging");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("AssistanceDataForPaging");
            e
        })
    }
}
// AssistanceDataForRecommendedCells
#[derive(Clone, Debug)]
pub struct AssistanceDataForRecommendedCells {
    pub recommended_cells_for_paging: RecommendedCellsForPaging,
}

impl AssistanceDataForRecommendedCells {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let recommended_cells_for_paging = RecommendedCellsForPaging::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            recommended_cells_for_paging,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.recommended_cells_for_paging.encode(data)?;

        Ok(())
    }
}

impl PerCodec for AssistanceDataForRecommendedCells {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        AssistanceDataForRecommendedCells::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("AssistanceDataForRecommendedCells");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("AssistanceDataForRecommendedCells");
            e
        })
    }
}
// AssociatedQosFlowList
#[derive(Clone, Debug)]
pub struct AssociatedQosFlowList(pub NonEmpty<AssociatedQosFlowItem>);

impl AssociatedQosFlowList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(64), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(AssociatedQosFlowItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(64), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for AssociatedQosFlowList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        AssociatedQosFlowList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("AssociatedQosFlowList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("AssociatedQosFlowList");
            e
        })
    }
}
// AssociatedQosFlowItem
#[derive(Clone, Debug)]
pub struct AssociatedQosFlowItem {
    pub qos_flow_identifier: QosFlowIdentifier,
    pub qos_flow_mapping_indication: Option<QosFlowMappingIndication>,
    pub current_qos_para_set_index: Option<AlternativeQosParaSetIndex>,
}

impl AssociatedQosFlowItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 2)?;
        let qos_flow_identifier = QosFlowIdentifier::decode(data)?;
        let qos_flow_mapping_indication = if optionals[0] {
            Some(QosFlowMappingIndication::decode(data)?)
        } else {
            None
        };

        // Process the extension container
        let mut current_qos_para_set_index: Option<AlternativeQosParaSetIndex> = None;

        if optionals[1] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    221 => {
                        current_qos_para_set_index = Some(AlternativeQosParaSetIndex::decode(data)?)
                    }
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            qos_flow_identifier,
            qos_flow_mapping_indication,
            current_qos_para_set_index,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();
        if let Some(x) = &self.current_qos_para_set_index {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 221, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        let mut optionals = BitString::new();
        optionals.push(self.qos_flow_mapping_indication.is_some());
        optionals.push(num_ies != 0);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.qos_flow_identifier.encode(data)?;
        if let Some(x) = &self.qos_flow_mapping_indication {
            x.encode(data)?;
        }
        if num_ies != 0 {
            encode::encode_length_determinent(data, Some(1), Some(65535), false, num_ies)?;
            data.append_aligned(ies);
        }
        Ok(())
    }
}

impl PerCodec for AssociatedQosFlowItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        AssociatedQosFlowItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("AssociatedQosFlowItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("AssociatedQosFlowItem");
            e
        })
    }
}
// AuthenticatedIndication
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum AuthenticatedIndication {
    True,
}

impl AuthenticatedIndication {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(0), true)?;
        if extended {
            return Err(PerCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(data, Some(0), Some(0), true, *self as i128, false)
    }
}

impl PerCodec for AuthenticatedIndication {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        AuthenticatedIndication::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("AuthenticatedIndication");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("AuthenticatedIndication");
            e
        })
    }
}
// AveragingWindow
#[derive(Clone, Copy, Debug)]
pub struct AveragingWindow(pub u16);

impl AveragingWindow {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(
            decode::decode_integer(data, Some(0), Some(4095), true)?.0 as u16,
        ))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_integer(data, Some(0), Some(4095), true, self.0 as i128, false)
    }
}

impl PerCodec for AveragingWindow {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        AveragingWindow::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("AveragingWindow");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("AveragingWindow");
            e
        })
    }
}
// AreaScopeOfMdtNr
#[derive(Clone, Debug)]
pub enum AreaScopeOfMdtNr {
    CellBased(CellBasedMdtNr),
    TaBased(TaBasedMdt),
    PlmnWide,
    TaiBased(TaiBasedMdt),
}

impl AreaScopeOfMdtNr {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_choice_idx(data, 0, 4, false)?;
        if extended {
            return Err(PerCodecError::new("CHOICE additions not implemented"));
        }
        match idx {
            0 => Ok(Self::CellBased(CellBasedMdtNr::decode(data)?)),
            1 => Ok(Self::TaBased(TaBasedMdt::decode(data)?)),
            2 => Ok(Self::PlmnWide),
            3 => Ok(Self::TaiBased(TaiBasedMdt::decode(data)?)),
            4 => {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _ = Criticality::decode(data)?;
                let _ = decode::decode_length_determinent(data, None, None, false)?;
                let result = match id {
                    x => Err(PerCodecError::new(format!("Unrecognised IE type {}", x))),
                };
                data.decode_align()?;
                result
            }
            _ => Err(PerCodecError::new("Unknown choice idx")),
        }
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        match self {
            Self::CellBased(x) => {
                encode::encode_choice_idx(data, 0, 4, false, 0, false)?;
                x.encode(data)
            }
            Self::TaBased(x) => {
                encode::encode_choice_idx(data, 0, 4, false, 1, false)?;
                x.encode(data)
            }
            Self::PlmnWide => {
                encode::encode_choice_idx(data, 0, 4, false, 2, false)?;
                Ok(())
            }
            Self::TaiBased(x) => {
                encode::encode_choice_idx(data, 0, 4, false, 3, false)?;
                x.encode(data)
            }
        }
    }
}

impl PerCodec for AreaScopeOfMdtNr {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        AreaScopeOfMdtNr::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("AreaScopeOfMdtNr");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("AreaScopeOfMdtNr");
            e
        })
    }
}
// AreaScopeOfMdtEutra
#[derive(Clone, Debug)]
pub enum AreaScopeOfMdtEutra {
    CellBased(CellBasedMdtEutra),
    TaBased(TaBasedMdt),
    PlmnWide,
    TaiBased(TaiBasedMdt),
}

impl AreaScopeOfMdtEutra {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_choice_idx(data, 0, 4, false)?;
        if extended {
            return Err(PerCodecError::new("CHOICE additions not implemented"));
        }
        match idx {
            0 => Ok(Self::CellBased(CellBasedMdtEutra::decode(data)?)),
            1 => Ok(Self::TaBased(TaBasedMdt::decode(data)?)),
            2 => Ok(Self::PlmnWide),
            3 => Ok(Self::TaiBased(TaiBasedMdt::decode(data)?)),
            4 => {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _ = Criticality::decode(data)?;
                let _ = decode::decode_length_determinent(data, None, None, false)?;
                let result = match id {
                    x => Err(PerCodecError::new(format!("Unrecognised IE type {}", x))),
                };
                data.decode_align()?;
                result
            }
            _ => Err(PerCodecError::new("Unknown choice idx")),
        }
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        match self {
            Self::CellBased(x) => {
                encode::encode_choice_idx(data, 0, 4, false, 0, false)?;
                x.encode(data)
            }
            Self::TaBased(x) => {
                encode::encode_choice_idx(data, 0, 4, false, 1, false)?;
                x.encode(data)
            }
            Self::PlmnWide => {
                encode::encode_choice_idx(data, 0, 4, false, 2, false)?;
                Ok(())
            }
            Self::TaiBased(x) => {
                encode::encode_choice_idx(data, 0, 4, false, 3, false)?;
                x.encode(data)
            }
        }
    }
}

impl PerCodec for AreaScopeOfMdtEutra {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        AreaScopeOfMdtEutra::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("AreaScopeOfMdtEutra");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("AreaScopeOfMdtEutra");
            e
        })
    }
}
// AreaScopeOfNeighCellsList
#[derive(Clone, Debug)]
pub struct AreaScopeOfNeighCellsList(pub NonEmpty<AreaScopeOfNeighCellsItem>);

impl AreaScopeOfNeighCellsList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(8), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(AreaScopeOfNeighCellsItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(8), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for AreaScopeOfNeighCellsList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        AreaScopeOfNeighCellsList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("AreaScopeOfNeighCellsList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("AreaScopeOfNeighCellsList");
            e
        })
    }
}
// AreaScopeOfNeighCellsItem
#[derive(Clone, Debug)]
pub struct AreaScopeOfNeighCellsItem {
    pub nr_frequency_info: NrFrequencyInfo,
    pub pci_list_for_mdt: Option<PciListForMdt>,
}

impl AreaScopeOfNeighCellsItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 2)?;
        let nr_frequency_info = NrFrequencyInfo::decode(data)?;
        let pci_list_for_mdt = if optionals[0] {
            Some(PciListForMdt::decode(data)?)
        } else {
            None
        };

        // Process the extension container

        if optionals[1] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            nr_frequency_info,
            pci_list_for_mdt,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.pci_list_for_mdt.is_some());
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.nr_frequency_info.encode(data)?;
        if let Some(x) = &self.pci_list_for_mdt {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl PerCodec for AreaScopeOfNeighCellsItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        AreaScopeOfNeighCellsItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("AreaScopeOfNeighCellsItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("AreaScopeOfNeighCellsItem");
            e
        })
    }
}
// BitRate
#[derive(Clone, Copy, Debug)]
pub struct BitRate(pub u64);

impl BitRate {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(
            decode::decode_integer(data, Some(0), Some(4000000000000), true)?.0 as u64,
        ))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_integer(
            data,
            Some(0),
            Some(4000000000000),
            true,
            self.0 as i128,
            false,
        )
    }
}

impl PerCodec for BitRate {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        BitRate::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("BitRate");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("BitRate");
            e
        })
    }
}
// BroadcastCancelledAreaList
#[derive(Clone, Debug)]
pub enum BroadcastCancelledAreaList {
    CellIdCancelledEutra(CellIdCancelledEutra),
    TaiCancelledEutra(TaiCancelledEutra),
    EmergencyAreaIdCancelledEutra(EmergencyAreaIdCancelledEutra),
    CellIdCancelledNr(CellIdCancelledNr),
    TaiCancelledNr(TaiCancelledNr),
    EmergencyAreaIdCancelledNr(EmergencyAreaIdCancelledNr),
}

impl BroadcastCancelledAreaList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_choice_idx(data, 0, 6, false)?;
        if extended {
            return Err(PerCodecError::new("CHOICE additions not implemented"));
        }
        match idx {
            0 => Ok(Self::CellIdCancelledEutra(CellIdCancelledEutra::decode(
                data,
            )?)),
            1 => Ok(Self::TaiCancelledEutra(TaiCancelledEutra::decode(data)?)),
            2 => Ok(Self::EmergencyAreaIdCancelledEutra(
                EmergencyAreaIdCancelledEutra::decode(data)?,
            )),
            3 => Ok(Self::CellIdCancelledNr(CellIdCancelledNr::decode(data)?)),
            4 => Ok(Self::TaiCancelledNr(TaiCancelledNr::decode(data)?)),
            5 => Ok(Self::EmergencyAreaIdCancelledNr(
                EmergencyAreaIdCancelledNr::decode(data)?,
            )),
            6 => {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _ = Criticality::decode(data)?;
                let _ = decode::decode_length_determinent(data, None, None, false)?;
                let result = match id {
                    x => Err(PerCodecError::new(format!("Unrecognised IE type {}", x))),
                };
                data.decode_align()?;
                result
            }
            _ => Err(PerCodecError::new("Unknown choice idx")),
        }
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        match self {
            Self::CellIdCancelledEutra(x) => {
                encode::encode_choice_idx(data, 0, 6, false, 0, false)?;
                x.encode(data)
            }
            Self::TaiCancelledEutra(x) => {
                encode::encode_choice_idx(data, 0, 6, false, 1, false)?;
                x.encode(data)
            }
            Self::EmergencyAreaIdCancelledEutra(x) => {
                encode::encode_choice_idx(data, 0, 6, false, 2, false)?;
                x.encode(data)
            }
            Self::CellIdCancelledNr(x) => {
                encode::encode_choice_idx(data, 0, 6, false, 3, false)?;
                x.encode(data)
            }
            Self::TaiCancelledNr(x) => {
                encode::encode_choice_idx(data, 0, 6, false, 4, false)?;
                x.encode(data)
            }
            Self::EmergencyAreaIdCancelledNr(x) => {
                encode::encode_choice_idx(data, 0, 6, false, 5, false)?;
                x.encode(data)
            }
        }
    }
}

impl PerCodec for BroadcastCancelledAreaList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        BroadcastCancelledAreaList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("BroadcastCancelledAreaList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("BroadcastCancelledAreaList");
            e
        })
    }
}
// BroadcastCompletedAreaList
#[derive(Clone, Debug)]
pub enum BroadcastCompletedAreaList {
    CellIdBroadcastEutra(CellIdBroadcastEutra),
    TaiBroadcastEutra(TaiBroadcastEutra),
    EmergencyAreaIdBroadcastEutra(EmergencyAreaIdBroadcastEutra),
    CellIdBroadcastNr(CellIdBroadcastNr),
    TaiBroadcastNr(TaiBroadcastNr),
    EmergencyAreaIdBroadcastNr(EmergencyAreaIdBroadcastNr),
}

impl BroadcastCompletedAreaList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_choice_idx(data, 0, 6, false)?;
        if extended {
            return Err(PerCodecError::new("CHOICE additions not implemented"));
        }
        match idx {
            0 => Ok(Self::CellIdBroadcastEutra(CellIdBroadcastEutra::decode(
                data,
            )?)),
            1 => Ok(Self::TaiBroadcastEutra(TaiBroadcastEutra::decode(data)?)),
            2 => Ok(Self::EmergencyAreaIdBroadcastEutra(
                EmergencyAreaIdBroadcastEutra::decode(data)?,
            )),
            3 => Ok(Self::CellIdBroadcastNr(CellIdBroadcastNr::decode(data)?)),
            4 => Ok(Self::TaiBroadcastNr(TaiBroadcastNr::decode(data)?)),
            5 => Ok(Self::EmergencyAreaIdBroadcastNr(
                EmergencyAreaIdBroadcastNr::decode(data)?,
            )),
            6 => {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _ = Criticality::decode(data)?;
                let _ = decode::decode_length_determinent(data, None, None, false)?;
                let result = match id {
                    x => Err(PerCodecError::new(format!("Unrecognised IE type {}", x))),
                };
                data.decode_align()?;
                result
            }
            _ => Err(PerCodecError::new("Unknown choice idx")),
        }
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        match self {
            Self::CellIdBroadcastEutra(x) => {
                encode::encode_choice_idx(data, 0, 6, false, 0, false)?;
                x.encode(data)
            }
            Self::TaiBroadcastEutra(x) => {
                encode::encode_choice_idx(data, 0, 6, false, 1, false)?;
                x.encode(data)
            }
            Self::EmergencyAreaIdBroadcastEutra(x) => {
                encode::encode_choice_idx(data, 0, 6, false, 2, false)?;
                x.encode(data)
            }
            Self::CellIdBroadcastNr(x) => {
                encode::encode_choice_idx(data, 0, 6, false, 3, false)?;
                x.encode(data)
            }
            Self::TaiBroadcastNr(x) => {
                encode::encode_choice_idx(data, 0, 6, false, 4, false)?;
                x.encode(data)
            }
            Self::EmergencyAreaIdBroadcastNr(x) => {
                encode::encode_choice_idx(data, 0, 6, false, 5, false)?;
                x.encode(data)
            }
        }
    }
}

impl PerCodec for BroadcastCompletedAreaList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        BroadcastCompletedAreaList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("BroadcastCompletedAreaList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("BroadcastCompletedAreaList");
            e
        })
    }
}
// BroadcastPlmnList
#[derive(Clone, Debug)]
pub struct BroadcastPlmnList(pub NonEmpty<BroadcastPlmnItem>);

impl BroadcastPlmnList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(12), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(BroadcastPlmnItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(12), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for BroadcastPlmnList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        BroadcastPlmnList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("BroadcastPlmnList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("BroadcastPlmnList");
            e
        })
    }
}
// BroadcastPlmnItem
#[derive(Clone, Debug)]
pub struct BroadcastPlmnItem {
    pub plmn_identity: PlmnIdentity,
    pub tai_slice_support_list: SliceSupportList,
    pub npn_support: Option<NpnSupport>,
    pub extended_tai_slice_support_list: Option<ExtendedSliceSupportList>,
}

impl BroadcastPlmnItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let plmn_identity = PlmnIdentity::decode(data)?;
        let tai_slice_support_list = SliceSupportList::decode(data)?;

        // Process the extension container
        let mut npn_support: Option<NpnSupport> = None;
        let mut extended_tai_slice_support_list: Option<ExtendedSliceSupportList> = None;

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    258 => npn_support = Some(NpnSupport::decode(data)?),
                    271 => {
                        extended_tai_slice_support_list =
                            Some(ExtendedSliceSupportList::decode(data)?)
                    }
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            plmn_identity,
            tai_slice_support_list,
            npn_support,
            extended_tai_slice_support_list,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();
        if let Some(x) = &self.npn_support {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 258, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.extended_tai_slice_support_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 271, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        let mut optionals = BitString::new();
        optionals.push(num_ies != 0);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.plmn_identity.encode(data)?;
        self.tai_slice_support_list.encode(data)?;
        if num_ies != 0 {
            encode::encode_length_determinent(data, Some(1), Some(65535), false, num_ies)?;
            data.append_aligned(ies);
        }
        Ok(())
    }
}

impl PerCodec for BroadcastPlmnItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        BroadcastPlmnItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("BroadcastPlmnItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("BroadcastPlmnItem");
            e
        })
    }
}
// BluetoothMeasurementConfiguration
#[derive(Clone, Debug)]
pub struct BluetoothMeasurementConfiguration {
    pub bluetooth_meas_config: BluetoothMeasConfig,
    pub bluetooth_meas_config_name_list: Option<BluetoothMeasConfigNameList>,
    pub bt_rssi: Option<BtRssi>,
}

impl BluetoothMeasurementConfiguration {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 3)?;
        let bluetooth_meas_config = BluetoothMeasConfig::decode(data)?;
        let bluetooth_meas_config_name_list = if optionals[0] {
            Some(BluetoothMeasConfigNameList::decode(data)?)
        } else {
            None
        };
        let bt_rssi = if optionals[1] {
            Some(BtRssi::decode(data)?)
        } else {
            None
        };

        // Process the extension container

        if optionals[2] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            bluetooth_meas_config,
            bluetooth_meas_config_name_list,
            bt_rssi,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.bluetooth_meas_config_name_list.is_some());
        optionals.push(self.bt_rssi.is_some());
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.bluetooth_meas_config.encode(data)?;
        if let Some(x) = &self.bluetooth_meas_config_name_list {
            x.encode(data)?;
        }
        if let Some(x) = &self.bt_rssi {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl PerCodec for BluetoothMeasurementConfiguration {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        BluetoothMeasurementConfiguration::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("BluetoothMeasurementConfiguration");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("BluetoothMeasurementConfiguration");
            e
        })
    }
}
// BluetoothMeasConfigNameList
#[derive(Clone, Debug)]
pub struct BluetoothMeasConfigNameList(pub NonEmpty<BluetoothMeasConfigNameItem>);

impl BluetoothMeasConfigNameList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(4), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(BluetoothMeasConfigNameItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(4), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for BluetoothMeasConfigNameList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        BluetoothMeasConfigNameList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("BluetoothMeasConfigNameList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("BluetoothMeasConfigNameList");
            e
        })
    }
}
// BluetoothMeasConfigNameItem
#[derive(Clone, Debug)]
pub struct BluetoothMeasConfigNameItem {
    pub bluetooth_name: BluetoothName,
}

impl BluetoothMeasConfigNameItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let bluetooth_name = BluetoothName::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self { bluetooth_name })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.bluetooth_name.encode(data)?;

        Ok(())
    }
}

impl PerCodec for BluetoothMeasConfigNameItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        BluetoothMeasConfigNameItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("BluetoothMeasConfigNameItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("BluetoothMeasConfigNameItem");
            e
        })
    }
}
// BluetoothMeasConfig
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum BluetoothMeasConfig {
    Setup,
}

impl BluetoothMeasConfig {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(0), true)?;
        if extended {
            return Err(PerCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(data, Some(0), Some(0), true, *self as i128, false)
    }
}

impl PerCodec for BluetoothMeasConfig {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        BluetoothMeasConfig::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("BluetoothMeasConfig");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("BluetoothMeasConfig");
            e
        })
    }
}
// BluetoothName
#[derive(Clone, Debug)]
pub struct BluetoothName(pub Vec<u8>);

impl BluetoothName {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(decode::decode_octetstring(
            data,
            Some(1),
            Some(248),
            false,
        )?))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_octetstring(data, Some(1), Some(248), false, &self.0, false)
    }
}

impl PerCodec for BluetoothName {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        BluetoothName::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("BluetoothName");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("BluetoothName");
            e
        })
    }
}
// BurstArrivalTime
#[derive(Clone, Debug)]
pub struct BurstArrivalTime(pub Vec<u8>);

impl BurstArrivalTime {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(decode::decode_octetstring(data, None, None, false)?))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_octetstring(data, None, None, false, &self.0, false)
    }
}

impl PerCodec for BurstArrivalTime {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        BurstArrivalTime::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("BurstArrivalTime");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("BurstArrivalTime");
            e
        })
    }
}
// CagId
#[derive(Clone, Debug)]
pub struct CagId(pub BitString);

impl CagId {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(decode::decode_bitstring(
            data,
            Some(32),
            Some(32),
            false,
        )?))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_bitstring(data, Some(32), Some(32), false, &self.0, false)
    }
}

impl PerCodec for CagId {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        CagId::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CagId");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CagId");
            e
        })
    }
}
// CancelAllWarningMessages
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum CancelAllWarningMessages {
    True,
}

impl CancelAllWarningMessages {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(0), true)?;
        if extended {
            return Err(PerCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(data, Some(0), Some(0), true, *self as i128, false)
    }
}

impl PerCodec for CancelAllWarningMessages {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        CancelAllWarningMessages::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CancelAllWarningMessages");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CancelAllWarningMessages");
            e
        })
    }
}
// CancelledCellsInEaiEutra
#[derive(Clone, Debug)]
pub struct CancelledCellsInEaiEutra(pub NonEmpty<CancelledCellsInEaiEutraItem>);

impl CancelledCellsInEaiEutra {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(CancelledCellsInEaiEutraItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(65535), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for CancelledCellsInEaiEutra {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        CancelledCellsInEaiEutra::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CancelledCellsInEaiEutra");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CancelledCellsInEaiEutra");
            e
        })
    }
}
// CancelledCellsInEaiEutraItem
#[derive(Clone, Debug)]
pub struct CancelledCellsInEaiEutraItem {
    pub eutra_cgi: EutraCgi,
    pub number_of_broadcasts: NumberOfBroadcasts,
}

impl CancelledCellsInEaiEutraItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let eutra_cgi = EutraCgi::decode(data)?;
        let number_of_broadcasts = NumberOfBroadcasts::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            eutra_cgi,
            number_of_broadcasts,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.eutra_cgi.encode(data)?;
        self.number_of_broadcasts.encode(data)?;

        Ok(())
    }
}

impl PerCodec for CancelledCellsInEaiEutraItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        CancelledCellsInEaiEutraItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CancelledCellsInEaiEutraItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CancelledCellsInEaiEutraItem");
            e
        })
    }
}
// CancelledCellsInEaiNr
#[derive(Clone, Debug)]
pub struct CancelledCellsInEaiNr(pub NonEmpty<CancelledCellsInEaiNrItem>);

impl CancelledCellsInEaiNr {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(CancelledCellsInEaiNrItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(65535), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for CancelledCellsInEaiNr {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        CancelledCellsInEaiNr::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CancelledCellsInEaiNr");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CancelledCellsInEaiNr");
            e
        })
    }
}
// CancelledCellsInEaiNrItem
#[derive(Clone, Debug)]
pub struct CancelledCellsInEaiNrItem {
    pub nr_cgi: NrCgi,
    pub number_of_broadcasts: NumberOfBroadcasts,
}

impl CancelledCellsInEaiNrItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let nr_cgi = NrCgi::decode(data)?;
        let number_of_broadcasts = NumberOfBroadcasts::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            nr_cgi,
            number_of_broadcasts,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.nr_cgi.encode(data)?;
        self.number_of_broadcasts.encode(data)?;

        Ok(())
    }
}

impl PerCodec for CancelledCellsInEaiNrItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        CancelledCellsInEaiNrItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CancelledCellsInEaiNrItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CancelledCellsInEaiNrItem");
            e
        })
    }
}
// CancelledCellsInTaiEutra
#[derive(Clone, Debug)]
pub struct CancelledCellsInTaiEutra(pub NonEmpty<CancelledCellsInTaiEutraItem>);

impl CancelledCellsInTaiEutra {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(CancelledCellsInTaiEutraItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(65535), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for CancelledCellsInTaiEutra {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        CancelledCellsInTaiEutra::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CancelledCellsInTaiEutra");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CancelledCellsInTaiEutra");
            e
        })
    }
}
// CancelledCellsInTaiEutraItem
#[derive(Clone, Debug)]
pub struct CancelledCellsInTaiEutraItem {
    pub eutra_cgi: EutraCgi,
    pub number_of_broadcasts: NumberOfBroadcasts,
}

impl CancelledCellsInTaiEutraItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let eutra_cgi = EutraCgi::decode(data)?;
        let number_of_broadcasts = NumberOfBroadcasts::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            eutra_cgi,
            number_of_broadcasts,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.eutra_cgi.encode(data)?;
        self.number_of_broadcasts.encode(data)?;

        Ok(())
    }
}

impl PerCodec for CancelledCellsInTaiEutraItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        CancelledCellsInTaiEutraItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CancelledCellsInTaiEutraItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CancelledCellsInTaiEutraItem");
            e
        })
    }
}
// CancelledCellsInTaiNr
#[derive(Clone, Debug)]
pub struct CancelledCellsInTaiNr(pub NonEmpty<CancelledCellsInTaiNrItem>);

impl CancelledCellsInTaiNr {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(CancelledCellsInTaiNrItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(65535), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for CancelledCellsInTaiNr {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        CancelledCellsInTaiNr::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CancelledCellsInTaiNr");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CancelledCellsInTaiNr");
            e
        })
    }
}
// CancelledCellsInTaiNrItem
#[derive(Clone, Debug)]
pub struct CancelledCellsInTaiNrItem {
    pub nr_cgi: NrCgi,
    pub number_of_broadcasts: NumberOfBroadcasts,
}

impl CancelledCellsInTaiNrItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let nr_cgi = NrCgi::decode(data)?;
        let number_of_broadcasts = NumberOfBroadcasts::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            nr_cgi,
            number_of_broadcasts,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.nr_cgi.encode(data)?;
        self.number_of_broadcasts.encode(data)?;

        Ok(())
    }
}

impl PerCodec for CancelledCellsInTaiNrItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        CancelledCellsInTaiNrItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CancelledCellsInTaiNrItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CancelledCellsInTaiNrItem");
            e
        })
    }
}
// CandidateCellList
#[derive(Clone, Debug)]
pub struct CandidateCellList(pub NonEmpty<CandidateCellItem>);

impl CandidateCellList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(32), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(CandidateCellItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(32), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for CandidateCellList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        CandidateCellList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CandidateCellList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CandidateCellList");
            e
        })
    }
}
// CandidateCellItem
#[derive(Clone, Debug)]
pub struct CandidateCellItem {
    pub candidate_cell: CandidateCell,
}

impl CandidateCellItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let candidate_cell = CandidateCell::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self { candidate_cell })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.candidate_cell.encode(data)?;

        Ok(())
    }
}

impl PerCodec for CandidateCellItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        CandidateCellItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CandidateCellItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CandidateCellItem");
            e
        })
    }
}
// CandidateCell
#[derive(Clone, Debug)]
pub enum CandidateCell {
    CandidateCgi(CandidateCellId),
    CandidatePci(CandidatePci),
}

impl CandidateCell {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_choice_idx(data, 0, 2, false)?;
        if extended {
            return Err(PerCodecError::new("CHOICE additions not implemented"));
        }
        match idx {
            0 => Ok(Self::CandidateCgi(CandidateCellId::decode(data)?)),
            1 => Ok(Self::CandidatePci(CandidatePci::decode(data)?)),
            2 => {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _ = Criticality::decode(data)?;
                let _ = decode::decode_length_determinent(data, None, None, false)?;
                let result = match id {
                    x => Err(PerCodecError::new(format!("Unrecognised IE type {}", x))),
                };
                data.decode_align()?;
                result
            }
            _ => Err(PerCodecError::new("Unknown choice idx")),
        }
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        match self {
            Self::CandidateCgi(x) => {
                encode::encode_choice_idx(data, 0, 2, false, 0, false)?;
                x.encode(data)
            }
            Self::CandidatePci(x) => {
                encode::encode_choice_idx(data, 0, 2, false, 1, false)?;
                x.encode(data)
            }
        }
    }
}

impl PerCodec for CandidateCell {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        CandidateCell::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CandidateCell");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CandidateCell");
            e
        })
    }
}
// CandidateCellId
#[derive(Clone, Debug)]
pub struct CandidateCellId {
    pub candidate_cell_id: NrCgi,
}

impl CandidateCellId {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let candidate_cell_id = NrCgi::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self { candidate_cell_id })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.candidate_cell_id.encode(data)?;

        Ok(())
    }
}

impl PerCodec for CandidateCellId {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        CandidateCellId::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CandidateCellId");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CandidateCellId");
            e
        })
    }
}
// CandidatePci
#[derive(Clone, Debug)]
pub struct CandidatePci {
    pub candidate_pci: u16,
    pub candidate_nr_arfcn: u32,
}

impl CandidatePci {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let candidate_pci = decode::decode_integer(data, Some(0), Some(1007), true)?.0 as u16;
        let candidate_nr_arfcn =
            decode::decode_integer(data, Some(0), Some(3279165), false)?.0 as u32;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            candidate_pci,
            candidate_nr_arfcn,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        encode::encode_integer(
            data,
            Some(0),
            Some(1007),
            true,
            self.candidate_pci as i128,
            false,
        )?;
        encode::encode_integer(
            data,
            Some(0),
            Some(3279165),
            false,
            self.candidate_nr_arfcn as i128,
            false,
        )?;

        Ok(())
    }
}

impl PerCodec for CandidatePci {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        CandidatePci::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CandidatePci");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CandidatePci");
            e
        })
    }
}
// Cause
#[derive(Clone, Debug)]
pub enum Cause {
    RadioNetwork(CauseRadioNetwork),
    Transport(CauseTransport),
    Nas(CauseNas),
    Protocol(CauseProtocol),
    Misc(CauseMisc),
}

impl Cause {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_choice_idx(data, 0, 5, false)?;
        if extended {
            return Err(PerCodecError::new("CHOICE additions not implemented"));
        }
        match idx {
            0 => Ok(Self::RadioNetwork(CauseRadioNetwork::decode(data)?)),
            1 => Ok(Self::Transport(CauseTransport::decode(data)?)),
            2 => Ok(Self::Nas(CauseNas::decode(data)?)),
            3 => Ok(Self::Protocol(CauseProtocol::decode(data)?)),
            4 => Ok(Self::Misc(CauseMisc::decode(data)?)),
            5 => {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _ = Criticality::decode(data)?;
                let _ = decode::decode_length_determinent(data, None, None, false)?;
                let result = match id {
                    x => Err(PerCodecError::new(format!("Unrecognised IE type {}", x))),
                };
                data.decode_align()?;
                result
            }
            _ => Err(PerCodecError::new("Unknown choice idx")),
        }
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        match self {
            Self::RadioNetwork(x) => {
                encode::encode_choice_idx(data, 0, 5, false, 0, false)?;
                x.encode(data)
            }
            Self::Transport(x) => {
                encode::encode_choice_idx(data, 0, 5, false, 1, false)?;
                x.encode(data)
            }
            Self::Nas(x) => {
                encode::encode_choice_idx(data, 0, 5, false, 2, false)?;
                x.encode(data)
            }
            Self::Protocol(x) => {
                encode::encode_choice_idx(data, 0, 5, false, 3, false)?;
                x.encode(data)
            }
            Self::Misc(x) => {
                encode::encode_choice_idx(data, 0, 5, false, 4, false)?;
                x.encode(data)
            }
        }
    }
}

impl PerCodec for Cause {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Cause::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("Cause");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("Cause");
            e
        })
    }
}
// CauseMisc
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum CauseMisc {
    ControlProcessingOverload,
    NotEnoughUserPlaneProcessingResources,
    HardwareFailure,
    OmIntervention,
    UnknownPlmnOrSnpn,
    Unspecified,
}

impl CauseMisc {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(5), true)?;
        if extended {
            return Err(PerCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(data, Some(0), Some(5), true, *self as i128, false)
    }
}

impl PerCodec for CauseMisc {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        CauseMisc::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CauseMisc");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CauseMisc");
            e
        })
    }
}
// CauseNas
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum CauseNas {
    NormalRelease,
    AuthenticationFailure,
    Deregister,
    Unspecified,
}

impl CauseNas {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(3), true)?;
        if extended {
            return Err(PerCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(data, Some(0), Some(3), true, *self as i128, false)
    }
}

impl PerCodec for CauseNas {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        CauseNas::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CauseNas");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CauseNas");
            e
        })
    }
}
// CauseProtocol
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum CauseProtocol {
    TransferSyntaxError,
    AbstractSyntaxErrorReject,
    AbstractSyntaxErrorIgnoreAndNotify,
    MessageNotCompatibleWithReceiverState,
    SemanticError,
    AbstractSyntaxErrorFalselyConstructedMessage,
    Unspecified,
}

impl CauseProtocol {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(6), true)?;
        if extended {
            return Err(PerCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(data, Some(0), Some(6), true, *self as i128, false)
    }
}

impl PerCodec for CauseProtocol {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        CauseProtocol::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CauseProtocol");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CauseProtocol");
            e
        })
    }
}
// CauseRadioNetwork
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum CauseRadioNetwork {
    Unspecified,
    TxnrelocoverallExpiry,
    SuccessfulHandover,
    ReleaseDueToNgranGeneratedReason,
    ReleaseDueTo5gcGeneratedReason,
    HandoverCancelled,
    PartialHandover,
    HoFailureInTarget5gcNgranNodeOrTargetSystem,
    HoTargetNotAllowed,
    TngrelocoverallExpiry,
    TngrelocprepExpiry,
    CellNotAvailable,
    UnknownTargetId,
    NoRadioResourcesAvailableInTargetCell,
    UnknownLocalUeNgapId,
    InconsistentRemoteUeNgapId,
    HandoverDesirableForRadioReason,
    TimeCriticalHandover,
    ResourceOptimisationHandover,
    ReduceLoadInServingCell,
    UserInactivity,
    RadioConnectionWithUeLost,
    RadioResourcesNotAvailable,
    InvalidQosCombination,
    FailureInRadioInterfaceProcedure,
    InteractionWithOtherProcedure,
    UnknownPduSessionId,
    UnkownQosFlowId,
    MultiplePduSessionIdInstances,
    MultipleQosFlowIdInstances,
    EncryptionAndOrIntegrityProtectionAlgorithmsNotSupported,
    NgIntraSystemHandoverTriggered,
    NgInterSystemHandoverTriggered,
    XnHandoverTriggered,
    NotSupported5qiValue,
    UeContextTransfer,
    ImsVoiceEpsFallbackOrRatFallbackTriggered,
    UpIntegrityProtectionNotPossible,
    UpConfidentialityProtectionNotPossible,
    SliceNotSupported,
    UeInRrcInactiveStateNotReachable,
    Redirection,
    ResourcesNotAvailableForTheSlice,
    UeMaxIntegrityProtectedDataRateReason,
    ReleaseDueToCnDetectedMobility,
}

impl CauseRadioNetwork {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(44), true)?;
        if extended {
            return Err(PerCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(data, Some(0), Some(44), true, *self as i128, false)
    }
}

impl PerCodec for CauseRadioNetwork {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        CauseRadioNetwork::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CauseRadioNetwork");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CauseRadioNetwork");
            e
        })
    }
}
// CauseTransport
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum CauseTransport {
    TransportResourceUnavailable,
    Unspecified,
}

impl CauseTransport {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(1), true)?;
        if extended {
            return Err(PerCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(data, Some(0), Some(1), true, *self as i128, false)
    }
}

impl PerCodec for CauseTransport {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        CauseTransport::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CauseTransport");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CauseTransport");
            e
        })
    }
}
// CellCagInformation
#[derive(Clone, Debug)]
pub struct CellCagInformation {
    pub ngran_cgi: NgranCgi,
    pub cell_cag_list: CellCagList,
}

impl CellCagInformation {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let ngran_cgi = NgranCgi::decode(data)?;
        let cell_cag_list = CellCagList::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            ngran_cgi,
            cell_cag_list,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.ngran_cgi.encode(data)?;
        self.cell_cag_list.encode(data)?;

        Ok(())
    }
}

impl PerCodec for CellCagInformation {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        CellCagInformation::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CellCagInformation");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CellCagInformation");
            e
        })
    }
}
// CellCagList
#[derive(Clone, Debug)]
pub struct CellCagList(pub NonEmpty<CagId>);

impl CellCagList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(64), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(CagId::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(64), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for CellCagList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        CellCagList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CellCagList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CellCagList");
            e
        })
    }
}
// CellIdBroadcastEutra
#[derive(Clone, Debug)]
pub struct CellIdBroadcastEutra(pub NonEmpty<CellIdBroadcastEutraItem>);

impl CellIdBroadcastEutra {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(CellIdBroadcastEutraItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(65535), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for CellIdBroadcastEutra {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        CellIdBroadcastEutra::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CellIdBroadcastEutra");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CellIdBroadcastEutra");
            e
        })
    }
}
// CellIdBroadcastEutraItem
#[derive(Clone, Debug)]
pub struct CellIdBroadcastEutraItem {
    pub eutra_cgi: EutraCgi,
}

impl CellIdBroadcastEutraItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let eutra_cgi = EutraCgi::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self { eutra_cgi })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.eutra_cgi.encode(data)?;

        Ok(())
    }
}

impl PerCodec for CellIdBroadcastEutraItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        CellIdBroadcastEutraItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CellIdBroadcastEutraItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CellIdBroadcastEutraItem");
            e
        })
    }
}
// CellIdBroadcastNr
#[derive(Clone, Debug)]
pub struct CellIdBroadcastNr(pub NonEmpty<CellIdBroadcastNrItem>);

impl CellIdBroadcastNr {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(CellIdBroadcastNrItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(65535), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for CellIdBroadcastNr {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        CellIdBroadcastNr::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CellIdBroadcastNr");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CellIdBroadcastNr");
            e
        })
    }
}
// CellIdBroadcastNrItem
#[derive(Clone, Debug)]
pub struct CellIdBroadcastNrItem {
    pub nr_cgi: NrCgi,
}

impl CellIdBroadcastNrItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let nr_cgi = NrCgi::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self { nr_cgi })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.nr_cgi.encode(data)?;

        Ok(())
    }
}

impl PerCodec for CellIdBroadcastNrItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        CellIdBroadcastNrItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CellIdBroadcastNrItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CellIdBroadcastNrItem");
            e
        })
    }
}
// CellIdCancelledEutra
#[derive(Clone, Debug)]
pub struct CellIdCancelledEutra(pub NonEmpty<CellIdCancelledEutraItem>);

impl CellIdCancelledEutra {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(CellIdCancelledEutraItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(65535), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for CellIdCancelledEutra {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        CellIdCancelledEutra::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CellIdCancelledEutra");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CellIdCancelledEutra");
            e
        })
    }
}
// CellIdCancelledEutraItem
#[derive(Clone, Debug)]
pub struct CellIdCancelledEutraItem {
    pub eutra_cgi: EutraCgi,
    pub number_of_broadcasts: NumberOfBroadcasts,
}

impl CellIdCancelledEutraItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let eutra_cgi = EutraCgi::decode(data)?;
        let number_of_broadcasts = NumberOfBroadcasts::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            eutra_cgi,
            number_of_broadcasts,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.eutra_cgi.encode(data)?;
        self.number_of_broadcasts.encode(data)?;

        Ok(())
    }
}

impl PerCodec for CellIdCancelledEutraItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        CellIdCancelledEutraItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CellIdCancelledEutraItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CellIdCancelledEutraItem");
            e
        })
    }
}
// CellIdCancelledNr
#[derive(Clone, Debug)]
pub struct CellIdCancelledNr(pub NonEmpty<CellIdCancelledNrItem>);

impl CellIdCancelledNr {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(CellIdCancelledNrItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(65535), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for CellIdCancelledNr {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        CellIdCancelledNr::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CellIdCancelledNr");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CellIdCancelledNr");
            e
        })
    }
}
// CellIdCancelledNrItem
#[derive(Clone, Debug)]
pub struct CellIdCancelledNrItem {
    pub nr_cgi: NrCgi,
    pub number_of_broadcasts: NumberOfBroadcasts,
}

impl CellIdCancelledNrItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let nr_cgi = NrCgi::decode(data)?;
        let number_of_broadcasts = NumberOfBroadcasts::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            nr_cgi,
            number_of_broadcasts,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.nr_cgi.encode(data)?;
        self.number_of_broadcasts.encode(data)?;

        Ok(())
    }
}

impl PerCodec for CellIdCancelledNrItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        CellIdCancelledNrItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CellIdCancelledNrItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CellIdCancelledNrItem");
            e
        })
    }
}
// CellIdListForRestart
#[derive(Clone, Debug)]
pub enum CellIdListForRestart {
    EutraCgiListforRestart(EutraCgiList),
    NrCgiListforRestart(NrCgiList),
}

impl CellIdListForRestart {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_choice_idx(data, 0, 2, false)?;
        if extended {
            return Err(PerCodecError::new("CHOICE additions not implemented"));
        }
        match idx {
            0 => Ok(Self::EutraCgiListforRestart(EutraCgiList::decode(data)?)),
            1 => Ok(Self::NrCgiListforRestart(NrCgiList::decode(data)?)),
            2 => {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _ = Criticality::decode(data)?;
                let _ = decode::decode_length_determinent(data, None, None, false)?;
                let result = match id {
                    x => Err(PerCodecError::new(format!("Unrecognised IE type {}", x))),
                };
                data.decode_align()?;
                result
            }
            _ => Err(PerCodecError::new("Unknown choice idx")),
        }
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        match self {
            Self::EutraCgiListforRestart(x) => {
                encode::encode_choice_idx(data, 0, 2, false, 0, false)?;
                x.encode(data)
            }
            Self::NrCgiListforRestart(x) => {
                encode::encode_choice_idx(data, 0, 2, false, 1, false)?;
                x.encode(data)
            }
        }
    }
}

impl PerCodec for CellIdListForRestart {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        CellIdListForRestart::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CellIdListForRestart");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CellIdListForRestart");
            e
        })
    }
}
// CellSize
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum CellSize {
    Verysmall,
    Small,
    Medium,
    Large,
}

impl CellSize {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(3), true)?;
        if extended {
            return Err(PerCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(data, Some(0), Some(3), true, *self as i128, false)
    }
}

impl PerCodec for CellSize {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        CellSize::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CellSize");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CellSize");
            e
        })
    }
}
// CellType
#[derive(Clone, Debug)]
pub struct CellType {
    pub cell_size: CellSize,
}

impl CellType {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let cell_size = CellSize::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self { cell_size })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.cell_size.encode(data)?;

        Ok(())
    }
}

impl PerCodec for CellType {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        CellType::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CellType");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CellType");
            e
        })
    }
}
// CEmodeBSupportIndicator
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum CEmodeBSupportIndicator {
    Supported,
}

impl CEmodeBSupportIndicator {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(0), true)?;
        if extended {
            return Err(PerCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(data, Some(0), Some(0), true, *self as i128, false)
    }
}

impl PerCodec for CEmodeBSupportIndicator {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        CEmodeBSupportIndicator::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CEmodeBSupportIndicator");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CEmodeBSupportIndicator");
            e
        })
    }
}
// CEmodeBrestricted
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum CEmodeBrestricted {
    Restricted,
    NotRestricted,
}

impl CEmodeBrestricted {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(1), true)?;
        if extended {
            return Err(PerCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(data, Some(0), Some(1), true, *self as i128, false)
    }
}

impl PerCodec for CEmodeBrestricted {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        CEmodeBrestricted::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CEmodeBrestricted");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CEmodeBrestricted");
            e
        })
    }
}
// CnAssistedRanTuning
#[derive(Clone, Debug)]
pub struct CnAssistedRanTuning {
    pub expected_ue_behaviour: Option<ExpectedUeBehaviour>,
}

impl CnAssistedRanTuning {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 2)?;
        let expected_ue_behaviour = if optionals[0] {
            Some(ExpectedUeBehaviour::decode(data)?)
        } else {
            None
        };

        // Process the extension container

        if optionals[1] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            expected_ue_behaviour,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.expected_ue_behaviour.is_some());
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        if let Some(x) = &self.expected_ue_behaviour {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl PerCodec for CnAssistedRanTuning {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        CnAssistedRanTuning::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CnAssistedRanTuning");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CnAssistedRanTuning");
            e
        })
    }
}
// CnTypeRestrictionsForEquivalent
#[derive(Clone, Debug)]
pub struct CnTypeRestrictionsForEquivalent(pub NonEmpty<CnTypeRestrictionsForEquivalentItem>);

impl CnTypeRestrictionsForEquivalent {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(15), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(CnTypeRestrictionsForEquivalentItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(15), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for CnTypeRestrictionsForEquivalent {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        CnTypeRestrictionsForEquivalent::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CnTypeRestrictionsForEquivalent");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CnTypeRestrictionsForEquivalent");
            e
        })
    }
}
// CnTypeRestrictionsForEquivalentItem
#[derive(Clone, Debug)]
pub struct CnTypeRestrictionsForEquivalentItem {
    pub plmn_identity: PlmnIdentity,
    pub cn_type: CnType,
}

impl CnTypeRestrictionsForEquivalentItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let plmn_identity = PlmnIdentity::decode(data)?;
        let cn_type = CnType::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            plmn_identity,
            cn_type,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.plmn_identity.encode(data)?;
        self.cn_type.encode(data)?;

        Ok(())
    }
}

impl PerCodec for CnTypeRestrictionsForEquivalentItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        CnTypeRestrictionsForEquivalentItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CnTypeRestrictionsForEquivalentItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CnTypeRestrictionsForEquivalentItem");
            e
        })
    }
}
// CnTypeRestrictionsForServing
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum CnTypeRestrictionsForServing {
    EpcForbidden,
}

impl CnTypeRestrictionsForServing {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(0), true)?;
        if extended {
            return Err(PerCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(data, Some(0), Some(0), true, *self as i128, false)
    }
}

impl PerCodec for CnTypeRestrictionsForServing {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        CnTypeRestrictionsForServing::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CnTypeRestrictionsForServing");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CnTypeRestrictionsForServing");
            e
        })
    }
}
// CommonNetworkInstance
#[derive(Clone, Debug)]
pub struct CommonNetworkInstance(pub Vec<u8>);

impl CommonNetworkInstance {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(decode::decode_octetstring(data, None, None, false)?))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_octetstring(data, None, None, false, &self.0, false)
    }
}

impl PerCodec for CommonNetworkInstance {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        CommonNetworkInstance::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CommonNetworkInstance");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CommonNetworkInstance");
            e
        })
    }
}
// CompletedCellsInEaiEutra
#[derive(Clone, Debug)]
pub struct CompletedCellsInEaiEutra(pub NonEmpty<CompletedCellsInEaiEutraItem>);

impl CompletedCellsInEaiEutra {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(CompletedCellsInEaiEutraItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(65535), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for CompletedCellsInEaiEutra {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        CompletedCellsInEaiEutra::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CompletedCellsInEaiEutra");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CompletedCellsInEaiEutra");
            e
        })
    }
}
// CompletedCellsInEaiEutraItem
#[derive(Clone, Debug)]
pub struct CompletedCellsInEaiEutraItem {
    pub eutra_cgi: EutraCgi,
}

impl CompletedCellsInEaiEutraItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let eutra_cgi = EutraCgi::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self { eutra_cgi })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.eutra_cgi.encode(data)?;

        Ok(())
    }
}

impl PerCodec for CompletedCellsInEaiEutraItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        CompletedCellsInEaiEutraItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CompletedCellsInEaiEutraItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CompletedCellsInEaiEutraItem");
            e
        })
    }
}
// CompletedCellsInEaiNr
#[derive(Clone, Debug)]
pub struct CompletedCellsInEaiNr(pub NonEmpty<CompletedCellsInEaiNrItem>);

impl CompletedCellsInEaiNr {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(CompletedCellsInEaiNrItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(65535), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for CompletedCellsInEaiNr {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        CompletedCellsInEaiNr::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CompletedCellsInEaiNr");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CompletedCellsInEaiNr");
            e
        })
    }
}
// CompletedCellsInEaiNrItem
#[derive(Clone, Debug)]
pub struct CompletedCellsInEaiNrItem {
    pub nr_cgi: NrCgi,
}

impl CompletedCellsInEaiNrItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let nr_cgi = NrCgi::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self { nr_cgi })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.nr_cgi.encode(data)?;

        Ok(())
    }
}

impl PerCodec for CompletedCellsInEaiNrItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        CompletedCellsInEaiNrItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CompletedCellsInEaiNrItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CompletedCellsInEaiNrItem");
            e
        })
    }
}
// CompletedCellsInTaiEutra
#[derive(Clone, Debug)]
pub struct CompletedCellsInTaiEutra(pub NonEmpty<CompletedCellsInTaiEutraItem>);

impl CompletedCellsInTaiEutra {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(CompletedCellsInTaiEutraItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(65535), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for CompletedCellsInTaiEutra {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        CompletedCellsInTaiEutra::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CompletedCellsInTaiEutra");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CompletedCellsInTaiEutra");
            e
        })
    }
}
// CompletedCellsInTaiEutraItem
#[derive(Clone, Debug)]
pub struct CompletedCellsInTaiEutraItem {
    pub eutra_cgi: EutraCgi,
}

impl CompletedCellsInTaiEutraItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let eutra_cgi = EutraCgi::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self { eutra_cgi })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.eutra_cgi.encode(data)?;

        Ok(())
    }
}

impl PerCodec for CompletedCellsInTaiEutraItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        CompletedCellsInTaiEutraItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CompletedCellsInTaiEutraItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CompletedCellsInTaiEutraItem");
            e
        })
    }
}
// CompletedCellsInTaiNr
#[derive(Clone, Debug)]
pub struct CompletedCellsInTaiNr(pub NonEmpty<CompletedCellsInTaiNrItem>);

impl CompletedCellsInTaiNr {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(CompletedCellsInTaiNrItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(65535), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for CompletedCellsInTaiNr {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        CompletedCellsInTaiNr::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CompletedCellsInTaiNr");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CompletedCellsInTaiNr");
            e
        })
    }
}
// CompletedCellsInTaiNrItem
#[derive(Clone, Debug)]
pub struct CompletedCellsInTaiNrItem {
    pub nr_cgi: NrCgi,
}

impl CompletedCellsInTaiNrItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let nr_cgi = NrCgi::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self { nr_cgi })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.nr_cgi.encode(data)?;

        Ok(())
    }
}

impl PerCodec for CompletedCellsInTaiNrItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        CompletedCellsInTaiNrItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CompletedCellsInTaiNrItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CompletedCellsInTaiNrItem");
            e
        })
    }
}
// ConcurrentWarningMessageInd
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum ConcurrentWarningMessageInd {
    True,
}

impl ConcurrentWarningMessageInd {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(0), true)?;
        if extended {
            return Err(PerCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(data, Some(0), Some(0), true, *self as i128, false)
    }
}

impl PerCodec for ConcurrentWarningMessageInd {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        ConcurrentWarningMessageInd::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ConcurrentWarningMessageInd");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ConcurrentWarningMessageInd");
            e
        })
    }
}
// ConfidentialityProtectionIndication
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum ConfidentialityProtectionIndication {
    Required,
    Preferred,
    NotNeeded,
}

impl ConfidentialityProtectionIndication {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(2), true)?;
        if extended {
            return Err(PerCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(data, Some(0), Some(2), true, *self as i128, false)
    }
}

impl PerCodec for ConfidentialityProtectionIndication {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        ConfidentialityProtectionIndication::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ConfidentialityProtectionIndication");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ConfidentialityProtectionIndication");
            e
        })
    }
}
// ConfidentialityProtectionResult
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum ConfidentialityProtectionResult {
    Performed,
    NotPerformed,
}

impl ConfidentialityProtectionResult {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(1), true)?;
        if extended {
            return Err(PerCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(data, Some(0), Some(1), true, *self as i128, false)
    }
}

impl PerCodec for ConfidentialityProtectionResult {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        ConfidentialityProtectionResult::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ConfidentialityProtectionResult");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ConfidentialityProtectionResult");
            e
        })
    }
}
// ConfiguredTacIndication
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum ConfiguredTacIndication {
    True,
}

impl ConfiguredTacIndication {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(0), true)?;
        if extended {
            return Err(PerCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(data, Some(0), Some(0), true, *self as i128, false)
    }
}

impl PerCodec for ConfiguredTacIndication {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        ConfiguredTacIndication::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ConfiguredTacIndication");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ConfiguredTacIndication");
            e
        })
    }
}
// CoreNetworkAssistanceInformationForInactive
#[derive(Clone, Debug)]
pub struct CoreNetworkAssistanceInformationForInactive {
    pub ue_identity_index_value: UeIdentityIndexValue,
    pub ue_specific_drx: Option<PagingDrx>,
    pub periodic_registration_update_timer: PeriodicRegistrationUpdateTimer,
    pub mico_mode_indication: Option<MicoModeIndication>,
    pub tai_list_for_inactive: TaiListForInactive,
    pub expected_ue_behaviour: Option<ExpectedUeBehaviour>,
    pub paginge_drx_information: Option<PagingeDrxInformation>,
    pub extended_ue_identity_index_value: Option<ExtendedUeIdentityIndexValue>,
    pub ue_radio_capability_for_paging: Option<UeRadioCapabilityForPaging>,
}

impl CoreNetworkAssistanceInformationForInactive {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 4)?;
        let ue_identity_index_value = UeIdentityIndexValue::decode(data)?;
        let ue_specific_drx = if optionals[0] {
            Some(PagingDrx::decode(data)?)
        } else {
            None
        };
        let periodic_registration_update_timer = PeriodicRegistrationUpdateTimer::decode(data)?;
        let mico_mode_indication = if optionals[1] {
            Some(MicoModeIndication::decode(data)?)
        } else {
            None
        };
        let tai_list_for_inactive = TaiListForInactive::decode(data)?;
        let expected_ue_behaviour = if optionals[2] {
            Some(ExpectedUeBehaviour::decode(data)?)
        } else {
            None
        };

        // Process the extension container
        let mut paginge_drx_information: Option<PagingeDrxInformation> = None;
        let mut extended_ue_identity_index_value: Option<ExtendedUeIdentityIndexValue> = None;
        let mut ue_radio_capability_for_paging: Option<UeRadioCapabilityForPaging> = None;

        if optionals[3] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    223 => paginge_drx_information = Some(PagingeDrxInformation::decode(data)?),
                    280 => {
                        extended_ue_identity_index_value =
                            Some(ExtendedUeIdentityIndexValue::decode(data)?)
                    }
                    118 => {
                        ue_radio_capability_for_paging =
                            Some(UeRadioCapabilityForPaging::decode(data)?)
                    }
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            ue_identity_index_value,
            ue_specific_drx,
            periodic_registration_update_timer,
            mico_mode_indication,
            tai_list_for_inactive,
            expected_ue_behaviour,
            paginge_drx_information,
            extended_ue_identity_index_value,
            ue_radio_capability_for_paging,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();
        if let Some(x) = &self.paginge_drx_information {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 223, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.extended_ue_identity_index_value {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 280, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.ue_radio_capability_for_paging {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 118, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        let mut optionals = BitString::new();
        optionals.push(self.ue_specific_drx.is_some());
        optionals.push(self.mico_mode_indication.is_some());
        optionals.push(self.expected_ue_behaviour.is_some());
        optionals.push(num_ies != 0);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.ue_identity_index_value.encode(data)?;
        if let Some(x) = &self.ue_specific_drx {
            x.encode(data)?;
        }
        self.periodic_registration_update_timer.encode(data)?;
        if let Some(x) = &self.mico_mode_indication {
            x.encode(data)?;
        }
        self.tai_list_for_inactive.encode(data)?;
        if let Some(x) = &self.expected_ue_behaviour {
            x.encode(data)?;
        }
        if num_ies != 0 {
            encode::encode_length_determinent(data, Some(1), Some(65535), false, num_ies)?;
            data.append_aligned(ies);
        }
        Ok(())
    }
}

impl PerCodec for CoreNetworkAssistanceInformationForInactive {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        CoreNetworkAssistanceInformationForInactive::decode_inner(data).map_err(
            |mut e: PerCodecError| {
                e.push_context("CoreNetworkAssistanceInformationForInactive");
                e
            },
        )
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CoreNetworkAssistanceInformationForInactive");
            e
        })
    }
}
// CountValueForPdcpSn12
#[derive(Clone, Debug)]
pub struct CountValueForPdcpSn12 {
    pub pdcp_sn12: u16,
    pub hfn_pdcp_sn12: u32,
}

impl CountValueForPdcpSn12 {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let pdcp_sn12 = decode::decode_integer(data, Some(0), Some(4095), false)?.0 as u16;
        let hfn_pdcp_sn12 = decode::decode_integer(data, Some(0), Some(1048575), false)?.0 as u32;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            pdcp_sn12,
            hfn_pdcp_sn12,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        encode::encode_integer(
            data,
            Some(0),
            Some(4095),
            false,
            self.pdcp_sn12 as i128,
            false,
        )?;
        encode::encode_integer(
            data,
            Some(0),
            Some(1048575),
            false,
            self.hfn_pdcp_sn12 as i128,
            false,
        )?;

        Ok(())
    }
}

impl PerCodec for CountValueForPdcpSn12 {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        CountValueForPdcpSn12::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CountValueForPdcpSn12");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CountValueForPdcpSn12");
            e
        })
    }
}
// CountValueForPdcpSn18
#[derive(Clone, Debug)]
pub struct CountValueForPdcpSn18 {
    pub pdcp_sn18: u32,
    pub hfn_pdcp_sn18: u16,
}

impl CountValueForPdcpSn18 {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let pdcp_sn18 = decode::decode_integer(data, Some(0), Some(262143), false)?.0 as u32;
        let hfn_pdcp_sn18 = decode::decode_integer(data, Some(0), Some(16383), false)?.0 as u16;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            pdcp_sn18,
            hfn_pdcp_sn18,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        encode::encode_integer(
            data,
            Some(0),
            Some(262143),
            false,
            self.pdcp_sn18 as i128,
            false,
        )?;
        encode::encode_integer(
            data,
            Some(0),
            Some(16383),
            false,
            self.hfn_pdcp_sn18 as i128,
            false,
        )?;

        Ok(())
    }
}

impl PerCodec for CountValueForPdcpSn18 {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        CountValueForPdcpSn18::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CountValueForPdcpSn18");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CountValueForPdcpSn18");
            e
        })
    }
}
// CoverageEnhancementLevel
#[derive(Clone, Debug)]
pub struct CoverageEnhancementLevel(pub Vec<u8>);

impl CoverageEnhancementLevel {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(decode::decode_octetstring(data, None, None, false)?))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_octetstring(data, None, None, false, &self.0, false)
    }
}

impl PerCodec for CoverageEnhancementLevel {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        CoverageEnhancementLevel::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CoverageEnhancementLevel");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CoverageEnhancementLevel");
            e
        })
    }
}
// CpTransportLayerInformation
#[derive(Clone, Debug)]
pub enum CpTransportLayerInformation {
    EndpointIpAddress(TransportLayerAddress),
    EndpointIpAddressAndPort(EndpointIpAddressAndPort),
}

impl CpTransportLayerInformation {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_choice_idx(data, 0, 1, false)?;
        if extended {
            return Err(PerCodecError::new("CHOICE additions not implemented"));
        }
        match idx {
            0 => Ok(Self::EndpointIpAddress(TransportLayerAddress::decode(
                data,
            )?)),
            1 => {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _ = Criticality::decode(data)?;
                let _ = decode::decode_length_determinent(data, None, None, false)?;
                let result = match id {
                    169 => Ok(Self::EndpointIpAddressAndPort(
                        EndpointIpAddressAndPort::decode(data)?,
                    )),
                    x => Err(PerCodecError::new(format!("Unrecognised IE type {}", x))),
                };
                data.decode_align()?;
                result
            }
            _ => Err(PerCodecError::new("Unknown choice idx")),
        }
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        match self {
            Self::EndpointIpAddress(x) => {
                encode::encode_choice_idx(data, 0, 1, false, 0, false)?;
                x.encode(data)
            }
            Self::EndpointIpAddressAndPort(x) => {
                encode::encode_choice_idx(data, 0, 1, false, 1, false)?;
                encode::encode_integer(data, Some(0), Some(65535), false, 169, false)?;
                Criticality::Reject.encode(data)?;
                let ie = &mut Allocator::new_codec_data();
                x.encode(ie)?;
                encode::encode_length_determinent(data, None, None, false, ie.length_in_bytes())?;
                Ok(data.append_aligned(ie))
            }
        }
    }
}

impl PerCodec for CpTransportLayerInformation {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        CpTransportLayerInformation::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CpTransportLayerInformation");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CpTransportLayerInformation");
            e
        })
    }
}
// CriticalityDiagnostics
#[derive(Clone, Debug)]
pub struct CriticalityDiagnostics {
    pub procedure_code: Option<ProcedureCode>,
    pub triggering_message: Option<TriggeringMessage>,
    pub procedure_criticality: Option<Criticality>,
    pub i_es_criticality_diagnostics: Option<CriticalityDiagnosticsIeList>,
}

impl CriticalityDiagnostics {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 5)?;
        let procedure_code = if optionals[0] {
            Some(ProcedureCode::decode(data)?)
        } else {
            None
        };
        let triggering_message = if optionals[1] {
            Some(TriggeringMessage::decode(data)?)
        } else {
            None
        };
        let procedure_criticality = if optionals[2] {
            Some(Criticality::decode(data)?)
        } else {
            None
        };
        let i_es_criticality_diagnostics = if optionals[3] {
            Some(CriticalityDiagnosticsIeList::decode(data)?)
        } else {
            None
        };

        // Process the extension container

        if optionals[4] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            procedure_code,
            triggering_message,
            procedure_criticality,
            i_es_criticality_diagnostics,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.procedure_code.is_some());
        optionals.push(self.triggering_message.is_some());
        optionals.push(self.procedure_criticality.is_some());
        optionals.push(self.i_es_criticality_diagnostics.is_some());
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        if let Some(x) = &self.procedure_code {
            x.encode(data)?;
        }
        if let Some(x) = &self.triggering_message {
            x.encode(data)?;
        }
        if let Some(x) = &self.procedure_criticality {
            x.encode(data)?;
        }
        if let Some(x) = &self.i_es_criticality_diagnostics {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl PerCodec for CriticalityDiagnostics {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        CriticalityDiagnostics::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CriticalityDiagnostics");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CriticalityDiagnostics");
            e
        })
    }
}
// CriticalityDiagnosticsIeList
#[derive(Clone, Debug)]
pub struct CriticalityDiagnosticsIeList(pub NonEmpty<CriticalityDiagnosticsIeItem>);

impl CriticalityDiagnosticsIeList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(256), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(CriticalityDiagnosticsIeItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(256), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for CriticalityDiagnosticsIeList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        CriticalityDiagnosticsIeList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CriticalityDiagnosticsIeList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CriticalityDiagnosticsIeList");
            e
        })
    }
}
// CriticalityDiagnosticsIeItem
#[derive(Clone, Debug)]
pub struct CriticalityDiagnosticsIeItem {
    pub ie_criticality: Criticality,
    pub ie_id: ProtocolIeId,
    pub type_of_error: TypeOfError,
}

impl CriticalityDiagnosticsIeItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let ie_criticality = Criticality::decode(data)?;
        let ie_id = ProtocolIeId::decode(data)?;
        let type_of_error = TypeOfError::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            ie_criticality,
            ie_id,
            type_of_error,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.ie_criticality.encode(data)?;
        self.ie_id.encode(data)?;
        self.type_of_error.encode(data)?;

        Ok(())
    }
}

impl PerCodec for CriticalityDiagnosticsIeItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        CriticalityDiagnosticsIeItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CriticalityDiagnosticsIeItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CriticalityDiagnosticsIeItem");
            e
        })
    }
}
// CellBasedMdtNr
#[derive(Clone, Debug)]
pub struct CellBasedMdtNr {
    pub cell_id_listfor_mdt: CellIdListforMdtNr,
}

impl CellBasedMdtNr {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let cell_id_listfor_mdt = CellIdListforMdtNr::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            cell_id_listfor_mdt,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.cell_id_listfor_mdt.encode(data)?;

        Ok(())
    }
}

impl PerCodec for CellBasedMdtNr {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        CellBasedMdtNr::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CellBasedMdtNr");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CellBasedMdtNr");
            e
        })
    }
}
// CellIdListforMdtNr
#[derive(Clone, Debug)]
pub struct CellIdListforMdtNr(pub NonEmpty<NrCgi>);

impl CellIdListforMdtNr {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(32), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(NrCgi::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(32), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for CellIdListforMdtNr {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        CellIdListforMdtNr::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CellIdListforMdtNr");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CellIdListforMdtNr");
            e
        })
    }
}
// CellBasedMdtEutra
#[derive(Clone, Debug)]
pub struct CellBasedMdtEutra {
    pub cell_id_listfor_mdt: CellIdListforMdtEutra,
}

impl CellBasedMdtEutra {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let cell_id_listfor_mdt = CellIdListforMdtEutra::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            cell_id_listfor_mdt,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.cell_id_listfor_mdt.encode(data)?;

        Ok(())
    }
}

impl PerCodec for CellBasedMdtEutra {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        CellBasedMdtEutra::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CellBasedMdtEutra");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CellBasedMdtEutra");
            e
        })
    }
}
// CellIdListforMdtEutra
#[derive(Clone, Debug)]
pub struct CellIdListforMdtEutra(pub NonEmpty<EutraCgi>);

impl CellIdListforMdtEutra {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(32), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(EutraCgi::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(32), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for CellIdListforMdtEutra {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        CellIdListforMdtEutra::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CellIdListforMdtEutra");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CellIdListforMdtEutra");
            e
        })
    }
}
// DataCodingScheme
#[derive(Clone, Debug)]
pub struct DataCodingScheme(pub BitString);

impl DataCodingScheme {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(decode::decode_bitstring(
            data,
            Some(8),
            Some(8),
            false,
        )?))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_bitstring(data, Some(8), Some(8), false, &self.0, false)
    }
}

impl PerCodec for DataCodingScheme {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        DataCodingScheme::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DataCodingScheme");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DataCodingScheme");
            e
        })
    }
}
// DataForwardingAccepted
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum DataForwardingAccepted {
    DataForwardingAccepted,
}

impl DataForwardingAccepted {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(0), true)?;
        if extended {
            return Err(PerCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(data, Some(0), Some(0), true, *self as i128, false)
    }
}

impl PerCodec for DataForwardingAccepted {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        DataForwardingAccepted::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DataForwardingAccepted");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DataForwardingAccepted");
            e
        })
    }
}
// DataForwardingNotPossible
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum DataForwardingNotPossible {
    DataForwardingNotPossible,
}

impl DataForwardingNotPossible {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(0), true)?;
        if extended {
            return Err(PerCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(data, Some(0), Some(0), true, *self as i128, false)
    }
}

impl PerCodec for DataForwardingNotPossible {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        DataForwardingNotPossible::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DataForwardingNotPossible");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DataForwardingNotPossible");
            e
        })
    }
}
// DataForwardingResponseDrbList
#[derive(Clone, Debug)]
pub struct DataForwardingResponseDrbList(pub NonEmpty<DataForwardingResponseDrbItem>);

impl DataForwardingResponseDrbList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(32), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(DataForwardingResponseDrbItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(32), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for DataForwardingResponseDrbList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        DataForwardingResponseDrbList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DataForwardingResponseDrbList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DataForwardingResponseDrbList");
            e
        })
    }
}
// DataForwardingResponseDrbItem
#[derive(Clone, Debug)]
pub struct DataForwardingResponseDrbItem {
    pub drb_id: DrbId,
    pub dl_forwarding_up_tnl_information: Option<UpTransportLayerInformation>,
    pub ul_forwarding_up_tnl_information: Option<UpTransportLayerInformation>,
}

impl DataForwardingResponseDrbItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 3)?;
        let drb_id = DrbId::decode(data)?;
        let dl_forwarding_up_tnl_information = if optionals[0] {
            Some(UpTransportLayerInformation::decode(data)?)
        } else {
            None
        };
        let ul_forwarding_up_tnl_information = if optionals[1] {
            Some(UpTransportLayerInformation::decode(data)?)
        } else {
            None
        };

        // Process the extension container

        if optionals[2] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            drb_id,
            dl_forwarding_up_tnl_information,
            ul_forwarding_up_tnl_information,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.dl_forwarding_up_tnl_information.is_some());
        optionals.push(self.ul_forwarding_up_tnl_information.is_some());
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.drb_id.encode(data)?;
        if let Some(x) = &self.dl_forwarding_up_tnl_information {
            x.encode(data)?;
        }
        if let Some(x) = &self.ul_forwarding_up_tnl_information {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl PerCodec for DataForwardingResponseDrbItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        DataForwardingResponseDrbItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DataForwardingResponseDrbItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DataForwardingResponseDrbItem");
            e
        })
    }
}
// DapsRequestInfo
#[derive(Clone, Debug)]
pub struct DapsRequestInfo {
    pub daps_indicator: DapsIndicator,
}

impl DapsRequestInfo {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let daps_indicator = DapsIndicator::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self { daps_indicator })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.daps_indicator.encode(data)?;

        Ok(())
    }
}

impl PerCodec for DapsRequestInfo {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        DapsRequestInfo::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DapsRequestInfo");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DapsRequestInfo");
            e
        })
    }
}
// DapsResponseInfoList
#[derive(Clone, Debug)]
pub struct DapsResponseInfoList(pub NonEmpty<DapsResponseInfoItem>);

impl DapsResponseInfoList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(32), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(DapsResponseInfoItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(32), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for DapsResponseInfoList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        DapsResponseInfoList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DapsResponseInfoList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DapsResponseInfoList");
            e
        })
    }
}
// DapsResponseInfoItem
#[derive(Clone, Debug)]
pub struct DapsResponseInfoItem {
    pub drb_id: DrbId,
    pub daps_response_info: DapsResponseInfo,
}

impl DapsResponseInfoItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let drb_id = DrbId::decode(data)?;
        let daps_response_info = DapsResponseInfo::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            drb_id,
            daps_response_info,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.drb_id.encode(data)?;
        self.daps_response_info.encode(data)?;

        Ok(())
    }
}

impl PerCodec for DapsResponseInfoItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        DapsResponseInfoItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DapsResponseInfoItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DapsResponseInfoItem");
            e
        })
    }
}
// DapsResponseInfo
#[derive(Clone, Debug)]
pub struct DapsResponseInfo {
    pub dapsresponseindicator: Dapsresponseindicator,
}

impl DapsResponseInfo {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let dapsresponseindicator = Dapsresponseindicator::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            dapsresponseindicator,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.dapsresponseindicator.encode(data)?;

        Ok(())
    }
}

impl PerCodec for DapsResponseInfo {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        DapsResponseInfo::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DapsResponseInfo");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DapsResponseInfo");
            e
        })
    }
}
// DataForwardingResponseErabList
#[derive(Clone, Debug)]
pub struct DataForwardingResponseErabList(pub NonEmpty<DataForwardingResponseErabListItem>);

impl DataForwardingResponseErabList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(256), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(DataForwardingResponseErabListItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(256), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for DataForwardingResponseErabList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        DataForwardingResponseErabList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DataForwardingResponseErabList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DataForwardingResponseErabList");
            e
        })
    }
}
// DataForwardingResponseErabListItem
#[derive(Clone, Debug)]
pub struct DataForwardingResponseErabListItem {
    pub e_rab_id: ERabId,
    pub dl_forwarding_up_tnl_information: UpTransportLayerInformation,
}

impl DataForwardingResponseErabListItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let e_rab_id = ERabId::decode(data)?;
        let dl_forwarding_up_tnl_information = UpTransportLayerInformation::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            e_rab_id,
            dl_forwarding_up_tnl_information,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.e_rab_id.encode(data)?;
        self.dl_forwarding_up_tnl_information.encode(data)?;

        Ok(())
    }
}

impl PerCodec for DataForwardingResponseErabListItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        DataForwardingResponseErabListItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DataForwardingResponseErabListItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DataForwardingResponseErabListItem");
            e
        })
    }
}
// DelayCritical
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum DelayCritical {
    DelayCritical,
    NonDelayCritical,
}

impl DelayCritical {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(1), true)?;
        if extended {
            return Err(PerCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(data, Some(0), Some(1), true, *self as i128, false)
    }
}

impl PerCodec for DelayCritical {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        DelayCritical::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DelayCritical");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DelayCritical");
            e
        })
    }
}
// DlCpSecurityInformation
#[derive(Clone, Debug)]
pub struct DlCpSecurityInformation {
    pub dl_nas_mac: DlNasMac,
}

impl DlCpSecurityInformation {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let dl_nas_mac = DlNasMac::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self { dl_nas_mac })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.dl_nas_mac.encode(data)?;

        Ok(())
    }
}

impl PerCodec for DlCpSecurityInformation {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        DlCpSecurityInformation::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DlCpSecurityInformation");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DlCpSecurityInformation");
            e
        })
    }
}
// DlNasMac
#[derive(Clone, Debug)]
pub struct DlNasMac(pub BitString);

impl DlNasMac {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(decode::decode_bitstring(
            data,
            Some(16),
            Some(16),
            false,
        )?))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_bitstring(data, Some(16), Some(16), false, &self.0, false)
    }
}

impl PerCodec for DlNasMac {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        DlNasMac::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DlNasMac");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DlNasMac");
            e
        })
    }
}
// DlForwarding
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum DlForwarding {
    DlForwardingProposed,
}

impl DlForwarding {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(0), true)?;
        if extended {
            return Err(PerCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(data, Some(0), Some(0), true, *self as i128, false)
    }
}

impl PerCodec for DlForwarding {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        DlForwarding::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DlForwarding");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DlForwarding");
            e
        })
    }
}
// DlNguTnlInformationReused
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum DlNguTnlInformationReused {
    True,
}

impl DlNguTnlInformationReused {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(0), true)?;
        if extended {
            return Err(PerCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(data, Some(0), Some(0), true, *self as i128, false)
    }
}

impl PerCodec for DlNguTnlInformationReused {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        DlNguTnlInformationReused::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DlNguTnlInformationReused");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DlNguTnlInformationReused");
            e
        })
    }
}
// DirectForwardingPathAvailability
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum DirectForwardingPathAvailability {
    DirectPathAvailable,
}

impl DirectForwardingPathAvailability {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(0), true)?;
        if extended {
            return Err(PerCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(data, Some(0), Some(0), true, *self as i128, false)
    }
}

impl PerCodec for DirectForwardingPathAvailability {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        DirectForwardingPathAvailability::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DirectForwardingPathAvailability");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DirectForwardingPathAvailability");
            e
        })
    }
}
// DrbId
#[derive(Clone, Copy, Debug)]
pub struct DrbId(pub u8);

impl DrbId {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(
            decode::decode_integer(data, Some(1), Some(32), true)?.0 as u8,
        ))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_integer(data, Some(1), Some(32), true, self.0 as i128, false)
    }
}

impl PerCodec for DrbId {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        DrbId::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DrbId");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DrbId");
            e
        })
    }
}
// DrbsSubjectToStatusTransferList
#[derive(Clone, Debug)]
pub struct DrbsSubjectToStatusTransferList(pub NonEmpty<DrbsSubjectToStatusTransferItem>);

impl DrbsSubjectToStatusTransferList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(32), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(DrbsSubjectToStatusTransferItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(32), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for DrbsSubjectToStatusTransferList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        DrbsSubjectToStatusTransferList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DrbsSubjectToStatusTransferList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DrbsSubjectToStatusTransferList");
            e
        })
    }
}
// DrbsSubjectToStatusTransferItem
#[derive(Clone, Debug)]
pub struct DrbsSubjectToStatusTransferItem {
    pub drb_id: DrbId,
    pub drb_status_ul: DrbStatusUl,
    pub drb_status_dl: DrbStatusDl,
    pub old_associated_qos_flow_list_ul_endmarkerexpected: Option<AssociatedQosFlowList>,
}

impl DrbsSubjectToStatusTransferItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let drb_id = DrbId::decode(data)?;
        let drb_status_ul = DrbStatusUl::decode(data)?;
        let drb_status_dl = DrbStatusDl::decode(data)?;

        // Process the extension container
        let mut old_associated_qos_flow_list_ul_endmarkerexpected: Option<AssociatedQosFlowList> =
            None;

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    159 => {
                        old_associated_qos_flow_list_ul_endmarkerexpected =
                            Some(AssociatedQosFlowList::decode(data)?)
                    }
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            drb_id,
            drb_status_ul,
            drb_status_dl,
            old_associated_qos_flow_list_ul_endmarkerexpected,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();
        if let Some(x) = &self.old_associated_qos_flow_list_ul_endmarkerexpected {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 159, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        let mut optionals = BitString::new();
        optionals.push(num_ies != 0);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.drb_id.encode(data)?;
        self.drb_status_ul.encode(data)?;
        self.drb_status_dl.encode(data)?;
        if num_ies != 0 {
            encode::encode_length_determinent(data, Some(1), Some(65535), false, num_ies)?;
            data.append_aligned(ies);
        }
        Ok(())
    }
}

impl PerCodec for DrbsSubjectToStatusTransferItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        DrbsSubjectToStatusTransferItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DrbsSubjectToStatusTransferItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DrbsSubjectToStatusTransferItem");
            e
        })
    }
}
// DrbStatusDl
#[derive(Clone, Debug)]
pub enum DrbStatusDl {
    DrbStatusDl12(DrbStatusDl12),
    DrbStatusDl18(DrbStatusDl18),
}

impl DrbStatusDl {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_choice_idx(data, 0, 2, false)?;
        if extended {
            return Err(PerCodecError::new("CHOICE additions not implemented"));
        }
        match idx {
            0 => Ok(Self::DrbStatusDl12(DrbStatusDl12::decode(data)?)),
            1 => Ok(Self::DrbStatusDl18(DrbStatusDl18::decode(data)?)),
            2 => {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _ = Criticality::decode(data)?;
                let _ = decode::decode_length_determinent(data, None, None, false)?;
                let result = match id {
                    x => Err(PerCodecError::new(format!("Unrecognised IE type {}", x))),
                };
                data.decode_align()?;
                result
            }
            _ => Err(PerCodecError::new("Unknown choice idx")),
        }
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        match self {
            Self::DrbStatusDl12(x) => {
                encode::encode_choice_idx(data, 0, 2, false, 0, false)?;
                x.encode(data)
            }
            Self::DrbStatusDl18(x) => {
                encode::encode_choice_idx(data, 0, 2, false, 1, false)?;
                x.encode(data)
            }
        }
    }
}

impl PerCodec for DrbStatusDl {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        DrbStatusDl::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DrbStatusDl");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DrbStatusDl");
            e
        })
    }
}
// DrbStatusDl12
#[derive(Clone, Debug)]
pub struct DrbStatusDl12 {
    pub dl_count_value: CountValueForPdcpSn12,
}

impl DrbStatusDl12 {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let dl_count_value = CountValueForPdcpSn12::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self { dl_count_value })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.dl_count_value.encode(data)?;

        Ok(())
    }
}

impl PerCodec for DrbStatusDl12 {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        DrbStatusDl12::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DrbStatusDl12");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DrbStatusDl12");
            e
        })
    }
}
// DrbStatusDl18
#[derive(Clone, Debug)]
pub struct DrbStatusDl18 {
    pub dl_count_value: CountValueForPdcpSn18,
}

impl DrbStatusDl18 {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let dl_count_value = CountValueForPdcpSn18::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self { dl_count_value })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.dl_count_value.encode(data)?;

        Ok(())
    }
}

impl PerCodec for DrbStatusDl18 {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        DrbStatusDl18::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DrbStatusDl18");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DrbStatusDl18");
            e
        })
    }
}
// DrbStatusUl
#[derive(Clone, Debug)]
pub enum DrbStatusUl {
    DrbStatusUl12(DrbStatusUl12),
    DrbStatusUl18(DrbStatusUl18),
}

impl DrbStatusUl {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_choice_idx(data, 0, 2, false)?;
        if extended {
            return Err(PerCodecError::new("CHOICE additions not implemented"));
        }
        match idx {
            0 => Ok(Self::DrbStatusUl12(DrbStatusUl12::decode(data)?)),
            1 => Ok(Self::DrbStatusUl18(DrbStatusUl18::decode(data)?)),
            2 => {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _ = Criticality::decode(data)?;
                let _ = decode::decode_length_determinent(data, None, None, false)?;
                let result = match id {
                    x => Err(PerCodecError::new(format!("Unrecognised IE type {}", x))),
                };
                data.decode_align()?;
                result
            }
            _ => Err(PerCodecError::new("Unknown choice idx")),
        }
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        match self {
            Self::DrbStatusUl12(x) => {
                encode::encode_choice_idx(data, 0, 2, false, 0, false)?;
                x.encode(data)
            }
            Self::DrbStatusUl18(x) => {
                encode::encode_choice_idx(data, 0, 2, false, 1, false)?;
                x.encode(data)
            }
        }
    }
}

impl PerCodec for DrbStatusUl {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        DrbStatusUl::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DrbStatusUl");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DrbStatusUl");
            e
        })
    }
}
// DrbStatusUl12
#[derive(Clone, Debug)]
pub struct DrbStatusUl12 {
    pub ul_count_value: CountValueForPdcpSn12,
    pub receive_status_of_ul_pdcp_s_du_s: Option<BitString>,
}

impl DrbStatusUl12 {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 2)?;
        let ul_count_value = CountValueForPdcpSn12::decode(data)?;
        let receive_status_of_ul_pdcp_s_du_s = if optionals[0] {
            Some(decode::decode_bitstring(data, Some(1), Some(2048), false)?)
        } else {
            None
        };

        // Process the extension container

        if optionals[1] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            ul_count_value,
            receive_status_of_ul_pdcp_s_du_s,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.receive_status_of_ul_pdcp_s_du_s.is_some());
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.ul_count_value.encode(data)?;
        if let Some(x) = &self.receive_status_of_ul_pdcp_s_du_s {
            encode::encode_bitstring(data, Some(1), Some(2048), false, &x, false)?;
        }

        Ok(())
    }
}

impl PerCodec for DrbStatusUl12 {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        DrbStatusUl12::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DrbStatusUl12");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DrbStatusUl12");
            e
        })
    }
}
// DrbStatusUl18
#[derive(Clone, Debug)]
pub struct DrbStatusUl18 {
    pub ul_count_value: CountValueForPdcpSn18,
    pub receive_status_of_ul_pdcp_s_du_s: Option<BitString>,
}

impl DrbStatusUl18 {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 2)?;
        let ul_count_value = CountValueForPdcpSn18::decode(data)?;
        let receive_status_of_ul_pdcp_s_du_s = if optionals[0] {
            Some(decode::decode_bitstring(
                data,
                Some(1),
                Some(131072),
                false,
            )?)
        } else {
            None
        };

        // Process the extension container

        if optionals[1] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            ul_count_value,
            receive_status_of_ul_pdcp_s_du_s,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.receive_status_of_ul_pdcp_s_du_s.is_some());
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.ul_count_value.encode(data)?;
        if let Some(x) = &self.receive_status_of_ul_pdcp_s_du_s {
            encode::encode_bitstring(data, Some(1), Some(131072), false, &x, false)?;
        }

        Ok(())
    }
}

impl PerCodec for DrbStatusUl18 {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        DrbStatusUl18::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DrbStatusUl18");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DrbStatusUl18");
            e
        })
    }
}
// DrbsToQosFlowsMappingList
#[derive(Clone, Debug)]
pub struct DrbsToQosFlowsMappingList(pub NonEmpty<DrbsToQosFlowsMappingItem>);

impl DrbsToQosFlowsMappingList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(32), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(DrbsToQosFlowsMappingItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(32), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for DrbsToQosFlowsMappingList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        DrbsToQosFlowsMappingList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DrbsToQosFlowsMappingList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DrbsToQosFlowsMappingList");
            e
        })
    }
}
// DrbsToQosFlowsMappingItem
#[derive(Clone, Debug)]
pub struct DrbsToQosFlowsMappingItem {
    pub drb_id: DrbId,
    pub associated_qos_flow_list: AssociatedQosFlowList,
    pub daps_request_info: Option<DapsRequestInfo>,
}

impl DrbsToQosFlowsMappingItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let drb_id = DrbId::decode(data)?;
        let associated_qos_flow_list = AssociatedQosFlowList::decode(data)?;

        // Process the extension container
        let mut daps_request_info: Option<DapsRequestInfo> = None;

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    266 => daps_request_info = Some(DapsRequestInfo::decode(data)?),
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            drb_id,
            associated_qos_flow_list,
            daps_request_info,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();
        if let Some(x) = &self.daps_request_info {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 266, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        let mut optionals = BitString::new();
        optionals.push(num_ies != 0);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.drb_id.encode(data)?;
        self.associated_qos_flow_list.encode(data)?;
        if num_ies != 0 {
            encode::encode_length_determinent(data, Some(1), Some(65535), false, num_ies)?;
            data.append_aligned(ies);
        }
        Ok(())
    }
}

impl PerCodec for DrbsToQosFlowsMappingItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        DrbsToQosFlowsMappingItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DrbsToQosFlowsMappingItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DrbsToQosFlowsMappingItem");
            e
        })
    }
}
// Dynamic5qiDescriptor
#[derive(Clone, Debug)]
pub struct Dynamic5qiDescriptor {
    pub priority_level_qos: PriorityLevelQos,
    pub packet_delay_budget: PacketDelayBudget,
    pub packet_error_rate: PacketErrorRate,
    pub five_qi: Option<FiveQi>,
    pub delay_critical: Option<DelayCritical>,
    pub averaging_window: Option<AveragingWindow>,
    pub maximum_data_burst_volume: Option<MaximumDataBurstVolume>,
    pub extended_packet_delay_budget: Option<ExtendedPacketDelayBudget>,
    pub cn_packet_delay_budget_dl: Option<ExtendedPacketDelayBudget>,
    pub cn_packet_delay_budget_ul: Option<ExtendedPacketDelayBudget>,
}

impl Dynamic5qiDescriptor {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 5)?;
        let priority_level_qos = PriorityLevelQos::decode(data)?;
        let packet_delay_budget = PacketDelayBudget::decode(data)?;
        let packet_error_rate = PacketErrorRate::decode(data)?;
        let five_qi = if optionals[0] {
            Some(FiveQi::decode(data)?)
        } else {
            None
        };
        let delay_critical = if optionals[1] {
            Some(DelayCritical::decode(data)?)
        } else {
            None
        };
        let averaging_window = if optionals[2] {
            Some(AveragingWindow::decode(data)?)
        } else {
            None
        };
        let maximum_data_burst_volume = if optionals[3] {
            Some(MaximumDataBurstVolume::decode(data)?)
        } else {
            None
        };

        // Process the extension container
        let mut extended_packet_delay_budget: Option<ExtendedPacketDelayBudget> = None;
        let mut cn_packet_delay_budget_dl: Option<ExtendedPacketDelayBudget> = None;
        let mut cn_packet_delay_budget_ul: Option<ExtendedPacketDelayBudget> = None;

        if optionals[4] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    189 => {
                        extended_packet_delay_budget =
                            Some(ExtendedPacketDelayBudget::decode(data)?)
                    }
                    187 => {
                        cn_packet_delay_budget_dl = Some(ExtendedPacketDelayBudget::decode(data)?)
                    }
                    188 => {
                        cn_packet_delay_budget_ul = Some(ExtendedPacketDelayBudget::decode(data)?)
                    }
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            priority_level_qos,
            packet_delay_budget,
            packet_error_rate,
            five_qi,
            delay_critical,
            averaging_window,
            maximum_data_burst_volume,
            extended_packet_delay_budget,
            cn_packet_delay_budget_dl,
            cn_packet_delay_budget_ul,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();
        if let Some(x) = &self.extended_packet_delay_budget {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 189, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.cn_packet_delay_budget_dl {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 187, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.cn_packet_delay_budget_ul {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 188, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        let mut optionals = BitString::new();
        optionals.push(self.five_qi.is_some());
        optionals.push(self.delay_critical.is_some());
        optionals.push(self.averaging_window.is_some());
        optionals.push(self.maximum_data_burst_volume.is_some());
        optionals.push(num_ies != 0);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.priority_level_qos.encode(data)?;
        self.packet_delay_budget.encode(data)?;
        self.packet_error_rate.encode(data)?;
        if let Some(x) = &self.five_qi {
            x.encode(data)?;
        }
        if let Some(x) = &self.delay_critical {
            x.encode(data)?;
        }
        if let Some(x) = &self.averaging_window {
            x.encode(data)?;
        }
        if let Some(x) = &self.maximum_data_burst_volume {
            x.encode(data)?;
        }
        if num_ies != 0 {
            encode::encode_length_determinent(data, Some(1), Some(65535), false, num_ies)?;
            data.append_aligned(ies);
        }
        Ok(())
    }
}

impl PerCodec for Dynamic5qiDescriptor {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Dynamic5qiDescriptor::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("Dynamic5qiDescriptor");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("Dynamic5qiDescriptor");
            e
        })
    }
}
// EarlyStatusTransferTransparentContainer
#[derive(Clone, Debug)]
pub struct EarlyStatusTransferTransparentContainer {
    pub procedure_stage: ProcedureStageChoice,
}

impl EarlyStatusTransferTransparentContainer {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let procedure_stage = ProcedureStageChoice::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self { procedure_stage })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.procedure_stage.encode(data)?;

        Ok(())
    }
}

impl PerCodec for EarlyStatusTransferTransparentContainer {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        EarlyStatusTransferTransparentContainer::decode_inner(data).map_err(
            |mut e: PerCodecError| {
                e.push_context("EarlyStatusTransferTransparentContainer");
                e
            },
        )
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("EarlyStatusTransferTransparentContainer");
            e
        })
    }
}
// ProcedureStageChoice
#[derive(Clone, Debug)]
pub enum ProcedureStageChoice {
    FirstDlCount(FirstDlCount),
}

impl ProcedureStageChoice {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_choice_idx(data, 0, 1, false)?;
        if extended {
            return Err(PerCodecError::new("CHOICE additions not implemented"));
        }
        match idx {
            0 => Ok(Self::FirstDlCount(FirstDlCount::decode(data)?)),
            1 => {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _ = Criticality::decode(data)?;
                let _ = decode::decode_length_determinent(data, None, None, false)?;
                let result = match id {
                    x => Err(PerCodecError::new(format!("Unrecognised IE type {}", x))),
                };
                data.decode_align()?;
                result
            }
            _ => Err(PerCodecError::new("Unknown choice idx")),
        }
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        match self {
            Self::FirstDlCount(x) => {
                encode::encode_choice_idx(data, 0, 1, false, 0, false)?;
                x.encode(data)
            }
        }
    }
}

impl PerCodec for ProcedureStageChoice {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        ProcedureStageChoice::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ProcedureStageChoice");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ProcedureStageChoice");
            e
        })
    }
}
// FirstDlCount
#[derive(Clone, Debug)]
pub struct FirstDlCount {
    pub drbs_subject_to_early_status_transfer: DrbsSubjectToEarlyStatusTransferList,
}

impl FirstDlCount {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let drbs_subject_to_early_status_transfer =
            DrbsSubjectToEarlyStatusTransferList::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            drbs_subject_to_early_status_transfer,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.drbs_subject_to_early_status_transfer.encode(data)?;

        Ok(())
    }
}

impl PerCodec for FirstDlCount {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        FirstDlCount::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("FirstDlCount");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("FirstDlCount");
            e
        })
    }
}
// DrbsSubjectToEarlyStatusTransferList
#[derive(Clone, Debug)]
pub struct DrbsSubjectToEarlyStatusTransferList(pub NonEmpty<DrbsSubjectToEarlyStatusTransferItem>);

impl DrbsSubjectToEarlyStatusTransferList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(32), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(DrbsSubjectToEarlyStatusTransferItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(32), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for DrbsSubjectToEarlyStatusTransferList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        DrbsSubjectToEarlyStatusTransferList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DrbsSubjectToEarlyStatusTransferList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DrbsSubjectToEarlyStatusTransferList");
            e
        })
    }
}
// DrbsSubjectToEarlyStatusTransferItem
#[derive(Clone, Debug)]
pub struct DrbsSubjectToEarlyStatusTransferItem {
    pub drb_id: DrbId,
    pub first_dl_count: DrbStatusDl,
}

impl DrbsSubjectToEarlyStatusTransferItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let drb_id = DrbId::decode(data)?;
        let first_dl_count = DrbStatusDl::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            drb_id,
            first_dl_count,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.drb_id.encode(data)?;
        self.first_dl_count.encode(data)?;

        Ok(())
    }
}

impl PerCodec for DrbsSubjectToEarlyStatusTransferItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        DrbsSubjectToEarlyStatusTransferItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DrbsSubjectToEarlyStatusTransferItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DrbsSubjectToEarlyStatusTransferItem");
            e
        })
    }
}
// EdtSession
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum EdtSession {
    True,
}

impl EdtSession {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(0), true)?;
        if extended {
            return Err(PerCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(data, Some(0), Some(0), true, *self as i128, false)
    }
}

impl PerCodec for EdtSession {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        EdtSession::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("EdtSession");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("EdtSession");
            e
        })
    }
}
// EmergencyAreaId
#[derive(Clone, Debug)]
pub struct EmergencyAreaId(pub [u8; 3]);

impl EmergencyAreaId {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(
            decode::decode_octetstring(data, Some(3), Some(3), false)?
                .try_into()
                .unwrap(),
        ))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_octetstring(data, Some(3), Some(3), false, &(self.0).into(), false)
    }
}

impl PerCodec for EmergencyAreaId {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        EmergencyAreaId::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("EmergencyAreaId");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("EmergencyAreaId");
            e
        })
    }
}
// EmergencyAreaIdBroadcastEutra
#[derive(Clone, Debug)]
pub struct EmergencyAreaIdBroadcastEutra(pub NonEmpty<EmergencyAreaIdBroadcastEutraItem>);

impl EmergencyAreaIdBroadcastEutra {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(EmergencyAreaIdBroadcastEutraItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(65535), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for EmergencyAreaIdBroadcastEutra {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        EmergencyAreaIdBroadcastEutra::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("EmergencyAreaIdBroadcastEutra");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("EmergencyAreaIdBroadcastEutra");
            e
        })
    }
}
// EmergencyAreaIdBroadcastEutraItem
#[derive(Clone, Debug)]
pub struct EmergencyAreaIdBroadcastEutraItem {
    pub emergency_area_id: EmergencyAreaId,
    pub completed_cells_in_eai_eutra: CompletedCellsInEaiEutra,
}

impl EmergencyAreaIdBroadcastEutraItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let emergency_area_id = EmergencyAreaId::decode(data)?;
        let completed_cells_in_eai_eutra = CompletedCellsInEaiEutra::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            emergency_area_id,
            completed_cells_in_eai_eutra,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.emergency_area_id.encode(data)?;
        self.completed_cells_in_eai_eutra.encode(data)?;

        Ok(())
    }
}

impl PerCodec for EmergencyAreaIdBroadcastEutraItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        EmergencyAreaIdBroadcastEutraItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("EmergencyAreaIdBroadcastEutraItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("EmergencyAreaIdBroadcastEutraItem");
            e
        })
    }
}
// EmergencyAreaIdBroadcastNr
#[derive(Clone, Debug)]
pub struct EmergencyAreaIdBroadcastNr(pub NonEmpty<EmergencyAreaIdBroadcastNrItem>);

impl EmergencyAreaIdBroadcastNr {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(EmergencyAreaIdBroadcastNrItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(65535), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for EmergencyAreaIdBroadcastNr {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        EmergencyAreaIdBroadcastNr::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("EmergencyAreaIdBroadcastNr");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("EmergencyAreaIdBroadcastNr");
            e
        })
    }
}
// EmergencyAreaIdBroadcastNrItem
#[derive(Clone, Debug)]
pub struct EmergencyAreaIdBroadcastNrItem {
    pub emergency_area_id: EmergencyAreaId,
    pub completed_cells_in_eai_nr: CompletedCellsInEaiNr,
}

impl EmergencyAreaIdBroadcastNrItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let emergency_area_id = EmergencyAreaId::decode(data)?;
        let completed_cells_in_eai_nr = CompletedCellsInEaiNr::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            emergency_area_id,
            completed_cells_in_eai_nr,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.emergency_area_id.encode(data)?;
        self.completed_cells_in_eai_nr.encode(data)?;

        Ok(())
    }
}

impl PerCodec for EmergencyAreaIdBroadcastNrItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        EmergencyAreaIdBroadcastNrItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("EmergencyAreaIdBroadcastNrItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("EmergencyAreaIdBroadcastNrItem");
            e
        })
    }
}
// EmergencyAreaIdCancelledEutra
#[derive(Clone, Debug)]
pub struct EmergencyAreaIdCancelledEutra(pub NonEmpty<EmergencyAreaIdCancelledEutraItem>);

impl EmergencyAreaIdCancelledEutra {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(EmergencyAreaIdCancelledEutraItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(65535), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for EmergencyAreaIdCancelledEutra {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        EmergencyAreaIdCancelledEutra::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("EmergencyAreaIdCancelledEutra");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("EmergencyAreaIdCancelledEutra");
            e
        })
    }
}
// EmergencyAreaIdCancelledEutraItem
#[derive(Clone, Debug)]
pub struct EmergencyAreaIdCancelledEutraItem {
    pub emergency_area_id: EmergencyAreaId,
    pub cancelled_cells_in_eai_eutra: CancelledCellsInEaiEutra,
}

impl EmergencyAreaIdCancelledEutraItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let emergency_area_id = EmergencyAreaId::decode(data)?;
        let cancelled_cells_in_eai_eutra = CancelledCellsInEaiEutra::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            emergency_area_id,
            cancelled_cells_in_eai_eutra,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.emergency_area_id.encode(data)?;
        self.cancelled_cells_in_eai_eutra.encode(data)?;

        Ok(())
    }
}

impl PerCodec for EmergencyAreaIdCancelledEutraItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        EmergencyAreaIdCancelledEutraItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("EmergencyAreaIdCancelledEutraItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("EmergencyAreaIdCancelledEutraItem");
            e
        })
    }
}
// EmergencyAreaIdCancelledNr
#[derive(Clone, Debug)]
pub struct EmergencyAreaIdCancelledNr(pub NonEmpty<EmergencyAreaIdCancelledNrItem>);

impl EmergencyAreaIdCancelledNr {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(EmergencyAreaIdCancelledNrItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(65535), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for EmergencyAreaIdCancelledNr {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        EmergencyAreaIdCancelledNr::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("EmergencyAreaIdCancelledNr");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("EmergencyAreaIdCancelledNr");
            e
        })
    }
}
// EmergencyAreaIdCancelledNrItem
#[derive(Clone, Debug)]
pub struct EmergencyAreaIdCancelledNrItem {
    pub emergency_area_id: EmergencyAreaId,
    pub cancelled_cells_in_eai_nr: CancelledCellsInEaiNr,
}

impl EmergencyAreaIdCancelledNrItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let emergency_area_id = EmergencyAreaId::decode(data)?;
        let cancelled_cells_in_eai_nr = CancelledCellsInEaiNr::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            emergency_area_id,
            cancelled_cells_in_eai_nr,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.emergency_area_id.encode(data)?;
        self.cancelled_cells_in_eai_nr.encode(data)?;

        Ok(())
    }
}

impl PerCodec for EmergencyAreaIdCancelledNrItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        EmergencyAreaIdCancelledNrItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("EmergencyAreaIdCancelledNrItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("EmergencyAreaIdCancelledNrItem");
            e
        })
    }
}
// EmergencyAreaIdList
#[derive(Clone, Debug)]
pub struct EmergencyAreaIdList(pub NonEmpty<EmergencyAreaId>);

impl EmergencyAreaIdList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(EmergencyAreaId::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(65535), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for EmergencyAreaIdList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        EmergencyAreaIdList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("EmergencyAreaIdList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("EmergencyAreaIdList");
            e
        })
    }
}
// EmergencyAreaIdListForRestart
#[derive(Clone, Debug)]
pub struct EmergencyAreaIdListForRestart(pub NonEmpty<EmergencyAreaId>);

impl EmergencyAreaIdListForRestart {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(256), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(EmergencyAreaId::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(256), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for EmergencyAreaIdListForRestart {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        EmergencyAreaIdListForRestart::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("EmergencyAreaIdListForRestart");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("EmergencyAreaIdListForRestart");
            e
        })
    }
}
// EmergencyFallbackIndicator
#[derive(Clone, Debug)]
pub struct EmergencyFallbackIndicator {
    pub emergency_fallback_request_indicator: EmergencyFallbackRequestIndicator,
    pub emergency_service_target_cn: Option<EmergencyServiceTargetCn>,
}

impl EmergencyFallbackIndicator {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 2)?;
        let emergency_fallback_request_indicator = EmergencyFallbackRequestIndicator::decode(data)?;
        let emergency_service_target_cn = if optionals[0] {
            Some(EmergencyServiceTargetCn::decode(data)?)
        } else {
            None
        };

        // Process the extension container

        if optionals[1] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            emergency_fallback_request_indicator,
            emergency_service_target_cn,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.emergency_service_target_cn.is_some());
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.emergency_fallback_request_indicator.encode(data)?;
        if let Some(x) = &self.emergency_service_target_cn {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl PerCodec for EmergencyFallbackIndicator {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        EmergencyFallbackIndicator::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("EmergencyFallbackIndicator");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("EmergencyFallbackIndicator");
            e
        })
    }
}
// EmergencyFallbackRequestIndicator
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum EmergencyFallbackRequestIndicator {
    EmergencyFallbackRequested,
}

impl EmergencyFallbackRequestIndicator {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(0), true)?;
        if extended {
            return Err(PerCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(data, Some(0), Some(0), true, *self as i128, false)
    }
}

impl PerCodec for EmergencyFallbackRequestIndicator {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        EmergencyFallbackRequestIndicator::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("EmergencyFallbackRequestIndicator");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("EmergencyFallbackRequestIndicator");
            e
        })
    }
}
// EmergencyServiceTargetCn
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum EmergencyServiceTargetCn {
    FiveGc,
    Epc,
}

impl EmergencyServiceTargetCn {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(1), true)?;
        if extended {
            return Err(PerCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(data, Some(0), Some(1), true, *self as i128, false)
    }
}

impl PerCodec for EmergencyServiceTargetCn {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        EmergencyServiceTargetCn::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("EmergencyServiceTargetCn");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("EmergencyServiceTargetCn");
            e
        })
    }
}
// EnbId
#[derive(Clone, Debug)]
pub enum EnbId {
    MacroEnbId(BitString),
    HomeEnbId(BitString),
    ShortMacroEnbId(BitString),
    LongMacroEnbId(BitString),
}

impl EnbId {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_choice_idx(data, 0, 4, false)?;
        if extended {
            return Err(PerCodecError::new("CHOICE additions not implemented"));
        }
        match idx {
            0 => Ok(Self::MacroEnbId(decode::decode_bitstring(
                data,
                Some(20),
                Some(20),
                false,
            )?)),
            1 => Ok(Self::HomeEnbId(decode::decode_bitstring(
                data,
                Some(28),
                Some(28),
                false,
            )?)),
            2 => Ok(Self::ShortMacroEnbId(decode::decode_bitstring(
                data,
                Some(18),
                Some(18),
                false,
            )?)),
            3 => Ok(Self::LongMacroEnbId(decode::decode_bitstring(
                data,
                Some(21),
                Some(21),
                false,
            )?)),
            4 => {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _ = Criticality::decode(data)?;
                let _ = decode::decode_length_determinent(data, None, None, false)?;
                let result = match id {
                    x => Err(PerCodecError::new(format!("Unrecognised IE type {}", x))),
                };
                data.decode_align()?;
                result
            }
            _ => Err(PerCodecError::new("Unknown choice idx")),
        }
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        match self {
            Self::MacroEnbId(x) => {
                encode::encode_choice_idx(data, 0, 4, false, 0, false)?;
                encode::encode_bitstring(data, Some(20), Some(20), false, &x, false)
            }
            Self::HomeEnbId(x) => {
                encode::encode_choice_idx(data, 0, 4, false, 1, false)?;
                encode::encode_bitstring(data, Some(28), Some(28), false, &x, false)
            }
            Self::ShortMacroEnbId(x) => {
                encode::encode_choice_idx(data, 0, 4, false, 2, false)?;
                encode::encode_bitstring(data, Some(18), Some(18), false, &x, false)
            }
            Self::LongMacroEnbId(x) => {
                encode::encode_choice_idx(data, 0, 4, false, 3, false)?;
                encode::encode_bitstring(data, Some(21), Some(21), false, &x, false)
            }
        }
    }
}

impl PerCodec for EnbId {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        EnbId::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("EnbId");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("EnbId");
            e
        })
    }
}
// EnhancedCoverageRestriction
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum EnhancedCoverageRestriction {
    Restricted,
}

impl EnhancedCoverageRestriction {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(0), true)?;
        if extended {
            return Err(PerCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(data, Some(0), Some(0), true, *self as i128, false)
    }
}

impl PerCodec for EnhancedCoverageRestriction {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        EnhancedCoverageRestriction::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("EnhancedCoverageRestriction");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("EnhancedCoverageRestriction");
            e
        })
    }
}
// ExtendedConnectedTime
#[derive(Clone, Copy, Debug)]
pub struct ExtendedConnectedTime(pub u8);

impl ExtendedConnectedTime {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(
            decode::decode_integer(data, Some(0), Some(255), false)?.0 as u8,
        ))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_integer(data, Some(0), Some(255), false, self.0 as i128, false)
    }
}

impl PerCodec for ExtendedConnectedTime {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        ExtendedConnectedTime::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ExtendedConnectedTime");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ExtendedConnectedTime");
            e
        })
    }
}
// EnDcsonConfigurationTransfer
#[derive(Clone, Debug)]
pub struct EnDcsonConfigurationTransfer(pub Vec<u8>);

impl EnDcsonConfigurationTransfer {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(decode::decode_octetstring(data, None, None, false)?))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_octetstring(data, None, None, false, &self.0, false)
    }
}

impl PerCodec for EnDcsonConfigurationTransfer {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        EnDcsonConfigurationTransfer::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("EnDcsonConfigurationTransfer");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("EnDcsonConfigurationTransfer");
            e
        })
    }
}
// EndpointIpAddressAndPort
#[derive(Clone, Debug)]
pub struct EndpointIpAddressAndPort {
    pub endpoint_ip_address: TransportLayerAddress,
    pub port_number: PortNumber,
}

impl EndpointIpAddressAndPort {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, false, 1)?;
        let endpoint_ip_address = TransportLayerAddress::decode(data)?;
        let port_number = PortNumber::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            endpoint_ip_address,
            port_number,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, false, &optionals, false)?;
        self.endpoint_ip_address.encode(data)?;
        self.port_number.encode(data)?;

        Ok(())
    }
}

impl PerCodec for EndpointIpAddressAndPort {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        EndpointIpAddressAndPort::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("EndpointIpAddressAndPort");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("EndpointIpAddressAndPort");
            e
        })
    }
}
// EndIndication
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum EndIndication {
    NoFurtherData,
    FurtherDataExists,
}

impl EndIndication {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(1), true)?;
        if extended {
            return Err(PerCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(data, Some(0), Some(1), true, *self as i128, false)
    }
}

impl PerCodec for EndIndication {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        EndIndication::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("EndIndication");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("EndIndication");
            e
        })
    }
}
// EquivalentPlmns
#[derive(Clone, Debug)]
pub struct EquivalentPlmns(pub NonEmpty<PlmnIdentity>);

impl EquivalentPlmns {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(15), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(PlmnIdentity::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(15), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for EquivalentPlmns {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        EquivalentPlmns::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("EquivalentPlmns");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("EquivalentPlmns");
            e
        })
    }
}
// EpsTac
#[derive(Clone, Debug)]
pub struct EpsTac(pub [u8; 2]);

impl EpsTac {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(
            decode::decode_octetstring(data, Some(2), Some(2), false)?
                .try_into()
                .unwrap(),
        ))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_octetstring(data, Some(2), Some(2), false, &(self.0).into(), false)
    }
}

impl PerCodec for EpsTac {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        EpsTac::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("EpsTac");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("EpsTac");
            e
        })
    }
}
// EpsTai
#[derive(Clone, Debug)]
pub struct EpsTai {
    pub plmn_identity: PlmnIdentity,
    pub eps_tac: EpsTac,
}

impl EpsTai {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let plmn_identity = PlmnIdentity::decode(data)?;
        let eps_tac = EpsTac::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            plmn_identity,
            eps_tac,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.plmn_identity.encode(data)?;
        self.eps_tac.encode(data)?;

        Ok(())
    }
}

impl PerCodec for EpsTai {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        EpsTai::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("EpsTai");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("EpsTai");
            e
        })
    }
}
// ERabId
#[derive(Clone, Copy, Debug)]
pub struct ERabId(pub u8);

impl ERabId {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(
            decode::decode_integer(data, Some(0), Some(15), true)?.0 as u8,
        ))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_integer(data, Some(0), Some(15), true, self.0 as i128, false)
    }
}

impl PerCodec for ERabId {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        ERabId::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ERabId");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ERabId");
            e
        })
    }
}
// ERabInformationList
#[derive(Clone, Debug)]
pub struct ERabInformationList(pub NonEmpty<ERabInformationItem>);

impl ERabInformationList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(256), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(ERabInformationItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(256), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for ERabInformationList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        ERabInformationList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ERabInformationList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ERabInformationList");
            e
        })
    }
}
// ERabInformationItem
#[derive(Clone, Debug)]
pub struct ERabInformationItem {
    pub e_rab_id: ERabId,
    pub dl_forwarding: Option<DlForwarding>,
}

impl ERabInformationItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 2)?;
        let e_rab_id = ERabId::decode(data)?;
        let dl_forwarding = if optionals[0] {
            Some(DlForwarding::decode(data)?)
        } else {
            None
        };

        // Process the extension container

        if optionals[1] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            e_rab_id,
            dl_forwarding,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.dl_forwarding.is_some());
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.e_rab_id.encode(data)?;
        if let Some(x) = &self.dl_forwarding {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl PerCodec for ERabInformationItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        ERabInformationItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ERabInformationItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ERabInformationItem");
            e
        })
    }
}
// EutraCellIdentity
#[derive(Clone, Debug)]
pub struct EutraCellIdentity(pub BitString);

impl EutraCellIdentity {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(decode::decode_bitstring(
            data,
            Some(28),
            Some(28),
            false,
        )?))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_bitstring(data, Some(28), Some(28), false, &self.0, false)
    }
}

impl PerCodec for EutraCellIdentity {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        EutraCellIdentity::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("EutraCellIdentity");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("EutraCellIdentity");
            e
        })
    }
}
// EutraCgi
#[derive(Clone, Debug)]
pub struct EutraCgi {
    pub plmn_identity: PlmnIdentity,
    pub eutra_cell_identity: EutraCellIdentity,
}

impl EutraCgi {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let plmn_identity = PlmnIdentity::decode(data)?;
        let eutra_cell_identity = EutraCellIdentity::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            plmn_identity,
            eutra_cell_identity,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.plmn_identity.encode(data)?;
        self.eutra_cell_identity.encode(data)?;

        Ok(())
    }
}

impl PerCodec for EutraCgi {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        EutraCgi::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("EutraCgi");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("EutraCgi");
            e
        })
    }
}
// EutraCgiList
#[derive(Clone, Debug)]
pub struct EutraCgiList(pub NonEmpty<EutraCgi>);

impl EutraCgiList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(256), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(EutraCgi::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(256), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for EutraCgiList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        EutraCgiList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("EutraCgiList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("EutraCgiList");
            e
        })
    }
}
// EutraCgiListForWarning
#[derive(Clone, Debug)]
pub struct EutraCgiListForWarning(pub NonEmpty<EutraCgi>);

impl EutraCgiListForWarning {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(EutraCgi::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(65535), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for EutraCgiListForWarning {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        EutraCgiListForWarning::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("EutraCgiListForWarning");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("EutraCgiListForWarning");
            e
        })
    }
}
// EutrAencryptionAlgorithms
#[derive(Clone, Debug)]
pub struct EutrAencryptionAlgorithms(pub BitString);

impl EutrAencryptionAlgorithms {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(decode::decode_bitstring(
            data,
            Some(16),
            Some(16),
            true,
        )?))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_bitstring(data, Some(16), Some(16), true, &self.0, false)
    }
}

impl PerCodec for EutrAencryptionAlgorithms {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        EutrAencryptionAlgorithms::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("EutrAencryptionAlgorithms");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("EutrAencryptionAlgorithms");
            e
        })
    }
}
// EutrAintegrityProtectionAlgorithms
#[derive(Clone, Debug)]
pub struct EutrAintegrityProtectionAlgorithms(pub BitString);

impl EutrAintegrityProtectionAlgorithms {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(decode::decode_bitstring(
            data,
            Some(16),
            Some(16),
            true,
        )?))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_bitstring(data, Some(16), Some(16), true, &self.0, false)
    }
}

impl PerCodec for EutrAintegrityProtectionAlgorithms {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        EutrAintegrityProtectionAlgorithms::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("EutrAintegrityProtectionAlgorithms");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("EutrAintegrityProtectionAlgorithms");
            e
        })
    }
}
// EventType
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum EventType {
    Direct,
    ChangeOfServeCell,
    UePresenceInAreaOfInterest,
    StopChangeOfServeCell,
    StopUePresenceInAreaOfInterest,
    CancelLocationReportingForTheUe,
}

impl EventType {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(5), true)?;
        if extended {
            return Err(PerCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(data, Some(0), Some(5), true, *self as i128, false)
    }
}

impl PerCodec for EventType {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        EventType::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("EventType");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("EventType");
            e
        })
    }
}
// ExpectedActivityPeriod
#[derive(Clone, Copy, Debug)]
pub struct ExpectedActivityPeriod(pub u8);

impl ExpectedActivityPeriod {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(
            decode::decode_integer(data, Some(1), Some(181), true)?.0 as u8,
        ))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_integer(data, Some(1), Some(181), true, self.0 as i128, false)
    }
}

impl PerCodec for ExpectedActivityPeriod {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        ExpectedActivityPeriod::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ExpectedActivityPeriod");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ExpectedActivityPeriod");
            e
        })
    }
}
// ExpectedHoInterval
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum ExpectedHoInterval {
    Sec15,
    Sec30,
    Sec60,
    Sec90,
    Sec120,
    Sec180,
    LongTime,
}

impl ExpectedHoInterval {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(6), true)?;
        if extended {
            return Err(PerCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(data, Some(0), Some(6), true, *self as i128, false)
    }
}

impl PerCodec for ExpectedHoInterval {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        ExpectedHoInterval::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ExpectedHoInterval");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ExpectedHoInterval");
            e
        })
    }
}
// ExpectedIdlePeriod
#[derive(Clone, Copy, Debug)]
pub struct ExpectedIdlePeriod(pub u8);

impl ExpectedIdlePeriod {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(
            decode::decode_integer(data, Some(1), Some(181), true)?.0 as u8,
        ))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_integer(data, Some(1), Some(181), true, self.0 as i128, false)
    }
}

impl PerCodec for ExpectedIdlePeriod {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        ExpectedIdlePeriod::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ExpectedIdlePeriod");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ExpectedIdlePeriod");
            e
        })
    }
}
// ExpectedUeActivityBehaviour
#[derive(Clone, Debug)]
pub struct ExpectedUeActivityBehaviour {
    pub expected_activity_period: Option<ExpectedActivityPeriod>,
    pub expected_idle_period: Option<ExpectedIdlePeriod>,
    pub source_of_ue_activity_behaviour_information: Option<SourceOfUeActivityBehaviourInformation>,
}

impl ExpectedUeActivityBehaviour {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 4)?;
        let expected_activity_period = if optionals[0] {
            Some(ExpectedActivityPeriod::decode(data)?)
        } else {
            None
        };
        let expected_idle_period = if optionals[1] {
            Some(ExpectedIdlePeriod::decode(data)?)
        } else {
            None
        };
        let source_of_ue_activity_behaviour_information = if optionals[2] {
            Some(SourceOfUeActivityBehaviourInformation::decode(data)?)
        } else {
            None
        };

        // Process the extension container

        if optionals[3] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            expected_activity_period,
            expected_idle_period,
            source_of_ue_activity_behaviour_information,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.expected_activity_period.is_some());
        optionals.push(self.expected_idle_period.is_some());
        optionals.push(self.source_of_ue_activity_behaviour_information.is_some());
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        if let Some(x) = &self.expected_activity_period {
            x.encode(data)?;
        }
        if let Some(x) = &self.expected_idle_period {
            x.encode(data)?;
        }
        if let Some(x) = &self.source_of_ue_activity_behaviour_information {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl PerCodec for ExpectedUeActivityBehaviour {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        ExpectedUeActivityBehaviour::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ExpectedUeActivityBehaviour");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ExpectedUeActivityBehaviour");
            e
        })
    }
}
// ExpectedUeBehaviour
#[derive(Clone, Debug)]
pub struct ExpectedUeBehaviour {
    pub expected_ue_activity_behaviour: Option<ExpectedUeActivityBehaviour>,
    pub expected_ho_interval: Option<ExpectedHoInterval>,
    pub expected_ue_mobility: Option<ExpectedUeMobility>,
    pub expected_ue_moving_trajectory: Option<ExpectedUeMovingTrajectory>,
}

impl ExpectedUeBehaviour {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 5)?;
        let expected_ue_activity_behaviour = if optionals[0] {
            Some(ExpectedUeActivityBehaviour::decode(data)?)
        } else {
            None
        };
        let expected_ho_interval = if optionals[1] {
            Some(ExpectedHoInterval::decode(data)?)
        } else {
            None
        };
        let expected_ue_mobility = if optionals[2] {
            Some(ExpectedUeMobility::decode(data)?)
        } else {
            None
        };
        let expected_ue_moving_trajectory = if optionals[3] {
            Some(ExpectedUeMovingTrajectory::decode(data)?)
        } else {
            None
        };

        // Process the extension container

        if optionals[4] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            expected_ue_activity_behaviour,
            expected_ho_interval,
            expected_ue_mobility,
            expected_ue_moving_trajectory,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.expected_ue_activity_behaviour.is_some());
        optionals.push(self.expected_ho_interval.is_some());
        optionals.push(self.expected_ue_mobility.is_some());
        optionals.push(self.expected_ue_moving_trajectory.is_some());
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        if let Some(x) = &self.expected_ue_activity_behaviour {
            x.encode(data)?;
        }
        if let Some(x) = &self.expected_ho_interval {
            x.encode(data)?;
        }
        if let Some(x) = &self.expected_ue_mobility {
            x.encode(data)?;
        }
        if let Some(x) = &self.expected_ue_moving_trajectory {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl PerCodec for ExpectedUeBehaviour {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        ExpectedUeBehaviour::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ExpectedUeBehaviour");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ExpectedUeBehaviour");
            e
        })
    }
}
// ExpectedUeMobility
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum ExpectedUeMobility {
    Stationary,
    Mobile,
}

impl ExpectedUeMobility {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(1), true)?;
        if extended {
            return Err(PerCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(data, Some(0), Some(1), true, *self as i128, false)
    }
}

impl PerCodec for ExpectedUeMobility {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        ExpectedUeMobility::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ExpectedUeMobility");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ExpectedUeMobility");
            e
        })
    }
}
// ExpectedUeMovingTrajectory
#[derive(Clone, Debug)]
pub struct ExpectedUeMovingTrajectory(pub NonEmpty<ExpectedUeMovingTrajectoryItem>);

impl ExpectedUeMovingTrajectory {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(16), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(ExpectedUeMovingTrajectoryItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(16), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for ExpectedUeMovingTrajectory {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        ExpectedUeMovingTrajectory::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ExpectedUeMovingTrajectory");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ExpectedUeMovingTrajectory");
            e
        })
    }
}
// ExpectedUeMovingTrajectoryItem
#[derive(Clone, Debug)]
pub struct ExpectedUeMovingTrajectoryItem {
    pub ngran_cgi: NgranCgi,
    pub time_stayed_in_cell: Option<u16>,
}

impl ExpectedUeMovingTrajectoryItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 2)?;
        let ngran_cgi = NgranCgi::decode(data)?;
        let time_stayed_in_cell = if optionals[0] {
            Some(decode::decode_integer(data, Some(0), Some(4095), false)?.0 as u16)
        } else {
            None
        };

        // Process the extension container

        if optionals[1] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            ngran_cgi,
            time_stayed_in_cell,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.time_stayed_in_cell.is_some());
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.ngran_cgi.encode(data)?;
        if let Some(x) = &self.time_stayed_in_cell {
            encode::encode_integer(data, Some(0), Some(4095), false, *x as i128, false)?;
        }

        Ok(())
    }
}

impl PerCodec for ExpectedUeMovingTrajectoryItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        ExpectedUeMovingTrajectoryItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ExpectedUeMovingTrajectoryItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ExpectedUeMovingTrajectoryItem");
            e
        })
    }
}
// ExtendedAmfName
#[derive(Clone, Debug)]
pub struct ExtendedAmfName {
    pub amf_name_visible_string: Option<AmfNameVisibleString>,
    pub amf_name_utf8_string: Option<AmfNameUtf8String>,
}

impl ExtendedAmfName {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 3)?;
        let amf_name_visible_string = if optionals[0] {
            Some(AmfNameVisibleString::decode(data)?)
        } else {
            None
        };
        let amf_name_utf8_string = if optionals[1] {
            Some(AmfNameUtf8String::decode(data)?)
        } else {
            None
        };

        // Process the extension container

        if optionals[2] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            amf_name_visible_string,
            amf_name_utf8_string,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.amf_name_visible_string.is_some());
        optionals.push(self.amf_name_utf8_string.is_some());
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        if let Some(x) = &self.amf_name_visible_string {
            x.encode(data)?;
        }
        if let Some(x) = &self.amf_name_utf8_string {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl PerCodec for ExtendedAmfName {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        ExtendedAmfName::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ExtendedAmfName");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ExtendedAmfName");
            e
        })
    }
}
// ExtendedPacketDelayBudget
#[derive(Clone, Copy, Debug)]
pub struct ExtendedPacketDelayBudget(pub u16);

impl ExtendedPacketDelayBudget {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(
            decode::decode_integer(data, Some(1), Some(65535), true)?.0 as u16,
        ))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_integer(data, Some(1), Some(65535), true, self.0 as i128, false)
    }
}

impl PerCodec for ExtendedPacketDelayBudget {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        ExtendedPacketDelayBudget::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ExtendedPacketDelayBudget");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ExtendedPacketDelayBudget");
            e
        })
    }
}
// ExtendedRanNodeName
#[derive(Clone, Debug)]
pub struct ExtendedRanNodeName {
    pub ran_node_name_visible_string: Option<RanNodeNameVisibleString>,
    pub ran_node_name_utf8_string: Option<RanNodeNameUtf8String>,
}

impl ExtendedRanNodeName {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 3)?;
        let ran_node_name_visible_string = if optionals[0] {
            Some(RanNodeNameVisibleString::decode(data)?)
        } else {
            None
        };
        let ran_node_name_utf8_string = if optionals[1] {
            Some(RanNodeNameUtf8String::decode(data)?)
        } else {
            None
        };

        // Process the extension container

        if optionals[2] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            ran_node_name_visible_string,
            ran_node_name_utf8_string,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.ran_node_name_visible_string.is_some());
        optionals.push(self.ran_node_name_utf8_string.is_some());
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        if let Some(x) = &self.ran_node_name_visible_string {
            x.encode(data)?;
        }
        if let Some(x) = &self.ran_node_name_utf8_string {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl PerCodec for ExtendedRanNodeName {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        ExtendedRanNodeName::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ExtendedRanNodeName");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ExtendedRanNodeName");
            e
        })
    }
}
// ExtendedRatRestrictionInformation
#[derive(Clone, Debug)]
pub struct ExtendedRatRestrictionInformation {
    pub primary_rat_restriction: BitString,
    pub secondary_rat_restriction: BitString,
}

impl ExtendedRatRestrictionInformation {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let primary_rat_restriction = decode::decode_bitstring(data, Some(8), Some(8), true)?;
        let secondary_rat_restriction = decode::decode_bitstring(data, Some(8), Some(8), true)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            primary_rat_restriction,
            secondary_rat_restriction,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        encode::encode_bitstring(
            data,
            Some(8),
            Some(8),
            true,
            &self.primary_rat_restriction,
            false,
        )?;
        encode::encode_bitstring(
            data,
            Some(8),
            Some(8),
            true,
            &self.secondary_rat_restriction,
            false,
        )?;

        Ok(())
    }
}

impl PerCodec for ExtendedRatRestrictionInformation {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        ExtendedRatRestrictionInformation::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ExtendedRatRestrictionInformation");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ExtendedRatRestrictionInformation");
            e
        })
    }
}
// ExtendedRncId
#[derive(Clone, Copy, Debug)]
pub struct ExtendedRncId(pub u16);

impl ExtendedRncId {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(
            decode::decode_integer(data, Some(4096), Some(65535), false)?.0 as u16,
        ))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_integer(data, Some(4096), Some(65535), false, self.0 as i128, false)
    }
}

impl PerCodec for ExtendedRncId {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        ExtendedRncId::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ExtendedRncId");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ExtendedRncId");
            e
        })
    }
}
// ExtendedSliceSupportList
#[derive(Clone, Debug)]
pub struct ExtendedSliceSupportList(pub NonEmpty<SliceSupportItem>);

impl ExtendedSliceSupportList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(SliceSupportItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(65535), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for ExtendedSliceSupportList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        ExtendedSliceSupportList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ExtendedSliceSupportList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ExtendedSliceSupportList");
            e
        })
    }
}
// ExtendedUeIdentityIndexValue
#[derive(Clone, Debug)]
pub struct ExtendedUeIdentityIndexValue(pub BitString);

impl ExtendedUeIdentityIndexValue {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(decode::decode_bitstring(
            data,
            Some(16),
            Some(16),
            false,
        )?))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_bitstring(data, Some(16), Some(16), false, &self.0, false)
    }
}

impl PerCodec for ExtendedUeIdentityIndexValue {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        ExtendedUeIdentityIndexValue::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ExtendedUeIdentityIndexValue");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ExtendedUeIdentityIndexValue");
            e
        })
    }
}
// EventTrigger
#[derive(Clone, Debug)]
pub enum EventTrigger {
    OutOfCoverage(OutOfCoverage),
    EventL1LoggedMdtConfig(EventL1LoggedMdtConfig),
}

impl EventTrigger {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_choice_idx(data, 0, 2, false)?;
        if extended {
            return Err(PerCodecError::new("CHOICE additions not implemented"));
        }
        match idx {
            0 => Ok(Self::OutOfCoverage(OutOfCoverage::decode(data)?)),
            1 => Ok(Self::EventL1LoggedMdtConfig(
                EventL1LoggedMdtConfig::decode(data)?,
            )),
            2 => {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _ = Criticality::decode(data)?;
                let _ = decode::decode_length_determinent(data, None, None, false)?;
                let result = match id {
                    x => Err(PerCodecError::new(format!("Unrecognised IE type {}", x))),
                };
                data.decode_align()?;
                result
            }
            _ => Err(PerCodecError::new("Unknown choice idx")),
        }
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        match self {
            Self::OutOfCoverage(x) => {
                encode::encode_choice_idx(data, 0, 2, false, 0, false)?;
                x.encode(data)
            }
            Self::EventL1LoggedMdtConfig(x) => {
                encode::encode_choice_idx(data, 0, 2, false, 1, false)?;
                x.encode(data)
            }
        }
    }
}

impl PerCodec for EventTrigger {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        EventTrigger::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("EventTrigger");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("EventTrigger");
            e
        })
    }
}
// EventL1LoggedMdtConfig
#[derive(Clone, Debug)]
pub struct EventL1LoggedMdtConfig {
    pub l1_threshold: MeasurementThresholdL1LoggedMdt,
    pub hysteresis: Hysteresis,
    pub time_to_trigger: TimeToTrigger,
}

impl EventL1LoggedMdtConfig {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let l1_threshold = MeasurementThresholdL1LoggedMdt::decode(data)?;
        let hysteresis = Hysteresis::decode(data)?;
        let time_to_trigger = TimeToTrigger::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            l1_threshold,
            hysteresis,
            time_to_trigger,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.l1_threshold.encode(data)?;
        self.hysteresis.encode(data)?;
        self.time_to_trigger.encode(data)?;

        Ok(())
    }
}

impl PerCodec for EventL1LoggedMdtConfig {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        EventL1LoggedMdtConfig::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("EventL1LoggedMdtConfig");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("EventL1LoggedMdtConfig");
            e
        })
    }
}
// MeasurementThresholdL1LoggedMdt
#[derive(Clone, Debug)]
pub enum MeasurementThresholdL1LoggedMdt {
    ThresholdRsrp(ThresholdRsrp),
    ThresholdRsrq(ThresholdRsrq),
}

impl MeasurementThresholdL1LoggedMdt {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_choice_idx(data, 0, 2, false)?;
        if extended {
            return Err(PerCodecError::new("CHOICE additions not implemented"));
        }
        match idx {
            0 => Ok(Self::ThresholdRsrp(ThresholdRsrp::decode(data)?)),
            1 => Ok(Self::ThresholdRsrq(ThresholdRsrq::decode(data)?)),
            2 => {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _ = Criticality::decode(data)?;
                let _ = decode::decode_length_determinent(data, None, None, false)?;
                let result = match id {
                    x => Err(PerCodecError::new(format!("Unrecognised IE type {}", x))),
                };
                data.decode_align()?;
                result
            }
            _ => Err(PerCodecError::new("Unknown choice idx")),
        }
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        match self {
            Self::ThresholdRsrp(x) => {
                encode::encode_choice_idx(data, 0, 2, false, 0, false)?;
                x.encode(data)
            }
            Self::ThresholdRsrq(x) => {
                encode::encode_choice_idx(data, 0, 2, false, 1, false)?;
                x.encode(data)
            }
        }
    }
}

impl PerCodec for MeasurementThresholdL1LoggedMdt {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        MeasurementThresholdL1LoggedMdt::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MeasurementThresholdL1LoggedMdt");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MeasurementThresholdL1LoggedMdt");
            e
        })
    }
}
// FailureIndication
#[derive(Clone, Debug)]
pub struct FailureIndication {
    pub ue_rlf_report_container: UeRlfReportContainer,
}

impl FailureIndication {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let ue_rlf_report_container = UeRlfReportContainer::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            ue_rlf_report_container,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.ue_rlf_report_container.encode(data)?;

        Ok(())
    }
}

impl PerCodec for FailureIndication {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        FailureIndication::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("FailureIndication");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("FailureIndication");
            e
        })
    }
}
// FiveGSTmsi
#[derive(Clone, Debug)]
pub struct FiveGSTmsi {
    pub amf_set_id: AmfSetId,
    pub amf_pointer: AmfPointer,
    pub five_g_tmsi: FiveGTmsi,
}

impl FiveGSTmsi {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let amf_set_id = AmfSetId::decode(data)?;
        let amf_pointer = AmfPointer::decode(data)?;
        let five_g_tmsi = FiveGTmsi::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            amf_set_id,
            amf_pointer,
            five_g_tmsi,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.amf_set_id.encode(data)?;
        self.amf_pointer.encode(data)?;
        self.five_g_tmsi.encode(data)?;

        Ok(())
    }
}

impl PerCodec for FiveGSTmsi {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        FiveGSTmsi::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("FiveGSTmsi");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("FiveGSTmsi");
            e
        })
    }
}
// FiveGTmsi
#[derive(Clone, Debug)]
pub struct FiveGTmsi(pub [u8; 4]);

impl FiveGTmsi {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(
            decode::decode_octetstring(data, Some(4), Some(4), false)?
                .try_into()
                .unwrap(),
        ))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_octetstring(data, Some(4), Some(4), false, &(self.0).into(), false)
    }
}

impl PerCodec for FiveGTmsi {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        FiveGTmsi::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("FiveGTmsi");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("FiveGTmsi");
            e
        })
    }
}
// FiveQi
#[derive(Clone, Copy, Debug)]
pub struct FiveQi(pub u8);

impl FiveQi {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(
            decode::decode_integer(data, Some(0), Some(255), true)?.0 as u8,
        ))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_integer(data, Some(0), Some(255), true, self.0 as i128, false)
    }
}

impl PerCodec for FiveQi {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        FiveQi::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("FiveQi");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("FiveQi");
            e
        })
    }
}
// ForbiddenAreaInformation
#[derive(Clone, Debug)]
pub struct ForbiddenAreaInformation(pub NonEmpty<ForbiddenAreaInformationItem>);

impl ForbiddenAreaInformation {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(16), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(ForbiddenAreaInformationItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(16), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for ForbiddenAreaInformation {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        ForbiddenAreaInformation::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ForbiddenAreaInformation");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ForbiddenAreaInformation");
            e
        })
    }
}
// ForbiddenAreaInformationItem
#[derive(Clone, Debug)]
pub struct ForbiddenAreaInformationItem {
    pub plmn_identity: PlmnIdentity,
    pub forbidden_ta_cs: ForbiddenTaCs,
}

impl ForbiddenAreaInformationItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let plmn_identity = PlmnIdentity::decode(data)?;
        let forbidden_ta_cs = ForbiddenTaCs::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            plmn_identity,
            forbidden_ta_cs,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.plmn_identity.encode(data)?;
        self.forbidden_ta_cs.encode(data)?;

        Ok(())
    }
}

impl PerCodec for ForbiddenAreaInformationItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        ForbiddenAreaInformationItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ForbiddenAreaInformationItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ForbiddenAreaInformationItem");
            e
        })
    }
}
// ForbiddenTaCs
#[derive(Clone, Debug)]
pub struct ForbiddenTaCs(pub NonEmpty<Tac>);

impl ForbiddenTaCs {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(4096), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(Tac::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(4096), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for ForbiddenTaCs {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        ForbiddenTaCs::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ForbiddenTaCs");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ForbiddenTaCs");
            e
        })
    }
}
// FromEutranToNgran
#[derive(Clone, Debug)]
pub struct FromEutranToNgran {
    pub source_enb_id: IntersystemSonEnbId,
    pub target_ngran_node_id: IntersystemSonNgranNodeId,
}

impl FromEutranToNgran {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, false, 1)?;
        let source_enb_id = IntersystemSonEnbId::decode(data)?;
        let target_ngran_node_id = IntersystemSonNgranNodeId::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            source_enb_id,
            target_ngran_node_id,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, false, &optionals, false)?;
        self.source_enb_id.encode(data)?;
        self.target_ngran_node_id.encode(data)?;

        Ok(())
    }
}

impl PerCodec for FromEutranToNgran {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        FromEutranToNgran::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("FromEutranToNgran");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("FromEutranToNgran");
            e
        })
    }
}
// FromNgranToEutran
#[derive(Clone, Debug)]
pub struct FromNgranToEutran {
    pub source_ngran_node_id: IntersystemSonNgranNodeId,
    pub target_enb_id: IntersystemSonEnbId,
}

impl FromNgranToEutran {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, false, 1)?;
        let source_ngran_node_id = IntersystemSonNgranNodeId::decode(data)?;
        let target_enb_id = IntersystemSonEnbId::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            source_ngran_node_id,
            target_enb_id,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, false, &optionals, false)?;
        self.source_ngran_node_id.encode(data)?;
        self.target_enb_id.encode(data)?;

        Ok(())
    }
}

impl PerCodec for FromNgranToEutran {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        FromNgranToEutran::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("FromNgranToEutran");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("FromNgranToEutran");
            e
        })
    }
}
// GbrQosInformation
#[derive(Clone, Debug)]
pub struct GbrQosInformation {
    pub maximum_flow_bit_rate_dl: BitRate,
    pub maximum_flow_bit_rate_ul: BitRate,
    pub guaranteed_flow_bit_rate_dl: BitRate,
    pub guaranteed_flow_bit_rate_ul: BitRate,
    pub notification_control: Option<NotificationControl>,
    pub maximum_packet_loss_rate_dl: Option<PacketLossRate>,
    pub maximum_packet_loss_rate_ul: Option<PacketLossRate>,
    pub alternative_qos_para_set_list: Option<AlternativeQosParaSetList>,
}

impl GbrQosInformation {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 4)?;
        let maximum_flow_bit_rate_dl = BitRate::decode(data)?;
        let maximum_flow_bit_rate_ul = BitRate::decode(data)?;
        let guaranteed_flow_bit_rate_dl = BitRate::decode(data)?;
        let guaranteed_flow_bit_rate_ul = BitRate::decode(data)?;
        let notification_control = if optionals[0] {
            Some(NotificationControl::decode(data)?)
        } else {
            None
        };
        let maximum_packet_loss_rate_dl = if optionals[1] {
            Some(PacketLossRate::decode(data)?)
        } else {
            None
        };
        let maximum_packet_loss_rate_ul = if optionals[2] {
            Some(PacketLossRate::decode(data)?)
        } else {
            None
        };

        // Process the extension container
        let mut alternative_qos_para_set_list: Option<AlternativeQosParaSetList> = None;

        if optionals[3] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    220 => {
                        alternative_qos_para_set_list =
                            Some(AlternativeQosParaSetList::decode(data)?)
                    }
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            maximum_flow_bit_rate_dl,
            maximum_flow_bit_rate_ul,
            guaranteed_flow_bit_rate_dl,
            guaranteed_flow_bit_rate_ul,
            notification_control,
            maximum_packet_loss_rate_dl,
            maximum_packet_loss_rate_ul,
            alternative_qos_para_set_list,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();
        if let Some(x) = &self.alternative_qos_para_set_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 220, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        let mut optionals = BitString::new();
        optionals.push(self.notification_control.is_some());
        optionals.push(self.maximum_packet_loss_rate_dl.is_some());
        optionals.push(self.maximum_packet_loss_rate_ul.is_some());
        optionals.push(num_ies != 0);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.maximum_flow_bit_rate_dl.encode(data)?;
        self.maximum_flow_bit_rate_ul.encode(data)?;
        self.guaranteed_flow_bit_rate_dl.encode(data)?;
        self.guaranteed_flow_bit_rate_ul.encode(data)?;
        if let Some(x) = &self.notification_control {
            x.encode(data)?;
        }
        if let Some(x) = &self.maximum_packet_loss_rate_dl {
            x.encode(data)?;
        }
        if let Some(x) = &self.maximum_packet_loss_rate_ul {
            x.encode(data)?;
        }
        if num_ies != 0 {
            encode::encode_length_determinent(data, Some(1), Some(65535), false, num_ies)?;
            data.append_aligned(ies);
        }
        Ok(())
    }
}

impl PerCodec for GbrQosInformation {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        GbrQosInformation::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("GbrQosInformation");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("GbrQosInformation");
            e
        })
    }
}
// GlobalCableId
#[derive(Clone, Debug)]
pub struct GlobalCableId(pub Vec<u8>);

impl GlobalCableId {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(decode::decode_octetstring(data, None, None, false)?))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_octetstring(data, None, None, false, &self.0, false)
    }
}

impl PerCodec for GlobalCableId {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        GlobalCableId::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("GlobalCableId");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("GlobalCableId");
            e
        })
    }
}
// GlobalEnbId
#[derive(Clone, Debug)]
pub struct GlobalEnbId {
    pub plmn_identity: PlmnIdentity,
    pub enb_id: EnbId,
}

impl GlobalEnbId {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let plmn_identity = PlmnIdentity::decode(data)?;
        let enb_id = EnbId::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            plmn_identity,
            enb_id,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.plmn_identity.encode(data)?;
        self.enb_id.encode(data)?;

        Ok(())
    }
}

impl PerCodec for GlobalEnbId {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        GlobalEnbId::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("GlobalEnbId");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("GlobalEnbId");
            e
        })
    }
}
// GlobalGnbId
#[derive(Clone, Debug)]
pub struct GlobalGnbId {
    pub plmn_identity: PlmnIdentity,
    pub gnb_id: GnbId,
}

impl GlobalGnbId {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let plmn_identity = PlmnIdentity::decode(data)?;
        let gnb_id = GnbId::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            plmn_identity,
            gnb_id,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.plmn_identity.encode(data)?;
        self.gnb_id.encode(data)?;

        Ok(())
    }
}

impl PerCodec for GlobalGnbId {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        GlobalGnbId::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("GlobalGnbId");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("GlobalGnbId");
            e
        })
    }
}
// GlobalN3IwfId
#[derive(Clone, Debug)]
pub struct GlobalN3IwfId {
    pub plmn_identity: PlmnIdentity,
    pub n3_iwf_id: N3IwfId,
}

impl GlobalN3IwfId {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let plmn_identity = PlmnIdentity::decode(data)?;
        let n3_iwf_id = N3IwfId::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            plmn_identity,
            n3_iwf_id,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.plmn_identity.encode(data)?;
        self.n3_iwf_id.encode(data)?;

        Ok(())
    }
}

impl PerCodec for GlobalN3IwfId {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        GlobalN3IwfId::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("GlobalN3IwfId");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("GlobalN3IwfId");
            e
        })
    }
}
// GlobalLineId
#[derive(Clone, Debug)]
pub struct GlobalLineId {
    pub global_line_identity: GlobalLineIdentity,
    pub line_type: Option<LineType>,
}

impl GlobalLineId {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 2)?;
        let global_line_identity = GlobalLineIdentity::decode(data)?;
        let line_type = if optionals[0] {
            Some(LineType::decode(data)?)
        } else {
            None
        };

        // Process the extension container

        if optionals[1] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            global_line_identity,
            line_type,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.line_type.is_some());
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.global_line_identity.encode(data)?;
        if let Some(x) = &self.line_type {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl PerCodec for GlobalLineId {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        GlobalLineId::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("GlobalLineId");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("GlobalLineId");
            e
        })
    }
}
// GlobalLineIdentity
#[derive(Clone, Debug)]
pub struct GlobalLineIdentity(pub Vec<u8>);

impl GlobalLineIdentity {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(decode::decode_octetstring(data, None, None, false)?))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_octetstring(data, None, None, false, &self.0, false)
    }
}

impl PerCodec for GlobalLineIdentity {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        GlobalLineIdentity::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("GlobalLineIdentity");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("GlobalLineIdentity");
            e
        })
    }
}
// GlobalNgEnbId
#[derive(Clone, Debug)]
pub struct GlobalNgEnbId {
    pub plmn_identity: PlmnIdentity,
    pub ng_enb_id: NgEnbId,
}

impl GlobalNgEnbId {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let plmn_identity = PlmnIdentity::decode(data)?;
        let ng_enb_id = NgEnbId::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            plmn_identity,
            ng_enb_id,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.plmn_identity.encode(data)?;
        self.ng_enb_id.encode(data)?;

        Ok(())
    }
}

impl PerCodec for GlobalNgEnbId {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        GlobalNgEnbId::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("GlobalNgEnbId");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("GlobalNgEnbId");
            e
        })
    }
}
// GlobalRanNodeId
#[derive(Clone, Debug)]
pub enum GlobalRanNodeId {
    GlobalGnbId(GlobalGnbId),
    GlobalNgEnbId(GlobalNgEnbId),
    GlobalN3IwfId(GlobalN3IwfId),
    GlobalTngfId(GlobalTngfId),
    GlobalTwifId(GlobalTwifId),
    GlobalWAgfId(GlobalWAgfId),
}

impl GlobalRanNodeId {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_choice_idx(data, 0, 3, false)?;
        if extended {
            return Err(PerCodecError::new("CHOICE additions not implemented"));
        }
        match idx {
            0 => Ok(Self::GlobalGnbId(GlobalGnbId::decode(data)?)),
            1 => Ok(Self::GlobalNgEnbId(GlobalNgEnbId::decode(data)?)),
            2 => Ok(Self::GlobalN3IwfId(GlobalN3IwfId::decode(data)?)),
            3 => {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _ = Criticality::decode(data)?;
                let _ = decode::decode_length_determinent(data, None, None, false)?;
                let result = match id {
                    240 => Ok(Self::GlobalTngfId(GlobalTngfId::decode(data)?)),
                    241 => Ok(Self::GlobalTwifId(GlobalTwifId::decode(data)?)),
                    242 => Ok(Self::GlobalWAgfId(GlobalWAgfId::decode(data)?)),
                    x => Err(PerCodecError::new(format!("Unrecognised IE type {}", x))),
                };
                data.decode_align()?;
                result
            }
            _ => Err(PerCodecError::new("Unknown choice idx")),
        }
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        match self {
            Self::GlobalGnbId(x) => {
                encode::encode_choice_idx(data, 0, 3, false, 0, false)?;
                x.encode(data)
            }
            Self::GlobalNgEnbId(x) => {
                encode::encode_choice_idx(data, 0, 3, false, 1, false)?;
                x.encode(data)
            }
            Self::GlobalN3IwfId(x) => {
                encode::encode_choice_idx(data, 0, 3, false, 2, false)?;
                x.encode(data)
            }
            Self::GlobalTngfId(x) => {
                encode::encode_choice_idx(data, 0, 3, false, 3, false)?;
                encode::encode_integer(data, Some(0), Some(65535), false, 240, false)?;
                Criticality::Reject.encode(data)?;
                let ie = &mut Allocator::new_codec_data();
                x.encode(ie)?;
                encode::encode_length_determinent(data, None, None, false, ie.length_in_bytes())?;
                Ok(data.append_aligned(ie))
            }
            Self::GlobalTwifId(x) => {
                encode::encode_choice_idx(data, 0, 3, false, 3, false)?;
                encode::encode_integer(data, Some(0), Some(65535), false, 241, false)?;
                Criticality::Reject.encode(data)?;
                let ie = &mut Allocator::new_codec_data();
                x.encode(ie)?;
                encode::encode_length_determinent(data, None, None, false, ie.length_in_bytes())?;
                Ok(data.append_aligned(ie))
            }
            Self::GlobalWAgfId(x) => {
                encode::encode_choice_idx(data, 0, 3, false, 3, false)?;
                encode::encode_integer(data, Some(0), Some(65535), false, 242, false)?;
                Criticality::Reject.encode(data)?;
                let ie = &mut Allocator::new_codec_data();
                x.encode(ie)?;
                encode::encode_length_determinent(data, None, None, false, ie.length_in_bytes())?;
                Ok(data.append_aligned(ie))
            }
        }
    }
}

impl PerCodec for GlobalRanNodeId {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        GlobalRanNodeId::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("GlobalRanNodeId");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("GlobalRanNodeId");
            e
        })
    }
}
// GlobalTngfId
#[derive(Clone, Debug)]
pub struct GlobalTngfId {
    pub plmn_identity: PlmnIdentity,
    pub tngf_id: TngfId,
}

impl GlobalTngfId {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let plmn_identity = PlmnIdentity::decode(data)?;
        let tngf_id = TngfId::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            plmn_identity,
            tngf_id,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.plmn_identity.encode(data)?;
        self.tngf_id.encode(data)?;

        Ok(())
    }
}

impl PerCodec for GlobalTngfId {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        GlobalTngfId::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("GlobalTngfId");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("GlobalTngfId");
            e
        })
    }
}
// GlobalTwifId
#[derive(Clone, Debug)]
pub struct GlobalTwifId {
    pub plmn_identity: PlmnIdentity,
    pub twif_id: TwifId,
}

impl GlobalTwifId {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let plmn_identity = PlmnIdentity::decode(data)?;
        let twif_id = TwifId::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            plmn_identity,
            twif_id,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.plmn_identity.encode(data)?;
        self.twif_id.encode(data)?;

        Ok(())
    }
}

impl PerCodec for GlobalTwifId {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        GlobalTwifId::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("GlobalTwifId");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("GlobalTwifId");
            e
        })
    }
}
// GlobalWAgfId
#[derive(Clone, Debug)]
pub struct GlobalWAgfId {
    pub plmn_identity: PlmnIdentity,
    pub w_agf_id: WAgfId,
}

impl GlobalWAgfId {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let plmn_identity = PlmnIdentity::decode(data)?;
        let w_agf_id = WAgfId::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            plmn_identity,
            w_agf_id,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.plmn_identity.encode(data)?;
        self.w_agf_id.encode(data)?;

        Ok(())
    }
}

impl PerCodec for GlobalWAgfId {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        GlobalWAgfId::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("GlobalWAgfId");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("GlobalWAgfId");
            e
        })
    }
}
// GnbId
#[derive(Clone, Debug)]
pub enum GnbId {
    GnbId(BitString),
}

impl GnbId {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_choice_idx(data, 0, 1, false)?;
        if extended {
            return Err(PerCodecError::new("CHOICE additions not implemented"));
        }
        match idx {
            0 => Ok(Self::GnbId(decode::decode_bitstring(
                data,
                Some(22),
                Some(32),
                false,
            )?)),
            1 => {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _ = Criticality::decode(data)?;
                let _ = decode::decode_length_determinent(data, None, None, false)?;
                let result = match id {
                    x => Err(PerCodecError::new(format!("Unrecognised IE type {}", x))),
                };
                data.decode_align()?;
                result
            }
            _ => Err(PerCodecError::new("Unknown choice idx")),
        }
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        match self {
            Self::GnbId(x) => {
                encode::encode_choice_idx(data, 0, 1, false, 0, false)?;
                encode::encode_bitstring(data, Some(22), Some(32), false, &x, false)
            }
        }
    }
}

impl PerCodec for GnbId {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        GnbId::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("GnbId");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("GnbId");
            e
        })
    }
}
// Guami
#[derive(Clone, Debug)]
pub struct Guami {
    pub plmn_identity: PlmnIdentity,
    pub amf_region_id: AmfRegionId,
    pub amf_set_id: AmfSetId,
    pub amf_pointer: AmfPointer,
}

impl Guami {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let plmn_identity = PlmnIdentity::decode(data)?;
        let amf_region_id = AmfRegionId::decode(data)?;
        let amf_set_id = AmfSetId::decode(data)?;
        let amf_pointer = AmfPointer::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            plmn_identity,
            amf_region_id,
            amf_set_id,
            amf_pointer,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.plmn_identity.encode(data)?;
        self.amf_region_id.encode(data)?;
        self.amf_set_id.encode(data)?;
        self.amf_pointer.encode(data)?;

        Ok(())
    }
}

impl PerCodec for Guami {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Guami::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("Guami");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("Guami");
            e
        })
    }
}
// GuamiType
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum GuamiType {
    Native,
    Mapped,
}

impl GuamiType {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(1), true)?;
        if extended {
            return Err(PerCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(data, Some(0), Some(1), true, *self as i128, false)
    }
}

impl PerCodec for GuamiType {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        GuamiType::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("GuamiType");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("GuamiType");
            e
        })
    }
}
// HandoverCommandTransfer
#[derive(Clone, Debug)]
pub struct HandoverCommandTransfer {
    pub dl_forwarding_up_tnl_information: Option<UpTransportLayerInformation>,
    pub qos_flow_to_be_forwarded_list: Option<QosFlowToBeForwardedList>,
    pub data_forwarding_response_drb_list: Option<DataForwardingResponseDrbList>,
    pub additional_dl_forwarding_up_tnl_information: Option<QosFlowPerTnlInformationList>,
    pub ul_forwarding_up_tnl_information: Option<UpTransportLayerInformation>,
    pub additional_ul_forwarding_up_tnl_information: Option<UpTransportLayerInformationList>,
    pub data_forwarding_response_erab_list: Option<DataForwardingResponseErabList>,
}

impl HandoverCommandTransfer {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 4)?;
        let dl_forwarding_up_tnl_information = if optionals[0] {
            Some(UpTransportLayerInformation::decode(data)?)
        } else {
            None
        };
        let qos_flow_to_be_forwarded_list = if optionals[1] {
            Some(QosFlowToBeForwardedList::decode(data)?)
        } else {
            None
        };
        let data_forwarding_response_drb_list = if optionals[2] {
            Some(DataForwardingResponseDrbList::decode(data)?)
        } else {
            None
        };

        // Process the extension container
        let mut additional_dl_forwarding_up_tnl_information: Option<QosFlowPerTnlInformationList> =
            None;
        let mut ul_forwarding_up_tnl_information: Option<UpTransportLayerInformation> = None;
        let mut additional_ul_forwarding_up_tnl_information: Option<
            UpTransportLayerInformationList,
        > = None;
        let mut data_forwarding_response_erab_list: Option<DataForwardingResponseErabList> = None;

        if optionals[3] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    152 => {
                        additional_dl_forwarding_up_tnl_information =
                            Some(QosFlowPerTnlInformationList::decode(data)?)
                    }
                    164 => {
                        ul_forwarding_up_tnl_information =
                            Some(UpTransportLayerInformation::decode(data)?)
                    }
                    172 => {
                        additional_ul_forwarding_up_tnl_information =
                            Some(UpTransportLayerInformationList::decode(data)?)
                    }
                    249 => {
                        data_forwarding_response_erab_list =
                            Some(DataForwardingResponseErabList::decode(data)?)
                    }
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            dl_forwarding_up_tnl_information,
            qos_flow_to_be_forwarded_list,
            data_forwarding_response_drb_list,
            additional_dl_forwarding_up_tnl_information,
            ul_forwarding_up_tnl_information,
            additional_ul_forwarding_up_tnl_information,
            data_forwarding_response_erab_list,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();
        if let Some(x) = &self.additional_dl_forwarding_up_tnl_information {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 152, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.ul_forwarding_up_tnl_information {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 164, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.additional_ul_forwarding_up_tnl_information {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 172, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.data_forwarding_response_erab_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 249, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        let mut optionals = BitString::new();
        optionals.push(self.dl_forwarding_up_tnl_information.is_some());
        optionals.push(self.qos_flow_to_be_forwarded_list.is_some());
        optionals.push(self.data_forwarding_response_drb_list.is_some());
        optionals.push(num_ies != 0);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        if let Some(x) = &self.dl_forwarding_up_tnl_information {
            x.encode(data)?;
        }
        if let Some(x) = &self.qos_flow_to_be_forwarded_list {
            x.encode(data)?;
        }
        if let Some(x) = &self.data_forwarding_response_drb_list {
            x.encode(data)?;
        }
        if num_ies != 0 {
            encode::encode_length_determinent(data, Some(1), Some(65535), false, num_ies)?;
            data.append_aligned(ies);
        }
        Ok(())
    }
}

impl PerCodec for HandoverCommandTransfer {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        HandoverCommandTransfer::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("HandoverCommandTransfer");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("HandoverCommandTransfer");
            e
        })
    }
}
// HandoverFlag
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum HandoverFlag {
    HandoverPreparation,
}

impl HandoverFlag {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(0), true)?;
        if extended {
            return Err(PerCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(data, Some(0), Some(0), true, *self as i128, false)
    }
}

impl PerCodec for HandoverFlag {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        HandoverFlag::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("HandoverFlag");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("HandoverFlag");
            e
        })
    }
}
// HandoverPreparationUnsuccessfulTransfer
#[derive(Clone, Debug)]
pub struct HandoverPreparationUnsuccessfulTransfer {
    pub cause: Cause,
}

impl HandoverPreparationUnsuccessfulTransfer {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let cause = Cause::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self { cause })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.cause.encode(data)?;

        Ok(())
    }
}

impl PerCodec for HandoverPreparationUnsuccessfulTransfer {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        HandoverPreparationUnsuccessfulTransfer::decode_inner(data).map_err(
            |mut e: PerCodecError| {
                e.push_context("HandoverPreparationUnsuccessfulTransfer");
                e
            },
        )
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("HandoverPreparationUnsuccessfulTransfer");
            e
        })
    }
}
// HandoverRequestAcknowledgeTransfer
#[derive(Clone, Debug)]
pub struct HandoverRequestAcknowledgeTransfer {
    pub dl_ngu_up_tnl_information: UpTransportLayerInformation,
    pub dl_forwarding_up_tnl_information: Option<UpTransportLayerInformation>,
    pub security_result: Option<SecurityResult>,
    pub qos_flow_setup_response_list: QosFlowListWithDataForwarding,
    pub qos_flow_failed_to_setup_list: Option<QosFlowListWithCause>,
    pub data_forwarding_response_drb_list: Option<DataForwardingResponseDrbList>,
    pub additional_dl_up_tnl_information_for_ho_list: Option<AdditionalDlUpTnlInformationForHoList>,
    pub ul_forwarding_up_tnl_information: Option<UpTransportLayerInformation>,
    pub additional_ul_forwarding_up_tnl_information: Option<UpTransportLayerInformationList>,
    pub data_forwarding_response_erab_list: Option<DataForwardingResponseErabList>,
    pub redundant_dl_ngu_up_tnl_information: Option<UpTransportLayerInformation>,
    pub used_rsn_information: Option<RedundantPduSessionInformation>,
    pub global_ran_node_id: Option<GlobalRanNodeId>,
}

impl HandoverRequestAcknowledgeTransfer {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 5)?;
        let dl_ngu_up_tnl_information = UpTransportLayerInformation::decode(data)?;
        let dl_forwarding_up_tnl_information = if optionals[0] {
            Some(UpTransportLayerInformation::decode(data)?)
        } else {
            None
        };
        let security_result = if optionals[1] {
            Some(SecurityResult::decode(data)?)
        } else {
            None
        };
        let qos_flow_setup_response_list = QosFlowListWithDataForwarding::decode(data)?;
        let qos_flow_failed_to_setup_list = if optionals[2] {
            Some(QosFlowListWithCause::decode(data)?)
        } else {
            None
        };
        let data_forwarding_response_drb_list = if optionals[3] {
            Some(DataForwardingResponseDrbList::decode(data)?)
        } else {
            None
        };

        // Process the extension container
        let mut additional_dl_up_tnl_information_for_ho_list: Option<
            AdditionalDlUpTnlInformationForHoList,
        > = None;
        let mut ul_forwarding_up_tnl_information: Option<UpTransportLayerInformation> = None;
        let mut additional_ul_forwarding_up_tnl_information: Option<
            UpTransportLayerInformationList,
        > = None;
        let mut data_forwarding_response_erab_list: Option<DataForwardingResponseErabList> = None;
        let mut redundant_dl_ngu_up_tnl_information: Option<UpTransportLayerInformation> = None;
        let mut used_rsn_information: Option<RedundantPduSessionInformation> = None;
        let mut global_ran_node_id: Option<GlobalRanNodeId> = None;

        if optionals[4] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    153 => {
                        additional_dl_up_tnl_information_for_ho_list =
                            Some(AdditionalDlUpTnlInformationForHoList::decode(data)?)
                    }
                    164 => {
                        ul_forwarding_up_tnl_information =
                            Some(UpTransportLayerInformation::decode(data)?)
                    }
                    172 => {
                        additional_ul_forwarding_up_tnl_information =
                            Some(UpTransportLayerInformationList::decode(data)?)
                    }
                    249 => {
                        data_forwarding_response_erab_list =
                            Some(DataForwardingResponseErabList::decode(data)?)
                    }
                    192 => {
                        redundant_dl_ngu_up_tnl_information =
                            Some(UpTransportLayerInformation::decode(data)?)
                    }
                    198 => {
                        used_rsn_information = Some(RedundantPduSessionInformation::decode(data)?)
                    }
                    27 => global_ran_node_id = Some(GlobalRanNodeId::decode(data)?),
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            dl_ngu_up_tnl_information,
            dl_forwarding_up_tnl_information,
            security_result,
            qos_flow_setup_response_list,
            qos_flow_failed_to_setup_list,
            data_forwarding_response_drb_list,
            additional_dl_up_tnl_information_for_ho_list,
            ul_forwarding_up_tnl_information,
            additional_ul_forwarding_up_tnl_information,
            data_forwarding_response_erab_list,
            redundant_dl_ngu_up_tnl_information,
            used_rsn_information,
            global_ran_node_id,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();
        if let Some(x) = &self.additional_dl_up_tnl_information_for_ho_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 153, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.ul_forwarding_up_tnl_information {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 164, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.additional_ul_forwarding_up_tnl_information {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 172, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.data_forwarding_response_erab_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 249, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.redundant_dl_ngu_up_tnl_information {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 192, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.used_rsn_information {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 198, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.global_ran_node_id {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 27, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        let mut optionals = BitString::new();
        optionals.push(self.dl_forwarding_up_tnl_information.is_some());
        optionals.push(self.security_result.is_some());
        optionals.push(self.qos_flow_failed_to_setup_list.is_some());
        optionals.push(self.data_forwarding_response_drb_list.is_some());
        optionals.push(num_ies != 0);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.dl_ngu_up_tnl_information.encode(data)?;
        if let Some(x) = &self.dl_forwarding_up_tnl_information {
            x.encode(data)?;
        }
        if let Some(x) = &self.security_result {
            x.encode(data)?;
        }
        self.qos_flow_setup_response_list.encode(data)?;
        if let Some(x) = &self.qos_flow_failed_to_setup_list {
            x.encode(data)?;
        }
        if let Some(x) = &self.data_forwarding_response_drb_list {
            x.encode(data)?;
        }
        if num_ies != 0 {
            encode::encode_length_determinent(data, Some(1), Some(65535), false, num_ies)?;
            data.append_aligned(ies);
        }
        Ok(())
    }
}

impl PerCodec for HandoverRequestAcknowledgeTransfer {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        HandoverRequestAcknowledgeTransfer::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("HandoverRequestAcknowledgeTransfer");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("HandoverRequestAcknowledgeTransfer");
            e
        })
    }
}
// HandoverRequiredTransfer
#[derive(Clone, Debug)]
pub struct HandoverRequiredTransfer {
    pub direct_forwarding_path_availability: Option<DirectForwardingPathAvailability>,
}

impl HandoverRequiredTransfer {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 2)?;
        let direct_forwarding_path_availability = if optionals[0] {
            Some(DirectForwardingPathAvailability::decode(data)?)
        } else {
            None
        };

        // Process the extension container

        if optionals[1] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            direct_forwarding_path_availability,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.direct_forwarding_path_availability.is_some());
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        if let Some(x) = &self.direct_forwarding_path_availability {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl PerCodec for HandoverRequiredTransfer {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        HandoverRequiredTransfer::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("HandoverRequiredTransfer");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("HandoverRequiredTransfer");
            e
        })
    }
}
// HandoverResourceAllocationUnsuccessfulTransfer
#[derive(Clone, Debug)]
pub struct HandoverResourceAllocationUnsuccessfulTransfer {
    pub cause: Cause,
    pub criticality_diagnostics: Option<CriticalityDiagnostics>,
}

impl HandoverResourceAllocationUnsuccessfulTransfer {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 2)?;
        let cause = Cause::decode(data)?;
        let criticality_diagnostics = if optionals[0] {
            Some(CriticalityDiagnostics::decode(data)?)
        } else {
            None
        };

        // Process the extension container

        if optionals[1] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            cause,
            criticality_diagnostics,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.criticality_diagnostics.is_some());
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.cause.encode(data)?;
        if let Some(x) = &self.criticality_diagnostics {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl PerCodec for HandoverResourceAllocationUnsuccessfulTransfer {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        HandoverResourceAllocationUnsuccessfulTransfer::decode_inner(data).map_err(
            |mut e: PerCodecError| {
                e.push_context("HandoverResourceAllocationUnsuccessfulTransfer");
                e
            },
        )
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("HandoverResourceAllocationUnsuccessfulTransfer");
            e
        })
    }
}
// HandoverType
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum HandoverType {
    Intra5gs,
    FivegsToEps,
    EpsTo5gs,
}

impl HandoverType {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(2), true)?;
        if extended {
            return Err(PerCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(data, Some(0), Some(2), true, *self as i128, false)
    }
}

impl PerCodec for HandoverType {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        HandoverType::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("HandoverType");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("HandoverType");
            e
        })
    }
}
// HfcNodeId
#[derive(Clone, Debug)]
pub struct HfcNodeId(pub Vec<u8>);

impl HfcNodeId {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(decode::decode_octetstring(data, None, None, false)?))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_octetstring(data, None, None, false, &self.0, false)
    }
}

impl PerCodec for HfcNodeId {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        HfcNodeId::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("HfcNodeId");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("HfcNodeId");
            e
        })
    }
}
// HoReport
#[derive(Clone, Debug)]
pub struct HoReport {
    pub handover_report_type: HandoverReportType,
    pub handover_cause: Cause,
    pub sourcecell_cgi: NgranCgi,
    pub targetcell_cgi: NgranCgi,
    pub reestablishmentcell_cgi: Option<NgranCgi>,
    pub sourcecell_c_rnti: Option<BitString>,
    pub targetcellin_eutran: Option<EutraCgi>,
    pub mobility_information: Option<MobilityInformation>,
    pub ue_rlf_report_container: Option<UeRlfReportContainer>,
}

impl HoReport {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 6)?;
        let handover_report_type = HandoverReportType::decode(data)?;
        let handover_cause = Cause::decode(data)?;
        let sourcecell_cgi = NgranCgi::decode(data)?;
        let targetcell_cgi = NgranCgi::decode(data)?;
        let reestablishmentcell_cgi = if optionals[0] {
            Some(NgranCgi::decode(data)?)
        } else {
            None
        };
        let sourcecell_c_rnti = if optionals[1] {
            Some(decode::decode_bitstring(data, Some(16), Some(16), false)?)
        } else {
            None
        };
        let targetcellin_eutran = if optionals[2] {
            Some(EutraCgi::decode(data)?)
        } else {
            None
        };
        let mobility_information = if optionals[3] {
            Some(MobilityInformation::decode(data)?)
        } else {
            None
        };
        let ue_rlf_report_container = if optionals[4] {
            Some(UeRlfReportContainer::decode(data)?)
        } else {
            None
        };

        // Process the extension container

        if optionals[5] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            handover_report_type,
            handover_cause,
            sourcecell_cgi,
            targetcell_cgi,
            reestablishmentcell_cgi,
            sourcecell_c_rnti,
            targetcellin_eutran,
            mobility_information,
            ue_rlf_report_container,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.reestablishmentcell_cgi.is_some());
        optionals.push(self.sourcecell_c_rnti.is_some());
        optionals.push(self.targetcellin_eutran.is_some());
        optionals.push(self.mobility_information.is_some());
        optionals.push(self.ue_rlf_report_container.is_some());
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.handover_report_type.encode(data)?;
        self.handover_cause.encode(data)?;
        self.sourcecell_cgi.encode(data)?;
        self.targetcell_cgi.encode(data)?;
        if let Some(x) = &self.reestablishmentcell_cgi {
            x.encode(data)?;
        }
        if let Some(x) = &self.sourcecell_c_rnti {
            encode::encode_bitstring(data, Some(16), Some(16), false, &x, false)?;
        }
        if let Some(x) = &self.targetcellin_eutran {
            x.encode(data)?;
        }
        if let Some(x) = &self.mobility_information {
            x.encode(data)?;
        }
        if let Some(x) = &self.ue_rlf_report_container {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl PerCodec for HoReport {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        HoReport::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("HoReport");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("HoReport");
            e
        })
    }
}
// Hysteresis
#[derive(Clone, Copy, Debug)]
pub struct Hysteresis(pub u8);

impl Hysteresis {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(
            decode::decode_integer(data, Some(0), Some(30), false)?.0 as u8,
        ))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_integer(data, Some(0), Some(30), false, self.0 as i128, false)
    }
}

impl PerCodec for Hysteresis {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Hysteresis::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("Hysteresis");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("Hysteresis");
            e
        })
    }
}
// IabAuthorized
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum IabAuthorized {
    Authorized,
    NotAuthorized,
}

impl IabAuthorized {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(1), true)?;
        if extended {
            return Err(PerCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(data, Some(0), Some(1), true, *self as i128, false)
    }
}

impl PerCodec for IabAuthorized {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        IabAuthorized::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("IabAuthorized");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("IabAuthorized");
            e
        })
    }
}
// IabSupported
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum IabSupported {
    True,
}

impl IabSupported {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(0), true)?;
        if extended {
            return Err(PerCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(data, Some(0), Some(0), true, *self as i128, false)
    }
}

impl PerCodec for IabSupported {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        IabSupported::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("IabSupported");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("IabSupported");
            e
        })
    }
}
// IabNodeIndication
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum IabNodeIndication {
    True,
}

impl IabNodeIndication {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(0), true)?;
        if extended {
            return Err(PerCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(data, Some(0), Some(0), true, *self as i128, false)
    }
}

impl PerCodec for IabNodeIndication {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        IabNodeIndication::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("IabNodeIndication");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("IabNodeIndication");
            e
        })
    }
}
// ImsVoiceSupportIndicator
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum ImsVoiceSupportIndicator {
    Supported,
    NotSupported,
}

impl ImsVoiceSupportIndicator {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(1), true)?;
        if extended {
            return Err(PerCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(data, Some(0), Some(1), true, *self as i128, false)
    }
}

impl PerCodec for ImsVoiceSupportIndicator {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        ImsVoiceSupportIndicator::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ImsVoiceSupportIndicator");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ImsVoiceSupportIndicator");
            e
        })
    }
}
// IndexToRfsp
#[derive(Clone, Copy, Debug)]
pub struct IndexToRfsp(pub u16);

impl IndexToRfsp {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(
            decode::decode_integer(data, Some(1), Some(256), true)?.0 as u16,
        ))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_integer(data, Some(1), Some(256), true, self.0 as i128, false)
    }
}

impl PerCodec for IndexToRfsp {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        IndexToRfsp::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("IndexToRfsp");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("IndexToRfsp");
            e
        })
    }
}
// InfoOnRecommendedCellsAndRanNodesForPaging
#[derive(Clone, Debug)]
pub struct InfoOnRecommendedCellsAndRanNodesForPaging {
    pub recommended_cells_for_paging: RecommendedCellsForPaging,
    pub recommend_ran_nodes_for_paging: RecommendedRanNodesForPaging,
}

impl InfoOnRecommendedCellsAndRanNodesForPaging {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let recommended_cells_for_paging = RecommendedCellsForPaging::decode(data)?;
        let recommend_ran_nodes_for_paging = RecommendedRanNodesForPaging::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            recommended_cells_for_paging,
            recommend_ran_nodes_for_paging,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.recommended_cells_for_paging.encode(data)?;
        self.recommend_ran_nodes_for_paging.encode(data)?;

        Ok(())
    }
}

impl PerCodec for InfoOnRecommendedCellsAndRanNodesForPaging {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        InfoOnRecommendedCellsAndRanNodesForPaging::decode_inner(data).map_err(
            |mut e: PerCodecError| {
                e.push_context("InfoOnRecommendedCellsAndRanNodesForPaging");
                e
            },
        )
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("InfoOnRecommendedCellsAndRanNodesForPaging");
            e
        })
    }
}
// IntegrityProtectionIndication
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum IntegrityProtectionIndication {
    Required,
    Preferred,
    NotNeeded,
}

impl IntegrityProtectionIndication {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(2), true)?;
        if extended {
            return Err(PerCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(data, Some(0), Some(2), true, *self as i128, false)
    }
}

impl PerCodec for IntegrityProtectionIndication {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        IntegrityProtectionIndication::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("IntegrityProtectionIndication");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("IntegrityProtectionIndication");
            e
        })
    }
}
// IntegrityProtectionResult
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum IntegrityProtectionResult {
    Performed,
    NotPerformed,
}

impl IntegrityProtectionResult {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(1), true)?;
        if extended {
            return Err(PerCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(data, Some(0), Some(1), true, *self as i128, false)
    }
}

impl PerCodec for IntegrityProtectionResult {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        IntegrityProtectionResult::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("IntegrityProtectionResult");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("IntegrityProtectionResult");
            e
        })
    }
}
// IntendedNumberOfPagingAttempts
#[derive(Clone, Copy, Debug)]
pub struct IntendedNumberOfPagingAttempts(pub u8);

impl IntendedNumberOfPagingAttempts {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(
            decode::decode_integer(data, Some(1), Some(16), true)?.0 as u8,
        ))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_integer(data, Some(1), Some(16), true, self.0 as i128, false)
    }
}

impl PerCodec for IntendedNumberOfPagingAttempts {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        IntendedNumberOfPagingAttempts::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("IntendedNumberOfPagingAttempts");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("IntendedNumberOfPagingAttempts");
            e
        })
    }
}
// InterfacesToTrace
#[derive(Clone, Debug)]
pub struct InterfacesToTrace(pub BitString);

impl InterfacesToTrace {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(decode::decode_bitstring(
            data,
            Some(8),
            Some(8),
            false,
        )?))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_bitstring(data, Some(8), Some(8), false, &self.0, false)
    }
}

impl PerCodec for InterfacesToTrace {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        InterfacesToTrace::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("InterfacesToTrace");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("InterfacesToTrace");
            e
        })
    }
}
// ImmediateMdtNr
#[derive(Clone, Debug)]
pub struct ImmediateMdtNr {
    pub measurements_to_activate: MeasurementsToActivate,
    pub m1_configuration: Option<M1Configuration>,
    pub m4_configuration: Option<M4Configuration>,
    pub m5_configuration: Option<M5Configuration>,
    pub m6_configuration: Option<M6Configuration>,
    pub m7_configuration: Option<M7Configuration>,
    pub bluetooth_measurement_configuration: Option<BluetoothMeasurementConfiguration>,
    pub wlan_measurement_configuration: Option<WlanMeasurementConfiguration>,
    pub mdt_location_info: Option<MdtLocationInfo>,
    pub sensor_measurement_configuration: Option<SensorMeasurementConfiguration>,
}

impl ImmediateMdtNr {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 10)?;
        let measurements_to_activate = MeasurementsToActivate::decode(data)?;
        let m1_configuration = if optionals[0] {
            Some(M1Configuration::decode(data)?)
        } else {
            None
        };
        let m4_configuration = if optionals[1] {
            Some(M4Configuration::decode(data)?)
        } else {
            None
        };
        let m5_configuration = if optionals[2] {
            Some(M5Configuration::decode(data)?)
        } else {
            None
        };
        let m6_configuration = if optionals[3] {
            Some(M6Configuration::decode(data)?)
        } else {
            None
        };
        let m7_configuration = if optionals[4] {
            Some(M7Configuration::decode(data)?)
        } else {
            None
        };
        let bluetooth_measurement_configuration = if optionals[5] {
            Some(BluetoothMeasurementConfiguration::decode(data)?)
        } else {
            None
        };
        let wlan_measurement_configuration = if optionals[6] {
            Some(WlanMeasurementConfiguration::decode(data)?)
        } else {
            None
        };
        let mdt_location_info = if optionals[7] {
            Some(MdtLocationInfo::decode(data)?)
        } else {
            None
        };
        let sensor_measurement_configuration = if optionals[8] {
            Some(SensorMeasurementConfiguration::decode(data)?)
        } else {
            None
        };

        // Process the extension container

        if optionals[9] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            measurements_to_activate,
            m1_configuration,
            m4_configuration,
            m5_configuration,
            m6_configuration,
            m7_configuration,
            bluetooth_measurement_configuration,
            wlan_measurement_configuration,
            mdt_location_info,
            sensor_measurement_configuration,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.m1_configuration.is_some());
        optionals.push(self.m4_configuration.is_some());
        optionals.push(self.m5_configuration.is_some());
        optionals.push(self.m6_configuration.is_some());
        optionals.push(self.m7_configuration.is_some());
        optionals.push(self.bluetooth_measurement_configuration.is_some());
        optionals.push(self.wlan_measurement_configuration.is_some());
        optionals.push(self.mdt_location_info.is_some());
        optionals.push(self.sensor_measurement_configuration.is_some());
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.measurements_to_activate.encode(data)?;
        if let Some(x) = &self.m1_configuration {
            x.encode(data)?;
        }
        if let Some(x) = &self.m4_configuration {
            x.encode(data)?;
        }
        if let Some(x) = &self.m5_configuration {
            x.encode(data)?;
        }
        if let Some(x) = &self.m6_configuration {
            x.encode(data)?;
        }
        if let Some(x) = &self.m7_configuration {
            x.encode(data)?;
        }
        if let Some(x) = &self.bluetooth_measurement_configuration {
            x.encode(data)?;
        }
        if let Some(x) = &self.wlan_measurement_configuration {
            x.encode(data)?;
        }
        if let Some(x) = &self.mdt_location_info {
            x.encode(data)?;
        }
        if let Some(x) = &self.sensor_measurement_configuration {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl PerCodec for ImmediateMdtNr {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        ImmediateMdtNr::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ImmediateMdtNr");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ImmediateMdtNr");
            e
        })
    }
}
// InterSystemFailureIndication
#[derive(Clone, Debug)]
pub struct InterSystemFailureIndication {
    pub ue_rlf_report_container: Option<UeRlfReportContainer>,
}

impl InterSystemFailureIndication {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 2)?;
        let ue_rlf_report_container = if optionals[0] {
            Some(UeRlfReportContainer::decode(data)?)
        } else {
            None
        };

        // Process the extension container

        if optionals[1] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            ue_rlf_report_container,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.ue_rlf_report_container.is_some());
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        if let Some(x) = &self.ue_rlf_report_container {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl PerCodec for InterSystemFailureIndication {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        InterSystemFailureIndication::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("InterSystemFailureIndication");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("InterSystemFailureIndication");
            e
        })
    }
}
// IntersystemSonConfigurationTransfer
#[derive(Clone, Debug)]
pub struct IntersystemSonConfigurationTransfer {
    pub transfer_type: IntersystemSonTransferType,
    pub intersystem_son_information: IntersystemSonInformation,
}

impl IntersystemSonConfigurationTransfer {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let transfer_type = IntersystemSonTransferType::decode(data)?;
        let intersystem_son_information = IntersystemSonInformation::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            transfer_type,
            intersystem_son_information,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.transfer_type.encode(data)?;
        self.intersystem_son_information.encode(data)?;

        Ok(())
    }
}

impl PerCodec for IntersystemSonConfigurationTransfer {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        IntersystemSonConfigurationTransfer::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("IntersystemSonConfigurationTransfer");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("IntersystemSonConfigurationTransfer");
            e
        })
    }
}
// IntersystemSonTransferType
#[derive(Clone, Debug)]
pub enum IntersystemSonTransferType {
    FromEutranToNgran(FromEutranToNgran),
    FromNgranToEutran(FromNgranToEutran),
}

impl IntersystemSonTransferType {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_choice_idx(data, 0, 2, false)?;
        if extended {
            return Err(PerCodecError::new("CHOICE additions not implemented"));
        }
        match idx {
            0 => Ok(Self::FromEutranToNgran(FromEutranToNgran::decode(data)?)),
            1 => Ok(Self::FromNgranToEutran(FromNgranToEutran::decode(data)?)),
            2 => {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _ = Criticality::decode(data)?;
                let _ = decode::decode_length_determinent(data, None, None, false)?;
                let result = match id {
                    x => Err(PerCodecError::new(format!("Unrecognised IE type {}", x))),
                };
                data.decode_align()?;
                result
            }
            _ => Err(PerCodecError::new("Unknown choice idx")),
        }
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        match self {
            Self::FromEutranToNgran(x) => {
                encode::encode_choice_idx(data, 0, 2, false, 0, false)?;
                x.encode(data)
            }
            Self::FromNgranToEutran(x) => {
                encode::encode_choice_idx(data, 0, 2, false, 1, false)?;
                x.encode(data)
            }
        }
    }
}

impl PerCodec for IntersystemSonTransferType {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        IntersystemSonTransferType::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("IntersystemSonTransferType");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("IntersystemSonTransferType");
            e
        })
    }
}
// IntersystemSonEnbId
#[derive(Clone, Debug)]
pub struct IntersystemSonEnbId {
    pub global_enb_id: GlobalEnbId,
    pub selected_epstai: EpsTai,
}

impl IntersystemSonEnbId {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let global_enb_id = GlobalEnbId::decode(data)?;
        let selected_epstai = EpsTai::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            global_enb_id,
            selected_epstai,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.global_enb_id.encode(data)?;
        self.selected_epstai.encode(data)?;

        Ok(())
    }
}

impl PerCodec for IntersystemSonEnbId {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        IntersystemSonEnbId::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("IntersystemSonEnbId");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("IntersystemSonEnbId");
            e
        })
    }
}
// IntersystemSonNgranNodeId
#[derive(Clone, Debug)]
pub struct IntersystemSonNgranNodeId {
    pub global_ran_node_id: GlobalRanNodeId,
    pub selected_tai: Tai,
}

impl IntersystemSonNgranNodeId {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let global_ran_node_id = GlobalRanNodeId::decode(data)?;
        let selected_tai = Tai::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            global_ran_node_id,
            selected_tai,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.global_ran_node_id.encode(data)?;
        self.selected_tai.encode(data)?;

        Ok(())
    }
}

impl PerCodec for IntersystemSonNgranNodeId {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        IntersystemSonNgranNodeId::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("IntersystemSonNgranNodeId");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("IntersystemSonNgranNodeId");
            e
        })
    }
}
// IntersystemSonInformation
#[derive(Clone, Debug)]
pub enum IntersystemSonInformation {
    IntersystemSonInformationReport(IntersystemSonInformationReport),
}

impl IntersystemSonInformation {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_choice_idx(data, 0, 1, false)?;
        if extended {
            return Err(PerCodecError::new("CHOICE additions not implemented"));
        }
        match idx {
            0 => Ok(Self::IntersystemSonInformationReport(
                IntersystemSonInformationReport::decode(data)?,
            )),
            1 => {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _ = Criticality::decode(data)?;
                let _ = decode::decode_length_determinent(data, None, None, false)?;
                let result = match id {
                    x => Err(PerCodecError::new(format!("Unrecognised IE type {}", x))),
                };
                data.decode_align()?;
                result
            }
            _ => Err(PerCodecError::new("Unknown choice idx")),
        }
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        match self {
            Self::IntersystemSonInformationReport(x) => {
                encode::encode_choice_idx(data, 0, 1, false, 0, false)?;
                x.encode(data)
            }
        }
    }
}

impl PerCodec for IntersystemSonInformation {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        IntersystemSonInformation::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("IntersystemSonInformation");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("IntersystemSonInformation");
            e
        })
    }
}
// IntersystemSonInformationReport
#[derive(Clone, Debug)]
pub enum IntersystemSonInformationReport {
    HoReportInformation(InterSystemHoReport),
    FailureIndicationInformation(InterSystemFailureIndication),
}

impl IntersystemSonInformationReport {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_choice_idx(data, 0, 2, false)?;
        if extended {
            return Err(PerCodecError::new("CHOICE additions not implemented"));
        }
        match idx {
            0 => Ok(Self::HoReportInformation(InterSystemHoReport::decode(
                data,
            )?)),
            1 => Ok(Self::FailureIndicationInformation(
                InterSystemFailureIndication::decode(data)?,
            )),
            2 => {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _ = Criticality::decode(data)?;
                let _ = decode::decode_length_determinent(data, None, None, false)?;
                let result = match id {
                    x => Err(PerCodecError::new(format!("Unrecognised IE type {}", x))),
                };
                data.decode_align()?;
                result
            }
            _ => Err(PerCodecError::new("Unknown choice idx")),
        }
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        match self {
            Self::HoReportInformation(x) => {
                encode::encode_choice_idx(data, 0, 2, false, 0, false)?;
                x.encode(data)
            }
            Self::FailureIndicationInformation(x) => {
                encode::encode_choice_idx(data, 0, 2, false, 1, false)?;
                x.encode(data)
            }
        }
    }
}

impl PerCodec for IntersystemSonInformationReport {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        IntersystemSonInformationReport::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("IntersystemSonInformationReport");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("IntersystemSonInformationReport");
            e
        })
    }
}
// InterSystemHoReport
#[derive(Clone, Debug)]
pub struct InterSystemHoReport {
    pub handover_report_type: InterSystemHandoverReportType,
}

impl InterSystemHoReport {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let handover_report_type = InterSystemHandoverReportType::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            handover_report_type,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.handover_report_type.encode(data)?;

        Ok(())
    }
}

impl PerCodec for InterSystemHoReport {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        InterSystemHoReport::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("InterSystemHoReport");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("InterSystemHoReport");
            e
        })
    }
}
// InterSystemHandoverReportType
#[derive(Clone, Debug)]
pub enum InterSystemHandoverReportType {
    TooearlyIntersystemHo(TooearlyIntersystemHo),
    IntersystemUnnecessaryHo(IntersystemUnnecessaryHo),
}

impl InterSystemHandoverReportType {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_choice_idx(data, 0, 2, false)?;
        if extended {
            return Err(PerCodecError::new("CHOICE additions not implemented"));
        }
        match idx {
            0 => Ok(Self::TooearlyIntersystemHo(TooearlyIntersystemHo::decode(
                data,
            )?)),
            1 => Ok(Self::IntersystemUnnecessaryHo(
                IntersystemUnnecessaryHo::decode(data)?,
            )),
            2 => {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _ = Criticality::decode(data)?;
                let _ = decode::decode_length_determinent(data, None, None, false)?;
                let result = match id {
                    x => Err(PerCodecError::new(format!("Unrecognised IE type {}", x))),
                };
                data.decode_align()?;
                result
            }
            _ => Err(PerCodecError::new("Unknown choice idx")),
        }
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        match self {
            Self::TooearlyIntersystemHo(x) => {
                encode::encode_choice_idx(data, 0, 2, false, 0, false)?;
                x.encode(data)
            }
            Self::IntersystemUnnecessaryHo(x) => {
                encode::encode_choice_idx(data, 0, 2, false, 1, false)?;
                x.encode(data)
            }
        }
    }
}

impl PerCodec for InterSystemHandoverReportType {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        InterSystemHandoverReportType::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("InterSystemHandoverReportType");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("InterSystemHandoverReportType");
            e
        })
    }
}
// IntersystemUnnecessaryHo
#[derive(Clone, Debug)]
pub struct IntersystemUnnecessaryHo {
    pub sourcecell_id: NgranCgi,
    pub targetcell_id: EutraCgi,
    pub early_iratho: EarlyIratho,
    pub candidate_cell_list: CandidateCellList,
}

impl IntersystemUnnecessaryHo {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let sourcecell_id = NgranCgi::decode(data)?;
        let targetcell_id = EutraCgi::decode(data)?;
        let early_iratho = EarlyIratho::decode(data)?;
        let candidate_cell_list = CandidateCellList::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            sourcecell_id,
            targetcell_id,
            early_iratho,
            candidate_cell_list,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.sourcecell_id.encode(data)?;
        self.targetcell_id.encode(data)?;
        self.early_iratho.encode(data)?;
        self.candidate_cell_list.encode(data)?;

        Ok(())
    }
}

impl PerCodec for IntersystemUnnecessaryHo {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        IntersystemUnnecessaryHo::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("IntersystemUnnecessaryHo");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("IntersystemUnnecessaryHo");
            e
        })
    }
}
// Lac
#[derive(Clone, Debug)]
pub struct Lac(pub [u8; 2]);

impl Lac {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(
            decode::decode_octetstring(data, Some(2), Some(2), false)?
                .try_into()
                .unwrap(),
        ))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_octetstring(data, Some(2), Some(2), false, &(self.0).into(), false)
    }
}

impl PerCodec for Lac {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Lac::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("Lac");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("Lac");
            e
        })
    }
}
// Lai
#[derive(Clone, Debug)]
pub struct Lai {
    pub plmn_identity: PlmnIdentity,
    pub lac: Lac,
}

impl Lai {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let plmn_identity = PlmnIdentity::decode(data)?;
        let lac = Lac::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self { plmn_identity, lac })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.plmn_identity.encode(data)?;
        self.lac.encode(data)?;

        Ok(())
    }
}

impl PerCodec for Lai {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Lai::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("Lai");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("Lai");
            e
        })
    }
}
// LastVisitedCellInformation
#[derive(Clone, Debug)]
pub enum LastVisitedCellInformation {
    NgranCell(LastVisitedNgranCellInformation),
    EutranCell(LastVisitedEutranCellInformation),
    UtranCell(LastVisitedUtranCellInformation),
    GeranCell(LastVisitedGeranCellInformation),
}

impl LastVisitedCellInformation {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_choice_idx(data, 0, 4, false)?;
        if extended {
            return Err(PerCodecError::new("CHOICE additions not implemented"));
        }
        match idx {
            0 => Ok(Self::NgranCell(LastVisitedNgranCellInformation::decode(
                data,
            )?)),
            1 => Ok(Self::EutranCell(LastVisitedEutranCellInformation::decode(
                data,
            )?)),
            2 => Ok(Self::UtranCell(LastVisitedUtranCellInformation::decode(
                data,
            )?)),
            3 => Ok(Self::GeranCell(LastVisitedGeranCellInformation::decode(
                data,
            )?)),
            4 => {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _ = Criticality::decode(data)?;
                let _ = decode::decode_length_determinent(data, None, None, false)?;
                let result = match id {
                    x => Err(PerCodecError::new(format!("Unrecognised IE type {}", x))),
                };
                data.decode_align()?;
                result
            }
            _ => Err(PerCodecError::new("Unknown choice idx")),
        }
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        match self {
            Self::NgranCell(x) => {
                encode::encode_choice_idx(data, 0, 4, false, 0, false)?;
                x.encode(data)
            }
            Self::EutranCell(x) => {
                encode::encode_choice_idx(data, 0, 4, false, 1, false)?;
                x.encode(data)
            }
            Self::UtranCell(x) => {
                encode::encode_choice_idx(data, 0, 4, false, 2, false)?;
                x.encode(data)
            }
            Self::GeranCell(x) => {
                encode::encode_choice_idx(data, 0, 4, false, 3, false)?;
                x.encode(data)
            }
        }
    }
}

impl PerCodec for LastVisitedCellInformation {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        LastVisitedCellInformation::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("LastVisitedCellInformation");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("LastVisitedCellInformation");
            e
        })
    }
}
// LastVisitedCellItem
#[derive(Clone, Debug)]
pub struct LastVisitedCellItem {
    pub last_visited_cell_information: LastVisitedCellInformation,
}

impl LastVisitedCellItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let last_visited_cell_information = LastVisitedCellInformation::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            last_visited_cell_information,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.last_visited_cell_information.encode(data)?;

        Ok(())
    }
}

impl PerCodec for LastVisitedCellItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        LastVisitedCellItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("LastVisitedCellItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("LastVisitedCellItem");
            e
        })
    }
}
// LastVisitedEutranCellInformation
#[derive(Clone, Debug)]
pub struct LastVisitedEutranCellInformation(pub Vec<u8>);

impl LastVisitedEutranCellInformation {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(decode::decode_octetstring(data, None, None, false)?))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_octetstring(data, None, None, false, &self.0, false)
    }
}

impl PerCodec for LastVisitedEutranCellInformation {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        LastVisitedEutranCellInformation::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("LastVisitedEutranCellInformation");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("LastVisitedEutranCellInformation");
            e
        })
    }
}
// LastVisitedGeranCellInformation
#[derive(Clone, Debug)]
pub struct LastVisitedGeranCellInformation(pub Vec<u8>);

impl LastVisitedGeranCellInformation {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(decode::decode_octetstring(data, None, None, false)?))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_octetstring(data, None, None, false, &self.0, false)
    }
}

impl PerCodec for LastVisitedGeranCellInformation {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        LastVisitedGeranCellInformation::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("LastVisitedGeranCellInformation");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("LastVisitedGeranCellInformation");
            e
        })
    }
}
// LastVisitedNgranCellInformation
#[derive(Clone, Debug)]
pub struct LastVisitedNgranCellInformation {
    pub global_cell_id: NgranCgi,
    pub cell_type: CellType,
    pub time_ue_stayed_in_cell: TimeUeStayedInCell,
    pub time_ue_stayed_in_cell_enhanced_granularity: Option<TimeUeStayedInCellEnhancedGranularity>,
    pub ho_cause_value: Option<Cause>,
}

impl LastVisitedNgranCellInformation {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 3)?;
        let global_cell_id = NgranCgi::decode(data)?;
        let cell_type = CellType::decode(data)?;
        let time_ue_stayed_in_cell = TimeUeStayedInCell::decode(data)?;
        let time_ue_stayed_in_cell_enhanced_granularity = if optionals[0] {
            Some(TimeUeStayedInCellEnhancedGranularity::decode(data)?)
        } else {
            None
        };
        let ho_cause_value = if optionals[1] {
            Some(Cause::decode(data)?)
        } else {
            None
        };

        // Process the extension container

        if optionals[2] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            global_cell_id,
            cell_type,
            time_ue_stayed_in_cell,
            time_ue_stayed_in_cell_enhanced_granularity,
            ho_cause_value,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.time_ue_stayed_in_cell_enhanced_granularity.is_some());
        optionals.push(self.ho_cause_value.is_some());
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.global_cell_id.encode(data)?;
        self.cell_type.encode(data)?;
        self.time_ue_stayed_in_cell.encode(data)?;
        if let Some(x) = &self.time_ue_stayed_in_cell_enhanced_granularity {
            x.encode(data)?;
        }
        if let Some(x) = &self.ho_cause_value {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl PerCodec for LastVisitedNgranCellInformation {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        LastVisitedNgranCellInformation::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("LastVisitedNgranCellInformation");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("LastVisitedNgranCellInformation");
            e
        })
    }
}
// LastVisitedUtranCellInformation
#[derive(Clone, Debug)]
pub struct LastVisitedUtranCellInformation(pub Vec<u8>);

impl LastVisitedUtranCellInformation {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(decode::decode_octetstring(data, None, None, false)?))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_octetstring(data, None, None, false, &self.0, false)
    }
}

impl PerCodec for LastVisitedUtranCellInformation {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        LastVisitedUtranCellInformation::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("LastVisitedUtranCellInformation");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("LastVisitedUtranCellInformation");
            e
        })
    }
}
// LineType
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum LineType {
    Dsl,
    Pon,
}

impl LineType {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(1), true)?;
        if extended {
            return Err(PerCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(data, Some(0), Some(1), true, *self as i128, false)
    }
}

impl PerCodec for LineType {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        LineType::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("LineType");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("LineType");
            e
        })
    }
}
// LocationReportingAdditionalInfo
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum LocationReportingAdditionalInfo {
    IncludePsCell,
}

impl LocationReportingAdditionalInfo {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(0), true)?;
        if extended {
            return Err(PerCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(data, Some(0), Some(0), true, *self as i128, false)
    }
}

impl PerCodec for LocationReportingAdditionalInfo {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        LocationReportingAdditionalInfo::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("LocationReportingAdditionalInfo");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("LocationReportingAdditionalInfo");
            e
        })
    }
}
// LocationReportingReferenceId
#[derive(Clone, Copy, Debug)]
pub struct LocationReportingReferenceId(pub u8);

impl LocationReportingReferenceId {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(
            decode::decode_integer(data, Some(1), Some(64), true)?.0 as u8,
        ))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_integer(data, Some(1), Some(64), true, self.0 as i128, false)
    }
}

impl PerCodec for LocationReportingReferenceId {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        LocationReportingReferenceId::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("LocationReportingReferenceId");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("LocationReportingReferenceId");
            e
        })
    }
}
// LocationReportingRequestType
#[derive(Clone, Debug)]
pub struct LocationReportingRequestType {
    pub event_type: EventType,
    pub report_area: ReportArea,
    pub area_of_interest_list: Option<AreaOfInterestList>,
    pub location_reporting_reference_id_to_be_cancelled: Option<LocationReportingReferenceId>,
    pub location_reporting_additional_info: Option<LocationReportingAdditionalInfo>,
}

impl LocationReportingRequestType {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 3)?;
        let event_type = EventType::decode(data)?;
        let report_area = ReportArea::decode(data)?;
        let area_of_interest_list = if optionals[0] {
            Some(AreaOfInterestList::decode(data)?)
        } else {
            None
        };
        let location_reporting_reference_id_to_be_cancelled = if optionals[1] {
            Some(LocationReportingReferenceId::decode(data)?)
        } else {
            None
        };

        // Process the extension container
        let mut location_reporting_additional_info: Option<LocationReportingAdditionalInfo> = None;

        if optionals[2] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    170 => {
                        location_reporting_additional_info =
                            Some(LocationReportingAdditionalInfo::decode(data)?)
                    }
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            event_type,
            report_area,
            area_of_interest_list,
            location_reporting_reference_id_to_be_cancelled,
            location_reporting_additional_info,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();
        if let Some(x) = &self.location_reporting_additional_info {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 170, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        let mut optionals = BitString::new();
        optionals.push(self.area_of_interest_list.is_some());
        optionals.push(
            self.location_reporting_reference_id_to_be_cancelled
                .is_some(),
        );
        optionals.push(num_ies != 0);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.event_type.encode(data)?;
        self.report_area.encode(data)?;
        if let Some(x) = &self.area_of_interest_list {
            x.encode(data)?;
        }
        if let Some(x) = &self.location_reporting_reference_id_to_be_cancelled {
            x.encode(data)?;
        }
        if num_ies != 0 {
            encode::encode_length_determinent(data, Some(1), Some(65535), false, num_ies)?;
            data.append_aligned(ies);
        }
        Ok(())
    }
}

impl PerCodec for LocationReportingRequestType {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        LocationReportingRequestType::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("LocationReportingRequestType");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("LocationReportingRequestType");
            e
        })
    }
}
// LoggedMdtNr
#[derive(Clone, Debug)]
pub struct LoggedMdtNr {
    pub logging_interval: LoggingInterval,
    pub logging_duration: LoggingDuration,
    pub logged_mdt_trigger: LoggedMdtTrigger,
    pub bluetooth_measurement_configuration: Option<BluetoothMeasurementConfiguration>,
    pub wlan_measurement_configuration: Option<WlanMeasurementConfiguration>,
    pub sensor_measurement_configuration: Option<SensorMeasurementConfiguration>,
    pub area_scope_of_neigh_cells_list: Option<AreaScopeOfNeighCellsList>,
}

impl LoggedMdtNr {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 5)?;
        let logging_interval = LoggingInterval::decode(data)?;
        let logging_duration = LoggingDuration::decode(data)?;
        let logged_mdt_trigger = LoggedMdtTrigger::decode(data)?;
        let bluetooth_measurement_configuration = if optionals[0] {
            Some(BluetoothMeasurementConfiguration::decode(data)?)
        } else {
            None
        };
        let wlan_measurement_configuration = if optionals[1] {
            Some(WlanMeasurementConfiguration::decode(data)?)
        } else {
            None
        };
        let sensor_measurement_configuration = if optionals[2] {
            Some(SensorMeasurementConfiguration::decode(data)?)
        } else {
            None
        };
        let area_scope_of_neigh_cells_list = if optionals[3] {
            Some(AreaScopeOfNeighCellsList::decode(data)?)
        } else {
            None
        };

        // Process the extension container

        if optionals[4] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            logging_interval,
            logging_duration,
            logged_mdt_trigger,
            bluetooth_measurement_configuration,
            wlan_measurement_configuration,
            sensor_measurement_configuration,
            area_scope_of_neigh_cells_list,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.bluetooth_measurement_configuration.is_some());
        optionals.push(self.wlan_measurement_configuration.is_some());
        optionals.push(self.sensor_measurement_configuration.is_some());
        optionals.push(self.area_scope_of_neigh_cells_list.is_some());
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.logging_interval.encode(data)?;
        self.logging_duration.encode(data)?;
        self.logged_mdt_trigger.encode(data)?;
        if let Some(x) = &self.bluetooth_measurement_configuration {
            x.encode(data)?;
        }
        if let Some(x) = &self.wlan_measurement_configuration {
            x.encode(data)?;
        }
        if let Some(x) = &self.sensor_measurement_configuration {
            x.encode(data)?;
        }
        if let Some(x) = &self.area_scope_of_neigh_cells_list {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl PerCodec for LoggedMdtNr {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        LoggedMdtNr::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("LoggedMdtNr");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("LoggedMdtNr");
            e
        })
    }
}
// LoggingInterval
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum LoggingInterval {
    Ms320,
    Ms640,
    Ms1280,
    Ms2560,
    Ms5120,
    Ms10240,
    Ms20480,
    Ms30720,
    Ms40960,
    Ms61440,
    Infinity,
}

impl LoggingInterval {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(10), true)?;
        if extended {
            return Err(PerCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(data, Some(0), Some(10), true, *self as i128, false)
    }
}

impl PerCodec for LoggingInterval {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        LoggingInterval::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("LoggingInterval");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("LoggingInterval");
            e
        })
    }
}
// LoggingDuration
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum LoggingDuration {
    M10,
    M20,
    M40,
    M60,
    M90,
    M120,
}

impl LoggingDuration {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(5), true)?;
        if extended {
            return Err(PerCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(data, Some(0), Some(5), true, *self as i128, false)
    }
}

impl PerCodec for LoggingDuration {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        LoggingDuration::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("LoggingDuration");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("LoggingDuration");
            e
        })
    }
}
// LinksToLog
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum LinksToLog {
    Uplink,
    Downlink,
    BothUplinkAndDownlink,
}

impl LinksToLog {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(2), true)?;
        if extended {
            return Err(PerCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(data, Some(0), Some(2), true, *self as i128, false)
    }
}

impl PerCodec for LinksToLog {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        LinksToLog::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("LinksToLog");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("LinksToLog");
            e
        })
    }
}
// LoggedMdtTrigger
#[derive(Clone, Debug)]
pub enum LoggedMdtTrigger {
    Periodical,
    EventTrigger(EventTrigger),
}

impl LoggedMdtTrigger {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_choice_idx(data, 0, 2, false)?;
        if extended {
            return Err(PerCodecError::new("CHOICE additions not implemented"));
        }
        match idx {
            0 => Ok(Self::Periodical),
            1 => Ok(Self::EventTrigger(EventTrigger::decode(data)?)),
            2 => {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _ = Criticality::decode(data)?;
                let _ = decode::decode_length_determinent(data, None, None, false)?;
                let result = match id {
                    x => Err(PerCodecError::new(format!("Unrecognised IE type {}", x))),
                };
                data.decode_align()?;
                result
            }
            _ => Err(PerCodecError::new("Unknown choice idx")),
        }
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        match self {
            Self::Periodical => {
                encode::encode_choice_idx(data, 0, 2, false, 0, false)?;
                Ok(())
            }
            Self::EventTrigger(x) => {
                encode::encode_choice_idx(data, 0, 2, false, 1, false)?;
                x.encode(data)
            }
        }
    }
}

impl PerCodec for LoggedMdtTrigger {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        LoggedMdtTrigger::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("LoggedMdtTrigger");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("LoggedMdtTrigger");
            e
        })
    }
}
// LtemIndication
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum LtemIndication {
    LteM,
}

impl LtemIndication {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(0), true)?;
        if extended {
            return Err(PerCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(data, Some(0), Some(0), true, *self as i128, false)
    }
}

impl PerCodec for LtemIndication {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        LtemIndication::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("LtemIndication");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("LtemIndication");
            e
        })
    }
}
// LteUeRlfReportContainer
#[derive(Clone, Debug)]
pub struct LteUeRlfReportContainer(pub Vec<u8>);

impl LteUeRlfReportContainer {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(decode::decode_octetstring(data, None, None, false)?))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_octetstring(data, None, None, false, &self.0, false)
    }
}

impl PerCodec for LteUeRlfReportContainer {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        LteUeRlfReportContainer::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("LteUeRlfReportContainer");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("LteUeRlfReportContainer");
            e
        })
    }
}
// Ltev2xServicesAuthorized
#[derive(Clone, Debug)]
pub struct Ltev2xServicesAuthorized {
    pub vehicle_ue: Option<VehicleUe>,
    pub pedestrian_ue: Option<PedestrianUe>,
}

impl Ltev2xServicesAuthorized {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 3)?;
        let vehicle_ue = if optionals[0] {
            Some(VehicleUe::decode(data)?)
        } else {
            None
        };
        let pedestrian_ue = if optionals[1] {
            Some(PedestrianUe::decode(data)?)
        } else {
            None
        };

        // Process the extension container

        if optionals[2] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            vehicle_ue,
            pedestrian_ue,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.vehicle_ue.is_some());
        optionals.push(self.pedestrian_ue.is_some());
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        if let Some(x) = &self.vehicle_ue {
            x.encode(data)?;
        }
        if let Some(x) = &self.pedestrian_ue {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl PerCodec for Ltev2xServicesAuthorized {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ltev2xServicesAuthorized::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("Ltev2xServicesAuthorized");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("Ltev2xServicesAuthorized");
            e
        })
    }
}
// LteUeSidelinkAggregateMaximumBitrate
#[derive(Clone, Debug)]
pub struct LteUeSidelinkAggregateMaximumBitrate {
    pub ue_sidelink_aggregate_maximum_bit_rate: BitRate,
}

impl LteUeSidelinkAggregateMaximumBitrate {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let ue_sidelink_aggregate_maximum_bit_rate = BitRate::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            ue_sidelink_aggregate_maximum_bit_rate,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.ue_sidelink_aggregate_maximum_bit_rate.encode(data)?;

        Ok(())
    }
}

impl PerCodec for LteUeSidelinkAggregateMaximumBitrate {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        LteUeSidelinkAggregateMaximumBitrate::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("LteUeSidelinkAggregateMaximumBitrate");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("LteUeSidelinkAggregateMaximumBitrate");
            e
        })
    }
}
// MaskedImeisv
#[derive(Clone, Debug)]
pub struct MaskedImeisv(pub BitString);

impl MaskedImeisv {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(decode::decode_bitstring(
            data,
            Some(64),
            Some(64),
            false,
        )?))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_bitstring(data, Some(64), Some(64), false, &self.0, false)
    }
}

impl PerCodec for MaskedImeisv {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        MaskedImeisv::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MaskedImeisv");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MaskedImeisv");
            e
        })
    }
}
// MaximumDataBurstVolume
#[derive(Clone, Copy, Debug)]
pub struct MaximumDataBurstVolume(pub i128);

impl MaximumDataBurstVolume {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(
            decode::decode_integer(data, Some(0), Some(4095), true)?.0,
        ))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_integer(data, Some(0), Some(4095), true, self.0, false)
    }
}

impl PerCodec for MaximumDataBurstVolume {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        MaximumDataBurstVolume::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MaximumDataBurstVolume");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MaximumDataBurstVolume");
            e
        })
    }
}
// MessageIdentifier
#[derive(Clone, Debug)]
pub struct MessageIdentifier(pub BitString);

impl MessageIdentifier {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(decode::decode_bitstring(
            data,
            Some(16),
            Some(16),
            false,
        )?))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_bitstring(data, Some(16), Some(16), false, &self.0, false)
    }
}

impl PerCodec for MessageIdentifier {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        MessageIdentifier::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MessageIdentifier");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MessageIdentifier");
            e
        })
    }
}
// MaximumIntegrityProtectedDataRate
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum MaximumIntegrityProtectedDataRate {
    Bitrate64kbs,
    MaximumUeRate,
}

impl MaximumIntegrityProtectedDataRate {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(1), true)?;
        if extended {
            return Err(PerCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(data, Some(0), Some(1), true, *self as i128, false)
    }
}

impl PerCodec for MaximumIntegrityProtectedDataRate {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        MaximumIntegrityProtectedDataRate::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MaximumIntegrityProtectedDataRate");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MaximumIntegrityProtectedDataRate");
            e
        })
    }
}
// MicoModeIndication
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum MicoModeIndication {
    True,
}

impl MicoModeIndication {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(0), true)?;
        if extended {
            return Err(PerCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(data, Some(0), Some(0), true, *self as i128, false)
    }
}

impl PerCodec for MicoModeIndication {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        MicoModeIndication::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MicoModeIndication");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MicoModeIndication");
            e
        })
    }
}
// MobilityInformation
#[derive(Clone, Debug)]
pub struct MobilityInformation(pub BitString);

impl MobilityInformation {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(decode::decode_bitstring(
            data,
            Some(16),
            Some(16),
            false,
        )?))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_bitstring(data, Some(16), Some(16), false, &self.0, false)
    }
}

impl PerCodec for MobilityInformation {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        MobilityInformation::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MobilityInformation");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MobilityInformation");
            e
        })
    }
}
// MobilityRestrictionList
#[derive(Clone, Debug)]
pub struct MobilityRestrictionList {
    pub serving_plmn: PlmnIdentity,
    pub equivalent_plmns: Option<EquivalentPlmns>,
    pub rat_restrictions: Option<RatRestrictions>,
    pub forbidden_area_information: Option<ForbiddenAreaInformation>,
    pub service_area_information: Option<ServiceAreaInformation>,
    pub last_eutran_plmn_identity: Option<PlmnIdentity>,
    pub cn_type_restrictions_for_serving: Option<CnTypeRestrictionsForServing>,
    pub cn_type_restrictions_for_equivalent: Option<CnTypeRestrictionsForEquivalent>,
    pub npn_mobility_information: Option<NpnMobilityInformation>,
}

impl MobilityRestrictionList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 5)?;
        let serving_plmn = PlmnIdentity::decode(data)?;
        let equivalent_plmns = if optionals[0] {
            Some(EquivalentPlmns::decode(data)?)
        } else {
            None
        };
        let rat_restrictions = if optionals[1] {
            Some(RatRestrictions::decode(data)?)
        } else {
            None
        };
        let forbidden_area_information = if optionals[2] {
            Some(ForbiddenAreaInformation::decode(data)?)
        } else {
            None
        };
        let service_area_information = if optionals[3] {
            Some(ServiceAreaInformation::decode(data)?)
        } else {
            None
        };

        // Process the extension container
        let mut last_eutran_plmn_identity: Option<PlmnIdentity> = None;
        let mut cn_type_restrictions_for_serving: Option<CnTypeRestrictionsForServing> = None;
        let mut cn_type_restrictions_for_equivalent: Option<CnTypeRestrictionsForEquivalent> = None;
        let mut npn_mobility_information: Option<NpnMobilityInformation> = None;

        if optionals[4] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    150 => last_eutran_plmn_identity = Some(PlmnIdentity::decode(data)?),
                    161 => {
                        cn_type_restrictions_for_serving =
                            Some(CnTypeRestrictionsForServing::decode(data)?)
                    }
                    160 => {
                        cn_type_restrictions_for_equivalent =
                            Some(CnTypeRestrictionsForEquivalent::decode(data)?)
                    }
                    261 => npn_mobility_information = Some(NpnMobilityInformation::decode(data)?),
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            serving_plmn,
            equivalent_plmns,
            rat_restrictions,
            forbidden_area_information,
            service_area_information,
            last_eutran_plmn_identity,
            cn_type_restrictions_for_serving,
            cn_type_restrictions_for_equivalent,
            npn_mobility_information,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();
        if let Some(x) = &self.last_eutran_plmn_identity {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 150, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.cn_type_restrictions_for_serving {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 161, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.cn_type_restrictions_for_equivalent {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 160, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.npn_mobility_information {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 261, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        let mut optionals = BitString::new();
        optionals.push(self.equivalent_plmns.is_some());
        optionals.push(self.rat_restrictions.is_some());
        optionals.push(self.forbidden_area_information.is_some());
        optionals.push(self.service_area_information.is_some());
        optionals.push(num_ies != 0);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.serving_plmn.encode(data)?;
        if let Some(x) = &self.equivalent_plmns {
            x.encode(data)?;
        }
        if let Some(x) = &self.rat_restrictions {
            x.encode(data)?;
        }
        if let Some(x) = &self.forbidden_area_information {
            x.encode(data)?;
        }
        if let Some(x) = &self.service_area_information {
            x.encode(data)?;
        }
        if num_ies != 0 {
            encode::encode_length_determinent(data, Some(1), Some(65535), false, num_ies)?;
            data.append_aligned(ies);
        }
        Ok(())
    }
}

impl PerCodec for MobilityRestrictionList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        MobilityRestrictionList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MobilityRestrictionList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MobilityRestrictionList");
            e
        })
    }
}
// MdtPlmnList
#[derive(Clone, Debug)]
pub struct MdtPlmnList(pub NonEmpty<PlmnIdentity>);

impl MdtPlmnList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(16), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(PlmnIdentity::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(16), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for MdtPlmnList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        MdtPlmnList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MdtPlmnList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MdtPlmnList");
            e
        })
    }
}
// MdtConfiguration
#[derive(Clone, Debug)]
pub struct MdtConfiguration {
    pub mdt_config_nr: Option<MdtConfigurationNr>,
    pub mdt_config_eutra: Option<MdtConfigurationEutra>,
}

impl MdtConfiguration {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 3)?;
        let mdt_config_nr = if optionals[0] {
            Some(MdtConfigurationNr::decode(data)?)
        } else {
            None
        };
        let mdt_config_eutra = if optionals[1] {
            Some(MdtConfigurationEutra::decode(data)?)
        } else {
            None
        };

        // Process the extension container

        if optionals[2] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            mdt_config_nr,
            mdt_config_eutra,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.mdt_config_nr.is_some());
        optionals.push(self.mdt_config_eutra.is_some());
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        if let Some(x) = &self.mdt_config_nr {
            x.encode(data)?;
        }
        if let Some(x) = &self.mdt_config_eutra {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl PerCodec for MdtConfiguration {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        MdtConfiguration::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MdtConfiguration");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MdtConfiguration");
            e
        })
    }
}
// MdtConfigurationNr
#[derive(Clone, Debug)]
pub struct MdtConfigurationNr {
    pub mdt_activation: MdtActivation,
    pub area_scope_of_mdt: AreaScopeOfMdtNr,
    pub mdt_mode_nr: MdtModeNr,
    pub signalling_based_mdt_plmn_list: Option<MdtPlmnList>,
}

impl MdtConfigurationNr {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 2)?;
        let mdt_activation = MdtActivation::decode(data)?;
        let area_scope_of_mdt = AreaScopeOfMdtNr::decode(data)?;
        let mdt_mode_nr = MdtModeNr::decode(data)?;
        let signalling_based_mdt_plmn_list = if optionals[0] {
            Some(MdtPlmnList::decode(data)?)
        } else {
            None
        };

        // Process the extension container

        if optionals[1] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            mdt_activation,
            area_scope_of_mdt,
            mdt_mode_nr,
            signalling_based_mdt_plmn_list,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.signalling_based_mdt_plmn_list.is_some());
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.mdt_activation.encode(data)?;
        self.area_scope_of_mdt.encode(data)?;
        self.mdt_mode_nr.encode(data)?;
        if let Some(x) = &self.signalling_based_mdt_plmn_list {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl PerCodec for MdtConfigurationNr {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        MdtConfigurationNr::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MdtConfigurationNr");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MdtConfigurationNr");
            e
        })
    }
}
// MdtConfigurationEutra
#[derive(Clone, Debug)]
pub struct MdtConfigurationEutra {
    pub mdt_activation: MdtActivation,
    pub area_scope_of_mdt: AreaScopeOfMdtEutra,
    pub mdt_mode: MdtModeEutra,
    pub signalling_based_mdt_plmn_list: Option<MdtPlmnList>,
}

impl MdtConfigurationEutra {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 2)?;
        let mdt_activation = MdtActivation::decode(data)?;
        let area_scope_of_mdt = AreaScopeOfMdtEutra::decode(data)?;
        let mdt_mode = MdtModeEutra::decode(data)?;
        let signalling_based_mdt_plmn_list = if optionals[0] {
            Some(MdtPlmnList::decode(data)?)
        } else {
            None
        };

        // Process the extension container

        if optionals[1] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            mdt_activation,
            area_scope_of_mdt,
            mdt_mode,
            signalling_based_mdt_plmn_list,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.signalling_based_mdt_plmn_list.is_some());
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.mdt_activation.encode(data)?;
        self.area_scope_of_mdt.encode(data)?;
        self.mdt_mode.encode(data)?;
        if let Some(x) = &self.signalling_based_mdt_plmn_list {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl PerCodec for MdtConfigurationEutra {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        MdtConfigurationEutra::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MdtConfigurationEutra");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MdtConfigurationEutra");
            e
        })
    }
}
// MdtActivation
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum MdtActivation {
    ImmediateMdtOnly,
    LoggedMdtOnly,
    ImmediateMdtAndTrace,
}

impl MdtActivation {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(2), true)?;
        if extended {
            return Err(PerCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(data, Some(0), Some(2), true, *self as i128, false)
    }
}

impl PerCodec for MdtActivation {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        MdtActivation::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MdtActivation");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MdtActivation");
            e
        })
    }
}
// MdtModeNr
#[derive(Clone, Debug)]
pub enum MdtModeNr {
    ImmediateMdtNr(ImmediateMdtNr),
    LoggedMdtNr(LoggedMdtNr),
}

impl MdtModeNr {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_choice_idx(data, 0, 2, false)?;
        if extended {
            return Err(PerCodecError::new("CHOICE additions not implemented"));
        }
        match idx {
            0 => Ok(Self::ImmediateMdtNr(ImmediateMdtNr::decode(data)?)),
            1 => Ok(Self::LoggedMdtNr(LoggedMdtNr::decode(data)?)),
            2 => {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _ = Criticality::decode(data)?;
                let _ = decode::decode_length_determinent(data, None, None, false)?;
                let result = match id {
                    x => Err(PerCodecError::new(format!("Unrecognised IE type {}", x))),
                };
                data.decode_align()?;
                result
            }
            _ => Err(PerCodecError::new("Unknown choice idx")),
        }
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        match self {
            Self::ImmediateMdtNr(x) => {
                encode::encode_choice_idx(data, 0, 2, false, 0, false)?;
                x.encode(data)
            }
            Self::LoggedMdtNr(x) => {
                encode::encode_choice_idx(data, 0, 2, false, 1, false)?;
                x.encode(data)
            }
        }
    }
}

impl PerCodec for MdtModeNr {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        MdtModeNr::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MdtModeNr");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MdtModeNr");
            e
        })
    }
}
// MdtModeEutra
#[derive(Clone, Debug)]
pub struct MdtModeEutra(pub Vec<u8>);

impl MdtModeEutra {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(decode::decode_octetstring(data, None, None, false)?))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_octetstring(data, None, None, false, &self.0, false)
    }
}

impl PerCodec for MdtModeEutra {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        MdtModeEutra::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MdtModeEutra");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MdtModeEutra");
            e
        })
    }
}
// MeasurementsToActivate
#[derive(Clone, Debug)]
pub struct MeasurementsToActivate(pub BitString);

impl MeasurementsToActivate {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(decode::decode_bitstring(
            data,
            Some(8),
            Some(8),
            false,
        )?))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_bitstring(data, Some(8), Some(8), false, &self.0, false)
    }
}

impl PerCodec for MeasurementsToActivate {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        MeasurementsToActivate::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MeasurementsToActivate");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MeasurementsToActivate");
            e
        })
    }
}
// M1Configuration
#[derive(Clone, Debug)]
pub struct M1Configuration {
    pub m1reporting_trigger: M1ReportingTrigger,
    pub m1threshold_event_a2: Option<M1ThresholdEventA2>,
    pub m1periodic_reporting: Option<M1PeriodicReporting>,
}

impl M1Configuration {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 3)?;
        let m1reporting_trigger = M1ReportingTrigger::decode(data)?;
        let m1threshold_event_a2 = if optionals[0] {
            Some(M1ThresholdEventA2::decode(data)?)
        } else {
            None
        };
        let m1periodic_reporting = if optionals[1] {
            Some(M1PeriodicReporting::decode(data)?)
        } else {
            None
        };

        // Process the extension container

        if optionals[2] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            m1reporting_trigger,
            m1threshold_event_a2,
            m1periodic_reporting,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.m1threshold_event_a2.is_some());
        optionals.push(self.m1periodic_reporting.is_some());
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.m1reporting_trigger.encode(data)?;
        if let Some(x) = &self.m1threshold_event_a2 {
            x.encode(data)?;
        }
        if let Some(x) = &self.m1periodic_reporting {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl PerCodec for M1Configuration {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        M1Configuration::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("M1Configuration");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("M1Configuration");
            e
        })
    }
}
// M1ReportingTrigger
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum M1ReportingTrigger {
    Periodic,
    A2eventtriggered,
    A2eventtriggeredPeriodic,
}

impl M1ReportingTrigger {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(2), true)?;
        if extended {
            return Err(PerCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(data, Some(0), Some(2), true, *self as i128, false)
    }
}

impl PerCodec for M1ReportingTrigger {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        M1ReportingTrigger::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("M1ReportingTrigger");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("M1ReportingTrigger");
            e
        })
    }
}
// M1ThresholdEventA2
#[derive(Clone, Debug)]
pub struct M1ThresholdEventA2 {
    pub m1_threshold_type: M1ThresholdType,
}

impl M1ThresholdEventA2 {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let m1_threshold_type = M1ThresholdType::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self { m1_threshold_type })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.m1_threshold_type.encode(data)?;

        Ok(())
    }
}

impl PerCodec for M1ThresholdEventA2 {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        M1ThresholdEventA2::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("M1ThresholdEventA2");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("M1ThresholdEventA2");
            e
        })
    }
}
// M1ThresholdType
#[derive(Clone, Debug)]
pub enum M1ThresholdType {
    ThresholdRsrp(ThresholdRsrp),
    ThresholdRsrq(ThresholdRsrq),
    ThresholdSiNr(ThresholdSiNr),
}

impl M1ThresholdType {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_choice_idx(data, 0, 3, false)?;
        if extended {
            return Err(PerCodecError::new("CHOICE additions not implemented"));
        }
        match idx {
            0 => Ok(Self::ThresholdRsrp(ThresholdRsrp::decode(data)?)),
            1 => Ok(Self::ThresholdRsrq(ThresholdRsrq::decode(data)?)),
            2 => Ok(Self::ThresholdSiNr(ThresholdSiNr::decode(data)?)),
            3 => {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _ = Criticality::decode(data)?;
                let _ = decode::decode_length_determinent(data, None, None, false)?;
                let result = match id {
                    x => Err(PerCodecError::new(format!("Unrecognised IE type {}", x))),
                };
                data.decode_align()?;
                result
            }
            _ => Err(PerCodecError::new("Unknown choice idx")),
        }
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        match self {
            Self::ThresholdRsrp(x) => {
                encode::encode_choice_idx(data, 0, 3, false, 0, false)?;
                x.encode(data)
            }
            Self::ThresholdRsrq(x) => {
                encode::encode_choice_idx(data, 0, 3, false, 1, false)?;
                x.encode(data)
            }
            Self::ThresholdSiNr(x) => {
                encode::encode_choice_idx(data, 0, 3, false, 2, false)?;
                x.encode(data)
            }
        }
    }
}

impl PerCodec for M1ThresholdType {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        M1ThresholdType::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("M1ThresholdType");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("M1ThresholdType");
            e
        })
    }
}
// M1PeriodicReporting
#[derive(Clone, Debug)]
pub struct M1PeriodicReporting {
    pub report_interval: ReportIntervalMdt,
    pub report_amount: ReportAmountMdt,
}

impl M1PeriodicReporting {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let report_interval = ReportIntervalMdt::decode(data)?;
        let report_amount = ReportAmountMdt::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            report_interval,
            report_amount,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.report_interval.encode(data)?;
        self.report_amount.encode(data)?;

        Ok(())
    }
}

impl PerCodec for M1PeriodicReporting {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        M1PeriodicReporting::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("M1PeriodicReporting");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("M1PeriodicReporting");
            e
        })
    }
}
// M4Configuration
#[derive(Clone, Debug)]
pub struct M4Configuration {
    pub m4period: M4period,
    pub m4_links_to_log: LinksToLog,
}

impl M4Configuration {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let m4period = M4period::decode(data)?;
        let m4_links_to_log = LinksToLog::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            m4period,
            m4_links_to_log,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.m4period.encode(data)?;
        self.m4_links_to_log.encode(data)?;

        Ok(())
    }
}

impl PerCodec for M4Configuration {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        M4Configuration::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("M4Configuration");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("M4Configuration");
            e
        })
    }
}
// M4period
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum M4period {
    Ms1024,
    Ms2048,
    Ms5120,
    Ms10240,
    Min1,
}

impl M4period {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(4), true)?;
        if extended {
            return Err(PerCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(data, Some(0), Some(4), true, *self as i128, false)
    }
}

impl PerCodec for M4period {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        M4period::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("M4period");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("M4period");
            e
        })
    }
}
// M5Configuration
#[derive(Clone, Debug)]
pub struct M5Configuration {
    pub m5period: M5period,
    pub m5_links_to_log: LinksToLog,
}

impl M5Configuration {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let m5period = M5period::decode(data)?;
        let m5_links_to_log = LinksToLog::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            m5period,
            m5_links_to_log,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.m5period.encode(data)?;
        self.m5_links_to_log.encode(data)?;

        Ok(())
    }
}

impl PerCodec for M5Configuration {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        M5Configuration::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("M5Configuration");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("M5Configuration");
            e
        })
    }
}
// M5period
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum M5period {
    Ms1024,
    Ms2048,
    Ms5120,
    Ms10240,
    Min1,
}

impl M5period {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(4), true)?;
        if extended {
            return Err(PerCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(data, Some(0), Some(4), true, *self as i128, false)
    }
}

impl PerCodec for M5period {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        M5period::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("M5period");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("M5period");
            e
        })
    }
}
// M6Configuration
#[derive(Clone, Debug)]
pub struct M6Configuration {
    pub m6report_interval: M6reportInterval,
    pub m6_links_to_log: LinksToLog,
}

impl M6Configuration {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let m6report_interval = M6reportInterval::decode(data)?;
        let m6_links_to_log = LinksToLog::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            m6report_interval,
            m6_links_to_log,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.m6report_interval.encode(data)?;
        self.m6_links_to_log.encode(data)?;

        Ok(())
    }
}

impl PerCodec for M6Configuration {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        M6Configuration::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("M6Configuration");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("M6Configuration");
            e
        })
    }
}
// M6reportInterval
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum M6reportInterval {
    Ms120,
    Ms240,
    Ms480,
    Ms640,
    Ms1024,
    Ms2048,
    Ms5120,
    Ms10240,
    Ms20480,
    Ms40960,
    Min1,
    Min6,
    Min12,
    Min30,
}

impl M6reportInterval {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(13), true)?;
        if extended {
            return Err(PerCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(data, Some(0), Some(13), true, *self as i128, false)
    }
}

impl PerCodec for M6reportInterval {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        M6reportInterval::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("M6reportInterval");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("M6reportInterval");
            e
        })
    }
}
// M7Configuration
#[derive(Clone, Debug)]
pub struct M7Configuration {
    pub m7period: M7period,
    pub m7_links_to_log: LinksToLog,
}

impl M7Configuration {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let m7period = M7period::decode(data)?;
        let m7_links_to_log = LinksToLog::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            m7period,
            m7_links_to_log,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.m7period.encode(data)?;
        self.m7_links_to_log.encode(data)?;

        Ok(())
    }
}

impl PerCodec for M7Configuration {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        M7Configuration::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("M7Configuration");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("M7Configuration");
            e
        })
    }
}
// M7period
#[derive(Clone, Copy, Debug)]
pub struct M7period(pub u8);

impl M7period {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(
            decode::decode_integer(data, Some(1), Some(60), true)?.0 as u8,
        ))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_integer(data, Some(1), Some(60), true, self.0 as i128, false)
    }
}

impl PerCodec for M7period {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        M7period::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("M7period");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("M7period");
            e
        })
    }
}
// MdtLocationInfo
#[derive(Clone, Debug)]
pub struct MdtLocationInfo {
    pub mdt_location_information: MdtLocationInformation,
}

impl MdtLocationInfo {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let mdt_location_information = MdtLocationInformation::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            mdt_location_information,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.mdt_location_information.encode(data)?;

        Ok(())
    }
}

impl PerCodec for MdtLocationInfo {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        MdtLocationInfo::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MdtLocationInfo");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MdtLocationInfo");
            e
        })
    }
}
// MdtLocationInformation
#[derive(Clone, Debug)]
pub struct MdtLocationInformation(pub BitString);

impl MdtLocationInformation {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(decode::decode_bitstring(
            data,
            Some(8),
            Some(8),
            false,
        )?))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_bitstring(data, Some(8), Some(8), false, &self.0, false)
    }
}

impl PerCodec for MdtLocationInformation {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        MdtLocationInformation::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MdtLocationInformation");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MdtLocationInformation");
            e
        })
    }
}
// N3IwfId
#[derive(Clone, Debug)]
pub enum N3IwfId {
    N3IwfId(BitString),
}

impl N3IwfId {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_choice_idx(data, 0, 1, false)?;
        if extended {
            return Err(PerCodecError::new("CHOICE additions not implemented"));
        }
        match idx {
            0 => Ok(Self::N3IwfId(decode::decode_bitstring(
                data,
                Some(16),
                Some(16),
                false,
            )?)),
            1 => {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _ = Criticality::decode(data)?;
                let _ = decode::decode_length_determinent(data, None, None, false)?;
                let result = match id {
                    x => Err(PerCodecError::new(format!("Unrecognised IE type {}", x))),
                };
                data.decode_align()?;
                result
            }
            _ => Err(PerCodecError::new("Unknown choice idx")),
        }
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        match self {
            Self::N3IwfId(x) => {
                encode::encode_choice_idx(data, 0, 1, false, 0, false)?;
                encode::encode_bitstring(data, Some(16), Some(16), false, &x, false)
            }
        }
    }
}

impl PerCodec for N3IwfId {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        N3IwfId::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("N3IwfId");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("N3IwfId");
            e
        })
    }
}
// NasPdu
#[derive(Clone, Debug)]
pub struct NasPdu(pub Vec<u8>);

impl NasPdu {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(decode::decode_octetstring(data, None, None, false)?))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_octetstring(data, None, None, false, &self.0, false)
    }
}

impl PerCodec for NasPdu {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        NasPdu::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NasPdu");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NasPdu");
            e
        })
    }
}
// NasSecurityParametersFromNgran
#[derive(Clone, Debug)]
pub struct NasSecurityParametersFromNgran(pub Vec<u8>);

impl NasSecurityParametersFromNgran {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(decode::decode_octetstring(data, None, None, false)?))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_octetstring(data, None, None, false, &self.0, false)
    }
}

impl PerCodec for NasSecurityParametersFromNgran {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        NasSecurityParametersFromNgran::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NasSecurityParametersFromNgran");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NasSecurityParametersFromNgran");
            e
        })
    }
}
// NbIotDefaultPagingDrx
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum NbIotDefaultPagingDrx {
    Rf128,
    Rf256,
    Rf512,
    Rf1024,
}

impl NbIotDefaultPagingDrx {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(3), true)?;
        if extended {
            return Err(PerCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(data, Some(0), Some(3), true, *self as i128, false)
    }
}

impl PerCodec for NbIotDefaultPagingDrx {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        NbIotDefaultPagingDrx::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NbIotDefaultPagingDrx");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NbIotDefaultPagingDrx");
            e
        })
    }
}
// NbIotPagingDrx
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum NbIotPagingDrx {
    Rf32,
    Rf64,
    Rf128,
    Rf256,
    Rf512,
    Rf1024,
}

impl NbIotPagingDrx {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(5), true)?;
        if extended {
            return Err(PerCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(data, Some(0), Some(5), true, *self as i128, false)
    }
}

impl PerCodec for NbIotPagingDrx {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        NbIotPagingDrx::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NbIotPagingDrx");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NbIotPagingDrx");
            e
        })
    }
}
// NbIotPagingEDrxCycle
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum NbIotPagingEDrxCycle {
    Hf2,
    Hf4,
    Hf6,
    Hf8,
    Hf10,
    Hf12,
    Hf14,
    Hf16,
    Hf32,
    Hf64,
    Hf128,
    Hf256,
    Hf512,
    Hf1024,
}

impl NbIotPagingEDrxCycle {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(13), true)?;
        if extended {
            return Err(PerCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(data, Some(0), Some(13), true, *self as i128, false)
    }
}

impl PerCodec for NbIotPagingEDrxCycle {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        NbIotPagingEDrxCycle::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NbIotPagingEDrxCycle");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NbIotPagingEDrxCycle");
            e
        })
    }
}
// NbIotPagingTimeWindow
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum NbIotPagingTimeWindow {
    S1,
    S2,
    S3,
    S4,
    S5,
    S6,
    S7,
    S8,
    S9,
    S10,
    S11,
    S12,
    S13,
    S14,
    S15,
    S16,
}

impl NbIotPagingTimeWindow {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(15), true)?;
        if extended {
            return Err(PerCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(data, Some(0), Some(15), true, *self as i128, false)
    }
}

impl PerCodec for NbIotPagingTimeWindow {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        NbIotPagingTimeWindow::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NbIotPagingTimeWindow");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NbIotPagingTimeWindow");
            e
        })
    }
}
// NbIotPagingEDrxInfo
#[derive(Clone, Debug)]
pub struct NbIotPagingEDrxInfo {
    pub nb_iot_paging_e_drx_cycle: NbIotPagingEDrxCycle,
    pub nb_iot_paging_time_window: Option<NbIotPagingTimeWindow>,
}

impl NbIotPagingEDrxInfo {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 2)?;
        let nb_iot_paging_e_drx_cycle = NbIotPagingEDrxCycle::decode(data)?;
        let nb_iot_paging_time_window = if optionals[0] {
            Some(NbIotPagingTimeWindow::decode(data)?)
        } else {
            None
        };

        // Process the extension container

        if optionals[1] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            nb_iot_paging_e_drx_cycle,
            nb_iot_paging_time_window,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.nb_iot_paging_time_window.is_some());
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.nb_iot_paging_e_drx_cycle.encode(data)?;
        if let Some(x) = &self.nb_iot_paging_time_window {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl PerCodec for NbIotPagingEDrxInfo {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        NbIotPagingEDrxInfo::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NbIotPagingEDrxInfo");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NbIotPagingEDrxInfo");
            e
        })
    }
}
// NbIotUePriority
#[derive(Clone, Copy, Debug)]
pub struct NbIotUePriority(pub u8);

impl NbIotUePriority {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(
            decode::decode_integer(data, Some(0), Some(255), true)?.0 as u8,
        ))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_integer(data, Some(0), Some(255), true, self.0 as i128, false)
    }
}

impl PerCodec for NbIotUePriority {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        NbIotUePriority::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NbIotUePriority");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NbIotUePriority");
            e
        })
    }
}
// NetworkInstance
#[derive(Clone, Copy, Debug)]
pub struct NetworkInstance(pub u16);

impl NetworkInstance {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(
            decode::decode_integer(data, Some(1), Some(256), true)?.0 as u16,
        ))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_integer(data, Some(1), Some(256), true, self.0 as i128, false)
    }
}

impl PerCodec for NetworkInstance {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        NetworkInstance::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NetworkInstance");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NetworkInstance");
            e
        })
    }
}
// NewSecurityContextInd
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum NewSecurityContextInd {
    True,
}

impl NewSecurityContextInd {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(0), true)?;
        if extended {
            return Err(PerCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(data, Some(0), Some(0), true, *self as i128, false)
    }
}

impl PerCodec for NewSecurityContextInd {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        NewSecurityContextInd::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NewSecurityContextInd");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NewSecurityContextInd");
            e
        })
    }
}
// NextHopChainingCount
#[derive(Clone, Copy, Debug)]
pub struct NextHopChainingCount(pub u8);

impl NextHopChainingCount {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(
            decode::decode_integer(data, Some(0), Some(7), false)?.0 as u8,
        ))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_integer(data, Some(0), Some(7), false, self.0 as i128, false)
    }
}

impl PerCodec for NextHopChainingCount {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        NextHopChainingCount::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NextHopChainingCount");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NextHopChainingCount");
            e
        })
    }
}
// NextPagingAreaScope
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum NextPagingAreaScope {
    Same,
    Changed,
}

impl NextPagingAreaScope {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(1), true)?;
        if extended {
            return Err(PerCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(data, Some(0), Some(1), true, *self as i128, false)
    }
}

impl PerCodec for NextPagingAreaScope {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        NextPagingAreaScope::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NextPagingAreaScope");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NextPagingAreaScope");
            e
        })
    }
}
// NgEnbId
#[derive(Clone, Debug)]
pub enum NgEnbId {
    MacroNgEnbId(BitString),
    ShortMacroNgEnbId(BitString),
    LongMacroNgEnbId(BitString),
}

impl NgEnbId {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_choice_idx(data, 0, 3, false)?;
        if extended {
            return Err(PerCodecError::new("CHOICE additions not implemented"));
        }
        match idx {
            0 => Ok(Self::MacroNgEnbId(decode::decode_bitstring(
                data,
                Some(20),
                Some(20),
                false,
            )?)),
            1 => Ok(Self::ShortMacroNgEnbId(decode::decode_bitstring(
                data,
                Some(18),
                Some(18),
                false,
            )?)),
            2 => Ok(Self::LongMacroNgEnbId(decode::decode_bitstring(
                data,
                Some(21),
                Some(21),
                false,
            )?)),
            3 => {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _ = Criticality::decode(data)?;
                let _ = decode::decode_length_determinent(data, None, None, false)?;
                let result = match id {
                    x => Err(PerCodecError::new(format!("Unrecognised IE type {}", x))),
                };
                data.decode_align()?;
                result
            }
            _ => Err(PerCodecError::new("Unknown choice idx")),
        }
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        match self {
            Self::MacroNgEnbId(x) => {
                encode::encode_choice_idx(data, 0, 3, false, 0, false)?;
                encode::encode_bitstring(data, Some(20), Some(20), false, &x, false)
            }
            Self::ShortMacroNgEnbId(x) => {
                encode::encode_choice_idx(data, 0, 3, false, 1, false)?;
                encode::encode_bitstring(data, Some(18), Some(18), false, &x, false)
            }
            Self::LongMacroNgEnbId(x) => {
                encode::encode_choice_idx(data, 0, 3, false, 2, false)?;
                encode::encode_bitstring(data, Some(21), Some(21), false, &x, false)
            }
        }
    }
}

impl PerCodec for NgEnbId {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        NgEnbId::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NgEnbId");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NgEnbId");
            e
        })
    }
}
// NotifySourceNgranNode
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum NotifySourceNgranNode {
    NotifySource,
}

impl NotifySourceNgranNode {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(0), true)?;
        if extended {
            return Err(PerCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(data, Some(0), Some(0), true, *self as i128, false)
    }
}

impl PerCodec for NotifySourceNgranNode {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        NotifySourceNgranNode::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NotifySourceNgranNode");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NotifySourceNgranNode");
            e
        })
    }
}
// NgranCgi
#[derive(Clone, Debug)]
pub enum NgranCgi {
    NrCgi(NrCgi),
    EutraCgi(EutraCgi),
}

impl NgranCgi {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_choice_idx(data, 0, 2, false)?;
        if extended {
            return Err(PerCodecError::new("CHOICE additions not implemented"));
        }
        match idx {
            0 => Ok(Self::NrCgi(NrCgi::decode(data)?)),
            1 => Ok(Self::EutraCgi(EutraCgi::decode(data)?)),
            2 => {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _ = Criticality::decode(data)?;
                let _ = decode::decode_length_determinent(data, None, None, false)?;
                let result = match id {
                    x => Err(PerCodecError::new(format!("Unrecognised IE type {}", x))),
                };
                data.decode_align()?;
                result
            }
            _ => Err(PerCodecError::new("Unknown choice idx")),
        }
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        match self {
            Self::NrCgi(x) => {
                encode::encode_choice_idx(data, 0, 2, false, 0, false)?;
                x.encode(data)
            }
            Self::EutraCgi(x) => {
                encode::encode_choice_idx(data, 0, 2, false, 1, false)?;
                x.encode(data)
            }
        }
    }
}

impl PerCodec for NgranCgi {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        NgranCgi::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NgranCgi");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NgranCgi");
            e
        })
    }
}
// NgranTnlAssociationToRemoveList
#[derive(Clone, Debug)]
pub struct NgranTnlAssociationToRemoveList(pub NonEmpty<NgranTnlAssociationToRemoveItem>);

impl NgranTnlAssociationToRemoveList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(32), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(NgranTnlAssociationToRemoveItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(32), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for NgranTnlAssociationToRemoveList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        NgranTnlAssociationToRemoveList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NgranTnlAssociationToRemoveList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NgranTnlAssociationToRemoveList");
            e
        })
    }
}
// NgranTnlAssociationToRemoveItem
#[derive(Clone, Debug)]
pub struct NgranTnlAssociationToRemoveItem {
    pub tnl_association_transport_layer_address: CpTransportLayerInformation,
    pub tnl_association_transport_layer_address_amf: Option<CpTransportLayerInformation>,
}

impl NgranTnlAssociationToRemoveItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, false, 2)?;
        let tnl_association_transport_layer_address = CpTransportLayerInformation::decode(data)?;
        let tnl_association_transport_layer_address_amf = if optionals[0] {
            Some(CpTransportLayerInformation::decode(data)?)
        } else {
            None
        };

        // Process the extension container

        if optionals[1] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            tnl_association_transport_layer_address,
            tnl_association_transport_layer_address_amf,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.tnl_association_transport_layer_address_amf.is_some());
        optionals.push(false);

        encode::encode_sequence_header(data, false, &optionals, false)?;
        self.tnl_association_transport_layer_address.encode(data)?;
        if let Some(x) = &self.tnl_association_transport_layer_address_amf {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl PerCodec for NgranTnlAssociationToRemoveItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        NgranTnlAssociationToRemoveItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NgranTnlAssociationToRemoveItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NgranTnlAssociationToRemoveItem");
            e
        })
    }
}
// NgranTraceId
#[derive(Clone, Debug)]
pub struct NgranTraceId(pub [u8; 8]);

impl NgranTraceId {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(
            decode::decode_octetstring(data, Some(8), Some(8), false)?
                .try_into()
                .unwrap(),
        ))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_octetstring(data, Some(8), Some(8), false, &(self.0).into(), false)
    }
}

impl PerCodec for NgranTraceId {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        NgranTraceId::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NgranTraceId");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NgranTraceId");
            e
        })
    }
}
// Nid
#[derive(Clone, Debug)]
pub struct Nid(pub BitString);

impl Nid {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(decode::decode_bitstring(
            data,
            Some(44),
            Some(44),
            false,
        )?))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_bitstring(data, Some(44), Some(44), false, &self.0, false)
    }
}

impl PerCodec for Nid {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Nid::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("Nid");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("Nid");
            e
        })
    }
}
// NonDynamic5qiDescriptor
#[derive(Clone, Debug)]
pub struct NonDynamic5qiDescriptor {
    pub five_qi: FiveQi,
    pub priority_level_qos: Option<PriorityLevelQos>,
    pub averaging_window: Option<AveragingWindow>,
    pub maximum_data_burst_volume: Option<MaximumDataBurstVolume>,
    pub cn_packet_delay_budget_dl: Option<ExtendedPacketDelayBudget>,
    pub cn_packet_delay_budget_ul: Option<ExtendedPacketDelayBudget>,
}

impl NonDynamic5qiDescriptor {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 4)?;
        let five_qi = FiveQi::decode(data)?;
        let priority_level_qos = if optionals[0] {
            Some(PriorityLevelQos::decode(data)?)
        } else {
            None
        };
        let averaging_window = if optionals[1] {
            Some(AveragingWindow::decode(data)?)
        } else {
            None
        };
        let maximum_data_burst_volume = if optionals[2] {
            Some(MaximumDataBurstVolume::decode(data)?)
        } else {
            None
        };

        // Process the extension container
        let mut cn_packet_delay_budget_dl: Option<ExtendedPacketDelayBudget> = None;
        let mut cn_packet_delay_budget_ul: Option<ExtendedPacketDelayBudget> = None;

        if optionals[3] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    187 => {
                        cn_packet_delay_budget_dl = Some(ExtendedPacketDelayBudget::decode(data)?)
                    }
                    188 => {
                        cn_packet_delay_budget_ul = Some(ExtendedPacketDelayBudget::decode(data)?)
                    }
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            five_qi,
            priority_level_qos,
            averaging_window,
            maximum_data_burst_volume,
            cn_packet_delay_budget_dl,
            cn_packet_delay_budget_ul,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();
        if let Some(x) = &self.cn_packet_delay_budget_dl {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 187, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.cn_packet_delay_budget_ul {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 188, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        let mut optionals = BitString::new();
        optionals.push(self.priority_level_qos.is_some());
        optionals.push(self.averaging_window.is_some());
        optionals.push(self.maximum_data_burst_volume.is_some());
        optionals.push(num_ies != 0);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.five_qi.encode(data)?;
        if let Some(x) = &self.priority_level_qos {
            x.encode(data)?;
        }
        if let Some(x) = &self.averaging_window {
            x.encode(data)?;
        }
        if let Some(x) = &self.maximum_data_burst_volume {
            x.encode(data)?;
        }
        if num_ies != 0 {
            encode::encode_length_determinent(data, Some(1), Some(65535), false, num_ies)?;
            data.append_aligned(ies);
        }
        Ok(())
    }
}

impl PerCodec for NonDynamic5qiDescriptor {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        NonDynamic5qiDescriptor::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NonDynamic5qiDescriptor");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NonDynamic5qiDescriptor");
            e
        })
    }
}
// NotAllowedTaCs
#[derive(Clone, Debug)]
pub struct NotAllowedTaCs(pub NonEmpty<Tac>);

impl NotAllowedTaCs {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(16), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(Tac::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(16), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for NotAllowedTaCs {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        NotAllowedTaCs::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NotAllowedTaCs");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NotAllowedTaCs");
            e
        })
    }
}
// NotificationCause
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum NotificationCause {
    Fulfilled,
    NotFulfilled,
}

impl NotificationCause {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(1), true)?;
        if extended {
            return Err(PerCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(data, Some(0), Some(1), true, *self as i128, false)
    }
}

impl PerCodec for NotificationCause {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        NotificationCause::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NotificationCause");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NotificationCause");
            e
        })
    }
}
// NotificationControl
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum NotificationControl {
    NotificationRequested,
}

impl NotificationControl {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(0), true)?;
        if extended {
            return Err(PerCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(data, Some(0), Some(0), true, *self as i128, false)
    }
}

impl PerCodec for NotificationControl {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        NotificationControl::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NotificationControl");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NotificationControl");
            e
        })
    }
}
// NpnAccessInformation
#[derive(Clone, Debug)]
pub enum NpnAccessInformation {
    PniNpnAccessInformation(CellCagList),
}

impl NpnAccessInformation {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_choice_idx(data, 0, 1, false)?;
        if extended {
            return Err(PerCodecError::new("CHOICE additions not implemented"));
        }
        match idx {
            0 => Ok(Self::PniNpnAccessInformation(CellCagList::decode(data)?)),
            1 => {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _ = Criticality::decode(data)?;
                let _ = decode::decode_length_determinent(data, None, None, false)?;
                let result = match id {
                    x => Err(PerCodecError::new(format!("Unrecognised IE type {}", x))),
                };
                data.decode_align()?;
                result
            }
            _ => Err(PerCodecError::new("Unknown choice idx")),
        }
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        match self {
            Self::PniNpnAccessInformation(x) => {
                encode::encode_choice_idx(data, 0, 1, false, 0, false)?;
                x.encode(data)
            }
        }
    }
}

impl PerCodec for NpnAccessInformation {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        NpnAccessInformation::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NpnAccessInformation");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NpnAccessInformation");
            e
        })
    }
}
// NpnMobilityInformation
#[derive(Clone, Debug)]
pub enum NpnMobilityInformation {
    SnpnMobilityInformation(SnpnMobilityInformation),
    PniNpnMobilityInformation(PniNpnMobilityInformation),
}

impl NpnMobilityInformation {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_choice_idx(data, 0, 2, false)?;
        if extended {
            return Err(PerCodecError::new("CHOICE additions not implemented"));
        }
        match idx {
            0 => Ok(Self::SnpnMobilityInformation(
                SnpnMobilityInformation::decode(data)?,
            )),
            1 => Ok(Self::PniNpnMobilityInformation(
                PniNpnMobilityInformation::decode(data)?,
            )),
            2 => {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _ = Criticality::decode(data)?;
                let _ = decode::decode_length_determinent(data, None, None, false)?;
                let result = match id {
                    x => Err(PerCodecError::new(format!("Unrecognised IE type {}", x))),
                };
                data.decode_align()?;
                result
            }
            _ => Err(PerCodecError::new("Unknown choice idx")),
        }
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        match self {
            Self::SnpnMobilityInformation(x) => {
                encode::encode_choice_idx(data, 0, 2, false, 0, false)?;
                x.encode(data)
            }
            Self::PniNpnMobilityInformation(x) => {
                encode::encode_choice_idx(data, 0, 2, false, 1, false)?;
                x.encode(data)
            }
        }
    }
}

impl PerCodec for NpnMobilityInformation {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        NpnMobilityInformation::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NpnMobilityInformation");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NpnMobilityInformation");
            e
        })
    }
}
// NpnPagingAssistanceInformation
#[derive(Clone, Debug)]
pub enum NpnPagingAssistanceInformation {
    PniNpnPagingAssistance(AllowedPniNpnList),
}

impl NpnPagingAssistanceInformation {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_choice_idx(data, 0, 1, false)?;
        if extended {
            return Err(PerCodecError::new("CHOICE additions not implemented"));
        }
        match idx {
            0 => Ok(Self::PniNpnPagingAssistance(AllowedPniNpnList::decode(
                data,
            )?)),
            1 => {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _ = Criticality::decode(data)?;
                let _ = decode::decode_length_determinent(data, None, None, false)?;
                let result = match id {
                    x => Err(PerCodecError::new(format!("Unrecognised IE type {}", x))),
                };
                data.decode_align()?;
                result
            }
            _ => Err(PerCodecError::new("Unknown choice idx")),
        }
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        match self {
            Self::PniNpnPagingAssistance(x) => {
                encode::encode_choice_idx(data, 0, 1, false, 0, false)?;
                x.encode(data)
            }
        }
    }
}

impl PerCodec for NpnPagingAssistanceInformation {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        NpnPagingAssistanceInformation::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NpnPagingAssistanceInformation");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NpnPagingAssistanceInformation");
            e
        })
    }
}
// NpnSupport
#[derive(Clone, Debug)]
pub enum NpnSupport {
    Snpn(Nid),
}

impl NpnSupport {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_choice_idx(data, 0, 1, false)?;
        if extended {
            return Err(PerCodecError::new("CHOICE additions not implemented"));
        }
        match idx {
            0 => Ok(Self::Snpn(Nid::decode(data)?)),
            1 => {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _ = Criticality::decode(data)?;
                let _ = decode::decode_length_determinent(data, None, None, false)?;
                let result = match id {
                    x => Err(PerCodecError::new(format!("Unrecognised IE type {}", x))),
                };
                data.decode_align()?;
                result
            }
            _ => Err(PerCodecError::new("Unknown choice idx")),
        }
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        match self {
            Self::Snpn(x) => {
                encode::encode_choice_idx(data, 0, 1, false, 0, false)?;
                x.encode(data)
            }
        }
    }
}

impl PerCodec for NpnSupport {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        NpnSupport::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NpnSupport");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NpnSupport");
            e
        })
    }
}
// NrCellIdentity
#[derive(Clone, Debug)]
pub struct NrCellIdentity(pub BitString);

impl NrCellIdentity {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(decode::decode_bitstring(
            data,
            Some(36),
            Some(36),
            false,
        )?))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_bitstring(data, Some(36), Some(36), false, &self.0, false)
    }
}

impl PerCodec for NrCellIdentity {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        NrCellIdentity::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NrCellIdentity");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NrCellIdentity");
            e
        })
    }
}
// NrCgi
#[derive(Clone, Debug)]
pub struct NrCgi {
    pub plmn_identity: PlmnIdentity,
    pub nr_cell_identity: NrCellIdentity,
}

impl NrCgi {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let plmn_identity = PlmnIdentity::decode(data)?;
        let nr_cell_identity = NrCellIdentity::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            plmn_identity,
            nr_cell_identity,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.plmn_identity.encode(data)?;
        self.nr_cell_identity.encode(data)?;

        Ok(())
    }
}

impl PerCodec for NrCgi {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        NrCgi::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NrCgi");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NrCgi");
            e
        })
    }
}
// NrCgiList
#[derive(Clone, Debug)]
pub struct NrCgiList(pub NonEmpty<NrCgi>);

impl NrCgiList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(16384), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(NrCgi::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(16384), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for NrCgiList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        NrCgiList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NrCgiList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NrCgiList");
            e
        })
    }
}
// NrCgiListForWarning
#[derive(Clone, Debug)]
pub struct NrCgiListForWarning(pub NonEmpty<NrCgi>);

impl NrCgiListForWarning {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(NrCgi::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(65535), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for NrCgiListForWarning {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        NrCgiListForWarning::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NrCgiListForWarning");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NrCgiListForWarning");
            e
        })
    }
}
// NrEncryptionAlgorithms
#[derive(Clone, Debug)]
pub struct NrEncryptionAlgorithms(pub BitString);

impl NrEncryptionAlgorithms {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(decode::decode_bitstring(
            data,
            Some(16),
            Some(16),
            true,
        )?))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_bitstring(data, Some(16), Some(16), true, &self.0, false)
    }
}

impl PerCodec for NrEncryptionAlgorithms {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        NrEncryptionAlgorithms::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NrEncryptionAlgorithms");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NrEncryptionAlgorithms");
            e
        })
    }
}
// NrIntegrityProtectionAlgorithms
#[derive(Clone, Debug)]
pub struct NrIntegrityProtectionAlgorithms(pub BitString);

impl NrIntegrityProtectionAlgorithms {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(decode::decode_bitstring(
            data,
            Some(16),
            Some(16),
            true,
        )?))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_bitstring(data, Some(16), Some(16), true, &self.0, false)
    }
}

impl PerCodec for NrIntegrityProtectionAlgorithms {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        NrIntegrityProtectionAlgorithms::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NrIntegrityProtectionAlgorithms");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NrIntegrityProtectionAlgorithms");
            e
        })
    }
}
// NrMobilityHistoryReport
#[derive(Clone, Debug)]
pub struct NrMobilityHistoryReport(pub Vec<u8>);

impl NrMobilityHistoryReport {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(decode::decode_octetstring(data, None, None, false)?))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_octetstring(data, None, None, false, &self.0, false)
    }
}

impl PerCodec for NrMobilityHistoryReport {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        NrMobilityHistoryReport::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NrMobilityHistoryReport");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NrMobilityHistoryReport");
            e
        })
    }
}
// NrPPaPdu
#[derive(Clone, Debug)]
pub struct NrPPaPdu(pub Vec<u8>);

impl NrPPaPdu {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(decode::decode_octetstring(data, None, None, false)?))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_octetstring(data, None, None, false, &self.0, false)
    }
}

impl PerCodec for NrPPaPdu {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        NrPPaPdu::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NrPPaPdu");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NrPPaPdu");
            e
        })
    }
}
// NrUeRlfReportContainer
#[derive(Clone, Debug)]
pub struct NrUeRlfReportContainer(pub Vec<u8>);

impl NrUeRlfReportContainer {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(decode::decode_octetstring(data, None, None, false)?))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_octetstring(data, None, None, false, &self.0, false)
    }
}

impl PerCodec for NrUeRlfReportContainer {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        NrUeRlfReportContainer::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NrUeRlfReportContainer");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NrUeRlfReportContainer");
            e
        })
    }
}
// NumberOfBroadcasts
#[derive(Clone, Copy, Debug)]
pub struct NumberOfBroadcasts(pub u16);

impl NumberOfBroadcasts {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(
            decode::decode_integer(data, Some(0), Some(65535), false)?.0 as u16,
        ))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_integer(data, Some(0), Some(65535), false, self.0 as i128, false)
    }
}

impl PerCodec for NumberOfBroadcasts {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        NumberOfBroadcasts::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NumberOfBroadcasts");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NumberOfBroadcasts");
            e
        })
    }
}
// NumberOfBroadcastsRequested
#[derive(Clone, Copy, Debug)]
pub struct NumberOfBroadcastsRequested(pub u16);

impl NumberOfBroadcastsRequested {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(
            decode::decode_integer(data, Some(0), Some(65535), false)?.0 as u16,
        ))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_integer(data, Some(0), Some(65535), false, self.0 as i128, false)
    }
}

impl PerCodec for NumberOfBroadcastsRequested {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        NumberOfBroadcastsRequested::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NumberOfBroadcastsRequested");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NumberOfBroadcastsRequested");
            e
        })
    }
}
// NrArfcn
#[derive(Clone, Copy, Debug)]
pub struct NrArfcn(pub u32);

impl NrArfcn {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(
            decode::decode_integer(data, Some(0), Some(3279165), false)?.0 as u32,
        ))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_integer(data, Some(0), Some(3279165), false, self.0 as i128, false)
    }
}

impl PerCodec for NrArfcn {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        NrArfcn::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NrArfcn");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NrArfcn");
            e
        })
    }
}
// NrFrequencyBand
#[derive(Clone, Copy, Debug)]
pub struct NrFrequencyBand(pub u16);

impl NrFrequencyBand {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(
            decode::decode_integer(data, Some(1), Some(1024), true)?.0 as u16,
        ))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_integer(data, Some(1), Some(1024), true, self.0 as i128, false)
    }
}

impl PerCodec for NrFrequencyBand {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        NrFrequencyBand::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NrFrequencyBand");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NrFrequencyBand");
            e
        })
    }
}
// NrFrequencyBandList
#[derive(Clone, Debug)]
pub struct NrFrequencyBandList(pub NonEmpty<NrFrequencyBandItem>);

impl NrFrequencyBandList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(32), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(NrFrequencyBandItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(32), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for NrFrequencyBandList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        NrFrequencyBandList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NrFrequencyBandList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NrFrequencyBandList");
            e
        })
    }
}
// NrFrequencyBandItem
#[derive(Clone, Debug)]
pub struct NrFrequencyBandItem {
    pub nr_frequency_band: NrFrequencyBand,
}

impl NrFrequencyBandItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let nr_frequency_band = NrFrequencyBand::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self { nr_frequency_band })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.nr_frequency_band.encode(data)?;

        Ok(())
    }
}

impl PerCodec for NrFrequencyBandItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        NrFrequencyBandItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NrFrequencyBandItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NrFrequencyBandItem");
            e
        })
    }
}
// NrFrequencyInfo
#[derive(Clone, Debug)]
pub struct NrFrequencyInfo {
    pub nr_arfcn: NrArfcn,
    pub frequency_band_list: NrFrequencyBandList,
}

impl NrFrequencyInfo {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let nr_arfcn = NrArfcn::decode(data)?;
        let frequency_band_list = NrFrequencyBandList::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            nr_arfcn,
            frequency_band_list,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.nr_arfcn.encode(data)?;
        self.frequency_band_list.encode(data)?;

        Ok(())
    }
}

impl PerCodec for NrFrequencyInfo {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        NrFrequencyInfo::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NrFrequencyInfo");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NrFrequencyInfo");
            e
        })
    }
}
// NrPci
#[derive(Clone, Copy, Debug)]
pub struct NrPci(pub u16);

impl NrPci {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(
            decode::decode_integer(data, Some(0), Some(1007), true)?.0 as u16,
        ))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_integer(data, Some(0), Some(1007), true, self.0 as i128, false)
    }
}

impl PerCodec for NrPci {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        NrPci::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NrPci");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NrPci");
            e
        })
    }
}
// NrV2xServicesAuthorized
#[derive(Clone, Debug)]
pub struct NrV2xServicesAuthorized {
    pub vehicle_ue: Option<VehicleUe>,
    pub pedestrian_ue: Option<PedestrianUe>,
}

impl NrV2xServicesAuthorized {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 3)?;
        let vehicle_ue = if optionals[0] {
            Some(VehicleUe::decode(data)?)
        } else {
            None
        };
        let pedestrian_ue = if optionals[1] {
            Some(PedestrianUe::decode(data)?)
        } else {
            None
        };

        // Process the extension container

        if optionals[2] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            vehicle_ue,
            pedestrian_ue,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.vehicle_ue.is_some());
        optionals.push(self.pedestrian_ue.is_some());
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        if let Some(x) = &self.vehicle_ue {
            x.encode(data)?;
        }
        if let Some(x) = &self.pedestrian_ue {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl PerCodec for NrV2xServicesAuthorized {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        NrV2xServicesAuthorized::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NrV2xServicesAuthorized");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NrV2xServicesAuthorized");
            e
        })
    }
}
// VehicleUe
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum VehicleUe {
    Authorized,
    NotAuthorized,
}

impl VehicleUe {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(1), true)?;
        if extended {
            return Err(PerCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(data, Some(0), Some(1), true, *self as i128, false)
    }
}

impl PerCodec for VehicleUe {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        VehicleUe::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("VehicleUe");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("VehicleUe");
            e
        })
    }
}
// PedestrianUe
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum PedestrianUe {
    Authorized,
    NotAuthorized,
}

impl PedestrianUe {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(1), true)?;
        if extended {
            return Err(PerCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(data, Some(0), Some(1), true, *self as i128, false)
    }
}

impl PerCodec for PedestrianUe {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PedestrianUe::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PedestrianUe");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PedestrianUe");
            e
        })
    }
}
// NrUeSidelinkAggregateMaximumBitrate
#[derive(Clone, Debug)]
pub struct NrUeSidelinkAggregateMaximumBitrate {
    pub ue_sidelink_aggregate_maximum_bit_rate: BitRate,
}

impl NrUeSidelinkAggregateMaximumBitrate {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let ue_sidelink_aggregate_maximum_bit_rate = BitRate::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            ue_sidelink_aggregate_maximum_bit_rate,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.ue_sidelink_aggregate_maximum_bit_rate.encode(data)?;

        Ok(())
    }
}

impl PerCodec for NrUeSidelinkAggregateMaximumBitrate {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        NrUeSidelinkAggregateMaximumBitrate::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NrUeSidelinkAggregateMaximumBitrate");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NrUeSidelinkAggregateMaximumBitrate");
            e
        })
    }
}
// OverloadAction
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum OverloadAction {
    RejectNonEmergencyMoDt,
    RejectRrcCrSignalling,
    PermitEmergencySessionsAndMobileTerminatedServicesOnly,
    PermitHighPrioritySessionsAndMobileTerminatedServicesOnly,
}

impl OverloadAction {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(3), true)?;
        if extended {
            return Err(PerCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(data, Some(0), Some(3), true, *self as i128, false)
    }
}

impl PerCodec for OverloadAction {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        OverloadAction::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("OverloadAction");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("OverloadAction");
            e
        })
    }
}
// OverloadResponse
#[derive(Clone, Debug)]
pub enum OverloadResponse {
    OverloadAction(OverloadAction),
}

impl OverloadResponse {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_choice_idx(data, 0, 1, false)?;
        if extended {
            return Err(PerCodecError::new("CHOICE additions not implemented"));
        }
        match idx {
            0 => Ok(Self::OverloadAction(OverloadAction::decode(data)?)),
            1 => {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _ = Criticality::decode(data)?;
                let _ = decode::decode_length_determinent(data, None, None, false)?;
                let result = match id {
                    x => Err(PerCodecError::new(format!("Unrecognised IE type {}", x))),
                };
                data.decode_align()?;
                result
            }
            _ => Err(PerCodecError::new("Unknown choice idx")),
        }
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        match self {
            Self::OverloadAction(x) => {
                encode::encode_choice_idx(data, 0, 1, false, 0, false)?;
                x.encode(data)
            }
        }
    }
}

impl PerCodec for OverloadResponse {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        OverloadResponse::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("OverloadResponse");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("OverloadResponse");
            e
        })
    }
}
// OverloadStartNssaiList
#[derive(Clone, Debug)]
pub struct OverloadStartNssaiList(pub NonEmpty<OverloadStartNssaiItem>);

impl OverloadStartNssaiList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(1024), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(OverloadStartNssaiItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(1024), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for OverloadStartNssaiList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        OverloadStartNssaiList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("OverloadStartNssaiList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("OverloadStartNssaiList");
            e
        })
    }
}
// OverloadStartNssaiItem
#[derive(Clone, Debug)]
pub struct OverloadStartNssaiItem {
    pub slice_overload_list: SliceOverloadList,
    pub slice_overload_response: Option<OverloadResponse>,
    pub slice_traffic_load_reduction_indication: Option<TrafficLoadReductionIndication>,
}

impl OverloadStartNssaiItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 3)?;
        let slice_overload_list = SliceOverloadList::decode(data)?;
        let slice_overload_response = if optionals[0] {
            Some(OverloadResponse::decode(data)?)
        } else {
            None
        };
        let slice_traffic_load_reduction_indication = if optionals[1] {
            Some(TrafficLoadReductionIndication::decode(data)?)
        } else {
            None
        };

        // Process the extension container

        if optionals[2] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            slice_overload_list,
            slice_overload_response,
            slice_traffic_load_reduction_indication,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.slice_overload_response.is_some());
        optionals.push(self.slice_traffic_load_reduction_indication.is_some());
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.slice_overload_list.encode(data)?;
        if let Some(x) = &self.slice_overload_response {
            x.encode(data)?;
        }
        if let Some(x) = &self.slice_traffic_load_reduction_indication {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl PerCodec for OverloadStartNssaiItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        OverloadStartNssaiItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("OverloadStartNssaiItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("OverloadStartNssaiItem");
            e
        })
    }
}
// PacketDelayBudget
#[derive(Clone, Copy, Debug)]
pub struct PacketDelayBudget(pub u16);

impl PacketDelayBudget {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(
            decode::decode_integer(data, Some(0), Some(1023), true)?.0 as u16,
        ))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_integer(data, Some(0), Some(1023), true, self.0 as i128, false)
    }
}

impl PerCodec for PacketDelayBudget {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PacketDelayBudget::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PacketDelayBudget");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PacketDelayBudget");
            e
        })
    }
}
// PacketErrorRate
#[derive(Clone, Debug)]
pub struct PacketErrorRate {
    pub per_scalar: u8,
    pub per_exponent: u8,
}

impl PacketErrorRate {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let per_scalar = decode::decode_integer(data, Some(0), Some(9), true)?.0 as u8;
        let per_exponent = decode::decode_integer(data, Some(0), Some(9), true)?.0 as u8;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            per_scalar,
            per_exponent,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        encode::encode_integer(data, Some(0), Some(9), true, self.per_scalar as i128, false)?;
        encode::encode_integer(
            data,
            Some(0),
            Some(9),
            true,
            self.per_exponent as i128,
            false,
        )?;

        Ok(())
    }
}

impl PerCodec for PacketErrorRate {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PacketErrorRate::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PacketErrorRate");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PacketErrorRate");
            e
        })
    }
}
// PacketLossRate
#[derive(Clone, Copy, Debug)]
pub struct PacketLossRate(pub u16);

impl PacketLossRate {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(
            decode::decode_integer(data, Some(0), Some(1000), true)?.0 as u16,
        ))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_integer(data, Some(0), Some(1000), true, self.0 as i128, false)
    }
}

impl PerCodec for PacketLossRate {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PacketLossRate::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PacketLossRate");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PacketLossRate");
            e
        })
    }
}
// PagingAssisDataforCEcapabUe
#[derive(Clone, Debug)]
pub struct PagingAssisDataforCEcapabUe {
    pub eutra_cgi: EutraCgi,
    pub coverage_enhancement_level: CoverageEnhancementLevel,
}

impl PagingAssisDataforCEcapabUe {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let eutra_cgi = EutraCgi::decode(data)?;
        let coverage_enhancement_level = CoverageEnhancementLevel::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            eutra_cgi,
            coverage_enhancement_level,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.eutra_cgi.encode(data)?;
        self.coverage_enhancement_level.encode(data)?;

        Ok(())
    }
}

impl PerCodec for PagingAssisDataforCEcapabUe {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PagingAssisDataforCEcapabUe::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PagingAssisDataforCEcapabUe");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PagingAssisDataforCEcapabUe");
            e
        })
    }
}
// PagingAttemptInformation
#[derive(Clone, Debug)]
pub struct PagingAttemptInformation {
    pub paging_attempt_count: PagingAttemptCount,
    pub intended_number_of_paging_attempts: IntendedNumberOfPagingAttempts,
    pub next_paging_area_scope: Option<NextPagingAreaScope>,
}

impl PagingAttemptInformation {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 2)?;
        let paging_attempt_count = PagingAttemptCount::decode(data)?;
        let intended_number_of_paging_attempts = IntendedNumberOfPagingAttempts::decode(data)?;
        let next_paging_area_scope = if optionals[0] {
            Some(NextPagingAreaScope::decode(data)?)
        } else {
            None
        };

        // Process the extension container

        if optionals[1] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            paging_attempt_count,
            intended_number_of_paging_attempts,
            next_paging_area_scope,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.next_paging_area_scope.is_some());
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.paging_attempt_count.encode(data)?;
        self.intended_number_of_paging_attempts.encode(data)?;
        if let Some(x) = &self.next_paging_area_scope {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl PerCodec for PagingAttemptInformation {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PagingAttemptInformation::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PagingAttemptInformation");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PagingAttemptInformation");
            e
        })
    }
}
// PagingAttemptCount
#[derive(Clone, Copy, Debug)]
pub struct PagingAttemptCount(pub u8);

impl PagingAttemptCount {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(
            decode::decode_integer(data, Some(1), Some(16), true)?.0 as u8,
        ))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_integer(data, Some(1), Some(16), true, self.0 as i128, false)
    }
}

impl PerCodec for PagingAttemptCount {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PagingAttemptCount::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PagingAttemptCount");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PagingAttemptCount");
            e
        })
    }
}
// PagingDrx
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum PagingDrx {
    V32,
    V64,
    V128,
    V256,
}

impl PagingDrx {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(3), true)?;
        if extended {
            return Err(PerCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(data, Some(0), Some(3), true, *self as i128, false)
    }
}

impl PerCodec for PagingDrx {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PagingDrx::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PagingDrx");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PagingDrx");
            e
        })
    }
}
// PagingOrigin
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum PagingOrigin {
    Non3gpp,
}

impl PagingOrigin {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(0), true)?;
        if extended {
            return Err(PerCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(data, Some(0), Some(0), true, *self as i128, false)
    }
}

impl PerCodec for PagingOrigin {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PagingOrigin::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PagingOrigin");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PagingOrigin");
            e
        })
    }
}
// PagingPriority
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum PagingPriority {
    Priolevel1,
    Priolevel2,
    Priolevel3,
    Priolevel4,
    Priolevel5,
    Priolevel6,
    Priolevel7,
    Priolevel8,
}

impl PagingPriority {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(7), true)?;
        if extended {
            return Err(PerCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(data, Some(0), Some(7), true, *self as i128, false)
    }
}

impl PerCodec for PagingPriority {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PagingPriority::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PagingPriority");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PagingPriority");
            e
        })
    }
}
// PagingeDrxInformation
#[derive(Clone, Debug)]
pub struct PagingeDrxInformation {
    pub paging_e_drx_cycle: PagingEDrxCycle,
    pub paging_time_window: Option<PagingTimeWindow>,
}

impl PagingeDrxInformation {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 2)?;
        let paging_e_drx_cycle = PagingEDrxCycle::decode(data)?;
        let paging_time_window = if optionals[0] {
            Some(PagingTimeWindow::decode(data)?)
        } else {
            None
        };

        // Process the extension container

        if optionals[1] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            paging_e_drx_cycle,
            paging_time_window,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.paging_time_window.is_some());
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.paging_e_drx_cycle.encode(data)?;
        if let Some(x) = &self.paging_time_window {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl PerCodec for PagingeDrxInformation {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PagingeDrxInformation::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PagingeDrxInformation");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PagingeDrxInformation");
            e
        })
    }
}
// PagingEDrxCycle
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum PagingEDrxCycle {
    Hfhalf,
    Hf1,
    Hf2,
    Hf4,
    Hf6,
    Hf8,
    Hf10,
    Hf12,
    Hf14,
    Hf16,
    Hf32,
    Hf64,
    Hf128,
    Hf256,
}

impl PagingEDrxCycle {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(13), true)?;
        if extended {
            return Err(PerCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(data, Some(0), Some(13), true, *self as i128, false)
    }
}

impl PerCodec for PagingEDrxCycle {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PagingEDrxCycle::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PagingEDrxCycle");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PagingEDrxCycle");
            e
        })
    }
}
// PagingTimeWindow
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum PagingTimeWindow {
    S1,
    S2,
    S3,
    S4,
    S5,
    S6,
    S7,
    S8,
    S9,
    S10,
    S11,
    S12,
    S13,
    S14,
    S15,
    S16,
}

impl PagingTimeWindow {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(15), true)?;
        if extended {
            return Err(PerCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(data, Some(0), Some(15), true, *self as i128, false)
    }
}

impl PerCodec for PagingTimeWindow {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PagingTimeWindow::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PagingTimeWindow");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PagingTimeWindow");
            e
        })
    }
}
// PagingProbabilityInformation
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum PagingProbabilityInformation {
    P00,
    P05,
    P10,
    P15,
    P20,
    P25,
    P30,
    P35,
    P40,
    P45,
    P50,
    P55,
    P60,
    P65,
    P70,
    P75,
    P80,
    P85,
    P90,
    P95,
    P100,
}

impl PagingProbabilityInformation {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(20), true)?;
        if extended {
            return Err(PerCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(data, Some(0), Some(20), true, *self as i128, false)
    }
}

impl PerCodec for PagingProbabilityInformation {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PagingProbabilityInformation::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PagingProbabilityInformation");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PagingProbabilityInformation");
            e
        })
    }
}
// PathSwitchRequestAcknowledgeTransfer
#[derive(Clone, Debug)]
pub struct PathSwitchRequestAcknowledgeTransfer {
    pub ul_ngu_up_tnl_information: Option<UpTransportLayerInformation>,
    pub security_indication: Option<SecurityIndication>,
    pub additional_ngu_up_tnl_information: Option<UpTransportLayerInformationPairList>,
    pub redundant_ul_ngu_up_tnl_information: Option<UpTransportLayerInformation>,
    pub additional_redundant_ngu_up_tnl_information: Option<UpTransportLayerInformationPairList>,
    pub qos_flow_parameters_list: Option<QosFlowParametersList>,
}

impl PathSwitchRequestAcknowledgeTransfer {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 3)?;
        let ul_ngu_up_tnl_information = if optionals[0] {
            Some(UpTransportLayerInformation::decode(data)?)
        } else {
            None
        };
        let security_indication = if optionals[1] {
            Some(SecurityIndication::decode(data)?)
        } else {
            None
        };

        // Process the extension container
        let mut additional_ngu_up_tnl_information: Option<UpTransportLayerInformationPairList> =
            None;
        let mut redundant_ul_ngu_up_tnl_information: Option<UpTransportLayerInformation> = None;
        let mut additional_redundant_ngu_up_tnl_information: Option<
            UpTransportLayerInformationPairList,
        > = None;
        let mut qos_flow_parameters_list: Option<QosFlowParametersList> = None;

        if optionals[2] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    154 => {
                        additional_ngu_up_tnl_information =
                            Some(UpTransportLayerInformationPairList::decode(data)?)
                    }
                    195 => {
                        redundant_ul_ngu_up_tnl_information =
                            Some(UpTransportLayerInformation::decode(data)?)
                    }
                    185 => {
                        additional_redundant_ngu_up_tnl_information =
                            Some(UpTransportLayerInformationPairList::decode(data)?)
                    }
                    277 => qos_flow_parameters_list = Some(QosFlowParametersList::decode(data)?),
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            ul_ngu_up_tnl_information,
            security_indication,
            additional_ngu_up_tnl_information,
            redundant_ul_ngu_up_tnl_information,
            additional_redundant_ngu_up_tnl_information,
            qos_flow_parameters_list,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();
        if let Some(x) = &self.additional_ngu_up_tnl_information {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 154, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.redundant_ul_ngu_up_tnl_information {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 195, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.additional_redundant_ngu_up_tnl_information {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 185, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.qos_flow_parameters_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 277, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        let mut optionals = BitString::new();
        optionals.push(self.ul_ngu_up_tnl_information.is_some());
        optionals.push(self.security_indication.is_some());
        optionals.push(num_ies != 0);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        if let Some(x) = &self.ul_ngu_up_tnl_information {
            x.encode(data)?;
        }
        if let Some(x) = &self.security_indication {
            x.encode(data)?;
        }
        if num_ies != 0 {
            encode::encode_length_determinent(data, Some(1), Some(65535), false, num_ies)?;
            data.append_aligned(ies);
        }
        Ok(())
    }
}

impl PerCodec for PathSwitchRequestAcknowledgeTransfer {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PathSwitchRequestAcknowledgeTransfer::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PathSwitchRequestAcknowledgeTransfer");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PathSwitchRequestAcknowledgeTransfer");
            e
        })
    }
}
// PathSwitchRequestSetupFailedTransfer
#[derive(Clone, Debug)]
pub struct PathSwitchRequestSetupFailedTransfer {
    pub cause: Cause,
}

impl PathSwitchRequestSetupFailedTransfer {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let cause = Cause::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self { cause })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.cause.encode(data)?;

        Ok(())
    }
}

impl PerCodec for PathSwitchRequestSetupFailedTransfer {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PathSwitchRequestSetupFailedTransfer::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PathSwitchRequestSetupFailedTransfer");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PathSwitchRequestSetupFailedTransfer");
            e
        })
    }
}
// PathSwitchRequestTransfer
#[derive(Clone, Debug)]
pub struct PathSwitchRequestTransfer {
    pub dl_ngu_up_tnl_information: UpTransportLayerInformation,
    pub dl_ngu_tnl_information_reused: Option<DlNguTnlInformationReused>,
    pub user_plane_security_information: Option<UserPlaneSecurityInformation>,
    pub qos_flow_accepted_list: QosFlowAcceptedList,
    pub additional_dl_qos_flow_per_tnl_information: Option<QosFlowPerTnlInformationList>,
    pub redundant_dl_ngu_up_tnl_information: Option<UpTransportLayerInformation>,
    pub redundant_dl_ngu_tnl_information_reused: Option<DlNguTnlInformationReused>,
    pub additional_redundant_dl_qos_flow_per_tnl_information: Option<QosFlowPerTnlInformationList>,
    pub used_rsn_information: Option<RedundantPduSessionInformation>,
    pub global_ran_node_id: Option<GlobalRanNodeId>,
}

impl PathSwitchRequestTransfer {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 3)?;
        let dl_ngu_up_tnl_information = UpTransportLayerInformation::decode(data)?;
        let dl_ngu_tnl_information_reused = if optionals[0] {
            Some(DlNguTnlInformationReused::decode(data)?)
        } else {
            None
        };
        let user_plane_security_information = if optionals[1] {
            Some(UserPlaneSecurityInformation::decode(data)?)
        } else {
            None
        };
        let qos_flow_accepted_list = QosFlowAcceptedList::decode(data)?;

        // Process the extension container
        let mut additional_dl_qos_flow_per_tnl_information: Option<QosFlowPerTnlInformationList> =
            None;
        let mut redundant_dl_ngu_up_tnl_information: Option<UpTransportLayerInformation> = None;
        let mut redundant_dl_ngu_tnl_information_reused: Option<DlNguTnlInformationReused> = None;
        let mut additional_redundant_dl_qos_flow_per_tnl_information: Option<
            QosFlowPerTnlInformationList,
        > = None;
        let mut used_rsn_information: Option<RedundantPduSessionInformation> = None;
        let mut global_ran_node_id: Option<GlobalRanNodeId> = None;

        if optionals[2] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    155 => {
                        additional_dl_qos_flow_per_tnl_information =
                            Some(QosFlowPerTnlInformationList::decode(data)?)
                    }
                    192 => {
                        redundant_dl_ngu_up_tnl_information =
                            Some(UpTransportLayerInformation::decode(data)?)
                    }
                    191 => {
                        redundant_dl_ngu_tnl_information_reused =
                            Some(DlNguTnlInformationReused::decode(data)?)
                    }
                    184 => {
                        additional_redundant_dl_qos_flow_per_tnl_information =
                            Some(QosFlowPerTnlInformationList::decode(data)?)
                    }
                    198 => {
                        used_rsn_information = Some(RedundantPduSessionInformation::decode(data)?)
                    }
                    27 => global_ran_node_id = Some(GlobalRanNodeId::decode(data)?),
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            dl_ngu_up_tnl_information,
            dl_ngu_tnl_information_reused,
            user_plane_security_information,
            qos_flow_accepted_list,
            additional_dl_qos_flow_per_tnl_information,
            redundant_dl_ngu_up_tnl_information,
            redundant_dl_ngu_tnl_information_reused,
            additional_redundant_dl_qos_flow_per_tnl_information,
            used_rsn_information,
            global_ran_node_id,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();
        if let Some(x) = &self.additional_dl_qos_flow_per_tnl_information {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 155, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.redundant_dl_ngu_up_tnl_information {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 192, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.redundant_dl_ngu_tnl_information_reused {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 191, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.additional_redundant_dl_qos_flow_per_tnl_information {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 184, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.used_rsn_information {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 198, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.global_ran_node_id {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 27, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        let mut optionals = BitString::new();
        optionals.push(self.dl_ngu_tnl_information_reused.is_some());
        optionals.push(self.user_plane_security_information.is_some());
        optionals.push(num_ies != 0);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.dl_ngu_up_tnl_information.encode(data)?;
        if let Some(x) = &self.dl_ngu_tnl_information_reused {
            x.encode(data)?;
        }
        if let Some(x) = &self.user_plane_security_information {
            x.encode(data)?;
        }
        self.qos_flow_accepted_list.encode(data)?;
        if num_ies != 0 {
            encode::encode_length_determinent(data, Some(1), Some(65535), false, num_ies)?;
            data.append_aligned(ies);
        }
        Ok(())
    }
}

impl PerCodec for PathSwitchRequestTransfer {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PathSwitchRequestTransfer::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PathSwitchRequestTransfer");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PathSwitchRequestTransfer");
            e
        })
    }
}
// PathSwitchRequestUnsuccessfulTransfer
#[derive(Clone, Debug)]
pub struct PathSwitchRequestUnsuccessfulTransfer {
    pub cause: Cause,
}

impl PathSwitchRequestUnsuccessfulTransfer {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let cause = Cause::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self { cause })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.cause.encode(data)?;

        Ok(())
    }
}

impl PerCodec for PathSwitchRequestUnsuccessfulTransfer {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PathSwitchRequestUnsuccessfulTransfer::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PathSwitchRequestUnsuccessfulTransfer");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PathSwitchRequestUnsuccessfulTransfer");
            e
        })
    }
}
// Pc5QosParameters
#[derive(Clone, Debug)]
pub struct Pc5QosParameters {
    pub pc_5_qos_flow_list: Pc5QosFlowList,
    pub pc_5_link_aggregate_bit_rates: Option<BitRate>,
}

impl Pc5QosParameters {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 2)?;
        let pc_5_qos_flow_list = Pc5QosFlowList::decode(data)?;
        let pc_5_link_aggregate_bit_rates = if optionals[0] {
            Some(BitRate::decode(data)?)
        } else {
            None
        };

        // Process the extension container

        if optionals[1] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            pc_5_qos_flow_list,
            pc_5_link_aggregate_bit_rates,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.pc_5_link_aggregate_bit_rates.is_some());
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.pc_5_qos_flow_list.encode(data)?;
        if let Some(x) = &self.pc_5_link_aggregate_bit_rates {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl PerCodec for Pc5QosParameters {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Pc5QosParameters::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("Pc5QosParameters");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("Pc5QosParameters");
            e
        })
    }
}
// Pc5QosFlowList
#[derive(Clone, Debug)]
pub struct Pc5QosFlowList(pub NonEmpty<Pc5QosFlowItem>);

impl Pc5QosFlowList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(2048), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(Pc5QosFlowItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(2048), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for Pc5QosFlowList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Pc5QosFlowList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("Pc5QosFlowList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("Pc5QosFlowList");
            e
        })
    }
}
// Pc5QosFlowItem
#[derive(Clone, Debug)]
pub struct Pc5QosFlowItem {
    pub pqi: FiveQi,
    pub pc_5_flow_bit_rates: Option<Pc5FlowBitRates>,
    pub range: Option<Range>,
}

impl Pc5QosFlowItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 3)?;
        let pqi = FiveQi::decode(data)?;
        let pc_5_flow_bit_rates = if optionals[0] {
            Some(Pc5FlowBitRates::decode(data)?)
        } else {
            None
        };
        let range = if optionals[1] {
            Some(Range::decode(data)?)
        } else {
            None
        };

        // Process the extension container

        if optionals[2] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            pqi,
            pc_5_flow_bit_rates,
            range,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.pc_5_flow_bit_rates.is_some());
        optionals.push(self.range.is_some());
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.pqi.encode(data)?;
        if let Some(x) = &self.pc_5_flow_bit_rates {
            x.encode(data)?;
        }
        if let Some(x) = &self.range {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl PerCodec for Pc5QosFlowItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Pc5QosFlowItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("Pc5QosFlowItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("Pc5QosFlowItem");
            e
        })
    }
}
// Pc5FlowBitRates
#[derive(Clone, Debug)]
pub struct Pc5FlowBitRates {
    pub guaranteed_flow_bit_rate: BitRate,
    pub maximum_flow_bit_rate: BitRate,
}

impl Pc5FlowBitRates {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let guaranteed_flow_bit_rate = BitRate::decode(data)?;
        let maximum_flow_bit_rate = BitRate::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            guaranteed_flow_bit_rate,
            maximum_flow_bit_rate,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.guaranteed_flow_bit_rate.encode(data)?;
        self.maximum_flow_bit_rate.encode(data)?;

        Ok(())
    }
}

impl PerCodec for Pc5FlowBitRates {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Pc5FlowBitRates::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("Pc5FlowBitRates");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("Pc5FlowBitRates");
            e
        })
    }
}
// PciListForMdt
#[derive(Clone, Debug)]
pub struct PciListForMdt(pub NonEmpty<NrPci>);

impl PciListForMdt {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(32), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(NrPci::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(32), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for PciListForMdt {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PciListForMdt::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PciListForMdt");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PciListForMdt");
            e
        })
    }
}
// PrivacyIndicator
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum PrivacyIndicator {
    ImmediateMdt,
    LoggedMdt,
}

impl PrivacyIndicator {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(1), true)?;
        if extended {
            return Err(PerCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(data, Some(0), Some(1), true, *self as i128, false)
    }
}

impl PerCodec for PrivacyIndicator {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PrivacyIndicator::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PrivacyIndicator");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PrivacyIndicator");
            e
        })
    }
}
// PduSessionAggregateMaximumBitRate
#[derive(Clone, Debug)]
pub struct PduSessionAggregateMaximumBitRate {
    pub pdu_session_aggregate_maximum_bit_rate_dl: BitRate,
    pub pdu_session_aggregate_maximum_bit_rate_ul: BitRate,
}

impl PduSessionAggregateMaximumBitRate {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let pdu_session_aggregate_maximum_bit_rate_dl = BitRate::decode(data)?;
        let pdu_session_aggregate_maximum_bit_rate_ul = BitRate::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            pdu_session_aggregate_maximum_bit_rate_dl,
            pdu_session_aggregate_maximum_bit_rate_ul,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.pdu_session_aggregate_maximum_bit_rate_dl
            .encode(data)?;
        self.pdu_session_aggregate_maximum_bit_rate_ul
            .encode(data)?;

        Ok(())
    }
}

impl PerCodec for PduSessionAggregateMaximumBitRate {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PduSessionAggregateMaximumBitRate::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PduSessionAggregateMaximumBitRate");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PduSessionAggregateMaximumBitRate");
            e
        })
    }
}
// PduSessionResourceAdmittedList
#[derive(Clone, Debug)]
pub struct PduSessionResourceAdmittedList(pub NonEmpty<PduSessionResourceAdmittedItem>);

impl PduSessionResourceAdmittedList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(256), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(PduSessionResourceAdmittedItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(256), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for PduSessionResourceAdmittedList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PduSessionResourceAdmittedList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PduSessionResourceAdmittedList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PduSessionResourceAdmittedList");
            e
        })
    }
}
// PduSessionResourceAdmittedItem
#[derive(Clone, Debug)]
pub struct PduSessionResourceAdmittedItem {
    pub pdu_session_id: PduSessionId,
    pub handover_request_acknowledge_transfer: Vec<u8>,
}

impl PduSessionResourceAdmittedItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let pdu_session_id = PduSessionId::decode(data)?;
        let handover_request_acknowledge_transfer =
            decode::decode_octetstring(data, None, None, false)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            pdu_session_id,
            handover_request_acknowledge_transfer,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.pdu_session_id.encode(data)?;
        encode::encode_octetstring(
            data,
            None,
            None,
            false,
            &self.handover_request_acknowledge_transfer,
            false,
        )?;

        Ok(())
    }
}

impl PerCodec for PduSessionResourceAdmittedItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PduSessionResourceAdmittedItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PduSessionResourceAdmittedItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PduSessionResourceAdmittedItem");
            e
        })
    }
}
// PduSessionResourceFailedToModifyListModCfm
#[derive(Clone, Debug)]
pub struct PduSessionResourceFailedToModifyListModCfm(
    pub NonEmpty<PduSessionResourceFailedToModifyItemModCfm>,
);

impl PduSessionResourceFailedToModifyListModCfm {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(256), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(PduSessionResourceFailedToModifyItemModCfm::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(256), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for PduSessionResourceFailedToModifyListModCfm {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PduSessionResourceFailedToModifyListModCfm::decode_inner(data).map_err(
            |mut e: PerCodecError| {
                e.push_context("PduSessionResourceFailedToModifyListModCfm");
                e
            },
        )
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PduSessionResourceFailedToModifyListModCfm");
            e
        })
    }
}
// PduSessionResourceFailedToModifyItemModCfm
#[derive(Clone, Debug)]
pub struct PduSessionResourceFailedToModifyItemModCfm {
    pub pdu_session_id: PduSessionId,
    pub pdu_session_resource_modify_indication_unsuccessful_transfer: Vec<u8>,
}

impl PduSessionResourceFailedToModifyItemModCfm {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let pdu_session_id = PduSessionId::decode(data)?;
        let pdu_session_resource_modify_indication_unsuccessful_transfer =
            decode::decode_octetstring(data, None, None, false)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            pdu_session_id,
            pdu_session_resource_modify_indication_unsuccessful_transfer,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.pdu_session_id.encode(data)?;
        encode::encode_octetstring(
            data,
            None,
            None,
            false,
            &self.pdu_session_resource_modify_indication_unsuccessful_transfer,
            false,
        )?;

        Ok(())
    }
}

impl PerCodec for PduSessionResourceFailedToModifyItemModCfm {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PduSessionResourceFailedToModifyItemModCfm::decode_inner(data).map_err(
            |mut e: PerCodecError| {
                e.push_context("PduSessionResourceFailedToModifyItemModCfm");
                e
            },
        )
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PduSessionResourceFailedToModifyItemModCfm");
            e
        })
    }
}
// PduSessionResourceFailedToModifyListModRes
#[derive(Clone, Debug)]
pub struct PduSessionResourceFailedToModifyListModRes(
    pub NonEmpty<PduSessionResourceFailedToModifyItemModRes>,
);

impl PduSessionResourceFailedToModifyListModRes {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(256), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(PduSessionResourceFailedToModifyItemModRes::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(256), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for PduSessionResourceFailedToModifyListModRes {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PduSessionResourceFailedToModifyListModRes::decode_inner(data).map_err(
            |mut e: PerCodecError| {
                e.push_context("PduSessionResourceFailedToModifyListModRes");
                e
            },
        )
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PduSessionResourceFailedToModifyListModRes");
            e
        })
    }
}
// PduSessionResourceFailedToModifyItemModRes
#[derive(Clone, Debug)]
pub struct PduSessionResourceFailedToModifyItemModRes {
    pub pdu_session_id: PduSessionId,
    pub pdu_session_resource_modify_unsuccessful_transfer: Vec<u8>,
}

impl PduSessionResourceFailedToModifyItemModRes {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let pdu_session_id = PduSessionId::decode(data)?;
        let pdu_session_resource_modify_unsuccessful_transfer =
            decode::decode_octetstring(data, None, None, false)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            pdu_session_id,
            pdu_session_resource_modify_unsuccessful_transfer,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.pdu_session_id.encode(data)?;
        encode::encode_octetstring(
            data,
            None,
            None,
            false,
            &self.pdu_session_resource_modify_unsuccessful_transfer,
            false,
        )?;

        Ok(())
    }
}

impl PerCodec for PduSessionResourceFailedToModifyItemModRes {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PduSessionResourceFailedToModifyItemModRes::decode_inner(data).map_err(
            |mut e: PerCodecError| {
                e.push_context("PduSessionResourceFailedToModifyItemModRes");
                e
            },
        )
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PduSessionResourceFailedToModifyItemModRes");
            e
        })
    }
}
// PduSessionResourceFailedToResumeListResReq
#[derive(Clone, Debug)]
pub struct PduSessionResourceFailedToResumeListResReq(
    pub NonEmpty<PduSessionResourceFailedToResumeItemResReq>,
);

impl PduSessionResourceFailedToResumeListResReq {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(256), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(PduSessionResourceFailedToResumeItemResReq::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(256), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for PduSessionResourceFailedToResumeListResReq {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PduSessionResourceFailedToResumeListResReq::decode_inner(data).map_err(
            |mut e: PerCodecError| {
                e.push_context("PduSessionResourceFailedToResumeListResReq");
                e
            },
        )
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PduSessionResourceFailedToResumeListResReq");
            e
        })
    }
}
// PduSessionResourceFailedToResumeItemResReq
#[derive(Clone, Debug)]
pub struct PduSessionResourceFailedToResumeItemResReq {
    pub pdu_session_id: PduSessionId,
    pub cause: Cause,
}

impl PduSessionResourceFailedToResumeItemResReq {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let pdu_session_id = PduSessionId::decode(data)?;
        let cause = Cause::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            pdu_session_id,
            cause,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.pdu_session_id.encode(data)?;
        self.cause.encode(data)?;

        Ok(())
    }
}

impl PerCodec for PduSessionResourceFailedToResumeItemResReq {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PduSessionResourceFailedToResumeItemResReq::decode_inner(data).map_err(
            |mut e: PerCodecError| {
                e.push_context("PduSessionResourceFailedToResumeItemResReq");
                e
            },
        )
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PduSessionResourceFailedToResumeItemResReq");
            e
        })
    }
}
// PduSessionResourceFailedToResumeListResRes
#[derive(Clone, Debug)]
pub struct PduSessionResourceFailedToResumeListResRes(
    pub NonEmpty<PduSessionResourceFailedToResumeItemResRes>,
);

impl PduSessionResourceFailedToResumeListResRes {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(256), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(PduSessionResourceFailedToResumeItemResRes::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(256), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for PduSessionResourceFailedToResumeListResRes {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PduSessionResourceFailedToResumeListResRes::decode_inner(data).map_err(
            |mut e: PerCodecError| {
                e.push_context("PduSessionResourceFailedToResumeListResRes");
                e
            },
        )
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PduSessionResourceFailedToResumeListResRes");
            e
        })
    }
}
// PduSessionResourceFailedToResumeItemResRes
#[derive(Clone, Debug)]
pub struct PduSessionResourceFailedToResumeItemResRes {
    pub pdu_session_id: PduSessionId,
    pub cause: Cause,
}

impl PduSessionResourceFailedToResumeItemResRes {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let pdu_session_id = PduSessionId::decode(data)?;
        let cause = Cause::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            pdu_session_id,
            cause,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.pdu_session_id.encode(data)?;
        self.cause.encode(data)?;

        Ok(())
    }
}

impl PerCodec for PduSessionResourceFailedToResumeItemResRes {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PduSessionResourceFailedToResumeItemResRes::decode_inner(data).map_err(
            |mut e: PerCodecError| {
                e.push_context("PduSessionResourceFailedToResumeItemResRes");
                e
            },
        )
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PduSessionResourceFailedToResumeItemResRes");
            e
        })
    }
}
// PduSessionResourceFailedToSetupListCxtFail
#[derive(Clone, Debug)]
pub struct PduSessionResourceFailedToSetupListCxtFail(
    pub NonEmpty<PduSessionResourceFailedToSetupItemCxtFail>,
);

impl PduSessionResourceFailedToSetupListCxtFail {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(256), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(PduSessionResourceFailedToSetupItemCxtFail::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(256), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for PduSessionResourceFailedToSetupListCxtFail {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PduSessionResourceFailedToSetupListCxtFail::decode_inner(data).map_err(
            |mut e: PerCodecError| {
                e.push_context("PduSessionResourceFailedToSetupListCxtFail");
                e
            },
        )
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PduSessionResourceFailedToSetupListCxtFail");
            e
        })
    }
}
// PduSessionResourceFailedToSetupItemCxtFail
#[derive(Clone, Debug)]
pub struct PduSessionResourceFailedToSetupItemCxtFail {
    pub pdu_session_id: PduSessionId,
    pub pdu_session_resource_setup_unsuccessful_transfer: Vec<u8>,
}

impl PduSessionResourceFailedToSetupItemCxtFail {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let pdu_session_id = PduSessionId::decode(data)?;
        let pdu_session_resource_setup_unsuccessful_transfer =
            decode::decode_octetstring(data, None, None, false)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            pdu_session_id,
            pdu_session_resource_setup_unsuccessful_transfer,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.pdu_session_id.encode(data)?;
        encode::encode_octetstring(
            data,
            None,
            None,
            false,
            &self.pdu_session_resource_setup_unsuccessful_transfer,
            false,
        )?;

        Ok(())
    }
}

impl PerCodec for PduSessionResourceFailedToSetupItemCxtFail {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PduSessionResourceFailedToSetupItemCxtFail::decode_inner(data).map_err(
            |mut e: PerCodecError| {
                e.push_context("PduSessionResourceFailedToSetupItemCxtFail");
                e
            },
        )
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PduSessionResourceFailedToSetupItemCxtFail");
            e
        })
    }
}
// PduSessionResourceFailedToSetupListCxtRes
#[derive(Clone, Debug)]
pub struct PduSessionResourceFailedToSetupListCxtRes(
    pub NonEmpty<PduSessionResourceFailedToSetupItemCxtRes>,
);

impl PduSessionResourceFailedToSetupListCxtRes {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(256), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(PduSessionResourceFailedToSetupItemCxtRes::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(256), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for PduSessionResourceFailedToSetupListCxtRes {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PduSessionResourceFailedToSetupListCxtRes::decode_inner(data).map_err(
            |mut e: PerCodecError| {
                e.push_context("PduSessionResourceFailedToSetupListCxtRes");
                e
            },
        )
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PduSessionResourceFailedToSetupListCxtRes");
            e
        })
    }
}
// PduSessionResourceFailedToSetupItemCxtRes
#[derive(Clone, Debug)]
pub struct PduSessionResourceFailedToSetupItemCxtRes {
    pub pdu_session_id: PduSessionId,
    pub pdu_session_resource_setup_unsuccessful_transfer: Vec<u8>,
}

impl PduSessionResourceFailedToSetupItemCxtRes {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let pdu_session_id = PduSessionId::decode(data)?;
        let pdu_session_resource_setup_unsuccessful_transfer =
            decode::decode_octetstring(data, None, None, false)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            pdu_session_id,
            pdu_session_resource_setup_unsuccessful_transfer,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.pdu_session_id.encode(data)?;
        encode::encode_octetstring(
            data,
            None,
            None,
            false,
            &self.pdu_session_resource_setup_unsuccessful_transfer,
            false,
        )?;

        Ok(())
    }
}

impl PerCodec for PduSessionResourceFailedToSetupItemCxtRes {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PduSessionResourceFailedToSetupItemCxtRes::decode_inner(data).map_err(
            |mut e: PerCodecError| {
                e.push_context("PduSessionResourceFailedToSetupItemCxtRes");
                e
            },
        )
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PduSessionResourceFailedToSetupItemCxtRes");
            e
        })
    }
}
// PduSessionResourceFailedToSetupListHoAck
#[derive(Clone, Debug)]
pub struct PduSessionResourceFailedToSetupListHoAck(
    pub NonEmpty<PduSessionResourceFailedToSetupItemHoAck>,
);

impl PduSessionResourceFailedToSetupListHoAck {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(256), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(PduSessionResourceFailedToSetupItemHoAck::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(256), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for PduSessionResourceFailedToSetupListHoAck {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PduSessionResourceFailedToSetupListHoAck::decode_inner(data).map_err(
            |mut e: PerCodecError| {
                e.push_context("PduSessionResourceFailedToSetupListHoAck");
                e
            },
        )
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PduSessionResourceFailedToSetupListHoAck");
            e
        })
    }
}
// PduSessionResourceFailedToSetupItemHoAck
#[derive(Clone, Debug)]
pub struct PduSessionResourceFailedToSetupItemHoAck {
    pub pdu_session_id: PduSessionId,
    pub handover_resource_allocation_unsuccessful_transfer: Vec<u8>,
}

impl PduSessionResourceFailedToSetupItemHoAck {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let pdu_session_id = PduSessionId::decode(data)?;
        let handover_resource_allocation_unsuccessful_transfer =
            decode::decode_octetstring(data, None, None, false)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            pdu_session_id,
            handover_resource_allocation_unsuccessful_transfer,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.pdu_session_id.encode(data)?;
        encode::encode_octetstring(
            data,
            None,
            None,
            false,
            &self.handover_resource_allocation_unsuccessful_transfer,
            false,
        )?;

        Ok(())
    }
}

impl PerCodec for PduSessionResourceFailedToSetupItemHoAck {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PduSessionResourceFailedToSetupItemHoAck::decode_inner(data).map_err(
            |mut e: PerCodecError| {
                e.push_context("PduSessionResourceFailedToSetupItemHoAck");
                e
            },
        )
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PduSessionResourceFailedToSetupItemHoAck");
            e
        })
    }
}
// PduSessionResourceFailedToSetupListPsReq
#[derive(Clone, Debug)]
pub struct PduSessionResourceFailedToSetupListPsReq(
    pub NonEmpty<PduSessionResourceFailedToSetupItemPsReq>,
);

impl PduSessionResourceFailedToSetupListPsReq {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(256), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(PduSessionResourceFailedToSetupItemPsReq::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(256), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for PduSessionResourceFailedToSetupListPsReq {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PduSessionResourceFailedToSetupListPsReq::decode_inner(data).map_err(
            |mut e: PerCodecError| {
                e.push_context("PduSessionResourceFailedToSetupListPsReq");
                e
            },
        )
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PduSessionResourceFailedToSetupListPsReq");
            e
        })
    }
}
// PduSessionResourceFailedToSetupItemPsReq
#[derive(Clone, Debug)]
pub struct PduSessionResourceFailedToSetupItemPsReq {
    pub pdu_session_id: PduSessionId,
    pub path_switch_request_setup_failed_transfer: Vec<u8>,
}

impl PduSessionResourceFailedToSetupItemPsReq {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let pdu_session_id = PduSessionId::decode(data)?;
        let path_switch_request_setup_failed_transfer =
            decode::decode_octetstring(data, None, None, false)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            pdu_session_id,
            path_switch_request_setup_failed_transfer,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.pdu_session_id.encode(data)?;
        encode::encode_octetstring(
            data,
            None,
            None,
            false,
            &self.path_switch_request_setup_failed_transfer,
            false,
        )?;

        Ok(())
    }
}

impl PerCodec for PduSessionResourceFailedToSetupItemPsReq {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PduSessionResourceFailedToSetupItemPsReq::decode_inner(data).map_err(
            |mut e: PerCodecError| {
                e.push_context("PduSessionResourceFailedToSetupItemPsReq");
                e
            },
        )
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PduSessionResourceFailedToSetupItemPsReq");
            e
        })
    }
}
// PduSessionResourceFailedToSetupListSuRes
#[derive(Clone, Debug)]
pub struct PduSessionResourceFailedToSetupListSuRes(
    pub NonEmpty<PduSessionResourceFailedToSetupItemSuRes>,
);

impl PduSessionResourceFailedToSetupListSuRes {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(256), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(PduSessionResourceFailedToSetupItemSuRes::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(256), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for PduSessionResourceFailedToSetupListSuRes {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PduSessionResourceFailedToSetupListSuRes::decode_inner(data).map_err(
            |mut e: PerCodecError| {
                e.push_context("PduSessionResourceFailedToSetupListSuRes");
                e
            },
        )
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PduSessionResourceFailedToSetupListSuRes");
            e
        })
    }
}
// PduSessionResourceFailedToSetupItemSuRes
#[derive(Clone, Debug)]
pub struct PduSessionResourceFailedToSetupItemSuRes {
    pub pdu_session_id: PduSessionId,
    pub pdu_session_resource_setup_unsuccessful_transfer: Vec<u8>,
}

impl PduSessionResourceFailedToSetupItemSuRes {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let pdu_session_id = PduSessionId::decode(data)?;
        let pdu_session_resource_setup_unsuccessful_transfer =
            decode::decode_octetstring(data, None, None, false)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            pdu_session_id,
            pdu_session_resource_setup_unsuccessful_transfer,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.pdu_session_id.encode(data)?;
        encode::encode_octetstring(
            data,
            None,
            None,
            false,
            &self.pdu_session_resource_setup_unsuccessful_transfer,
            false,
        )?;

        Ok(())
    }
}

impl PerCodec for PduSessionResourceFailedToSetupItemSuRes {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PduSessionResourceFailedToSetupItemSuRes::decode_inner(data).map_err(
            |mut e: PerCodecError| {
                e.push_context("PduSessionResourceFailedToSetupItemSuRes");
                e
            },
        )
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PduSessionResourceFailedToSetupItemSuRes");
            e
        })
    }
}
// PduSessionResourceHandoverList
#[derive(Clone, Debug)]
pub struct PduSessionResourceHandoverList(pub NonEmpty<PduSessionResourceHandoverItem>);

impl PduSessionResourceHandoverList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(256), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(PduSessionResourceHandoverItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(256), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for PduSessionResourceHandoverList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PduSessionResourceHandoverList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PduSessionResourceHandoverList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PduSessionResourceHandoverList");
            e
        })
    }
}
// PduSessionResourceHandoverItem
#[derive(Clone, Debug)]
pub struct PduSessionResourceHandoverItem {
    pub pdu_session_id: PduSessionId,
    pub handover_command_transfer: Vec<u8>,
}

impl PduSessionResourceHandoverItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let pdu_session_id = PduSessionId::decode(data)?;
        let handover_command_transfer = decode::decode_octetstring(data, None, None, false)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            pdu_session_id,
            handover_command_transfer,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.pdu_session_id.encode(data)?;
        encode::encode_octetstring(
            data,
            None,
            None,
            false,
            &self.handover_command_transfer,
            false,
        )?;

        Ok(())
    }
}

impl PerCodec for PduSessionResourceHandoverItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PduSessionResourceHandoverItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PduSessionResourceHandoverItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PduSessionResourceHandoverItem");
            e
        })
    }
}
// PduSessionResourceInformationList
#[derive(Clone, Debug)]
pub struct PduSessionResourceInformationList(pub NonEmpty<PduSessionResourceInformationItem>);

impl PduSessionResourceInformationList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(256), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(PduSessionResourceInformationItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(256), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for PduSessionResourceInformationList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PduSessionResourceInformationList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PduSessionResourceInformationList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PduSessionResourceInformationList");
            e
        })
    }
}
// PduSessionResourceInformationItem
#[derive(Clone, Debug)]
pub struct PduSessionResourceInformationItem {
    pub pdu_session_id: PduSessionId,
    pub qos_flow_information_list: QosFlowInformationList,
    pub drbs_to_qos_flows_mapping_list: Option<DrbsToQosFlowsMappingList>,
}

impl PduSessionResourceInformationItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 2)?;
        let pdu_session_id = PduSessionId::decode(data)?;
        let qos_flow_information_list = QosFlowInformationList::decode(data)?;
        let drbs_to_qos_flows_mapping_list = if optionals[0] {
            Some(DrbsToQosFlowsMappingList::decode(data)?)
        } else {
            None
        };

        // Process the extension container

        if optionals[1] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            pdu_session_id,
            qos_flow_information_list,
            drbs_to_qos_flows_mapping_list,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.drbs_to_qos_flows_mapping_list.is_some());
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.pdu_session_id.encode(data)?;
        self.qos_flow_information_list.encode(data)?;
        if let Some(x) = &self.drbs_to_qos_flows_mapping_list {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl PerCodec for PduSessionResourceInformationItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PduSessionResourceInformationItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PduSessionResourceInformationItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PduSessionResourceInformationItem");
            e
        })
    }
}
// PduSessionResourceListCxtRelCpl
#[derive(Clone, Debug)]
pub struct PduSessionResourceListCxtRelCpl(pub NonEmpty<PduSessionResourceItemCxtRelCpl>);

impl PduSessionResourceListCxtRelCpl {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(256), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(PduSessionResourceItemCxtRelCpl::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(256), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for PduSessionResourceListCxtRelCpl {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PduSessionResourceListCxtRelCpl::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PduSessionResourceListCxtRelCpl");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PduSessionResourceListCxtRelCpl");
            e
        })
    }
}
// PduSessionResourceItemCxtRelCpl
#[derive(Clone, Debug)]
pub struct PduSessionResourceItemCxtRelCpl {
    pub pdu_session_id: PduSessionId,
    pub pdu_session_resource_release_response_transfer: Option<Vec<u8>>,
}

impl PduSessionResourceItemCxtRelCpl {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let pdu_session_id = PduSessionId::decode(data)?;

        // Process the extension container
        let mut pdu_session_resource_release_response_transfer: Option<Vec<u8>> = None;

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    145 => {
                        pdu_session_resource_release_response_transfer =
                            Some(decode::decode_octetstring(data, None, None, false)?)
                    }
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            pdu_session_id,
            pdu_session_resource_release_response_transfer,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();
        if let Some(x) = &self.pdu_session_resource_release_response_transfer {
            let ie = &mut Allocator::new_codec_data();
            encode::encode_octetstring(ie, None, None, false, &x, false)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 145, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        let mut optionals = BitString::new();
        optionals.push(num_ies != 0);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.pdu_session_id.encode(data)?;
        if num_ies != 0 {
            encode::encode_length_determinent(data, Some(1), Some(65535), false, num_ies)?;
            data.append_aligned(ies);
        }
        Ok(())
    }
}

impl PerCodec for PduSessionResourceItemCxtRelCpl {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PduSessionResourceItemCxtRelCpl::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PduSessionResourceItemCxtRelCpl");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PduSessionResourceItemCxtRelCpl");
            e
        })
    }
}
// PduSessionResourceListCxtRelReq
#[derive(Clone, Debug)]
pub struct PduSessionResourceListCxtRelReq(pub NonEmpty<PduSessionResourceItemCxtRelReq>);

impl PduSessionResourceListCxtRelReq {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(256), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(PduSessionResourceItemCxtRelReq::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(256), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for PduSessionResourceListCxtRelReq {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PduSessionResourceListCxtRelReq::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PduSessionResourceListCxtRelReq");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PduSessionResourceListCxtRelReq");
            e
        })
    }
}
// PduSessionResourceItemCxtRelReq
#[derive(Clone, Debug)]
pub struct PduSessionResourceItemCxtRelReq {
    pub pdu_session_id: PduSessionId,
}

impl PduSessionResourceItemCxtRelReq {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let pdu_session_id = PduSessionId::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self { pdu_session_id })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.pdu_session_id.encode(data)?;

        Ok(())
    }
}

impl PerCodec for PduSessionResourceItemCxtRelReq {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PduSessionResourceItemCxtRelReq::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PduSessionResourceItemCxtRelReq");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PduSessionResourceItemCxtRelReq");
            e
        })
    }
}
// PduSessionResourceListHoRqd
#[derive(Clone, Debug)]
pub struct PduSessionResourceListHoRqd(pub NonEmpty<PduSessionResourceItemHoRqd>);

impl PduSessionResourceListHoRqd {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(256), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(PduSessionResourceItemHoRqd::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(256), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for PduSessionResourceListHoRqd {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PduSessionResourceListHoRqd::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PduSessionResourceListHoRqd");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PduSessionResourceListHoRqd");
            e
        })
    }
}
// PduSessionResourceItemHoRqd
#[derive(Clone, Debug)]
pub struct PduSessionResourceItemHoRqd {
    pub pdu_session_id: PduSessionId,
    pub handover_required_transfer: Vec<u8>,
}

impl PduSessionResourceItemHoRqd {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let pdu_session_id = PduSessionId::decode(data)?;
        let handover_required_transfer = decode::decode_octetstring(data, None, None, false)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            pdu_session_id,
            handover_required_transfer,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.pdu_session_id.encode(data)?;
        encode::encode_octetstring(
            data,
            None,
            None,
            false,
            &self.handover_required_transfer,
            false,
        )?;

        Ok(())
    }
}

impl PerCodec for PduSessionResourceItemHoRqd {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PduSessionResourceItemHoRqd::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PduSessionResourceItemHoRqd");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PduSessionResourceItemHoRqd");
            e
        })
    }
}
// PduSessionResourceModifyConfirmTransfer
#[derive(Clone, Debug)]
pub struct PduSessionResourceModifyConfirmTransfer {
    pub qos_flow_modify_confirm_list: QosFlowModifyConfirmList,
    pub ulngu_up_tnl_information: UpTransportLayerInformation,
    pub additional_ng_u_up_tnl_information: Option<UpTransportLayerInformationPairList>,
    pub qos_flow_failed_to_modify_list: Option<QosFlowListWithCause>,
    pub redundant_ul_ngu_up_tnl_information: Option<UpTransportLayerInformation>,
    pub additional_redundant_ngu_up_tnl_information: Option<UpTransportLayerInformationPairList>,
}

impl PduSessionResourceModifyConfirmTransfer {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 3)?;
        let qos_flow_modify_confirm_list = QosFlowModifyConfirmList::decode(data)?;
        let ulngu_up_tnl_information = UpTransportLayerInformation::decode(data)?;
        let additional_ng_u_up_tnl_information = if optionals[0] {
            Some(UpTransportLayerInformationPairList::decode(data)?)
        } else {
            None
        };
        let qos_flow_failed_to_modify_list = if optionals[1] {
            Some(QosFlowListWithCause::decode(data)?)
        } else {
            None
        };

        // Process the extension container
        let mut redundant_ul_ngu_up_tnl_information: Option<UpTransportLayerInformation> = None;
        let mut additional_redundant_ngu_up_tnl_information: Option<
            UpTransportLayerInformationPairList,
        > = None;

        if optionals[2] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    195 => {
                        redundant_ul_ngu_up_tnl_information =
                            Some(UpTransportLayerInformation::decode(data)?)
                    }
                    185 => {
                        additional_redundant_ngu_up_tnl_information =
                            Some(UpTransportLayerInformationPairList::decode(data)?)
                    }
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            qos_flow_modify_confirm_list,
            ulngu_up_tnl_information,
            additional_ng_u_up_tnl_information,
            qos_flow_failed_to_modify_list,
            redundant_ul_ngu_up_tnl_information,
            additional_redundant_ngu_up_tnl_information,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();
        if let Some(x) = &self.redundant_ul_ngu_up_tnl_information {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 195, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.additional_redundant_ngu_up_tnl_information {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 185, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        let mut optionals = BitString::new();
        optionals.push(self.additional_ng_u_up_tnl_information.is_some());
        optionals.push(self.qos_flow_failed_to_modify_list.is_some());
        optionals.push(num_ies != 0);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.qos_flow_modify_confirm_list.encode(data)?;
        self.ulngu_up_tnl_information.encode(data)?;
        if let Some(x) = &self.additional_ng_u_up_tnl_information {
            x.encode(data)?;
        }
        if let Some(x) = &self.qos_flow_failed_to_modify_list {
            x.encode(data)?;
        }
        if num_ies != 0 {
            encode::encode_length_determinent(data, Some(1), Some(65535), false, num_ies)?;
            data.append_aligned(ies);
        }
        Ok(())
    }
}

impl PerCodec for PduSessionResourceModifyConfirmTransfer {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PduSessionResourceModifyConfirmTransfer::decode_inner(data).map_err(
            |mut e: PerCodecError| {
                e.push_context("PduSessionResourceModifyConfirmTransfer");
                e
            },
        )
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PduSessionResourceModifyConfirmTransfer");
            e
        })
    }
}
// PduSessionResourceModifyIndicationUnsuccessfulTransfer
#[derive(Clone, Debug)]
pub struct PduSessionResourceModifyIndicationUnsuccessfulTransfer {
    pub cause: Cause,
}

impl PduSessionResourceModifyIndicationUnsuccessfulTransfer {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let cause = Cause::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self { cause })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.cause.encode(data)?;

        Ok(())
    }
}

impl PerCodec for PduSessionResourceModifyIndicationUnsuccessfulTransfer {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PduSessionResourceModifyIndicationUnsuccessfulTransfer::decode_inner(data).map_err(
            |mut e: PerCodecError| {
                e.push_context("PduSessionResourceModifyIndicationUnsuccessfulTransfer");
                e
            },
        )
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PduSessionResourceModifyIndicationUnsuccessfulTransfer");
            e
        })
    }
}
// PduSessionResourceModifyRequestTransfer
#[derive(Clone, Debug)]
pub struct PduSessionResourceModifyRequestTransfer {
    pub pdu_session_aggregate_maximum_bit_rate: Option<PduSessionAggregateMaximumBitRate>,
    pub ul_ngu_up_tnl_modify_list: Option<UlNguUpTnlModifyList>,
    pub network_instance: Option<NetworkInstance>,
    pub qos_flow_add_or_modify_request_list: Option<QosFlowAddOrModifyRequestList>,
    pub qos_flow_to_release_list: Option<QosFlowListWithCause>,
    pub additional_ul_ngu_up_tnl_information: Option<UpTransportLayerInformationList>,
    pub common_network_instance: Option<CommonNetworkInstance>,
    pub additional_redundant_ul_ngu_up_tnl_information: Option<UpTransportLayerInformationList>,
    pub redundant_common_network_instance: Option<CommonNetworkInstance>,
    pub redundant_ul_ngu_up_tnl_information: Option<UpTransportLayerInformation>,
    pub security_indication: Option<SecurityIndication>,
}

impl PduSessionResourceModifyRequestTransfer {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let _ = decode::decode_sequence_header(data, true, 0)?;
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut pdu_session_aggregate_maximum_bit_rate: Option<PduSessionAggregateMaximumBitRate> =
            None;
        let mut ul_ngu_up_tnl_modify_list: Option<UlNguUpTnlModifyList> = None;
        let mut network_instance: Option<NetworkInstance> = None;
        let mut qos_flow_add_or_modify_request_list: Option<QosFlowAddOrModifyRequestList> = None;
        let mut qos_flow_to_release_list: Option<QosFlowListWithCause> = None;
        let mut additional_ul_ngu_up_tnl_information: Option<UpTransportLayerInformationList> =
            None;
        let mut common_network_instance: Option<CommonNetworkInstance> = None;
        let mut additional_redundant_ul_ngu_up_tnl_information: Option<
            UpTransportLayerInformationList,
        > = None;
        let mut redundant_common_network_instance: Option<CommonNetworkInstance> = None;
        let mut redundant_ul_ngu_up_tnl_information: Option<UpTransportLayerInformation> = None;
        let mut security_indication: Option<SecurityIndication> = None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                130 => {
                    pdu_session_aggregate_maximum_bit_rate =
                        Some(PduSessionAggregateMaximumBitRate::decode(data)?)
                }
                140 => ul_ngu_up_tnl_modify_list = Some(UlNguUpTnlModifyList::decode(data)?),
                129 => network_instance = Some(NetworkInstance::decode(data)?),
                135 => {
                    qos_flow_add_or_modify_request_list =
                        Some(QosFlowAddOrModifyRequestList::decode(data)?)
                }
                137 => qos_flow_to_release_list = Some(QosFlowListWithCause::decode(data)?),
                126 => {
                    additional_ul_ngu_up_tnl_information =
                        Some(UpTransportLayerInformationList::decode(data)?)
                }
                166 => common_network_instance = Some(CommonNetworkInstance::decode(data)?),
                186 => {
                    additional_redundant_ul_ngu_up_tnl_information =
                        Some(UpTransportLayerInformationList::decode(data)?)
                }
                190 => {
                    redundant_common_network_instance = Some(CommonNetworkInstance::decode(data)?)
                }
                195 => {
                    redundant_ul_ngu_up_tnl_information =
                        Some(UpTransportLayerInformation::decode(data)?)
                }
                138 => security_indication = Some(SecurityIndication::decode(data)?),
                x => return Err(PerCodecError::new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        Ok(Self {
            pdu_session_aggregate_maximum_bit_rate,
            ul_ngu_up_tnl_modify_list,
            network_instance,
            qos_flow_add_or_modify_request_list,
            qos_flow_to_release_list,
            additional_ul_ngu_up_tnl_information,
            common_network_instance,
            additional_redundant_ul_ngu_up_tnl_information,
            redundant_common_network_instance,
            redundant_ul_ngu_up_tnl_information,
            security_indication,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        if let Some(x) = &self.pdu_session_aggregate_maximum_bit_rate {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 130, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.ul_ngu_up_tnl_modify_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 140, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.network_instance {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 129, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.qos_flow_add_or_modify_request_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 135, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.qos_flow_to_release_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 137, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.additional_ul_ngu_up_tnl_information {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 126, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.common_network_instance {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 166, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.additional_redundant_ul_ngu_up_tnl_information {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 186, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.redundant_common_network_instance {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 190, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.redundant_ul_ngu_up_tnl_information {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 195, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.security_indication {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 138, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        encode::encode_sequence_header(data, true, &BitString::new(), false)?;
        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for PduSessionResourceModifyRequestTransfer {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PduSessionResourceModifyRequestTransfer::decode_inner(data).map_err(
            |mut e: PerCodecError| {
                e.push_context("PduSessionResourceModifyRequestTransfer");
                e
            },
        )
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PduSessionResourceModifyRequestTransfer");
            e
        })
    }
}
// PduSessionResourceModifyResponseTransfer
#[derive(Clone, Debug)]
pub struct PduSessionResourceModifyResponseTransfer {
    pub dl_ngu_up_tnl_information: Option<UpTransportLayerInformation>,
    pub ul_ngu_up_tnl_information: Option<UpTransportLayerInformation>,
    pub qos_flow_add_or_modify_response_list: Option<QosFlowAddOrModifyResponseList>,
    pub additional_dl_qos_flow_per_tnl_information: Option<QosFlowPerTnlInformationList>,
    pub qos_flow_failed_to_add_or_modify_list: Option<QosFlowListWithCause>,
    pub additional_ngu_up_tnl_information: Option<UpTransportLayerInformationPairList>,
    pub redundant_dl_ngu_up_tnl_information: Option<UpTransportLayerInformation>,
    pub redundant_ul_ngu_up_tnl_information: Option<UpTransportLayerInformation>,
    pub additional_redundant_dl_qos_flow_per_tnl_information: Option<QosFlowPerTnlInformationList>,
    pub additional_redundant_ngu_up_tnl_information: Option<UpTransportLayerInformationPairList>,
}

impl PduSessionResourceModifyResponseTransfer {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 6)?;
        let dl_ngu_up_tnl_information = if optionals[0] {
            Some(UpTransportLayerInformation::decode(data)?)
        } else {
            None
        };
        let ul_ngu_up_tnl_information = if optionals[1] {
            Some(UpTransportLayerInformation::decode(data)?)
        } else {
            None
        };
        let qos_flow_add_or_modify_response_list = if optionals[2] {
            Some(QosFlowAddOrModifyResponseList::decode(data)?)
        } else {
            None
        };
        let additional_dl_qos_flow_per_tnl_information = if optionals[3] {
            Some(QosFlowPerTnlInformationList::decode(data)?)
        } else {
            None
        };
        let qos_flow_failed_to_add_or_modify_list = if optionals[4] {
            Some(QosFlowListWithCause::decode(data)?)
        } else {
            None
        };

        // Process the extension container
        let mut additional_ngu_up_tnl_information: Option<UpTransportLayerInformationPairList> =
            None;
        let mut redundant_dl_ngu_up_tnl_information: Option<UpTransportLayerInformation> = None;
        let mut redundant_ul_ngu_up_tnl_information: Option<UpTransportLayerInformation> = None;
        let mut additional_redundant_dl_qos_flow_per_tnl_information: Option<
            QosFlowPerTnlInformationList,
        > = None;
        let mut additional_redundant_ngu_up_tnl_information: Option<
            UpTransportLayerInformationPairList,
        > = None;

        if optionals[5] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    154 => {
                        additional_ngu_up_tnl_information =
                            Some(UpTransportLayerInformationPairList::decode(data)?)
                    }
                    192 => {
                        redundant_dl_ngu_up_tnl_information =
                            Some(UpTransportLayerInformation::decode(data)?)
                    }
                    195 => {
                        redundant_ul_ngu_up_tnl_information =
                            Some(UpTransportLayerInformation::decode(data)?)
                    }
                    184 => {
                        additional_redundant_dl_qos_flow_per_tnl_information =
                            Some(QosFlowPerTnlInformationList::decode(data)?)
                    }
                    185 => {
                        additional_redundant_ngu_up_tnl_information =
                            Some(UpTransportLayerInformationPairList::decode(data)?)
                    }
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            dl_ngu_up_tnl_information,
            ul_ngu_up_tnl_information,
            qos_flow_add_or_modify_response_list,
            additional_dl_qos_flow_per_tnl_information,
            qos_flow_failed_to_add_or_modify_list,
            additional_ngu_up_tnl_information,
            redundant_dl_ngu_up_tnl_information,
            redundant_ul_ngu_up_tnl_information,
            additional_redundant_dl_qos_flow_per_tnl_information,
            additional_redundant_ngu_up_tnl_information,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();
        if let Some(x) = &self.additional_ngu_up_tnl_information {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 154, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.redundant_dl_ngu_up_tnl_information {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 192, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.redundant_ul_ngu_up_tnl_information {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 195, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.additional_redundant_dl_qos_flow_per_tnl_information {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 184, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.additional_redundant_ngu_up_tnl_information {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 185, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        let mut optionals = BitString::new();
        optionals.push(self.dl_ngu_up_tnl_information.is_some());
        optionals.push(self.ul_ngu_up_tnl_information.is_some());
        optionals.push(self.qos_flow_add_or_modify_response_list.is_some());
        optionals.push(self.additional_dl_qos_flow_per_tnl_information.is_some());
        optionals.push(self.qos_flow_failed_to_add_or_modify_list.is_some());
        optionals.push(num_ies != 0);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        if let Some(x) = &self.dl_ngu_up_tnl_information {
            x.encode(data)?;
        }
        if let Some(x) = &self.ul_ngu_up_tnl_information {
            x.encode(data)?;
        }
        if let Some(x) = &self.qos_flow_add_or_modify_response_list {
            x.encode(data)?;
        }
        if let Some(x) = &self.additional_dl_qos_flow_per_tnl_information {
            x.encode(data)?;
        }
        if let Some(x) = &self.qos_flow_failed_to_add_or_modify_list {
            x.encode(data)?;
        }
        if num_ies != 0 {
            encode::encode_length_determinent(data, Some(1), Some(65535), false, num_ies)?;
            data.append_aligned(ies);
        }
        Ok(())
    }
}

impl PerCodec for PduSessionResourceModifyResponseTransfer {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PduSessionResourceModifyResponseTransfer::decode_inner(data).map_err(
            |mut e: PerCodecError| {
                e.push_context("PduSessionResourceModifyResponseTransfer");
                e
            },
        )
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PduSessionResourceModifyResponseTransfer");
            e
        })
    }
}
// PduSessionResourceModifyIndicationTransfer
#[derive(Clone, Debug)]
pub struct PduSessionResourceModifyIndicationTransfer {
    pub dl_qos_flow_per_tnl_information: QosFlowPerTnlInformation,
    pub additional_dl_qos_flow_per_tnl_information: Option<QosFlowPerTnlInformationList>,
    pub secondary_rat_usage_information: Option<SecondaryRatUsageInformation>,
    pub security_result: Option<SecurityResult>,
    pub redundant_dl_qos_flow_per_tnl_information: Option<QosFlowPerTnlInformation>,
    pub additional_redundant_dl_qos_flow_per_tnl_information: Option<QosFlowPerTnlInformationList>,
    pub global_ran_node_id: Option<GlobalRanNodeId>,
}

impl PduSessionResourceModifyIndicationTransfer {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 2)?;
        let dl_qos_flow_per_tnl_information = QosFlowPerTnlInformation::decode(data)?;
        let additional_dl_qos_flow_per_tnl_information = if optionals[0] {
            Some(QosFlowPerTnlInformationList::decode(data)?)
        } else {
            None
        };

        // Process the extension container
        let mut secondary_rat_usage_information: Option<SecondaryRatUsageInformation> = None;
        let mut security_result: Option<SecurityResult> = None;
        let mut redundant_dl_qos_flow_per_tnl_information: Option<QosFlowPerTnlInformation> = None;
        let mut additional_redundant_dl_qos_flow_per_tnl_information: Option<
            QosFlowPerTnlInformationList,
        > = None;
        let mut global_ran_node_id: Option<GlobalRanNodeId> = None;

        if optionals[1] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    144 => {
                        secondary_rat_usage_information =
                            Some(SecondaryRatUsageInformation::decode(data)?)
                    }
                    156 => security_result = Some(SecurityResult::decode(data)?),
                    193 => {
                        redundant_dl_qos_flow_per_tnl_information =
                            Some(QosFlowPerTnlInformation::decode(data)?)
                    }
                    184 => {
                        additional_redundant_dl_qos_flow_per_tnl_information =
                            Some(QosFlowPerTnlInformationList::decode(data)?)
                    }
                    27 => global_ran_node_id = Some(GlobalRanNodeId::decode(data)?),
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            dl_qos_flow_per_tnl_information,
            additional_dl_qos_flow_per_tnl_information,
            secondary_rat_usage_information,
            security_result,
            redundant_dl_qos_flow_per_tnl_information,
            additional_redundant_dl_qos_flow_per_tnl_information,
            global_ran_node_id,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();
        if let Some(x) = &self.secondary_rat_usage_information {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 144, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.security_result {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 156, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.redundant_dl_qos_flow_per_tnl_information {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 193, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.additional_redundant_dl_qos_flow_per_tnl_information {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 184, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.global_ran_node_id {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 27, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        let mut optionals = BitString::new();
        optionals.push(self.additional_dl_qos_flow_per_tnl_information.is_some());
        optionals.push(num_ies != 0);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.dl_qos_flow_per_tnl_information.encode(data)?;
        if let Some(x) = &self.additional_dl_qos_flow_per_tnl_information {
            x.encode(data)?;
        }
        if num_ies != 0 {
            encode::encode_length_determinent(data, Some(1), Some(65535), false, num_ies)?;
            data.append_aligned(ies);
        }
        Ok(())
    }
}

impl PerCodec for PduSessionResourceModifyIndicationTransfer {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PduSessionResourceModifyIndicationTransfer::decode_inner(data).map_err(
            |mut e: PerCodecError| {
                e.push_context("PduSessionResourceModifyIndicationTransfer");
                e
            },
        )
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PduSessionResourceModifyIndicationTransfer");
            e
        })
    }
}
// PduSessionResourceModifyListModCfm
#[derive(Clone, Debug)]
pub struct PduSessionResourceModifyListModCfm(pub NonEmpty<PduSessionResourceModifyItemModCfm>);

impl PduSessionResourceModifyListModCfm {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(256), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(PduSessionResourceModifyItemModCfm::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(256), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for PduSessionResourceModifyListModCfm {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PduSessionResourceModifyListModCfm::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PduSessionResourceModifyListModCfm");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PduSessionResourceModifyListModCfm");
            e
        })
    }
}
// PduSessionResourceModifyItemModCfm
#[derive(Clone, Debug)]
pub struct PduSessionResourceModifyItemModCfm {
    pub pdu_session_id: PduSessionId,
    pub pdu_session_resource_modify_confirm_transfer: Vec<u8>,
}

impl PduSessionResourceModifyItemModCfm {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let pdu_session_id = PduSessionId::decode(data)?;
        let pdu_session_resource_modify_confirm_transfer =
            decode::decode_octetstring(data, None, None, false)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            pdu_session_id,
            pdu_session_resource_modify_confirm_transfer,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.pdu_session_id.encode(data)?;
        encode::encode_octetstring(
            data,
            None,
            None,
            false,
            &self.pdu_session_resource_modify_confirm_transfer,
            false,
        )?;

        Ok(())
    }
}

impl PerCodec for PduSessionResourceModifyItemModCfm {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PduSessionResourceModifyItemModCfm::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PduSessionResourceModifyItemModCfm");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PduSessionResourceModifyItemModCfm");
            e
        })
    }
}
// PduSessionResourceModifyListModInd
#[derive(Clone, Debug)]
pub struct PduSessionResourceModifyListModInd(pub NonEmpty<PduSessionResourceModifyItemModInd>);

impl PduSessionResourceModifyListModInd {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(256), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(PduSessionResourceModifyItemModInd::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(256), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for PduSessionResourceModifyListModInd {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PduSessionResourceModifyListModInd::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PduSessionResourceModifyListModInd");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PduSessionResourceModifyListModInd");
            e
        })
    }
}
// PduSessionResourceModifyItemModInd
#[derive(Clone, Debug)]
pub struct PduSessionResourceModifyItemModInd {
    pub pdu_session_id: PduSessionId,
    pub pdu_session_resource_modify_indication_transfer: Vec<u8>,
}

impl PduSessionResourceModifyItemModInd {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let pdu_session_id = PduSessionId::decode(data)?;
        let pdu_session_resource_modify_indication_transfer =
            decode::decode_octetstring(data, None, None, false)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            pdu_session_id,
            pdu_session_resource_modify_indication_transfer,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.pdu_session_id.encode(data)?;
        encode::encode_octetstring(
            data,
            None,
            None,
            false,
            &self.pdu_session_resource_modify_indication_transfer,
            false,
        )?;

        Ok(())
    }
}

impl PerCodec for PduSessionResourceModifyItemModInd {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PduSessionResourceModifyItemModInd::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PduSessionResourceModifyItemModInd");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PduSessionResourceModifyItemModInd");
            e
        })
    }
}
// PduSessionResourceModifyListModReq
#[derive(Clone, Debug)]
pub struct PduSessionResourceModifyListModReq(pub NonEmpty<PduSessionResourceModifyItemModReq>);

impl PduSessionResourceModifyListModReq {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(256), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(PduSessionResourceModifyItemModReq::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(256), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for PduSessionResourceModifyListModReq {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PduSessionResourceModifyListModReq::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PduSessionResourceModifyListModReq");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PduSessionResourceModifyListModReq");
            e
        })
    }
}
// PduSessionResourceModifyItemModReq
#[derive(Clone, Debug)]
pub struct PduSessionResourceModifyItemModReq {
    pub pdu_session_id: PduSessionId,
    pub nas_pdu: Option<NasPdu>,
    pub pdu_session_resource_modify_request_transfer: Vec<u8>,
    pub snssai: Option<Snssai>,
}

impl PduSessionResourceModifyItemModReq {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 2)?;
        let pdu_session_id = PduSessionId::decode(data)?;
        let nas_pdu = if optionals[0] {
            Some(NasPdu::decode(data)?)
        } else {
            None
        };
        let pdu_session_resource_modify_request_transfer =
            decode::decode_octetstring(data, None, None, false)?;

        // Process the extension container
        let mut snssai: Option<Snssai> = None;

        if optionals[1] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    148 => snssai = Some(Snssai::decode(data)?),
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            pdu_session_id,
            nas_pdu,
            pdu_session_resource_modify_request_transfer,
            snssai,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();
        if let Some(x) = &self.snssai {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 148, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        let mut optionals = BitString::new();
        optionals.push(self.nas_pdu.is_some());
        optionals.push(num_ies != 0);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.pdu_session_id.encode(data)?;
        if let Some(x) = &self.nas_pdu {
            x.encode(data)?;
        }
        encode::encode_octetstring(
            data,
            None,
            None,
            false,
            &self.pdu_session_resource_modify_request_transfer,
            false,
        )?;
        if num_ies != 0 {
            encode::encode_length_determinent(data, Some(1), Some(65535), false, num_ies)?;
            data.append_aligned(ies);
        }
        Ok(())
    }
}

impl PerCodec for PduSessionResourceModifyItemModReq {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PduSessionResourceModifyItemModReq::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PduSessionResourceModifyItemModReq");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PduSessionResourceModifyItemModReq");
            e
        })
    }
}
// PduSessionResourceModifyListModRes
#[derive(Clone, Debug)]
pub struct PduSessionResourceModifyListModRes(pub NonEmpty<PduSessionResourceModifyItemModRes>);

impl PduSessionResourceModifyListModRes {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(256), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(PduSessionResourceModifyItemModRes::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(256), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for PduSessionResourceModifyListModRes {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PduSessionResourceModifyListModRes::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PduSessionResourceModifyListModRes");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PduSessionResourceModifyListModRes");
            e
        })
    }
}
// PduSessionResourceModifyItemModRes
#[derive(Clone, Debug)]
pub struct PduSessionResourceModifyItemModRes {
    pub pdu_session_id: PduSessionId,
    pub pdu_session_resource_modify_response_transfer: Vec<u8>,
}

impl PduSessionResourceModifyItemModRes {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let pdu_session_id = PduSessionId::decode(data)?;
        let pdu_session_resource_modify_response_transfer =
            decode::decode_octetstring(data, None, None, false)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            pdu_session_id,
            pdu_session_resource_modify_response_transfer,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.pdu_session_id.encode(data)?;
        encode::encode_octetstring(
            data,
            None,
            None,
            false,
            &self.pdu_session_resource_modify_response_transfer,
            false,
        )?;

        Ok(())
    }
}

impl PerCodec for PduSessionResourceModifyItemModRes {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PduSessionResourceModifyItemModRes::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PduSessionResourceModifyItemModRes");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PduSessionResourceModifyItemModRes");
            e
        })
    }
}
// PduSessionResourceModifyUnsuccessfulTransfer
#[derive(Clone, Debug)]
pub struct PduSessionResourceModifyUnsuccessfulTransfer {
    pub cause: Cause,
    pub criticality_diagnostics: Option<CriticalityDiagnostics>,
}

impl PduSessionResourceModifyUnsuccessfulTransfer {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 2)?;
        let cause = Cause::decode(data)?;
        let criticality_diagnostics = if optionals[0] {
            Some(CriticalityDiagnostics::decode(data)?)
        } else {
            None
        };

        // Process the extension container

        if optionals[1] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            cause,
            criticality_diagnostics,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.criticality_diagnostics.is_some());
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.cause.encode(data)?;
        if let Some(x) = &self.criticality_diagnostics {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl PerCodec for PduSessionResourceModifyUnsuccessfulTransfer {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PduSessionResourceModifyUnsuccessfulTransfer::decode_inner(data).map_err(
            |mut e: PerCodecError| {
                e.push_context("PduSessionResourceModifyUnsuccessfulTransfer");
                e
            },
        )
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PduSessionResourceModifyUnsuccessfulTransfer");
            e
        })
    }
}
// PduSessionResourceNotifyList
#[derive(Clone, Debug)]
pub struct PduSessionResourceNotifyList(pub NonEmpty<PduSessionResourceNotifyItem>);

impl PduSessionResourceNotifyList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(256), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(PduSessionResourceNotifyItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(256), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for PduSessionResourceNotifyList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PduSessionResourceNotifyList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PduSessionResourceNotifyList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PduSessionResourceNotifyList");
            e
        })
    }
}
// PduSessionResourceNotifyItem
#[derive(Clone, Debug)]
pub struct PduSessionResourceNotifyItem {
    pub pdu_session_id: PduSessionId,
    pub pdu_session_resource_notify_transfer: Vec<u8>,
}

impl PduSessionResourceNotifyItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let pdu_session_id = PduSessionId::decode(data)?;
        let pdu_session_resource_notify_transfer =
            decode::decode_octetstring(data, None, None, false)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            pdu_session_id,
            pdu_session_resource_notify_transfer,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.pdu_session_id.encode(data)?;
        encode::encode_octetstring(
            data,
            None,
            None,
            false,
            &self.pdu_session_resource_notify_transfer,
            false,
        )?;

        Ok(())
    }
}

impl PerCodec for PduSessionResourceNotifyItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PduSessionResourceNotifyItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PduSessionResourceNotifyItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PduSessionResourceNotifyItem");
            e
        })
    }
}
// PduSessionResourceNotifyReleasedTransfer
#[derive(Clone, Debug)]
pub struct PduSessionResourceNotifyReleasedTransfer {
    pub cause: Cause,
    pub secondary_rat_usage_information: Option<SecondaryRatUsageInformation>,
}

impl PduSessionResourceNotifyReleasedTransfer {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let cause = Cause::decode(data)?;

        // Process the extension container
        let mut secondary_rat_usage_information: Option<SecondaryRatUsageInformation> = None;

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    144 => {
                        secondary_rat_usage_information =
                            Some(SecondaryRatUsageInformation::decode(data)?)
                    }
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            cause,
            secondary_rat_usage_information,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();
        if let Some(x) = &self.secondary_rat_usage_information {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 144, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        let mut optionals = BitString::new();
        optionals.push(num_ies != 0);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.cause.encode(data)?;
        if num_ies != 0 {
            encode::encode_length_determinent(data, Some(1), Some(65535), false, num_ies)?;
            data.append_aligned(ies);
        }
        Ok(())
    }
}

impl PerCodec for PduSessionResourceNotifyReleasedTransfer {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PduSessionResourceNotifyReleasedTransfer::decode_inner(data).map_err(
            |mut e: PerCodecError| {
                e.push_context("PduSessionResourceNotifyReleasedTransfer");
                e
            },
        )
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PduSessionResourceNotifyReleasedTransfer");
            e
        })
    }
}
// PduSessionResourceNotifyTransfer
#[derive(Clone, Debug)]
pub struct PduSessionResourceNotifyTransfer {
    pub qos_flow_notify_list: Option<QosFlowNotifyList>,
    pub qos_flow_released_list: Option<QosFlowListWithCause>,
    pub secondary_rat_usage_information: Option<SecondaryRatUsageInformation>,
    pub qos_flow_feedback_list: Option<QosFlowFeedbackList>,
}

impl PduSessionResourceNotifyTransfer {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 3)?;
        let qos_flow_notify_list = if optionals[0] {
            Some(QosFlowNotifyList::decode(data)?)
        } else {
            None
        };
        let qos_flow_released_list = if optionals[1] {
            Some(QosFlowListWithCause::decode(data)?)
        } else {
            None
        };

        // Process the extension container
        let mut secondary_rat_usage_information: Option<SecondaryRatUsageInformation> = None;
        let mut qos_flow_feedback_list: Option<QosFlowFeedbackList> = None;

        if optionals[2] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    144 => {
                        secondary_rat_usage_information =
                            Some(SecondaryRatUsageInformation::decode(data)?)
                    }
                    278 => qos_flow_feedback_list = Some(QosFlowFeedbackList::decode(data)?),
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            qos_flow_notify_list,
            qos_flow_released_list,
            secondary_rat_usage_information,
            qos_flow_feedback_list,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();
        if let Some(x) = &self.secondary_rat_usage_information {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 144, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.qos_flow_feedback_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 278, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        let mut optionals = BitString::new();
        optionals.push(self.qos_flow_notify_list.is_some());
        optionals.push(self.qos_flow_released_list.is_some());
        optionals.push(num_ies != 0);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        if let Some(x) = &self.qos_flow_notify_list {
            x.encode(data)?;
        }
        if let Some(x) = &self.qos_flow_released_list {
            x.encode(data)?;
        }
        if num_ies != 0 {
            encode::encode_length_determinent(data, Some(1), Some(65535), false, num_ies)?;
            data.append_aligned(ies);
        }
        Ok(())
    }
}

impl PerCodec for PduSessionResourceNotifyTransfer {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PduSessionResourceNotifyTransfer::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PduSessionResourceNotifyTransfer");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PduSessionResourceNotifyTransfer");
            e
        })
    }
}
// PduSessionResourceReleaseCommandTransfer
#[derive(Clone, Debug)]
pub struct PduSessionResourceReleaseCommandTransfer {
    pub cause: Cause,
}

impl PduSessionResourceReleaseCommandTransfer {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let cause = Cause::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self { cause })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.cause.encode(data)?;

        Ok(())
    }
}

impl PerCodec for PduSessionResourceReleaseCommandTransfer {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PduSessionResourceReleaseCommandTransfer::decode_inner(data).map_err(
            |mut e: PerCodecError| {
                e.push_context("PduSessionResourceReleaseCommandTransfer");
                e
            },
        )
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PduSessionResourceReleaseCommandTransfer");
            e
        })
    }
}
// PduSessionResourceReleasedListNot
#[derive(Clone, Debug)]
pub struct PduSessionResourceReleasedListNot(pub NonEmpty<PduSessionResourceReleasedItemNot>);

impl PduSessionResourceReleasedListNot {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(256), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(PduSessionResourceReleasedItemNot::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(256), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for PduSessionResourceReleasedListNot {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PduSessionResourceReleasedListNot::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PduSessionResourceReleasedListNot");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PduSessionResourceReleasedListNot");
            e
        })
    }
}
// PduSessionResourceReleasedItemNot
#[derive(Clone, Debug)]
pub struct PduSessionResourceReleasedItemNot {
    pub pdu_session_id: PduSessionId,
    pub pdu_session_resource_notify_released_transfer: Vec<u8>,
}

impl PduSessionResourceReleasedItemNot {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let pdu_session_id = PduSessionId::decode(data)?;
        let pdu_session_resource_notify_released_transfer =
            decode::decode_octetstring(data, None, None, false)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            pdu_session_id,
            pdu_session_resource_notify_released_transfer,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.pdu_session_id.encode(data)?;
        encode::encode_octetstring(
            data,
            None,
            None,
            false,
            &self.pdu_session_resource_notify_released_transfer,
            false,
        )?;

        Ok(())
    }
}

impl PerCodec for PduSessionResourceReleasedItemNot {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PduSessionResourceReleasedItemNot::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PduSessionResourceReleasedItemNot");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PduSessionResourceReleasedItemNot");
            e
        })
    }
}
// PduSessionResourceReleasedListPsAck
#[derive(Clone, Debug)]
pub struct PduSessionResourceReleasedListPsAck(pub NonEmpty<PduSessionResourceReleasedItemPsAck>);

impl PduSessionResourceReleasedListPsAck {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(256), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(PduSessionResourceReleasedItemPsAck::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(256), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for PduSessionResourceReleasedListPsAck {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PduSessionResourceReleasedListPsAck::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PduSessionResourceReleasedListPsAck");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PduSessionResourceReleasedListPsAck");
            e
        })
    }
}
// PduSessionResourceReleasedItemPsAck
#[derive(Clone, Debug)]
pub struct PduSessionResourceReleasedItemPsAck {
    pub pdu_session_id: PduSessionId,
    pub path_switch_request_unsuccessful_transfer: Vec<u8>,
}

impl PduSessionResourceReleasedItemPsAck {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let pdu_session_id = PduSessionId::decode(data)?;
        let path_switch_request_unsuccessful_transfer =
            decode::decode_octetstring(data, None, None, false)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            pdu_session_id,
            path_switch_request_unsuccessful_transfer,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.pdu_session_id.encode(data)?;
        encode::encode_octetstring(
            data,
            None,
            None,
            false,
            &self.path_switch_request_unsuccessful_transfer,
            false,
        )?;

        Ok(())
    }
}

impl PerCodec for PduSessionResourceReleasedItemPsAck {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PduSessionResourceReleasedItemPsAck::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PduSessionResourceReleasedItemPsAck");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PduSessionResourceReleasedItemPsAck");
            e
        })
    }
}
// PduSessionResourceReleasedListPsFail
#[derive(Clone, Debug)]
pub struct PduSessionResourceReleasedListPsFail(pub NonEmpty<PduSessionResourceReleasedItemPsFail>);

impl PduSessionResourceReleasedListPsFail {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(256), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(PduSessionResourceReleasedItemPsFail::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(256), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for PduSessionResourceReleasedListPsFail {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PduSessionResourceReleasedListPsFail::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PduSessionResourceReleasedListPsFail");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PduSessionResourceReleasedListPsFail");
            e
        })
    }
}
// PduSessionResourceReleasedItemPsFail
#[derive(Clone, Debug)]
pub struct PduSessionResourceReleasedItemPsFail {
    pub pdu_session_id: PduSessionId,
    pub path_switch_request_unsuccessful_transfer: Vec<u8>,
}

impl PduSessionResourceReleasedItemPsFail {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let pdu_session_id = PduSessionId::decode(data)?;
        let path_switch_request_unsuccessful_transfer =
            decode::decode_octetstring(data, None, None, false)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            pdu_session_id,
            path_switch_request_unsuccessful_transfer,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.pdu_session_id.encode(data)?;
        encode::encode_octetstring(
            data,
            None,
            None,
            false,
            &self.path_switch_request_unsuccessful_transfer,
            false,
        )?;

        Ok(())
    }
}

impl PerCodec for PduSessionResourceReleasedItemPsFail {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PduSessionResourceReleasedItemPsFail::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PduSessionResourceReleasedItemPsFail");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PduSessionResourceReleasedItemPsFail");
            e
        })
    }
}
// PduSessionResourceReleasedListRelRes
#[derive(Clone, Debug)]
pub struct PduSessionResourceReleasedListRelRes(pub NonEmpty<PduSessionResourceReleasedItemRelRes>);

impl PduSessionResourceReleasedListRelRes {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(256), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(PduSessionResourceReleasedItemRelRes::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(256), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for PduSessionResourceReleasedListRelRes {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PduSessionResourceReleasedListRelRes::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PduSessionResourceReleasedListRelRes");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PduSessionResourceReleasedListRelRes");
            e
        })
    }
}
// PduSessionResourceReleasedItemRelRes
#[derive(Clone, Debug)]
pub struct PduSessionResourceReleasedItemRelRes {
    pub pdu_session_id: PduSessionId,
    pub pdu_session_resource_release_response_transfer: Vec<u8>,
}

impl PduSessionResourceReleasedItemRelRes {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let pdu_session_id = PduSessionId::decode(data)?;
        let pdu_session_resource_release_response_transfer =
            decode::decode_octetstring(data, None, None, false)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            pdu_session_id,
            pdu_session_resource_release_response_transfer,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.pdu_session_id.encode(data)?;
        encode::encode_octetstring(
            data,
            None,
            None,
            false,
            &self.pdu_session_resource_release_response_transfer,
            false,
        )?;

        Ok(())
    }
}

impl PerCodec for PduSessionResourceReleasedItemRelRes {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PduSessionResourceReleasedItemRelRes::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PduSessionResourceReleasedItemRelRes");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PduSessionResourceReleasedItemRelRes");
            e
        })
    }
}
// PduSessionResourceReleaseResponseTransfer
#[derive(Clone, Debug)]
pub struct PduSessionResourceReleaseResponseTransfer {
    pub secondary_rat_usage_information: Option<SecondaryRatUsageInformation>,
}

impl PduSessionResourceReleaseResponseTransfer {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;

        // Process the extension container
        let mut secondary_rat_usage_information: Option<SecondaryRatUsageInformation> = None;

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    144 => {
                        secondary_rat_usage_information =
                            Some(SecondaryRatUsageInformation::decode(data)?)
                    }
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            secondary_rat_usage_information,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();
        if let Some(x) = &self.secondary_rat_usage_information {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 144, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        let mut optionals = BitString::new();
        optionals.push(num_ies != 0);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        if num_ies != 0 {
            encode::encode_length_determinent(data, Some(1), Some(65535), false, num_ies)?;
            data.append_aligned(ies);
        }
        Ok(())
    }
}

impl PerCodec for PduSessionResourceReleaseResponseTransfer {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PduSessionResourceReleaseResponseTransfer::decode_inner(data).map_err(
            |mut e: PerCodecError| {
                e.push_context("PduSessionResourceReleaseResponseTransfer");
                e
            },
        )
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PduSessionResourceReleaseResponseTransfer");
            e
        })
    }
}
// PduSessionResourceResumeListResReq
#[derive(Clone, Debug)]
pub struct PduSessionResourceResumeListResReq(pub NonEmpty<PduSessionResourceResumeItemResReq>);

impl PduSessionResourceResumeListResReq {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(256), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(PduSessionResourceResumeItemResReq::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(256), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for PduSessionResourceResumeListResReq {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PduSessionResourceResumeListResReq::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PduSessionResourceResumeListResReq");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PduSessionResourceResumeListResReq");
            e
        })
    }
}
// PduSessionResourceResumeItemResReq
#[derive(Clone, Debug)]
pub struct PduSessionResourceResumeItemResReq {
    pub pdu_session_id: PduSessionId,
    pub ue_context_resume_request_transfer: Vec<u8>,
}

impl PduSessionResourceResumeItemResReq {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let pdu_session_id = PduSessionId::decode(data)?;
        let ue_context_resume_request_transfer =
            decode::decode_octetstring(data, None, None, false)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            pdu_session_id,
            ue_context_resume_request_transfer,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.pdu_session_id.encode(data)?;
        encode::encode_octetstring(
            data,
            None,
            None,
            false,
            &self.ue_context_resume_request_transfer,
            false,
        )?;

        Ok(())
    }
}

impl PerCodec for PduSessionResourceResumeItemResReq {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PduSessionResourceResumeItemResReq::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PduSessionResourceResumeItemResReq");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PduSessionResourceResumeItemResReq");
            e
        })
    }
}
// PduSessionResourceResumeListResRes
#[derive(Clone, Debug)]
pub struct PduSessionResourceResumeListResRes(pub NonEmpty<PduSessionResourceResumeItemResRes>);

impl PduSessionResourceResumeListResRes {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(256), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(PduSessionResourceResumeItemResRes::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(256), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for PduSessionResourceResumeListResRes {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PduSessionResourceResumeListResRes::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PduSessionResourceResumeListResRes");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PduSessionResourceResumeListResRes");
            e
        })
    }
}
// PduSessionResourceResumeItemResRes
#[derive(Clone, Debug)]
pub struct PduSessionResourceResumeItemResRes {
    pub pdu_session_id: PduSessionId,
    pub ue_context_resume_response_transfer: Vec<u8>,
}

impl PduSessionResourceResumeItemResRes {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let pdu_session_id = PduSessionId::decode(data)?;
        let ue_context_resume_response_transfer =
            decode::decode_octetstring(data, None, None, false)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            pdu_session_id,
            ue_context_resume_response_transfer,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.pdu_session_id.encode(data)?;
        encode::encode_octetstring(
            data,
            None,
            None,
            false,
            &self.ue_context_resume_response_transfer,
            false,
        )?;

        Ok(())
    }
}

impl PerCodec for PduSessionResourceResumeItemResRes {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PduSessionResourceResumeItemResRes::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PduSessionResourceResumeItemResRes");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PduSessionResourceResumeItemResRes");
            e
        })
    }
}
// PduSessionResourceSecondaryRatUsageList
#[derive(Clone, Debug)]
pub struct PduSessionResourceSecondaryRatUsageList(
    pub NonEmpty<PduSessionResourceSecondaryRatUsageItem>,
);

impl PduSessionResourceSecondaryRatUsageList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(256), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(PduSessionResourceSecondaryRatUsageItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(256), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for PduSessionResourceSecondaryRatUsageList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PduSessionResourceSecondaryRatUsageList::decode_inner(data).map_err(
            |mut e: PerCodecError| {
                e.push_context("PduSessionResourceSecondaryRatUsageList");
                e
            },
        )
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PduSessionResourceSecondaryRatUsageList");
            e
        })
    }
}
// PduSessionResourceSecondaryRatUsageItem
#[derive(Clone, Debug)]
pub struct PduSessionResourceSecondaryRatUsageItem {
    pub pdu_session_id: PduSessionId,
    pub secondary_rat_data_usage_report_transfer: Vec<u8>,
}

impl PduSessionResourceSecondaryRatUsageItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let pdu_session_id = PduSessionId::decode(data)?;
        let secondary_rat_data_usage_report_transfer =
            decode::decode_octetstring(data, None, None, false)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            pdu_session_id,
            secondary_rat_data_usage_report_transfer,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.pdu_session_id.encode(data)?;
        encode::encode_octetstring(
            data,
            None,
            None,
            false,
            &self.secondary_rat_data_usage_report_transfer,
            false,
        )?;

        Ok(())
    }
}

impl PerCodec for PduSessionResourceSecondaryRatUsageItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PduSessionResourceSecondaryRatUsageItem::decode_inner(data).map_err(
            |mut e: PerCodecError| {
                e.push_context("PduSessionResourceSecondaryRatUsageItem");
                e
            },
        )
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PduSessionResourceSecondaryRatUsageItem");
            e
        })
    }
}
// PduSessionResourceSetupListCxtReq
#[derive(Clone, Debug)]
pub struct PduSessionResourceSetupListCxtReq(pub NonEmpty<PduSessionResourceSetupItemCxtReq>);

impl PduSessionResourceSetupListCxtReq {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(256), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(PduSessionResourceSetupItemCxtReq::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(256), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for PduSessionResourceSetupListCxtReq {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PduSessionResourceSetupListCxtReq::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PduSessionResourceSetupListCxtReq");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PduSessionResourceSetupListCxtReq");
            e
        })
    }
}
// PduSessionResourceSetupItemCxtReq
#[derive(Clone, Debug)]
pub struct PduSessionResourceSetupItemCxtReq {
    pub pdu_session_id: PduSessionId,
    pub nas_pdu: Option<NasPdu>,
    pub snssai: Snssai,
    pub pdu_session_resource_setup_request_transfer: Vec<u8>,
}

impl PduSessionResourceSetupItemCxtReq {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 2)?;
        let pdu_session_id = PduSessionId::decode(data)?;
        let nas_pdu = if optionals[0] {
            Some(NasPdu::decode(data)?)
        } else {
            None
        };
        let snssai = Snssai::decode(data)?;
        let pdu_session_resource_setup_request_transfer =
            decode::decode_octetstring(data, None, None, false)?;

        // Process the extension container

        if optionals[1] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            pdu_session_id,
            nas_pdu,
            snssai,
            pdu_session_resource_setup_request_transfer,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.nas_pdu.is_some());
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.pdu_session_id.encode(data)?;
        if let Some(x) = &self.nas_pdu {
            x.encode(data)?;
        }
        self.snssai.encode(data)?;
        encode::encode_octetstring(
            data,
            None,
            None,
            false,
            &self.pdu_session_resource_setup_request_transfer,
            false,
        )?;

        Ok(())
    }
}

impl PerCodec for PduSessionResourceSetupItemCxtReq {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PduSessionResourceSetupItemCxtReq::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PduSessionResourceSetupItemCxtReq");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PduSessionResourceSetupItemCxtReq");
            e
        })
    }
}
// PduSessionResourceSetupListCxtRes
#[derive(Clone, Debug)]
pub struct PduSessionResourceSetupListCxtRes(pub NonEmpty<PduSessionResourceSetupItemCxtRes>);

impl PduSessionResourceSetupListCxtRes {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(256), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(PduSessionResourceSetupItemCxtRes::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(256), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for PduSessionResourceSetupListCxtRes {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PduSessionResourceSetupListCxtRes::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PduSessionResourceSetupListCxtRes");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PduSessionResourceSetupListCxtRes");
            e
        })
    }
}
// PduSessionResourceSetupItemCxtRes
#[derive(Clone, Debug)]
pub struct PduSessionResourceSetupItemCxtRes {
    pub pdu_session_id: PduSessionId,
    pub pdu_session_resource_setup_response_transfer: Vec<u8>,
}

impl PduSessionResourceSetupItemCxtRes {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let pdu_session_id = PduSessionId::decode(data)?;
        let pdu_session_resource_setup_response_transfer =
            decode::decode_octetstring(data, None, None, false)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            pdu_session_id,
            pdu_session_resource_setup_response_transfer,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.pdu_session_id.encode(data)?;
        encode::encode_octetstring(
            data,
            None,
            None,
            false,
            &self.pdu_session_resource_setup_response_transfer,
            false,
        )?;

        Ok(())
    }
}

impl PerCodec for PduSessionResourceSetupItemCxtRes {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PduSessionResourceSetupItemCxtRes::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PduSessionResourceSetupItemCxtRes");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PduSessionResourceSetupItemCxtRes");
            e
        })
    }
}
// PduSessionResourceSetupListHoReq
#[derive(Clone, Debug)]
pub struct PduSessionResourceSetupListHoReq(pub NonEmpty<PduSessionResourceSetupItemHoReq>);

impl PduSessionResourceSetupListHoReq {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(256), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(PduSessionResourceSetupItemHoReq::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(256), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for PduSessionResourceSetupListHoReq {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PduSessionResourceSetupListHoReq::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PduSessionResourceSetupListHoReq");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PduSessionResourceSetupListHoReq");
            e
        })
    }
}
// PduSessionResourceSetupItemHoReq
#[derive(Clone, Debug)]
pub struct PduSessionResourceSetupItemHoReq {
    pub pdu_session_id: PduSessionId,
    pub snssai: Snssai,
    pub handover_request_transfer: Vec<u8>,
}

impl PduSessionResourceSetupItemHoReq {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let pdu_session_id = PduSessionId::decode(data)?;
        let snssai = Snssai::decode(data)?;
        let handover_request_transfer = decode::decode_octetstring(data, None, None, false)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            pdu_session_id,
            snssai,
            handover_request_transfer,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.pdu_session_id.encode(data)?;
        self.snssai.encode(data)?;
        encode::encode_octetstring(
            data,
            None,
            None,
            false,
            &self.handover_request_transfer,
            false,
        )?;

        Ok(())
    }
}

impl PerCodec for PduSessionResourceSetupItemHoReq {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PduSessionResourceSetupItemHoReq::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PduSessionResourceSetupItemHoReq");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PduSessionResourceSetupItemHoReq");
            e
        })
    }
}
// PduSessionResourceSetupListSuReq
#[derive(Clone, Debug)]
pub struct PduSessionResourceSetupListSuReq(pub NonEmpty<PduSessionResourceSetupItemSuReq>);

impl PduSessionResourceSetupListSuReq {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(256), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(PduSessionResourceSetupItemSuReq::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(256), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for PduSessionResourceSetupListSuReq {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PduSessionResourceSetupListSuReq::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PduSessionResourceSetupListSuReq");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PduSessionResourceSetupListSuReq");
            e
        })
    }
}
// PduSessionResourceSetupItemSuReq
#[derive(Clone, Debug)]
pub struct PduSessionResourceSetupItemSuReq {
    pub pdu_session_id: PduSessionId,
    pub pdu_session_nas_pdu: Option<NasPdu>,
    pub snssai: Snssai,
    pub pdu_session_resource_setup_request_transfer: Vec<u8>,
}

impl PduSessionResourceSetupItemSuReq {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 2)?;
        let pdu_session_id = PduSessionId::decode(data)?;
        let pdu_session_nas_pdu = if optionals[0] {
            Some(NasPdu::decode(data)?)
        } else {
            None
        };
        let snssai = Snssai::decode(data)?;
        let pdu_session_resource_setup_request_transfer =
            decode::decode_octetstring(data, None, None, false)?;

        // Process the extension container

        if optionals[1] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            pdu_session_id,
            pdu_session_nas_pdu,
            snssai,
            pdu_session_resource_setup_request_transfer,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.pdu_session_nas_pdu.is_some());
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.pdu_session_id.encode(data)?;
        if let Some(x) = &self.pdu_session_nas_pdu {
            x.encode(data)?;
        }
        self.snssai.encode(data)?;
        encode::encode_octetstring(
            data,
            None,
            None,
            false,
            &self.pdu_session_resource_setup_request_transfer,
            false,
        )?;

        Ok(())
    }
}

impl PerCodec for PduSessionResourceSetupItemSuReq {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PduSessionResourceSetupItemSuReq::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PduSessionResourceSetupItemSuReq");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PduSessionResourceSetupItemSuReq");
            e
        })
    }
}
// PduSessionResourceSetupListSuRes
#[derive(Clone, Debug)]
pub struct PduSessionResourceSetupListSuRes(pub NonEmpty<PduSessionResourceSetupItemSuRes>);

impl PduSessionResourceSetupListSuRes {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(256), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(PduSessionResourceSetupItemSuRes::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(256), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for PduSessionResourceSetupListSuRes {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PduSessionResourceSetupListSuRes::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PduSessionResourceSetupListSuRes");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PduSessionResourceSetupListSuRes");
            e
        })
    }
}
// PduSessionResourceSetupItemSuRes
#[derive(Clone, Debug)]
pub struct PduSessionResourceSetupItemSuRes {
    pub pdu_session_id: PduSessionId,
    pub pdu_session_resource_setup_response_transfer: Vec<u8>,
}

impl PduSessionResourceSetupItemSuRes {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let pdu_session_id = PduSessionId::decode(data)?;
        let pdu_session_resource_setup_response_transfer =
            decode::decode_octetstring(data, None, None, false)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            pdu_session_id,
            pdu_session_resource_setup_response_transfer,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.pdu_session_id.encode(data)?;
        encode::encode_octetstring(
            data,
            None,
            None,
            false,
            &self.pdu_session_resource_setup_response_transfer,
            false,
        )?;

        Ok(())
    }
}

impl PerCodec for PduSessionResourceSetupItemSuRes {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PduSessionResourceSetupItemSuRes::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PduSessionResourceSetupItemSuRes");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PduSessionResourceSetupItemSuRes");
            e
        })
    }
}
// PduSessionResourceSetupRequestTransfer
#[derive(Clone, Debug)]
pub struct PduSessionResourceSetupRequestTransfer {
    pub pdu_session_aggregate_maximum_bit_rate: Option<PduSessionAggregateMaximumBitRate>,
    pub ul_ngu_up_tnl_information: UpTransportLayerInformation,
    pub additional_ul_ngu_up_tnl_information: Option<UpTransportLayerInformationList>,
    pub data_forwarding_not_possible: Option<DataForwardingNotPossible>,
    pub pdu_session_type: PduSessionType,
    pub security_indication: Option<SecurityIndication>,
    pub network_instance: Option<NetworkInstance>,
    pub qos_flow_setup_request_list: QosFlowSetupRequestList,
    pub common_network_instance: Option<CommonNetworkInstance>,
    pub direct_forwarding_path_availability: Option<DirectForwardingPathAvailability>,
    pub redundant_ul_ngu_up_tnl_information: Option<UpTransportLayerInformation>,
    pub additional_redundant_ul_ngu_up_tnl_information: Option<UpTransportLayerInformationList>,
    pub redundant_common_network_instance: Option<CommonNetworkInstance>,
    pub redundant_pdu_session_information: Option<RedundantPduSessionInformation>,
}

impl PduSessionResourceSetupRequestTransfer {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let _ = decode::decode_sequence_header(data, true, 0)?;
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut pdu_session_aggregate_maximum_bit_rate: Option<PduSessionAggregateMaximumBitRate> =
            None;
        let mut ul_ngu_up_tnl_information: Option<UpTransportLayerInformation> = None;
        let mut additional_ul_ngu_up_tnl_information: Option<UpTransportLayerInformationList> =
            None;
        let mut data_forwarding_not_possible: Option<DataForwardingNotPossible> = None;
        let mut pdu_session_type: Option<PduSessionType> = None;
        let mut security_indication: Option<SecurityIndication> = None;
        let mut network_instance: Option<NetworkInstance> = None;
        let mut qos_flow_setup_request_list: Option<QosFlowSetupRequestList> = None;
        let mut common_network_instance: Option<CommonNetworkInstance> = None;
        let mut direct_forwarding_path_availability: Option<DirectForwardingPathAvailability> =
            None;
        let mut redundant_ul_ngu_up_tnl_information: Option<UpTransportLayerInformation> = None;
        let mut additional_redundant_ul_ngu_up_tnl_information: Option<
            UpTransportLayerInformationList,
        > = None;
        let mut redundant_common_network_instance: Option<CommonNetworkInstance> = None;
        let mut redundant_pdu_session_information: Option<RedundantPduSessionInformation> = None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                130 => {
                    pdu_session_aggregate_maximum_bit_rate =
                        Some(PduSessionAggregateMaximumBitRate::decode(data)?)
                }
                139 => ul_ngu_up_tnl_information = Some(UpTransportLayerInformation::decode(data)?),
                126 => {
                    additional_ul_ngu_up_tnl_information =
                        Some(UpTransportLayerInformationList::decode(data)?)
                }
                127 => {
                    data_forwarding_not_possible = Some(DataForwardingNotPossible::decode(data)?)
                }
                134 => pdu_session_type = Some(PduSessionType::decode(data)?),
                138 => security_indication = Some(SecurityIndication::decode(data)?),
                129 => network_instance = Some(NetworkInstance::decode(data)?),
                136 => qos_flow_setup_request_list = Some(QosFlowSetupRequestList::decode(data)?),
                166 => common_network_instance = Some(CommonNetworkInstance::decode(data)?),
                22 => {
                    direct_forwarding_path_availability =
                        Some(DirectForwardingPathAvailability::decode(data)?)
                }
                195 => {
                    redundant_ul_ngu_up_tnl_information =
                        Some(UpTransportLayerInformation::decode(data)?)
                }
                186 => {
                    additional_redundant_ul_ngu_up_tnl_information =
                        Some(UpTransportLayerInformationList::decode(data)?)
                }
                190 => {
                    redundant_common_network_instance = Some(CommonNetworkInstance::decode(data)?)
                }
                197 => {
                    redundant_pdu_session_information =
                        Some(RedundantPduSessionInformation::decode(data)?)
                }
                x => return Err(PerCodecError::new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        let ul_ngu_up_tnl_information = ul_ngu_up_tnl_information.ok_or(PerCodecError::new(
            format!("Missing mandatory IE ul_ngu_up_tnl_information"),
        ))?;
        let pdu_session_type = pdu_session_type.ok_or(PerCodecError::new(format!(
            "Missing mandatory IE pdu_session_type"
        )))?;
        let qos_flow_setup_request_list = qos_flow_setup_request_list.ok_or(PerCodecError::new(
            format!("Missing mandatory IE qos_flow_setup_request_list"),
        ))?;
        Ok(Self {
            pdu_session_aggregate_maximum_bit_rate,
            ul_ngu_up_tnl_information,
            additional_ul_ngu_up_tnl_information,
            data_forwarding_not_possible,
            pdu_session_type,
            security_indication,
            network_instance,
            qos_flow_setup_request_list,
            common_network_instance,
            direct_forwarding_path_availability,
            redundant_ul_ngu_up_tnl_information,
            additional_redundant_ul_ngu_up_tnl_information,
            redundant_common_network_instance,
            redundant_pdu_session_information,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        if let Some(x) = &self.pdu_session_aggregate_maximum_bit_rate {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 130, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        let ie = &mut Allocator::new_codec_data();
        self.ul_ngu_up_tnl_information.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 139, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        if let Some(x) = &self.additional_ul_ngu_up_tnl_information {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 126, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.data_forwarding_not_possible {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 127, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        let ie = &mut Allocator::new_codec_data();
        self.pdu_session_type.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 134, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        if let Some(x) = &self.security_indication {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 138, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.network_instance {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 129, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        let ie = &mut Allocator::new_codec_data();
        self.qos_flow_setup_request_list.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 136, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        if let Some(x) = &self.common_network_instance {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 166, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.direct_forwarding_path_availability {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 22, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.redundant_ul_ngu_up_tnl_information {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 195, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.additional_redundant_ul_ngu_up_tnl_information {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 186, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.redundant_common_network_instance {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 190, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.redundant_pdu_session_information {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 197, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        encode::encode_sequence_header(data, true, &BitString::new(), false)?;
        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for PduSessionResourceSetupRequestTransfer {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PduSessionResourceSetupRequestTransfer::decode_inner(data).map_err(
            |mut e: PerCodecError| {
                e.push_context("PduSessionResourceSetupRequestTransfer");
                e
            },
        )
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PduSessionResourceSetupRequestTransfer");
            e
        })
    }
}
// PduSessionResourceSetupResponseTransfer
#[derive(Clone, Debug)]
pub struct PduSessionResourceSetupResponseTransfer {
    pub dl_qos_flow_per_tnl_information: QosFlowPerTnlInformation,
    pub additional_dl_qos_flow_per_tnl_information: Option<QosFlowPerTnlInformationList>,
    pub security_result: Option<SecurityResult>,
    pub qos_flow_failed_to_setup_list: Option<QosFlowListWithCause>,
    pub redundant_dl_qos_flow_per_tnl_information: Option<QosFlowPerTnlInformation>,
    pub additional_redundant_dl_qos_flow_per_tnl_information: Option<QosFlowPerTnlInformationList>,
    pub used_rsn_information: Option<RedundantPduSessionInformation>,
    pub global_ran_node_id: Option<GlobalRanNodeId>,
}

impl PduSessionResourceSetupResponseTransfer {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 4)?;
        let dl_qos_flow_per_tnl_information = QosFlowPerTnlInformation::decode(data)?;
        let additional_dl_qos_flow_per_tnl_information = if optionals[0] {
            Some(QosFlowPerTnlInformationList::decode(data)?)
        } else {
            None
        };
        let security_result = if optionals[1] {
            Some(SecurityResult::decode(data)?)
        } else {
            None
        };
        let qos_flow_failed_to_setup_list = if optionals[2] {
            Some(QosFlowListWithCause::decode(data)?)
        } else {
            None
        };

        // Process the extension container
        let mut redundant_dl_qos_flow_per_tnl_information: Option<QosFlowPerTnlInformation> = None;
        let mut additional_redundant_dl_qos_flow_per_tnl_information: Option<
            QosFlowPerTnlInformationList,
        > = None;
        let mut used_rsn_information: Option<RedundantPduSessionInformation> = None;
        let mut global_ran_node_id: Option<GlobalRanNodeId> = None;

        if optionals[3] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    193 => {
                        redundant_dl_qos_flow_per_tnl_information =
                            Some(QosFlowPerTnlInformation::decode(data)?)
                    }
                    184 => {
                        additional_redundant_dl_qos_flow_per_tnl_information =
                            Some(QosFlowPerTnlInformationList::decode(data)?)
                    }
                    198 => {
                        used_rsn_information = Some(RedundantPduSessionInformation::decode(data)?)
                    }
                    27 => global_ran_node_id = Some(GlobalRanNodeId::decode(data)?),
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            dl_qos_flow_per_tnl_information,
            additional_dl_qos_flow_per_tnl_information,
            security_result,
            qos_flow_failed_to_setup_list,
            redundant_dl_qos_flow_per_tnl_information,
            additional_redundant_dl_qos_flow_per_tnl_information,
            used_rsn_information,
            global_ran_node_id,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();
        if let Some(x) = &self.redundant_dl_qos_flow_per_tnl_information {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 193, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.additional_redundant_dl_qos_flow_per_tnl_information {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 184, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.used_rsn_information {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 198, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.global_ran_node_id {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 27, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        let mut optionals = BitString::new();
        optionals.push(self.additional_dl_qos_flow_per_tnl_information.is_some());
        optionals.push(self.security_result.is_some());
        optionals.push(self.qos_flow_failed_to_setup_list.is_some());
        optionals.push(num_ies != 0);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.dl_qos_flow_per_tnl_information.encode(data)?;
        if let Some(x) = &self.additional_dl_qos_flow_per_tnl_information {
            x.encode(data)?;
        }
        if let Some(x) = &self.security_result {
            x.encode(data)?;
        }
        if let Some(x) = &self.qos_flow_failed_to_setup_list {
            x.encode(data)?;
        }
        if num_ies != 0 {
            encode::encode_length_determinent(data, Some(1), Some(65535), false, num_ies)?;
            data.append_aligned(ies);
        }
        Ok(())
    }
}

impl PerCodec for PduSessionResourceSetupResponseTransfer {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PduSessionResourceSetupResponseTransfer::decode_inner(data).map_err(
            |mut e: PerCodecError| {
                e.push_context("PduSessionResourceSetupResponseTransfer");
                e
            },
        )
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PduSessionResourceSetupResponseTransfer");
            e
        })
    }
}
// PduSessionResourceSetupUnsuccessfulTransfer
#[derive(Clone, Debug)]
pub struct PduSessionResourceSetupUnsuccessfulTransfer {
    pub cause: Cause,
    pub criticality_diagnostics: Option<CriticalityDiagnostics>,
}

impl PduSessionResourceSetupUnsuccessfulTransfer {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 2)?;
        let cause = Cause::decode(data)?;
        let criticality_diagnostics = if optionals[0] {
            Some(CriticalityDiagnostics::decode(data)?)
        } else {
            None
        };

        // Process the extension container

        if optionals[1] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            cause,
            criticality_diagnostics,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.criticality_diagnostics.is_some());
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.cause.encode(data)?;
        if let Some(x) = &self.criticality_diagnostics {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl PerCodec for PduSessionResourceSetupUnsuccessfulTransfer {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PduSessionResourceSetupUnsuccessfulTransfer::decode_inner(data).map_err(
            |mut e: PerCodecError| {
                e.push_context("PduSessionResourceSetupUnsuccessfulTransfer");
                e
            },
        )
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PduSessionResourceSetupUnsuccessfulTransfer");
            e
        })
    }
}
// PduSessionResourceSuspendListSusReq
#[derive(Clone, Debug)]
pub struct PduSessionResourceSuspendListSusReq(pub NonEmpty<PduSessionResourceSuspendItemSusReq>);

impl PduSessionResourceSuspendListSusReq {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(256), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(PduSessionResourceSuspendItemSusReq::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(256), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for PduSessionResourceSuspendListSusReq {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PduSessionResourceSuspendListSusReq::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PduSessionResourceSuspendListSusReq");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PduSessionResourceSuspendListSusReq");
            e
        })
    }
}
// PduSessionResourceSuspendItemSusReq
#[derive(Clone, Debug)]
pub struct PduSessionResourceSuspendItemSusReq {
    pub pdu_session_id: PduSessionId,
    pub ue_context_suspend_request_transfer: Vec<u8>,
}

impl PduSessionResourceSuspendItemSusReq {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let pdu_session_id = PduSessionId::decode(data)?;
        let ue_context_suspend_request_transfer =
            decode::decode_octetstring(data, None, None, false)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            pdu_session_id,
            ue_context_suspend_request_transfer,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.pdu_session_id.encode(data)?;
        encode::encode_octetstring(
            data,
            None,
            None,
            false,
            &self.ue_context_suspend_request_transfer,
            false,
        )?;

        Ok(())
    }
}

impl PerCodec for PduSessionResourceSuspendItemSusReq {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PduSessionResourceSuspendItemSusReq::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PduSessionResourceSuspendItemSusReq");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PduSessionResourceSuspendItemSusReq");
            e
        })
    }
}
// PduSessionResourceSwitchedList
#[derive(Clone, Debug)]
pub struct PduSessionResourceSwitchedList(pub NonEmpty<PduSessionResourceSwitchedItem>);

impl PduSessionResourceSwitchedList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(256), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(PduSessionResourceSwitchedItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(256), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for PduSessionResourceSwitchedList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PduSessionResourceSwitchedList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PduSessionResourceSwitchedList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PduSessionResourceSwitchedList");
            e
        })
    }
}
// PduSessionResourceSwitchedItem
#[derive(Clone, Debug)]
pub struct PduSessionResourceSwitchedItem {
    pub pdu_session_id: PduSessionId,
    pub path_switch_request_acknowledge_transfer: Vec<u8>,
}

impl PduSessionResourceSwitchedItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let pdu_session_id = PduSessionId::decode(data)?;
        let path_switch_request_acknowledge_transfer =
            decode::decode_octetstring(data, None, None, false)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            pdu_session_id,
            path_switch_request_acknowledge_transfer,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.pdu_session_id.encode(data)?;
        encode::encode_octetstring(
            data,
            None,
            None,
            false,
            &self.path_switch_request_acknowledge_transfer,
            false,
        )?;

        Ok(())
    }
}

impl PerCodec for PduSessionResourceSwitchedItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PduSessionResourceSwitchedItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PduSessionResourceSwitchedItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PduSessionResourceSwitchedItem");
            e
        })
    }
}
// PduSessionResourceToBeSwitchedDlList
#[derive(Clone, Debug)]
pub struct PduSessionResourceToBeSwitchedDlList(pub NonEmpty<PduSessionResourceToBeSwitchedDlItem>);

impl PduSessionResourceToBeSwitchedDlList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(256), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(PduSessionResourceToBeSwitchedDlItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(256), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for PduSessionResourceToBeSwitchedDlList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PduSessionResourceToBeSwitchedDlList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PduSessionResourceToBeSwitchedDlList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PduSessionResourceToBeSwitchedDlList");
            e
        })
    }
}
// PduSessionResourceToBeSwitchedDlItem
#[derive(Clone, Debug)]
pub struct PduSessionResourceToBeSwitchedDlItem {
    pub pdu_session_id: PduSessionId,
    pub path_switch_request_transfer: Vec<u8>,
}

impl PduSessionResourceToBeSwitchedDlItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let pdu_session_id = PduSessionId::decode(data)?;
        let path_switch_request_transfer = decode::decode_octetstring(data, None, None, false)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            pdu_session_id,
            path_switch_request_transfer,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.pdu_session_id.encode(data)?;
        encode::encode_octetstring(
            data,
            None,
            None,
            false,
            &self.path_switch_request_transfer,
            false,
        )?;

        Ok(())
    }
}

impl PerCodec for PduSessionResourceToBeSwitchedDlItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PduSessionResourceToBeSwitchedDlItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PduSessionResourceToBeSwitchedDlItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PduSessionResourceToBeSwitchedDlItem");
            e
        })
    }
}
// PduSessionResourceToReleaseListHoCmd
#[derive(Clone, Debug)]
pub struct PduSessionResourceToReleaseListHoCmd(pub NonEmpty<PduSessionResourceToReleaseItemHoCmd>);

impl PduSessionResourceToReleaseListHoCmd {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(256), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(PduSessionResourceToReleaseItemHoCmd::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(256), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for PduSessionResourceToReleaseListHoCmd {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PduSessionResourceToReleaseListHoCmd::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PduSessionResourceToReleaseListHoCmd");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PduSessionResourceToReleaseListHoCmd");
            e
        })
    }
}
// PduSessionResourceToReleaseItemHoCmd
#[derive(Clone, Debug)]
pub struct PduSessionResourceToReleaseItemHoCmd {
    pub pdu_session_id: PduSessionId,
    pub handover_preparation_unsuccessful_transfer: Vec<u8>,
}

impl PduSessionResourceToReleaseItemHoCmd {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let pdu_session_id = PduSessionId::decode(data)?;
        let handover_preparation_unsuccessful_transfer =
            decode::decode_octetstring(data, None, None, false)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            pdu_session_id,
            handover_preparation_unsuccessful_transfer,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.pdu_session_id.encode(data)?;
        encode::encode_octetstring(
            data,
            None,
            None,
            false,
            &self.handover_preparation_unsuccessful_transfer,
            false,
        )?;

        Ok(())
    }
}

impl PerCodec for PduSessionResourceToReleaseItemHoCmd {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PduSessionResourceToReleaseItemHoCmd::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PduSessionResourceToReleaseItemHoCmd");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PduSessionResourceToReleaseItemHoCmd");
            e
        })
    }
}
// PduSessionResourceToReleaseListRelCmd
#[derive(Clone, Debug)]
pub struct PduSessionResourceToReleaseListRelCmd(
    pub NonEmpty<PduSessionResourceToReleaseItemRelCmd>,
);

impl PduSessionResourceToReleaseListRelCmd {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(256), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(PduSessionResourceToReleaseItemRelCmd::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(256), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for PduSessionResourceToReleaseListRelCmd {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PduSessionResourceToReleaseListRelCmd::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PduSessionResourceToReleaseListRelCmd");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PduSessionResourceToReleaseListRelCmd");
            e
        })
    }
}
// PduSessionResourceToReleaseItemRelCmd
#[derive(Clone, Debug)]
pub struct PduSessionResourceToReleaseItemRelCmd {
    pub pdu_session_id: PduSessionId,
    pub pdu_session_resource_release_command_transfer: Vec<u8>,
}

impl PduSessionResourceToReleaseItemRelCmd {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let pdu_session_id = PduSessionId::decode(data)?;
        let pdu_session_resource_release_command_transfer =
            decode::decode_octetstring(data, None, None, false)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            pdu_session_id,
            pdu_session_resource_release_command_transfer,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.pdu_session_id.encode(data)?;
        encode::encode_octetstring(
            data,
            None,
            None,
            false,
            &self.pdu_session_resource_release_command_transfer,
            false,
        )?;

        Ok(())
    }
}

impl PerCodec for PduSessionResourceToReleaseItemRelCmd {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PduSessionResourceToReleaseItemRelCmd::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PduSessionResourceToReleaseItemRelCmd");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PduSessionResourceToReleaseItemRelCmd");
            e
        })
    }
}
// PduSessionType
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum PduSessionType {
    Ipv4,
    Ipv6,
    Ipv4v6,
    Ethernet,
    Unstructured,
}

impl PduSessionType {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(4), true)?;
        if extended {
            return Err(PerCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(data, Some(0), Some(4), true, *self as i128, false)
    }
}

impl PerCodec for PduSessionType {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PduSessionType::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PduSessionType");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PduSessionType");
            e
        })
    }
}
// PduSessionUsageReport
#[derive(Clone, Debug)]
pub struct PduSessionUsageReport {
    pub rat_type: RatType,
    pub pdu_session_timed_report_list: VolumeTimedReportList,
}

impl PduSessionUsageReport {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let rat_type = RatType::decode(data)?;
        let pdu_session_timed_report_list = VolumeTimedReportList::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            rat_type,
            pdu_session_timed_report_list,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.rat_type.encode(data)?;
        self.pdu_session_timed_report_list.encode(data)?;

        Ok(())
    }
}

impl PerCodec for PduSessionUsageReport {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PduSessionUsageReport::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PduSessionUsageReport");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PduSessionUsageReport");
            e
        })
    }
}
// Periodicity
#[derive(Clone, Copy, Debug)]
pub struct Periodicity(pub u32);

impl Periodicity {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(
            decode::decode_integer(data, Some(0), Some(640000), true)?.0 as u32,
        ))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_integer(data, Some(0), Some(640000), true, self.0 as i128, false)
    }
}

impl PerCodec for Periodicity {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Periodicity::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("Periodicity");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("Periodicity");
            e
        })
    }
}
// PeriodicRegistrationUpdateTimer
#[derive(Clone, Debug)]
pub struct PeriodicRegistrationUpdateTimer(pub BitString);

impl PeriodicRegistrationUpdateTimer {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(decode::decode_bitstring(
            data,
            Some(8),
            Some(8),
            false,
        )?))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_bitstring(data, Some(8), Some(8), false, &self.0, false)
    }
}

impl PerCodec for PeriodicRegistrationUpdateTimer {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PeriodicRegistrationUpdateTimer::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PeriodicRegistrationUpdateTimer");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PeriodicRegistrationUpdateTimer");
            e
        })
    }
}
// PlmnIdentity
#[derive(Clone, Debug)]
pub struct PlmnIdentity(pub [u8; 3]);

impl PlmnIdentity {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(
            decode::decode_octetstring(data, Some(3), Some(3), false)?
                .try_into()
                .unwrap(),
        ))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_octetstring(data, Some(3), Some(3), false, &(self.0).into(), false)
    }
}

impl PerCodec for PlmnIdentity {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PlmnIdentity::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PlmnIdentity");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PlmnIdentity");
            e
        })
    }
}
// PlmnSupportList
#[derive(Clone, Debug)]
pub struct PlmnSupportList(pub NonEmpty<PlmnSupportItem>);

impl PlmnSupportList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(12), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(PlmnSupportItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(12), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for PlmnSupportList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PlmnSupportList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PlmnSupportList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PlmnSupportList");
            e
        })
    }
}
// PlmnSupportItem
#[derive(Clone, Debug)]
pub struct PlmnSupportItem {
    pub plmn_identity: PlmnIdentity,
    pub slice_support_list: SliceSupportList,
    pub npn_support: Option<NpnSupport>,
    pub extended_slice_support_list: Option<ExtendedSliceSupportList>,
}

impl PlmnSupportItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let plmn_identity = PlmnIdentity::decode(data)?;
        let slice_support_list = SliceSupportList::decode(data)?;

        // Process the extension container
        let mut npn_support: Option<NpnSupport> = None;
        let mut extended_slice_support_list: Option<ExtendedSliceSupportList> = None;

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    258 => npn_support = Some(NpnSupport::decode(data)?),
                    270 => {
                        extended_slice_support_list = Some(ExtendedSliceSupportList::decode(data)?)
                    }
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            plmn_identity,
            slice_support_list,
            npn_support,
            extended_slice_support_list,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();
        if let Some(x) = &self.npn_support {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 258, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.extended_slice_support_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 270, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        let mut optionals = BitString::new();
        optionals.push(num_ies != 0);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.plmn_identity.encode(data)?;
        self.slice_support_list.encode(data)?;
        if num_ies != 0 {
            encode::encode_length_determinent(data, Some(1), Some(65535), false, num_ies)?;
            data.append_aligned(ies);
        }
        Ok(())
    }
}

impl PerCodec for PlmnSupportItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PlmnSupportItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PlmnSupportItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PlmnSupportItem");
            e
        })
    }
}
// PniNpnMobilityInformation
#[derive(Clone, Debug)]
pub struct PniNpnMobilityInformation {
    pub allowed_pni_npi_list: AllowedPniNpnList,
}

impl PniNpnMobilityInformation {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let allowed_pni_npi_list = AllowedPniNpnList::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            allowed_pni_npi_list,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.allowed_pni_npi_list.encode(data)?;

        Ok(())
    }
}

impl PerCodec for PniNpnMobilityInformation {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PniNpnMobilityInformation::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PniNpnMobilityInformation");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PniNpnMobilityInformation");
            e
        })
    }
}
// PortNumber
#[derive(Clone, Debug)]
pub struct PortNumber(pub [u8; 2]);

impl PortNumber {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(
            decode::decode_octetstring(data, Some(2), Some(2), false)?
                .try_into()
                .unwrap(),
        ))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_octetstring(data, Some(2), Some(2), false, &(self.0).into(), false)
    }
}

impl PerCodec for PortNumber {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PortNumber::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PortNumber");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PortNumber");
            e
        })
    }
}
// PreEmptionCapability
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum PreEmptionCapability {
    ShallNotTriggerPreEmption,
    MayTriggerPreEmption,
}

impl PreEmptionCapability {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(1), true)?;
        if extended {
            return Err(PerCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(data, Some(0), Some(1), true, *self as i128, false)
    }
}

impl PerCodec for PreEmptionCapability {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PreEmptionCapability::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PreEmptionCapability");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PreEmptionCapability");
            e
        })
    }
}
// PreEmptionVulnerability
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum PreEmptionVulnerability {
    NotPreEmptable,
    PreEmptable,
}

impl PreEmptionVulnerability {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(1), true)?;
        if extended {
            return Err(PerCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(data, Some(0), Some(1), true, *self as i128, false)
    }
}

impl PerCodec for PreEmptionVulnerability {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PreEmptionVulnerability::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PreEmptionVulnerability");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PreEmptionVulnerability");
            e
        })
    }
}
// PriorityLevelArp
#[derive(Clone, Copy, Debug)]
pub struct PriorityLevelArp(pub u8);

impl PriorityLevelArp {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(
            decode::decode_integer(data, Some(1), Some(15), false)?.0 as u8,
        ))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_integer(data, Some(1), Some(15), false, self.0 as i128, false)
    }
}

impl PerCodec for PriorityLevelArp {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PriorityLevelArp::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PriorityLevelArp");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PriorityLevelArp");
            e
        })
    }
}
// PriorityLevelQos
#[derive(Clone, Copy, Debug)]
pub struct PriorityLevelQos(pub u8);

impl PriorityLevelQos {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(
            decode::decode_integer(data, Some(1), Some(127), true)?.0 as u8,
        ))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_integer(data, Some(1), Some(127), true, self.0 as i128, false)
    }
}

impl PerCodec for PriorityLevelQos {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PriorityLevelQos::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PriorityLevelQos");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PriorityLevelQos");
            e
        })
    }
}
// PwsFailedCellIdList
#[derive(Clone, Debug)]
pub enum PwsFailedCellIdList {
    EutraCgiPwsFailedList(EutraCgiList),
    NrCgiPwsFailedList(NrCgiList),
}

impl PwsFailedCellIdList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_choice_idx(data, 0, 2, false)?;
        if extended {
            return Err(PerCodecError::new("CHOICE additions not implemented"));
        }
        match idx {
            0 => Ok(Self::EutraCgiPwsFailedList(EutraCgiList::decode(data)?)),
            1 => Ok(Self::NrCgiPwsFailedList(NrCgiList::decode(data)?)),
            2 => {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _ = Criticality::decode(data)?;
                let _ = decode::decode_length_determinent(data, None, None, false)?;
                let result = match id {
                    x => Err(PerCodecError::new(format!("Unrecognised IE type {}", x))),
                };
                data.decode_align()?;
                result
            }
            _ => Err(PerCodecError::new("Unknown choice idx")),
        }
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        match self {
            Self::EutraCgiPwsFailedList(x) => {
                encode::encode_choice_idx(data, 0, 2, false, 0, false)?;
                x.encode(data)
            }
            Self::NrCgiPwsFailedList(x) => {
                encode::encode_choice_idx(data, 0, 2, false, 1, false)?;
                x.encode(data)
            }
        }
    }
}

impl PerCodec for PwsFailedCellIdList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PwsFailedCellIdList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PwsFailedCellIdList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PwsFailedCellIdList");
            e
        })
    }
}
// QosCharacteristics
#[derive(Clone, Debug)]
pub enum QosCharacteristics {
    NonDynamic5qi(NonDynamic5qiDescriptor),
    Dynamic5qi(Dynamic5qiDescriptor),
}

impl QosCharacteristics {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_choice_idx(data, 0, 2, false)?;
        if extended {
            return Err(PerCodecError::new("CHOICE additions not implemented"));
        }
        match idx {
            0 => Ok(Self::NonDynamic5qi(NonDynamic5qiDescriptor::decode(data)?)),
            1 => Ok(Self::Dynamic5qi(Dynamic5qiDescriptor::decode(data)?)),
            2 => {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _ = Criticality::decode(data)?;
                let _ = decode::decode_length_determinent(data, None, None, false)?;
                let result = match id {
                    x => Err(PerCodecError::new(format!("Unrecognised IE type {}", x))),
                };
                data.decode_align()?;
                result
            }
            _ => Err(PerCodecError::new("Unknown choice idx")),
        }
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        match self {
            Self::NonDynamic5qi(x) => {
                encode::encode_choice_idx(data, 0, 2, false, 0, false)?;
                x.encode(data)
            }
            Self::Dynamic5qi(x) => {
                encode::encode_choice_idx(data, 0, 2, false, 1, false)?;
                x.encode(data)
            }
        }
    }
}

impl PerCodec for QosCharacteristics {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        QosCharacteristics::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("QosCharacteristics");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("QosCharacteristics");
            e
        })
    }
}
// QosFlowAcceptedList
#[derive(Clone, Debug)]
pub struct QosFlowAcceptedList(pub NonEmpty<QosFlowAcceptedItem>);

impl QosFlowAcceptedList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(64), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(QosFlowAcceptedItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(64), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for QosFlowAcceptedList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        QosFlowAcceptedList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("QosFlowAcceptedList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("QosFlowAcceptedList");
            e
        })
    }
}
// QosFlowAcceptedItem
#[derive(Clone, Debug)]
pub struct QosFlowAcceptedItem {
    pub qos_flow_identifier: QosFlowIdentifier,
    pub current_qos_para_set_index: Option<AlternativeQosParaSetIndex>,
}

impl QosFlowAcceptedItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let qos_flow_identifier = QosFlowIdentifier::decode(data)?;

        // Process the extension container
        let mut current_qos_para_set_index: Option<AlternativeQosParaSetIndex> = None;

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    221 => {
                        current_qos_para_set_index = Some(AlternativeQosParaSetIndex::decode(data)?)
                    }
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            qos_flow_identifier,
            current_qos_para_set_index,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();
        if let Some(x) = &self.current_qos_para_set_index {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 221, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        let mut optionals = BitString::new();
        optionals.push(num_ies != 0);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.qos_flow_identifier.encode(data)?;
        if num_ies != 0 {
            encode::encode_length_determinent(data, Some(1), Some(65535), false, num_ies)?;
            data.append_aligned(ies);
        }
        Ok(())
    }
}

impl PerCodec for QosFlowAcceptedItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        QosFlowAcceptedItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("QosFlowAcceptedItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("QosFlowAcceptedItem");
            e
        })
    }
}
// QosFlowAddOrModifyRequestList
#[derive(Clone, Debug)]
pub struct QosFlowAddOrModifyRequestList(pub NonEmpty<QosFlowAddOrModifyRequestItem>);

impl QosFlowAddOrModifyRequestList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(64), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(QosFlowAddOrModifyRequestItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(64), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for QosFlowAddOrModifyRequestList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        QosFlowAddOrModifyRequestList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("QosFlowAddOrModifyRequestList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("QosFlowAddOrModifyRequestList");
            e
        })
    }
}
// QosFlowAddOrModifyRequestItem
#[derive(Clone, Debug)]
pub struct QosFlowAddOrModifyRequestItem {
    pub qos_flow_identifier: QosFlowIdentifier,
    pub qos_flow_level_qos_parameters: Option<QosFlowLevelQosParameters>,
    pub e_rab_id: Option<ERabId>,
    pub tsc_traffic_characteristics: Option<TscTrafficCharacteristics>,
    pub redundant_qos_flow_indicator: Option<RedundantQosFlowIndicator>,
}

impl QosFlowAddOrModifyRequestItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 3)?;
        let qos_flow_identifier = QosFlowIdentifier::decode(data)?;
        let qos_flow_level_qos_parameters = if optionals[0] {
            Some(QosFlowLevelQosParameters::decode(data)?)
        } else {
            None
        };
        let e_rab_id = if optionals[1] {
            Some(ERabId::decode(data)?)
        } else {
            None
        };

        // Process the extension container
        let mut tsc_traffic_characteristics: Option<TscTrafficCharacteristics> = None;
        let mut redundant_qos_flow_indicator: Option<RedundantQosFlowIndicator> = None;

        if optionals[2] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    196 => {
                        tsc_traffic_characteristics = Some(TscTrafficCharacteristics::decode(data)?)
                    }
                    194 => {
                        redundant_qos_flow_indicator =
                            Some(RedundantQosFlowIndicator::decode(data)?)
                    }
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            qos_flow_identifier,
            qos_flow_level_qos_parameters,
            e_rab_id,
            tsc_traffic_characteristics,
            redundant_qos_flow_indicator,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();
        if let Some(x) = &self.tsc_traffic_characteristics {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 196, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.redundant_qos_flow_indicator {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 194, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        let mut optionals = BitString::new();
        optionals.push(self.qos_flow_level_qos_parameters.is_some());
        optionals.push(self.e_rab_id.is_some());
        optionals.push(num_ies != 0);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.qos_flow_identifier.encode(data)?;
        if let Some(x) = &self.qos_flow_level_qos_parameters {
            x.encode(data)?;
        }
        if let Some(x) = &self.e_rab_id {
            x.encode(data)?;
        }
        if num_ies != 0 {
            encode::encode_length_determinent(data, Some(1), Some(65535), false, num_ies)?;
            data.append_aligned(ies);
        }
        Ok(())
    }
}

impl PerCodec for QosFlowAddOrModifyRequestItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        QosFlowAddOrModifyRequestItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("QosFlowAddOrModifyRequestItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("QosFlowAddOrModifyRequestItem");
            e
        })
    }
}
// QosFlowAddOrModifyResponseList
#[derive(Clone, Debug)]
pub struct QosFlowAddOrModifyResponseList(pub NonEmpty<QosFlowAddOrModifyResponseItem>);

impl QosFlowAddOrModifyResponseList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(64), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(QosFlowAddOrModifyResponseItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(64), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for QosFlowAddOrModifyResponseList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        QosFlowAddOrModifyResponseList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("QosFlowAddOrModifyResponseList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("QosFlowAddOrModifyResponseList");
            e
        })
    }
}
// QosFlowAddOrModifyResponseItem
#[derive(Clone, Debug)]
pub struct QosFlowAddOrModifyResponseItem {
    pub qos_flow_identifier: QosFlowIdentifier,
    pub current_qos_para_set_index: Option<AlternativeQosParaSetIndex>,
}

impl QosFlowAddOrModifyResponseItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let qos_flow_identifier = QosFlowIdentifier::decode(data)?;

        // Process the extension container
        let mut current_qos_para_set_index: Option<AlternativeQosParaSetIndex> = None;

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    221 => {
                        current_qos_para_set_index = Some(AlternativeQosParaSetIndex::decode(data)?)
                    }
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            qos_flow_identifier,
            current_qos_para_set_index,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();
        if let Some(x) = &self.current_qos_para_set_index {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 221, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        let mut optionals = BitString::new();
        optionals.push(num_ies != 0);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.qos_flow_identifier.encode(data)?;
        if num_ies != 0 {
            encode::encode_length_determinent(data, Some(1), Some(65535), false, num_ies)?;
            data.append_aligned(ies);
        }
        Ok(())
    }
}

impl PerCodec for QosFlowAddOrModifyResponseItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        QosFlowAddOrModifyResponseItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("QosFlowAddOrModifyResponseItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("QosFlowAddOrModifyResponseItem");
            e
        })
    }
}
// QosFlowFeedbackList
#[derive(Clone, Debug)]
pub struct QosFlowFeedbackList(pub NonEmpty<QosFlowFeedbackItem>);

impl QosFlowFeedbackList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(64), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(QosFlowFeedbackItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(64), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for QosFlowFeedbackList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        QosFlowFeedbackList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("QosFlowFeedbackList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("QosFlowFeedbackList");
            e
        })
    }
}
// QosFlowFeedbackItem
#[derive(Clone, Debug)]
pub struct QosFlowFeedbackItem {
    pub qos_flow_identifier: QosFlowIdentifier,
    pub update_feedback: Option<UpdateFeedback>,
    pub c_npacket_delay_budget_dl: Option<ExtendedPacketDelayBudget>,
    pub c_npacket_delay_budget_ul: Option<ExtendedPacketDelayBudget>,
}

impl QosFlowFeedbackItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 4)?;
        let qos_flow_identifier = QosFlowIdentifier::decode(data)?;
        let update_feedback = if optionals[0] {
            Some(UpdateFeedback::decode(data)?)
        } else {
            None
        };
        let c_npacket_delay_budget_dl = if optionals[1] {
            Some(ExtendedPacketDelayBudget::decode(data)?)
        } else {
            None
        };
        let c_npacket_delay_budget_ul = if optionals[2] {
            Some(ExtendedPacketDelayBudget::decode(data)?)
        } else {
            None
        };

        // Process the extension container

        if optionals[3] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            qos_flow_identifier,
            update_feedback,
            c_npacket_delay_budget_dl,
            c_npacket_delay_budget_ul,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.update_feedback.is_some());
        optionals.push(self.c_npacket_delay_budget_dl.is_some());
        optionals.push(self.c_npacket_delay_budget_ul.is_some());
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.qos_flow_identifier.encode(data)?;
        if let Some(x) = &self.update_feedback {
            x.encode(data)?;
        }
        if let Some(x) = &self.c_npacket_delay_budget_dl {
            x.encode(data)?;
        }
        if let Some(x) = &self.c_npacket_delay_budget_ul {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl PerCodec for QosFlowFeedbackItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        QosFlowFeedbackItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("QosFlowFeedbackItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("QosFlowFeedbackItem");
            e
        })
    }
}
// QosFlowIdentifier
#[derive(Clone, Copy, Debug)]
pub struct QosFlowIdentifier(pub u8);

impl QosFlowIdentifier {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(
            decode::decode_integer(data, Some(0), Some(63), true)?.0 as u8,
        ))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_integer(data, Some(0), Some(63), true, self.0 as i128, false)
    }
}

impl PerCodec for QosFlowIdentifier {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        QosFlowIdentifier::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("QosFlowIdentifier");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("QosFlowIdentifier");
            e
        })
    }
}
// QosFlowInformationList
#[derive(Clone, Debug)]
pub struct QosFlowInformationList(pub NonEmpty<QosFlowInformationItem>);

impl QosFlowInformationList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(64), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(QosFlowInformationItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(64), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for QosFlowInformationList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        QosFlowInformationList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("QosFlowInformationList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("QosFlowInformationList");
            e
        })
    }
}
// QosFlowInformationItem
#[derive(Clone, Debug)]
pub struct QosFlowInformationItem {
    pub qos_flow_identifier: QosFlowIdentifier,
    pub dl_forwarding: Option<DlForwarding>,
    pub ul_forwarding: Option<UlForwarding>,
}

impl QosFlowInformationItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 2)?;
        let qos_flow_identifier = QosFlowIdentifier::decode(data)?;
        let dl_forwarding = if optionals[0] {
            Some(DlForwarding::decode(data)?)
        } else {
            None
        };

        // Process the extension container
        let mut ul_forwarding: Option<UlForwarding> = None;

        if optionals[1] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    163 => ul_forwarding = Some(UlForwarding::decode(data)?),
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            qos_flow_identifier,
            dl_forwarding,
            ul_forwarding,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();
        if let Some(x) = &self.ul_forwarding {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 163, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        let mut optionals = BitString::new();
        optionals.push(self.dl_forwarding.is_some());
        optionals.push(num_ies != 0);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.qos_flow_identifier.encode(data)?;
        if let Some(x) = &self.dl_forwarding {
            x.encode(data)?;
        }
        if num_ies != 0 {
            encode::encode_length_determinent(data, Some(1), Some(65535), false, num_ies)?;
            data.append_aligned(ies);
        }
        Ok(())
    }
}

impl PerCodec for QosFlowInformationItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        QosFlowInformationItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("QosFlowInformationItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("QosFlowInformationItem");
            e
        })
    }
}
// QosFlowLevelQosParameters
#[derive(Clone, Debug)]
pub struct QosFlowLevelQosParameters {
    pub qos_characteristics: QosCharacteristics,
    pub allocation_and_retention_priority: AllocationAndRetentionPriority,
    pub gbr_qos_information: Option<GbrQosInformation>,
    pub reflective_qos_attribute: Option<ReflectiveQosAttribute>,
    pub additional_qos_flow_information: Option<AdditionalQosFlowInformation>,
    pub qos_monitoring_request: Option<QosMonitoringRequest>,
    pub qos_monitoring_reporting_frequency: Option<QosMonitoringReportingFrequency>,
}

impl QosFlowLevelQosParameters {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 4)?;
        let qos_characteristics = QosCharacteristics::decode(data)?;
        let allocation_and_retention_priority = AllocationAndRetentionPriority::decode(data)?;
        let gbr_qos_information = if optionals[0] {
            Some(GbrQosInformation::decode(data)?)
        } else {
            None
        };
        let reflective_qos_attribute = if optionals[1] {
            Some(ReflectiveQosAttribute::decode(data)?)
        } else {
            None
        };
        let additional_qos_flow_information = if optionals[2] {
            Some(AdditionalQosFlowInformation::decode(data)?)
        } else {
            None
        };

        // Process the extension container
        let mut qos_monitoring_request: Option<QosMonitoringRequest> = None;
        let mut qos_monitoring_reporting_frequency: Option<QosMonitoringReportingFrequency> = None;

        if optionals[3] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    181 => qos_monitoring_request = Some(QosMonitoringRequest::decode(data)?),
                    276 => {
                        qos_monitoring_reporting_frequency =
                            Some(QosMonitoringReportingFrequency::decode(data)?)
                    }
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            qos_characteristics,
            allocation_and_retention_priority,
            gbr_qos_information,
            reflective_qos_attribute,
            additional_qos_flow_information,
            qos_monitoring_request,
            qos_monitoring_reporting_frequency,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();
        if let Some(x) = &self.qos_monitoring_request {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 181, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.qos_monitoring_reporting_frequency {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 276, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        let mut optionals = BitString::new();
        optionals.push(self.gbr_qos_information.is_some());
        optionals.push(self.reflective_qos_attribute.is_some());
        optionals.push(self.additional_qos_flow_information.is_some());
        optionals.push(num_ies != 0);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.qos_characteristics.encode(data)?;
        self.allocation_and_retention_priority.encode(data)?;
        if let Some(x) = &self.gbr_qos_information {
            x.encode(data)?;
        }
        if let Some(x) = &self.reflective_qos_attribute {
            x.encode(data)?;
        }
        if let Some(x) = &self.additional_qos_flow_information {
            x.encode(data)?;
        }
        if num_ies != 0 {
            encode::encode_length_determinent(data, Some(1), Some(65535), false, num_ies)?;
            data.append_aligned(ies);
        }
        Ok(())
    }
}

impl PerCodec for QosFlowLevelQosParameters {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        QosFlowLevelQosParameters::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("QosFlowLevelQosParameters");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("QosFlowLevelQosParameters");
            e
        })
    }
}
// QosMonitoringRequest
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum QosMonitoringRequest {
    Ul,
    Dl,
    Both,
}

impl QosMonitoringRequest {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(2), true)?;
        if extended {
            return Err(PerCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(data, Some(0), Some(2), true, *self as i128, false)
    }
}

impl PerCodec for QosMonitoringRequest {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        QosMonitoringRequest::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("QosMonitoringRequest");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("QosMonitoringRequest");
            e
        })
    }
}
// QosMonitoringReportingFrequency
#[derive(Clone, Copy, Debug)]
pub struct QosMonitoringReportingFrequency(pub u16);

impl QosMonitoringReportingFrequency {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(
            decode::decode_integer(data, Some(1), Some(1800), true)?.0 as u16,
        ))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_integer(data, Some(1), Some(1800), true, self.0 as i128, false)
    }
}

impl PerCodec for QosMonitoringReportingFrequency {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        QosMonitoringReportingFrequency::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("QosMonitoringReportingFrequency");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("QosMonitoringReportingFrequency");
            e
        })
    }
}
// QosFlowListWithCause
#[derive(Clone, Debug)]
pub struct QosFlowListWithCause(pub NonEmpty<QosFlowWithCauseItem>);

impl QosFlowListWithCause {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(64), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(QosFlowWithCauseItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(64), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for QosFlowListWithCause {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        QosFlowListWithCause::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("QosFlowListWithCause");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("QosFlowListWithCause");
            e
        })
    }
}
// QosFlowWithCauseItem
#[derive(Clone, Debug)]
pub struct QosFlowWithCauseItem {
    pub qos_flow_identifier: QosFlowIdentifier,
    pub cause: Cause,
}

impl QosFlowWithCauseItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let qos_flow_identifier = QosFlowIdentifier::decode(data)?;
        let cause = Cause::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            qos_flow_identifier,
            cause,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.qos_flow_identifier.encode(data)?;
        self.cause.encode(data)?;

        Ok(())
    }
}

impl PerCodec for QosFlowWithCauseItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        QosFlowWithCauseItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("QosFlowWithCauseItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("QosFlowWithCauseItem");
            e
        })
    }
}
// QosFlowModifyConfirmList
#[derive(Clone, Debug)]
pub struct QosFlowModifyConfirmList(pub NonEmpty<QosFlowModifyConfirmItem>);

impl QosFlowModifyConfirmList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(64), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(QosFlowModifyConfirmItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(64), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for QosFlowModifyConfirmList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        QosFlowModifyConfirmList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("QosFlowModifyConfirmList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("QosFlowModifyConfirmList");
            e
        })
    }
}
// QosFlowModifyConfirmItem
#[derive(Clone, Debug)]
pub struct QosFlowModifyConfirmItem {
    pub qos_flow_identifier: QosFlowIdentifier,
}

impl QosFlowModifyConfirmItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let qos_flow_identifier = QosFlowIdentifier::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            qos_flow_identifier,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.qos_flow_identifier.encode(data)?;

        Ok(())
    }
}

impl PerCodec for QosFlowModifyConfirmItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        QosFlowModifyConfirmItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("QosFlowModifyConfirmItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("QosFlowModifyConfirmItem");
            e
        })
    }
}
// QosFlowNotifyList
#[derive(Clone, Debug)]
pub struct QosFlowNotifyList(pub NonEmpty<QosFlowNotifyItem>);

impl QosFlowNotifyList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(64), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(QosFlowNotifyItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(64), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for QosFlowNotifyList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        QosFlowNotifyList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("QosFlowNotifyList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("QosFlowNotifyList");
            e
        })
    }
}
// QosFlowNotifyItem
#[derive(Clone, Debug)]
pub struct QosFlowNotifyItem {
    pub qos_flow_identifier: QosFlowIdentifier,
    pub notification_cause: NotificationCause,
    pub current_qos_para_set_index: Option<AlternativeQosParaSetNotifyIndex>,
}

impl QosFlowNotifyItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let qos_flow_identifier = QosFlowIdentifier::decode(data)?;
        let notification_cause = NotificationCause::decode(data)?;

        // Process the extension container
        let mut current_qos_para_set_index: Option<AlternativeQosParaSetNotifyIndex> = None;

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    221 => {
                        current_qos_para_set_index =
                            Some(AlternativeQosParaSetNotifyIndex::decode(data)?)
                    }
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            qos_flow_identifier,
            notification_cause,
            current_qos_para_set_index,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();
        if let Some(x) = &self.current_qos_para_set_index {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 221, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        let mut optionals = BitString::new();
        optionals.push(num_ies != 0);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.qos_flow_identifier.encode(data)?;
        self.notification_cause.encode(data)?;
        if num_ies != 0 {
            encode::encode_length_determinent(data, Some(1), Some(65535), false, num_ies)?;
            data.append_aligned(ies);
        }
        Ok(())
    }
}

impl PerCodec for QosFlowNotifyItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        QosFlowNotifyItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("QosFlowNotifyItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("QosFlowNotifyItem");
            e
        })
    }
}
// QosFlowParametersList
#[derive(Clone, Debug)]
pub struct QosFlowParametersList(pub NonEmpty<QosFlowParametersItem>);

impl QosFlowParametersList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(64), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(QosFlowParametersItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(64), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for QosFlowParametersList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        QosFlowParametersList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("QosFlowParametersList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("QosFlowParametersList");
            e
        })
    }
}
// QosFlowParametersItem
#[derive(Clone, Debug)]
pub struct QosFlowParametersItem {
    pub qos_flow_identifier: QosFlowIdentifier,
    pub alternative_qos_para_set_list: Option<AlternativeQosParaSetList>,
    pub cn_packet_delay_budget_dl: Option<ExtendedPacketDelayBudget>,
    pub cn_packet_delay_budget_ul: Option<ExtendedPacketDelayBudget>,
    pub burst_arrival_time_downlink: Option<BurstArrivalTime>,
}

impl QosFlowParametersItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 2)?;
        let qos_flow_identifier = QosFlowIdentifier::decode(data)?;
        let alternative_qos_para_set_list = if optionals[0] {
            Some(AlternativeQosParaSetList::decode(data)?)
        } else {
            None
        };

        // Process the extension container
        let mut cn_packet_delay_budget_dl: Option<ExtendedPacketDelayBudget> = None;
        let mut cn_packet_delay_budget_ul: Option<ExtendedPacketDelayBudget> = None;
        let mut burst_arrival_time_downlink: Option<BurstArrivalTime> = None;

        if optionals[1] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    187 => {
                        cn_packet_delay_budget_dl = Some(ExtendedPacketDelayBudget::decode(data)?)
                    }
                    188 => {
                        cn_packet_delay_budget_ul = Some(ExtendedPacketDelayBudget::decode(data)?)
                    }
                    279 => burst_arrival_time_downlink = Some(BurstArrivalTime::decode(data)?),
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            qos_flow_identifier,
            alternative_qos_para_set_list,
            cn_packet_delay_budget_dl,
            cn_packet_delay_budget_ul,
            burst_arrival_time_downlink,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();
        if let Some(x) = &self.cn_packet_delay_budget_dl {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 187, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.cn_packet_delay_budget_ul {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 188, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.burst_arrival_time_downlink {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 279, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        let mut optionals = BitString::new();
        optionals.push(self.alternative_qos_para_set_list.is_some());
        optionals.push(num_ies != 0);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.qos_flow_identifier.encode(data)?;
        if let Some(x) = &self.alternative_qos_para_set_list {
            x.encode(data)?;
        }
        if num_ies != 0 {
            encode::encode_length_determinent(data, Some(1), Some(65535), false, num_ies)?;
            data.append_aligned(ies);
        }
        Ok(())
    }
}

impl PerCodec for QosFlowParametersItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        QosFlowParametersItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("QosFlowParametersItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("QosFlowParametersItem");
            e
        })
    }
}
// QosFlowPerTnlInformation
#[derive(Clone, Debug)]
pub struct QosFlowPerTnlInformation {
    pub up_transport_layer_information: UpTransportLayerInformation,
    pub associated_qos_flow_list: AssociatedQosFlowList,
}

impl QosFlowPerTnlInformation {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let up_transport_layer_information = UpTransportLayerInformation::decode(data)?;
        let associated_qos_flow_list = AssociatedQosFlowList::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            up_transport_layer_information,
            associated_qos_flow_list,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.up_transport_layer_information.encode(data)?;
        self.associated_qos_flow_list.encode(data)?;

        Ok(())
    }
}

impl PerCodec for QosFlowPerTnlInformation {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        QosFlowPerTnlInformation::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("QosFlowPerTnlInformation");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("QosFlowPerTnlInformation");
            e
        })
    }
}
// QosFlowPerTnlInformationList
#[derive(Clone, Debug)]
pub struct QosFlowPerTnlInformationList(pub NonEmpty<QosFlowPerTnlInformationItem>);

impl QosFlowPerTnlInformationList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(3), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(QosFlowPerTnlInformationItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(3), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for QosFlowPerTnlInformationList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        QosFlowPerTnlInformationList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("QosFlowPerTnlInformationList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("QosFlowPerTnlInformationList");
            e
        })
    }
}
// QosFlowPerTnlInformationItem
#[derive(Clone, Debug)]
pub struct QosFlowPerTnlInformationItem {
    pub qos_flow_per_tnl_information: QosFlowPerTnlInformation,
}

impl QosFlowPerTnlInformationItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let qos_flow_per_tnl_information = QosFlowPerTnlInformation::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            qos_flow_per_tnl_information,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.qos_flow_per_tnl_information.encode(data)?;

        Ok(())
    }
}

impl PerCodec for QosFlowPerTnlInformationItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        QosFlowPerTnlInformationItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("QosFlowPerTnlInformationItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("QosFlowPerTnlInformationItem");
            e
        })
    }
}
// QosFlowSetupRequestList
#[derive(Clone, Debug)]
pub struct QosFlowSetupRequestList(pub NonEmpty<QosFlowSetupRequestItem>);

impl QosFlowSetupRequestList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(64), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(QosFlowSetupRequestItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(64), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for QosFlowSetupRequestList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        QosFlowSetupRequestList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("QosFlowSetupRequestList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("QosFlowSetupRequestList");
            e
        })
    }
}
// QosFlowSetupRequestItem
#[derive(Clone, Debug)]
pub struct QosFlowSetupRequestItem {
    pub qos_flow_identifier: QosFlowIdentifier,
    pub qos_flow_level_qos_parameters: QosFlowLevelQosParameters,
    pub e_rab_id: Option<ERabId>,
    pub tsc_traffic_characteristics: Option<TscTrafficCharacteristics>,
    pub redundant_qos_flow_indicator: Option<RedundantQosFlowIndicator>,
}

impl QosFlowSetupRequestItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 2)?;
        let qos_flow_identifier = QosFlowIdentifier::decode(data)?;
        let qos_flow_level_qos_parameters = QosFlowLevelQosParameters::decode(data)?;
        let e_rab_id = if optionals[0] {
            Some(ERabId::decode(data)?)
        } else {
            None
        };

        // Process the extension container
        let mut tsc_traffic_characteristics: Option<TscTrafficCharacteristics> = None;
        let mut redundant_qos_flow_indicator: Option<RedundantQosFlowIndicator> = None;

        if optionals[1] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    196 => {
                        tsc_traffic_characteristics = Some(TscTrafficCharacteristics::decode(data)?)
                    }
                    194 => {
                        redundant_qos_flow_indicator =
                            Some(RedundantQosFlowIndicator::decode(data)?)
                    }
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            qos_flow_identifier,
            qos_flow_level_qos_parameters,
            e_rab_id,
            tsc_traffic_characteristics,
            redundant_qos_flow_indicator,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();
        if let Some(x) = &self.tsc_traffic_characteristics {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 196, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.redundant_qos_flow_indicator {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 194, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        let mut optionals = BitString::new();
        optionals.push(self.e_rab_id.is_some());
        optionals.push(num_ies != 0);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.qos_flow_identifier.encode(data)?;
        self.qos_flow_level_qos_parameters.encode(data)?;
        if let Some(x) = &self.e_rab_id {
            x.encode(data)?;
        }
        if num_ies != 0 {
            encode::encode_length_determinent(data, Some(1), Some(65535), false, num_ies)?;
            data.append_aligned(ies);
        }
        Ok(())
    }
}

impl PerCodec for QosFlowSetupRequestItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        QosFlowSetupRequestItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("QosFlowSetupRequestItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("QosFlowSetupRequestItem");
            e
        })
    }
}
// QosFlowListWithDataForwarding
#[derive(Clone, Debug)]
pub struct QosFlowListWithDataForwarding(pub NonEmpty<QosFlowItemWithDataForwarding>);

impl QosFlowListWithDataForwarding {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(64), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(QosFlowItemWithDataForwarding::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(64), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for QosFlowListWithDataForwarding {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        QosFlowListWithDataForwarding::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("QosFlowListWithDataForwarding");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("QosFlowListWithDataForwarding");
            e
        })
    }
}
// QosFlowItemWithDataForwarding
#[derive(Clone, Debug)]
pub struct QosFlowItemWithDataForwarding {
    pub qos_flow_identifier: QosFlowIdentifier,
    pub data_forwarding_accepted: Option<DataForwardingAccepted>,
    pub current_qos_para_set_index: Option<AlternativeQosParaSetIndex>,
}

impl QosFlowItemWithDataForwarding {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 2)?;
        let qos_flow_identifier = QosFlowIdentifier::decode(data)?;
        let data_forwarding_accepted = if optionals[0] {
            Some(DataForwardingAccepted::decode(data)?)
        } else {
            None
        };

        // Process the extension container
        let mut current_qos_para_set_index: Option<AlternativeQosParaSetIndex> = None;

        if optionals[1] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    221 => {
                        current_qos_para_set_index = Some(AlternativeQosParaSetIndex::decode(data)?)
                    }
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            qos_flow_identifier,
            data_forwarding_accepted,
            current_qos_para_set_index,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();
        if let Some(x) = &self.current_qos_para_set_index {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 221, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        let mut optionals = BitString::new();
        optionals.push(self.data_forwarding_accepted.is_some());
        optionals.push(num_ies != 0);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.qos_flow_identifier.encode(data)?;
        if let Some(x) = &self.data_forwarding_accepted {
            x.encode(data)?;
        }
        if num_ies != 0 {
            encode::encode_length_determinent(data, Some(1), Some(65535), false, num_ies)?;
            data.append_aligned(ies);
        }
        Ok(())
    }
}

impl PerCodec for QosFlowItemWithDataForwarding {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        QosFlowItemWithDataForwarding::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("QosFlowItemWithDataForwarding");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("QosFlowItemWithDataForwarding");
            e
        })
    }
}
// QosFlowToBeForwardedList
#[derive(Clone, Debug)]
pub struct QosFlowToBeForwardedList(pub NonEmpty<QosFlowToBeForwardedItem>);

impl QosFlowToBeForwardedList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(64), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(QosFlowToBeForwardedItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(64), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for QosFlowToBeForwardedList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        QosFlowToBeForwardedList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("QosFlowToBeForwardedList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("QosFlowToBeForwardedList");
            e
        })
    }
}
// QosFlowToBeForwardedItem
#[derive(Clone, Debug)]
pub struct QosFlowToBeForwardedItem {
    pub qos_flow_identifier: QosFlowIdentifier,
}

impl QosFlowToBeForwardedItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let qos_flow_identifier = QosFlowIdentifier::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            qos_flow_identifier,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.qos_flow_identifier.encode(data)?;

        Ok(())
    }
}

impl PerCodec for QosFlowToBeForwardedItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        QosFlowToBeForwardedItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("QosFlowToBeForwardedItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("QosFlowToBeForwardedItem");
            e
        })
    }
}
// QosFlowsUsageReportList
#[derive(Clone, Debug)]
pub struct QosFlowsUsageReportList(pub NonEmpty<QosFlowsUsageReportItem>);

impl QosFlowsUsageReportList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(64), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(QosFlowsUsageReportItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(64), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for QosFlowsUsageReportList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        QosFlowsUsageReportList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("QosFlowsUsageReportList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("QosFlowsUsageReportList");
            e
        })
    }
}
// QosFlowsUsageReportItem
#[derive(Clone, Debug)]
pub struct QosFlowsUsageReportItem {
    pub qos_flow_identifier: QosFlowIdentifier,
    pub rat_type: RatType1,
    pub qos_flows_timed_report_list: VolumeTimedReportList,
}

impl QosFlowsUsageReportItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let qos_flow_identifier = QosFlowIdentifier::decode(data)?;
        let rat_type = RatType1::decode(data)?;
        let qos_flows_timed_report_list = VolumeTimedReportList::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            qos_flow_identifier,
            rat_type,
            qos_flows_timed_report_list,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.qos_flow_identifier.encode(data)?;
        self.rat_type.encode(data)?;
        self.qos_flows_timed_report_list.encode(data)?;

        Ok(())
    }
}

impl PerCodec for QosFlowsUsageReportItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        QosFlowsUsageReportItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("QosFlowsUsageReportItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("QosFlowsUsageReportItem");
            e
        })
    }
}
// Range
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum Range {
    M50,
    M80,
    M180,
    M200,
    M350,
    M400,
    M500,
    M700,
    M1000,
}

impl Range {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(8), true)?;
        if extended {
            return Err(PerCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(data, Some(0), Some(8), true, *self as i128, false)
    }
}

impl PerCodec for Range {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Range::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("Range");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("Range");
            e
        })
    }
}
// RanNodeName
#[derive(Clone, Debug)]
pub struct RanNodeName(pub String);

impl RanNodeName {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(decode::decode_printable_string(
            data,
            Some(1),
            Some(150),
            true,
        )?))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_printable_string(data, Some(1), Some(150), true, &self.0, false)
    }
}

impl PerCodec for RanNodeName {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        RanNodeName::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("RanNodeName");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("RanNodeName");
            e
        })
    }
}
// RanNodeNameVisibleString
#[derive(Clone, Debug)]
pub struct RanNodeNameVisibleString(pub String);

impl RanNodeNameVisibleString {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(decode::decode_visible_string(
            data,
            Some(1),
            Some(150),
            true,
        )?))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_visible_string(data, Some(1), Some(150), true, &self.0, false)
    }
}

impl PerCodec for RanNodeNameVisibleString {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        RanNodeNameVisibleString::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("RanNodeNameVisibleString");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("RanNodeNameVisibleString");
            e
        })
    }
}
// RanNodeNameUtf8String
#[derive(Clone, Debug)]
pub struct RanNodeNameUtf8String(pub String);

impl RanNodeNameUtf8String {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(decode::decode_utf8_string(
            data,
            Some(1),
            Some(150),
            true,
        )?))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_utf8_string(data, Some(1), Some(150), true, &self.0, false)
    }
}

impl PerCodec for RanNodeNameUtf8String {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        RanNodeNameUtf8String::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("RanNodeNameUtf8String");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("RanNodeNameUtf8String");
            e
        })
    }
}
// RanPagingPriority
#[derive(Clone, Copy, Debug)]
pub struct RanPagingPriority(pub u16);

impl RanPagingPriority {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(
            decode::decode_integer(data, Some(1), Some(256), false)?.0 as u16,
        ))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_integer(data, Some(1), Some(256), false, self.0 as i128, false)
    }
}

impl PerCodec for RanPagingPriority {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        RanPagingPriority::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("RanPagingPriority");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("RanPagingPriority");
            e
        })
    }
}
// RanStatusTransferTransparentContainer
#[derive(Clone, Debug)]
pub struct RanStatusTransferTransparentContainer {
    pub drbs_subject_to_status_transfer_list: DrbsSubjectToStatusTransferList,
}

impl RanStatusTransferTransparentContainer {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let drbs_subject_to_status_transfer_list = DrbsSubjectToStatusTransferList::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            drbs_subject_to_status_transfer_list,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.drbs_subject_to_status_transfer_list.encode(data)?;

        Ok(())
    }
}

impl PerCodec for RanStatusTransferTransparentContainer {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        RanStatusTransferTransparentContainer::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("RanStatusTransferTransparentContainer");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("RanStatusTransferTransparentContainer");
            e
        })
    }
}
// RanUeNgapId
#[derive(Clone, Copy, Debug)]
pub struct RanUeNgapId(pub u32);

impl RanUeNgapId {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(
            decode::decode_integer(data, Some(0), Some(4294967295), false)?.0 as u32,
        ))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_integer(
            data,
            Some(0),
            Some(4294967295),
            false,
            self.0 as i128,
            false,
        )
    }
}

impl PerCodec for RanUeNgapId {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        RanUeNgapId::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("RanUeNgapId");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("RanUeNgapId");
            e
        })
    }
}
// RatInformation
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum RatInformation {
    Unlicensed,
    NbIot,
}

impl RatInformation {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(1), true)?;
        if extended {
            return Err(PerCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(data, Some(0), Some(1), true, *self as i128, false)
    }
}

impl PerCodec for RatInformation {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        RatInformation::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("RatInformation");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("RatInformation");
            e
        })
    }
}
// RatRestrictions
#[derive(Clone, Debug)]
pub struct RatRestrictions(pub NonEmpty<RatRestrictionsItem>);

impl RatRestrictions {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(16), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(RatRestrictionsItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(16), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for RatRestrictions {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        RatRestrictions::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("RatRestrictions");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("RatRestrictions");
            e
        })
    }
}
// RatRestrictionsItem
#[derive(Clone, Debug)]
pub struct RatRestrictionsItem {
    pub plmn_identity: PlmnIdentity,
    pub rat_restriction_information: RatRestrictionInformation,
    pub extended_rat_restriction_information: Option<ExtendedRatRestrictionInformation>,
}

impl RatRestrictionsItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let plmn_identity = PlmnIdentity::decode(data)?;
        let rat_restriction_information = RatRestrictionInformation::decode(data)?;

        // Process the extension container
        let mut extended_rat_restriction_information: Option<ExtendedRatRestrictionInformation> =
            None;

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    180 => {
                        extended_rat_restriction_information =
                            Some(ExtendedRatRestrictionInformation::decode(data)?)
                    }
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            plmn_identity,
            rat_restriction_information,
            extended_rat_restriction_information,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();
        if let Some(x) = &self.extended_rat_restriction_information {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 180, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        let mut optionals = BitString::new();
        optionals.push(num_ies != 0);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.plmn_identity.encode(data)?;
        self.rat_restriction_information.encode(data)?;
        if num_ies != 0 {
            encode::encode_length_determinent(data, Some(1), Some(65535), false, num_ies)?;
            data.append_aligned(ies);
        }
        Ok(())
    }
}

impl PerCodec for RatRestrictionsItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        RatRestrictionsItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("RatRestrictionsItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("RatRestrictionsItem");
            e
        })
    }
}
// RatRestrictionInformation
#[derive(Clone, Debug)]
pub struct RatRestrictionInformation(pub BitString);

impl RatRestrictionInformation {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(decode::decode_bitstring(
            data,
            Some(8),
            Some(8),
            true,
        )?))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_bitstring(data, Some(8), Some(8), true, &self.0, false)
    }
}

impl PerCodec for RatRestrictionInformation {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        RatRestrictionInformation::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("RatRestrictionInformation");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("RatRestrictionInformation");
            e
        })
    }
}
// RecommendedCellsForPaging
#[derive(Clone, Debug)]
pub struct RecommendedCellsForPaging {
    pub recommended_cell_list: RecommendedCellList,
}

impl RecommendedCellsForPaging {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let recommended_cell_list = RecommendedCellList::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            recommended_cell_list,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.recommended_cell_list.encode(data)?;

        Ok(())
    }
}

impl PerCodec for RecommendedCellsForPaging {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        RecommendedCellsForPaging::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("RecommendedCellsForPaging");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("RecommendedCellsForPaging");
            e
        })
    }
}
// RecommendedCellList
#[derive(Clone, Debug)]
pub struct RecommendedCellList(pub NonEmpty<RecommendedCellItem>);

impl RecommendedCellList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(16), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(RecommendedCellItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(16), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for RecommendedCellList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        RecommendedCellList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("RecommendedCellList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("RecommendedCellList");
            e
        })
    }
}
// RecommendedCellItem
#[derive(Clone, Debug)]
pub struct RecommendedCellItem {
    pub ngran_cgi: NgranCgi,
    pub time_stayed_in_cell: Option<u16>,
}

impl RecommendedCellItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 2)?;
        let ngran_cgi = NgranCgi::decode(data)?;
        let time_stayed_in_cell = if optionals[0] {
            Some(decode::decode_integer(data, Some(0), Some(4095), false)?.0 as u16)
        } else {
            None
        };

        // Process the extension container

        if optionals[1] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            ngran_cgi,
            time_stayed_in_cell,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.time_stayed_in_cell.is_some());
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.ngran_cgi.encode(data)?;
        if let Some(x) = &self.time_stayed_in_cell {
            encode::encode_integer(data, Some(0), Some(4095), false, *x as i128, false)?;
        }

        Ok(())
    }
}

impl PerCodec for RecommendedCellItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        RecommendedCellItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("RecommendedCellItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("RecommendedCellItem");
            e
        })
    }
}
// RecommendedRanNodesForPaging
#[derive(Clone, Debug)]
pub struct RecommendedRanNodesForPaging {
    pub recommended_ran_node_list: RecommendedRanNodeList,
}

impl RecommendedRanNodesForPaging {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let recommended_ran_node_list = RecommendedRanNodeList::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            recommended_ran_node_list,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.recommended_ran_node_list.encode(data)?;

        Ok(())
    }
}

impl PerCodec for RecommendedRanNodesForPaging {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        RecommendedRanNodesForPaging::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("RecommendedRanNodesForPaging");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("RecommendedRanNodesForPaging");
            e
        })
    }
}
// RecommendedRanNodeList
#[derive(Clone, Debug)]
pub struct RecommendedRanNodeList(pub NonEmpty<RecommendedRanNodeItem>);

impl RecommendedRanNodeList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(16), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(RecommendedRanNodeItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(16), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for RecommendedRanNodeList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        RecommendedRanNodeList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("RecommendedRanNodeList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("RecommendedRanNodeList");
            e
        })
    }
}
// RecommendedRanNodeItem
#[derive(Clone, Debug)]
pub struct RecommendedRanNodeItem {
    pub amf_paging_target: AmfPagingTarget,
}

impl RecommendedRanNodeItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let amf_paging_target = AmfPagingTarget::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self { amf_paging_target })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.amf_paging_target.encode(data)?;

        Ok(())
    }
}

impl PerCodec for RecommendedRanNodeItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        RecommendedRanNodeItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("RecommendedRanNodeItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("RecommendedRanNodeItem");
            e
        })
    }
}
// RedirectionVoiceFallback
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum RedirectionVoiceFallback {
    Possible,
    NotPossible,
}

impl RedirectionVoiceFallback {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(1), true)?;
        if extended {
            return Err(PerCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(data, Some(0), Some(1), true, *self as i128, false)
    }
}

impl PerCodec for RedirectionVoiceFallback {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        RedirectionVoiceFallback::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("RedirectionVoiceFallback");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("RedirectionVoiceFallback");
            e
        })
    }
}
// RedundantPduSessionInformation
#[derive(Clone, Debug)]
pub struct RedundantPduSessionInformation {
    pub rsn: Rsn,
}

impl RedundantPduSessionInformation {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let rsn = Rsn::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self { rsn })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.rsn.encode(data)?;

        Ok(())
    }
}

impl PerCodec for RedundantPduSessionInformation {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        RedundantPduSessionInformation::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("RedundantPduSessionInformation");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("RedundantPduSessionInformation");
            e
        })
    }
}
// RedundantQosFlowIndicator
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum RedundantQosFlowIndicator {
    True,
    False,
}

impl RedundantQosFlowIndicator {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(1), false)?;
        if extended {
            return Err(PerCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(data, Some(0), Some(1), false, *self as i128, false)
    }
}

impl PerCodec for RedundantQosFlowIndicator {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        RedundantQosFlowIndicator::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("RedundantQosFlowIndicator");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("RedundantQosFlowIndicator");
            e
        })
    }
}
// ReflectiveQosAttribute
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum ReflectiveQosAttribute {
    SubjectTo,
}

impl ReflectiveQosAttribute {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(0), true)?;
        if extended {
            return Err(PerCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(data, Some(0), Some(0), true, *self as i128, false)
    }
}

impl PerCodec for ReflectiveQosAttribute {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        ReflectiveQosAttribute::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ReflectiveQosAttribute");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ReflectiveQosAttribute");
            e
        })
    }
}
// RelativeAmfCapacity
#[derive(Clone, Copy, Debug)]
pub struct RelativeAmfCapacity(pub u8);

impl RelativeAmfCapacity {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(
            decode::decode_integer(data, Some(0), Some(255), false)?.0 as u8,
        ))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_integer(data, Some(0), Some(255), false, self.0 as i128, false)
    }
}

impl PerCodec for RelativeAmfCapacity {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        RelativeAmfCapacity::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("RelativeAmfCapacity");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("RelativeAmfCapacity");
            e
        })
    }
}
// ReportArea
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum ReportArea {
    Cell,
}

impl ReportArea {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(0), true)?;
        if extended {
            return Err(PerCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(data, Some(0), Some(0), true, *self as i128, false)
    }
}

impl PerCodec for ReportArea {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        ReportArea::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ReportArea");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ReportArea");
            e
        })
    }
}
// RepetitionPeriod
#[derive(Clone, Copy, Debug)]
pub struct RepetitionPeriod(pub u32);

impl RepetitionPeriod {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(
            decode::decode_integer(data, Some(0), Some(131071), false)?.0 as u32,
        ))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_integer(data, Some(0), Some(131071), false, self.0 as i128, false)
    }
}

impl PerCodec for RepetitionPeriod {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        RepetitionPeriod::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("RepetitionPeriod");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("RepetitionPeriod");
            e
        })
    }
}
// ResetAll
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum ResetAll {
    ResetAll,
}

impl ResetAll {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(0), true)?;
        if extended {
            return Err(PerCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(data, Some(0), Some(0), true, *self as i128, false)
    }
}

impl PerCodec for ResetAll {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        ResetAll::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ResetAll");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ResetAll");
            e
        })
    }
}
// ReportAmountMdt
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum ReportAmountMdt {
    R1,
    R2,
    R4,
    R8,
    R16,
    R32,
    R64,
    Rinfinity,
}

impl ReportAmountMdt {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(7), false)?;
        if extended {
            return Err(PerCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(data, Some(0), Some(7), false, *self as i128, false)
    }
}

impl PerCodec for ReportAmountMdt {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        ReportAmountMdt::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ReportAmountMdt");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ReportAmountMdt");
            e
        })
    }
}
// ReportIntervalMdt
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum ReportIntervalMdt {
    Ms120,
    Ms240,
    Ms480,
    Ms640,
    Ms1024,
    Ms2048,
    Ms5120,
    Ms10240,
    Min1,
    Min6,
    Min12,
    Min30,
    Min60,
}

impl ReportIntervalMdt {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(12), false)?;
        if extended {
            return Err(PerCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(data, Some(0), Some(12), false, *self as i128, false)
    }
}

impl PerCodec for ReportIntervalMdt {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        ReportIntervalMdt::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ReportIntervalMdt");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ReportIntervalMdt");
            e
        })
    }
}
// ResetType
#[derive(Clone, Debug)]
pub enum ResetType {
    NgInterface(ResetAll),
    PartOfNgInterface(UeAssociatedLogicalNgConnectionList),
}

impl ResetType {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_choice_idx(data, 0, 2, false)?;
        if extended {
            return Err(PerCodecError::new("CHOICE additions not implemented"));
        }
        match idx {
            0 => Ok(Self::NgInterface(ResetAll::decode(data)?)),
            1 => Ok(Self::PartOfNgInterface(
                UeAssociatedLogicalNgConnectionList::decode(data)?,
            )),
            2 => {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _ = Criticality::decode(data)?;
                let _ = decode::decode_length_determinent(data, None, None, false)?;
                let result = match id {
                    x => Err(PerCodecError::new(format!("Unrecognised IE type {}", x))),
                };
                data.decode_align()?;
                result
            }
            _ => Err(PerCodecError::new("Unknown choice idx")),
        }
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        match self {
            Self::NgInterface(x) => {
                encode::encode_choice_idx(data, 0, 2, false, 0, false)?;
                x.encode(data)
            }
            Self::PartOfNgInterface(x) => {
                encode::encode_choice_idx(data, 0, 2, false, 1, false)?;
                x.encode(data)
            }
        }
    }
}

impl PerCodec for ResetType {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        ResetType::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ResetType");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ResetType");
            e
        })
    }
}
// RgLevelWirelineAccessCharacteristics
#[derive(Clone, Debug)]
pub struct RgLevelWirelineAccessCharacteristics(pub Vec<u8>);

impl RgLevelWirelineAccessCharacteristics {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(decode::decode_octetstring(data, None, None, false)?))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_octetstring(data, None, None, false, &self.0, false)
    }
}

impl PerCodec for RgLevelWirelineAccessCharacteristics {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        RgLevelWirelineAccessCharacteristics::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("RgLevelWirelineAccessCharacteristics");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("RgLevelWirelineAccessCharacteristics");
            e
        })
    }
}
// RncId
#[derive(Clone, Copy, Debug)]
pub struct RncId(pub u16);

impl RncId {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(
            decode::decode_integer(data, Some(0), Some(4095), false)?.0 as u16,
        ))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_integer(data, Some(0), Some(4095), false, self.0 as i128, false)
    }
}

impl PerCodec for RncId {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        RncId::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("RncId");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("RncId");
            e
        })
    }
}
// RoutingId
#[derive(Clone, Debug)]
pub struct RoutingId(pub Vec<u8>);

impl RoutingId {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(decode::decode_octetstring(data, None, None, false)?))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_octetstring(data, None, None, false, &self.0, false)
    }
}

impl PerCodec for RoutingId {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        RoutingId::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("RoutingId");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("RoutingId");
            e
        })
    }
}
// RrcContainer
#[derive(Clone, Debug)]
pub struct RrcContainer(pub Vec<u8>);

impl RrcContainer {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(decode::decode_octetstring(data, None, None, false)?))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_octetstring(data, None, None, false, &self.0, false)
    }
}

impl PerCodec for RrcContainer {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        RrcContainer::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("RrcContainer");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("RrcContainer");
            e
        })
    }
}
// RrcEstablishmentCause
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum RrcEstablishmentCause {
    Emergency,
    HighPriorityAccess,
    MtAccess,
    MoSignalling,
    MoData,
    MoVoiceCall,
    MoVideoCall,
    MoSms,
    MpsPriorityAccess,
    McsPriorityAccess,
}

impl RrcEstablishmentCause {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(9), true)?;
        if extended {
            return Err(PerCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(data, Some(0), Some(9), true, *self as i128, false)
    }
}

impl PerCodec for RrcEstablishmentCause {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        RrcEstablishmentCause::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("RrcEstablishmentCause");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("RrcEstablishmentCause");
            e
        })
    }
}
// RrcInactiveTransitionReportRequest
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum RrcInactiveTransitionReportRequest {
    SubsequentStateTransitionReport,
    SingleRrcConnectedStateReport,
    CancelReport,
}

impl RrcInactiveTransitionReportRequest {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(2), true)?;
        if extended {
            return Err(PerCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(data, Some(0), Some(2), true, *self as i128, false)
    }
}

impl PerCodec for RrcInactiveTransitionReportRequest {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        RrcInactiveTransitionReportRequest::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("RrcInactiveTransitionReportRequest");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("RrcInactiveTransitionReportRequest");
            e
        })
    }
}
// RrcState
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum RrcState {
    Inactive,
    Connected,
}

impl RrcState {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(1), true)?;
        if extended {
            return Err(PerCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(data, Some(0), Some(1), true, *self as i128, false)
    }
}

impl PerCodec for RrcState {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        RrcState::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("RrcState");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("RrcState");
            e
        })
    }
}
// Rsn
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum Rsn {
    V1,
    V2,
}

impl Rsn {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(1), true)?;
        if extended {
            return Err(PerCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(data, Some(0), Some(1), true, *self as i128, false)
    }
}

impl PerCodec for Rsn {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Rsn::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("Rsn");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("Rsn");
            e
        })
    }
}
// RimInformationTransfer
#[derive(Clone, Debug)]
pub struct RimInformationTransfer {
    pub target_ran_node_id: TargetRanNodeId,
    pub source_ran_node_id: SourceRanNodeId,
    pub rim_information: RimInformation,
}

impl RimInformationTransfer {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let target_ran_node_id = TargetRanNodeId::decode(data)?;
        let source_ran_node_id = SourceRanNodeId::decode(data)?;
        let rim_information = RimInformation::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            target_ran_node_id,
            source_ran_node_id,
            rim_information,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.target_ran_node_id.encode(data)?;
        self.source_ran_node_id.encode(data)?;
        self.rim_information.encode(data)?;

        Ok(())
    }
}

impl PerCodec for RimInformationTransfer {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        RimInformationTransfer::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("RimInformationTransfer");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("RimInformationTransfer");
            e
        })
    }
}
// RimInformation
#[derive(Clone, Debug)]
pub struct RimInformation {
    pub target_gnb_set_id: GnbSetId,
    pub rim_rs_detection: RimRsDetection,
}

impl RimInformation {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let target_gnb_set_id = GnbSetId::decode(data)?;
        let rim_rs_detection = RimRsDetection::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            target_gnb_set_id,
            rim_rs_detection,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.target_gnb_set_id.encode(data)?;
        self.rim_rs_detection.encode(data)?;

        Ok(())
    }
}

impl PerCodec for RimInformation {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        RimInformation::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("RimInformation");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("RimInformation");
            e
        })
    }
}
// GnbSetId
#[derive(Clone, Debug)]
pub struct GnbSetId(pub BitString);

impl GnbSetId {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(decode::decode_bitstring(
            data,
            Some(22),
            Some(22),
            false,
        )?))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_bitstring(data, Some(22), Some(22), false, &self.0, false)
    }
}

impl PerCodec for GnbSetId {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        GnbSetId::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("GnbSetId");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("GnbSetId");
            e
        })
    }
}
// ScheduledCommunicationTime
#[derive(Clone, Debug)]
pub struct ScheduledCommunicationTime {
    pub dayof_week: Option<BitString>,
    pub timeof_day_start: Option<u32>,
    pub timeof_day_end: Option<u32>,
}

impl ScheduledCommunicationTime {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 4)?;
        let dayof_week = if optionals[0] {
            Some(decode::decode_bitstring(data, Some(7), Some(7), false)?)
        } else {
            None
        };
        let timeof_day_start = if optionals[1] {
            Some(decode::decode_integer(data, Some(0), Some(86399), true)?.0 as u32)
        } else {
            None
        };
        let timeof_day_end = if optionals[2] {
            Some(decode::decode_integer(data, Some(0), Some(86399), true)?.0 as u32)
        } else {
            None
        };

        // Process the extension container

        if optionals[3] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            dayof_week,
            timeof_day_start,
            timeof_day_end,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.dayof_week.is_some());
        optionals.push(self.timeof_day_start.is_some());
        optionals.push(self.timeof_day_end.is_some());
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        if let Some(x) = &self.dayof_week {
            encode::encode_bitstring(data, Some(7), Some(7), false, &x, false)?;
        }
        if let Some(x) = &self.timeof_day_start {
            encode::encode_integer(data, Some(0), Some(86399), true, *x as i128, false)?;
        }
        if let Some(x) = &self.timeof_day_end {
            encode::encode_integer(data, Some(0), Some(86399), true, *x as i128, false)?;
        }

        Ok(())
    }
}

impl PerCodec for ScheduledCommunicationTime {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        ScheduledCommunicationTime::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ScheduledCommunicationTime");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ScheduledCommunicationTime");
            e
        })
    }
}
// SctpTlAs
#[derive(Clone, Debug)]
pub struct SctpTlAs(pub NonEmpty<TransportLayerAddress>);

impl SctpTlAs {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(2), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(TransportLayerAddress::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(2), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for SctpTlAs {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        SctpTlAs::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SctpTlAs");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SctpTlAs");
            e
        })
    }
}
// Sd
#[derive(Clone, Debug)]
pub struct Sd(pub [u8; 3]);

impl Sd {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(
            decode::decode_octetstring(data, Some(3), Some(3), false)?
                .try_into()
                .unwrap(),
        ))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_octetstring(data, Some(3), Some(3), false, &(self.0).into(), false)
    }
}

impl PerCodec for Sd {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Sd::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("Sd");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("Sd");
            e
        })
    }
}
// SecondaryRatUsageInformation
#[derive(Clone, Debug)]
pub struct SecondaryRatUsageInformation {
    pub pdu_session_usage_report: Option<PduSessionUsageReport>,
    pub qos_flows_usage_report_list: Option<QosFlowsUsageReportList>,
}

impl SecondaryRatUsageInformation {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 3)?;
        let pdu_session_usage_report = if optionals[0] {
            Some(PduSessionUsageReport::decode(data)?)
        } else {
            None
        };
        let qos_flows_usage_report_list = if optionals[1] {
            Some(QosFlowsUsageReportList::decode(data)?)
        } else {
            None
        };

        // Process the extension container

        if optionals[2] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            pdu_session_usage_report,
            qos_flows_usage_report_list,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.pdu_session_usage_report.is_some());
        optionals.push(self.qos_flows_usage_report_list.is_some());
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        if let Some(x) = &self.pdu_session_usage_report {
            x.encode(data)?;
        }
        if let Some(x) = &self.qos_flows_usage_report_list {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl PerCodec for SecondaryRatUsageInformation {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        SecondaryRatUsageInformation::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SecondaryRatUsageInformation");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SecondaryRatUsageInformation");
            e
        })
    }
}
// SecondaryRatDataUsageReportTransfer
#[derive(Clone, Debug)]
pub struct SecondaryRatDataUsageReportTransfer {
    pub secondary_rat_usage_information: Option<SecondaryRatUsageInformation>,
}

impl SecondaryRatDataUsageReportTransfer {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 2)?;
        let secondary_rat_usage_information = if optionals[0] {
            Some(SecondaryRatUsageInformation::decode(data)?)
        } else {
            None
        };

        // Process the extension container

        if optionals[1] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            secondary_rat_usage_information,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.secondary_rat_usage_information.is_some());
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        if let Some(x) = &self.secondary_rat_usage_information {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl PerCodec for SecondaryRatDataUsageReportTransfer {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        SecondaryRatDataUsageReportTransfer::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SecondaryRatDataUsageReportTransfer");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SecondaryRatDataUsageReportTransfer");
            e
        })
    }
}
// SecurityContext
#[derive(Clone, Debug)]
pub struct SecurityContext {
    pub next_hop_chaining_count: NextHopChainingCount,
    pub next_hop_nh: SecurityKey,
}

impl SecurityContext {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let next_hop_chaining_count = NextHopChainingCount::decode(data)?;
        let next_hop_nh = SecurityKey::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            next_hop_chaining_count,
            next_hop_nh,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.next_hop_chaining_count.encode(data)?;
        self.next_hop_nh.encode(data)?;

        Ok(())
    }
}

impl PerCodec for SecurityContext {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        SecurityContext::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SecurityContext");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SecurityContext");
            e
        })
    }
}
// SecurityIndication
#[derive(Clone, Debug)]
pub struct SecurityIndication {
    pub integrity_protection_indication: IntegrityProtectionIndication,
    pub confidentiality_protection_indication: ConfidentialityProtectionIndication,
    pub maximum_integrity_protected_data_rate_ul: Option<MaximumIntegrityProtectedDataRate>,
    pub maximum_integrity_protected_data_rate_dl: Option<MaximumIntegrityProtectedDataRate>,
}

impl SecurityIndication {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 2)?;
        let integrity_protection_indication = IntegrityProtectionIndication::decode(data)?;
        let confidentiality_protection_indication =
            ConfidentialityProtectionIndication::decode(data)?;
        let maximum_integrity_protected_data_rate_ul = if optionals[0] {
            Some(MaximumIntegrityProtectedDataRate::decode(data)?)
        } else {
            None
        };

        // Process the extension container
        let mut maximum_integrity_protected_data_rate_dl: Option<
            MaximumIntegrityProtectedDataRate,
        > = None;

        if optionals[1] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    151 => {
                        maximum_integrity_protected_data_rate_dl =
                            Some(MaximumIntegrityProtectedDataRate::decode(data)?)
                    }
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            integrity_protection_indication,
            confidentiality_protection_indication,
            maximum_integrity_protected_data_rate_ul,
            maximum_integrity_protected_data_rate_dl,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();
        if let Some(x) = &self.maximum_integrity_protected_data_rate_dl {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 151, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        let mut optionals = BitString::new();
        optionals.push(self.maximum_integrity_protected_data_rate_ul.is_some());
        optionals.push(num_ies != 0);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.integrity_protection_indication.encode(data)?;
        self.confidentiality_protection_indication.encode(data)?;
        if let Some(x) = &self.maximum_integrity_protected_data_rate_ul {
            x.encode(data)?;
        }
        if num_ies != 0 {
            encode::encode_length_determinent(data, Some(1), Some(65535), false, num_ies)?;
            data.append_aligned(ies);
        }
        Ok(())
    }
}

impl PerCodec for SecurityIndication {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        SecurityIndication::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SecurityIndication");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SecurityIndication");
            e
        })
    }
}
// SecurityKey
#[derive(Clone, Debug)]
pub struct SecurityKey(pub BitString);

impl SecurityKey {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(decode::decode_bitstring(
            data,
            Some(256),
            Some(256),
            false,
        )?))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_bitstring(data, Some(256), Some(256), false, &self.0, false)
    }
}

impl PerCodec for SecurityKey {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        SecurityKey::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SecurityKey");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SecurityKey");
            e
        })
    }
}
// SecurityResult
#[derive(Clone, Debug)]
pub struct SecurityResult {
    pub integrity_protection_result: IntegrityProtectionResult,
    pub confidentiality_protection_result: ConfidentialityProtectionResult,
}

impl SecurityResult {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let integrity_protection_result = IntegrityProtectionResult::decode(data)?;
        let confidentiality_protection_result = ConfidentialityProtectionResult::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            integrity_protection_result,
            confidentiality_protection_result,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.integrity_protection_result.encode(data)?;
        self.confidentiality_protection_result.encode(data)?;

        Ok(())
    }
}

impl PerCodec for SecurityResult {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        SecurityResult::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SecurityResult");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SecurityResult");
            e
        })
    }
}
// SensorMeasurementConfiguration
#[derive(Clone, Debug)]
pub struct SensorMeasurementConfiguration {
    pub sensor_meas_config: SensorMeasConfig,
    pub sensor_meas_config_name_list: Option<SensorMeasConfigNameList>,
}

impl SensorMeasurementConfiguration {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 2)?;
        let sensor_meas_config = SensorMeasConfig::decode(data)?;
        let sensor_meas_config_name_list = if optionals[0] {
            Some(SensorMeasConfigNameList::decode(data)?)
        } else {
            None
        };

        // Process the extension container

        if optionals[1] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            sensor_meas_config,
            sensor_meas_config_name_list,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.sensor_meas_config_name_list.is_some());
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.sensor_meas_config.encode(data)?;
        if let Some(x) = &self.sensor_meas_config_name_list {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl PerCodec for SensorMeasurementConfiguration {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        SensorMeasurementConfiguration::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SensorMeasurementConfiguration");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SensorMeasurementConfiguration");
            e
        })
    }
}
// SensorMeasConfigNameList
#[derive(Clone, Debug)]
pub struct SensorMeasConfigNameList(pub NonEmpty<SensorMeasConfigNameItem>);

impl SensorMeasConfigNameList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(3), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(SensorMeasConfigNameItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(3), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for SensorMeasConfigNameList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        SensorMeasConfigNameList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SensorMeasConfigNameList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SensorMeasConfigNameList");
            e
        })
    }
}
// SensorMeasConfigNameItem
#[derive(Clone, Debug)]
pub struct SensorMeasConfigNameItem {
    pub sensor_name_config: SensorNameConfig,
}

impl SensorMeasConfigNameItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let sensor_name_config = SensorNameConfig::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self { sensor_name_config })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.sensor_name_config.encode(data)?;

        Ok(())
    }
}

impl PerCodec for SensorMeasConfigNameItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        SensorMeasConfigNameItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SensorMeasConfigNameItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SensorMeasConfigNameItem");
            e
        })
    }
}
// SensorMeasConfig
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum SensorMeasConfig {
    Setup,
}

impl SensorMeasConfig {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(0), true)?;
        if extended {
            return Err(PerCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(data, Some(0), Some(0), true, *self as i128, false)
    }
}

impl PerCodec for SensorMeasConfig {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        SensorMeasConfig::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SensorMeasConfig");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SensorMeasConfig");
            e
        })
    }
}
// SensorNameConfig
#[derive(Clone, Debug)]
pub enum SensorNameConfig {
    UncompensatedBarometricConfig(UncompensatedBarometricConfig),
    UeSpeedConfig(UeSpeedConfig),
    UeOrientationConfig(UeOrientationConfig),
}

impl SensorNameConfig {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_choice_idx(data, 0, 3, false)?;
        if extended {
            return Err(PerCodecError::new("CHOICE additions not implemented"));
        }
        match idx {
            0 => Ok(Self::UncompensatedBarometricConfig(
                UncompensatedBarometricConfig::decode(data)?,
            )),
            1 => Ok(Self::UeSpeedConfig(UeSpeedConfig::decode(data)?)),
            2 => Ok(Self::UeOrientationConfig(UeOrientationConfig::decode(
                data,
            )?)),
            3 => {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _ = Criticality::decode(data)?;
                let _ = decode::decode_length_determinent(data, None, None, false)?;
                let result = match id {
                    x => Err(PerCodecError::new(format!("Unrecognised IE type {}", x))),
                };
                data.decode_align()?;
                result
            }
            _ => Err(PerCodecError::new("Unknown choice idx")),
        }
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        match self {
            Self::UncompensatedBarometricConfig(x) => {
                encode::encode_choice_idx(data, 0, 3, false, 0, false)?;
                x.encode(data)
            }
            Self::UeSpeedConfig(x) => {
                encode::encode_choice_idx(data, 0, 3, false, 1, false)?;
                x.encode(data)
            }
            Self::UeOrientationConfig(x) => {
                encode::encode_choice_idx(data, 0, 3, false, 2, false)?;
                x.encode(data)
            }
        }
    }
}

impl PerCodec for SensorNameConfig {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        SensorNameConfig::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SensorNameConfig");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SensorNameConfig");
            e
        })
    }
}
// SerialNumber
#[derive(Clone, Debug)]
pub struct SerialNumber(pub BitString);

impl SerialNumber {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(decode::decode_bitstring(
            data,
            Some(16),
            Some(16),
            false,
        )?))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_bitstring(data, Some(16), Some(16), false, &self.0, false)
    }
}

impl PerCodec for SerialNumber {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        SerialNumber::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SerialNumber");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SerialNumber");
            e
        })
    }
}
// ServedGuamiList
#[derive(Clone, Debug)]
pub struct ServedGuamiList(pub NonEmpty<ServedGuamiItem>);

impl ServedGuamiList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(256), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(ServedGuamiItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(256), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for ServedGuamiList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        ServedGuamiList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ServedGuamiList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ServedGuamiList");
            e
        })
    }
}
// ServedGuamiItem
#[derive(Clone, Debug)]
pub struct ServedGuamiItem {
    pub guami: Guami,
    pub backup_amf_name: Option<AmfName>,
    pub guami_type: Option<GuamiType>,
}

impl ServedGuamiItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 2)?;
        let guami = Guami::decode(data)?;
        let backup_amf_name = if optionals[0] {
            Some(AmfName::decode(data)?)
        } else {
            None
        };

        // Process the extension container
        let mut guami_type: Option<GuamiType> = None;

        if optionals[1] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    176 => guami_type = Some(GuamiType::decode(data)?),
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            guami,
            backup_amf_name,
            guami_type,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();
        if let Some(x) = &self.guami_type {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 176, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        let mut optionals = BitString::new();
        optionals.push(self.backup_amf_name.is_some());
        optionals.push(num_ies != 0);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.guami.encode(data)?;
        if let Some(x) = &self.backup_amf_name {
            x.encode(data)?;
        }
        if num_ies != 0 {
            encode::encode_length_determinent(data, Some(1), Some(65535), false, num_ies)?;
            data.append_aligned(ies);
        }
        Ok(())
    }
}

impl PerCodec for ServedGuamiItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        ServedGuamiItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ServedGuamiItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ServedGuamiItem");
            e
        })
    }
}
// ServiceAreaInformation
#[derive(Clone, Debug)]
pub struct ServiceAreaInformation(pub NonEmpty<ServiceAreaInformationItem>);

impl ServiceAreaInformation {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(16), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(ServiceAreaInformationItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(16), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for ServiceAreaInformation {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        ServiceAreaInformation::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ServiceAreaInformation");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ServiceAreaInformation");
            e
        })
    }
}
// ServiceAreaInformationItem
#[derive(Clone, Debug)]
pub struct ServiceAreaInformationItem {
    pub plmn_identity: PlmnIdentity,
    pub allowed_ta_cs: Option<AllowedTaCs>,
    pub not_allowed_ta_cs: Option<NotAllowedTaCs>,
}

impl ServiceAreaInformationItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 3)?;
        let plmn_identity = PlmnIdentity::decode(data)?;
        let allowed_ta_cs = if optionals[0] {
            Some(AllowedTaCs::decode(data)?)
        } else {
            None
        };
        let not_allowed_ta_cs = if optionals[1] {
            Some(NotAllowedTaCs::decode(data)?)
        } else {
            None
        };

        // Process the extension container

        if optionals[2] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            plmn_identity,
            allowed_ta_cs,
            not_allowed_ta_cs,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.allowed_ta_cs.is_some());
        optionals.push(self.not_allowed_ta_cs.is_some());
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.plmn_identity.encode(data)?;
        if let Some(x) = &self.allowed_ta_cs {
            x.encode(data)?;
        }
        if let Some(x) = &self.not_allowed_ta_cs {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl PerCodec for ServiceAreaInformationItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        ServiceAreaInformationItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ServiceAreaInformationItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ServiceAreaInformationItem");
            e
        })
    }
}
// SGnbUeX2apId
#[derive(Clone, Copy, Debug)]
pub struct SGnbUeX2apId(pub u32);

impl SGnbUeX2apId {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(
            decode::decode_integer(data, Some(0), Some(4294967295), false)?.0 as u32,
        ))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_integer(
            data,
            Some(0),
            Some(4294967295),
            false,
            self.0 as i128,
            false,
        )
    }
}

impl PerCodec for SGnbUeX2apId {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        SGnbUeX2apId::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SGnbUeX2apId");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SGnbUeX2apId");
            e
        })
    }
}
// SliceOverloadList
#[derive(Clone, Debug)]
pub struct SliceOverloadList(pub NonEmpty<SliceOverloadItem>);

impl SliceOverloadList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(1024), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(SliceOverloadItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(1024), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for SliceOverloadList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        SliceOverloadList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SliceOverloadList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SliceOverloadList");
            e
        })
    }
}
// SliceOverloadItem
#[derive(Clone, Debug)]
pub struct SliceOverloadItem {
    pub snssai: Snssai,
}

impl SliceOverloadItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let snssai = Snssai::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self { snssai })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.snssai.encode(data)?;

        Ok(())
    }
}

impl PerCodec for SliceOverloadItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        SliceOverloadItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SliceOverloadItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SliceOverloadItem");
            e
        })
    }
}
// SliceSupportList
#[derive(Clone, Debug)]
pub struct SliceSupportList(pub NonEmpty<SliceSupportItem>);

impl SliceSupportList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(1024), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(SliceSupportItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(1024), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for SliceSupportList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        SliceSupportList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SliceSupportList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SliceSupportList");
            e
        })
    }
}
// SliceSupportItem
#[derive(Clone, Debug)]
pub struct SliceSupportItem {
    pub snssai: Snssai,
}

impl SliceSupportItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let snssai = Snssai::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self { snssai })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.snssai.encode(data)?;

        Ok(())
    }
}

impl PerCodec for SliceSupportItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        SliceSupportItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SliceSupportItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SliceSupportItem");
            e
        })
    }
}
// SnpnMobilityInformation
#[derive(Clone, Debug)]
pub struct SnpnMobilityInformation {
    pub serving_nid: Nid,
}

impl SnpnMobilityInformation {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let serving_nid = Nid::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self { serving_nid })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.serving_nid.encode(data)?;

        Ok(())
    }
}

impl PerCodec for SnpnMobilityInformation {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        SnpnMobilityInformation::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SnpnMobilityInformation");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SnpnMobilityInformation");
            e
        })
    }
}
// Snssai
#[derive(Clone, Debug)]
pub struct Snssai {
    pub sst: Sst,
    pub sd: Option<Sd>,
}

impl Snssai {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 2)?;
        let sst = Sst::decode(data)?;
        let sd = if optionals[0] {
            Some(Sd::decode(data)?)
        } else {
            None
        };

        // Process the extension container

        if optionals[1] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self { sst, sd })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.sd.is_some());
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.sst.encode(data)?;
        if let Some(x) = &self.sd {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl PerCodec for Snssai {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Snssai::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("Snssai");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("Snssai");
            e
        })
    }
}
// SonConfigurationTransfer
#[derive(Clone, Debug)]
pub struct SonConfigurationTransfer {
    pub target_ran_node_id: TargetRanNodeId,
    pub source_ran_node_id: SourceRanNodeId,
    pub son_information: SonInformation,
    pub xn_tnl_configuration_info: Option<XnTnlConfigurationInfo>,
}

impl SonConfigurationTransfer {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 2)?;
        let target_ran_node_id = TargetRanNodeId::decode(data)?;
        let source_ran_node_id = SourceRanNodeId::decode(data)?;
        let son_information = SonInformation::decode(data)?;
        let xn_tnl_configuration_info = if optionals[0] {
            Some(XnTnlConfigurationInfo::decode(data)?)
        } else {
            None
        };

        // Process the extension container

        if optionals[1] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            target_ran_node_id,
            source_ran_node_id,
            son_information,
            xn_tnl_configuration_info,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.xn_tnl_configuration_info.is_some());
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.target_ran_node_id.encode(data)?;
        self.source_ran_node_id.encode(data)?;
        self.son_information.encode(data)?;
        if let Some(x) = &self.xn_tnl_configuration_info {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl PerCodec for SonConfigurationTransfer {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        SonConfigurationTransfer::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SonConfigurationTransfer");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SonConfigurationTransfer");
            e
        })
    }
}
// SonInformation
#[derive(Clone, Debug)]
pub enum SonInformation {
    SonInformationRequest(SonInformationRequest),
    SonInformationReply(SonInformationReply),
    SonInformationReport(SonInformationReport),
}

impl SonInformation {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_choice_idx(data, 0, 2, false)?;
        if extended {
            return Err(PerCodecError::new("CHOICE additions not implemented"));
        }
        match idx {
            0 => Ok(Self::SonInformationRequest(SonInformationRequest::decode(
                data,
            )?)),
            1 => Ok(Self::SonInformationReply(SonInformationReply::decode(
                data,
            )?)),
            2 => {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _ = Criticality::decode(data)?;
                let _ = decode::decode_length_determinent(data, None, None, false)?;
                let result = match id {
                    252 => Ok(Self::SonInformationReport(SonInformationReport::decode(
                        data,
                    )?)),
                    x => Err(PerCodecError::new(format!("Unrecognised IE type {}", x))),
                };
                data.decode_align()?;
                result
            }
            _ => Err(PerCodecError::new("Unknown choice idx")),
        }
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        match self {
            Self::SonInformationRequest(x) => {
                encode::encode_choice_idx(data, 0, 2, false, 0, false)?;
                x.encode(data)
            }
            Self::SonInformationReply(x) => {
                encode::encode_choice_idx(data, 0, 2, false, 1, false)?;
                x.encode(data)
            }
            Self::SonInformationReport(x) => {
                encode::encode_choice_idx(data, 0, 2, false, 2, false)?;
                encode::encode_integer(data, Some(0), Some(65535), false, 252, false)?;
                Criticality::Ignore.encode(data)?;
                let ie = &mut Allocator::new_codec_data();
                x.encode(ie)?;
                encode::encode_length_determinent(data, None, None, false, ie.length_in_bytes())?;
                Ok(data.append_aligned(ie))
            }
        }
    }
}

impl PerCodec for SonInformation {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        SonInformation::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SonInformation");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SonInformation");
            e
        })
    }
}
// SonInformationReply
#[derive(Clone, Debug)]
pub struct SonInformationReply {
    pub xn_tnl_configuration_info: Option<XnTnlConfigurationInfo>,
}

impl SonInformationReply {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 2)?;
        let xn_tnl_configuration_info = if optionals[0] {
            Some(XnTnlConfigurationInfo::decode(data)?)
        } else {
            None
        };

        // Process the extension container

        if optionals[1] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            xn_tnl_configuration_info,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.xn_tnl_configuration_info.is_some());
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        if let Some(x) = &self.xn_tnl_configuration_info {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl PerCodec for SonInformationReply {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        SonInformationReply::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SonInformationReply");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SonInformationReply");
            e
        })
    }
}
// SonInformationReport
#[derive(Clone, Debug)]
pub enum SonInformationReport {
    FailureIndicationInformation(FailureIndication),
    HoReportInformation(HoReport),
}

impl SonInformationReport {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_choice_idx(data, 0, 2, false)?;
        if extended {
            return Err(PerCodecError::new("CHOICE additions not implemented"));
        }
        match idx {
            0 => Ok(Self::FailureIndicationInformation(
                FailureIndication::decode(data)?,
            )),
            1 => Ok(Self::HoReportInformation(HoReport::decode(data)?)),
            2 => {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _ = Criticality::decode(data)?;
                let _ = decode::decode_length_determinent(data, None, None, false)?;
                let result = match id {
                    x => Err(PerCodecError::new(format!("Unrecognised IE type {}", x))),
                };
                data.decode_align()?;
                result
            }
            _ => Err(PerCodecError::new("Unknown choice idx")),
        }
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        match self {
            Self::FailureIndicationInformation(x) => {
                encode::encode_choice_idx(data, 0, 2, false, 0, false)?;
                x.encode(data)
            }
            Self::HoReportInformation(x) => {
                encode::encode_choice_idx(data, 0, 2, false, 1, false)?;
                x.encode(data)
            }
        }
    }
}

impl PerCodec for SonInformationReport {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        SonInformationReport::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SonInformationReport");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SonInformationReport");
            e
        })
    }
}
// SonInformationRequest
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum SonInformationRequest {
    XnTnlConfigurationInfo,
}

impl SonInformationRequest {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(0), true)?;
        if extended {
            return Err(PerCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(data, Some(0), Some(0), true, *self as i128, false)
    }
}

impl PerCodec for SonInformationRequest {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        SonInformationRequest::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SonInformationRequest");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SonInformationRequest");
            e
        })
    }
}
// SourceNgranNodeToTargetNgranNodeTransparentContainer
#[derive(Clone, Debug)]
pub struct SourceNgranNodeToTargetNgranNodeTransparentContainer {
    pub rrc_container: RrcContainer,
    pub pdu_session_resource_information_list: Option<PduSessionResourceInformationList>,
    pub e_rab_information_list: Option<ERabInformationList>,
    pub target_cell_id: NgranCgi,
    pub index_to_rfsp: Option<IndexToRfsp>,
    pub ue_history_information: UeHistoryInformation,
    pub s_gnb_ue_x2ap_id: Option<SGnbUeX2apId>,
    pub ue_history_information_from_the_ue: Option<UeHistoryInformationFromTheUe>,
}

impl SourceNgranNodeToTargetNgranNodeTransparentContainer {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 4)?;
        let rrc_container = RrcContainer::decode(data)?;
        let pdu_session_resource_information_list = if optionals[0] {
            Some(PduSessionResourceInformationList::decode(data)?)
        } else {
            None
        };
        let e_rab_information_list = if optionals[1] {
            Some(ERabInformationList::decode(data)?)
        } else {
            None
        };
        let target_cell_id = NgranCgi::decode(data)?;
        let index_to_rfsp = if optionals[2] {
            Some(IndexToRfsp::decode(data)?)
        } else {
            None
        };
        let ue_history_information = UeHistoryInformation::decode(data)?;

        // Process the extension container
        let mut s_gnb_ue_x2ap_id: Option<SGnbUeX2apId> = None;
        let mut ue_history_information_from_the_ue: Option<UeHistoryInformationFromTheUe> = None;

        if optionals[3] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    182 => s_gnb_ue_x2ap_id = Some(SGnbUeX2apId::decode(data)?),
                    253 => {
                        ue_history_information_from_the_ue =
                            Some(UeHistoryInformationFromTheUe::decode(data)?)
                    }
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            rrc_container,
            pdu_session_resource_information_list,
            e_rab_information_list,
            target_cell_id,
            index_to_rfsp,
            ue_history_information,
            s_gnb_ue_x2ap_id,
            ue_history_information_from_the_ue,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();
        if let Some(x) = &self.s_gnb_ue_x2ap_id {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 182, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.ue_history_information_from_the_ue {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 253, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        let mut optionals = BitString::new();
        optionals.push(self.pdu_session_resource_information_list.is_some());
        optionals.push(self.e_rab_information_list.is_some());
        optionals.push(self.index_to_rfsp.is_some());
        optionals.push(num_ies != 0);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.rrc_container.encode(data)?;
        if let Some(x) = &self.pdu_session_resource_information_list {
            x.encode(data)?;
        }
        if let Some(x) = &self.e_rab_information_list {
            x.encode(data)?;
        }
        self.target_cell_id.encode(data)?;
        if let Some(x) = &self.index_to_rfsp {
            x.encode(data)?;
        }
        self.ue_history_information.encode(data)?;
        if num_ies != 0 {
            encode::encode_length_determinent(data, Some(1), Some(65535), false, num_ies)?;
            data.append_aligned(ies);
        }
        Ok(())
    }
}

impl PerCodec for SourceNgranNodeToTargetNgranNodeTransparentContainer {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        SourceNgranNodeToTargetNgranNodeTransparentContainer::decode_inner(data).map_err(
            |mut e: PerCodecError| {
                e.push_context("SourceNgranNodeToTargetNgranNodeTransparentContainer");
                e
            },
        )
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SourceNgranNodeToTargetNgranNodeTransparentContainer");
            e
        })
    }
}
// SourceOfUeActivityBehaviourInformation
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum SourceOfUeActivityBehaviourInformation {
    SubscriptionInformation,
    Statistics,
}

impl SourceOfUeActivityBehaviourInformation {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(1), true)?;
        if extended {
            return Err(PerCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(data, Some(0), Some(1), true, *self as i128, false)
    }
}

impl PerCodec for SourceOfUeActivityBehaviourInformation {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        SourceOfUeActivityBehaviourInformation::decode_inner(data).map_err(
            |mut e: PerCodecError| {
                e.push_context("SourceOfUeActivityBehaviourInformation");
                e
            },
        )
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SourceOfUeActivityBehaviourInformation");
            e
        })
    }
}
// SourceRanNodeId
#[derive(Clone, Debug)]
pub struct SourceRanNodeId {
    pub global_ran_node_id: GlobalRanNodeId,
    pub selected_tai: Tai,
}

impl SourceRanNodeId {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let global_ran_node_id = GlobalRanNodeId::decode(data)?;
        let selected_tai = Tai::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            global_ran_node_id,
            selected_tai,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.global_ran_node_id.encode(data)?;
        self.selected_tai.encode(data)?;

        Ok(())
    }
}

impl PerCodec for SourceRanNodeId {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        SourceRanNodeId::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SourceRanNodeId");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SourceRanNodeId");
            e
        })
    }
}
// SourceToTargetTransparentContainer
#[derive(Clone, Debug)]
pub struct SourceToTargetTransparentContainer(pub Vec<u8>);

impl SourceToTargetTransparentContainer {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(decode::decode_octetstring(data, None, None, false)?))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_octetstring(data, None, None, false, &self.0, false)
    }
}

impl PerCodec for SourceToTargetTransparentContainer {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        SourceToTargetTransparentContainer::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SourceToTargetTransparentContainer");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SourceToTargetTransparentContainer");
            e
        })
    }
}
// SourceToTargetAmfInformationReroute
#[derive(Clone, Debug)]
pub struct SourceToTargetAmfInformationReroute {
    pub configured_nssai: Option<ConfiguredNssai>,
    pub rejected_nssa_iin_plmn: Option<RejectedNssaIinPlmn>,
    pub rejected_nssa_iin_ta: Option<RejectedNssaIinTa>,
}

impl SourceToTargetAmfInformationReroute {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 4)?;
        let configured_nssai = if optionals[0] {
            Some(ConfiguredNssai::decode(data)?)
        } else {
            None
        };
        let rejected_nssa_iin_plmn = if optionals[1] {
            Some(RejectedNssaIinPlmn::decode(data)?)
        } else {
            None
        };
        let rejected_nssa_iin_ta = if optionals[2] {
            Some(RejectedNssaIinTa::decode(data)?)
        } else {
            None
        };

        // Process the extension container

        if optionals[3] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            configured_nssai,
            rejected_nssa_iin_plmn,
            rejected_nssa_iin_ta,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.configured_nssai.is_some());
        optionals.push(self.rejected_nssa_iin_plmn.is_some());
        optionals.push(self.rejected_nssa_iin_ta.is_some());
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        if let Some(x) = &self.configured_nssai {
            x.encode(data)?;
        }
        if let Some(x) = &self.rejected_nssa_iin_plmn {
            x.encode(data)?;
        }
        if let Some(x) = &self.rejected_nssa_iin_ta {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl PerCodec for SourceToTargetAmfInformationReroute {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        SourceToTargetAmfInformationReroute::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SourceToTargetAmfInformationReroute");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SourceToTargetAmfInformationReroute");
            e
        })
    }
}
// SrvccOperationPossible
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum SrvccOperationPossible {
    Possible,
    NotPossible,
}

impl SrvccOperationPossible {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(1), true)?;
        if extended {
            return Err(PerCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(data, Some(0), Some(1), true, *self as i128, false)
    }
}

impl PerCodec for SrvccOperationPossible {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        SrvccOperationPossible::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SrvccOperationPossible");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SrvccOperationPossible");
            e
        })
    }
}
// ConfiguredNssai
#[derive(Clone, Debug)]
pub struct ConfiguredNssai(pub [u8; 128]);

impl ConfiguredNssai {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(
            decode::decode_octetstring(data, Some(128), Some(128), false)?
                .try_into()
                .unwrap(),
        ))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_octetstring(data, Some(128), Some(128), false, &(self.0).into(), false)
    }
}

impl PerCodec for ConfiguredNssai {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        ConfiguredNssai::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ConfiguredNssai");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ConfiguredNssai");
            e
        })
    }
}
// RejectedNssaIinPlmn
#[derive(Clone, Debug)]
pub struct RejectedNssaIinPlmn(pub [u8; 32]);

impl RejectedNssaIinPlmn {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(
            decode::decode_octetstring(data, Some(32), Some(32), false)?
                .try_into()
                .unwrap(),
        ))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_octetstring(data, Some(32), Some(32), false, &(self.0).into(), false)
    }
}

impl PerCodec for RejectedNssaIinPlmn {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        RejectedNssaIinPlmn::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("RejectedNssaIinPlmn");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("RejectedNssaIinPlmn");
            e
        })
    }
}
// RejectedNssaIinTa
#[derive(Clone, Debug)]
pub struct RejectedNssaIinTa(pub [u8; 32]);

impl RejectedNssaIinTa {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(
            decode::decode_octetstring(data, Some(32), Some(32), false)?
                .try_into()
                .unwrap(),
        ))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_octetstring(data, Some(32), Some(32), false, &(self.0).into(), false)
    }
}

impl PerCodec for RejectedNssaIinTa {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        RejectedNssaIinTa::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("RejectedNssaIinTa");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("RejectedNssaIinTa");
            e
        })
    }
}
// Sst
#[derive(Clone, Debug)]
pub struct Sst(pub [u8; 1]);

impl Sst {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(
            decode::decode_octetstring(data, Some(1), Some(1), false)?
                .try_into()
                .unwrap(),
        ))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_octetstring(data, Some(1), Some(1), false, &(self.0).into(), false)
    }
}

impl PerCodec for Sst {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Sst::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("Sst");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("Sst");
            e
        })
    }
}
// SupportedTaList
#[derive(Clone, Debug)]
pub struct SupportedTaList(pub NonEmpty<SupportedTaItem>);

impl SupportedTaList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(256), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(SupportedTaItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(256), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for SupportedTaList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        SupportedTaList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SupportedTaList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SupportedTaList");
            e
        })
    }
}
// SupportedTaItem
#[derive(Clone, Debug)]
pub struct SupportedTaItem {
    pub tac: Tac,
    pub broadcast_plmn_list: BroadcastPlmnList,
    pub configured_tac_indication: Option<ConfiguredTacIndication>,
    pub rat_information: Option<RatInformation>,
}

impl SupportedTaItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let tac = Tac::decode(data)?;
        let broadcast_plmn_list = BroadcastPlmnList::decode(data)?;

        // Process the extension container
        let mut configured_tac_indication: Option<ConfiguredTacIndication> = None;
        let mut rat_information: Option<RatInformation> = None;

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    272 => configured_tac_indication = Some(ConfiguredTacIndication::decode(data)?),
                    179 => rat_information = Some(RatInformation::decode(data)?),
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            tac,
            broadcast_plmn_list,
            configured_tac_indication,
            rat_information,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();
        if let Some(x) = &self.configured_tac_indication {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 272, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.rat_information {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 179, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        let mut optionals = BitString::new();
        optionals.push(num_ies != 0);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.tac.encode(data)?;
        self.broadcast_plmn_list.encode(data)?;
        if num_ies != 0 {
            encode::encode_length_determinent(data, Some(1), Some(65535), false, num_ies)?;
            data.append_aligned(ies);
        }
        Ok(())
    }
}

impl PerCodec for SupportedTaItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        SupportedTaItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SupportedTaItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SupportedTaItem");
            e
        })
    }
}
// SuspendIndicator
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum SuspendIndicator {
    True,
}

impl SuspendIndicator {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(0), true)?;
        if extended {
            return Err(PerCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(data, Some(0), Some(0), true, *self as i128, false)
    }
}

impl PerCodec for SuspendIndicator {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        SuspendIndicator::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SuspendIndicator");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SuspendIndicator");
            e
        })
    }
}
// SuspendRequestIndication
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum SuspendRequestIndication {
    SuspendRequested,
}

impl SuspendRequestIndication {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(0), true)?;
        if extended {
            return Err(PerCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(data, Some(0), Some(0), true, *self as i128, false)
    }
}

impl PerCodec for SuspendRequestIndication {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        SuspendRequestIndication::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SuspendRequestIndication");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SuspendRequestIndication");
            e
        })
    }
}
// SuspendResponseIndication
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum SuspendResponseIndication {
    SuspendIndicated,
}

impl SuspendResponseIndication {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(0), true)?;
        if extended {
            return Err(PerCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(data, Some(0), Some(0), true, *self as i128, false)
    }
}

impl PerCodec for SuspendResponseIndication {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        SuspendResponseIndication::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SuspendResponseIndication");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SuspendResponseIndication");
            e
        })
    }
}
// Tac
#[derive(Clone, Debug)]
pub struct Tac(pub [u8; 3]);

impl Tac {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(
            decode::decode_octetstring(data, Some(3), Some(3), false)?
                .try_into()
                .unwrap(),
        ))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_octetstring(data, Some(3), Some(3), false, &(self.0).into(), false)
    }
}

impl PerCodec for Tac {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Tac::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("Tac");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("Tac");
            e
        })
    }
}
// Tai
#[derive(Clone, Debug)]
pub struct Tai {
    pub plmn_identity: PlmnIdentity,
    pub tac: Tac,
}

impl Tai {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let plmn_identity = PlmnIdentity::decode(data)?;
        let tac = Tac::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self { plmn_identity, tac })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.plmn_identity.encode(data)?;
        self.tac.encode(data)?;

        Ok(())
    }
}

impl PerCodec for Tai {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Tai::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("Tai");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("Tai");
            e
        })
    }
}
// TaiBroadcastEutra
#[derive(Clone, Debug)]
pub struct TaiBroadcastEutra(pub NonEmpty<TaiBroadcastEutraItem>);

impl TaiBroadcastEutra {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(TaiBroadcastEutraItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(65535), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for TaiBroadcastEutra {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        TaiBroadcastEutra::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TaiBroadcastEutra");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TaiBroadcastEutra");
            e
        })
    }
}
// TaiBroadcastEutraItem
#[derive(Clone, Debug)]
pub struct TaiBroadcastEutraItem {
    pub tai: Tai,
    pub completed_cells_in_tai_eutra: CompletedCellsInTaiEutra,
}

impl TaiBroadcastEutraItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let tai = Tai::decode(data)?;
        let completed_cells_in_tai_eutra = CompletedCellsInTaiEutra::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            tai,
            completed_cells_in_tai_eutra,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.tai.encode(data)?;
        self.completed_cells_in_tai_eutra.encode(data)?;

        Ok(())
    }
}

impl PerCodec for TaiBroadcastEutraItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        TaiBroadcastEutraItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TaiBroadcastEutraItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TaiBroadcastEutraItem");
            e
        })
    }
}
// TaiBroadcastNr
#[derive(Clone, Debug)]
pub struct TaiBroadcastNr(pub NonEmpty<TaiBroadcastNrItem>);

impl TaiBroadcastNr {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(TaiBroadcastNrItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(65535), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for TaiBroadcastNr {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        TaiBroadcastNr::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TaiBroadcastNr");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TaiBroadcastNr");
            e
        })
    }
}
// TaiBroadcastNrItem
#[derive(Clone, Debug)]
pub struct TaiBroadcastNrItem {
    pub tai: Tai,
    pub completed_cells_in_tai_nr: CompletedCellsInTaiNr,
}

impl TaiBroadcastNrItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let tai = Tai::decode(data)?;
        let completed_cells_in_tai_nr = CompletedCellsInTaiNr::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            tai,
            completed_cells_in_tai_nr,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.tai.encode(data)?;
        self.completed_cells_in_tai_nr.encode(data)?;

        Ok(())
    }
}

impl PerCodec for TaiBroadcastNrItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        TaiBroadcastNrItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TaiBroadcastNrItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TaiBroadcastNrItem");
            e
        })
    }
}
// TaiCancelledEutra
#[derive(Clone, Debug)]
pub struct TaiCancelledEutra(pub NonEmpty<TaiCancelledEutraItem>);

impl TaiCancelledEutra {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(TaiCancelledEutraItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(65535), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for TaiCancelledEutra {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        TaiCancelledEutra::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TaiCancelledEutra");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TaiCancelledEutra");
            e
        })
    }
}
// TaiCancelledEutraItem
#[derive(Clone, Debug)]
pub struct TaiCancelledEutraItem {
    pub tai: Tai,
    pub cancelled_cells_in_tai_eutra: CancelledCellsInTaiEutra,
}

impl TaiCancelledEutraItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let tai = Tai::decode(data)?;
        let cancelled_cells_in_tai_eutra = CancelledCellsInTaiEutra::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            tai,
            cancelled_cells_in_tai_eutra,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.tai.encode(data)?;
        self.cancelled_cells_in_tai_eutra.encode(data)?;

        Ok(())
    }
}

impl PerCodec for TaiCancelledEutraItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        TaiCancelledEutraItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TaiCancelledEutraItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TaiCancelledEutraItem");
            e
        })
    }
}
// TaiCancelledNr
#[derive(Clone, Debug)]
pub struct TaiCancelledNr(pub NonEmpty<TaiCancelledNrItem>);

impl TaiCancelledNr {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(TaiCancelledNrItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(65535), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for TaiCancelledNr {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        TaiCancelledNr::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TaiCancelledNr");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TaiCancelledNr");
            e
        })
    }
}
// TaiCancelledNrItem
#[derive(Clone, Debug)]
pub struct TaiCancelledNrItem {
    pub tai: Tai,
    pub cancelled_cells_in_tai_nr: CancelledCellsInTaiNr,
}

impl TaiCancelledNrItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let tai = Tai::decode(data)?;
        let cancelled_cells_in_tai_nr = CancelledCellsInTaiNr::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            tai,
            cancelled_cells_in_tai_nr,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.tai.encode(data)?;
        self.cancelled_cells_in_tai_nr.encode(data)?;

        Ok(())
    }
}

impl PerCodec for TaiCancelledNrItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        TaiCancelledNrItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TaiCancelledNrItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TaiCancelledNrItem");
            e
        })
    }
}
// TaiListForInactive
#[derive(Clone, Debug)]
pub struct TaiListForInactive(pub NonEmpty<TaiListForInactiveItem>);

impl TaiListForInactive {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(16), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(TaiListForInactiveItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(16), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for TaiListForInactive {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        TaiListForInactive::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TaiListForInactive");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TaiListForInactive");
            e
        })
    }
}
// TaiListForInactiveItem
#[derive(Clone, Debug)]
pub struct TaiListForInactiveItem {
    pub tai: Tai,
}

impl TaiListForInactiveItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let tai = Tai::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self { tai })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.tai.encode(data)?;

        Ok(())
    }
}

impl PerCodec for TaiListForInactiveItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        TaiListForInactiveItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TaiListForInactiveItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TaiListForInactiveItem");
            e
        })
    }
}
// TaiListForPaging
#[derive(Clone, Debug)]
pub struct TaiListForPaging(pub NonEmpty<TaiListForPagingItem>);

impl TaiListForPaging {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(16), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(TaiListForPagingItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(16), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for TaiListForPaging {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        TaiListForPaging::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TaiListForPaging");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TaiListForPaging");
            e
        })
    }
}
// TaiListForPagingItem
#[derive(Clone, Debug)]
pub struct TaiListForPagingItem {
    pub tai: Tai,
}

impl TaiListForPagingItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let tai = Tai::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self { tai })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.tai.encode(data)?;

        Ok(())
    }
}

impl PerCodec for TaiListForPagingItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        TaiListForPagingItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TaiListForPagingItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TaiListForPagingItem");
            e
        })
    }
}
// TaiListForRestart
#[derive(Clone, Debug)]
pub struct TaiListForRestart(pub NonEmpty<Tai>);

impl TaiListForRestart {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(2048), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(Tai::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(2048), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for TaiListForRestart {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        TaiListForRestart::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TaiListForRestart");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TaiListForRestart");
            e
        })
    }
}
// TaiListForWarning
#[derive(Clone, Debug)]
pub struct TaiListForWarning(pub NonEmpty<Tai>);

impl TaiListForWarning {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(Tai::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(65535), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for TaiListForWarning {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        TaiListForWarning::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TaiListForWarning");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TaiListForWarning");
            e
        })
    }
}
// TargetEnbId
#[derive(Clone, Debug)]
pub struct TargetEnbId {
    pub global_enb_id: GlobalNgEnbId,
    pub selected_eps_tai: EpsTai,
}

impl TargetEnbId {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let global_enb_id = GlobalNgEnbId::decode(data)?;
        let selected_eps_tai = EpsTai::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            global_enb_id,
            selected_eps_tai,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.global_enb_id.encode(data)?;
        self.selected_eps_tai.encode(data)?;

        Ok(())
    }
}

impl PerCodec for TargetEnbId {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        TargetEnbId::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TargetEnbId");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TargetEnbId");
            e
        })
    }
}
// TargetId
#[derive(Clone, Debug)]
pub enum TargetId {
    TargetRanNodeId(TargetRanNodeId),
    TargetEnbId(TargetEnbId),
    TargetRncId(TargetRncId),
}

impl TargetId {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_choice_idx(data, 0, 2, false)?;
        if extended {
            return Err(PerCodecError::new("CHOICE additions not implemented"));
        }
        match idx {
            0 => Ok(Self::TargetRanNodeId(TargetRanNodeId::decode(data)?)),
            1 => Ok(Self::TargetEnbId(TargetEnbId::decode(data)?)),
            2 => {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _ = Criticality::decode(data)?;
                let _ = decode::decode_length_determinent(data, None, None, false)?;
                let result = match id {
                    178 => Ok(Self::TargetRncId(TargetRncId::decode(data)?)),
                    x => Err(PerCodecError::new(format!("Unrecognised IE type {}", x))),
                };
                data.decode_align()?;
                result
            }
            _ => Err(PerCodecError::new("Unknown choice idx")),
        }
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        match self {
            Self::TargetRanNodeId(x) => {
                encode::encode_choice_idx(data, 0, 2, false, 0, false)?;
                x.encode(data)
            }
            Self::TargetEnbId(x) => {
                encode::encode_choice_idx(data, 0, 2, false, 1, false)?;
                x.encode(data)
            }
            Self::TargetRncId(x) => {
                encode::encode_choice_idx(data, 0, 2, false, 2, false)?;
                encode::encode_integer(data, Some(0), Some(65535), false, 178, false)?;
                Criticality::Reject.encode(data)?;
                let ie = &mut Allocator::new_codec_data();
                x.encode(ie)?;
                encode::encode_length_determinent(data, None, None, false, ie.length_in_bytes())?;
                Ok(data.append_aligned(ie))
            }
        }
    }
}

impl PerCodec for TargetId {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        TargetId::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TargetId");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TargetId");
            e
        })
    }
}
// TargetNgranNodeToSourceNgranNodeTransparentContainer
#[derive(Clone, Debug)]
pub struct TargetNgranNodeToSourceNgranNodeTransparentContainer {
    pub rrc_container: RrcContainer,
    pub daps_response_info_list: Option<DapsResponseInfoList>,
}

impl TargetNgranNodeToSourceNgranNodeTransparentContainer {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let rrc_container = RrcContainer::decode(data)?;

        // Process the extension container
        let mut daps_response_info_list: Option<DapsResponseInfoList> = None;

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    267 => daps_response_info_list = Some(DapsResponseInfoList::decode(data)?),
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            rrc_container,
            daps_response_info_list,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();
        if let Some(x) = &self.daps_response_info_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 267, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        let mut optionals = BitString::new();
        optionals.push(num_ies != 0);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.rrc_container.encode(data)?;
        if num_ies != 0 {
            encode::encode_length_determinent(data, Some(1), Some(65535), false, num_ies)?;
            data.append_aligned(ies);
        }
        Ok(())
    }
}

impl PerCodec for TargetNgranNodeToSourceNgranNodeTransparentContainer {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        TargetNgranNodeToSourceNgranNodeTransparentContainer::decode_inner(data).map_err(
            |mut e: PerCodecError| {
                e.push_context("TargetNgranNodeToSourceNgranNodeTransparentContainer");
                e
            },
        )
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TargetNgranNodeToSourceNgranNodeTransparentContainer");
            e
        })
    }
}
// TargetNgranNodeToSourceNgranNodeFailureTransparentContainer
#[derive(Clone, Debug)]
pub struct TargetNgranNodeToSourceNgranNodeFailureTransparentContainer {
    pub cell_cag_information: CellCagInformation,
}

impl TargetNgranNodeToSourceNgranNodeFailureTransparentContainer {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let cell_cag_information = CellCagInformation::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            cell_cag_information,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.cell_cag_information.encode(data)?;

        Ok(())
    }
}

impl PerCodec for TargetNgranNodeToSourceNgranNodeFailureTransparentContainer {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        TargetNgranNodeToSourceNgranNodeFailureTransparentContainer::decode_inner(data).map_err(
            |mut e: PerCodecError| {
                e.push_context("TargetNgranNodeToSourceNgranNodeFailureTransparentContainer");
                e
            },
        )
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TargetNgranNodeToSourceNgranNodeFailureTransparentContainer");
            e
        })
    }
}
// TargetRanNodeId
#[derive(Clone, Debug)]
pub struct TargetRanNodeId {
    pub global_ran_node_id: GlobalRanNodeId,
    pub selected_tai: Tai,
}

impl TargetRanNodeId {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let global_ran_node_id = GlobalRanNodeId::decode(data)?;
        let selected_tai = Tai::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            global_ran_node_id,
            selected_tai,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.global_ran_node_id.encode(data)?;
        self.selected_tai.encode(data)?;

        Ok(())
    }
}

impl PerCodec for TargetRanNodeId {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        TargetRanNodeId::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TargetRanNodeId");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TargetRanNodeId");
            e
        })
    }
}
// TargetRncId
#[derive(Clone, Debug)]
pub struct TargetRncId {
    pub lai: Lai,
    pub rnc_id: RncId,
    pub extended_rnc_id: Option<ExtendedRncId>,
}

impl TargetRncId {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 2)?;
        let lai = Lai::decode(data)?;
        let rnc_id = RncId::decode(data)?;
        let extended_rnc_id = if optionals[0] {
            Some(ExtendedRncId::decode(data)?)
        } else {
            None
        };

        // Process the extension container

        if optionals[1] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            lai,
            rnc_id,
            extended_rnc_id,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.extended_rnc_id.is_some());
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.lai.encode(data)?;
        self.rnc_id.encode(data)?;
        if let Some(x) = &self.extended_rnc_id {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl PerCodec for TargetRncId {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        TargetRncId::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TargetRncId");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TargetRncId");
            e
        })
    }
}
// TargetToSourceTransparentContainer
#[derive(Clone, Debug)]
pub struct TargetToSourceTransparentContainer(pub Vec<u8>);

impl TargetToSourceTransparentContainer {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(decode::decode_octetstring(data, None, None, false)?))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_octetstring(data, None, None, false, &self.0, false)
    }
}

impl PerCodec for TargetToSourceTransparentContainer {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        TargetToSourceTransparentContainer::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TargetToSourceTransparentContainer");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TargetToSourceTransparentContainer");
            e
        })
    }
}
// TargettoSourceFailureTransparentContainer
#[derive(Clone, Debug)]
pub struct TargettoSourceFailureTransparentContainer(pub Vec<u8>);

impl TargettoSourceFailureTransparentContainer {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(decode::decode_octetstring(data, None, None, false)?))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_octetstring(data, None, None, false, &self.0, false)
    }
}

impl PerCodec for TargettoSourceFailureTransparentContainer {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        TargettoSourceFailureTransparentContainer::decode_inner(data).map_err(
            |mut e: PerCodecError| {
                e.push_context("TargettoSourceFailureTransparentContainer");
                e
            },
        )
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TargettoSourceFailureTransparentContainer");
            e
        })
    }
}
// TimerApproachForGuamiRemoval
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum TimerApproachForGuamiRemoval {
    ApplyTimer,
}

impl TimerApproachForGuamiRemoval {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(0), true)?;
        if extended {
            return Err(PerCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(data, Some(0), Some(0), true, *self as i128, false)
    }
}

impl PerCodec for TimerApproachForGuamiRemoval {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        TimerApproachForGuamiRemoval::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TimerApproachForGuamiRemoval");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TimerApproachForGuamiRemoval");
            e
        })
    }
}
// TimeStamp
#[derive(Clone, Debug)]
pub struct TimeStamp(pub [u8; 4]);

impl TimeStamp {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(
            decode::decode_octetstring(data, Some(4), Some(4), false)?
                .try_into()
                .unwrap(),
        ))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_octetstring(data, Some(4), Some(4), false, &(self.0).into(), false)
    }
}

impl PerCodec for TimeStamp {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        TimeStamp::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TimeStamp");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TimeStamp");
            e
        })
    }
}
// TimeToWait
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum TimeToWait {
    V1s,
    V2s,
    V5s,
    V10s,
    V20s,
    V60s,
}

impl TimeToWait {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(5), true)?;
        if extended {
            return Err(PerCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(data, Some(0), Some(5), true, *self as i128, false)
    }
}

impl PerCodec for TimeToWait {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        TimeToWait::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TimeToWait");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TimeToWait");
            e
        })
    }
}
// TimeUeStayedInCell
#[derive(Clone, Copy, Debug)]
pub struct TimeUeStayedInCell(pub u16);

impl TimeUeStayedInCell {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(
            decode::decode_integer(data, Some(0), Some(4095), false)?.0 as u16,
        ))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_integer(data, Some(0), Some(4095), false, self.0 as i128, false)
    }
}

impl PerCodec for TimeUeStayedInCell {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        TimeUeStayedInCell::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TimeUeStayedInCell");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TimeUeStayedInCell");
            e
        })
    }
}
// TimeUeStayedInCellEnhancedGranularity
#[derive(Clone, Copy, Debug)]
pub struct TimeUeStayedInCellEnhancedGranularity(pub u16);

impl TimeUeStayedInCellEnhancedGranularity {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(
            decode::decode_integer(data, Some(0), Some(40950), false)?.0 as u16,
        ))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_integer(data, Some(0), Some(40950), false, self.0 as i128, false)
    }
}

impl PerCodec for TimeUeStayedInCellEnhancedGranularity {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        TimeUeStayedInCellEnhancedGranularity::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TimeUeStayedInCellEnhancedGranularity");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TimeUeStayedInCellEnhancedGranularity");
            e
        })
    }
}
// TnapId
#[derive(Clone, Debug)]
pub struct TnapId(pub Vec<u8>);

impl TnapId {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(decode::decode_octetstring(data, None, None, false)?))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_octetstring(data, None, None, false, &self.0, false)
    }
}

impl PerCodec for TnapId {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        TnapId::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TnapId");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TnapId");
            e
        })
    }
}
// TngfId
#[derive(Clone, Debug)]
pub enum TngfId {
    TngfId(BitString),
}

impl TngfId {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_choice_idx(data, 0, 1, false)?;
        if extended {
            return Err(PerCodecError::new("CHOICE additions not implemented"));
        }
        match idx {
            0 => Ok(Self::TngfId(decode::decode_bitstring(
                data,
                Some(32),
                Some(32),
                true,
            )?)),
            1 => {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _ = Criticality::decode(data)?;
                let _ = decode::decode_length_determinent(data, None, None, false)?;
                let result = match id {
                    x => Err(PerCodecError::new(format!("Unrecognised IE type {}", x))),
                };
                data.decode_align()?;
                result
            }
            _ => Err(PerCodecError::new("Unknown choice idx")),
        }
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        match self {
            Self::TngfId(x) => {
                encode::encode_choice_idx(data, 0, 1, false, 0, false)?;
                encode::encode_bitstring(data, Some(32), Some(32), true, &x, false)
            }
        }
    }
}

impl PerCodec for TngfId {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        TngfId::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TngfId");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TngfId");
            e
        })
    }
}
// TnlAddressWeightFactor
#[derive(Clone, Copy, Debug)]
pub struct TnlAddressWeightFactor(pub u8);

impl TnlAddressWeightFactor {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(
            decode::decode_integer(data, Some(0), Some(255), false)?.0 as u8,
        ))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_integer(data, Some(0), Some(255), false, self.0 as i128, false)
    }
}

impl PerCodec for TnlAddressWeightFactor {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        TnlAddressWeightFactor::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TnlAddressWeightFactor");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TnlAddressWeightFactor");
            e
        })
    }
}
// TnlAssociationList
#[derive(Clone, Debug)]
pub struct TnlAssociationList(pub NonEmpty<TnlAssociationItem>);

impl TnlAssociationList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(32), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(TnlAssociationItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(32), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for TnlAssociationList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        TnlAssociationList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TnlAssociationList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TnlAssociationList");
            e
        })
    }
}
// TnlAssociationItem
#[derive(Clone, Debug)]
pub struct TnlAssociationItem {
    pub tnl_association_address: CpTransportLayerInformation,
    pub cause: Cause,
}

impl TnlAssociationItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let tnl_association_address = CpTransportLayerInformation::decode(data)?;
        let cause = Cause::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            tnl_association_address,
            cause,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.tnl_association_address.encode(data)?;
        self.cause.encode(data)?;

        Ok(())
    }
}

impl PerCodec for TnlAssociationItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        TnlAssociationItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TnlAssociationItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TnlAssociationItem");
            e
        })
    }
}
// TnlAssociationUsage
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum TnlAssociationUsage {
    Ue,
    NonUe,
    Both,
}

impl TnlAssociationUsage {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(2), true)?;
        if extended {
            return Err(PerCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(data, Some(0), Some(2), true, *self as i128, false)
    }
}

impl PerCodec for TnlAssociationUsage {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        TnlAssociationUsage::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TnlAssociationUsage");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TnlAssociationUsage");
            e
        })
    }
}
// TooearlyIntersystemHo
#[derive(Clone, Debug)]
pub struct TooearlyIntersystemHo {
    pub sourcecell_id: EutraCgi,
    pub failurecell_id: NgranCgi,
    pub ue_rlf_report_container: Option<UeRlfReportContainer>,
}

impl TooearlyIntersystemHo {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 2)?;
        let sourcecell_id = EutraCgi::decode(data)?;
        let failurecell_id = NgranCgi::decode(data)?;
        let ue_rlf_report_container = if optionals[0] {
            Some(UeRlfReportContainer::decode(data)?)
        } else {
            None
        };

        // Process the extension container

        if optionals[1] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            sourcecell_id,
            failurecell_id,
            ue_rlf_report_container,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.ue_rlf_report_container.is_some());
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.sourcecell_id.encode(data)?;
        self.failurecell_id.encode(data)?;
        if let Some(x) = &self.ue_rlf_report_container {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl PerCodec for TooearlyIntersystemHo {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        TooearlyIntersystemHo::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TooearlyIntersystemHo");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TooearlyIntersystemHo");
            e
        })
    }
}
// TraceActivation
#[derive(Clone, Debug)]
pub struct TraceActivation {
    pub ngran_trace_id: NgranTraceId,
    pub interfaces_to_trace: InterfacesToTrace,
    pub trace_depth: TraceDepth,
    pub trace_collection_entity_ip_address: TransportLayerAddress,
    pub mdt_configuration: Option<MdtConfiguration>,
    pub trace_collection_entity_uri: Option<UriAddress>,
}

impl TraceActivation {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let ngran_trace_id = NgranTraceId::decode(data)?;
        let interfaces_to_trace = InterfacesToTrace::decode(data)?;
        let trace_depth = TraceDepth::decode(data)?;
        let trace_collection_entity_ip_address = TransportLayerAddress::decode(data)?;

        // Process the extension container
        let mut mdt_configuration: Option<MdtConfiguration> = None;
        let mut trace_collection_entity_uri: Option<UriAddress> = None;

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    255 => mdt_configuration = Some(MdtConfiguration::decode(data)?),
                    257 => trace_collection_entity_uri = Some(UriAddress::decode(data)?),
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            ngran_trace_id,
            interfaces_to_trace,
            trace_depth,
            trace_collection_entity_ip_address,
            mdt_configuration,
            trace_collection_entity_uri,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();
        if let Some(x) = &self.mdt_configuration {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 255, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.trace_collection_entity_uri {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 257, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        let mut optionals = BitString::new();
        optionals.push(num_ies != 0);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.ngran_trace_id.encode(data)?;
        self.interfaces_to_trace.encode(data)?;
        self.trace_depth.encode(data)?;
        self.trace_collection_entity_ip_address.encode(data)?;
        if num_ies != 0 {
            encode::encode_length_determinent(data, Some(1), Some(65535), false, num_ies)?;
            data.append_aligned(ies);
        }
        Ok(())
    }
}

impl PerCodec for TraceActivation {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        TraceActivation::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TraceActivation");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TraceActivation");
            e
        })
    }
}
// TraceDepth
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum TraceDepth {
    Minimum,
    Medium,
    Maximum,
    MinimumWithoutVendorSpecificExtension,
    MediumWithoutVendorSpecificExtension,
    MaximumWithoutVendorSpecificExtension,
}

impl TraceDepth {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(5), true)?;
        if extended {
            return Err(PerCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(data, Some(0), Some(5), true, *self as i128, false)
    }
}

impl PerCodec for TraceDepth {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        TraceDepth::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TraceDepth");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TraceDepth");
            e
        })
    }
}
// TrafficLoadReductionIndication
#[derive(Clone, Copy, Debug)]
pub struct TrafficLoadReductionIndication(pub u8);

impl TrafficLoadReductionIndication {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(
            decode::decode_integer(data, Some(1), Some(99), false)?.0 as u8,
        ))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_integer(data, Some(1), Some(99), false, self.0 as i128, false)
    }
}

impl PerCodec for TrafficLoadReductionIndication {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        TrafficLoadReductionIndication::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TrafficLoadReductionIndication");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TrafficLoadReductionIndication");
            e
        })
    }
}
// TypeOfError
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum TypeOfError {
    NotUnderstood,
    Missing,
}

impl TypeOfError {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(1), true)?;
        if extended {
            return Err(PerCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(data, Some(0), Some(1), true, *self as i128, false)
    }
}

impl PerCodec for TypeOfError {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        TypeOfError::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TypeOfError");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TypeOfError");
            e
        })
    }
}
// TaiBasedMdt
#[derive(Clone, Debug)]
pub struct TaiBasedMdt {
    pub tai_listfor_mdt: TaiListforMdt,
}

impl TaiBasedMdt {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let tai_listfor_mdt = TaiListforMdt::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self { tai_listfor_mdt })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.tai_listfor_mdt.encode(data)?;

        Ok(())
    }
}

impl PerCodec for TaiBasedMdt {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        TaiBasedMdt::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TaiBasedMdt");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TaiBasedMdt");
            e
        })
    }
}
// TaiListforMdt
#[derive(Clone, Debug)]
pub struct TaiListforMdt(pub NonEmpty<Tai>);

impl TaiListforMdt {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(8), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(Tai::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(8), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for TaiListforMdt {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        TaiListforMdt::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TaiListforMdt");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TaiListforMdt");
            e
        })
    }
}
// TaBasedMdt
#[derive(Clone, Debug)]
pub struct TaBasedMdt {
    pub ta_listfor_mdt: TaListforMdt,
}

impl TaBasedMdt {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let ta_listfor_mdt = TaListforMdt::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self { ta_listfor_mdt })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.ta_listfor_mdt.encode(data)?;

        Ok(())
    }
}

impl PerCodec for TaBasedMdt {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        TaBasedMdt::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TaBasedMdt");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TaBasedMdt");
            e
        })
    }
}
// TaListforMdt
#[derive(Clone, Debug)]
pub struct TaListforMdt(pub NonEmpty<Tac>);

impl TaListforMdt {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(8), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(Tac::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(8), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for TaListforMdt {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        TaListforMdt::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TaListforMdt");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TaListforMdt");
            e
        })
    }
}
// ThresholdRsrp
#[derive(Clone, Copy, Debug)]
pub struct ThresholdRsrp(pub u8);

impl ThresholdRsrp {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(
            decode::decode_integer(data, Some(0), Some(127), false)?.0 as u8,
        ))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_integer(data, Some(0), Some(127), false, self.0 as i128, false)
    }
}

impl PerCodec for ThresholdRsrp {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        ThresholdRsrp::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ThresholdRsrp");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ThresholdRsrp");
            e
        })
    }
}
// ThresholdRsrq
#[derive(Clone, Copy, Debug)]
pub struct ThresholdRsrq(pub u8);

impl ThresholdRsrq {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(
            decode::decode_integer(data, Some(0), Some(127), false)?.0 as u8,
        ))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_integer(data, Some(0), Some(127), false, self.0 as i128, false)
    }
}

impl PerCodec for ThresholdRsrq {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        ThresholdRsrq::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ThresholdRsrq");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ThresholdRsrq");
            e
        })
    }
}
// ThresholdSiNr
#[derive(Clone, Copy, Debug)]
pub struct ThresholdSiNr(pub u8);

impl ThresholdSiNr {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(
            decode::decode_integer(data, Some(0), Some(127), false)?.0 as u8,
        ))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_integer(data, Some(0), Some(127), false, self.0 as i128, false)
    }
}

impl PerCodec for ThresholdSiNr {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        ThresholdSiNr::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ThresholdSiNr");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ThresholdSiNr");
            e
        })
    }
}
// TimeToTrigger
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum TimeToTrigger {
    Ms0,
    Ms40,
    Ms64,
    Ms80,
    Ms100,
    Ms128,
    Ms160,
    Ms256,
    Ms320,
    Ms480,
    Ms512,
    Ms640,
    Ms1024,
    Ms1280,
    Ms2560,
    Ms5120,
}

impl TimeToTrigger {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(15), false)?;
        if extended {
            return Err(PerCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(data, Some(0), Some(15), false, *self as i128, false)
    }
}

impl PerCodec for TimeToTrigger {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        TimeToTrigger::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TimeToTrigger");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TimeToTrigger");
            e
        })
    }
}
// TwapId
#[derive(Clone, Debug)]
pub struct TwapId(pub Vec<u8>);

impl TwapId {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(decode::decode_octetstring(data, None, None, false)?))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_octetstring(data, None, None, false, &self.0, false)
    }
}

impl PerCodec for TwapId {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        TwapId::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TwapId");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TwapId");
            e
        })
    }
}
// TwifId
#[derive(Clone, Debug)]
pub enum TwifId {
    TwifId(BitString),
}

impl TwifId {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_choice_idx(data, 0, 1, false)?;
        if extended {
            return Err(PerCodecError::new("CHOICE additions not implemented"));
        }
        match idx {
            0 => Ok(Self::TwifId(decode::decode_bitstring(
                data,
                Some(32),
                Some(32),
                true,
            )?)),
            1 => {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _ = Criticality::decode(data)?;
                let _ = decode::decode_length_determinent(data, None, None, false)?;
                let result = match id {
                    x => Err(PerCodecError::new(format!("Unrecognised IE type {}", x))),
                };
                data.decode_align()?;
                result
            }
            _ => Err(PerCodecError::new("Unknown choice idx")),
        }
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        match self {
            Self::TwifId(x) => {
                encode::encode_choice_idx(data, 0, 1, false, 0, false)?;
                encode::encode_bitstring(data, Some(32), Some(32), true, &x, false)
            }
        }
    }
}

impl PerCodec for TwifId {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        TwifId::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TwifId");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TwifId");
            e
        })
    }
}
// TscAssistanceInformation
#[derive(Clone, Debug)]
pub struct TscAssistanceInformation {
    pub periodicity: Periodicity,
    pub burst_arrival_time: Option<BurstArrivalTime>,
}

impl TscAssistanceInformation {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 2)?;
        let periodicity = Periodicity::decode(data)?;
        let burst_arrival_time = if optionals[0] {
            Some(BurstArrivalTime::decode(data)?)
        } else {
            None
        };

        // Process the extension container

        if optionals[1] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            periodicity,
            burst_arrival_time,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.burst_arrival_time.is_some());
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.periodicity.encode(data)?;
        if let Some(x) = &self.burst_arrival_time {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl PerCodec for TscAssistanceInformation {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        TscAssistanceInformation::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TscAssistanceInformation");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TscAssistanceInformation");
            e
        })
    }
}
// TscTrafficCharacteristics
#[derive(Clone, Debug)]
pub struct TscTrafficCharacteristics {
    pub tsc_assistance_information_dl: Option<TscAssistanceInformation>,
    pub tsc_assistance_information_ul: Option<TscAssistanceInformation>,
}

impl TscTrafficCharacteristics {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 3)?;
        let tsc_assistance_information_dl = if optionals[0] {
            Some(TscAssistanceInformation::decode(data)?)
        } else {
            None
        };
        let tsc_assistance_information_ul = if optionals[1] {
            Some(TscAssistanceInformation::decode(data)?)
        } else {
            None
        };

        // Process the extension container

        if optionals[2] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            tsc_assistance_information_dl,
            tsc_assistance_information_ul,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.tsc_assistance_information_dl.is_some());
        optionals.push(self.tsc_assistance_information_ul.is_some());
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        if let Some(x) = &self.tsc_assistance_information_dl {
            x.encode(data)?;
        }
        if let Some(x) = &self.tsc_assistance_information_ul {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl PerCodec for TscTrafficCharacteristics {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        TscTrafficCharacteristics::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TscTrafficCharacteristics");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TscTrafficCharacteristics");
            e
        })
    }
}
// UeAggregateMaximumBitRate
#[derive(Clone, Debug)]
pub struct UeAggregateMaximumBitRate {
    pub ue_aggregate_maximum_bit_rate_dl: BitRate,
    pub ue_aggregate_maximum_bit_rate_ul: BitRate,
}

impl UeAggregateMaximumBitRate {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let ue_aggregate_maximum_bit_rate_dl = BitRate::decode(data)?;
        let ue_aggregate_maximum_bit_rate_ul = BitRate::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            ue_aggregate_maximum_bit_rate_dl,
            ue_aggregate_maximum_bit_rate_ul,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.ue_aggregate_maximum_bit_rate_dl.encode(data)?;
        self.ue_aggregate_maximum_bit_rate_ul.encode(data)?;

        Ok(())
    }
}

impl PerCodec for UeAggregateMaximumBitRate {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        UeAggregateMaximumBitRate::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UeAggregateMaximumBitRate");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UeAggregateMaximumBitRate");
            e
        })
    }
}
// UeAssociatedLogicalNgConnectionList
#[derive(Clone, Debug)]
pub struct UeAssociatedLogicalNgConnectionList(pub NonEmpty<UeAssociatedLogicalNgConnectionItem>);

impl UeAssociatedLogicalNgConnectionList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(65536), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(UeAssociatedLogicalNgConnectionItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(65536), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for UeAssociatedLogicalNgConnectionList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        UeAssociatedLogicalNgConnectionList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UeAssociatedLogicalNgConnectionList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UeAssociatedLogicalNgConnectionList");
            e
        })
    }
}
// UeAssociatedLogicalNgConnectionItem
#[derive(Clone, Debug)]
pub struct UeAssociatedLogicalNgConnectionItem {
    pub amf_ue_ngap_id: Option<AmfUeNgapId>,
    pub ran_ue_ngap_id: Option<RanUeNgapId>,
}

impl UeAssociatedLogicalNgConnectionItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 3)?;
        let amf_ue_ngap_id = if optionals[0] {
            Some(AmfUeNgapId::decode(data)?)
        } else {
            None
        };
        let ran_ue_ngap_id = if optionals[1] {
            Some(RanUeNgapId::decode(data)?)
        } else {
            None
        };

        // Process the extension container

        if optionals[2] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            amf_ue_ngap_id,
            ran_ue_ngap_id,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.amf_ue_ngap_id.is_some());
        optionals.push(self.ran_ue_ngap_id.is_some());
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        if let Some(x) = &self.amf_ue_ngap_id {
            x.encode(data)?;
        }
        if let Some(x) = &self.ran_ue_ngap_id {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl PerCodec for UeAssociatedLogicalNgConnectionItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        UeAssociatedLogicalNgConnectionItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UeAssociatedLogicalNgConnectionItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UeAssociatedLogicalNgConnectionItem");
            e
        })
    }
}
// UeCapabilityInfoRequest
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum UeCapabilityInfoRequest {
    Requested,
}

impl UeCapabilityInfoRequest {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(0), true)?;
        if extended {
            return Err(PerCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(data, Some(0), Some(0), true, *self as i128, false)
    }
}

impl PerCodec for UeCapabilityInfoRequest {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        UeCapabilityInfoRequest::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UeCapabilityInfoRequest");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UeCapabilityInfoRequest");
            e
        })
    }
}
// UeContextRequest
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum UeContextRequest {
    Requested,
}

impl UeContextRequest {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(0), true)?;
        if extended {
            return Err(PerCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(data, Some(0), Some(0), true, *self as i128, false)
    }
}

impl PerCodec for UeContextRequest {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        UeContextRequest::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UeContextRequest");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UeContextRequest");
            e
        })
    }
}
// UeContextResumeRequestTransfer
#[derive(Clone, Debug)]
pub struct UeContextResumeRequestTransfer {
    pub qos_flow_failed_to_resume_list: Option<QosFlowListWithCause>,
}

impl UeContextResumeRequestTransfer {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 2)?;
        let qos_flow_failed_to_resume_list = if optionals[0] {
            Some(QosFlowListWithCause::decode(data)?)
        } else {
            None
        };

        // Process the extension container

        if optionals[1] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            qos_flow_failed_to_resume_list,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.qos_flow_failed_to_resume_list.is_some());
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        if let Some(x) = &self.qos_flow_failed_to_resume_list {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl PerCodec for UeContextResumeRequestTransfer {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        UeContextResumeRequestTransfer::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UeContextResumeRequestTransfer");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UeContextResumeRequestTransfer");
            e
        })
    }
}
// UeContextResumeResponseTransfer
#[derive(Clone, Debug)]
pub struct UeContextResumeResponseTransfer {
    pub qos_flow_failed_to_resume_list: Option<QosFlowListWithCause>,
}

impl UeContextResumeResponseTransfer {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 2)?;
        let qos_flow_failed_to_resume_list = if optionals[0] {
            Some(QosFlowListWithCause::decode(data)?)
        } else {
            None
        };

        // Process the extension container

        if optionals[1] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            qos_flow_failed_to_resume_list,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.qos_flow_failed_to_resume_list.is_some());
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        if let Some(x) = &self.qos_flow_failed_to_resume_list {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl PerCodec for UeContextResumeResponseTransfer {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        UeContextResumeResponseTransfer::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UeContextResumeResponseTransfer");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UeContextResumeResponseTransfer");
            e
        })
    }
}
// UeContextSuspendRequestTransfer
#[derive(Clone, Debug)]
pub struct UeContextSuspendRequestTransfer {
    pub suspend_indicator: Option<SuspendIndicator>,
}

impl UeContextSuspendRequestTransfer {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 2)?;
        let suspend_indicator = if optionals[0] {
            Some(SuspendIndicator::decode(data)?)
        } else {
            None
        };

        // Process the extension container

        if optionals[1] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self { suspend_indicator })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.suspend_indicator.is_some());
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        if let Some(x) = &self.suspend_indicator {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl PerCodec for UeContextSuspendRequestTransfer {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        UeContextSuspendRequestTransfer::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UeContextSuspendRequestTransfer");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UeContextSuspendRequestTransfer");
            e
        })
    }
}
// UeDifferentiationInfo
#[derive(Clone, Debug)]
pub struct UeDifferentiationInfo {
    pub periodic_communication_indicator: Option<PeriodicCommunicationIndicator>,
    pub periodic_time: Option<u16>,
    pub scheduled_communication_time: Option<ScheduledCommunicationTime>,
    pub stationary_indication: Option<StationaryIndication>,
    pub traffic_profile: Option<TrafficProfile>,
    pub battery_indication: Option<BatteryIndication>,
}

impl UeDifferentiationInfo {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 7)?;
        let periodic_communication_indicator = if optionals[0] {
            Some(PeriodicCommunicationIndicator::decode(data)?)
        } else {
            None
        };
        let periodic_time = if optionals[1] {
            Some(decode::decode_integer(data, Some(1), Some(3600), true)?.0 as u16)
        } else {
            None
        };
        let scheduled_communication_time = if optionals[2] {
            Some(ScheduledCommunicationTime::decode(data)?)
        } else {
            None
        };
        let stationary_indication = if optionals[3] {
            Some(StationaryIndication::decode(data)?)
        } else {
            None
        };
        let traffic_profile = if optionals[4] {
            Some(TrafficProfile::decode(data)?)
        } else {
            None
        };
        let battery_indication = if optionals[5] {
            Some(BatteryIndication::decode(data)?)
        } else {
            None
        };

        // Process the extension container

        if optionals[6] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            periodic_communication_indicator,
            periodic_time,
            scheduled_communication_time,
            stationary_indication,
            traffic_profile,
            battery_indication,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.periodic_communication_indicator.is_some());
        optionals.push(self.periodic_time.is_some());
        optionals.push(self.scheduled_communication_time.is_some());
        optionals.push(self.stationary_indication.is_some());
        optionals.push(self.traffic_profile.is_some());
        optionals.push(self.battery_indication.is_some());
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        if let Some(x) = &self.periodic_communication_indicator {
            x.encode(data)?;
        }
        if let Some(x) = &self.periodic_time {
            encode::encode_integer(data, Some(1), Some(3600), true, *x as i128, false)?;
        }
        if let Some(x) = &self.scheduled_communication_time {
            x.encode(data)?;
        }
        if let Some(x) = &self.stationary_indication {
            x.encode(data)?;
        }
        if let Some(x) = &self.traffic_profile {
            x.encode(data)?;
        }
        if let Some(x) = &self.battery_indication {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl PerCodec for UeDifferentiationInfo {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        UeDifferentiationInfo::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UeDifferentiationInfo");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UeDifferentiationInfo");
            e
        })
    }
}
// UeHistoryInformation
#[derive(Clone, Debug)]
pub struct UeHistoryInformation(pub NonEmpty<LastVisitedCellItem>);

impl UeHistoryInformation {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(16), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(LastVisitedCellItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(16), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for UeHistoryInformation {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        UeHistoryInformation::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UeHistoryInformation");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UeHistoryInformation");
            e
        })
    }
}
// UeHistoryInformationFromTheUe
#[derive(Clone, Debug)]
pub enum UeHistoryInformationFromTheUe {
    Nr(NrMobilityHistoryReport),
}

impl UeHistoryInformationFromTheUe {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_choice_idx(data, 0, 1, false)?;
        if extended {
            return Err(PerCodecError::new("CHOICE additions not implemented"));
        }
        match idx {
            0 => Ok(Self::Nr(NrMobilityHistoryReport::decode(data)?)),
            1 => {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _ = Criticality::decode(data)?;
                let _ = decode::decode_length_determinent(data, None, None, false)?;
                let result = match id {
                    x => Err(PerCodecError::new(format!("Unrecognised IE type {}", x))),
                };
                data.decode_align()?;
                result
            }
            _ => Err(PerCodecError::new("Unknown choice idx")),
        }
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        match self {
            Self::Nr(x) => {
                encode::encode_choice_idx(data, 0, 1, false, 0, false)?;
                x.encode(data)
            }
        }
    }
}

impl PerCodec for UeHistoryInformationFromTheUe {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        UeHistoryInformationFromTheUe::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UeHistoryInformationFromTheUe");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UeHistoryInformationFromTheUe");
            e
        })
    }
}
// UeIdentityIndexValue
#[derive(Clone, Debug)]
pub enum UeIdentityIndexValue {
    IndexLength10(BitString),
}

impl UeIdentityIndexValue {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_choice_idx(data, 0, 1, false)?;
        if extended {
            return Err(PerCodecError::new("CHOICE additions not implemented"));
        }
        match idx {
            0 => Ok(Self::IndexLength10(decode::decode_bitstring(
                data,
                Some(10),
                Some(10),
                false,
            )?)),
            1 => {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _ = Criticality::decode(data)?;
                let _ = decode::decode_length_determinent(data, None, None, false)?;
                let result = match id {
                    x => Err(PerCodecError::new(format!("Unrecognised IE type {}", x))),
                };
                data.decode_align()?;
                result
            }
            _ => Err(PerCodecError::new("Unknown choice idx")),
        }
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        match self {
            Self::IndexLength10(x) => {
                encode::encode_choice_idx(data, 0, 1, false, 0, false)?;
                encode::encode_bitstring(data, Some(10), Some(10), false, &x, false)
            }
        }
    }
}

impl PerCodec for UeIdentityIndexValue {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        UeIdentityIndexValue::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UeIdentityIndexValue");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UeIdentityIndexValue");
            e
        })
    }
}
// UeNgapIDs
#[derive(Clone, Debug)]
pub enum UeNgapIDs {
    UeNgapIdPair(UeNgapIdPair),
    AmfUeNgapId(AmfUeNgapId),
}

impl UeNgapIDs {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_choice_idx(data, 0, 2, false)?;
        if extended {
            return Err(PerCodecError::new("CHOICE additions not implemented"));
        }
        match idx {
            0 => Ok(Self::UeNgapIdPair(UeNgapIdPair::decode(data)?)),
            1 => Ok(Self::AmfUeNgapId(AmfUeNgapId::decode(data)?)),
            2 => {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _ = Criticality::decode(data)?;
                let _ = decode::decode_length_determinent(data, None, None, false)?;
                let result = match id {
                    x => Err(PerCodecError::new(format!("Unrecognised IE type {}", x))),
                };
                data.decode_align()?;
                result
            }
            _ => Err(PerCodecError::new("Unknown choice idx")),
        }
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        match self {
            Self::UeNgapIdPair(x) => {
                encode::encode_choice_idx(data, 0, 2, false, 0, false)?;
                x.encode(data)
            }
            Self::AmfUeNgapId(x) => {
                encode::encode_choice_idx(data, 0, 2, false, 1, false)?;
                x.encode(data)
            }
        }
    }
}

impl PerCodec for UeNgapIDs {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        UeNgapIDs::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UeNgapIDs");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UeNgapIDs");
            e
        })
    }
}
// UeNgapIdPair
#[derive(Clone, Debug)]
pub struct UeNgapIdPair {
    pub amf_ue_ngap_id: AmfUeNgapId,
    pub ran_ue_ngap_id: RanUeNgapId,
}

impl UeNgapIdPair {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let amf_ue_ngap_id = AmfUeNgapId::decode(data)?;
        let ran_ue_ngap_id = RanUeNgapId::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            amf_ue_ngap_id,
            ran_ue_ngap_id,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.amf_ue_ngap_id.encode(data)?;
        self.ran_ue_ngap_id.encode(data)?;

        Ok(())
    }
}

impl PerCodec for UeNgapIdPair {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        UeNgapIdPair::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UeNgapIdPair");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UeNgapIdPair");
            e
        })
    }
}
// UePagingIdentity
#[derive(Clone, Debug)]
pub enum UePagingIdentity {
    FiveGSTmsi(FiveGSTmsi),
}

impl UePagingIdentity {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_choice_idx(data, 0, 1, false)?;
        if extended {
            return Err(PerCodecError::new("CHOICE additions not implemented"));
        }
        match idx {
            0 => Ok(Self::FiveGSTmsi(FiveGSTmsi::decode(data)?)),
            1 => {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _ = Criticality::decode(data)?;
                let _ = decode::decode_length_determinent(data, None, None, false)?;
                let result = match id {
                    x => Err(PerCodecError::new(format!("Unrecognised IE type {}", x))),
                };
                data.decode_align()?;
                result
            }
            _ => Err(PerCodecError::new("Unknown choice idx")),
        }
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        match self {
            Self::FiveGSTmsi(x) => {
                encode::encode_choice_idx(data, 0, 1, false, 0, false)?;
                x.encode(data)
            }
        }
    }
}

impl PerCodec for UePagingIdentity {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        UePagingIdentity::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UePagingIdentity");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UePagingIdentity");
            e
        })
    }
}
// UePresence
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum UePresence {
    In,
    Out,
    Unknown,
}

impl UePresence {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(2), true)?;
        if extended {
            return Err(PerCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(data, Some(0), Some(2), true, *self as i128, false)
    }
}

impl PerCodec for UePresence {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        UePresence::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UePresence");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UePresence");
            e
        })
    }
}
// UePresenceInAreaOfInterestList
#[derive(Clone, Debug)]
pub struct UePresenceInAreaOfInterestList(pub NonEmpty<UePresenceInAreaOfInterestItem>);

impl UePresenceInAreaOfInterestList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(64), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(UePresenceInAreaOfInterestItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(64), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for UePresenceInAreaOfInterestList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        UePresenceInAreaOfInterestList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UePresenceInAreaOfInterestList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UePresenceInAreaOfInterestList");
            e
        })
    }
}
// UePresenceInAreaOfInterestItem
#[derive(Clone, Debug)]
pub struct UePresenceInAreaOfInterestItem {
    pub location_reporting_reference_id: LocationReportingReferenceId,
    pub ue_presence: UePresence,
}

impl UePresenceInAreaOfInterestItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let location_reporting_reference_id = LocationReportingReferenceId::decode(data)?;
        let ue_presence = UePresence::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            location_reporting_reference_id,
            ue_presence,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.location_reporting_reference_id.encode(data)?;
        self.ue_presence.encode(data)?;

        Ok(())
    }
}

impl PerCodec for UePresenceInAreaOfInterestItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        UePresenceInAreaOfInterestItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UePresenceInAreaOfInterestItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UePresenceInAreaOfInterestItem");
            e
        })
    }
}
// UeRadioCapability
#[derive(Clone, Debug)]
pub struct UeRadioCapability(pub Vec<u8>);

impl UeRadioCapability {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(decode::decode_octetstring(data, None, None, false)?))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_octetstring(data, None, None, false, &self.0, false)
    }
}

impl PerCodec for UeRadioCapability {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        UeRadioCapability::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UeRadioCapability");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UeRadioCapability");
            e
        })
    }
}
// UeRadioCapabilityForPaging
#[derive(Clone, Debug)]
pub struct UeRadioCapabilityForPaging {
    pub ue_radio_capability_for_paging_of_nr: Option<UeRadioCapabilityForPagingOfNr>,
    pub ue_radio_capability_for_paging_of_eutra: Option<UeRadioCapabilityForPagingOfEutra>,
    pub ue_radio_capability_for_paging_of_nb_iot: Option<UeRadioCapabilityForPagingOfNbIot>,
}

impl UeRadioCapabilityForPaging {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 3)?;
        let ue_radio_capability_for_paging_of_nr = if optionals[0] {
            Some(UeRadioCapabilityForPagingOfNr::decode(data)?)
        } else {
            None
        };
        let ue_radio_capability_for_paging_of_eutra = if optionals[1] {
            Some(UeRadioCapabilityForPagingOfEutra::decode(data)?)
        } else {
            None
        };

        // Process the extension container
        let mut ue_radio_capability_for_paging_of_nb_iot: Option<
            UeRadioCapabilityForPagingOfNbIot,
        > = None;

        if optionals[2] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    214 => {
                        ue_radio_capability_for_paging_of_nb_iot =
                            Some(UeRadioCapabilityForPagingOfNbIot::decode(data)?)
                    }
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            ue_radio_capability_for_paging_of_nr,
            ue_radio_capability_for_paging_of_eutra,
            ue_radio_capability_for_paging_of_nb_iot,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();
        if let Some(x) = &self.ue_radio_capability_for_paging_of_nb_iot {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 214, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        let mut optionals = BitString::new();
        optionals.push(self.ue_radio_capability_for_paging_of_nr.is_some());
        optionals.push(self.ue_radio_capability_for_paging_of_eutra.is_some());
        optionals.push(num_ies != 0);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        if let Some(x) = &self.ue_radio_capability_for_paging_of_nr {
            x.encode(data)?;
        }
        if let Some(x) = &self.ue_radio_capability_for_paging_of_eutra {
            x.encode(data)?;
        }
        if num_ies != 0 {
            encode::encode_length_determinent(data, Some(1), Some(65535), false, num_ies)?;
            data.append_aligned(ies);
        }
        Ok(())
    }
}

impl PerCodec for UeRadioCapabilityForPaging {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        UeRadioCapabilityForPaging::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UeRadioCapabilityForPaging");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UeRadioCapabilityForPaging");
            e
        })
    }
}
// UeRadioCapabilityForPagingOfNbIot
#[derive(Clone, Debug)]
pub struct UeRadioCapabilityForPagingOfNbIot(pub Vec<u8>);

impl UeRadioCapabilityForPagingOfNbIot {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(decode::decode_octetstring(data, None, None, false)?))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_octetstring(data, None, None, false, &self.0, false)
    }
}

impl PerCodec for UeRadioCapabilityForPagingOfNbIot {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        UeRadioCapabilityForPagingOfNbIot::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UeRadioCapabilityForPagingOfNbIot");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UeRadioCapabilityForPagingOfNbIot");
            e
        })
    }
}
// UeRadioCapabilityForPagingOfNr
#[derive(Clone, Debug)]
pub struct UeRadioCapabilityForPagingOfNr(pub Vec<u8>);

impl UeRadioCapabilityForPagingOfNr {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(decode::decode_octetstring(data, None, None, false)?))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_octetstring(data, None, None, false, &self.0, false)
    }
}

impl PerCodec for UeRadioCapabilityForPagingOfNr {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        UeRadioCapabilityForPagingOfNr::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UeRadioCapabilityForPagingOfNr");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UeRadioCapabilityForPagingOfNr");
            e
        })
    }
}
// UeRadioCapabilityForPagingOfEutra
#[derive(Clone, Debug)]
pub struct UeRadioCapabilityForPagingOfEutra(pub Vec<u8>);

impl UeRadioCapabilityForPagingOfEutra {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(decode::decode_octetstring(data, None, None, false)?))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_octetstring(data, None, None, false, &self.0, false)
    }
}

impl PerCodec for UeRadioCapabilityForPagingOfEutra {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        UeRadioCapabilityForPagingOfEutra::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UeRadioCapabilityForPagingOfEutra");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UeRadioCapabilityForPagingOfEutra");
            e
        })
    }
}
// UeRadioCapabilityId
#[derive(Clone, Debug)]
pub struct UeRadioCapabilityId(pub Vec<u8>);

impl UeRadioCapabilityId {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(decode::decode_octetstring(data, None, None, false)?))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_octetstring(data, None, None, false, &self.0, false)
    }
}

impl PerCodec for UeRadioCapabilityId {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        UeRadioCapabilityId::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UeRadioCapabilityId");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UeRadioCapabilityId");
            e
        })
    }
}
// UeRetentionInformation
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum UeRetentionInformation {
    UesRetained,
}

impl UeRetentionInformation {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(0), true)?;
        if extended {
            return Err(PerCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(data, Some(0), Some(0), true, *self as i128, false)
    }
}

impl PerCodec for UeRetentionInformation {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        UeRetentionInformation::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UeRetentionInformation");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UeRetentionInformation");
            e
        })
    }
}
// UeRlfReportContainer
#[derive(Clone, Debug)]
pub enum UeRlfReportContainer {
    Nr(NrUeRlfReportContainer),
    Lte(LteUeRlfReportContainer),
}

impl UeRlfReportContainer {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_choice_idx(data, 0, 2, false)?;
        if extended {
            return Err(PerCodecError::new("CHOICE additions not implemented"));
        }
        match idx {
            0 => Ok(Self::Nr(NrUeRlfReportContainer::decode(data)?)),
            1 => Ok(Self::Lte(LteUeRlfReportContainer::decode(data)?)),
            2 => {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _ = Criticality::decode(data)?;
                let _ = decode::decode_length_determinent(data, None, None, false)?;
                let result = match id {
                    x => Err(PerCodecError::new(format!("Unrecognised IE type {}", x))),
                };
                data.decode_align()?;
                result
            }
            _ => Err(PerCodecError::new("Unknown choice idx")),
        }
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        match self {
            Self::Nr(x) => {
                encode::encode_choice_idx(data, 0, 2, false, 0, false)?;
                x.encode(data)
            }
            Self::Lte(x) => {
                encode::encode_choice_idx(data, 0, 2, false, 1, false)?;
                x.encode(data)
            }
        }
    }
}

impl PerCodec for UeRlfReportContainer {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        UeRlfReportContainer::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UeRlfReportContainer");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UeRlfReportContainer");
            e
        })
    }
}
// UeSecurityCapabilities
#[derive(Clone, Debug)]
pub struct UeSecurityCapabilities {
    pub nr_encryption_algorithms: NrEncryptionAlgorithms,
    pub nr_integrity_protection_algorithms: NrIntegrityProtectionAlgorithms,
    pub eutr_aencryption_algorithms: EutrAencryptionAlgorithms,
    pub eutr_aintegrity_protection_algorithms: EutrAintegrityProtectionAlgorithms,
}

impl UeSecurityCapabilities {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let nr_encryption_algorithms = NrEncryptionAlgorithms::decode(data)?;
        let nr_integrity_protection_algorithms = NrIntegrityProtectionAlgorithms::decode(data)?;
        let eutr_aencryption_algorithms = EutrAencryptionAlgorithms::decode(data)?;
        let eutr_aintegrity_protection_algorithms =
            EutrAintegrityProtectionAlgorithms::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            nr_encryption_algorithms,
            nr_integrity_protection_algorithms,
            eutr_aencryption_algorithms,
            eutr_aintegrity_protection_algorithms,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.nr_encryption_algorithms.encode(data)?;
        self.nr_integrity_protection_algorithms.encode(data)?;
        self.eutr_aencryption_algorithms.encode(data)?;
        self.eutr_aintegrity_protection_algorithms.encode(data)?;

        Ok(())
    }
}

impl PerCodec for UeSecurityCapabilities {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        UeSecurityCapabilities::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UeSecurityCapabilities");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UeSecurityCapabilities");
            e
        })
    }
}
// UeUpCIotSupport
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum UeUpCIotSupport {
    Supported,
}

impl UeUpCIotSupport {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(0), true)?;
        if extended {
            return Err(PerCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(data, Some(0), Some(0), true, *self as i128, false)
    }
}

impl PerCodec for UeUpCIotSupport {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        UeUpCIotSupport::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UeUpCIotSupport");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UeUpCIotSupport");
            e
        })
    }
}
// UlCpSecurityInformation
#[derive(Clone, Debug)]
pub struct UlCpSecurityInformation {
    pub ul_nas_mac: UlNasMac,
    pub ul_nas_count: UlNasCount,
}

impl UlCpSecurityInformation {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let ul_nas_mac = UlNasMac::decode(data)?;
        let ul_nas_count = UlNasCount::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            ul_nas_mac,
            ul_nas_count,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.ul_nas_mac.encode(data)?;
        self.ul_nas_count.encode(data)?;

        Ok(())
    }
}

impl PerCodec for UlCpSecurityInformation {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        UlCpSecurityInformation::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UlCpSecurityInformation");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UlCpSecurityInformation");
            e
        })
    }
}
// UlNasMac
#[derive(Clone, Debug)]
pub struct UlNasMac(pub BitString);

impl UlNasMac {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(decode::decode_bitstring(
            data,
            Some(16),
            Some(16),
            false,
        )?))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_bitstring(data, Some(16), Some(16), false, &self.0, false)
    }
}

impl PerCodec for UlNasMac {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        UlNasMac::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UlNasMac");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UlNasMac");
            e
        })
    }
}
// UlNasCount
#[derive(Clone, Debug)]
pub struct UlNasCount(pub BitString);

impl UlNasCount {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(decode::decode_bitstring(
            data,
            Some(5),
            Some(5),
            false,
        )?))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_bitstring(data, Some(5), Some(5), false, &self.0, false)
    }
}

impl PerCodec for UlNasCount {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        UlNasCount::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UlNasCount");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UlNasCount");
            e
        })
    }
}
// UlNguUpTnlModifyList
#[derive(Clone, Debug)]
pub struct UlNguUpTnlModifyList(pub NonEmpty<UlNguUpTnlModifyItem>);

impl UlNguUpTnlModifyList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(4), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(UlNguUpTnlModifyItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(4), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for UlNguUpTnlModifyList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        UlNguUpTnlModifyList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UlNguUpTnlModifyList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UlNguUpTnlModifyList");
            e
        })
    }
}
// UlNguUpTnlModifyItem
#[derive(Clone, Debug)]
pub struct UlNguUpTnlModifyItem {
    pub ul_ngu_up_tnl_information: UpTransportLayerInformation,
    pub dl_ngu_up_tnl_information: UpTransportLayerInformation,
    pub redundant_ul_ngu_up_tnl_information: Option<UpTransportLayerInformation>,
    pub redundant_dl_ngu_up_tnl_information: Option<UpTransportLayerInformation>,
}

impl UlNguUpTnlModifyItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let ul_ngu_up_tnl_information = UpTransportLayerInformation::decode(data)?;
        let dl_ngu_up_tnl_information = UpTransportLayerInformation::decode(data)?;

        // Process the extension container
        let mut redundant_ul_ngu_up_tnl_information: Option<UpTransportLayerInformation> = None;
        let mut redundant_dl_ngu_up_tnl_information: Option<UpTransportLayerInformation> = None;

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    195 => {
                        redundant_ul_ngu_up_tnl_information =
                            Some(UpTransportLayerInformation::decode(data)?)
                    }
                    192 => {
                        redundant_dl_ngu_up_tnl_information =
                            Some(UpTransportLayerInformation::decode(data)?)
                    }
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            ul_ngu_up_tnl_information,
            dl_ngu_up_tnl_information,
            redundant_ul_ngu_up_tnl_information,
            redundant_dl_ngu_up_tnl_information,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();
        if let Some(x) = &self.redundant_ul_ngu_up_tnl_information {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 195, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.redundant_dl_ngu_up_tnl_information {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 192, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        let mut optionals = BitString::new();
        optionals.push(num_ies != 0);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.ul_ngu_up_tnl_information.encode(data)?;
        self.dl_ngu_up_tnl_information.encode(data)?;
        if num_ies != 0 {
            encode::encode_length_determinent(data, Some(1), Some(65535), false, num_ies)?;
            data.append_aligned(ies);
        }
        Ok(())
    }
}

impl PerCodec for UlNguUpTnlModifyItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        UlNguUpTnlModifyItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UlNguUpTnlModifyItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UlNguUpTnlModifyItem");
            e
        })
    }
}
// UnavailableGuamiList
#[derive(Clone, Debug)]
pub struct UnavailableGuamiList(pub NonEmpty<UnavailableGuamiItem>);

impl UnavailableGuamiList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(256), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(UnavailableGuamiItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(256), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for UnavailableGuamiList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        UnavailableGuamiList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UnavailableGuamiList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UnavailableGuamiList");
            e
        })
    }
}
// UnavailableGuamiItem
#[derive(Clone, Debug)]
pub struct UnavailableGuamiItem {
    pub guami: Guami,
    pub timer_approach_for_guami_removal: Option<TimerApproachForGuamiRemoval>,
    pub backup_amf_name: Option<AmfName>,
}

impl UnavailableGuamiItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 3)?;
        let guami = Guami::decode(data)?;
        let timer_approach_for_guami_removal = if optionals[0] {
            Some(TimerApproachForGuamiRemoval::decode(data)?)
        } else {
            None
        };
        let backup_amf_name = if optionals[1] {
            Some(AmfName::decode(data)?)
        } else {
            None
        };

        // Process the extension container

        if optionals[2] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            guami,
            timer_approach_for_guami_removal,
            backup_amf_name,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.timer_approach_for_guami_removal.is_some());
        optionals.push(self.backup_amf_name.is_some());
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.guami.encode(data)?;
        if let Some(x) = &self.timer_approach_for_guami_removal {
            x.encode(data)?;
        }
        if let Some(x) = &self.backup_amf_name {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl PerCodec for UnavailableGuamiItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        UnavailableGuamiItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UnavailableGuamiItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UnavailableGuamiItem");
            e
        })
    }
}
// UlForwarding
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum UlForwarding {
    UlForwardingProposed,
}

impl UlForwarding {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(0), true)?;
        if extended {
            return Err(PerCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(data, Some(0), Some(0), true, *self as i128, false)
    }
}

impl PerCodec for UlForwarding {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        UlForwarding::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UlForwarding");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UlForwarding");
            e
        })
    }
}
// UpdateFeedback
#[derive(Clone, Debug)]
pub struct UpdateFeedback(pub BitString);

impl UpdateFeedback {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(decode::decode_bitstring(
            data,
            Some(8),
            Some(8),
            true,
        )?))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_bitstring(data, Some(8), Some(8), true, &self.0, false)
    }
}

impl PerCodec for UpdateFeedback {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        UpdateFeedback::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UpdateFeedback");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UpdateFeedback");
            e
        })
    }
}
// UpTransportLayerInformation
#[derive(Clone, Debug)]
pub enum UpTransportLayerInformation {
    GtpTunnel(GtpTunnel),
}

impl UpTransportLayerInformation {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_choice_idx(data, 0, 1, false)?;
        if extended {
            return Err(PerCodecError::new("CHOICE additions not implemented"));
        }
        match idx {
            0 => Ok(Self::GtpTunnel(GtpTunnel::decode(data)?)),
            1 => {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _ = Criticality::decode(data)?;
                let _ = decode::decode_length_determinent(data, None, None, false)?;
                let result = match id {
                    x => Err(PerCodecError::new(format!("Unrecognised IE type {}", x))),
                };
                data.decode_align()?;
                result
            }
            _ => Err(PerCodecError::new("Unknown choice idx")),
        }
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        match self {
            Self::GtpTunnel(x) => {
                encode::encode_choice_idx(data, 0, 1, false, 0, false)?;
                x.encode(data)
            }
        }
    }
}

impl PerCodec for UpTransportLayerInformation {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        UpTransportLayerInformation::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UpTransportLayerInformation");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UpTransportLayerInformation");
            e
        })
    }
}
// UpTransportLayerInformationList
#[derive(Clone, Debug)]
pub struct UpTransportLayerInformationList(pub NonEmpty<UpTransportLayerInformationItem>);

impl UpTransportLayerInformationList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(3), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(UpTransportLayerInformationItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(3), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for UpTransportLayerInformationList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        UpTransportLayerInformationList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UpTransportLayerInformationList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UpTransportLayerInformationList");
            e
        })
    }
}
// UpTransportLayerInformationItem
#[derive(Clone, Debug)]
pub struct UpTransportLayerInformationItem {
    pub ngu_up_tnl_information: UpTransportLayerInformation,
}

impl UpTransportLayerInformationItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let ngu_up_tnl_information = UpTransportLayerInformation::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            ngu_up_tnl_information,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.ngu_up_tnl_information.encode(data)?;

        Ok(())
    }
}

impl PerCodec for UpTransportLayerInformationItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        UpTransportLayerInformationItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UpTransportLayerInformationItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UpTransportLayerInformationItem");
            e
        })
    }
}
// UpTransportLayerInformationPairList
#[derive(Clone, Debug)]
pub struct UpTransportLayerInformationPairList(pub NonEmpty<UpTransportLayerInformationPairItem>);

impl UpTransportLayerInformationPairList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(3), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(UpTransportLayerInformationPairItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(3), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for UpTransportLayerInformationPairList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        UpTransportLayerInformationPairList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UpTransportLayerInformationPairList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UpTransportLayerInformationPairList");
            e
        })
    }
}
// UpTransportLayerInformationPairItem
#[derive(Clone, Debug)]
pub struct UpTransportLayerInformationPairItem {
    pub ul_ngu_up_tnl_information: UpTransportLayerInformation,
    pub dl_ngu_up_tnl_information: UpTransportLayerInformation,
}

impl UpTransportLayerInformationPairItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let ul_ngu_up_tnl_information = UpTransportLayerInformation::decode(data)?;
        let dl_ngu_up_tnl_information = UpTransportLayerInformation::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            ul_ngu_up_tnl_information,
            dl_ngu_up_tnl_information,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.ul_ngu_up_tnl_information.encode(data)?;
        self.dl_ngu_up_tnl_information.encode(data)?;

        Ok(())
    }
}

impl PerCodec for UpTransportLayerInformationPairItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        UpTransportLayerInformationPairItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UpTransportLayerInformationPairItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UpTransportLayerInformationPairItem");
            e
        })
    }
}
// UriAddress
#[derive(Clone, Debug)]
pub struct UriAddress(pub String);

impl UriAddress {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(decode::decode_visible_string(
            data, None, None, false,
        )?))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_visible_string(data, None, None, false, &self.0, false)
    }
}

impl PerCodec for UriAddress {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        UriAddress::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UriAddress");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UriAddress");
            e
        })
    }
}
// UserLocationInformation
#[derive(Clone, Debug)]
pub enum UserLocationInformation {
    UserLocationInformationEutra(UserLocationInformationEutra),
    UserLocationInformationNr(UserLocationInformationNr),
    UserLocationInformationN3Iwf(UserLocationInformationN3Iwf),
    UserLocationInformationTngf(UserLocationInformationTngf),
    UserLocationInformationTwif(UserLocationInformationTwif),
    UserLocationInformationWAgf(UserLocationInformationWAgf),
}

impl UserLocationInformation {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_choice_idx(data, 0, 3, false)?;
        if extended {
            return Err(PerCodecError::new("CHOICE additions not implemented"));
        }
        match idx {
            0 => Ok(Self::UserLocationInformationEutra(
                UserLocationInformationEutra::decode(data)?,
            )),
            1 => Ok(Self::UserLocationInformationNr(
                UserLocationInformationNr::decode(data)?,
            )),
            2 => Ok(Self::UserLocationInformationN3Iwf(
                UserLocationInformationN3Iwf::decode(data)?,
            )),
            3 => {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _ = Criticality::decode(data)?;
                let _ = decode::decode_length_determinent(data, None, None, false)?;
                let result = match id {
                    244 => Ok(Self::UserLocationInformationTngf(
                        UserLocationInformationTngf::decode(data)?,
                    )),
                    248 => Ok(Self::UserLocationInformationTwif(
                        UserLocationInformationTwif::decode(data)?,
                    )),
                    243 => Ok(Self::UserLocationInformationWAgf(
                        UserLocationInformationWAgf::decode(data)?,
                    )),
                    x => Err(PerCodecError::new(format!("Unrecognised IE type {}", x))),
                };
                data.decode_align()?;
                result
            }
            _ => Err(PerCodecError::new("Unknown choice idx")),
        }
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        match self {
            Self::UserLocationInformationEutra(x) => {
                encode::encode_choice_idx(data, 0, 3, false, 0, false)?;
                x.encode(data)
            }
            Self::UserLocationInformationNr(x) => {
                encode::encode_choice_idx(data, 0, 3, false, 1, false)?;
                x.encode(data)
            }
            Self::UserLocationInformationN3Iwf(x) => {
                encode::encode_choice_idx(data, 0, 3, false, 2, false)?;
                x.encode(data)
            }
            Self::UserLocationInformationTngf(x) => {
                encode::encode_choice_idx(data, 0, 3, false, 3, false)?;
                encode::encode_integer(data, Some(0), Some(65535), false, 244, false)?;
                Criticality::Ignore.encode(data)?;
                let ie = &mut Allocator::new_codec_data();
                x.encode(ie)?;
                encode::encode_length_determinent(data, None, None, false, ie.length_in_bytes())?;
                Ok(data.append_aligned(ie))
            }
            Self::UserLocationInformationTwif(x) => {
                encode::encode_choice_idx(data, 0, 3, false, 3, false)?;
                encode::encode_integer(data, Some(0), Some(65535), false, 248, false)?;
                Criticality::Ignore.encode(data)?;
                let ie = &mut Allocator::new_codec_data();
                x.encode(ie)?;
                encode::encode_length_determinent(data, None, None, false, ie.length_in_bytes())?;
                Ok(data.append_aligned(ie))
            }
            Self::UserLocationInformationWAgf(x) => {
                encode::encode_choice_idx(data, 0, 3, false, 3, false)?;
                encode::encode_integer(data, Some(0), Some(65535), false, 243, false)?;
                Criticality::Ignore.encode(data)?;
                let ie = &mut Allocator::new_codec_data();
                x.encode(ie)?;
                encode::encode_length_determinent(data, None, None, false, ie.length_in_bytes())?;
                Ok(data.append_aligned(ie))
            }
        }
    }
}

impl PerCodec for UserLocationInformation {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        UserLocationInformation::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UserLocationInformation");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UserLocationInformation");
            e
        })
    }
}
// UserLocationInformationEutra
#[derive(Clone, Debug)]
pub struct UserLocationInformationEutra {
    pub eutra_cgi: EutraCgi,
    pub tai: Tai,
    pub time_stamp: Option<TimeStamp>,
    pub ps_cell_information: Option<NgranCgi>,
}

impl UserLocationInformationEutra {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 2)?;
        let eutra_cgi = EutraCgi::decode(data)?;
        let tai = Tai::decode(data)?;
        let time_stamp = if optionals[0] {
            Some(TimeStamp::decode(data)?)
        } else {
            None
        };

        // Process the extension container
        let mut ps_cell_information: Option<NgranCgi> = None;

        if optionals[1] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    149 => ps_cell_information = Some(NgranCgi::decode(data)?),
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            eutra_cgi,
            tai,
            time_stamp,
            ps_cell_information,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();
        if let Some(x) = &self.ps_cell_information {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 149, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        let mut optionals = BitString::new();
        optionals.push(self.time_stamp.is_some());
        optionals.push(num_ies != 0);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.eutra_cgi.encode(data)?;
        self.tai.encode(data)?;
        if let Some(x) = &self.time_stamp {
            x.encode(data)?;
        }
        if num_ies != 0 {
            encode::encode_length_determinent(data, Some(1), Some(65535), false, num_ies)?;
            data.append_aligned(ies);
        }
        Ok(())
    }
}

impl PerCodec for UserLocationInformationEutra {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        UserLocationInformationEutra::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UserLocationInformationEutra");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UserLocationInformationEutra");
            e
        })
    }
}
// UserLocationInformationN3Iwf
#[derive(Clone, Debug)]
pub struct UserLocationInformationN3Iwf {
    pub ip_address: TransportLayerAddress,
    pub port_number: PortNumber,
}

impl UserLocationInformationN3Iwf {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let ip_address = TransportLayerAddress::decode(data)?;
        let port_number = PortNumber::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            ip_address,
            port_number,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.ip_address.encode(data)?;
        self.port_number.encode(data)?;

        Ok(())
    }
}

impl PerCodec for UserLocationInformationN3Iwf {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        UserLocationInformationN3Iwf::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UserLocationInformationN3Iwf");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UserLocationInformationN3Iwf");
            e
        })
    }
}
// UserLocationInformationTngf
#[derive(Clone, Debug)]
pub struct UserLocationInformationTngf {
    pub tnap_id: TnapId,
    pub ip_address: TransportLayerAddress,
    pub port_number: Option<PortNumber>,
}

impl UserLocationInformationTngf {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 2)?;
        let tnap_id = TnapId::decode(data)?;
        let ip_address = TransportLayerAddress::decode(data)?;
        let port_number = if optionals[0] {
            Some(PortNumber::decode(data)?)
        } else {
            None
        };

        // Process the extension container

        if optionals[1] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            tnap_id,
            ip_address,
            port_number,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.port_number.is_some());
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.tnap_id.encode(data)?;
        self.ip_address.encode(data)?;
        if let Some(x) = &self.port_number {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl PerCodec for UserLocationInformationTngf {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        UserLocationInformationTngf::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UserLocationInformationTngf");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UserLocationInformationTngf");
            e
        })
    }
}
// UserLocationInformationTwif
#[derive(Clone, Debug)]
pub struct UserLocationInformationTwif {
    pub twap_id: TwapId,
    pub ip_address: TransportLayerAddress,
    pub port_number: Option<PortNumber>,
}

impl UserLocationInformationTwif {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 2)?;
        let twap_id = TwapId::decode(data)?;
        let ip_address = TransportLayerAddress::decode(data)?;
        let port_number = if optionals[0] {
            Some(PortNumber::decode(data)?)
        } else {
            None
        };

        // Process the extension container

        if optionals[1] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            twap_id,
            ip_address,
            port_number,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.port_number.is_some());
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.twap_id.encode(data)?;
        self.ip_address.encode(data)?;
        if let Some(x) = &self.port_number {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl PerCodec for UserLocationInformationTwif {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        UserLocationInformationTwif::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UserLocationInformationTwif");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UserLocationInformationTwif");
            e
        })
    }
}
// UserLocationInformationWAgf
#[derive(Clone, Debug)]
pub enum UserLocationInformationWAgf {
    GlobalLineId(GlobalLineId),
    HfcNodeId(HfcNodeId),
    GlobalCableId(GlobalCableId),
}

impl UserLocationInformationWAgf {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_choice_idx(data, 0, 2, false)?;
        if extended {
            return Err(PerCodecError::new("CHOICE additions not implemented"));
        }
        match idx {
            0 => Ok(Self::GlobalLineId(GlobalLineId::decode(data)?)),
            1 => Ok(Self::HfcNodeId(HfcNodeId::decode(data)?)),
            2 => {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _ = Criticality::decode(data)?;
                let _ = decode::decode_length_determinent(data, None, None, false)?;
                let result = match id {
                    275 => Ok(Self::GlobalCableId(GlobalCableId::decode(data)?)),
                    x => Err(PerCodecError::new(format!("Unrecognised IE type {}", x))),
                };
                data.decode_align()?;
                result
            }
            _ => Err(PerCodecError::new("Unknown choice idx")),
        }
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        match self {
            Self::GlobalLineId(x) => {
                encode::encode_choice_idx(data, 0, 2, false, 0, false)?;
                x.encode(data)
            }
            Self::HfcNodeId(x) => {
                encode::encode_choice_idx(data, 0, 2, false, 1, false)?;
                x.encode(data)
            }
            Self::GlobalCableId(x) => {
                encode::encode_choice_idx(data, 0, 2, false, 2, false)?;
                encode::encode_integer(data, Some(0), Some(65535), false, 275, false)?;
                Criticality::Ignore.encode(data)?;
                let ie = &mut Allocator::new_codec_data();
                x.encode(ie)?;
                encode::encode_length_determinent(data, None, None, false, ie.length_in_bytes())?;
                Ok(data.append_aligned(ie))
            }
        }
    }
}

impl PerCodec for UserLocationInformationWAgf {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        UserLocationInformationWAgf::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UserLocationInformationWAgf");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UserLocationInformationWAgf");
            e
        })
    }
}
// UserLocationInformationNr
#[derive(Clone, Debug)]
pub struct UserLocationInformationNr {
    pub nr_cgi: NrCgi,
    pub tai: Tai,
    pub time_stamp: Option<TimeStamp>,
    pub ps_cell_information: Option<NgranCgi>,
    pub nid: Option<Nid>,
}

impl UserLocationInformationNr {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 2)?;
        let nr_cgi = NrCgi::decode(data)?;
        let tai = Tai::decode(data)?;
        let time_stamp = if optionals[0] {
            Some(TimeStamp::decode(data)?)
        } else {
            None
        };

        // Process the extension container
        let mut ps_cell_information: Option<NgranCgi> = None;
        let mut nid: Option<Nid> = None;

        if optionals[1] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    149 => ps_cell_information = Some(NgranCgi::decode(data)?),
                    263 => nid = Some(Nid::decode(data)?),
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            nr_cgi,
            tai,
            time_stamp,
            ps_cell_information,
            nid,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();
        if let Some(x) = &self.ps_cell_information {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 149, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.nid {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 263, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        let mut optionals = BitString::new();
        optionals.push(self.time_stamp.is_some());
        optionals.push(num_ies != 0);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.nr_cgi.encode(data)?;
        self.tai.encode(data)?;
        if let Some(x) = &self.time_stamp {
            x.encode(data)?;
        }
        if num_ies != 0 {
            encode::encode_length_determinent(data, Some(1), Some(65535), false, num_ies)?;
            data.append_aligned(ies);
        }
        Ok(())
    }
}

impl PerCodec for UserLocationInformationNr {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        UserLocationInformationNr::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UserLocationInformationNr");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UserLocationInformationNr");
            e
        })
    }
}
// UserPlaneSecurityInformation
#[derive(Clone, Debug)]
pub struct UserPlaneSecurityInformation {
    pub security_result: SecurityResult,
    pub security_indication: SecurityIndication,
}

impl UserPlaneSecurityInformation {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let security_result = SecurityResult::decode(data)?;
        let security_indication = SecurityIndication::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            security_result,
            security_indication,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.security_result.encode(data)?;
        self.security_indication.encode(data)?;

        Ok(())
    }
}

impl PerCodec for UserPlaneSecurityInformation {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        UserPlaneSecurityInformation::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UserPlaneSecurityInformation");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UserPlaneSecurityInformation");
            e
        })
    }
}
// VolumeTimedReportList
#[derive(Clone, Debug)]
pub struct VolumeTimedReportList(pub NonEmpty<VolumeTimedReportItem>);

impl VolumeTimedReportList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(2), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(VolumeTimedReportItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(2), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for VolumeTimedReportList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        VolumeTimedReportList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("VolumeTimedReportList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("VolumeTimedReportList");
            e
        })
    }
}
// VolumeTimedReportItem
#[derive(Clone, Debug)]
pub struct VolumeTimedReportItem {
    pub start_time_stamp: [u8; 4],
    pub end_time_stamp: [u8; 4],
    pub usage_count_ul: u64,
    pub usage_count_dl: u64,
}

impl VolumeTimedReportItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let start_time_stamp = decode::decode_octetstring(data, Some(4), Some(4), false)?
            .try_into()
            .unwrap();
        let end_time_stamp = decode::decode_octetstring(data, Some(4), Some(4), false)?
            .try_into()
            .unwrap();
        let usage_count_ul = decode::decode_integer(data, Some(0), None, false)?.0 as u64;
        let usage_count_dl = decode::decode_integer(data, Some(0), None, false)?.0 as u64;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            start_time_stamp,
            end_time_stamp,
            usage_count_ul,
            usage_count_dl,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        encode::encode_octetstring(
            data,
            Some(4),
            Some(4),
            false,
            &(self.start_time_stamp).into(),
            false,
        )?;
        encode::encode_octetstring(
            data,
            Some(4),
            Some(4),
            false,
            &(self.end_time_stamp).into(),
            false,
        )?;
        encode::encode_integer(
            data,
            Some(0),
            None,
            false,
            self.usage_count_ul as i128,
            false,
        )?;
        encode::encode_integer(
            data,
            Some(0),
            None,
            false,
            self.usage_count_dl as i128,
            false,
        )?;

        Ok(())
    }
}

impl PerCodec for VolumeTimedReportItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        VolumeTimedReportItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("VolumeTimedReportItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("VolumeTimedReportItem");
            e
        })
    }
}
// WAgfId
#[derive(Clone, Debug)]
pub enum WAgfId {
    WAgfId(BitString),
}

impl WAgfId {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_choice_idx(data, 0, 1, false)?;
        if extended {
            return Err(PerCodecError::new("CHOICE additions not implemented"));
        }
        match idx {
            0 => Ok(Self::WAgfId(decode::decode_bitstring(
                data,
                Some(16),
                Some(16),
                true,
            )?)),
            1 => {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _ = Criticality::decode(data)?;
                let _ = decode::decode_length_determinent(data, None, None, false)?;
                let result = match id {
                    x => Err(PerCodecError::new(format!("Unrecognised IE type {}", x))),
                };
                data.decode_align()?;
                result
            }
            _ => Err(PerCodecError::new("Unknown choice idx")),
        }
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        match self {
            Self::WAgfId(x) => {
                encode::encode_choice_idx(data, 0, 1, false, 0, false)?;
                encode::encode_bitstring(data, Some(16), Some(16), true, &x, false)
            }
        }
    }
}

impl PerCodec for WAgfId {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        WAgfId::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("WAgfId");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("WAgfId");
            e
        })
    }
}
// WarningAreaCoordinates
#[derive(Clone, Debug)]
pub struct WarningAreaCoordinates(pub Vec<u8>);

impl WarningAreaCoordinates {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(decode::decode_octetstring(
            data,
            Some(1),
            Some(1024),
            false,
        )?))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_octetstring(data, Some(1), Some(1024), false, &self.0, false)
    }
}

impl PerCodec for WarningAreaCoordinates {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        WarningAreaCoordinates::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("WarningAreaCoordinates");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("WarningAreaCoordinates");
            e
        })
    }
}
// WarningAreaList
#[derive(Clone, Debug)]
pub enum WarningAreaList {
    EutraCgiListForWarning(EutraCgiListForWarning),
    NrCgiListForWarning(NrCgiListForWarning),
    TaiListForWarning(TaiListForWarning),
    EmergencyAreaIdList(EmergencyAreaIdList),
}

impl WarningAreaList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_choice_idx(data, 0, 4, false)?;
        if extended {
            return Err(PerCodecError::new("CHOICE additions not implemented"));
        }
        match idx {
            0 => Ok(Self::EutraCgiListForWarning(
                EutraCgiListForWarning::decode(data)?,
            )),
            1 => Ok(Self::NrCgiListForWarning(NrCgiListForWarning::decode(
                data,
            )?)),
            2 => Ok(Self::TaiListForWarning(TaiListForWarning::decode(data)?)),
            3 => Ok(Self::EmergencyAreaIdList(EmergencyAreaIdList::decode(
                data,
            )?)),
            4 => {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _ = Criticality::decode(data)?;
                let _ = decode::decode_length_determinent(data, None, None, false)?;
                let result = match id {
                    x => Err(PerCodecError::new(format!("Unrecognised IE type {}", x))),
                };
                data.decode_align()?;
                result
            }
            _ => Err(PerCodecError::new("Unknown choice idx")),
        }
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        match self {
            Self::EutraCgiListForWarning(x) => {
                encode::encode_choice_idx(data, 0, 4, false, 0, false)?;
                x.encode(data)
            }
            Self::NrCgiListForWarning(x) => {
                encode::encode_choice_idx(data, 0, 4, false, 1, false)?;
                x.encode(data)
            }
            Self::TaiListForWarning(x) => {
                encode::encode_choice_idx(data, 0, 4, false, 2, false)?;
                x.encode(data)
            }
            Self::EmergencyAreaIdList(x) => {
                encode::encode_choice_idx(data, 0, 4, false, 3, false)?;
                x.encode(data)
            }
        }
    }
}

impl PerCodec for WarningAreaList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        WarningAreaList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("WarningAreaList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("WarningAreaList");
            e
        })
    }
}
// WarningMessageContents
#[derive(Clone, Debug)]
pub struct WarningMessageContents(pub Vec<u8>);

impl WarningMessageContents {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(decode::decode_octetstring(
            data,
            Some(1),
            Some(9600),
            false,
        )?))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_octetstring(data, Some(1), Some(9600), false, &self.0, false)
    }
}

impl PerCodec for WarningMessageContents {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        WarningMessageContents::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("WarningMessageContents");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("WarningMessageContents");
            e
        })
    }
}
// WarningSecurityInfo
#[derive(Clone, Debug)]
pub struct WarningSecurityInfo(pub [u8; 50]);

impl WarningSecurityInfo {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(
            decode::decode_octetstring(data, Some(50), Some(50), false)?
                .try_into()
                .unwrap(),
        ))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_octetstring(data, Some(50), Some(50), false, &(self.0).into(), false)
    }
}

impl PerCodec for WarningSecurityInfo {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        WarningSecurityInfo::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("WarningSecurityInfo");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("WarningSecurityInfo");
            e
        })
    }
}
// WarningType
#[derive(Clone, Debug)]
pub struct WarningType(pub [u8; 2]);

impl WarningType {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(
            decode::decode_octetstring(data, Some(2), Some(2), false)?
                .try_into()
                .unwrap(),
        ))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_octetstring(data, Some(2), Some(2), false, &(self.0).into(), false)
    }
}

impl PerCodec for WarningType {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        WarningType::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("WarningType");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("WarningType");
            e
        })
    }
}
// WlanMeasurementConfiguration
#[derive(Clone, Debug)]
pub struct WlanMeasurementConfiguration {
    pub wlan_meas_config: WlanMeasConfig,
    pub wlan_meas_config_name_list: Option<WlanMeasConfigNameList>,
    pub wlan_rssi: Option<WlanRssi>,
    pub wlan_rtt: Option<WlanRtt>,
}

impl WlanMeasurementConfiguration {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 4)?;
        let wlan_meas_config = WlanMeasConfig::decode(data)?;
        let wlan_meas_config_name_list = if optionals[0] {
            Some(WlanMeasConfigNameList::decode(data)?)
        } else {
            None
        };
        let wlan_rssi = if optionals[1] {
            Some(WlanRssi::decode(data)?)
        } else {
            None
        };
        let wlan_rtt = if optionals[2] {
            Some(WlanRtt::decode(data)?)
        } else {
            None
        };

        // Process the extension container

        if optionals[3] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            wlan_meas_config,
            wlan_meas_config_name_list,
            wlan_rssi,
            wlan_rtt,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.wlan_meas_config_name_list.is_some());
        optionals.push(self.wlan_rssi.is_some());
        optionals.push(self.wlan_rtt.is_some());
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.wlan_meas_config.encode(data)?;
        if let Some(x) = &self.wlan_meas_config_name_list {
            x.encode(data)?;
        }
        if let Some(x) = &self.wlan_rssi {
            x.encode(data)?;
        }
        if let Some(x) = &self.wlan_rtt {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl PerCodec for WlanMeasurementConfiguration {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        WlanMeasurementConfiguration::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("WlanMeasurementConfiguration");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("WlanMeasurementConfiguration");
            e
        })
    }
}
// WlanMeasConfigNameList
#[derive(Clone, Debug)]
pub struct WlanMeasConfigNameList(pub NonEmpty<WlanMeasConfigNameItem>);

impl WlanMeasConfigNameList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(4), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(WlanMeasConfigNameItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(4), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for WlanMeasConfigNameList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        WlanMeasConfigNameList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("WlanMeasConfigNameList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("WlanMeasConfigNameList");
            e
        })
    }
}
// WlanMeasConfigNameItem
#[derive(Clone, Debug)]
pub struct WlanMeasConfigNameItem {
    pub wlan_name: WlanName,
}

impl WlanMeasConfigNameItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let wlan_name = WlanName::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self { wlan_name })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.wlan_name.encode(data)?;

        Ok(())
    }
}

impl PerCodec for WlanMeasConfigNameItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        WlanMeasConfigNameItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("WlanMeasConfigNameItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("WlanMeasConfigNameItem");
            e
        })
    }
}
// WlanMeasConfig
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum WlanMeasConfig {
    Setup,
}

impl WlanMeasConfig {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(0), true)?;
        if extended {
            return Err(PerCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(data, Some(0), Some(0), true, *self as i128, false)
    }
}

impl PerCodec for WlanMeasConfig {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        WlanMeasConfig::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("WlanMeasConfig");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("WlanMeasConfig");
            e
        })
    }
}
// WlanName
#[derive(Clone, Debug)]
pub struct WlanName(pub Vec<u8>);

impl WlanName {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(decode::decode_octetstring(
            data,
            Some(1),
            Some(32),
            false,
        )?))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_octetstring(data, Some(1), Some(32), false, &self.0, false)
    }
}

impl PerCodec for WlanName {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        WlanName::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("WlanName");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("WlanName");
            e
        })
    }
}
// WusAssistanceInformation
#[derive(Clone, Debug)]
pub struct WusAssistanceInformation {
    pub paging_probability_information: PagingProbabilityInformation,
}

impl WusAssistanceInformation {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let paging_probability_information = PagingProbabilityInformation::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            paging_probability_information,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.paging_probability_information.encode(data)?;

        Ok(())
    }
}

impl PerCodec for WusAssistanceInformation {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        WusAssistanceInformation::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("WusAssistanceInformation");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("WusAssistanceInformation");
            e
        })
    }
}
// XnExtTlAs
#[derive(Clone, Debug)]
pub struct XnExtTlAs(pub NonEmpty<XnExtTlaItem>);

impl XnExtTlAs {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(16), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(XnExtTlaItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(16), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for XnExtTlAs {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        XnExtTlAs::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("XnExtTlAs");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("XnExtTlAs");
            e
        })
    }
}
// XnExtTlaItem
#[derive(Clone, Debug)]
pub struct XnExtTlaItem {
    pub i_psec_tla: Option<TransportLayerAddress>,
    pub gtp_tl_as: Option<XnGtpTlAs>,
    pub sctp_tl_as: Option<SctpTlAs>,
}

impl XnExtTlaItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 3)?;
        let i_psec_tla = if optionals[0] {
            Some(TransportLayerAddress::decode(data)?)
        } else {
            None
        };
        let gtp_tl_as = if optionals[1] {
            Some(XnGtpTlAs::decode(data)?)
        } else {
            None
        };

        // Process the extension container
        let mut sctp_tl_as: Option<SctpTlAs> = None;

        if optionals[2] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    173 => sctp_tl_as = Some(SctpTlAs::decode(data)?),
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            i_psec_tla,
            gtp_tl_as,
            sctp_tl_as,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();
        if let Some(x) = &self.sctp_tl_as {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 173, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        let mut optionals = BitString::new();
        optionals.push(self.i_psec_tla.is_some());
        optionals.push(self.gtp_tl_as.is_some());
        optionals.push(num_ies != 0);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        if let Some(x) = &self.i_psec_tla {
            x.encode(data)?;
        }
        if let Some(x) = &self.gtp_tl_as {
            x.encode(data)?;
        }
        if num_ies != 0 {
            encode::encode_length_determinent(data, Some(1), Some(65535), false, num_ies)?;
            data.append_aligned(ies);
        }
        Ok(())
    }
}

impl PerCodec for XnExtTlaItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        XnExtTlaItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("XnExtTlaItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("XnExtTlaItem");
            e
        })
    }
}
// XnGtpTlAs
#[derive(Clone, Debug)]
pub struct XnGtpTlAs(pub NonEmpty<TransportLayerAddress>);

impl XnGtpTlAs {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(16), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(TransportLayerAddress::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(16), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for XnGtpTlAs {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        XnGtpTlAs::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("XnGtpTlAs");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("XnGtpTlAs");
            e
        })
    }
}
// XnTlAs
#[derive(Clone, Debug)]
pub struct XnTlAs(pub NonEmpty<TransportLayerAddress>);

impl XnTlAs {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(2), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(TransportLayerAddress::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(2), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for XnTlAs {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        XnTlAs::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("XnTlAs");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("XnTlAs");
            e
        })
    }
}
// XnTnlConfigurationInfo
#[derive(Clone, Debug)]
pub struct XnTnlConfigurationInfo {
    pub xn_transport_layer_addresses: XnTlAs,
    pub xn_extended_transport_layer_addresses: Option<XnExtTlAs>,
}

impl XnTnlConfigurationInfo {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 2)?;
        let xn_transport_layer_addresses = XnTlAs::decode(data)?;
        let xn_extended_transport_layer_addresses = if optionals[0] {
            Some(XnExtTlAs::decode(data)?)
        } else {
            None
        };

        // Process the extension container

        if optionals[1] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            xn_transport_layer_addresses,
            xn_extended_transport_layer_addresses,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.xn_extended_transport_layer_addresses.is_some());
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.xn_transport_layer_addresses.encode(data)?;
        if let Some(x) = &self.xn_extended_transport_layer_addresses {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl PerCodec for XnTnlConfigurationInfo {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        XnTnlConfigurationInfo::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("XnTnlConfigurationInfo");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("XnTnlConfigurationInfo");
            e
        })
    }
}
// PniNpnRestricted
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum PniNpnRestricted {
    Restricted,
    NotRestricted,
}

impl PniNpnRestricted {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(1), true)?;
        if extended {
            return Err(PerCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(data, Some(0), Some(1), true, *self as i128, false)
    }
}

impl PerCodec for PniNpnRestricted {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PniNpnRestricted::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PniNpnRestricted");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PniNpnRestricted");
            e
        })
    }
}
// QosFlowMappingIndication
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum QosFlowMappingIndication {
    Ul,
    Dl,
}

impl QosFlowMappingIndication {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(1), true)?;
        if extended {
            return Err(PerCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(data, Some(0), Some(1), true, *self as i128, false)
    }
}

impl PerCodec for QosFlowMappingIndication {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        QosFlowMappingIndication::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("QosFlowMappingIndication");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("QosFlowMappingIndication");
            e
        })
    }
}
// BtRssi
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum BtRssi {
    True,
}

impl BtRssi {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(0), true)?;
        if extended {
            return Err(PerCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(data, Some(0), Some(0), true, *self as i128, false)
    }
}

impl PerCodec for BtRssi {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        BtRssi::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("BtRssi");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("BtRssi");
            e
        })
    }
}
// CnType
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum CnType {
    EpcForbidden,
    FiveGcForbidden,
}

impl CnType {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(1), true)?;
        if extended {
            return Err(PerCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(data, Some(0), Some(1), true, *self as i128, false)
    }
}

impl PerCodec for CnType {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        CnType::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CnType");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CnType");
            e
        })
    }
}
// DapsIndicator
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum DapsIndicator {
    DapsHoRequired,
}

impl DapsIndicator {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(0), true)?;
        if extended {
            return Err(PerCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(data, Some(0), Some(0), true, *self as i128, false)
    }
}

impl PerCodec for DapsIndicator {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        DapsIndicator::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DapsIndicator");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DapsIndicator");
            e
        })
    }
}
// Dapsresponseindicator
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum Dapsresponseindicator {
    DapsHoAccepted,
    DapsHoNotAccepted,
}

impl Dapsresponseindicator {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(1), true)?;
        if extended {
            return Err(PerCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(data, Some(0), Some(1), true, *self as i128, false)
    }
}

impl PerCodec for Dapsresponseindicator {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Dapsresponseindicator::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("Dapsresponseindicator");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("Dapsresponseindicator");
            e
        })
    }
}
// OutOfCoverage
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum OutOfCoverage {
    True,
}

impl OutOfCoverage {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(0), true)?;
        if extended {
            return Err(PerCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(data, Some(0), Some(0), true, *self as i128, false)
    }
}

impl PerCodec for OutOfCoverage {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        OutOfCoverage::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("OutOfCoverage");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("OutOfCoverage");
            e
        })
    }
}
// HandoverReportType
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum HandoverReportType {
    HoTooEarly,
    HoToWrongCell,
    IntersystemPingPong,
}

impl HandoverReportType {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(2), true)?;
        if extended {
            return Err(PerCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(data, Some(0), Some(2), true, *self as i128, false)
    }
}

impl PerCodec for HandoverReportType {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        HandoverReportType::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("HandoverReportType");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("HandoverReportType");
            e
        })
    }
}
// EarlyIratho
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum EarlyIratho {
    True,
    False,
}

impl EarlyIratho {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(1), true)?;
        if extended {
            return Err(PerCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(data, Some(0), Some(1), true, *self as i128, false)
    }
}

impl PerCodec for EarlyIratho {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        EarlyIratho::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("EarlyIratho");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("EarlyIratho");
            e
        })
    }
}
// RatType
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum RatType {
    Nr,
    Eutra,
}

impl RatType {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(1), true)?;
        if extended {
            return Err(PerCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(data, Some(0), Some(1), true, *self as i128, false)
    }
}

impl PerCodec for RatType {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        RatType::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("RatType");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("RatType");
            e
        })
    }
}
// RatType1
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum RatType1 {
    Nr,
    Eutra,
}

impl RatType1 {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(1), true)?;
        if extended {
            return Err(PerCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(data, Some(0), Some(1), true, *self as i128, false)
    }
}

impl PerCodec for RatType1 {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        RatType1::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("RatType1");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("RatType1");
            e
        })
    }
}
// RimRsDetection
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum RimRsDetection {
    RsDetected,
    RsDisappeared,
}

impl RimRsDetection {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(1), true)?;
        if extended {
            return Err(PerCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(data, Some(0), Some(1), true, *self as i128, false)
    }
}

impl PerCodec for RimRsDetection {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        RimRsDetection::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("RimRsDetection");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("RimRsDetection");
            e
        })
    }
}
// UncompensatedBarometricConfig
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum UncompensatedBarometricConfig {
    True,
}

impl UncompensatedBarometricConfig {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(0), true)?;
        if extended {
            return Err(PerCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(data, Some(0), Some(0), true, *self as i128, false)
    }
}

impl PerCodec for UncompensatedBarometricConfig {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        UncompensatedBarometricConfig::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UncompensatedBarometricConfig");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UncompensatedBarometricConfig");
            e
        })
    }
}
// UeSpeedConfig
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum UeSpeedConfig {
    True,
}

impl UeSpeedConfig {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(0), true)?;
        if extended {
            return Err(PerCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(data, Some(0), Some(0), true, *self as i128, false)
    }
}

impl PerCodec for UeSpeedConfig {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        UeSpeedConfig::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UeSpeedConfig");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UeSpeedConfig");
            e
        })
    }
}
// UeOrientationConfig
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum UeOrientationConfig {
    True,
}

impl UeOrientationConfig {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(0), true)?;
        if extended {
            return Err(PerCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(data, Some(0), Some(0), true, *self as i128, false)
    }
}

impl PerCodec for UeOrientationConfig {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        UeOrientationConfig::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UeOrientationConfig");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UeOrientationConfig");
            e
        })
    }
}
// PeriodicCommunicationIndicator
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum PeriodicCommunicationIndicator {
    Periodically,
    Ondemand,
}

impl PeriodicCommunicationIndicator {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(1), true)?;
        if extended {
            return Err(PerCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(data, Some(0), Some(1), true, *self as i128, false)
    }
}

impl PerCodec for PeriodicCommunicationIndicator {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PeriodicCommunicationIndicator::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PeriodicCommunicationIndicator");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PeriodicCommunicationIndicator");
            e
        })
    }
}
// StationaryIndication
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum StationaryIndication {
    Stationary,
    Mobile,
}

impl StationaryIndication {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(1), true)?;
        if extended {
            return Err(PerCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(data, Some(0), Some(1), true, *self as i128, false)
    }
}

impl PerCodec for StationaryIndication {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        StationaryIndication::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("StationaryIndication");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("StationaryIndication");
            e
        })
    }
}
// TrafficProfile
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum TrafficProfile {
    SinglePacket,
    DualPackets,
    MultiplePackets,
}

impl TrafficProfile {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(2), true)?;
        if extended {
            return Err(PerCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(data, Some(0), Some(2), true, *self as i128, false)
    }
}

impl PerCodec for TrafficProfile {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        TrafficProfile::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TrafficProfile");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TrafficProfile");
            e
        })
    }
}
// BatteryIndication
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum BatteryIndication {
    BatteryPowered,
    BatteryPoweredNotRechargeableOrReplaceable,
    NotBatteryPowered,
}

impl BatteryIndication {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(2), true)?;
        if extended {
            return Err(PerCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(data, Some(0), Some(2), true, *self as i128, false)
    }
}

impl PerCodec for BatteryIndication {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        BatteryIndication::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("BatteryIndication");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("BatteryIndication");
            e
        })
    }
}
// WlanRssi
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum WlanRssi {
    True,
}

impl WlanRssi {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(0), true)?;
        if extended {
            return Err(PerCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(data, Some(0), Some(0), true, *self as i128, false)
    }
}

impl PerCodec for WlanRssi {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        WlanRssi::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("WlanRssi");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("WlanRssi");
            e
        })
    }
}
// WlanRtt
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum WlanRtt {
    True,
}

impl WlanRtt {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(0), true)?;
        if extended {
            return Err(PerCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(data, Some(0), Some(0), true, *self as i128, false)
    }
}

impl PerCodec for WlanRtt {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        WlanRtt::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("WlanRtt");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("WlanRtt");
            e
        })
    }
}
