// Autogenerated from NGAP-PDU-Contents.asn
#![allow(clippy::all)]
use super::common::*;
use super::ies::*;
use asn1_per::{aper::*, *};
#[allow(unused_imports)]
use xxap::{GtpTunnel, PduSessionId, TransportLayerAddress};

// PduSessionResourceSetupRequest
#[derive(Clone, Debug)]
pub struct PduSessionResourceSetupRequest {
    pub amf_ue_ngap_id: AmfUeNgapId,
    pub ran_ue_ngap_id: RanUeNgapId,
    pub ran_paging_priority: Option<RanPagingPriority>,
    pub nas_pdu: Option<NasPdu>,
    pub pdu_session_resource_setup_list_su_req: PduSessionResourceSetupListSuReq,
    pub ue_aggregate_maximum_bit_rate: Option<UeAggregateMaximumBitRate>,
}

impl PduSessionResourceSetupRequest {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let _ = decode::decode_sequence_header(data, true, 0)?;
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut amf_ue_ngap_id: Option<AmfUeNgapId> = None;
        let mut ran_ue_ngap_id: Option<RanUeNgapId> = None;
        let mut ran_paging_priority: Option<RanPagingPriority> = None;
        let mut nas_pdu: Option<NasPdu> = None;
        let mut pdu_session_resource_setup_list_su_req: Option<PduSessionResourceSetupListSuReq> =
            None;
        let mut ue_aggregate_maximum_bit_rate: Option<UeAggregateMaximumBitRate> = None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                10 => amf_ue_ngap_id = Some(AmfUeNgapId::decode(data)?),
                85 => ran_ue_ngap_id = Some(RanUeNgapId::decode(data)?),
                83 => ran_paging_priority = Some(RanPagingPriority::decode(data)?),
                38 => nas_pdu = Some(NasPdu::decode(data)?),
                74 => {
                    pdu_session_resource_setup_list_su_req =
                        Some(PduSessionResourceSetupListSuReq::decode(data)?)
                }
                110 => {
                    ue_aggregate_maximum_bit_rate = Some(UeAggregateMaximumBitRate::decode(data)?)
                }
                x => return Err(PerCodecError::new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        let amf_ue_ngap_id = amf_ue_ngap_id.ok_or(PerCodecError::new(format!(
            "Missing mandatory IE amf_ue_ngap_id"
        )))?;
        let ran_ue_ngap_id = ran_ue_ngap_id.ok_or(PerCodecError::new(format!(
            "Missing mandatory IE ran_ue_ngap_id"
        )))?;
        let pdu_session_resource_setup_list_su_req =
            pdu_session_resource_setup_list_su_req.ok_or(PerCodecError::new(format!(
                "Missing mandatory IE pdu_session_resource_setup_list_su_req"
            )))?;
        Ok(Self {
            amf_ue_ngap_id,
            ran_ue_ngap_id,
            ran_paging_priority,
            nas_pdu,
            pdu_session_resource_setup_list_su_req,
            ue_aggregate_maximum_bit_rate,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        let ie = &mut Allocator::new_codec_data();
        self.amf_ue_ngap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 10, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.ran_ue_ngap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 85, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        if let Some(x) = &self.ran_paging_priority {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 83, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.nas_pdu {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 38, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        let ie = &mut Allocator::new_codec_data();
        self.pdu_session_resource_setup_list_su_req.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 74, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        if let Some(x) = &self.ue_aggregate_maximum_bit_rate {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 110, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        encode::encode_sequence_header(data, true, &BitString::new(), false)?;
        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for PduSessionResourceSetupRequest {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PduSessionResourceSetupRequest::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PduSessionResourceSetupRequest");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PduSessionResourceSetupRequest");
            e
        })
    }
}
// PduSessionResourceSetupResponse
#[derive(Clone, Debug)]
pub struct PduSessionResourceSetupResponse {
    pub amf_ue_ngap_id: AmfUeNgapId,
    pub ran_ue_ngap_id: RanUeNgapId,
    pub pdu_session_resource_setup_list_su_res: Option<PduSessionResourceSetupListSuRes>,
    pub pdu_session_resource_failed_to_setup_list_su_res:
        Option<PduSessionResourceFailedToSetupListSuRes>,
    pub criticality_diagnostics: Option<CriticalityDiagnostics>,
}

impl PduSessionResourceSetupResponse {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let _ = decode::decode_sequence_header(data, true, 0)?;
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut amf_ue_ngap_id: Option<AmfUeNgapId> = None;
        let mut ran_ue_ngap_id: Option<RanUeNgapId> = None;
        let mut pdu_session_resource_setup_list_su_res: Option<PduSessionResourceSetupListSuRes> =
            None;
        let mut pdu_session_resource_failed_to_setup_list_su_res: Option<
            PduSessionResourceFailedToSetupListSuRes,
        > = None;
        let mut criticality_diagnostics: Option<CriticalityDiagnostics> = None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                10 => amf_ue_ngap_id = Some(AmfUeNgapId::decode(data)?),
                85 => ran_ue_ngap_id = Some(RanUeNgapId::decode(data)?),
                75 => {
                    pdu_session_resource_setup_list_su_res =
                        Some(PduSessionResourceSetupListSuRes::decode(data)?)
                }
                58 => {
                    pdu_session_resource_failed_to_setup_list_su_res =
                        Some(PduSessionResourceFailedToSetupListSuRes::decode(data)?)
                }
                19 => criticality_diagnostics = Some(CriticalityDiagnostics::decode(data)?),
                x => return Err(PerCodecError::new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        let amf_ue_ngap_id = amf_ue_ngap_id.ok_or(PerCodecError::new(format!(
            "Missing mandatory IE amf_ue_ngap_id"
        )))?;
        let ran_ue_ngap_id = ran_ue_ngap_id.ok_or(PerCodecError::new(format!(
            "Missing mandatory IE ran_ue_ngap_id"
        )))?;
        Ok(Self {
            amf_ue_ngap_id,
            ran_ue_ngap_id,
            pdu_session_resource_setup_list_su_res,
            pdu_session_resource_failed_to_setup_list_su_res,
            criticality_diagnostics,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        let ie = &mut Allocator::new_codec_data();
        self.amf_ue_ngap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 10, false)?;
        Criticality::Ignore.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.ran_ue_ngap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 85, false)?;
        Criticality::Ignore.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        if let Some(x) = &self.pdu_session_resource_setup_list_su_res {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 75, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.pdu_session_resource_failed_to_setup_list_su_res {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 58, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.criticality_diagnostics {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 19, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        encode::encode_sequence_header(data, true, &BitString::new(), false)?;
        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for PduSessionResourceSetupResponse {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PduSessionResourceSetupResponse::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PduSessionResourceSetupResponse");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PduSessionResourceSetupResponse");
            e
        })
    }
}
// PduSessionResourceReleaseCommand
#[derive(Clone, Debug)]
pub struct PduSessionResourceReleaseCommand {
    pub amf_ue_ngap_id: AmfUeNgapId,
    pub ran_ue_ngap_id: RanUeNgapId,
    pub ran_paging_priority: Option<RanPagingPriority>,
    pub nas_pdu: Option<NasPdu>,
    pub pdu_session_resource_to_release_list_rel_cmd: PduSessionResourceToReleaseListRelCmd,
}

impl PduSessionResourceReleaseCommand {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let _ = decode::decode_sequence_header(data, true, 0)?;
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut amf_ue_ngap_id: Option<AmfUeNgapId> = None;
        let mut ran_ue_ngap_id: Option<RanUeNgapId> = None;
        let mut ran_paging_priority: Option<RanPagingPriority> = None;
        let mut nas_pdu: Option<NasPdu> = None;
        let mut pdu_session_resource_to_release_list_rel_cmd: Option<
            PduSessionResourceToReleaseListRelCmd,
        > = None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                10 => amf_ue_ngap_id = Some(AmfUeNgapId::decode(data)?),
                85 => ran_ue_ngap_id = Some(RanUeNgapId::decode(data)?),
                83 => ran_paging_priority = Some(RanPagingPriority::decode(data)?),
                38 => nas_pdu = Some(NasPdu::decode(data)?),
                79 => {
                    pdu_session_resource_to_release_list_rel_cmd =
                        Some(PduSessionResourceToReleaseListRelCmd::decode(data)?)
                }
                x => return Err(PerCodecError::new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        let amf_ue_ngap_id = amf_ue_ngap_id.ok_or(PerCodecError::new(format!(
            "Missing mandatory IE amf_ue_ngap_id"
        )))?;
        let ran_ue_ngap_id = ran_ue_ngap_id.ok_or(PerCodecError::new(format!(
            "Missing mandatory IE ran_ue_ngap_id"
        )))?;
        let pdu_session_resource_to_release_list_rel_cmd =
            pdu_session_resource_to_release_list_rel_cmd.ok_or(PerCodecError::new(format!(
                "Missing mandatory IE pdu_session_resource_to_release_list_rel_cmd"
            )))?;
        Ok(Self {
            amf_ue_ngap_id,
            ran_ue_ngap_id,
            ran_paging_priority,
            nas_pdu,
            pdu_session_resource_to_release_list_rel_cmd,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        let ie = &mut Allocator::new_codec_data();
        self.amf_ue_ngap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 10, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.ran_ue_ngap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 85, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        if let Some(x) = &self.ran_paging_priority {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 83, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.nas_pdu {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 38, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        let ie = &mut Allocator::new_codec_data();
        self.pdu_session_resource_to_release_list_rel_cmd
            .encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 79, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        encode::encode_sequence_header(data, true, &BitString::new(), false)?;
        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for PduSessionResourceReleaseCommand {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PduSessionResourceReleaseCommand::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PduSessionResourceReleaseCommand");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PduSessionResourceReleaseCommand");
            e
        })
    }
}
// PduSessionResourceReleaseResponse
#[derive(Clone, Debug)]
pub struct PduSessionResourceReleaseResponse {
    pub amf_ue_ngap_id: AmfUeNgapId,
    pub ran_ue_ngap_id: RanUeNgapId,
    pub pdu_session_resource_released_list_rel_res: PduSessionResourceReleasedListRelRes,
    pub user_location_information: Option<UserLocationInformation>,
    pub criticality_diagnostics: Option<CriticalityDiagnostics>,
}

impl PduSessionResourceReleaseResponse {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let _ = decode::decode_sequence_header(data, true, 0)?;
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut amf_ue_ngap_id: Option<AmfUeNgapId> = None;
        let mut ran_ue_ngap_id: Option<RanUeNgapId> = None;
        let mut pdu_session_resource_released_list_rel_res: Option<
            PduSessionResourceReleasedListRelRes,
        > = None;
        let mut user_location_information: Option<UserLocationInformation> = None;
        let mut criticality_diagnostics: Option<CriticalityDiagnostics> = None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                10 => amf_ue_ngap_id = Some(AmfUeNgapId::decode(data)?),
                85 => ran_ue_ngap_id = Some(RanUeNgapId::decode(data)?),
                70 => {
                    pdu_session_resource_released_list_rel_res =
                        Some(PduSessionResourceReleasedListRelRes::decode(data)?)
                }
                121 => user_location_information = Some(UserLocationInformation::decode(data)?),
                19 => criticality_diagnostics = Some(CriticalityDiagnostics::decode(data)?),
                x => return Err(PerCodecError::new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        let amf_ue_ngap_id = amf_ue_ngap_id.ok_or(PerCodecError::new(format!(
            "Missing mandatory IE amf_ue_ngap_id"
        )))?;
        let ran_ue_ngap_id = ran_ue_ngap_id.ok_or(PerCodecError::new(format!(
            "Missing mandatory IE ran_ue_ngap_id"
        )))?;
        let pdu_session_resource_released_list_rel_res = pdu_session_resource_released_list_rel_res
            .ok_or(PerCodecError::new(format!(
                "Missing mandatory IE pdu_session_resource_released_list_rel_res"
            )))?;
        Ok(Self {
            amf_ue_ngap_id,
            ran_ue_ngap_id,
            pdu_session_resource_released_list_rel_res,
            user_location_information,
            criticality_diagnostics,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        let ie = &mut Allocator::new_codec_data();
        self.amf_ue_ngap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 10, false)?;
        Criticality::Ignore.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.ran_ue_ngap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 85, false)?;
        Criticality::Ignore.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.pdu_session_resource_released_list_rel_res.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 70, false)?;
        Criticality::Ignore.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        if let Some(x) = &self.user_location_information {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 121, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.criticality_diagnostics {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 19, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        encode::encode_sequence_header(data, true, &BitString::new(), false)?;
        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for PduSessionResourceReleaseResponse {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PduSessionResourceReleaseResponse::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PduSessionResourceReleaseResponse");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PduSessionResourceReleaseResponse");
            e
        })
    }
}
// PduSessionResourceModifyRequest
#[derive(Clone, Debug)]
pub struct PduSessionResourceModifyRequest {
    pub amf_ue_ngap_id: AmfUeNgapId,
    pub ran_ue_ngap_id: RanUeNgapId,
    pub ran_paging_priority: Option<RanPagingPriority>,
    pub pdu_session_resource_modify_list_mod_req: PduSessionResourceModifyListModReq,
}

impl PduSessionResourceModifyRequest {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let _ = decode::decode_sequence_header(data, true, 0)?;
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut amf_ue_ngap_id: Option<AmfUeNgapId> = None;
        let mut ran_ue_ngap_id: Option<RanUeNgapId> = None;
        let mut ran_paging_priority: Option<RanPagingPriority> = None;
        let mut pdu_session_resource_modify_list_mod_req: Option<
            PduSessionResourceModifyListModReq,
        > = None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                10 => amf_ue_ngap_id = Some(AmfUeNgapId::decode(data)?),
                85 => ran_ue_ngap_id = Some(RanUeNgapId::decode(data)?),
                83 => ran_paging_priority = Some(RanPagingPriority::decode(data)?),
                64 => {
                    pdu_session_resource_modify_list_mod_req =
                        Some(PduSessionResourceModifyListModReq::decode(data)?)
                }
                x => return Err(PerCodecError::new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        let amf_ue_ngap_id = amf_ue_ngap_id.ok_or(PerCodecError::new(format!(
            "Missing mandatory IE amf_ue_ngap_id"
        )))?;
        let ran_ue_ngap_id = ran_ue_ngap_id.ok_or(PerCodecError::new(format!(
            "Missing mandatory IE ran_ue_ngap_id"
        )))?;
        let pdu_session_resource_modify_list_mod_req = pdu_session_resource_modify_list_mod_req
            .ok_or(PerCodecError::new(format!(
                "Missing mandatory IE pdu_session_resource_modify_list_mod_req"
            )))?;
        Ok(Self {
            amf_ue_ngap_id,
            ran_ue_ngap_id,
            ran_paging_priority,
            pdu_session_resource_modify_list_mod_req,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        let ie = &mut Allocator::new_codec_data();
        self.amf_ue_ngap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 10, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.ran_ue_ngap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 85, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        if let Some(x) = &self.ran_paging_priority {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 83, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        let ie = &mut Allocator::new_codec_data();
        self.pdu_session_resource_modify_list_mod_req.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 64, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        encode::encode_sequence_header(data, true, &BitString::new(), false)?;
        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for PduSessionResourceModifyRequest {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PduSessionResourceModifyRequest::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PduSessionResourceModifyRequest");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PduSessionResourceModifyRequest");
            e
        })
    }
}
// PduSessionResourceModifyResponse
#[derive(Clone, Debug)]
pub struct PduSessionResourceModifyResponse {
    pub amf_ue_ngap_id: AmfUeNgapId,
    pub ran_ue_ngap_id: RanUeNgapId,
    pub pdu_session_resource_modify_list_mod_res: Option<PduSessionResourceModifyListModRes>,
    pub pdu_session_resource_failed_to_modify_list_mod_res:
        Option<PduSessionResourceFailedToModifyListModRes>,
    pub user_location_information: Option<UserLocationInformation>,
    pub criticality_diagnostics: Option<CriticalityDiagnostics>,
}

impl PduSessionResourceModifyResponse {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let _ = decode::decode_sequence_header(data, true, 0)?;
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut amf_ue_ngap_id: Option<AmfUeNgapId> = None;
        let mut ran_ue_ngap_id: Option<RanUeNgapId> = None;
        let mut pdu_session_resource_modify_list_mod_res: Option<
            PduSessionResourceModifyListModRes,
        > = None;
        let mut pdu_session_resource_failed_to_modify_list_mod_res: Option<
            PduSessionResourceFailedToModifyListModRes,
        > = None;
        let mut user_location_information: Option<UserLocationInformation> = None;
        let mut criticality_diagnostics: Option<CriticalityDiagnostics> = None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                10 => amf_ue_ngap_id = Some(AmfUeNgapId::decode(data)?),
                85 => ran_ue_ngap_id = Some(RanUeNgapId::decode(data)?),
                65 => {
                    pdu_session_resource_modify_list_mod_res =
                        Some(PduSessionResourceModifyListModRes::decode(data)?)
                }
                54 => {
                    pdu_session_resource_failed_to_modify_list_mod_res =
                        Some(PduSessionResourceFailedToModifyListModRes::decode(data)?)
                }
                121 => user_location_information = Some(UserLocationInformation::decode(data)?),
                19 => criticality_diagnostics = Some(CriticalityDiagnostics::decode(data)?),
                x => return Err(PerCodecError::new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        let amf_ue_ngap_id = amf_ue_ngap_id.ok_or(PerCodecError::new(format!(
            "Missing mandatory IE amf_ue_ngap_id"
        )))?;
        let ran_ue_ngap_id = ran_ue_ngap_id.ok_or(PerCodecError::new(format!(
            "Missing mandatory IE ran_ue_ngap_id"
        )))?;
        Ok(Self {
            amf_ue_ngap_id,
            ran_ue_ngap_id,
            pdu_session_resource_modify_list_mod_res,
            pdu_session_resource_failed_to_modify_list_mod_res,
            user_location_information,
            criticality_diagnostics,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        let ie = &mut Allocator::new_codec_data();
        self.amf_ue_ngap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 10, false)?;
        Criticality::Ignore.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.ran_ue_ngap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 85, false)?;
        Criticality::Ignore.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        if let Some(x) = &self.pdu_session_resource_modify_list_mod_res {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 65, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.pdu_session_resource_failed_to_modify_list_mod_res {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 54, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.user_location_information {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 121, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.criticality_diagnostics {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 19, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        encode::encode_sequence_header(data, true, &BitString::new(), false)?;
        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for PduSessionResourceModifyResponse {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PduSessionResourceModifyResponse::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PduSessionResourceModifyResponse");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PduSessionResourceModifyResponse");
            e
        })
    }
}
// PduSessionResourceNotify
#[derive(Clone, Debug)]
pub struct PduSessionResourceNotify {
    pub amf_ue_ngap_id: AmfUeNgapId,
    pub ran_ue_ngap_id: RanUeNgapId,
    pub pdu_session_resource_notify_list: Option<PduSessionResourceNotifyList>,
    pub pdu_session_resource_released_list_not: Option<PduSessionResourceReleasedListNot>,
    pub user_location_information: Option<UserLocationInformation>,
}

impl PduSessionResourceNotify {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let _ = decode::decode_sequence_header(data, true, 0)?;
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut amf_ue_ngap_id: Option<AmfUeNgapId> = None;
        let mut ran_ue_ngap_id: Option<RanUeNgapId> = None;
        let mut pdu_session_resource_notify_list: Option<PduSessionResourceNotifyList> = None;
        let mut pdu_session_resource_released_list_not: Option<PduSessionResourceReleasedListNot> =
            None;
        let mut user_location_information: Option<UserLocationInformation> = None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                10 => amf_ue_ngap_id = Some(AmfUeNgapId::decode(data)?),
                85 => ran_ue_ngap_id = Some(RanUeNgapId::decode(data)?),
                66 => {
                    pdu_session_resource_notify_list =
                        Some(PduSessionResourceNotifyList::decode(data)?)
                }
                67 => {
                    pdu_session_resource_released_list_not =
                        Some(PduSessionResourceReleasedListNot::decode(data)?)
                }
                121 => user_location_information = Some(UserLocationInformation::decode(data)?),
                x => return Err(PerCodecError::new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        let amf_ue_ngap_id = amf_ue_ngap_id.ok_or(PerCodecError::new(format!(
            "Missing mandatory IE amf_ue_ngap_id"
        )))?;
        let ran_ue_ngap_id = ran_ue_ngap_id.ok_or(PerCodecError::new(format!(
            "Missing mandatory IE ran_ue_ngap_id"
        )))?;
        Ok(Self {
            amf_ue_ngap_id,
            ran_ue_ngap_id,
            pdu_session_resource_notify_list,
            pdu_session_resource_released_list_not,
            user_location_information,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        let ie = &mut Allocator::new_codec_data();
        self.amf_ue_ngap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 10, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.ran_ue_ngap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 85, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        if let Some(x) = &self.pdu_session_resource_notify_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 66, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.pdu_session_resource_released_list_not {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 67, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.user_location_information {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 121, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        encode::encode_sequence_header(data, true, &BitString::new(), false)?;
        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for PduSessionResourceNotify {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PduSessionResourceNotify::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PduSessionResourceNotify");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PduSessionResourceNotify");
            e
        })
    }
}
// PduSessionResourceModifyIndication
#[derive(Clone, Debug)]
pub struct PduSessionResourceModifyIndication {
    pub amf_ue_ngap_id: AmfUeNgapId,
    pub ran_ue_ngap_id: RanUeNgapId,
    pub pdu_session_resource_modify_list_mod_ind: PduSessionResourceModifyListModInd,
    pub user_location_information: Option<UserLocationInformation>,
}

impl PduSessionResourceModifyIndication {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let _ = decode::decode_sequence_header(data, true, 0)?;
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut amf_ue_ngap_id: Option<AmfUeNgapId> = None;
        let mut ran_ue_ngap_id: Option<RanUeNgapId> = None;
        let mut pdu_session_resource_modify_list_mod_ind: Option<
            PduSessionResourceModifyListModInd,
        > = None;
        let mut user_location_information: Option<UserLocationInformation> = None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                10 => amf_ue_ngap_id = Some(AmfUeNgapId::decode(data)?),
                85 => ran_ue_ngap_id = Some(RanUeNgapId::decode(data)?),
                63 => {
                    pdu_session_resource_modify_list_mod_ind =
                        Some(PduSessionResourceModifyListModInd::decode(data)?)
                }
                121 => user_location_information = Some(UserLocationInformation::decode(data)?),
                x => return Err(PerCodecError::new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        let amf_ue_ngap_id = amf_ue_ngap_id.ok_or(PerCodecError::new(format!(
            "Missing mandatory IE amf_ue_ngap_id"
        )))?;
        let ran_ue_ngap_id = ran_ue_ngap_id.ok_or(PerCodecError::new(format!(
            "Missing mandatory IE ran_ue_ngap_id"
        )))?;
        let pdu_session_resource_modify_list_mod_ind = pdu_session_resource_modify_list_mod_ind
            .ok_or(PerCodecError::new(format!(
                "Missing mandatory IE pdu_session_resource_modify_list_mod_ind"
            )))?;
        Ok(Self {
            amf_ue_ngap_id,
            ran_ue_ngap_id,
            pdu_session_resource_modify_list_mod_ind,
            user_location_information,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        let ie = &mut Allocator::new_codec_data();
        self.amf_ue_ngap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 10, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.ran_ue_ngap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 85, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.pdu_session_resource_modify_list_mod_ind.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 63, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        if let Some(x) = &self.user_location_information {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 121, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        encode::encode_sequence_header(data, true, &BitString::new(), false)?;
        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for PduSessionResourceModifyIndication {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PduSessionResourceModifyIndication::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PduSessionResourceModifyIndication");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PduSessionResourceModifyIndication");
            e
        })
    }
}
// PduSessionResourceModifyConfirm
#[derive(Clone, Debug)]
pub struct PduSessionResourceModifyConfirm {
    pub amf_ue_ngap_id: AmfUeNgapId,
    pub ran_ue_ngap_id: RanUeNgapId,
    pub pdu_session_resource_modify_list_mod_cfm: Option<PduSessionResourceModifyListModCfm>,
    pub pdu_session_resource_failed_to_modify_list_mod_cfm:
        Option<PduSessionResourceFailedToModifyListModCfm>,
    pub criticality_diagnostics: Option<CriticalityDiagnostics>,
}

impl PduSessionResourceModifyConfirm {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let _ = decode::decode_sequence_header(data, true, 0)?;
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut amf_ue_ngap_id: Option<AmfUeNgapId> = None;
        let mut ran_ue_ngap_id: Option<RanUeNgapId> = None;
        let mut pdu_session_resource_modify_list_mod_cfm: Option<
            PduSessionResourceModifyListModCfm,
        > = None;
        let mut pdu_session_resource_failed_to_modify_list_mod_cfm: Option<
            PduSessionResourceFailedToModifyListModCfm,
        > = None;
        let mut criticality_diagnostics: Option<CriticalityDiagnostics> = None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                10 => amf_ue_ngap_id = Some(AmfUeNgapId::decode(data)?),
                85 => ran_ue_ngap_id = Some(RanUeNgapId::decode(data)?),
                62 => {
                    pdu_session_resource_modify_list_mod_cfm =
                        Some(PduSessionResourceModifyListModCfm::decode(data)?)
                }
                131 => {
                    pdu_session_resource_failed_to_modify_list_mod_cfm =
                        Some(PduSessionResourceFailedToModifyListModCfm::decode(data)?)
                }
                19 => criticality_diagnostics = Some(CriticalityDiagnostics::decode(data)?),
                x => return Err(PerCodecError::new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        let amf_ue_ngap_id = amf_ue_ngap_id.ok_or(PerCodecError::new(format!(
            "Missing mandatory IE amf_ue_ngap_id"
        )))?;
        let ran_ue_ngap_id = ran_ue_ngap_id.ok_or(PerCodecError::new(format!(
            "Missing mandatory IE ran_ue_ngap_id"
        )))?;
        Ok(Self {
            amf_ue_ngap_id,
            ran_ue_ngap_id,
            pdu_session_resource_modify_list_mod_cfm,
            pdu_session_resource_failed_to_modify_list_mod_cfm,
            criticality_diagnostics,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        let ie = &mut Allocator::new_codec_data();
        self.amf_ue_ngap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 10, false)?;
        Criticality::Ignore.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.ran_ue_ngap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 85, false)?;
        Criticality::Ignore.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        if let Some(x) = &self.pdu_session_resource_modify_list_mod_cfm {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 62, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.pdu_session_resource_failed_to_modify_list_mod_cfm {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 131, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.criticality_diagnostics {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 19, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        encode::encode_sequence_header(data, true, &BitString::new(), false)?;
        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for PduSessionResourceModifyConfirm {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PduSessionResourceModifyConfirm::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PduSessionResourceModifyConfirm");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PduSessionResourceModifyConfirm");
            e
        })
    }
}
// InitialContextSetupRequest
#[derive(Clone, Debug)]
pub struct InitialContextSetupRequest {
    pub amf_ue_ngap_id: AmfUeNgapId,
    pub ran_ue_ngap_id: RanUeNgapId,
    pub old_amf: Option<AmfName>,
    pub ue_aggregate_maximum_bit_rate: Option<UeAggregateMaximumBitRate>,
    pub core_network_assistance_information_for_inactive:
        Option<CoreNetworkAssistanceInformationForInactive>,
    pub guami: Guami,
    pub pdu_session_resource_setup_list_cxt_req: Option<PduSessionResourceSetupListCxtReq>,
    pub allowed_nssai: AllowedNssai,
    pub ue_security_capabilities: UeSecurityCapabilities,
    pub security_key: SecurityKey,
    pub trace_activation: Option<TraceActivation>,
    pub mobility_restriction_list: Option<MobilityRestrictionList>,
    pub ue_radio_capability: Option<UeRadioCapability>,
    pub index_to_rfsp: Option<IndexToRfsp>,
    pub masked_imeisv: Option<MaskedImeisv>,
    pub nas_pdu: Option<NasPdu>,
    pub emergency_fallback_indicator: Option<EmergencyFallbackIndicator>,
    pub rrc_inactive_transition_report_request: Option<RrcInactiveTransitionReportRequest>,
    pub ue_radio_capability_for_paging: Option<UeRadioCapabilityForPaging>,
    pub redirection_voice_fallback: Option<RedirectionVoiceFallback>,
    pub location_reporting_request_type: Option<LocationReportingRequestType>,
    pub cn_assisted_ran_tuning: Option<CnAssistedRanTuning>,
    pub srvcc_operation_possible: Option<SrvccOperationPossible>,
    pub iab_authorized: Option<IabAuthorized>,
    pub enhanced_coverage_restriction: Option<EnhancedCoverageRestriction>,
    pub extended_connected_time: Option<ExtendedConnectedTime>,
    pub ue_differentiation_info: Option<UeDifferentiationInfo>,
    pub nr_v2x_services_authorized: Option<NrV2xServicesAuthorized>,
    pub ltev2x_services_authorized: Option<Ltev2xServicesAuthorized>,
    pub nr_ue_sidelink_aggregate_maximum_bitrate: Option<NrUeSidelinkAggregateMaximumBitrate>,
    pub lte_ue_sidelink_aggregate_maximum_bitrate: Option<LteUeSidelinkAggregateMaximumBitrate>,
    pub pc5_qos_parameters: Option<Pc5QosParameters>,
    pub c_emode_brestricted: Option<CEmodeBrestricted>,
    pub ue_up_c_iot_support: Option<UeUpCIotSupport>,
    pub rg_level_wireline_access_characteristics: Option<RgLevelWirelineAccessCharacteristics>,
    pub management_based_mdt_plmn_list: Option<MdtPlmnList>,
    pub ue_radio_capability_id: Option<UeRadioCapabilityId>,
}

impl InitialContextSetupRequest {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let _ = decode::decode_sequence_header(data, true, 0)?;
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut amf_ue_ngap_id: Option<AmfUeNgapId> = None;
        let mut ran_ue_ngap_id: Option<RanUeNgapId> = None;
        let mut old_amf: Option<AmfName> = None;
        let mut ue_aggregate_maximum_bit_rate: Option<UeAggregateMaximumBitRate> = None;
        let mut core_network_assistance_information_for_inactive: Option<
            CoreNetworkAssistanceInformationForInactive,
        > = None;
        let mut guami: Option<Guami> = None;
        let mut pdu_session_resource_setup_list_cxt_req: Option<PduSessionResourceSetupListCxtReq> =
            None;
        let mut allowed_nssai: Option<AllowedNssai> = None;
        let mut ue_security_capabilities: Option<UeSecurityCapabilities> = None;
        let mut security_key: Option<SecurityKey> = None;
        let mut trace_activation: Option<TraceActivation> = None;
        let mut mobility_restriction_list: Option<MobilityRestrictionList> = None;
        let mut ue_radio_capability: Option<UeRadioCapability> = None;
        let mut index_to_rfsp: Option<IndexToRfsp> = None;
        let mut masked_imeisv: Option<MaskedImeisv> = None;
        let mut nas_pdu: Option<NasPdu> = None;
        let mut emergency_fallback_indicator: Option<EmergencyFallbackIndicator> = None;
        let mut rrc_inactive_transition_report_request: Option<RrcInactiveTransitionReportRequest> =
            None;
        let mut ue_radio_capability_for_paging: Option<UeRadioCapabilityForPaging> = None;
        let mut redirection_voice_fallback: Option<RedirectionVoiceFallback> = None;
        let mut location_reporting_request_type: Option<LocationReportingRequestType> = None;
        let mut cn_assisted_ran_tuning: Option<CnAssistedRanTuning> = None;
        let mut srvcc_operation_possible: Option<SrvccOperationPossible> = None;
        let mut iab_authorized: Option<IabAuthorized> = None;
        let mut enhanced_coverage_restriction: Option<EnhancedCoverageRestriction> = None;
        let mut extended_connected_time: Option<ExtendedConnectedTime> = None;
        let mut ue_differentiation_info: Option<UeDifferentiationInfo> = None;
        let mut nr_v2x_services_authorized: Option<NrV2xServicesAuthorized> = None;
        let mut ltev2x_services_authorized: Option<Ltev2xServicesAuthorized> = None;
        let mut nr_ue_sidelink_aggregate_maximum_bitrate: Option<
            NrUeSidelinkAggregateMaximumBitrate,
        > = None;
        let mut lte_ue_sidelink_aggregate_maximum_bitrate: Option<
            LteUeSidelinkAggregateMaximumBitrate,
        > = None;
        let mut pc5_qos_parameters: Option<Pc5QosParameters> = None;
        let mut c_emode_brestricted: Option<CEmodeBrestricted> = None;
        let mut ue_up_c_iot_support: Option<UeUpCIotSupport> = None;
        let mut rg_level_wireline_access_characteristics: Option<
            RgLevelWirelineAccessCharacteristics,
        > = None;
        let mut management_based_mdt_plmn_list: Option<MdtPlmnList> = None;
        let mut ue_radio_capability_id: Option<UeRadioCapabilityId> = None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                10 => amf_ue_ngap_id = Some(AmfUeNgapId::decode(data)?),
                85 => ran_ue_ngap_id = Some(RanUeNgapId::decode(data)?),
                48 => old_amf = Some(AmfName::decode(data)?),
                110 => {
                    ue_aggregate_maximum_bit_rate = Some(UeAggregateMaximumBitRate::decode(data)?)
                }
                18 => {
                    core_network_assistance_information_for_inactive =
                        Some(CoreNetworkAssistanceInformationForInactive::decode(data)?)
                }
                28 => guami = Some(Guami::decode(data)?),
                71 => {
                    pdu_session_resource_setup_list_cxt_req =
                        Some(PduSessionResourceSetupListCxtReq::decode(data)?)
                }
                0 => allowed_nssai = Some(AllowedNssai::decode(data)?),
                119 => ue_security_capabilities = Some(UeSecurityCapabilities::decode(data)?),
                94 => security_key = Some(SecurityKey::decode(data)?),
                108 => trace_activation = Some(TraceActivation::decode(data)?),
                36 => mobility_restriction_list = Some(MobilityRestrictionList::decode(data)?),
                117 => ue_radio_capability = Some(UeRadioCapability::decode(data)?),
                31 => index_to_rfsp = Some(IndexToRfsp::decode(data)?),
                34 => masked_imeisv = Some(MaskedImeisv::decode(data)?),
                38 => nas_pdu = Some(NasPdu::decode(data)?),
                24 => {
                    emergency_fallback_indicator = Some(EmergencyFallbackIndicator::decode(data)?)
                }
                91 => {
                    rrc_inactive_transition_report_request =
                        Some(RrcInactiveTransitionReportRequest::decode(data)?)
                }
                118 => {
                    ue_radio_capability_for_paging = Some(UeRadioCapabilityForPaging::decode(data)?)
                }
                146 => redirection_voice_fallback = Some(RedirectionVoiceFallback::decode(data)?),
                33 => {
                    location_reporting_request_type =
                        Some(LocationReportingRequestType::decode(data)?)
                }
                165 => cn_assisted_ran_tuning = Some(CnAssistedRanTuning::decode(data)?),
                177 => srvcc_operation_possible = Some(SrvccOperationPossible::decode(data)?),
                199 => iab_authorized = Some(IabAuthorized::decode(data)?),
                205 => {
                    enhanced_coverage_restriction = Some(EnhancedCoverageRestriction::decode(data)?)
                }
                206 => extended_connected_time = Some(ExtendedConnectedTime::decode(data)?),
                209 => ue_differentiation_info = Some(UeDifferentiationInfo::decode(data)?),
                216 => nr_v2x_services_authorized = Some(NrV2xServicesAuthorized::decode(data)?),
                215 => ltev2x_services_authorized = Some(Ltev2xServicesAuthorized::decode(data)?),
                218 => {
                    nr_ue_sidelink_aggregate_maximum_bitrate =
                        Some(NrUeSidelinkAggregateMaximumBitrate::decode(data)?)
                }
                217 => {
                    lte_ue_sidelink_aggregate_maximum_bitrate =
                        Some(LteUeSidelinkAggregateMaximumBitrate::decode(data)?)
                }
                219 => pc5_qos_parameters = Some(Pc5QosParameters::decode(data)?),
                222 => c_emode_brestricted = Some(CEmodeBrestricted::decode(data)?),
                234 => ue_up_c_iot_support = Some(UeUpCIotSupport::decode(data)?),
                238 => {
                    rg_level_wireline_access_characteristics =
                        Some(RgLevelWirelineAccessCharacteristics::decode(data)?)
                }
                254 => management_based_mdt_plmn_list = Some(MdtPlmnList::decode(data)?),
                264 => ue_radio_capability_id = Some(UeRadioCapabilityId::decode(data)?),
                x => return Err(PerCodecError::new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        let amf_ue_ngap_id = amf_ue_ngap_id.ok_or(PerCodecError::new(format!(
            "Missing mandatory IE amf_ue_ngap_id"
        )))?;
        let ran_ue_ngap_id = ran_ue_ngap_id.ok_or(PerCodecError::new(format!(
            "Missing mandatory IE ran_ue_ngap_id"
        )))?;
        let guami = guami.ok_or(PerCodecError::new(format!("Missing mandatory IE guami")))?;
        let allowed_nssai = allowed_nssai.ok_or(PerCodecError::new(format!(
            "Missing mandatory IE allowed_nssai"
        )))?;
        let ue_security_capabilities = ue_security_capabilities.ok_or(PerCodecError::new(
            format!("Missing mandatory IE ue_security_capabilities"),
        ))?;
        let security_key = security_key.ok_or(PerCodecError::new(format!(
            "Missing mandatory IE security_key"
        )))?;
        Ok(Self {
            amf_ue_ngap_id,
            ran_ue_ngap_id,
            old_amf,
            ue_aggregate_maximum_bit_rate,
            core_network_assistance_information_for_inactive,
            guami,
            pdu_session_resource_setup_list_cxt_req,
            allowed_nssai,
            ue_security_capabilities,
            security_key,
            trace_activation,
            mobility_restriction_list,
            ue_radio_capability,
            index_to_rfsp,
            masked_imeisv,
            nas_pdu,
            emergency_fallback_indicator,
            rrc_inactive_transition_report_request,
            ue_radio_capability_for_paging,
            redirection_voice_fallback,
            location_reporting_request_type,
            cn_assisted_ran_tuning,
            srvcc_operation_possible,
            iab_authorized,
            enhanced_coverage_restriction,
            extended_connected_time,
            ue_differentiation_info,
            nr_v2x_services_authorized,
            ltev2x_services_authorized,
            nr_ue_sidelink_aggregate_maximum_bitrate,
            lte_ue_sidelink_aggregate_maximum_bitrate,
            pc5_qos_parameters,
            c_emode_brestricted,
            ue_up_c_iot_support,
            rg_level_wireline_access_characteristics,
            management_based_mdt_plmn_list,
            ue_radio_capability_id,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        let ie = &mut Allocator::new_codec_data();
        self.amf_ue_ngap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 10, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.ran_ue_ngap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 85, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        if let Some(x) = &self.old_amf {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 48, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.ue_aggregate_maximum_bit_rate {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 110, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.core_network_assistance_information_for_inactive {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 18, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        let ie = &mut Allocator::new_codec_data();
        self.guami.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 28, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        if let Some(x) = &self.pdu_session_resource_setup_list_cxt_req {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 71, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        let ie = &mut Allocator::new_codec_data();
        self.allowed_nssai.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 0, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.ue_security_capabilities.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 119, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.security_key.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 94, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        if let Some(x) = &self.trace_activation {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 108, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.mobility_restriction_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 36, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.ue_radio_capability {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 117, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.index_to_rfsp {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 31, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.masked_imeisv {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 34, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.nas_pdu {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 38, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.emergency_fallback_indicator {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 24, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.rrc_inactive_transition_report_request {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 91, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.ue_radio_capability_for_paging {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 118, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.redirection_voice_fallback {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 146, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.location_reporting_request_type {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 33, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.cn_assisted_ran_tuning {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 165, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.srvcc_operation_possible {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 177, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.iab_authorized {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 199, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.enhanced_coverage_restriction {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 205, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.extended_connected_time {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 206, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.ue_differentiation_info {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 209, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.nr_v2x_services_authorized {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 216, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.ltev2x_services_authorized {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 215, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.nr_ue_sidelink_aggregate_maximum_bitrate {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 218, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.lte_ue_sidelink_aggregate_maximum_bitrate {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 217, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.pc5_qos_parameters {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 219, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.c_emode_brestricted {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 222, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.ue_up_c_iot_support {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 234, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.rg_level_wireline_access_characteristics {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 238, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.management_based_mdt_plmn_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 254, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.ue_radio_capability_id {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 264, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        encode::encode_sequence_header(data, true, &BitString::new(), false)?;
        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for InitialContextSetupRequest {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        InitialContextSetupRequest::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("InitialContextSetupRequest");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("InitialContextSetupRequest");
            e
        })
    }
}
// InitialContextSetupResponse
#[derive(Clone, Debug)]
pub struct InitialContextSetupResponse {
    pub amf_ue_ngap_id: AmfUeNgapId,
    pub ran_ue_ngap_id: RanUeNgapId,
    pub pdu_session_resource_setup_list_cxt_res: Option<PduSessionResourceSetupListCxtRes>,
    pub pdu_session_resource_failed_to_setup_list_cxt_res:
        Option<PduSessionResourceFailedToSetupListCxtRes>,
    pub criticality_diagnostics: Option<CriticalityDiagnostics>,
}

impl InitialContextSetupResponse {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let _ = decode::decode_sequence_header(data, true, 0)?;
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut amf_ue_ngap_id: Option<AmfUeNgapId> = None;
        let mut ran_ue_ngap_id: Option<RanUeNgapId> = None;
        let mut pdu_session_resource_setup_list_cxt_res: Option<PduSessionResourceSetupListCxtRes> =
            None;
        let mut pdu_session_resource_failed_to_setup_list_cxt_res: Option<
            PduSessionResourceFailedToSetupListCxtRes,
        > = None;
        let mut criticality_diagnostics: Option<CriticalityDiagnostics> = None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                10 => amf_ue_ngap_id = Some(AmfUeNgapId::decode(data)?),
                85 => ran_ue_ngap_id = Some(RanUeNgapId::decode(data)?),
                72 => {
                    pdu_session_resource_setup_list_cxt_res =
                        Some(PduSessionResourceSetupListCxtRes::decode(data)?)
                }
                55 => {
                    pdu_session_resource_failed_to_setup_list_cxt_res =
                        Some(PduSessionResourceFailedToSetupListCxtRes::decode(data)?)
                }
                19 => criticality_diagnostics = Some(CriticalityDiagnostics::decode(data)?),
                x => return Err(PerCodecError::new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        let amf_ue_ngap_id = amf_ue_ngap_id.ok_or(PerCodecError::new(format!(
            "Missing mandatory IE amf_ue_ngap_id"
        )))?;
        let ran_ue_ngap_id = ran_ue_ngap_id.ok_or(PerCodecError::new(format!(
            "Missing mandatory IE ran_ue_ngap_id"
        )))?;
        Ok(Self {
            amf_ue_ngap_id,
            ran_ue_ngap_id,
            pdu_session_resource_setup_list_cxt_res,
            pdu_session_resource_failed_to_setup_list_cxt_res,
            criticality_diagnostics,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        let ie = &mut Allocator::new_codec_data();
        self.amf_ue_ngap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 10, false)?;
        Criticality::Ignore.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.ran_ue_ngap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 85, false)?;
        Criticality::Ignore.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        if let Some(x) = &self.pdu_session_resource_setup_list_cxt_res {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 72, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.pdu_session_resource_failed_to_setup_list_cxt_res {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 55, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.criticality_diagnostics {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 19, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        encode::encode_sequence_header(data, true, &BitString::new(), false)?;
        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for InitialContextSetupResponse {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        InitialContextSetupResponse::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("InitialContextSetupResponse");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("InitialContextSetupResponse");
            e
        })
    }
}
// InitialContextSetupFailure
#[derive(Clone, Debug)]
pub struct InitialContextSetupFailure {
    pub amf_ue_ngap_id: AmfUeNgapId,
    pub ran_ue_ngap_id: RanUeNgapId,
    pub pdu_session_resource_failed_to_setup_list_cxt_fail:
        Option<PduSessionResourceFailedToSetupListCxtFail>,
    pub cause: Cause,
    pub criticality_diagnostics: Option<CriticalityDiagnostics>,
}

impl InitialContextSetupFailure {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let _ = decode::decode_sequence_header(data, true, 0)?;
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut amf_ue_ngap_id: Option<AmfUeNgapId> = None;
        let mut ran_ue_ngap_id: Option<RanUeNgapId> = None;
        let mut pdu_session_resource_failed_to_setup_list_cxt_fail: Option<
            PduSessionResourceFailedToSetupListCxtFail,
        > = None;
        let mut cause: Option<Cause> = None;
        let mut criticality_diagnostics: Option<CriticalityDiagnostics> = None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                10 => amf_ue_ngap_id = Some(AmfUeNgapId::decode(data)?),
                85 => ran_ue_ngap_id = Some(RanUeNgapId::decode(data)?),
                132 => {
                    pdu_session_resource_failed_to_setup_list_cxt_fail =
                        Some(PduSessionResourceFailedToSetupListCxtFail::decode(data)?)
                }
                15 => cause = Some(Cause::decode(data)?),
                19 => criticality_diagnostics = Some(CriticalityDiagnostics::decode(data)?),
                x => return Err(PerCodecError::new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        let amf_ue_ngap_id = amf_ue_ngap_id.ok_or(PerCodecError::new(format!(
            "Missing mandatory IE amf_ue_ngap_id"
        )))?;
        let ran_ue_ngap_id = ran_ue_ngap_id.ok_or(PerCodecError::new(format!(
            "Missing mandatory IE ran_ue_ngap_id"
        )))?;
        let cause = cause.ok_or(PerCodecError::new(format!("Missing mandatory IE cause")))?;
        Ok(Self {
            amf_ue_ngap_id,
            ran_ue_ngap_id,
            pdu_session_resource_failed_to_setup_list_cxt_fail,
            cause,
            criticality_diagnostics,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        let ie = &mut Allocator::new_codec_data();
        self.amf_ue_ngap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 10, false)?;
        Criticality::Ignore.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.ran_ue_ngap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 85, false)?;
        Criticality::Ignore.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        if let Some(x) = &self.pdu_session_resource_failed_to_setup_list_cxt_fail {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 132, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        let ie = &mut Allocator::new_codec_data();
        self.cause.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 15, false)?;
        Criticality::Ignore.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        if let Some(x) = &self.criticality_diagnostics {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 19, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        encode::encode_sequence_header(data, true, &BitString::new(), false)?;
        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for InitialContextSetupFailure {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        InitialContextSetupFailure::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("InitialContextSetupFailure");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("InitialContextSetupFailure");
            e
        })
    }
}
// UeContextReleaseRequest
#[derive(Clone, Debug)]
pub struct UeContextReleaseRequest {
    pub amf_ue_ngap_id: AmfUeNgapId,
    pub ran_ue_ngap_id: RanUeNgapId,
    pub pdu_session_resource_list_cxt_rel_req: Option<PduSessionResourceListCxtRelReq>,
    pub cause: Cause,
}

impl UeContextReleaseRequest {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let _ = decode::decode_sequence_header(data, true, 0)?;
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut amf_ue_ngap_id: Option<AmfUeNgapId> = None;
        let mut ran_ue_ngap_id: Option<RanUeNgapId> = None;
        let mut pdu_session_resource_list_cxt_rel_req: Option<PduSessionResourceListCxtRelReq> =
            None;
        let mut cause: Option<Cause> = None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                10 => amf_ue_ngap_id = Some(AmfUeNgapId::decode(data)?),
                85 => ran_ue_ngap_id = Some(RanUeNgapId::decode(data)?),
                133 => {
                    pdu_session_resource_list_cxt_rel_req =
                        Some(PduSessionResourceListCxtRelReq::decode(data)?)
                }
                15 => cause = Some(Cause::decode(data)?),
                x => return Err(PerCodecError::new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        let amf_ue_ngap_id = amf_ue_ngap_id.ok_or(PerCodecError::new(format!(
            "Missing mandatory IE amf_ue_ngap_id"
        )))?;
        let ran_ue_ngap_id = ran_ue_ngap_id.ok_or(PerCodecError::new(format!(
            "Missing mandatory IE ran_ue_ngap_id"
        )))?;
        let cause = cause.ok_or(PerCodecError::new(format!("Missing mandatory IE cause")))?;
        Ok(Self {
            amf_ue_ngap_id,
            ran_ue_ngap_id,
            pdu_session_resource_list_cxt_rel_req,
            cause,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        let ie = &mut Allocator::new_codec_data();
        self.amf_ue_ngap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 10, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.ran_ue_ngap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 85, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        if let Some(x) = &self.pdu_session_resource_list_cxt_rel_req {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 133, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        let ie = &mut Allocator::new_codec_data();
        self.cause.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 15, false)?;
        Criticality::Ignore.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        encode::encode_sequence_header(data, true, &BitString::new(), false)?;
        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for UeContextReleaseRequest {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        UeContextReleaseRequest::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UeContextReleaseRequest");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UeContextReleaseRequest");
            e
        })
    }
}
// UeContextReleaseCommand
#[derive(Clone, Debug)]
pub struct UeContextReleaseCommand {
    pub ue_ngap_i_ds: UeNgapIDs,
    pub cause: Cause,
}

impl UeContextReleaseCommand {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let _ = decode::decode_sequence_header(data, true, 0)?;
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut ue_ngap_i_ds: Option<UeNgapIDs> = None;
        let mut cause: Option<Cause> = None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                114 => ue_ngap_i_ds = Some(UeNgapIDs::decode(data)?),
                15 => cause = Some(Cause::decode(data)?),
                x => return Err(PerCodecError::new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        let ue_ngap_i_ds = ue_ngap_i_ds.ok_or(PerCodecError::new(format!(
            "Missing mandatory IE ue_ngap_i_ds"
        )))?;
        let cause = cause.ok_or(PerCodecError::new(format!("Missing mandatory IE cause")))?;
        Ok(Self {
            ue_ngap_i_ds,
            cause,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        let ie = &mut Allocator::new_codec_data();
        self.ue_ngap_i_ds.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 114, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.cause.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 15, false)?;
        Criticality::Ignore.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        encode::encode_sequence_header(data, true, &BitString::new(), false)?;
        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for UeContextReleaseCommand {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        UeContextReleaseCommand::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UeContextReleaseCommand");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UeContextReleaseCommand");
            e
        })
    }
}
// UeContextReleaseComplete
#[derive(Clone, Debug)]
pub struct UeContextReleaseComplete {
    pub amf_ue_ngap_id: AmfUeNgapId,
    pub ran_ue_ngap_id: RanUeNgapId,
    pub user_location_information: Option<UserLocationInformation>,
    pub info_on_recommended_cells_and_ran_nodes_for_paging:
        Option<InfoOnRecommendedCellsAndRanNodesForPaging>,
    pub pdu_session_resource_list_cxt_rel_cpl: Option<PduSessionResourceListCxtRelCpl>,
    pub criticality_diagnostics: Option<CriticalityDiagnostics>,
    pub paging_assis_datafor_c_ecapab_ue: Option<PagingAssisDataforCEcapabUe>,
}

impl UeContextReleaseComplete {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let _ = decode::decode_sequence_header(data, true, 0)?;
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut amf_ue_ngap_id: Option<AmfUeNgapId> = None;
        let mut ran_ue_ngap_id: Option<RanUeNgapId> = None;
        let mut user_location_information: Option<UserLocationInformation> = None;
        let mut info_on_recommended_cells_and_ran_nodes_for_paging: Option<
            InfoOnRecommendedCellsAndRanNodesForPaging,
        > = None;
        let mut pdu_session_resource_list_cxt_rel_cpl: Option<PduSessionResourceListCxtRelCpl> =
            None;
        let mut criticality_diagnostics: Option<CriticalityDiagnostics> = None;
        let mut paging_assis_datafor_c_ecapab_ue: Option<PagingAssisDataforCEcapabUe> = None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                10 => amf_ue_ngap_id = Some(AmfUeNgapId::decode(data)?),
                85 => ran_ue_ngap_id = Some(RanUeNgapId::decode(data)?),
                121 => user_location_information = Some(UserLocationInformation::decode(data)?),
                32 => {
                    info_on_recommended_cells_and_ran_nodes_for_paging =
                        Some(InfoOnRecommendedCellsAndRanNodesForPaging::decode(data)?)
                }
                60 => {
                    pdu_session_resource_list_cxt_rel_cpl =
                        Some(PduSessionResourceListCxtRelCpl::decode(data)?)
                }
                19 => criticality_diagnostics = Some(CriticalityDiagnostics::decode(data)?),
                207 => {
                    paging_assis_datafor_c_ecapab_ue =
                        Some(PagingAssisDataforCEcapabUe::decode(data)?)
                }
                x => return Err(PerCodecError::new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        let amf_ue_ngap_id = amf_ue_ngap_id.ok_or(PerCodecError::new(format!(
            "Missing mandatory IE amf_ue_ngap_id"
        )))?;
        let ran_ue_ngap_id = ran_ue_ngap_id.ok_or(PerCodecError::new(format!(
            "Missing mandatory IE ran_ue_ngap_id"
        )))?;
        Ok(Self {
            amf_ue_ngap_id,
            ran_ue_ngap_id,
            user_location_information,
            info_on_recommended_cells_and_ran_nodes_for_paging,
            pdu_session_resource_list_cxt_rel_cpl,
            criticality_diagnostics,
            paging_assis_datafor_c_ecapab_ue,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        let ie = &mut Allocator::new_codec_data();
        self.amf_ue_ngap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 10, false)?;
        Criticality::Ignore.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.ran_ue_ngap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 85, false)?;
        Criticality::Ignore.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        if let Some(x) = &self.user_location_information {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 121, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.info_on_recommended_cells_and_ran_nodes_for_paging {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 32, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.pdu_session_resource_list_cxt_rel_cpl {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 60, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.criticality_diagnostics {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 19, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.paging_assis_datafor_c_ecapab_ue {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 207, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        encode::encode_sequence_header(data, true, &BitString::new(), false)?;
        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for UeContextReleaseComplete {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        UeContextReleaseComplete::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UeContextReleaseComplete");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UeContextReleaseComplete");
            e
        })
    }
}
// UeContextResumeRequest
#[derive(Clone, Debug)]
pub struct UeContextResumeRequest {
    pub amf_ue_ngap_id: AmfUeNgapId,
    pub ran_ue_ngap_id: RanUeNgapId,
    pub rrc_resume_cause: RrcEstablishmentCause,
    pub pdu_session_resource_resume_list_res_req: Option<PduSessionResourceResumeListResReq>,
    pub pdu_session_resource_failed_to_resume_list_res_req:
        Option<PduSessionResourceFailedToResumeListResReq>,
    pub suspend_request_indication: Option<SuspendRequestIndication>,
    pub info_on_recommended_cells_and_ran_nodes_for_paging:
        Option<InfoOnRecommendedCellsAndRanNodesForPaging>,
    pub paging_assis_datafor_c_ecapab_ue: Option<PagingAssisDataforCEcapabUe>,
}

impl UeContextResumeRequest {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let _ = decode::decode_sequence_header(data, true, 0)?;
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut amf_ue_ngap_id: Option<AmfUeNgapId> = None;
        let mut ran_ue_ngap_id: Option<RanUeNgapId> = None;
        let mut rrc_resume_cause: Option<RrcEstablishmentCause> = None;
        let mut pdu_session_resource_resume_list_res_req: Option<
            PduSessionResourceResumeListResReq,
        > = None;
        let mut pdu_session_resource_failed_to_resume_list_res_req: Option<
            PduSessionResourceFailedToResumeListResReq,
        > = None;
        let mut suspend_request_indication: Option<SuspendRequestIndication> = None;
        let mut info_on_recommended_cells_and_ran_nodes_for_paging: Option<
            InfoOnRecommendedCellsAndRanNodesForPaging,
        > = None;
        let mut paging_assis_datafor_c_ecapab_ue: Option<PagingAssisDataforCEcapabUe> = None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                10 => amf_ue_ngap_id = Some(AmfUeNgapId::decode(data)?),
                85 => ran_ue_ngap_id = Some(RanUeNgapId::decode(data)?),
                237 => rrc_resume_cause = Some(RrcEstablishmentCause::decode(data)?),
                232 => {
                    pdu_session_resource_resume_list_res_req =
                        Some(PduSessionResourceResumeListResReq::decode(data)?)
                }
                229 => {
                    pdu_session_resource_failed_to_resume_list_res_req =
                        Some(PduSessionResourceFailedToResumeListResReq::decode(data)?)
                }
                235 => suspend_request_indication = Some(SuspendRequestIndication::decode(data)?),
                32 => {
                    info_on_recommended_cells_and_ran_nodes_for_paging =
                        Some(InfoOnRecommendedCellsAndRanNodesForPaging::decode(data)?)
                }
                207 => {
                    paging_assis_datafor_c_ecapab_ue =
                        Some(PagingAssisDataforCEcapabUe::decode(data)?)
                }
                x => return Err(PerCodecError::new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        let amf_ue_ngap_id = amf_ue_ngap_id.ok_or(PerCodecError::new(format!(
            "Missing mandatory IE amf_ue_ngap_id"
        )))?;
        let ran_ue_ngap_id = ran_ue_ngap_id.ok_or(PerCodecError::new(format!(
            "Missing mandatory IE ran_ue_ngap_id"
        )))?;
        let rrc_resume_cause = rrc_resume_cause.ok_or(PerCodecError::new(format!(
            "Missing mandatory IE rrc_resume_cause"
        )))?;
        Ok(Self {
            amf_ue_ngap_id,
            ran_ue_ngap_id,
            rrc_resume_cause,
            pdu_session_resource_resume_list_res_req,
            pdu_session_resource_failed_to_resume_list_res_req,
            suspend_request_indication,
            info_on_recommended_cells_and_ran_nodes_for_paging,
            paging_assis_datafor_c_ecapab_ue,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        let ie = &mut Allocator::new_codec_data();
        self.amf_ue_ngap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 10, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.ran_ue_ngap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 85, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.rrc_resume_cause.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 237, false)?;
        Criticality::Ignore.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        if let Some(x) = &self.pdu_session_resource_resume_list_res_req {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 232, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.pdu_session_resource_failed_to_resume_list_res_req {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 229, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.suspend_request_indication {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 235, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.info_on_recommended_cells_and_ran_nodes_for_paging {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 32, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.paging_assis_datafor_c_ecapab_ue {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 207, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        encode::encode_sequence_header(data, true, &BitString::new(), false)?;
        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for UeContextResumeRequest {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        UeContextResumeRequest::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UeContextResumeRequest");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UeContextResumeRequest");
            e
        })
    }
}
// UeContextResumeResponse
#[derive(Clone, Debug)]
pub struct UeContextResumeResponse {
    pub amf_ue_ngap_id: AmfUeNgapId,
    pub ran_ue_ngap_id: RanUeNgapId,
    pub pdu_session_resource_resume_list_res_res: Option<PduSessionResourceResumeListResRes>,
    pub pdu_session_resource_failed_to_resume_list_res_res:
        Option<PduSessionResourceFailedToResumeListResRes>,
    pub security_context: Option<SecurityContext>,
    pub suspend_response_indication: Option<SuspendResponseIndication>,
    pub extended_connected_time: Option<ExtendedConnectedTime>,
    pub criticality_diagnostics: Option<CriticalityDiagnostics>,
}

impl UeContextResumeResponse {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let _ = decode::decode_sequence_header(data, true, 0)?;
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut amf_ue_ngap_id: Option<AmfUeNgapId> = None;
        let mut ran_ue_ngap_id: Option<RanUeNgapId> = None;
        let mut pdu_session_resource_resume_list_res_res: Option<
            PduSessionResourceResumeListResRes,
        > = None;
        let mut pdu_session_resource_failed_to_resume_list_res_res: Option<
            PduSessionResourceFailedToResumeListResRes,
        > = None;
        let mut security_context: Option<SecurityContext> = None;
        let mut suspend_response_indication: Option<SuspendResponseIndication> = None;
        let mut extended_connected_time: Option<ExtendedConnectedTime> = None;
        let mut criticality_diagnostics: Option<CriticalityDiagnostics> = None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                10 => amf_ue_ngap_id = Some(AmfUeNgapId::decode(data)?),
                85 => ran_ue_ngap_id = Some(RanUeNgapId::decode(data)?),
                233 => {
                    pdu_session_resource_resume_list_res_res =
                        Some(PduSessionResourceResumeListResRes::decode(data)?)
                }
                230 => {
                    pdu_session_resource_failed_to_resume_list_res_res =
                        Some(PduSessionResourceFailedToResumeListResRes::decode(data)?)
                }
                93 => security_context = Some(SecurityContext::decode(data)?),
                236 => suspend_response_indication = Some(SuspendResponseIndication::decode(data)?),
                206 => extended_connected_time = Some(ExtendedConnectedTime::decode(data)?),
                19 => criticality_diagnostics = Some(CriticalityDiagnostics::decode(data)?),
                x => return Err(PerCodecError::new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        let amf_ue_ngap_id = amf_ue_ngap_id.ok_or(PerCodecError::new(format!(
            "Missing mandatory IE amf_ue_ngap_id"
        )))?;
        let ran_ue_ngap_id = ran_ue_ngap_id.ok_or(PerCodecError::new(format!(
            "Missing mandatory IE ran_ue_ngap_id"
        )))?;
        Ok(Self {
            amf_ue_ngap_id,
            ran_ue_ngap_id,
            pdu_session_resource_resume_list_res_res,
            pdu_session_resource_failed_to_resume_list_res_res,
            security_context,
            suspend_response_indication,
            extended_connected_time,
            criticality_diagnostics,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        let ie = &mut Allocator::new_codec_data();
        self.amf_ue_ngap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 10, false)?;
        Criticality::Ignore.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.ran_ue_ngap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 85, false)?;
        Criticality::Ignore.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        if let Some(x) = &self.pdu_session_resource_resume_list_res_res {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 233, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.pdu_session_resource_failed_to_resume_list_res_res {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 230, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.security_context {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 93, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.suspend_response_indication {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 236, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.extended_connected_time {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 206, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.criticality_diagnostics {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 19, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        encode::encode_sequence_header(data, true, &BitString::new(), false)?;
        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for UeContextResumeResponse {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        UeContextResumeResponse::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UeContextResumeResponse");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UeContextResumeResponse");
            e
        })
    }
}
// UeContextResumeFailure
#[derive(Clone, Debug)]
pub struct UeContextResumeFailure {
    pub amf_ue_ngap_id: AmfUeNgapId,
    pub ran_ue_ngap_id: RanUeNgapId,
    pub cause: Cause,
    pub criticality_diagnostics: Option<CriticalityDiagnostics>,
}

impl UeContextResumeFailure {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let _ = decode::decode_sequence_header(data, true, 0)?;
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut amf_ue_ngap_id: Option<AmfUeNgapId> = None;
        let mut ran_ue_ngap_id: Option<RanUeNgapId> = None;
        let mut cause: Option<Cause> = None;
        let mut criticality_diagnostics: Option<CriticalityDiagnostics> = None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                10 => amf_ue_ngap_id = Some(AmfUeNgapId::decode(data)?),
                85 => ran_ue_ngap_id = Some(RanUeNgapId::decode(data)?),
                15 => cause = Some(Cause::decode(data)?),
                19 => criticality_diagnostics = Some(CriticalityDiagnostics::decode(data)?),
                x => return Err(PerCodecError::new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        let amf_ue_ngap_id = amf_ue_ngap_id.ok_or(PerCodecError::new(format!(
            "Missing mandatory IE amf_ue_ngap_id"
        )))?;
        let ran_ue_ngap_id = ran_ue_ngap_id.ok_or(PerCodecError::new(format!(
            "Missing mandatory IE ran_ue_ngap_id"
        )))?;
        let cause = cause.ok_or(PerCodecError::new(format!("Missing mandatory IE cause")))?;
        Ok(Self {
            amf_ue_ngap_id,
            ran_ue_ngap_id,
            cause,
            criticality_diagnostics,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        let ie = &mut Allocator::new_codec_data();
        self.amf_ue_ngap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 10, false)?;
        Criticality::Ignore.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.ran_ue_ngap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 85, false)?;
        Criticality::Ignore.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.cause.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 15, false)?;
        Criticality::Ignore.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        if let Some(x) = &self.criticality_diagnostics {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 19, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        encode::encode_sequence_header(data, true, &BitString::new(), false)?;
        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for UeContextResumeFailure {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        UeContextResumeFailure::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UeContextResumeFailure");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UeContextResumeFailure");
            e
        })
    }
}
// UeContextSuspendRequest
#[derive(Clone, Debug)]
pub struct UeContextSuspendRequest {
    pub amf_ue_ngap_id: AmfUeNgapId,
    pub ran_ue_ngap_id: RanUeNgapId,
    pub info_on_recommended_cells_and_ran_nodes_for_paging:
        Option<InfoOnRecommendedCellsAndRanNodesForPaging>,
    pub paging_assis_datafor_c_ecapab_ue: Option<PagingAssisDataforCEcapabUe>,
    pub pdu_session_resource_suspend_list_sus_req: Option<PduSessionResourceSuspendListSusReq>,
}

impl UeContextSuspendRequest {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let _ = decode::decode_sequence_header(data, true, 0)?;
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut amf_ue_ngap_id: Option<AmfUeNgapId> = None;
        let mut ran_ue_ngap_id: Option<RanUeNgapId> = None;
        let mut info_on_recommended_cells_and_ran_nodes_for_paging: Option<
            InfoOnRecommendedCellsAndRanNodesForPaging,
        > = None;
        let mut paging_assis_datafor_c_ecapab_ue: Option<PagingAssisDataforCEcapabUe> = None;
        let mut pdu_session_resource_suspend_list_sus_req: Option<
            PduSessionResourceSuspendListSusReq,
        > = None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                10 => amf_ue_ngap_id = Some(AmfUeNgapId::decode(data)?),
                85 => ran_ue_ngap_id = Some(RanUeNgapId::decode(data)?),
                32 => {
                    info_on_recommended_cells_and_ran_nodes_for_paging =
                        Some(InfoOnRecommendedCellsAndRanNodesForPaging::decode(data)?)
                }
                207 => {
                    paging_assis_datafor_c_ecapab_ue =
                        Some(PagingAssisDataforCEcapabUe::decode(data)?)
                }
                231 => {
                    pdu_session_resource_suspend_list_sus_req =
                        Some(PduSessionResourceSuspendListSusReq::decode(data)?)
                }
                x => return Err(PerCodecError::new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        let amf_ue_ngap_id = amf_ue_ngap_id.ok_or(PerCodecError::new(format!(
            "Missing mandatory IE amf_ue_ngap_id"
        )))?;
        let ran_ue_ngap_id = ran_ue_ngap_id.ok_or(PerCodecError::new(format!(
            "Missing mandatory IE ran_ue_ngap_id"
        )))?;
        Ok(Self {
            amf_ue_ngap_id,
            ran_ue_ngap_id,
            info_on_recommended_cells_and_ran_nodes_for_paging,
            paging_assis_datafor_c_ecapab_ue,
            pdu_session_resource_suspend_list_sus_req,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        let ie = &mut Allocator::new_codec_data();
        self.amf_ue_ngap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 10, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.ran_ue_ngap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 85, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        if let Some(x) = &self.info_on_recommended_cells_and_ran_nodes_for_paging {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 32, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.paging_assis_datafor_c_ecapab_ue {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 207, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.pdu_session_resource_suspend_list_sus_req {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 231, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        encode::encode_sequence_header(data, true, &BitString::new(), false)?;
        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for UeContextSuspendRequest {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        UeContextSuspendRequest::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UeContextSuspendRequest");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UeContextSuspendRequest");
            e
        })
    }
}
// UeContextSuspendResponse
#[derive(Clone, Debug)]
pub struct UeContextSuspendResponse {
    pub amf_ue_ngap_id: AmfUeNgapId,
    pub ran_ue_ngap_id: RanUeNgapId,
    pub security_context: Option<SecurityContext>,
    pub criticality_diagnostics: Option<CriticalityDiagnostics>,
}

impl UeContextSuspendResponse {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let _ = decode::decode_sequence_header(data, true, 0)?;
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut amf_ue_ngap_id: Option<AmfUeNgapId> = None;
        let mut ran_ue_ngap_id: Option<RanUeNgapId> = None;
        let mut security_context: Option<SecurityContext> = None;
        let mut criticality_diagnostics: Option<CriticalityDiagnostics> = None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                10 => amf_ue_ngap_id = Some(AmfUeNgapId::decode(data)?),
                85 => ran_ue_ngap_id = Some(RanUeNgapId::decode(data)?),
                93 => security_context = Some(SecurityContext::decode(data)?),
                19 => criticality_diagnostics = Some(CriticalityDiagnostics::decode(data)?),
                x => return Err(PerCodecError::new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        let amf_ue_ngap_id = amf_ue_ngap_id.ok_or(PerCodecError::new(format!(
            "Missing mandatory IE amf_ue_ngap_id"
        )))?;
        let ran_ue_ngap_id = ran_ue_ngap_id.ok_or(PerCodecError::new(format!(
            "Missing mandatory IE ran_ue_ngap_id"
        )))?;
        Ok(Self {
            amf_ue_ngap_id,
            ran_ue_ngap_id,
            security_context,
            criticality_diagnostics,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        let ie = &mut Allocator::new_codec_data();
        self.amf_ue_ngap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 10, false)?;
        Criticality::Ignore.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.ran_ue_ngap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 85, false)?;
        Criticality::Ignore.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        if let Some(x) = &self.security_context {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 93, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.criticality_diagnostics {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 19, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        encode::encode_sequence_header(data, true, &BitString::new(), false)?;
        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for UeContextSuspendResponse {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        UeContextSuspendResponse::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UeContextSuspendResponse");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UeContextSuspendResponse");
            e
        })
    }
}
// UeContextSuspendFailure
#[derive(Clone, Debug)]
pub struct UeContextSuspendFailure {
    pub amf_ue_ngap_id: AmfUeNgapId,
    pub ran_ue_ngap_id: RanUeNgapId,
    pub cause: Cause,
    pub criticality_diagnostics: Option<CriticalityDiagnostics>,
}

impl UeContextSuspendFailure {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let _ = decode::decode_sequence_header(data, true, 0)?;
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut amf_ue_ngap_id: Option<AmfUeNgapId> = None;
        let mut ran_ue_ngap_id: Option<RanUeNgapId> = None;
        let mut cause: Option<Cause> = None;
        let mut criticality_diagnostics: Option<CriticalityDiagnostics> = None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                10 => amf_ue_ngap_id = Some(AmfUeNgapId::decode(data)?),
                85 => ran_ue_ngap_id = Some(RanUeNgapId::decode(data)?),
                15 => cause = Some(Cause::decode(data)?),
                19 => criticality_diagnostics = Some(CriticalityDiagnostics::decode(data)?),
                x => return Err(PerCodecError::new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        let amf_ue_ngap_id = amf_ue_ngap_id.ok_or(PerCodecError::new(format!(
            "Missing mandatory IE amf_ue_ngap_id"
        )))?;
        let ran_ue_ngap_id = ran_ue_ngap_id.ok_or(PerCodecError::new(format!(
            "Missing mandatory IE ran_ue_ngap_id"
        )))?;
        let cause = cause.ok_or(PerCodecError::new(format!("Missing mandatory IE cause")))?;
        Ok(Self {
            amf_ue_ngap_id,
            ran_ue_ngap_id,
            cause,
            criticality_diagnostics,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        let ie = &mut Allocator::new_codec_data();
        self.amf_ue_ngap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 10, false)?;
        Criticality::Ignore.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.ran_ue_ngap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 85, false)?;
        Criticality::Ignore.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.cause.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 15, false)?;
        Criticality::Ignore.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        if let Some(x) = &self.criticality_diagnostics {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 19, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        encode::encode_sequence_header(data, true, &BitString::new(), false)?;
        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for UeContextSuspendFailure {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        UeContextSuspendFailure::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UeContextSuspendFailure");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UeContextSuspendFailure");
            e
        })
    }
}
// UeContextModificationRequest
#[derive(Clone, Debug)]
pub struct UeContextModificationRequest {
    pub amf_ue_ngap_id: AmfUeNgapId,
    pub ran_ue_ngap_id: RanUeNgapId,
    pub ran_paging_priority: Option<RanPagingPriority>,
    pub security_key: Option<SecurityKey>,
    pub index_to_rfsp: Option<IndexToRfsp>,
    pub ue_aggregate_maximum_bit_rate: Option<UeAggregateMaximumBitRate>,
    pub ue_security_capabilities: Option<UeSecurityCapabilities>,
    pub core_network_assistance_information_for_inactive:
        Option<CoreNetworkAssistanceInformationForInactive>,
    pub emergency_fallback_indicator: Option<EmergencyFallbackIndicator>,
    pub new_amf_ue_ngap_id: Option<AmfUeNgapId>,
    pub rrc_inactive_transition_report_request: Option<RrcInactiveTransitionReportRequest>,
    pub new_guami: Option<Guami>,
    pub cn_assisted_ran_tuning: Option<CnAssistedRanTuning>,
    pub srvcc_operation_possible: Option<SrvccOperationPossible>,
    pub iab_authorized: Option<IabAuthorized>,
    pub nr_v2x_services_authorized: Option<NrV2xServicesAuthorized>,
    pub ltev2x_services_authorized: Option<Ltev2xServicesAuthorized>,
    pub nr_ue_sidelink_aggregate_maximum_bitrate: Option<NrUeSidelinkAggregateMaximumBitrate>,
    pub lte_ue_sidelink_aggregate_maximum_bitrate: Option<LteUeSidelinkAggregateMaximumBitrate>,
    pub pc5_qos_parameters: Option<Pc5QosParameters>,
    pub ue_radio_capability_id: Option<UeRadioCapabilityId>,
    pub rg_level_wireline_access_characteristics: Option<RgLevelWirelineAccessCharacteristics>,
}

impl UeContextModificationRequest {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let _ = decode::decode_sequence_header(data, true, 0)?;
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut amf_ue_ngap_id: Option<AmfUeNgapId> = None;
        let mut ran_ue_ngap_id: Option<RanUeNgapId> = None;
        let mut ran_paging_priority: Option<RanPagingPriority> = None;
        let mut security_key: Option<SecurityKey> = None;
        let mut index_to_rfsp: Option<IndexToRfsp> = None;
        let mut ue_aggregate_maximum_bit_rate: Option<UeAggregateMaximumBitRate> = None;
        let mut ue_security_capabilities: Option<UeSecurityCapabilities> = None;
        let mut core_network_assistance_information_for_inactive: Option<
            CoreNetworkAssistanceInformationForInactive,
        > = None;
        let mut emergency_fallback_indicator: Option<EmergencyFallbackIndicator> = None;
        let mut new_amf_ue_ngap_id: Option<AmfUeNgapId> = None;
        let mut rrc_inactive_transition_report_request: Option<RrcInactiveTransitionReportRequest> =
            None;
        let mut new_guami: Option<Guami> = None;
        let mut cn_assisted_ran_tuning: Option<CnAssistedRanTuning> = None;
        let mut srvcc_operation_possible: Option<SrvccOperationPossible> = None;
        let mut iab_authorized: Option<IabAuthorized> = None;
        let mut nr_v2x_services_authorized: Option<NrV2xServicesAuthorized> = None;
        let mut ltev2x_services_authorized: Option<Ltev2xServicesAuthorized> = None;
        let mut nr_ue_sidelink_aggregate_maximum_bitrate: Option<
            NrUeSidelinkAggregateMaximumBitrate,
        > = None;
        let mut lte_ue_sidelink_aggregate_maximum_bitrate: Option<
            LteUeSidelinkAggregateMaximumBitrate,
        > = None;
        let mut pc5_qos_parameters: Option<Pc5QosParameters> = None;
        let mut ue_radio_capability_id: Option<UeRadioCapabilityId> = None;
        let mut rg_level_wireline_access_characteristics: Option<
            RgLevelWirelineAccessCharacteristics,
        > = None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                10 => amf_ue_ngap_id = Some(AmfUeNgapId::decode(data)?),
                85 => ran_ue_ngap_id = Some(RanUeNgapId::decode(data)?),
                83 => ran_paging_priority = Some(RanPagingPriority::decode(data)?),
                94 => security_key = Some(SecurityKey::decode(data)?),
                31 => index_to_rfsp = Some(IndexToRfsp::decode(data)?),
                110 => {
                    ue_aggregate_maximum_bit_rate = Some(UeAggregateMaximumBitRate::decode(data)?)
                }
                119 => ue_security_capabilities = Some(UeSecurityCapabilities::decode(data)?),
                18 => {
                    core_network_assistance_information_for_inactive =
                        Some(CoreNetworkAssistanceInformationForInactive::decode(data)?)
                }
                24 => {
                    emergency_fallback_indicator = Some(EmergencyFallbackIndicator::decode(data)?)
                }
                40 => new_amf_ue_ngap_id = Some(AmfUeNgapId::decode(data)?),
                91 => {
                    rrc_inactive_transition_report_request =
                        Some(RrcInactiveTransitionReportRequest::decode(data)?)
                }
                162 => new_guami = Some(Guami::decode(data)?),
                165 => cn_assisted_ran_tuning = Some(CnAssistedRanTuning::decode(data)?),
                177 => srvcc_operation_possible = Some(SrvccOperationPossible::decode(data)?),
                199 => iab_authorized = Some(IabAuthorized::decode(data)?),
                216 => nr_v2x_services_authorized = Some(NrV2xServicesAuthorized::decode(data)?),
                215 => ltev2x_services_authorized = Some(Ltev2xServicesAuthorized::decode(data)?),
                218 => {
                    nr_ue_sidelink_aggregate_maximum_bitrate =
                        Some(NrUeSidelinkAggregateMaximumBitrate::decode(data)?)
                }
                217 => {
                    lte_ue_sidelink_aggregate_maximum_bitrate =
                        Some(LteUeSidelinkAggregateMaximumBitrate::decode(data)?)
                }
                219 => pc5_qos_parameters = Some(Pc5QosParameters::decode(data)?),
                264 => ue_radio_capability_id = Some(UeRadioCapabilityId::decode(data)?),
                238 => {
                    rg_level_wireline_access_characteristics =
                        Some(RgLevelWirelineAccessCharacteristics::decode(data)?)
                }
                x => return Err(PerCodecError::new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        let amf_ue_ngap_id = amf_ue_ngap_id.ok_or(PerCodecError::new(format!(
            "Missing mandatory IE amf_ue_ngap_id"
        )))?;
        let ran_ue_ngap_id = ran_ue_ngap_id.ok_or(PerCodecError::new(format!(
            "Missing mandatory IE ran_ue_ngap_id"
        )))?;
        Ok(Self {
            amf_ue_ngap_id,
            ran_ue_ngap_id,
            ran_paging_priority,
            security_key,
            index_to_rfsp,
            ue_aggregate_maximum_bit_rate,
            ue_security_capabilities,
            core_network_assistance_information_for_inactive,
            emergency_fallback_indicator,
            new_amf_ue_ngap_id,
            rrc_inactive_transition_report_request,
            new_guami,
            cn_assisted_ran_tuning,
            srvcc_operation_possible,
            iab_authorized,
            nr_v2x_services_authorized,
            ltev2x_services_authorized,
            nr_ue_sidelink_aggregate_maximum_bitrate,
            lte_ue_sidelink_aggregate_maximum_bitrate,
            pc5_qos_parameters,
            ue_radio_capability_id,
            rg_level_wireline_access_characteristics,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        let ie = &mut Allocator::new_codec_data();
        self.amf_ue_ngap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 10, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.ran_ue_ngap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 85, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        if let Some(x) = &self.ran_paging_priority {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 83, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.security_key {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 94, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.index_to_rfsp {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 31, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.ue_aggregate_maximum_bit_rate {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 110, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.ue_security_capabilities {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 119, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.core_network_assistance_information_for_inactive {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 18, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.emergency_fallback_indicator {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 24, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.new_amf_ue_ngap_id {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 40, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.rrc_inactive_transition_report_request {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 91, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.new_guami {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 162, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.cn_assisted_ran_tuning {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 165, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.srvcc_operation_possible {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 177, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.iab_authorized {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 199, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.nr_v2x_services_authorized {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 216, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.ltev2x_services_authorized {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 215, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.nr_ue_sidelink_aggregate_maximum_bitrate {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 218, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.lte_ue_sidelink_aggregate_maximum_bitrate {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 217, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.pc5_qos_parameters {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 219, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.ue_radio_capability_id {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 264, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.rg_level_wireline_access_characteristics {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 238, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        encode::encode_sequence_header(data, true, &BitString::new(), false)?;
        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for UeContextModificationRequest {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        UeContextModificationRequest::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UeContextModificationRequest");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UeContextModificationRequest");
            e
        })
    }
}
// UeContextModificationResponse
#[derive(Clone, Debug)]
pub struct UeContextModificationResponse {
    pub amf_ue_ngap_id: AmfUeNgapId,
    pub ran_ue_ngap_id: RanUeNgapId,
    pub rrc_state: Option<RrcState>,
    pub user_location_information: Option<UserLocationInformation>,
    pub criticality_diagnostics: Option<CriticalityDiagnostics>,
}

impl UeContextModificationResponse {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let _ = decode::decode_sequence_header(data, true, 0)?;
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut amf_ue_ngap_id: Option<AmfUeNgapId> = None;
        let mut ran_ue_ngap_id: Option<RanUeNgapId> = None;
        let mut rrc_state: Option<RrcState> = None;
        let mut user_location_information: Option<UserLocationInformation> = None;
        let mut criticality_diagnostics: Option<CriticalityDiagnostics> = None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                10 => amf_ue_ngap_id = Some(AmfUeNgapId::decode(data)?),
                85 => ran_ue_ngap_id = Some(RanUeNgapId::decode(data)?),
                92 => rrc_state = Some(RrcState::decode(data)?),
                121 => user_location_information = Some(UserLocationInformation::decode(data)?),
                19 => criticality_diagnostics = Some(CriticalityDiagnostics::decode(data)?),
                x => return Err(PerCodecError::new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        let amf_ue_ngap_id = amf_ue_ngap_id.ok_or(PerCodecError::new(format!(
            "Missing mandatory IE amf_ue_ngap_id"
        )))?;
        let ran_ue_ngap_id = ran_ue_ngap_id.ok_or(PerCodecError::new(format!(
            "Missing mandatory IE ran_ue_ngap_id"
        )))?;
        Ok(Self {
            amf_ue_ngap_id,
            ran_ue_ngap_id,
            rrc_state,
            user_location_information,
            criticality_diagnostics,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        let ie = &mut Allocator::new_codec_data();
        self.amf_ue_ngap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 10, false)?;
        Criticality::Ignore.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.ran_ue_ngap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 85, false)?;
        Criticality::Ignore.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        if let Some(x) = &self.rrc_state {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 92, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.user_location_information {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 121, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.criticality_diagnostics {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 19, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        encode::encode_sequence_header(data, true, &BitString::new(), false)?;
        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for UeContextModificationResponse {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        UeContextModificationResponse::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UeContextModificationResponse");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UeContextModificationResponse");
            e
        })
    }
}
// UeContextModificationFailure
#[derive(Clone, Debug)]
pub struct UeContextModificationFailure {
    pub amf_ue_ngap_id: AmfUeNgapId,
    pub ran_ue_ngap_id: RanUeNgapId,
    pub cause: Cause,
    pub criticality_diagnostics: Option<CriticalityDiagnostics>,
}

impl UeContextModificationFailure {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let _ = decode::decode_sequence_header(data, true, 0)?;
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut amf_ue_ngap_id: Option<AmfUeNgapId> = None;
        let mut ran_ue_ngap_id: Option<RanUeNgapId> = None;
        let mut cause: Option<Cause> = None;
        let mut criticality_diagnostics: Option<CriticalityDiagnostics> = None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                10 => amf_ue_ngap_id = Some(AmfUeNgapId::decode(data)?),
                85 => ran_ue_ngap_id = Some(RanUeNgapId::decode(data)?),
                15 => cause = Some(Cause::decode(data)?),
                19 => criticality_diagnostics = Some(CriticalityDiagnostics::decode(data)?),
                x => return Err(PerCodecError::new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        let amf_ue_ngap_id = amf_ue_ngap_id.ok_or(PerCodecError::new(format!(
            "Missing mandatory IE amf_ue_ngap_id"
        )))?;
        let ran_ue_ngap_id = ran_ue_ngap_id.ok_or(PerCodecError::new(format!(
            "Missing mandatory IE ran_ue_ngap_id"
        )))?;
        let cause = cause.ok_or(PerCodecError::new(format!("Missing mandatory IE cause")))?;
        Ok(Self {
            amf_ue_ngap_id,
            ran_ue_ngap_id,
            cause,
            criticality_diagnostics,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        let ie = &mut Allocator::new_codec_data();
        self.amf_ue_ngap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 10, false)?;
        Criticality::Ignore.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.ran_ue_ngap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 85, false)?;
        Criticality::Ignore.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.cause.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 15, false)?;
        Criticality::Ignore.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        if let Some(x) = &self.criticality_diagnostics {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 19, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        encode::encode_sequence_header(data, true, &BitString::new(), false)?;
        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for UeContextModificationFailure {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        UeContextModificationFailure::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UeContextModificationFailure");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UeContextModificationFailure");
            e
        })
    }
}
// RrcInactiveTransitionReport
#[derive(Clone, Debug)]
pub struct RrcInactiveTransitionReport {
    pub amf_ue_ngap_id: AmfUeNgapId,
    pub ran_ue_ngap_id: RanUeNgapId,
    pub rrc_state: RrcState,
    pub user_location_information: UserLocationInformation,
}

impl RrcInactiveTransitionReport {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let _ = decode::decode_sequence_header(data, true, 0)?;
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut amf_ue_ngap_id: Option<AmfUeNgapId> = None;
        let mut ran_ue_ngap_id: Option<RanUeNgapId> = None;
        let mut rrc_state: Option<RrcState> = None;
        let mut user_location_information: Option<UserLocationInformation> = None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                10 => amf_ue_ngap_id = Some(AmfUeNgapId::decode(data)?),
                85 => ran_ue_ngap_id = Some(RanUeNgapId::decode(data)?),
                92 => rrc_state = Some(RrcState::decode(data)?),
                121 => user_location_information = Some(UserLocationInformation::decode(data)?),
                x => return Err(PerCodecError::new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        let amf_ue_ngap_id = amf_ue_ngap_id.ok_or(PerCodecError::new(format!(
            "Missing mandatory IE amf_ue_ngap_id"
        )))?;
        let ran_ue_ngap_id = ran_ue_ngap_id.ok_or(PerCodecError::new(format!(
            "Missing mandatory IE ran_ue_ngap_id"
        )))?;
        let rrc_state = rrc_state.ok_or(PerCodecError::new(format!(
            "Missing mandatory IE rrc_state"
        )))?;
        let user_location_information = user_location_information.ok_or(PerCodecError::new(
            format!("Missing mandatory IE user_location_information"),
        ))?;
        Ok(Self {
            amf_ue_ngap_id,
            ran_ue_ngap_id,
            rrc_state,
            user_location_information,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        let ie = &mut Allocator::new_codec_data();
        self.amf_ue_ngap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 10, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.ran_ue_ngap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 85, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.rrc_state.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 92, false)?;
        Criticality::Ignore.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.user_location_information.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 121, false)?;
        Criticality::Ignore.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        encode::encode_sequence_header(data, true, &BitString::new(), false)?;
        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for RrcInactiveTransitionReport {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        RrcInactiveTransitionReport::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("RrcInactiveTransitionReport");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("RrcInactiveTransitionReport");
            e
        })
    }
}
// RetrieveUeInformation
#[derive(Clone, Debug)]
pub struct RetrieveUeInformation {
    pub five_g_s_tmsi: FiveGSTmsi,
}

impl RetrieveUeInformation {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let _ = decode::decode_sequence_header(data, true, 0)?;
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut five_g_s_tmsi: Option<FiveGSTmsi> = None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                26 => five_g_s_tmsi = Some(FiveGSTmsi::decode(data)?),
                x => return Err(PerCodecError::new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        let five_g_s_tmsi = five_g_s_tmsi.ok_or(PerCodecError::new(format!(
            "Missing mandatory IE five_g_s_tmsi"
        )))?;
        Ok(Self { five_g_s_tmsi })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        let ie = &mut Allocator::new_codec_data();
        self.five_g_s_tmsi.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 26, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        encode::encode_sequence_header(data, true, &BitString::new(), false)?;
        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for RetrieveUeInformation {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        RetrieveUeInformation::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("RetrieveUeInformation");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("RetrieveUeInformation");
            e
        })
    }
}
// UeInformationTransfer
#[derive(Clone, Debug)]
pub struct UeInformationTransfer {
    pub five_g_s_tmsi: FiveGSTmsi,
    pub nb_iot_ue_priority: Option<NbIotUePriority>,
    pub ue_radio_capability: Option<UeRadioCapability>,
    pub snssai: Option<Snssai>,
    pub allowed_nssai: Option<AllowedNssai>,
    pub ue_differentiation_info: Option<UeDifferentiationInfo>,
}

impl UeInformationTransfer {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let _ = decode::decode_sequence_header(data, true, 0)?;
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut five_g_s_tmsi: Option<FiveGSTmsi> = None;
        let mut nb_iot_ue_priority: Option<NbIotUePriority> = None;
        let mut ue_radio_capability: Option<UeRadioCapability> = None;
        let mut snssai: Option<Snssai> = None;
        let mut allowed_nssai: Option<AllowedNssai> = None;
        let mut ue_differentiation_info: Option<UeDifferentiationInfo> = None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                26 => five_g_s_tmsi = Some(FiveGSTmsi::decode(data)?),
                210 => nb_iot_ue_priority = Some(NbIotUePriority::decode(data)?),
                117 => ue_radio_capability = Some(UeRadioCapability::decode(data)?),
                148 => snssai = Some(Snssai::decode(data)?),
                0 => allowed_nssai = Some(AllowedNssai::decode(data)?),
                209 => ue_differentiation_info = Some(UeDifferentiationInfo::decode(data)?),
                x => return Err(PerCodecError::new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        let five_g_s_tmsi = five_g_s_tmsi.ok_or(PerCodecError::new(format!(
            "Missing mandatory IE five_g_s_tmsi"
        )))?;
        Ok(Self {
            five_g_s_tmsi,
            nb_iot_ue_priority,
            ue_radio_capability,
            snssai,
            allowed_nssai,
            ue_differentiation_info,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        let ie = &mut Allocator::new_codec_data();
        self.five_g_s_tmsi.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 26, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        if let Some(x) = &self.nb_iot_ue_priority {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 210, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.ue_radio_capability {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 117, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.snssai {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 148, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.allowed_nssai {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 0, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.ue_differentiation_info {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 209, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        encode::encode_sequence_header(data, true, &BitString::new(), false)?;
        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for UeInformationTransfer {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        UeInformationTransfer::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UeInformationTransfer");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UeInformationTransfer");
            e
        })
    }
}
// RancpRelocationIndication
#[derive(Clone, Debug)]
pub struct RancpRelocationIndication {
    pub ran_ue_ngap_id: RanUeNgapId,
    pub five_g_s_tmsi: FiveGSTmsi,
    pub eutra_cgi: EutraCgi,
    pub tai: Tai,
    pub ul_cp_security_information: UlCpSecurityInformation,
}

impl RancpRelocationIndication {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let _ = decode::decode_sequence_header(data, true, 0)?;
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut ran_ue_ngap_id: Option<RanUeNgapId> = None;
        let mut five_g_s_tmsi: Option<FiveGSTmsi> = None;
        let mut eutra_cgi: Option<EutraCgi> = None;
        let mut tai: Option<Tai> = None;
        let mut ul_cp_security_information: Option<UlCpSecurityInformation> = None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                85 => ran_ue_ngap_id = Some(RanUeNgapId::decode(data)?),
                26 => five_g_s_tmsi = Some(FiveGSTmsi::decode(data)?),
                25 => eutra_cgi = Some(EutraCgi::decode(data)?),
                213 => tai = Some(Tai::decode(data)?),
                211 => ul_cp_security_information = Some(UlCpSecurityInformation::decode(data)?),
                x => return Err(PerCodecError::new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        let ran_ue_ngap_id = ran_ue_ngap_id.ok_or(PerCodecError::new(format!(
            "Missing mandatory IE ran_ue_ngap_id"
        )))?;
        let five_g_s_tmsi = five_g_s_tmsi.ok_or(PerCodecError::new(format!(
            "Missing mandatory IE five_g_s_tmsi"
        )))?;
        let eutra_cgi = eutra_cgi.ok_or(PerCodecError::new(format!(
            "Missing mandatory IE eutra_cgi"
        )))?;
        let tai = tai.ok_or(PerCodecError::new(format!("Missing mandatory IE tai")))?;
        let ul_cp_security_information = ul_cp_security_information.ok_or(PerCodecError::new(
            format!("Missing mandatory IE ul_cp_security_information"),
        ))?;
        Ok(Self {
            ran_ue_ngap_id,
            five_g_s_tmsi,
            eutra_cgi,
            tai,
            ul_cp_security_information,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        let ie = &mut Allocator::new_codec_data();
        self.ran_ue_ngap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 85, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.five_g_s_tmsi.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 26, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.eutra_cgi.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 25, false)?;
        Criticality::Ignore.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.tai.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 213, false)?;
        Criticality::Ignore.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.ul_cp_security_information.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 211, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        encode::encode_sequence_header(data, true, &BitString::new(), false)?;
        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for RancpRelocationIndication {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        RancpRelocationIndication::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("RancpRelocationIndication");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("RancpRelocationIndication");
            e
        })
    }
}
// HandoverRequired
#[derive(Clone, Debug)]
pub struct HandoverRequired {
    pub amf_ue_ngap_id: AmfUeNgapId,
    pub ran_ue_ngap_id: RanUeNgapId,
    pub handover_type: HandoverType,
    pub cause: Cause,
    pub target_id: TargetId,
    pub direct_forwarding_path_availability: Option<DirectForwardingPathAvailability>,
    pub pdu_session_resource_list_ho_rqd: PduSessionResourceListHoRqd,
    pub source_to_target_transparent_container: SourceToTargetTransparentContainer,
}

impl HandoverRequired {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let _ = decode::decode_sequence_header(data, true, 0)?;
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut amf_ue_ngap_id: Option<AmfUeNgapId> = None;
        let mut ran_ue_ngap_id: Option<RanUeNgapId> = None;
        let mut handover_type: Option<HandoverType> = None;
        let mut cause: Option<Cause> = None;
        let mut target_id: Option<TargetId> = None;
        let mut direct_forwarding_path_availability: Option<DirectForwardingPathAvailability> =
            None;
        let mut pdu_session_resource_list_ho_rqd: Option<PduSessionResourceListHoRqd> = None;
        let mut source_to_target_transparent_container: Option<SourceToTargetTransparentContainer> =
            None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                10 => amf_ue_ngap_id = Some(AmfUeNgapId::decode(data)?),
                85 => ran_ue_ngap_id = Some(RanUeNgapId::decode(data)?),
                29 => handover_type = Some(HandoverType::decode(data)?),
                15 => cause = Some(Cause::decode(data)?),
                105 => target_id = Some(TargetId::decode(data)?),
                22 => {
                    direct_forwarding_path_availability =
                        Some(DirectForwardingPathAvailability::decode(data)?)
                }
                61 => {
                    pdu_session_resource_list_ho_rqd =
                        Some(PduSessionResourceListHoRqd::decode(data)?)
                }
                101 => {
                    source_to_target_transparent_container =
                        Some(SourceToTargetTransparentContainer::decode(data)?)
                }
                x => return Err(PerCodecError::new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        let amf_ue_ngap_id = amf_ue_ngap_id.ok_or(PerCodecError::new(format!(
            "Missing mandatory IE amf_ue_ngap_id"
        )))?;
        let ran_ue_ngap_id = ran_ue_ngap_id.ok_or(PerCodecError::new(format!(
            "Missing mandatory IE ran_ue_ngap_id"
        )))?;
        let handover_type = handover_type.ok_or(PerCodecError::new(format!(
            "Missing mandatory IE handover_type"
        )))?;
        let cause = cause.ok_or(PerCodecError::new(format!("Missing mandatory IE cause")))?;
        let target_id = target_id.ok_or(PerCodecError::new(format!(
            "Missing mandatory IE target_id"
        )))?;
        let pdu_session_resource_list_ho_rqd =
            pdu_session_resource_list_ho_rqd.ok_or(PerCodecError::new(format!(
                "Missing mandatory IE pdu_session_resource_list_ho_rqd"
            )))?;
        let source_to_target_transparent_container =
            source_to_target_transparent_container.ok_or(PerCodecError::new(format!(
                "Missing mandatory IE source_to_target_transparent_container"
            )))?;
        Ok(Self {
            amf_ue_ngap_id,
            ran_ue_ngap_id,
            handover_type,
            cause,
            target_id,
            direct_forwarding_path_availability,
            pdu_session_resource_list_ho_rqd,
            source_to_target_transparent_container,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        let ie = &mut Allocator::new_codec_data();
        self.amf_ue_ngap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 10, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.ran_ue_ngap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 85, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.handover_type.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 29, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.cause.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 15, false)?;
        Criticality::Ignore.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.target_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 105, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        if let Some(x) = &self.direct_forwarding_path_availability {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 22, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        let ie = &mut Allocator::new_codec_data();
        self.pdu_session_resource_list_ho_rqd.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 61, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.source_to_target_transparent_container.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 101, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        encode::encode_sequence_header(data, true, &BitString::new(), false)?;
        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for HandoverRequired {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        HandoverRequired::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("HandoverRequired");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("HandoverRequired");
            e
        })
    }
}
// HandoverCommand
#[derive(Clone, Debug)]
pub struct HandoverCommand {
    pub amf_ue_ngap_id: AmfUeNgapId,
    pub ran_ue_ngap_id: RanUeNgapId,
    pub handover_type: HandoverType,
    pub nas_security_parameters_from_ngran: Option<NasSecurityParametersFromNgran>,
    pub pdu_session_resource_handover_list: Option<PduSessionResourceHandoverList>,
    pub pdu_session_resource_to_release_list_ho_cmd: Option<PduSessionResourceToReleaseListHoCmd>,
    pub target_to_source_transparent_container: TargetToSourceTransparentContainer,
    pub criticality_diagnostics: Option<CriticalityDiagnostics>,
}

impl HandoverCommand {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let _ = decode::decode_sequence_header(data, true, 0)?;
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut amf_ue_ngap_id: Option<AmfUeNgapId> = None;
        let mut ran_ue_ngap_id: Option<RanUeNgapId> = None;
        let mut handover_type: Option<HandoverType> = None;
        let mut nas_security_parameters_from_ngran: Option<NasSecurityParametersFromNgran> = None;
        let mut pdu_session_resource_handover_list: Option<PduSessionResourceHandoverList> = None;
        let mut pdu_session_resource_to_release_list_ho_cmd: Option<
            PduSessionResourceToReleaseListHoCmd,
        > = None;
        let mut target_to_source_transparent_container: Option<TargetToSourceTransparentContainer> =
            None;
        let mut criticality_diagnostics: Option<CriticalityDiagnostics> = None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                10 => amf_ue_ngap_id = Some(AmfUeNgapId::decode(data)?),
                85 => ran_ue_ngap_id = Some(RanUeNgapId::decode(data)?),
                29 => handover_type = Some(HandoverType::decode(data)?),
                39 => {
                    nas_security_parameters_from_ngran =
                        Some(NasSecurityParametersFromNgran::decode(data)?)
                }
                59 => {
                    pdu_session_resource_handover_list =
                        Some(PduSessionResourceHandoverList::decode(data)?)
                }
                78 => {
                    pdu_session_resource_to_release_list_ho_cmd =
                        Some(PduSessionResourceToReleaseListHoCmd::decode(data)?)
                }
                106 => {
                    target_to_source_transparent_container =
                        Some(TargetToSourceTransparentContainer::decode(data)?)
                }
                19 => criticality_diagnostics = Some(CriticalityDiagnostics::decode(data)?),
                x => return Err(PerCodecError::new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        let amf_ue_ngap_id = amf_ue_ngap_id.ok_or(PerCodecError::new(format!(
            "Missing mandatory IE amf_ue_ngap_id"
        )))?;
        let ran_ue_ngap_id = ran_ue_ngap_id.ok_or(PerCodecError::new(format!(
            "Missing mandatory IE ran_ue_ngap_id"
        )))?;
        let handover_type = handover_type.ok_or(PerCodecError::new(format!(
            "Missing mandatory IE handover_type"
        )))?;
        let target_to_source_transparent_container =
            target_to_source_transparent_container.ok_or(PerCodecError::new(format!(
                "Missing mandatory IE target_to_source_transparent_container"
            )))?;
        Ok(Self {
            amf_ue_ngap_id,
            ran_ue_ngap_id,
            handover_type,
            nas_security_parameters_from_ngran,
            pdu_session_resource_handover_list,
            pdu_session_resource_to_release_list_ho_cmd,
            target_to_source_transparent_container,
            criticality_diagnostics,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        let ie = &mut Allocator::new_codec_data();
        self.amf_ue_ngap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 10, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.ran_ue_ngap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 85, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.handover_type.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 29, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        if let Some(x) = &self.nas_security_parameters_from_ngran {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 39, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.pdu_session_resource_handover_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 59, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.pdu_session_resource_to_release_list_ho_cmd {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 78, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        let ie = &mut Allocator::new_codec_data();
        self.target_to_source_transparent_container.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 106, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        if let Some(x) = &self.criticality_diagnostics {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 19, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        encode::encode_sequence_header(data, true, &BitString::new(), false)?;
        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for HandoverCommand {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        HandoverCommand::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("HandoverCommand");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("HandoverCommand");
            e
        })
    }
}
// HandoverPreparationFailure
#[derive(Clone, Debug)]
pub struct HandoverPreparationFailure {
    pub amf_ue_ngap_id: AmfUeNgapId,
    pub ran_ue_ngap_id: RanUeNgapId,
    pub cause: Cause,
    pub criticality_diagnostics: Option<CriticalityDiagnostics>,
    pub targetto_source_failure_transparent_container:
        Option<TargettoSourceFailureTransparentContainer>,
}

impl HandoverPreparationFailure {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let _ = decode::decode_sequence_header(data, true, 0)?;
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut amf_ue_ngap_id: Option<AmfUeNgapId> = None;
        let mut ran_ue_ngap_id: Option<RanUeNgapId> = None;
        let mut cause: Option<Cause> = None;
        let mut criticality_diagnostics: Option<CriticalityDiagnostics> = None;
        let mut targetto_source_failure_transparent_container: Option<
            TargettoSourceFailureTransparentContainer,
        > = None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                10 => amf_ue_ngap_id = Some(AmfUeNgapId::decode(data)?),
                85 => ran_ue_ngap_id = Some(RanUeNgapId::decode(data)?),
                15 => cause = Some(Cause::decode(data)?),
                19 => criticality_diagnostics = Some(CriticalityDiagnostics::decode(data)?),
                262 => {
                    targetto_source_failure_transparent_container =
                        Some(TargettoSourceFailureTransparentContainer::decode(data)?)
                }
                x => return Err(PerCodecError::new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        let amf_ue_ngap_id = amf_ue_ngap_id.ok_or(PerCodecError::new(format!(
            "Missing mandatory IE amf_ue_ngap_id"
        )))?;
        let ran_ue_ngap_id = ran_ue_ngap_id.ok_or(PerCodecError::new(format!(
            "Missing mandatory IE ran_ue_ngap_id"
        )))?;
        let cause = cause.ok_or(PerCodecError::new(format!("Missing mandatory IE cause")))?;
        Ok(Self {
            amf_ue_ngap_id,
            ran_ue_ngap_id,
            cause,
            criticality_diagnostics,
            targetto_source_failure_transparent_container,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        let ie = &mut Allocator::new_codec_data();
        self.amf_ue_ngap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 10, false)?;
        Criticality::Ignore.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.ran_ue_ngap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 85, false)?;
        Criticality::Ignore.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.cause.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 15, false)?;
        Criticality::Ignore.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        if let Some(x) = &self.criticality_diagnostics {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 19, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.targetto_source_failure_transparent_container {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 262, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        encode::encode_sequence_header(data, true, &BitString::new(), false)?;
        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for HandoverPreparationFailure {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        HandoverPreparationFailure::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("HandoverPreparationFailure");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("HandoverPreparationFailure");
            e
        })
    }
}
// HandoverRequest
#[derive(Clone, Debug)]
pub struct HandoverRequest {
    pub amf_ue_ngap_id: AmfUeNgapId,
    pub handover_type: HandoverType,
    pub cause: Cause,
    pub ue_aggregate_maximum_bit_rate: UeAggregateMaximumBitRate,
    pub core_network_assistance_information_for_inactive:
        Option<CoreNetworkAssistanceInformationForInactive>,
    pub ue_security_capabilities: UeSecurityCapabilities,
    pub security_context: SecurityContext,
    pub new_security_context_ind: Option<NewSecurityContextInd>,
    pub nasc: Option<NasPdu>,
    pub pdu_session_resource_setup_list_ho_req: PduSessionResourceSetupListHoReq,
    pub allowed_nssai: AllowedNssai,
    pub trace_activation: Option<TraceActivation>,
    pub masked_imeisv: Option<MaskedImeisv>,
    pub source_to_target_transparent_container: SourceToTargetTransparentContainer,
    pub mobility_restriction_list: Option<MobilityRestrictionList>,
    pub location_reporting_request_type: Option<LocationReportingRequestType>,
    pub rrc_inactive_transition_report_request: Option<RrcInactiveTransitionReportRequest>,
    pub guami: Guami,
    pub redirection_voice_fallback: Option<RedirectionVoiceFallback>,
    pub cn_assisted_ran_tuning: Option<CnAssistedRanTuning>,
    pub srvcc_operation_possible: Option<SrvccOperationPossible>,
    pub iab_authorized: Option<IabAuthorized>,
    pub enhanced_coverage_restriction: Option<EnhancedCoverageRestriction>,
    pub ue_differentiation_info: Option<UeDifferentiationInfo>,
    pub nr_v2x_services_authorized: Option<NrV2xServicesAuthorized>,
    pub ltev2x_services_authorized: Option<Ltev2xServicesAuthorized>,
    pub nr_ue_sidelink_aggregate_maximum_bitrate: Option<NrUeSidelinkAggregateMaximumBitrate>,
    pub lte_ue_sidelink_aggregate_maximum_bitrate: Option<LteUeSidelinkAggregateMaximumBitrate>,
    pub pc5_qos_parameters: Option<Pc5QosParameters>,
    pub c_emode_brestricted: Option<CEmodeBrestricted>,
    pub ue_up_c_iot_support: Option<UeUpCIotSupport>,
    pub management_based_mdt_plmn_list: Option<MdtPlmnList>,
    pub ue_radio_capability_id: Option<UeRadioCapabilityId>,
    pub extended_connected_time: Option<ExtendedConnectedTime>,
}

impl HandoverRequest {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let _ = decode::decode_sequence_header(data, true, 0)?;
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut amf_ue_ngap_id: Option<AmfUeNgapId> = None;
        let mut handover_type: Option<HandoverType> = None;
        let mut cause: Option<Cause> = None;
        let mut ue_aggregate_maximum_bit_rate: Option<UeAggregateMaximumBitRate> = None;
        let mut core_network_assistance_information_for_inactive: Option<
            CoreNetworkAssistanceInformationForInactive,
        > = None;
        let mut ue_security_capabilities: Option<UeSecurityCapabilities> = None;
        let mut security_context: Option<SecurityContext> = None;
        let mut new_security_context_ind: Option<NewSecurityContextInd> = None;
        let mut nasc: Option<NasPdu> = None;
        let mut pdu_session_resource_setup_list_ho_req: Option<PduSessionResourceSetupListHoReq> =
            None;
        let mut allowed_nssai: Option<AllowedNssai> = None;
        let mut trace_activation: Option<TraceActivation> = None;
        let mut masked_imeisv: Option<MaskedImeisv> = None;
        let mut source_to_target_transparent_container: Option<SourceToTargetTransparentContainer> =
            None;
        let mut mobility_restriction_list: Option<MobilityRestrictionList> = None;
        let mut location_reporting_request_type: Option<LocationReportingRequestType> = None;
        let mut rrc_inactive_transition_report_request: Option<RrcInactiveTransitionReportRequest> =
            None;
        let mut guami: Option<Guami> = None;
        let mut redirection_voice_fallback: Option<RedirectionVoiceFallback> = None;
        let mut cn_assisted_ran_tuning: Option<CnAssistedRanTuning> = None;
        let mut srvcc_operation_possible: Option<SrvccOperationPossible> = None;
        let mut iab_authorized: Option<IabAuthorized> = None;
        let mut enhanced_coverage_restriction: Option<EnhancedCoverageRestriction> = None;
        let mut ue_differentiation_info: Option<UeDifferentiationInfo> = None;
        let mut nr_v2x_services_authorized: Option<NrV2xServicesAuthorized> = None;
        let mut ltev2x_services_authorized: Option<Ltev2xServicesAuthorized> = None;
        let mut nr_ue_sidelink_aggregate_maximum_bitrate: Option<
            NrUeSidelinkAggregateMaximumBitrate,
        > = None;
        let mut lte_ue_sidelink_aggregate_maximum_bitrate: Option<
            LteUeSidelinkAggregateMaximumBitrate,
        > = None;
        let mut pc5_qos_parameters: Option<Pc5QosParameters> = None;
        let mut c_emode_brestricted: Option<CEmodeBrestricted> = None;
        let mut ue_up_c_iot_support: Option<UeUpCIotSupport> = None;
        let mut management_based_mdt_plmn_list: Option<MdtPlmnList> = None;
        let mut ue_radio_capability_id: Option<UeRadioCapabilityId> = None;
        let mut extended_connected_time: Option<ExtendedConnectedTime> = None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                10 => amf_ue_ngap_id = Some(AmfUeNgapId::decode(data)?),
                29 => handover_type = Some(HandoverType::decode(data)?),
                15 => cause = Some(Cause::decode(data)?),
                110 => {
                    ue_aggregate_maximum_bit_rate = Some(UeAggregateMaximumBitRate::decode(data)?)
                }
                18 => {
                    core_network_assistance_information_for_inactive =
                        Some(CoreNetworkAssistanceInformationForInactive::decode(data)?)
                }
                119 => ue_security_capabilities = Some(UeSecurityCapabilities::decode(data)?),
                93 => security_context = Some(SecurityContext::decode(data)?),
                41 => new_security_context_ind = Some(NewSecurityContextInd::decode(data)?),
                37 => nasc = Some(NasPdu::decode(data)?),
                73 => {
                    pdu_session_resource_setup_list_ho_req =
                        Some(PduSessionResourceSetupListHoReq::decode(data)?)
                }
                0 => allowed_nssai = Some(AllowedNssai::decode(data)?),
                108 => trace_activation = Some(TraceActivation::decode(data)?),
                34 => masked_imeisv = Some(MaskedImeisv::decode(data)?),
                101 => {
                    source_to_target_transparent_container =
                        Some(SourceToTargetTransparentContainer::decode(data)?)
                }
                36 => mobility_restriction_list = Some(MobilityRestrictionList::decode(data)?),
                33 => {
                    location_reporting_request_type =
                        Some(LocationReportingRequestType::decode(data)?)
                }
                91 => {
                    rrc_inactive_transition_report_request =
                        Some(RrcInactiveTransitionReportRequest::decode(data)?)
                }
                28 => guami = Some(Guami::decode(data)?),
                146 => redirection_voice_fallback = Some(RedirectionVoiceFallback::decode(data)?),
                165 => cn_assisted_ran_tuning = Some(CnAssistedRanTuning::decode(data)?),
                177 => srvcc_operation_possible = Some(SrvccOperationPossible::decode(data)?),
                199 => iab_authorized = Some(IabAuthorized::decode(data)?),
                205 => {
                    enhanced_coverage_restriction = Some(EnhancedCoverageRestriction::decode(data)?)
                }
                209 => ue_differentiation_info = Some(UeDifferentiationInfo::decode(data)?),
                216 => nr_v2x_services_authorized = Some(NrV2xServicesAuthorized::decode(data)?),
                215 => ltev2x_services_authorized = Some(Ltev2xServicesAuthorized::decode(data)?),
                218 => {
                    nr_ue_sidelink_aggregate_maximum_bitrate =
                        Some(NrUeSidelinkAggregateMaximumBitrate::decode(data)?)
                }
                217 => {
                    lte_ue_sidelink_aggregate_maximum_bitrate =
                        Some(LteUeSidelinkAggregateMaximumBitrate::decode(data)?)
                }
                219 => pc5_qos_parameters = Some(Pc5QosParameters::decode(data)?),
                222 => c_emode_brestricted = Some(CEmodeBrestricted::decode(data)?),
                234 => ue_up_c_iot_support = Some(UeUpCIotSupport::decode(data)?),
                254 => management_based_mdt_plmn_list = Some(MdtPlmnList::decode(data)?),
                264 => ue_radio_capability_id = Some(UeRadioCapabilityId::decode(data)?),
                206 => extended_connected_time = Some(ExtendedConnectedTime::decode(data)?),
                x => return Err(PerCodecError::new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        let amf_ue_ngap_id = amf_ue_ngap_id.ok_or(PerCodecError::new(format!(
            "Missing mandatory IE amf_ue_ngap_id"
        )))?;
        let handover_type = handover_type.ok_or(PerCodecError::new(format!(
            "Missing mandatory IE handover_type"
        )))?;
        let cause = cause.ok_or(PerCodecError::new(format!("Missing mandatory IE cause")))?;
        let ue_aggregate_maximum_bit_rate =
            ue_aggregate_maximum_bit_rate.ok_or(PerCodecError::new(format!(
                "Missing mandatory IE ue_aggregate_maximum_bit_rate"
            )))?;
        let ue_security_capabilities = ue_security_capabilities.ok_or(PerCodecError::new(
            format!("Missing mandatory IE ue_security_capabilities"),
        ))?;
        let security_context = security_context.ok_or(PerCodecError::new(format!(
            "Missing mandatory IE security_context"
        )))?;
        let pdu_session_resource_setup_list_ho_req =
            pdu_session_resource_setup_list_ho_req.ok_or(PerCodecError::new(format!(
                "Missing mandatory IE pdu_session_resource_setup_list_ho_req"
            )))?;
        let allowed_nssai = allowed_nssai.ok_or(PerCodecError::new(format!(
            "Missing mandatory IE allowed_nssai"
        )))?;
        let source_to_target_transparent_container =
            source_to_target_transparent_container.ok_or(PerCodecError::new(format!(
                "Missing mandatory IE source_to_target_transparent_container"
            )))?;
        let guami = guami.ok_or(PerCodecError::new(format!("Missing mandatory IE guami")))?;
        Ok(Self {
            amf_ue_ngap_id,
            handover_type,
            cause,
            ue_aggregate_maximum_bit_rate,
            core_network_assistance_information_for_inactive,
            ue_security_capabilities,
            security_context,
            new_security_context_ind,
            nasc,
            pdu_session_resource_setup_list_ho_req,
            allowed_nssai,
            trace_activation,
            masked_imeisv,
            source_to_target_transparent_container,
            mobility_restriction_list,
            location_reporting_request_type,
            rrc_inactive_transition_report_request,
            guami,
            redirection_voice_fallback,
            cn_assisted_ran_tuning,
            srvcc_operation_possible,
            iab_authorized,
            enhanced_coverage_restriction,
            ue_differentiation_info,
            nr_v2x_services_authorized,
            ltev2x_services_authorized,
            nr_ue_sidelink_aggregate_maximum_bitrate,
            lte_ue_sidelink_aggregate_maximum_bitrate,
            pc5_qos_parameters,
            c_emode_brestricted,
            ue_up_c_iot_support,
            management_based_mdt_plmn_list,
            ue_radio_capability_id,
            extended_connected_time,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        let ie = &mut Allocator::new_codec_data();
        self.amf_ue_ngap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 10, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.handover_type.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 29, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.cause.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 15, false)?;
        Criticality::Ignore.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.ue_aggregate_maximum_bit_rate.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 110, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        if let Some(x) = &self.core_network_assistance_information_for_inactive {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 18, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        let ie = &mut Allocator::new_codec_data();
        self.ue_security_capabilities.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 119, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.security_context.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 93, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        if let Some(x) = &self.new_security_context_ind {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 41, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.nasc {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 37, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        let ie = &mut Allocator::new_codec_data();
        self.pdu_session_resource_setup_list_ho_req.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 73, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.allowed_nssai.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 0, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        if let Some(x) = &self.trace_activation {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 108, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.masked_imeisv {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 34, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        let ie = &mut Allocator::new_codec_data();
        self.source_to_target_transparent_container.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 101, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        if let Some(x) = &self.mobility_restriction_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 36, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.location_reporting_request_type {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 33, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.rrc_inactive_transition_report_request {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 91, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        let ie = &mut Allocator::new_codec_data();
        self.guami.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 28, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        if let Some(x) = &self.redirection_voice_fallback {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 146, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.cn_assisted_ran_tuning {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 165, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.srvcc_operation_possible {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 177, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.iab_authorized {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 199, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.enhanced_coverage_restriction {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 205, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.ue_differentiation_info {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 209, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.nr_v2x_services_authorized {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 216, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.ltev2x_services_authorized {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 215, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.nr_ue_sidelink_aggregate_maximum_bitrate {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 218, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.lte_ue_sidelink_aggregate_maximum_bitrate {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 217, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.pc5_qos_parameters {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 219, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.c_emode_brestricted {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 222, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.ue_up_c_iot_support {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 234, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.management_based_mdt_plmn_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 254, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.ue_radio_capability_id {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 264, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.extended_connected_time {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 206, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        encode::encode_sequence_header(data, true, &BitString::new(), false)?;
        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for HandoverRequest {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        HandoverRequest::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("HandoverRequest");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("HandoverRequest");
            e
        })
    }
}
// HandoverRequestAcknowledge
#[derive(Clone, Debug)]
pub struct HandoverRequestAcknowledge {
    pub amf_ue_ngap_id: AmfUeNgapId,
    pub ran_ue_ngap_id: RanUeNgapId,
    pub pdu_session_resource_admitted_list: PduSessionResourceAdmittedList,
    pub pdu_session_resource_failed_to_setup_list_ho_ack:
        Option<PduSessionResourceFailedToSetupListHoAck>,
    pub target_to_source_transparent_container: TargetToSourceTransparentContainer,
    pub criticality_diagnostics: Option<CriticalityDiagnostics>,
}

impl HandoverRequestAcknowledge {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let _ = decode::decode_sequence_header(data, true, 0)?;
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut amf_ue_ngap_id: Option<AmfUeNgapId> = None;
        let mut ran_ue_ngap_id: Option<RanUeNgapId> = None;
        let mut pdu_session_resource_admitted_list: Option<PduSessionResourceAdmittedList> = None;
        let mut pdu_session_resource_failed_to_setup_list_ho_ack: Option<
            PduSessionResourceFailedToSetupListHoAck,
        > = None;
        let mut target_to_source_transparent_container: Option<TargetToSourceTransparentContainer> =
            None;
        let mut criticality_diagnostics: Option<CriticalityDiagnostics> = None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                10 => amf_ue_ngap_id = Some(AmfUeNgapId::decode(data)?),
                85 => ran_ue_ngap_id = Some(RanUeNgapId::decode(data)?),
                53 => {
                    pdu_session_resource_admitted_list =
                        Some(PduSessionResourceAdmittedList::decode(data)?)
                }
                56 => {
                    pdu_session_resource_failed_to_setup_list_ho_ack =
                        Some(PduSessionResourceFailedToSetupListHoAck::decode(data)?)
                }
                106 => {
                    target_to_source_transparent_container =
                        Some(TargetToSourceTransparentContainer::decode(data)?)
                }
                19 => criticality_diagnostics = Some(CriticalityDiagnostics::decode(data)?),
                x => return Err(PerCodecError::new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        let amf_ue_ngap_id = amf_ue_ngap_id.ok_or(PerCodecError::new(format!(
            "Missing mandatory IE amf_ue_ngap_id"
        )))?;
        let ran_ue_ngap_id = ran_ue_ngap_id.ok_or(PerCodecError::new(format!(
            "Missing mandatory IE ran_ue_ngap_id"
        )))?;
        let pdu_session_resource_admitted_list =
            pdu_session_resource_admitted_list.ok_or(PerCodecError::new(format!(
                "Missing mandatory IE pdu_session_resource_admitted_list"
            )))?;
        let target_to_source_transparent_container =
            target_to_source_transparent_container.ok_or(PerCodecError::new(format!(
                "Missing mandatory IE target_to_source_transparent_container"
            )))?;
        Ok(Self {
            amf_ue_ngap_id,
            ran_ue_ngap_id,
            pdu_session_resource_admitted_list,
            pdu_session_resource_failed_to_setup_list_ho_ack,
            target_to_source_transparent_container,
            criticality_diagnostics,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        let ie = &mut Allocator::new_codec_data();
        self.amf_ue_ngap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 10, false)?;
        Criticality::Ignore.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.ran_ue_ngap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 85, false)?;
        Criticality::Ignore.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.pdu_session_resource_admitted_list.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 53, false)?;
        Criticality::Ignore.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        if let Some(x) = &self.pdu_session_resource_failed_to_setup_list_ho_ack {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 56, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        let ie = &mut Allocator::new_codec_data();
        self.target_to_source_transparent_container.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 106, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        if let Some(x) = &self.criticality_diagnostics {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 19, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        encode::encode_sequence_header(data, true, &BitString::new(), false)?;
        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for HandoverRequestAcknowledge {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        HandoverRequestAcknowledge::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("HandoverRequestAcknowledge");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("HandoverRequestAcknowledge");
            e
        })
    }
}
// HandoverFailure
#[derive(Clone, Debug)]
pub struct HandoverFailure {
    pub amf_ue_ngap_id: AmfUeNgapId,
    pub cause: Cause,
    pub criticality_diagnostics: Option<CriticalityDiagnostics>,
    pub targetto_source_failure_transparent_container:
        Option<TargettoSourceFailureTransparentContainer>,
}

impl HandoverFailure {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let _ = decode::decode_sequence_header(data, true, 0)?;
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut amf_ue_ngap_id: Option<AmfUeNgapId> = None;
        let mut cause: Option<Cause> = None;
        let mut criticality_diagnostics: Option<CriticalityDiagnostics> = None;
        let mut targetto_source_failure_transparent_container: Option<
            TargettoSourceFailureTransparentContainer,
        > = None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                10 => amf_ue_ngap_id = Some(AmfUeNgapId::decode(data)?),
                15 => cause = Some(Cause::decode(data)?),
                19 => criticality_diagnostics = Some(CriticalityDiagnostics::decode(data)?),
                262 => {
                    targetto_source_failure_transparent_container =
                        Some(TargettoSourceFailureTransparentContainer::decode(data)?)
                }
                x => return Err(PerCodecError::new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        let amf_ue_ngap_id = amf_ue_ngap_id.ok_or(PerCodecError::new(format!(
            "Missing mandatory IE amf_ue_ngap_id"
        )))?;
        let cause = cause.ok_or(PerCodecError::new(format!("Missing mandatory IE cause")))?;
        Ok(Self {
            amf_ue_ngap_id,
            cause,
            criticality_diagnostics,
            targetto_source_failure_transparent_container,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        let ie = &mut Allocator::new_codec_data();
        self.amf_ue_ngap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 10, false)?;
        Criticality::Ignore.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.cause.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 15, false)?;
        Criticality::Ignore.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        if let Some(x) = &self.criticality_diagnostics {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 19, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.targetto_source_failure_transparent_container {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 262, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        encode::encode_sequence_header(data, true, &BitString::new(), false)?;
        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for HandoverFailure {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        HandoverFailure::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("HandoverFailure");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("HandoverFailure");
            e
        })
    }
}
// HandoverNotify
#[derive(Clone, Debug)]
pub struct HandoverNotify {
    pub amf_ue_ngap_id: AmfUeNgapId,
    pub ran_ue_ngap_id: RanUeNgapId,
    pub user_location_information: UserLocationInformation,
    pub notify_source_ngran_node: Option<NotifySourceNgranNode>,
}

impl HandoverNotify {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let _ = decode::decode_sequence_header(data, true, 0)?;
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut amf_ue_ngap_id: Option<AmfUeNgapId> = None;
        let mut ran_ue_ngap_id: Option<RanUeNgapId> = None;
        let mut user_location_information: Option<UserLocationInformation> = None;
        let mut notify_source_ngran_node: Option<NotifySourceNgranNode> = None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                10 => amf_ue_ngap_id = Some(AmfUeNgapId::decode(data)?),
                85 => ran_ue_ngap_id = Some(RanUeNgapId::decode(data)?),
                121 => user_location_information = Some(UserLocationInformation::decode(data)?),
                269 => notify_source_ngran_node = Some(NotifySourceNgranNode::decode(data)?),
                x => return Err(PerCodecError::new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        let amf_ue_ngap_id = amf_ue_ngap_id.ok_or(PerCodecError::new(format!(
            "Missing mandatory IE amf_ue_ngap_id"
        )))?;
        let ran_ue_ngap_id = ran_ue_ngap_id.ok_or(PerCodecError::new(format!(
            "Missing mandatory IE ran_ue_ngap_id"
        )))?;
        let user_location_information = user_location_information.ok_or(PerCodecError::new(
            format!("Missing mandatory IE user_location_information"),
        ))?;
        Ok(Self {
            amf_ue_ngap_id,
            ran_ue_ngap_id,
            user_location_information,
            notify_source_ngran_node,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        let ie = &mut Allocator::new_codec_data();
        self.amf_ue_ngap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 10, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.ran_ue_ngap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 85, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.user_location_information.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 121, false)?;
        Criticality::Ignore.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        if let Some(x) = &self.notify_source_ngran_node {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 269, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        encode::encode_sequence_header(data, true, &BitString::new(), false)?;
        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for HandoverNotify {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        HandoverNotify::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("HandoverNotify");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("HandoverNotify");
            e
        })
    }
}
// PathSwitchRequest
#[derive(Clone, Debug)]
pub struct PathSwitchRequest {
    pub ran_ue_ngap_id: RanUeNgapId,
    pub source_amf_ue_ngap_id: AmfUeNgapId,
    pub user_location_information: UserLocationInformation,
    pub ue_security_capabilities: UeSecurityCapabilities,
    pub pdu_session_resource_to_be_switched_dl_list: PduSessionResourceToBeSwitchedDlList,
    pub pdu_session_resource_failed_to_setup_list_ps_req:
        Option<PduSessionResourceFailedToSetupListPsReq>,
    pub rrc_resume_cause: Option<RrcEstablishmentCause>,
}

impl PathSwitchRequest {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let _ = decode::decode_sequence_header(data, true, 0)?;
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut ran_ue_ngap_id: Option<RanUeNgapId> = None;
        let mut source_amf_ue_ngap_id: Option<AmfUeNgapId> = None;
        let mut user_location_information: Option<UserLocationInformation> = None;
        let mut ue_security_capabilities: Option<UeSecurityCapabilities> = None;
        let mut pdu_session_resource_to_be_switched_dl_list: Option<
            PduSessionResourceToBeSwitchedDlList,
        > = None;
        let mut pdu_session_resource_failed_to_setup_list_ps_req: Option<
            PduSessionResourceFailedToSetupListPsReq,
        > = None;
        let mut rrc_resume_cause: Option<RrcEstablishmentCause> = None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                85 => ran_ue_ngap_id = Some(RanUeNgapId::decode(data)?),
                100 => source_amf_ue_ngap_id = Some(AmfUeNgapId::decode(data)?),
                121 => user_location_information = Some(UserLocationInformation::decode(data)?),
                119 => ue_security_capabilities = Some(UeSecurityCapabilities::decode(data)?),
                76 => {
                    pdu_session_resource_to_be_switched_dl_list =
                        Some(PduSessionResourceToBeSwitchedDlList::decode(data)?)
                }
                57 => {
                    pdu_session_resource_failed_to_setup_list_ps_req =
                        Some(PduSessionResourceFailedToSetupListPsReq::decode(data)?)
                }
                237 => rrc_resume_cause = Some(RrcEstablishmentCause::decode(data)?),
                x => return Err(PerCodecError::new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        let ran_ue_ngap_id = ran_ue_ngap_id.ok_or(PerCodecError::new(format!(
            "Missing mandatory IE ran_ue_ngap_id"
        )))?;
        let source_amf_ue_ngap_id = source_amf_ue_ngap_id.ok_or(PerCodecError::new(format!(
            "Missing mandatory IE source_amf_ue_ngap_id"
        )))?;
        let user_location_information = user_location_information.ok_or(PerCodecError::new(
            format!("Missing mandatory IE user_location_information"),
        ))?;
        let ue_security_capabilities = ue_security_capabilities.ok_or(PerCodecError::new(
            format!("Missing mandatory IE ue_security_capabilities"),
        ))?;
        let pdu_session_resource_to_be_switched_dl_list =
            pdu_session_resource_to_be_switched_dl_list.ok_or(PerCodecError::new(format!(
                "Missing mandatory IE pdu_session_resource_to_be_switched_dl_list"
            )))?;
        Ok(Self {
            ran_ue_ngap_id,
            source_amf_ue_ngap_id,
            user_location_information,
            ue_security_capabilities,
            pdu_session_resource_to_be_switched_dl_list,
            pdu_session_resource_failed_to_setup_list_ps_req,
            rrc_resume_cause,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        let ie = &mut Allocator::new_codec_data();
        self.ran_ue_ngap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 85, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.source_amf_ue_ngap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 100, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.user_location_information.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 121, false)?;
        Criticality::Ignore.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.ue_security_capabilities.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 119, false)?;
        Criticality::Ignore.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.pdu_session_resource_to_be_switched_dl_list
            .encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 76, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        if let Some(x) = &self.pdu_session_resource_failed_to_setup_list_ps_req {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 57, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.rrc_resume_cause {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 237, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        encode::encode_sequence_header(data, true, &BitString::new(), false)?;
        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for PathSwitchRequest {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PathSwitchRequest::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PathSwitchRequest");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PathSwitchRequest");
            e
        })
    }
}
// PathSwitchRequestAcknowledge
#[derive(Clone, Debug)]
pub struct PathSwitchRequestAcknowledge {
    pub amf_ue_ngap_id: AmfUeNgapId,
    pub ran_ue_ngap_id: RanUeNgapId,
    pub ue_security_capabilities: Option<UeSecurityCapabilities>,
    pub security_context: SecurityContext,
    pub new_security_context_ind: Option<NewSecurityContextInd>,
    pub pdu_session_resource_switched_list: PduSessionResourceSwitchedList,
    pub pdu_session_resource_released_list_ps_ack: Option<PduSessionResourceReleasedListPsAck>,
    pub allowed_nssai: AllowedNssai,
    pub core_network_assistance_information_for_inactive:
        Option<CoreNetworkAssistanceInformationForInactive>,
    pub rrc_inactive_transition_report_request: Option<RrcInactiveTransitionReportRequest>,
    pub criticality_diagnostics: Option<CriticalityDiagnostics>,
    pub redirection_voice_fallback: Option<RedirectionVoiceFallback>,
    pub cn_assisted_ran_tuning: Option<CnAssistedRanTuning>,
    pub srvcc_operation_possible: Option<SrvccOperationPossible>,
    pub enhanced_coverage_restriction: Option<EnhancedCoverageRestriction>,
    pub extended_connected_time: Option<ExtendedConnectedTime>,
    pub ue_differentiation_info: Option<UeDifferentiationInfo>,
    pub nr_v2x_services_authorized: Option<NrV2xServicesAuthorized>,
    pub ltev2x_services_authorized: Option<Ltev2xServicesAuthorized>,
    pub nr_ue_sidelink_aggregate_maximum_bitrate: Option<NrUeSidelinkAggregateMaximumBitrate>,
    pub lte_ue_sidelink_aggregate_maximum_bitrate: Option<LteUeSidelinkAggregateMaximumBitrate>,
    pub pc5_qos_parameters: Option<Pc5QosParameters>,
    pub c_emode_brestricted: Option<CEmodeBrestricted>,
    pub ue_up_c_iot_support: Option<UeUpCIotSupport>,
    pub ue_radio_capability_id: Option<UeRadioCapabilityId>,
}

impl PathSwitchRequestAcknowledge {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let _ = decode::decode_sequence_header(data, true, 0)?;
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut amf_ue_ngap_id: Option<AmfUeNgapId> = None;
        let mut ran_ue_ngap_id: Option<RanUeNgapId> = None;
        let mut ue_security_capabilities: Option<UeSecurityCapabilities> = None;
        let mut security_context: Option<SecurityContext> = None;
        let mut new_security_context_ind: Option<NewSecurityContextInd> = None;
        let mut pdu_session_resource_switched_list: Option<PduSessionResourceSwitchedList> = None;
        let mut pdu_session_resource_released_list_ps_ack: Option<
            PduSessionResourceReleasedListPsAck,
        > = None;
        let mut allowed_nssai: Option<AllowedNssai> = None;
        let mut core_network_assistance_information_for_inactive: Option<
            CoreNetworkAssistanceInformationForInactive,
        > = None;
        let mut rrc_inactive_transition_report_request: Option<RrcInactiveTransitionReportRequest> =
            None;
        let mut criticality_diagnostics: Option<CriticalityDiagnostics> = None;
        let mut redirection_voice_fallback: Option<RedirectionVoiceFallback> = None;
        let mut cn_assisted_ran_tuning: Option<CnAssistedRanTuning> = None;
        let mut srvcc_operation_possible: Option<SrvccOperationPossible> = None;
        let mut enhanced_coverage_restriction: Option<EnhancedCoverageRestriction> = None;
        let mut extended_connected_time: Option<ExtendedConnectedTime> = None;
        let mut ue_differentiation_info: Option<UeDifferentiationInfo> = None;
        let mut nr_v2x_services_authorized: Option<NrV2xServicesAuthorized> = None;
        let mut ltev2x_services_authorized: Option<Ltev2xServicesAuthorized> = None;
        let mut nr_ue_sidelink_aggregate_maximum_bitrate: Option<
            NrUeSidelinkAggregateMaximumBitrate,
        > = None;
        let mut lte_ue_sidelink_aggregate_maximum_bitrate: Option<
            LteUeSidelinkAggregateMaximumBitrate,
        > = None;
        let mut pc5_qos_parameters: Option<Pc5QosParameters> = None;
        let mut c_emode_brestricted: Option<CEmodeBrestricted> = None;
        let mut ue_up_c_iot_support: Option<UeUpCIotSupport> = None;
        let mut ue_radio_capability_id: Option<UeRadioCapabilityId> = None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                10 => amf_ue_ngap_id = Some(AmfUeNgapId::decode(data)?),
                85 => ran_ue_ngap_id = Some(RanUeNgapId::decode(data)?),
                119 => ue_security_capabilities = Some(UeSecurityCapabilities::decode(data)?),
                93 => security_context = Some(SecurityContext::decode(data)?),
                41 => new_security_context_ind = Some(NewSecurityContextInd::decode(data)?),
                77 => {
                    pdu_session_resource_switched_list =
                        Some(PduSessionResourceSwitchedList::decode(data)?)
                }
                68 => {
                    pdu_session_resource_released_list_ps_ack =
                        Some(PduSessionResourceReleasedListPsAck::decode(data)?)
                }
                0 => allowed_nssai = Some(AllowedNssai::decode(data)?),
                18 => {
                    core_network_assistance_information_for_inactive =
                        Some(CoreNetworkAssistanceInformationForInactive::decode(data)?)
                }
                91 => {
                    rrc_inactive_transition_report_request =
                        Some(RrcInactiveTransitionReportRequest::decode(data)?)
                }
                19 => criticality_diagnostics = Some(CriticalityDiagnostics::decode(data)?),
                146 => redirection_voice_fallback = Some(RedirectionVoiceFallback::decode(data)?),
                165 => cn_assisted_ran_tuning = Some(CnAssistedRanTuning::decode(data)?),
                177 => srvcc_operation_possible = Some(SrvccOperationPossible::decode(data)?),
                205 => {
                    enhanced_coverage_restriction = Some(EnhancedCoverageRestriction::decode(data)?)
                }
                206 => extended_connected_time = Some(ExtendedConnectedTime::decode(data)?),
                209 => ue_differentiation_info = Some(UeDifferentiationInfo::decode(data)?),
                216 => nr_v2x_services_authorized = Some(NrV2xServicesAuthorized::decode(data)?),
                215 => ltev2x_services_authorized = Some(Ltev2xServicesAuthorized::decode(data)?),
                218 => {
                    nr_ue_sidelink_aggregate_maximum_bitrate =
                        Some(NrUeSidelinkAggregateMaximumBitrate::decode(data)?)
                }
                217 => {
                    lte_ue_sidelink_aggregate_maximum_bitrate =
                        Some(LteUeSidelinkAggregateMaximumBitrate::decode(data)?)
                }
                219 => pc5_qos_parameters = Some(Pc5QosParameters::decode(data)?),
                222 => c_emode_brestricted = Some(CEmodeBrestricted::decode(data)?),
                234 => ue_up_c_iot_support = Some(UeUpCIotSupport::decode(data)?),
                264 => ue_radio_capability_id = Some(UeRadioCapabilityId::decode(data)?),
                x => return Err(PerCodecError::new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        let amf_ue_ngap_id = amf_ue_ngap_id.ok_or(PerCodecError::new(format!(
            "Missing mandatory IE amf_ue_ngap_id"
        )))?;
        let ran_ue_ngap_id = ran_ue_ngap_id.ok_or(PerCodecError::new(format!(
            "Missing mandatory IE ran_ue_ngap_id"
        )))?;
        let security_context = security_context.ok_or(PerCodecError::new(format!(
            "Missing mandatory IE security_context"
        )))?;
        let pdu_session_resource_switched_list =
            pdu_session_resource_switched_list.ok_or(PerCodecError::new(format!(
                "Missing mandatory IE pdu_session_resource_switched_list"
            )))?;
        let allowed_nssai = allowed_nssai.ok_or(PerCodecError::new(format!(
            "Missing mandatory IE allowed_nssai"
        )))?;
        Ok(Self {
            amf_ue_ngap_id,
            ran_ue_ngap_id,
            ue_security_capabilities,
            security_context,
            new_security_context_ind,
            pdu_session_resource_switched_list,
            pdu_session_resource_released_list_ps_ack,
            allowed_nssai,
            core_network_assistance_information_for_inactive,
            rrc_inactive_transition_report_request,
            criticality_diagnostics,
            redirection_voice_fallback,
            cn_assisted_ran_tuning,
            srvcc_operation_possible,
            enhanced_coverage_restriction,
            extended_connected_time,
            ue_differentiation_info,
            nr_v2x_services_authorized,
            ltev2x_services_authorized,
            nr_ue_sidelink_aggregate_maximum_bitrate,
            lte_ue_sidelink_aggregate_maximum_bitrate,
            pc5_qos_parameters,
            c_emode_brestricted,
            ue_up_c_iot_support,
            ue_radio_capability_id,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        let ie = &mut Allocator::new_codec_data();
        self.amf_ue_ngap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 10, false)?;
        Criticality::Ignore.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.ran_ue_ngap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 85, false)?;
        Criticality::Ignore.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        if let Some(x) = &self.ue_security_capabilities {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 119, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        let ie = &mut Allocator::new_codec_data();
        self.security_context.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 93, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        if let Some(x) = &self.new_security_context_ind {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 41, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        let ie = &mut Allocator::new_codec_data();
        self.pdu_session_resource_switched_list.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 77, false)?;
        Criticality::Ignore.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        if let Some(x) = &self.pdu_session_resource_released_list_ps_ack {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 68, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        let ie = &mut Allocator::new_codec_data();
        self.allowed_nssai.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 0, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        if let Some(x) = &self.core_network_assistance_information_for_inactive {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 18, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.rrc_inactive_transition_report_request {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 91, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.criticality_diagnostics {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 19, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.redirection_voice_fallback {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 146, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.cn_assisted_ran_tuning {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 165, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.srvcc_operation_possible {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 177, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.enhanced_coverage_restriction {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 205, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.extended_connected_time {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 206, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.ue_differentiation_info {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 209, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.nr_v2x_services_authorized {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 216, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.ltev2x_services_authorized {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 215, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.nr_ue_sidelink_aggregate_maximum_bitrate {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 218, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.lte_ue_sidelink_aggregate_maximum_bitrate {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 217, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.pc5_qos_parameters {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 219, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.c_emode_brestricted {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 222, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.ue_up_c_iot_support {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 234, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.ue_radio_capability_id {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 264, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        encode::encode_sequence_header(data, true, &BitString::new(), false)?;
        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for PathSwitchRequestAcknowledge {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PathSwitchRequestAcknowledge::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PathSwitchRequestAcknowledge");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PathSwitchRequestAcknowledge");
            e
        })
    }
}
// PathSwitchRequestFailure
#[derive(Clone, Debug)]
pub struct PathSwitchRequestFailure {
    pub amf_ue_ngap_id: AmfUeNgapId,
    pub ran_ue_ngap_id: RanUeNgapId,
    pub pdu_session_resource_released_list_ps_fail: PduSessionResourceReleasedListPsFail,
    pub criticality_diagnostics: Option<CriticalityDiagnostics>,
}

impl PathSwitchRequestFailure {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let _ = decode::decode_sequence_header(data, true, 0)?;
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut amf_ue_ngap_id: Option<AmfUeNgapId> = None;
        let mut ran_ue_ngap_id: Option<RanUeNgapId> = None;
        let mut pdu_session_resource_released_list_ps_fail: Option<
            PduSessionResourceReleasedListPsFail,
        > = None;
        let mut criticality_diagnostics: Option<CriticalityDiagnostics> = None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                10 => amf_ue_ngap_id = Some(AmfUeNgapId::decode(data)?),
                85 => ran_ue_ngap_id = Some(RanUeNgapId::decode(data)?),
                69 => {
                    pdu_session_resource_released_list_ps_fail =
                        Some(PduSessionResourceReleasedListPsFail::decode(data)?)
                }
                19 => criticality_diagnostics = Some(CriticalityDiagnostics::decode(data)?),
                x => return Err(PerCodecError::new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        let amf_ue_ngap_id = amf_ue_ngap_id.ok_or(PerCodecError::new(format!(
            "Missing mandatory IE amf_ue_ngap_id"
        )))?;
        let ran_ue_ngap_id = ran_ue_ngap_id.ok_or(PerCodecError::new(format!(
            "Missing mandatory IE ran_ue_ngap_id"
        )))?;
        let pdu_session_resource_released_list_ps_fail = pdu_session_resource_released_list_ps_fail
            .ok_or(PerCodecError::new(format!(
                "Missing mandatory IE pdu_session_resource_released_list_ps_fail"
            )))?;
        Ok(Self {
            amf_ue_ngap_id,
            ran_ue_ngap_id,
            pdu_session_resource_released_list_ps_fail,
            criticality_diagnostics,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        let ie = &mut Allocator::new_codec_data();
        self.amf_ue_ngap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 10, false)?;
        Criticality::Ignore.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.ran_ue_ngap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 85, false)?;
        Criticality::Ignore.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.pdu_session_resource_released_list_ps_fail.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 69, false)?;
        Criticality::Ignore.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        if let Some(x) = &self.criticality_diagnostics {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 19, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        encode::encode_sequence_header(data, true, &BitString::new(), false)?;
        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for PathSwitchRequestFailure {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PathSwitchRequestFailure::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PathSwitchRequestFailure");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PathSwitchRequestFailure");
            e
        })
    }
}
// HandoverCancel
#[derive(Clone, Debug)]
pub struct HandoverCancel {
    pub amf_ue_ngap_id: AmfUeNgapId,
    pub ran_ue_ngap_id: RanUeNgapId,
    pub cause: Cause,
}

impl HandoverCancel {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let _ = decode::decode_sequence_header(data, true, 0)?;
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut amf_ue_ngap_id: Option<AmfUeNgapId> = None;
        let mut ran_ue_ngap_id: Option<RanUeNgapId> = None;
        let mut cause: Option<Cause> = None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                10 => amf_ue_ngap_id = Some(AmfUeNgapId::decode(data)?),
                85 => ran_ue_ngap_id = Some(RanUeNgapId::decode(data)?),
                15 => cause = Some(Cause::decode(data)?),
                x => return Err(PerCodecError::new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        let amf_ue_ngap_id = amf_ue_ngap_id.ok_or(PerCodecError::new(format!(
            "Missing mandatory IE amf_ue_ngap_id"
        )))?;
        let ran_ue_ngap_id = ran_ue_ngap_id.ok_or(PerCodecError::new(format!(
            "Missing mandatory IE ran_ue_ngap_id"
        )))?;
        let cause = cause.ok_or(PerCodecError::new(format!("Missing mandatory IE cause")))?;
        Ok(Self {
            amf_ue_ngap_id,
            ran_ue_ngap_id,
            cause,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        let ie = &mut Allocator::new_codec_data();
        self.amf_ue_ngap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 10, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.ran_ue_ngap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 85, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.cause.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 15, false)?;
        Criticality::Ignore.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        encode::encode_sequence_header(data, true, &BitString::new(), false)?;
        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for HandoverCancel {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        HandoverCancel::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("HandoverCancel");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("HandoverCancel");
            e
        })
    }
}
// HandoverCancelAcknowledge
#[derive(Clone, Debug)]
pub struct HandoverCancelAcknowledge {
    pub amf_ue_ngap_id: AmfUeNgapId,
    pub ran_ue_ngap_id: RanUeNgapId,
    pub criticality_diagnostics: Option<CriticalityDiagnostics>,
}

impl HandoverCancelAcknowledge {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let _ = decode::decode_sequence_header(data, true, 0)?;
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut amf_ue_ngap_id: Option<AmfUeNgapId> = None;
        let mut ran_ue_ngap_id: Option<RanUeNgapId> = None;
        let mut criticality_diagnostics: Option<CriticalityDiagnostics> = None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                10 => amf_ue_ngap_id = Some(AmfUeNgapId::decode(data)?),
                85 => ran_ue_ngap_id = Some(RanUeNgapId::decode(data)?),
                19 => criticality_diagnostics = Some(CriticalityDiagnostics::decode(data)?),
                x => return Err(PerCodecError::new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        let amf_ue_ngap_id = amf_ue_ngap_id.ok_or(PerCodecError::new(format!(
            "Missing mandatory IE amf_ue_ngap_id"
        )))?;
        let ran_ue_ngap_id = ran_ue_ngap_id.ok_or(PerCodecError::new(format!(
            "Missing mandatory IE ran_ue_ngap_id"
        )))?;
        Ok(Self {
            amf_ue_ngap_id,
            ran_ue_ngap_id,
            criticality_diagnostics,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        let ie = &mut Allocator::new_codec_data();
        self.amf_ue_ngap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 10, false)?;
        Criticality::Ignore.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.ran_ue_ngap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 85, false)?;
        Criticality::Ignore.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        if let Some(x) = &self.criticality_diagnostics {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 19, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        encode::encode_sequence_header(data, true, &BitString::new(), false)?;
        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for HandoverCancelAcknowledge {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        HandoverCancelAcknowledge::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("HandoverCancelAcknowledge");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("HandoverCancelAcknowledge");
            e
        })
    }
}
// HandoverSuccess
#[derive(Clone, Debug)]
pub struct HandoverSuccess {
    pub amf_ue_ngap_id: AmfUeNgapId,
    pub ran_ue_ngap_id: RanUeNgapId,
}

impl HandoverSuccess {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let _ = decode::decode_sequence_header(data, true, 0)?;
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut amf_ue_ngap_id: Option<AmfUeNgapId> = None;
        let mut ran_ue_ngap_id: Option<RanUeNgapId> = None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                10 => amf_ue_ngap_id = Some(AmfUeNgapId::decode(data)?),
                85 => ran_ue_ngap_id = Some(RanUeNgapId::decode(data)?),
                x => return Err(PerCodecError::new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        let amf_ue_ngap_id = amf_ue_ngap_id.ok_or(PerCodecError::new(format!(
            "Missing mandatory IE amf_ue_ngap_id"
        )))?;
        let ran_ue_ngap_id = ran_ue_ngap_id.ok_or(PerCodecError::new(format!(
            "Missing mandatory IE ran_ue_ngap_id"
        )))?;
        Ok(Self {
            amf_ue_ngap_id,
            ran_ue_ngap_id,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        let ie = &mut Allocator::new_codec_data();
        self.amf_ue_ngap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 10, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.ran_ue_ngap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 85, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        encode::encode_sequence_header(data, true, &BitString::new(), false)?;
        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for HandoverSuccess {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        HandoverSuccess::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("HandoverSuccess");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("HandoverSuccess");
            e
        })
    }
}
// UplinkRanEarlyStatusTransfer
#[derive(Clone, Debug)]
pub struct UplinkRanEarlyStatusTransfer {
    pub amf_ue_ngap_id: AmfUeNgapId,
    pub ran_ue_ngap_id: RanUeNgapId,
    pub early_status_transfer_transparent_container: EarlyStatusTransferTransparentContainer,
}

impl UplinkRanEarlyStatusTransfer {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let _ = decode::decode_sequence_header(data, true, 0)?;
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut amf_ue_ngap_id: Option<AmfUeNgapId> = None;
        let mut ran_ue_ngap_id: Option<RanUeNgapId> = None;
        let mut early_status_transfer_transparent_container: Option<
            EarlyStatusTransferTransparentContainer,
        > = None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                10 => amf_ue_ngap_id = Some(AmfUeNgapId::decode(data)?),
                85 => ran_ue_ngap_id = Some(RanUeNgapId::decode(data)?),
                268 => {
                    early_status_transfer_transparent_container =
                        Some(EarlyStatusTransferTransparentContainer::decode(data)?)
                }
                x => return Err(PerCodecError::new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        let amf_ue_ngap_id = amf_ue_ngap_id.ok_or(PerCodecError::new(format!(
            "Missing mandatory IE amf_ue_ngap_id"
        )))?;
        let ran_ue_ngap_id = ran_ue_ngap_id.ok_or(PerCodecError::new(format!(
            "Missing mandatory IE ran_ue_ngap_id"
        )))?;
        let early_status_transfer_transparent_container =
            early_status_transfer_transparent_container.ok_or(PerCodecError::new(format!(
                "Missing mandatory IE early_status_transfer_transparent_container"
            )))?;
        Ok(Self {
            amf_ue_ngap_id,
            ran_ue_ngap_id,
            early_status_transfer_transparent_container,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        let ie = &mut Allocator::new_codec_data();
        self.amf_ue_ngap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 10, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.ran_ue_ngap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 85, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.early_status_transfer_transparent_container
            .encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 268, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        encode::encode_sequence_header(data, true, &BitString::new(), false)?;
        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for UplinkRanEarlyStatusTransfer {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        UplinkRanEarlyStatusTransfer::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UplinkRanEarlyStatusTransfer");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UplinkRanEarlyStatusTransfer");
            e
        })
    }
}
// DownlinkRanEarlyStatusTransfer
#[derive(Clone, Debug)]
pub struct DownlinkRanEarlyStatusTransfer {
    pub amf_ue_ngap_id: AmfUeNgapId,
    pub ran_ue_ngap_id: RanUeNgapId,
    pub early_status_transfer_transparent_container: EarlyStatusTransferTransparentContainer,
}

impl DownlinkRanEarlyStatusTransfer {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let _ = decode::decode_sequence_header(data, true, 0)?;
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut amf_ue_ngap_id: Option<AmfUeNgapId> = None;
        let mut ran_ue_ngap_id: Option<RanUeNgapId> = None;
        let mut early_status_transfer_transparent_container: Option<
            EarlyStatusTransferTransparentContainer,
        > = None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                10 => amf_ue_ngap_id = Some(AmfUeNgapId::decode(data)?),
                85 => ran_ue_ngap_id = Some(RanUeNgapId::decode(data)?),
                268 => {
                    early_status_transfer_transparent_container =
                        Some(EarlyStatusTransferTransparentContainer::decode(data)?)
                }
                x => return Err(PerCodecError::new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        let amf_ue_ngap_id = amf_ue_ngap_id.ok_or(PerCodecError::new(format!(
            "Missing mandatory IE amf_ue_ngap_id"
        )))?;
        let ran_ue_ngap_id = ran_ue_ngap_id.ok_or(PerCodecError::new(format!(
            "Missing mandatory IE ran_ue_ngap_id"
        )))?;
        let early_status_transfer_transparent_container =
            early_status_transfer_transparent_container.ok_or(PerCodecError::new(format!(
                "Missing mandatory IE early_status_transfer_transparent_container"
            )))?;
        Ok(Self {
            amf_ue_ngap_id,
            ran_ue_ngap_id,
            early_status_transfer_transparent_container,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        let ie = &mut Allocator::new_codec_data();
        self.amf_ue_ngap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 10, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.ran_ue_ngap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 85, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.early_status_transfer_transparent_container
            .encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 268, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        encode::encode_sequence_header(data, true, &BitString::new(), false)?;
        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for DownlinkRanEarlyStatusTransfer {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        DownlinkRanEarlyStatusTransfer::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DownlinkRanEarlyStatusTransfer");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DownlinkRanEarlyStatusTransfer");
            e
        })
    }
}
// UplinkRanStatusTransfer
#[derive(Clone, Debug)]
pub struct UplinkRanStatusTransfer {
    pub amf_ue_ngap_id: AmfUeNgapId,
    pub ran_ue_ngap_id: RanUeNgapId,
    pub ran_status_transfer_transparent_container: RanStatusTransferTransparentContainer,
}

impl UplinkRanStatusTransfer {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let _ = decode::decode_sequence_header(data, true, 0)?;
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut amf_ue_ngap_id: Option<AmfUeNgapId> = None;
        let mut ran_ue_ngap_id: Option<RanUeNgapId> = None;
        let mut ran_status_transfer_transparent_container: Option<
            RanStatusTransferTransparentContainer,
        > = None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                10 => amf_ue_ngap_id = Some(AmfUeNgapId::decode(data)?),
                85 => ran_ue_ngap_id = Some(RanUeNgapId::decode(data)?),
                84 => {
                    ran_status_transfer_transparent_container =
                        Some(RanStatusTransferTransparentContainer::decode(data)?)
                }
                x => return Err(PerCodecError::new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        let amf_ue_ngap_id = amf_ue_ngap_id.ok_or(PerCodecError::new(format!(
            "Missing mandatory IE amf_ue_ngap_id"
        )))?;
        let ran_ue_ngap_id = ran_ue_ngap_id.ok_or(PerCodecError::new(format!(
            "Missing mandatory IE ran_ue_ngap_id"
        )))?;
        let ran_status_transfer_transparent_container = ran_status_transfer_transparent_container
            .ok_or(PerCodecError::new(format!(
            "Missing mandatory IE ran_status_transfer_transparent_container"
        )))?;
        Ok(Self {
            amf_ue_ngap_id,
            ran_ue_ngap_id,
            ran_status_transfer_transparent_container,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        let ie = &mut Allocator::new_codec_data();
        self.amf_ue_ngap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 10, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.ran_ue_ngap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 85, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.ran_status_transfer_transparent_container.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 84, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        encode::encode_sequence_header(data, true, &BitString::new(), false)?;
        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for UplinkRanStatusTransfer {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        UplinkRanStatusTransfer::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UplinkRanStatusTransfer");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UplinkRanStatusTransfer");
            e
        })
    }
}
// DownlinkRanStatusTransfer
#[derive(Clone, Debug)]
pub struct DownlinkRanStatusTransfer {
    pub amf_ue_ngap_id: AmfUeNgapId,
    pub ran_ue_ngap_id: RanUeNgapId,
    pub ran_status_transfer_transparent_container: RanStatusTransferTransparentContainer,
}

impl DownlinkRanStatusTransfer {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let _ = decode::decode_sequence_header(data, true, 0)?;
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut amf_ue_ngap_id: Option<AmfUeNgapId> = None;
        let mut ran_ue_ngap_id: Option<RanUeNgapId> = None;
        let mut ran_status_transfer_transparent_container: Option<
            RanStatusTransferTransparentContainer,
        > = None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                10 => amf_ue_ngap_id = Some(AmfUeNgapId::decode(data)?),
                85 => ran_ue_ngap_id = Some(RanUeNgapId::decode(data)?),
                84 => {
                    ran_status_transfer_transparent_container =
                        Some(RanStatusTransferTransparentContainer::decode(data)?)
                }
                x => return Err(PerCodecError::new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        let amf_ue_ngap_id = amf_ue_ngap_id.ok_or(PerCodecError::new(format!(
            "Missing mandatory IE amf_ue_ngap_id"
        )))?;
        let ran_ue_ngap_id = ran_ue_ngap_id.ok_or(PerCodecError::new(format!(
            "Missing mandatory IE ran_ue_ngap_id"
        )))?;
        let ran_status_transfer_transparent_container = ran_status_transfer_transparent_container
            .ok_or(PerCodecError::new(format!(
            "Missing mandatory IE ran_status_transfer_transparent_container"
        )))?;
        Ok(Self {
            amf_ue_ngap_id,
            ran_ue_ngap_id,
            ran_status_transfer_transparent_container,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        let ie = &mut Allocator::new_codec_data();
        self.amf_ue_ngap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 10, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.ran_ue_ngap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 85, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.ran_status_transfer_transparent_container.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 84, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        encode::encode_sequence_header(data, true, &BitString::new(), false)?;
        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for DownlinkRanStatusTransfer {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        DownlinkRanStatusTransfer::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DownlinkRanStatusTransfer");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DownlinkRanStatusTransfer");
            e
        })
    }
}
// Paging
#[derive(Clone, Debug)]
pub struct Paging {
    pub ue_paging_identity: UePagingIdentity,
    pub paging_drx: Option<PagingDrx>,
    pub tai_list_for_paging: TaiListForPaging,
    pub paging_priority: Option<PagingPriority>,
    pub ue_radio_capability_for_paging: Option<UeRadioCapabilityForPaging>,
    pub paging_origin: Option<PagingOrigin>,
    pub assistance_data_for_paging: Option<AssistanceDataForPaging>,
    pub nb_iot_paging_e_drx_info: Option<NbIotPagingEDrxInfo>,
    pub nb_iot_paging_drx: Option<NbIotPagingDrx>,
    pub enhanced_coverage_restriction: Option<EnhancedCoverageRestriction>,
    pub wus_assistance_information: Option<WusAssistanceInformation>,
    pub paginge_drx_information: Option<PagingeDrxInformation>,
    pub c_emode_brestricted: Option<CEmodeBrestricted>,
}

impl Paging {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let _ = decode::decode_sequence_header(data, true, 0)?;
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut ue_paging_identity: Option<UePagingIdentity> = None;
        let mut paging_drx: Option<PagingDrx> = None;
        let mut tai_list_for_paging: Option<TaiListForPaging> = None;
        let mut paging_priority: Option<PagingPriority> = None;
        let mut ue_radio_capability_for_paging: Option<UeRadioCapabilityForPaging> = None;
        let mut paging_origin: Option<PagingOrigin> = None;
        let mut assistance_data_for_paging: Option<AssistanceDataForPaging> = None;
        let mut nb_iot_paging_e_drx_info: Option<NbIotPagingEDrxInfo> = None;
        let mut nb_iot_paging_drx: Option<NbIotPagingDrx> = None;
        let mut enhanced_coverage_restriction: Option<EnhancedCoverageRestriction> = None;
        let mut wus_assistance_information: Option<WusAssistanceInformation> = None;
        let mut paginge_drx_information: Option<PagingeDrxInformation> = None;
        let mut c_emode_brestricted: Option<CEmodeBrestricted> = None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                115 => ue_paging_identity = Some(UePagingIdentity::decode(data)?),
                50 => paging_drx = Some(PagingDrx::decode(data)?),
                103 => tai_list_for_paging = Some(TaiListForPaging::decode(data)?),
                52 => paging_priority = Some(PagingPriority::decode(data)?),
                118 => {
                    ue_radio_capability_for_paging = Some(UeRadioCapabilityForPaging::decode(data)?)
                }
                51 => paging_origin = Some(PagingOrigin::decode(data)?),
                11 => assistance_data_for_paging = Some(AssistanceDataForPaging::decode(data)?),
                203 => nb_iot_paging_e_drx_info = Some(NbIotPagingEDrxInfo::decode(data)?),
                202 => nb_iot_paging_drx = Some(NbIotPagingDrx::decode(data)?),
                205 => {
                    enhanced_coverage_restriction = Some(EnhancedCoverageRestriction::decode(data)?)
                }
                208 => wus_assistance_information = Some(WusAssistanceInformation::decode(data)?),
                223 => paginge_drx_information = Some(PagingeDrxInformation::decode(data)?),
                222 => c_emode_brestricted = Some(CEmodeBrestricted::decode(data)?),
                x => return Err(PerCodecError::new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        let ue_paging_identity = ue_paging_identity.ok_or(PerCodecError::new(format!(
            "Missing mandatory IE ue_paging_identity"
        )))?;
        let tai_list_for_paging = tai_list_for_paging.ok_or(PerCodecError::new(format!(
            "Missing mandatory IE tai_list_for_paging"
        )))?;
        Ok(Self {
            ue_paging_identity,
            paging_drx,
            tai_list_for_paging,
            paging_priority,
            ue_radio_capability_for_paging,
            paging_origin,
            assistance_data_for_paging,
            nb_iot_paging_e_drx_info,
            nb_iot_paging_drx,
            enhanced_coverage_restriction,
            wus_assistance_information,
            paginge_drx_information,
            c_emode_brestricted,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        let ie = &mut Allocator::new_codec_data();
        self.ue_paging_identity.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 115, false)?;
        Criticality::Ignore.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        if let Some(x) = &self.paging_drx {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 50, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        let ie = &mut Allocator::new_codec_data();
        self.tai_list_for_paging.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 103, false)?;
        Criticality::Ignore.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        if let Some(x) = &self.paging_priority {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 52, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.ue_radio_capability_for_paging {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 118, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.paging_origin {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 51, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.assistance_data_for_paging {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 11, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.nb_iot_paging_e_drx_info {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 203, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.nb_iot_paging_drx {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 202, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.enhanced_coverage_restriction {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 205, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.wus_assistance_information {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 208, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.paginge_drx_information {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 223, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.c_emode_brestricted {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 222, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        encode::encode_sequence_header(data, true, &BitString::new(), false)?;
        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for Paging {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Paging::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("Paging");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("Paging");
            e
        })
    }
}
// InitialUeMessage
#[derive(Clone, Debug)]
pub struct InitialUeMessage {
    pub ran_ue_ngap_id: RanUeNgapId,
    pub nas_pdu: NasPdu,
    pub user_location_information: UserLocationInformation,
    pub rrc_establishment_cause: RrcEstablishmentCause,
    pub five_g_s_tmsi: Option<FiveGSTmsi>,
    pub amf_set_id: Option<AmfSetId>,
    pub ue_context_request: Option<UeContextRequest>,
    pub allowed_nssai: Option<AllowedNssai>,
    pub source_to_target_amf_information_reroute: Option<SourceToTargetAmfInformationReroute>,
    pub selected_plmn_identity: Option<PlmnIdentity>,
    pub iab_node_indication: Option<IabNodeIndication>,
    pub c_emode_b_support_indicator: Option<CEmodeBSupportIndicator>,
    pub ltem_indication: Option<LtemIndication>,
    pub edt_session: Option<EdtSession>,
    pub authenticated_indication: Option<AuthenticatedIndication>,
    pub npn_access_information: Option<NpnAccessInformation>,
}

impl InitialUeMessage {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let _ = decode::decode_sequence_header(data, true, 0)?;
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut ran_ue_ngap_id: Option<RanUeNgapId> = None;
        let mut nas_pdu: Option<NasPdu> = None;
        let mut user_location_information: Option<UserLocationInformation> = None;
        let mut rrc_establishment_cause: Option<RrcEstablishmentCause> = None;
        let mut five_g_s_tmsi: Option<FiveGSTmsi> = None;
        let mut amf_set_id: Option<AmfSetId> = None;
        let mut ue_context_request: Option<UeContextRequest> = None;
        let mut allowed_nssai: Option<AllowedNssai> = None;
        let mut source_to_target_amf_information_reroute: Option<
            SourceToTargetAmfInformationReroute,
        > = None;
        let mut selected_plmn_identity: Option<PlmnIdentity> = None;
        let mut iab_node_indication: Option<IabNodeIndication> = None;
        let mut c_emode_b_support_indicator: Option<CEmodeBSupportIndicator> = None;
        let mut ltem_indication: Option<LtemIndication> = None;
        let mut edt_session: Option<EdtSession> = None;
        let mut authenticated_indication: Option<AuthenticatedIndication> = None;
        let mut npn_access_information: Option<NpnAccessInformation> = None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                85 => ran_ue_ngap_id = Some(RanUeNgapId::decode(data)?),
                38 => nas_pdu = Some(NasPdu::decode(data)?),
                121 => user_location_information = Some(UserLocationInformation::decode(data)?),
                90 => rrc_establishment_cause = Some(RrcEstablishmentCause::decode(data)?),
                26 => five_g_s_tmsi = Some(FiveGSTmsi::decode(data)?),
                3 => amf_set_id = Some(AmfSetId::decode(data)?),
                112 => ue_context_request = Some(UeContextRequest::decode(data)?),
                0 => allowed_nssai = Some(AllowedNssai::decode(data)?),
                171 => {
                    source_to_target_amf_information_reroute =
                        Some(SourceToTargetAmfInformationReroute::decode(data)?)
                }
                174 => selected_plmn_identity = Some(PlmnIdentity::decode(data)?),
                201 => iab_node_indication = Some(IabNodeIndication::decode(data)?),
                224 => c_emode_b_support_indicator = Some(CEmodeBSupportIndicator::decode(data)?),
                225 => ltem_indication = Some(LtemIndication::decode(data)?),
                227 => edt_session = Some(EdtSession::decode(data)?),
                245 => authenticated_indication = Some(AuthenticatedIndication::decode(data)?),
                259 => npn_access_information = Some(NpnAccessInformation::decode(data)?),
                x => return Err(PerCodecError::new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        let ran_ue_ngap_id = ran_ue_ngap_id.ok_or(PerCodecError::new(format!(
            "Missing mandatory IE ran_ue_ngap_id"
        )))?;
        let nas_pdu = nas_pdu.ok_or(PerCodecError::new(format!("Missing mandatory IE nas_pdu")))?;
        let user_location_information = user_location_information.ok_or(PerCodecError::new(
            format!("Missing mandatory IE user_location_information"),
        ))?;
        let rrc_establishment_cause = rrc_establishment_cause.ok_or(PerCodecError::new(
            format!("Missing mandatory IE rrc_establishment_cause"),
        ))?;
        Ok(Self {
            ran_ue_ngap_id,
            nas_pdu,
            user_location_information,
            rrc_establishment_cause,
            five_g_s_tmsi,
            amf_set_id,
            ue_context_request,
            allowed_nssai,
            source_to_target_amf_information_reroute,
            selected_plmn_identity,
            iab_node_indication,
            c_emode_b_support_indicator,
            ltem_indication,
            edt_session,
            authenticated_indication,
            npn_access_information,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        let ie = &mut Allocator::new_codec_data();
        self.ran_ue_ngap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 85, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.nas_pdu.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 38, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.user_location_information.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 121, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.rrc_establishment_cause.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 90, false)?;
        Criticality::Ignore.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        if let Some(x) = &self.five_g_s_tmsi {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 26, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.amf_set_id {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 3, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.ue_context_request {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 112, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.allowed_nssai {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 0, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.source_to_target_amf_information_reroute {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 171, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.selected_plmn_identity {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 174, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.iab_node_indication {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 201, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.c_emode_b_support_indicator {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 224, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.ltem_indication {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 225, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.edt_session {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 227, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.authenticated_indication {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 245, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.npn_access_information {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 259, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        encode::encode_sequence_header(data, true, &BitString::new(), false)?;
        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for InitialUeMessage {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        InitialUeMessage::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("InitialUeMessage");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("InitialUeMessage");
            e
        })
    }
}
// DownlinkNasTransport
#[derive(Clone, Debug)]
pub struct DownlinkNasTransport {
    pub amf_ue_ngap_id: AmfUeNgapId,
    pub ran_ue_ngap_id: RanUeNgapId,
    pub old_amf: Option<AmfName>,
    pub ran_paging_priority: Option<RanPagingPriority>,
    pub nas_pdu: NasPdu,
    pub mobility_restriction_list: Option<MobilityRestrictionList>,
    pub index_to_rfsp: Option<IndexToRfsp>,
    pub ue_aggregate_maximum_bit_rate: Option<UeAggregateMaximumBitRate>,
    pub allowed_nssai: Option<AllowedNssai>,
    pub srvcc_operation_possible: Option<SrvccOperationPossible>,
    pub enhanced_coverage_restriction: Option<EnhancedCoverageRestriction>,
    pub extended_connected_time: Option<ExtendedConnectedTime>,
    pub ue_differentiation_info: Option<UeDifferentiationInfo>,
    pub c_emode_brestricted: Option<CEmodeBrestricted>,
    pub ue_radio_capability: Option<UeRadioCapability>,
    pub ue_capability_info_request: Option<UeCapabilityInfoRequest>,
    pub end_indication: Option<EndIndication>,
    pub ue_radio_capability_id: Option<UeRadioCapabilityId>,
}

impl DownlinkNasTransport {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let _ = decode::decode_sequence_header(data, true, 0)?;
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut amf_ue_ngap_id: Option<AmfUeNgapId> = None;
        let mut ran_ue_ngap_id: Option<RanUeNgapId> = None;
        let mut old_amf: Option<AmfName> = None;
        let mut ran_paging_priority: Option<RanPagingPriority> = None;
        let mut nas_pdu: Option<NasPdu> = None;
        let mut mobility_restriction_list: Option<MobilityRestrictionList> = None;
        let mut index_to_rfsp: Option<IndexToRfsp> = None;
        let mut ue_aggregate_maximum_bit_rate: Option<UeAggregateMaximumBitRate> = None;
        let mut allowed_nssai: Option<AllowedNssai> = None;
        let mut srvcc_operation_possible: Option<SrvccOperationPossible> = None;
        let mut enhanced_coverage_restriction: Option<EnhancedCoverageRestriction> = None;
        let mut extended_connected_time: Option<ExtendedConnectedTime> = None;
        let mut ue_differentiation_info: Option<UeDifferentiationInfo> = None;
        let mut c_emode_brestricted: Option<CEmodeBrestricted> = None;
        let mut ue_radio_capability: Option<UeRadioCapability> = None;
        let mut ue_capability_info_request: Option<UeCapabilityInfoRequest> = None;
        let mut end_indication: Option<EndIndication> = None;
        let mut ue_radio_capability_id: Option<UeRadioCapabilityId> = None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                10 => amf_ue_ngap_id = Some(AmfUeNgapId::decode(data)?),
                85 => ran_ue_ngap_id = Some(RanUeNgapId::decode(data)?),
                48 => old_amf = Some(AmfName::decode(data)?),
                83 => ran_paging_priority = Some(RanPagingPriority::decode(data)?),
                38 => nas_pdu = Some(NasPdu::decode(data)?),
                36 => mobility_restriction_list = Some(MobilityRestrictionList::decode(data)?),
                31 => index_to_rfsp = Some(IndexToRfsp::decode(data)?),
                110 => {
                    ue_aggregate_maximum_bit_rate = Some(UeAggregateMaximumBitRate::decode(data)?)
                }
                0 => allowed_nssai = Some(AllowedNssai::decode(data)?),
                177 => srvcc_operation_possible = Some(SrvccOperationPossible::decode(data)?),
                205 => {
                    enhanced_coverage_restriction = Some(EnhancedCoverageRestriction::decode(data)?)
                }
                206 => extended_connected_time = Some(ExtendedConnectedTime::decode(data)?),
                209 => ue_differentiation_info = Some(UeDifferentiationInfo::decode(data)?),
                222 => c_emode_brestricted = Some(CEmodeBrestricted::decode(data)?),
                117 => ue_radio_capability = Some(UeRadioCapability::decode(data)?),
                228 => ue_capability_info_request = Some(UeCapabilityInfoRequest::decode(data)?),
                226 => end_indication = Some(EndIndication::decode(data)?),
                264 => ue_radio_capability_id = Some(UeRadioCapabilityId::decode(data)?),
                x => return Err(PerCodecError::new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        let amf_ue_ngap_id = amf_ue_ngap_id.ok_or(PerCodecError::new(format!(
            "Missing mandatory IE amf_ue_ngap_id"
        )))?;
        let ran_ue_ngap_id = ran_ue_ngap_id.ok_or(PerCodecError::new(format!(
            "Missing mandatory IE ran_ue_ngap_id"
        )))?;
        let nas_pdu = nas_pdu.ok_or(PerCodecError::new(format!("Missing mandatory IE nas_pdu")))?;
        Ok(Self {
            amf_ue_ngap_id,
            ran_ue_ngap_id,
            old_amf,
            ran_paging_priority,
            nas_pdu,
            mobility_restriction_list,
            index_to_rfsp,
            ue_aggregate_maximum_bit_rate,
            allowed_nssai,
            srvcc_operation_possible,
            enhanced_coverage_restriction,
            extended_connected_time,
            ue_differentiation_info,
            c_emode_brestricted,
            ue_radio_capability,
            ue_capability_info_request,
            end_indication,
            ue_radio_capability_id,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        let ie = &mut Allocator::new_codec_data();
        self.amf_ue_ngap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 10, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.ran_ue_ngap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 85, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        if let Some(x) = &self.old_amf {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 48, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.ran_paging_priority {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 83, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        let ie = &mut Allocator::new_codec_data();
        self.nas_pdu.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 38, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        if let Some(x) = &self.mobility_restriction_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 36, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.index_to_rfsp {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 31, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.ue_aggregate_maximum_bit_rate {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 110, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.allowed_nssai {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 0, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.srvcc_operation_possible {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 177, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.enhanced_coverage_restriction {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 205, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.extended_connected_time {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 206, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.ue_differentiation_info {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 209, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.c_emode_brestricted {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 222, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.ue_radio_capability {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 117, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.ue_capability_info_request {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 228, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.end_indication {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 226, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.ue_radio_capability_id {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 264, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        encode::encode_sequence_header(data, true, &BitString::new(), false)?;
        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for DownlinkNasTransport {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        DownlinkNasTransport::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DownlinkNasTransport");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DownlinkNasTransport");
            e
        })
    }
}
// UplinkNasTransport
#[derive(Clone, Debug)]
pub struct UplinkNasTransport {
    pub amf_ue_ngap_id: AmfUeNgapId,
    pub ran_ue_ngap_id: RanUeNgapId,
    pub nas_pdu: NasPdu,
    pub user_location_information: UserLocationInformation,
    pub w_agf_identity_information: Option<Vec<u8>>,
    pub tngf_identity_information: Option<Vec<u8>>,
    pub twif_identity_information: Option<Vec<u8>>,
}

impl UplinkNasTransport {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let _ = decode::decode_sequence_header(data, true, 0)?;
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut amf_ue_ngap_id: Option<AmfUeNgapId> = None;
        let mut ran_ue_ngap_id: Option<RanUeNgapId> = None;
        let mut nas_pdu: Option<NasPdu> = None;
        let mut user_location_information: Option<UserLocationInformation> = None;
        let mut w_agf_identity_information: Option<Vec<u8>> = None;
        let mut tngf_identity_information: Option<Vec<u8>> = None;
        let mut twif_identity_information: Option<Vec<u8>> = None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                10 => amf_ue_ngap_id = Some(AmfUeNgapId::decode(data)?),
                85 => ran_ue_ngap_id = Some(RanUeNgapId::decode(data)?),
                38 => nas_pdu = Some(NasPdu::decode(data)?),
                121 => user_location_information = Some(UserLocationInformation::decode(data)?),
                239 => {
                    w_agf_identity_information =
                        Some(decode::decode_octetstring(data, None, None, false)?)
                }
                246 => {
                    tngf_identity_information =
                        Some(decode::decode_octetstring(data, None, None, false)?)
                }
                247 => {
                    twif_identity_information =
                        Some(decode::decode_octetstring(data, None, None, false)?)
                }
                x => return Err(PerCodecError::new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        let amf_ue_ngap_id = amf_ue_ngap_id.ok_or(PerCodecError::new(format!(
            "Missing mandatory IE amf_ue_ngap_id"
        )))?;
        let ran_ue_ngap_id = ran_ue_ngap_id.ok_or(PerCodecError::new(format!(
            "Missing mandatory IE ran_ue_ngap_id"
        )))?;
        let nas_pdu = nas_pdu.ok_or(PerCodecError::new(format!("Missing mandatory IE nas_pdu")))?;
        let user_location_information = user_location_information.ok_or(PerCodecError::new(
            format!("Missing mandatory IE user_location_information"),
        ))?;
        Ok(Self {
            amf_ue_ngap_id,
            ran_ue_ngap_id,
            nas_pdu,
            user_location_information,
            w_agf_identity_information,
            tngf_identity_information,
            twif_identity_information,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        let ie = &mut Allocator::new_codec_data();
        self.amf_ue_ngap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 10, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.ran_ue_ngap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 85, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.nas_pdu.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 38, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.user_location_information.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 121, false)?;
        Criticality::Ignore.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        if let Some(x) = &self.w_agf_identity_information {
            let ie = &mut Allocator::new_codec_data();
            encode::encode_octetstring(ie, None, None, false, &x, false)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 239, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.tngf_identity_information {
            let ie = &mut Allocator::new_codec_data();
            encode::encode_octetstring(ie, None, None, false, &x, false)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 246, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.twif_identity_information {
            let ie = &mut Allocator::new_codec_data();
            encode::encode_octetstring(ie, None, None, false, &x, false)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 247, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        encode::encode_sequence_header(data, true, &BitString::new(), false)?;
        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for UplinkNasTransport {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        UplinkNasTransport::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UplinkNasTransport");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UplinkNasTransport");
            e
        })
    }
}
// NasNonDeliveryIndication
#[derive(Clone, Debug)]
pub struct NasNonDeliveryIndication {
    pub amf_ue_ngap_id: AmfUeNgapId,
    pub ran_ue_ngap_id: RanUeNgapId,
    pub nas_pdu: NasPdu,
    pub cause: Cause,
}

impl NasNonDeliveryIndication {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let _ = decode::decode_sequence_header(data, true, 0)?;
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut amf_ue_ngap_id: Option<AmfUeNgapId> = None;
        let mut ran_ue_ngap_id: Option<RanUeNgapId> = None;
        let mut nas_pdu: Option<NasPdu> = None;
        let mut cause: Option<Cause> = None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                10 => amf_ue_ngap_id = Some(AmfUeNgapId::decode(data)?),
                85 => ran_ue_ngap_id = Some(RanUeNgapId::decode(data)?),
                38 => nas_pdu = Some(NasPdu::decode(data)?),
                15 => cause = Some(Cause::decode(data)?),
                x => return Err(PerCodecError::new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        let amf_ue_ngap_id = amf_ue_ngap_id.ok_or(PerCodecError::new(format!(
            "Missing mandatory IE amf_ue_ngap_id"
        )))?;
        let ran_ue_ngap_id = ran_ue_ngap_id.ok_or(PerCodecError::new(format!(
            "Missing mandatory IE ran_ue_ngap_id"
        )))?;
        let nas_pdu = nas_pdu.ok_or(PerCodecError::new(format!("Missing mandatory IE nas_pdu")))?;
        let cause = cause.ok_or(PerCodecError::new(format!("Missing mandatory IE cause")))?;
        Ok(Self {
            amf_ue_ngap_id,
            ran_ue_ngap_id,
            nas_pdu,
            cause,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        let ie = &mut Allocator::new_codec_data();
        self.amf_ue_ngap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 10, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.ran_ue_ngap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 85, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.nas_pdu.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 38, false)?;
        Criticality::Ignore.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.cause.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 15, false)?;
        Criticality::Ignore.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        encode::encode_sequence_header(data, true, &BitString::new(), false)?;
        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for NasNonDeliveryIndication {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        NasNonDeliveryIndication::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NasNonDeliveryIndication");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NasNonDeliveryIndication");
            e
        })
    }
}
// RerouteNasRequest
#[derive(Clone, Debug)]
pub struct RerouteNasRequest {
    pub ran_ue_ngap_id: RanUeNgapId,
    pub amf_ue_ngap_id: Option<AmfUeNgapId>,
    pub ngap_message: Vec<u8>,
    pub amf_set_id: AmfSetId,
    pub allowed_nssai: Option<AllowedNssai>,
    pub source_to_target_amf_information_reroute: Option<SourceToTargetAmfInformationReroute>,
}

impl RerouteNasRequest {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let _ = decode::decode_sequence_header(data, true, 0)?;
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut ran_ue_ngap_id: Option<RanUeNgapId> = None;
        let mut amf_ue_ngap_id: Option<AmfUeNgapId> = None;
        let mut ngap_message: Option<Vec<u8>> = None;
        let mut amf_set_id: Option<AmfSetId> = None;
        let mut allowed_nssai: Option<AllowedNssai> = None;
        let mut source_to_target_amf_information_reroute: Option<
            SourceToTargetAmfInformationReroute,
        > = None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                85 => ran_ue_ngap_id = Some(RanUeNgapId::decode(data)?),
                10 => amf_ue_ngap_id = Some(AmfUeNgapId::decode(data)?),
                42 => ngap_message = Some(decode::decode_octetstring(data, None, None, false)?),
                3 => amf_set_id = Some(AmfSetId::decode(data)?),
                0 => allowed_nssai = Some(AllowedNssai::decode(data)?),
                171 => {
                    source_to_target_amf_information_reroute =
                        Some(SourceToTargetAmfInformationReroute::decode(data)?)
                }
                x => return Err(PerCodecError::new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        let ran_ue_ngap_id = ran_ue_ngap_id.ok_or(PerCodecError::new(format!(
            "Missing mandatory IE ran_ue_ngap_id"
        )))?;
        let ngap_message = ngap_message.ok_or(PerCodecError::new(format!(
            "Missing mandatory IE ngap_message"
        )))?;
        let amf_set_id = amf_set_id.ok_or(PerCodecError::new(format!(
            "Missing mandatory IE amf_set_id"
        )))?;
        Ok(Self {
            ran_ue_ngap_id,
            amf_ue_ngap_id,
            ngap_message,
            amf_set_id,
            allowed_nssai,
            source_to_target_amf_information_reroute,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        let ie = &mut Allocator::new_codec_data();
        self.ran_ue_ngap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 85, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        if let Some(x) = &self.amf_ue_ngap_id {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 10, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        let ie = &mut Allocator::new_codec_data();
        encode::encode_octetstring(ie, None, None, false, &self.ngap_message, false)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 42, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.amf_set_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 3, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        if let Some(x) = &self.allowed_nssai {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 0, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.source_to_target_amf_information_reroute {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 171, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        encode::encode_sequence_header(data, true, &BitString::new(), false)?;
        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for RerouteNasRequest {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        RerouteNasRequest::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("RerouteNasRequest");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("RerouteNasRequest");
            e
        })
    }
}
// NgSetupRequest
#[derive(Clone, Debug)]
pub struct NgSetupRequest {
    pub global_ran_node_id: GlobalRanNodeId,
    pub ran_node_name: Option<RanNodeName>,
    pub supported_ta_list: SupportedTaList,
    pub default_paging_drx: PagingDrx,
    pub ue_retention_information: Option<UeRetentionInformation>,
    pub nb_iot_default_paging_drx: Option<NbIotDefaultPagingDrx>,
    pub extended_ran_node_name: Option<ExtendedRanNodeName>,
}

impl NgSetupRequest {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let _ = decode::decode_sequence_header(data, true, 0)?;
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut global_ran_node_id: Option<GlobalRanNodeId> = None;
        let mut ran_node_name: Option<RanNodeName> = None;
        let mut supported_ta_list: Option<SupportedTaList> = None;
        let mut default_paging_drx: Option<PagingDrx> = None;
        let mut ue_retention_information: Option<UeRetentionInformation> = None;
        let mut nb_iot_default_paging_drx: Option<NbIotDefaultPagingDrx> = None;
        let mut extended_ran_node_name: Option<ExtendedRanNodeName> = None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                27 => global_ran_node_id = Some(GlobalRanNodeId::decode(data)?),
                82 => ran_node_name = Some(RanNodeName::decode(data)?),
                102 => supported_ta_list = Some(SupportedTaList::decode(data)?),
                21 => default_paging_drx = Some(PagingDrx::decode(data)?),
                147 => ue_retention_information = Some(UeRetentionInformation::decode(data)?),
                204 => nb_iot_default_paging_drx = Some(NbIotDefaultPagingDrx::decode(data)?),
                273 => extended_ran_node_name = Some(ExtendedRanNodeName::decode(data)?),
                x => return Err(PerCodecError::new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        let global_ran_node_id = global_ran_node_id.ok_or(PerCodecError::new(format!(
            "Missing mandatory IE global_ran_node_id"
        )))?;
        let supported_ta_list = supported_ta_list.ok_or(PerCodecError::new(format!(
            "Missing mandatory IE supported_ta_list"
        )))?;
        let default_paging_drx = default_paging_drx.ok_or(PerCodecError::new(format!(
            "Missing mandatory IE default_paging_drx"
        )))?;
        Ok(Self {
            global_ran_node_id,
            ran_node_name,
            supported_ta_list,
            default_paging_drx,
            ue_retention_information,
            nb_iot_default_paging_drx,
            extended_ran_node_name,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        let ie = &mut Allocator::new_codec_data();
        self.global_ran_node_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 27, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        if let Some(x) = &self.ran_node_name {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 82, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        let ie = &mut Allocator::new_codec_data();
        self.supported_ta_list.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 102, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.default_paging_drx.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 21, false)?;
        Criticality::Ignore.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        if let Some(x) = &self.ue_retention_information {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 147, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.nb_iot_default_paging_drx {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 204, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.extended_ran_node_name {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 273, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        encode::encode_sequence_header(data, true, &BitString::new(), false)?;
        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for NgSetupRequest {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        NgSetupRequest::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NgSetupRequest");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NgSetupRequest");
            e
        })
    }
}
// NgSetupResponse
#[derive(Clone, Debug)]
pub struct NgSetupResponse {
    pub amf_name: AmfName,
    pub served_guami_list: ServedGuamiList,
    pub relative_amf_capacity: RelativeAmfCapacity,
    pub plmn_support_list: PlmnSupportList,
    pub criticality_diagnostics: Option<CriticalityDiagnostics>,
    pub ue_retention_information: Option<UeRetentionInformation>,
    pub iab_supported: Option<IabSupported>,
    pub extended_amf_name: Option<ExtendedAmfName>,
}

impl NgSetupResponse {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let _ = decode::decode_sequence_header(data, true, 0)?;
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut amf_name: Option<AmfName> = None;
        let mut served_guami_list: Option<ServedGuamiList> = None;
        let mut relative_amf_capacity: Option<RelativeAmfCapacity> = None;
        let mut plmn_support_list: Option<PlmnSupportList> = None;
        let mut criticality_diagnostics: Option<CriticalityDiagnostics> = None;
        let mut ue_retention_information: Option<UeRetentionInformation> = None;
        let mut iab_supported: Option<IabSupported> = None;
        let mut extended_amf_name: Option<ExtendedAmfName> = None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                1 => amf_name = Some(AmfName::decode(data)?),
                96 => served_guami_list = Some(ServedGuamiList::decode(data)?),
                86 => relative_amf_capacity = Some(RelativeAmfCapacity::decode(data)?),
                80 => plmn_support_list = Some(PlmnSupportList::decode(data)?),
                19 => criticality_diagnostics = Some(CriticalityDiagnostics::decode(data)?),
                147 => ue_retention_information = Some(UeRetentionInformation::decode(data)?),
                200 => iab_supported = Some(IabSupported::decode(data)?),
                274 => extended_amf_name = Some(ExtendedAmfName::decode(data)?),
                x => return Err(PerCodecError::new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        let amf_name =
            amf_name.ok_or(PerCodecError::new(format!("Missing mandatory IE amf_name")))?;
        let served_guami_list = served_guami_list.ok_or(PerCodecError::new(format!(
            "Missing mandatory IE served_guami_list"
        )))?;
        let relative_amf_capacity = relative_amf_capacity.ok_or(PerCodecError::new(format!(
            "Missing mandatory IE relative_amf_capacity"
        )))?;
        let plmn_support_list = plmn_support_list.ok_or(PerCodecError::new(format!(
            "Missing mandatory IE plmn_support_list"
        )))?;
        Ok(Self {
            amf_name,
            served_guami_list,
            relative_amf_capacity,
            plmn_support_list,
            criticality_diagnostics,
            ue_retention_information,
            iab_supported,
            extended_amf_name,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        let ie = &mut Allocator::new_codec_data();
        self.amf_name.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 1, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.served_guami_list.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 96, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.relative_amf_capacity.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 86, false)?;
        Criticality::Ignore.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.plmn_support_list.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 80, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        if let Some(x) = &self.criticality_diagnostics {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 19, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.ue_retention_information {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 147, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.iab_supported {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 200, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.extended_amf_name {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 274, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        encode::encode_sequence_header(data, true, &BitString::new(), false)?;
        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for NgSetupResponse {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        NgSetupResponse::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NgSetupResponse");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NgSetupResponse");
            e
        })
    }
}
// NgSetupFailure
#[derive(Clone, Debug)]
pub struct NgSetupFailure {
    pub cause: Cause,
    pub time_to_wait: Option<TimeToWait>,
    pub criticality_diagnostics: Option<CriticalityDiagnostics>,
}

impl NgSetupFailure {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let _ = decode::decode_sequence_header(data, true, 0)?;
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut cause: Option<Cause> = None;
        let mut time_to_wait: Option<TimeToWait> = None;
        let mut criticality_diagnostics: Option<CriticalityDiagnostics> = None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                15 => cause = Some(Cause::decode(data)?),
                107 => time_to_wait = Some(TimeToWait::decode(data)?),
                19 => criticality_diagnostics = Some(CriticalityDiagnostics::decode(data)?),
                x => return Err(PerCodecError::new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        let cause = cause.ok_or(PerCodecError::new(format!("Missing mandatory IE cause")))?;
        Ok(Self {
            cause,
            time_to_wait,
            criticality_diagnostics,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        let ie = &mut Allocator::new_codec_data();
        self.cause.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 15, false)?;
        Criticality::Ignore.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        if let Some(x) = &self.time_to_wait {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 107, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.criticality_diagnostics {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 19, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        encode::encode_sequence_header(data, true, &BitString::new(), false)?;
        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for NgSetupFailure {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        NgSetupFailure::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NgSetupFailure");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NgSetupFailure");
            e
        })
    }
}
// RanConfigurationUpdate
#[derive(Clone, Debug)]
pub struct RanConfigurationUpdate {
    pub ran_node_name: Option<RanNodeName>,
    pub supported_ta_list: Option<SupportedTaList>,
    pub default_paging_drx: Option<PagingDrx>,
    pub global_ran_node_id: Option<GlobalRanNodeId>,
    pub ngran_tnl_association_to_remove_list: Option<NgranTnlAssociationToRemoveList>,
    pub nb_iot_default_paging_drx: Option<NbIotDefaultPagingDrx>,
    pub extended_ran_node_name: Option<ExtendedRanNodeName>,
}

impl RanConfigurationUpdate {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let _ = decode::decode_sequence_header(data, true, 0)?;
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut ran_node_name: Option<RanNodeName> = None;
        let mut supported_ta_list: Option<SupportedTaList> = None;
        let mut default_paging_drx: Option<PagingDrx> = None;
        let mut global_ran_node_id: Option<GlobalRanNodeId> = None;
        let mut ngran_tnl_association_to_remove_list: Option<NgranTnlAssociationToRemoveList> =
            None;
        let mut nb_iot_default_paging_drx: Option<NbIotDefaultPagingDrx> = None;
        let mut extended_ran_node_name: Option<ExtendedRanNodeName> = None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                82 => ran_node_name = Some(RanNodeName::decode(data)?),
                102 => supported_ta_list = Some(SupportedTaList::decode(data)?),
                21 => default_paging_drx = Some(PagingDrx::decode(data)?),
                27 => global_ran_node_id = Some(GlobalRanNodeId::decode(data)?),
                167 => {
                    ngran_tnl_association_to_remove_list =
                        Some(NgranTnlAssociationToRemoveList::decode(data)?)
                }
                204 => nb_iot_default_paging_drx = Some(NbIotDefaultPagingDrx::decode(data)?),
                273 => extended_ran_node_name = Some(ExtendedRanNodeName::decode(data)?),
                x => return Err(PerCodecError::new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        Ok(Self {
            ran_node_name,
            supported_ta_list,
            default_paging_drx,
            global_ran_node_id,
            ngran_tnl_association_to_remove_list,
            nb_iot_default_paging_drx,
            extended_ran_node_name,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        if let Some(x) = &self.ran_node_name {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 82, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.supported_ta_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 102, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.default_paging_drx {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 21, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.global_ran_node_id {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 27, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.ngran_tnl_association_to_remove_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 167, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.nb_iot_default_paging_drx {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 204, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.extended_ran_node_name {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 273, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        encode::encode_sequence_header(data, true, &BitString::new(), false)?;
        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for RanConfigurationUpdate {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        RanConfigurationUpdate::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("RanConfigurationUpdate");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("RanConfigurationUpdate");
            e
        })
    }
}
// RanConfigurationUpdateAcknowledge
#[derive(Clone, Debug)]
pub struct RanConfigurationUpdateAcknowledge {
    pub criticality_diagnostics: Option<CriticalityDiagnostics>,
}

impl RanConfigurationUpdateAcknowledge {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let _ = decode::decode_sequence_header(data, true, 0)?;
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut criticality_diagnostics: Option<CriticalityDiagnostics> = None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                19 => criticality_diagnostics = Some(CriticalityDiagnostics::decode(data)?),
                x => return Err(PerCodecError::new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        Ok(Self {
            criticality_diagnostics,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        if let Some(x) = &self.criticality_diagnostics {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 19, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        encode::encode_sequence_header(data, true, &BitString::new(), false)?;
        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for RanConfigurationUpdateAcknowledge {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        RanConfigurationUpdateAcknowledge::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("RanConfigurationUpdateAcknowledge");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("RanConfigurationUpdateAcknowledge");
            e
        })
    }
}
// RanConfigurationUpdateFailure
#[derive(Clone, Debug)]
pub struct RanConfigurationUpdateFailure {
    pub cause: Cause,
    pub time_to_wait: Option<TimeToWait>,
    pub criticality_diagnostics: Option<CriticalityDiagnostics>,
}

impl RanConfigurationUpdateFailure {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let _ = decode::decode_sequence_header(data, true, 0)?;
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut cause: Option<Cause> = None;
        let mut time_to_wait: Option<TimeToWait> = None;
        let mut criticality_diagnostics: Option<CriticalityDiagnostics> = None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                15 => cause = Some(Cause::decode(data)?),
                107 => time_to_wait = Some(TimeToWait::decode(data)?),
                19 => criticality_diagnostics = Some(CriticalityDiagnostics::decode(data)?),
                x => return Err(PerCodecError::new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        let cause = cause.ok_or(PerCodecError::new(format!("Missing mandatory IE cause")))?;
        Ok(Self {
            cause,
            time_to_wait,
            criticality_diagnostics,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        let ie = &mut Allocator::new_codec_data();
        self.cause.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 15, false)?;
        Criticality::Ignore.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        if let Some(x) = &self.time_to_wait {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 107, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.criticality_diagnostics {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 19, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        encode::encode_sequence_header(data, true, &BitString::new(), false)?;
        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for RanConfigurationUpdateFailure {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        RanConfigurationUpdateFailure::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("RanConfigurationUpdateFailure");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("RanConfigurationUpdateFailure");
            e
        })
    }
}
// AmfConfigurationUpdate
#[derive(Clone, Debug)]
pub struct AmfConfigurationUpdate {
    pub amf_name: Option<AmfName>,
    pub served_guami_list: Option<ServedGuamiList>,
    pub relative_amf_capacity: Option<RelativeAmfCapacity>,
    pub plmn_support_list: Option<PlmnSupportList>,
    pub amf_tnl_association_to_add_list: Option<AmfTnlAssociationToAddList>,
    pub amf_tnl_association_to_remove_list: Option<AmfTnlAssociationToRemoveList>,
    pub amf_tnl_association_to_update_list: Option<AmfTnlAssociationToUpdateList>,
    pub extended_amf_name: Option<ExtendedAmfName>,
}

impl AmfConfigurationUpdate {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let _ = decode::decode_sequence_header(data, true, 0)?;
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut amf_name: Option<AmfName> = None;
        let mut served_guami_list: Option<ServedGuamiList> = None;
        let mut relative_amf_capacity: Option<RelativeAmfCapacity> = None;
        let mut plmn_support_list: Option<PlmnSupportList> = None;
        let mut amf_tnl_association_to_add_list: Option<AmfTnlAssociationToAddList> = None;
        let mut amf_tnl_association_to_remove_list: Option<AmfTnlAssociationToRemoveList> = None;
        let mut amf_tnl_association_to_update_list: Option<AmfTnlAssociationToUpdateList> = None;
        let mut extended_amf_name: Option<ExtendedAmfName> = None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                1 => amf_name = Some(AmfName::decode(data)?),
                96 => served_guami_list = Some(ServedGuamiList::decode(data)?),
                86 => relative_amf_capacity = Some(RelativeAmfCapacity::decode(data)?),
                80 => plmn_support_list = Some(PlmnSupportList::decode(data)?),
                6 => {
                    amf_tnl_association_to_add_list =
                        Some(AmfTnlAssociationToAddList::decode(data)?)
                }
                7 => {
                    amf_tnl_association_to_remove_list =
                        Some(AmfTnlAssociationToRemoveList::decode(data)?)
                }
                8 => {
                    amf_tnl_association_to_update_list =
                        Some(AmfTnlAssociationToUpdateList::decode(data)?)
                }
                274 => extended_amf_name = Some(ExtendedAmfName::decode(data)?),
                x => return Err(PerCodecError::new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        Ok(Self {
            amf_name,
            served_guami_list,
            relative_amf_capacity,
            plmn_support_list,
            amf_tnl_association_to_add_list,
            amf_tnl_association_to_remove_list,
            amf_tnl_association_to_update_list,
            extended_amf_name,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        if let Some(x) = &self.amf_name {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 1, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.served_guami_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 96, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.relative_amf_capacity {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 86, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.plmn_support_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 80, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.amf_tnl_association_to_add_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 6, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.amf_tnl_association_to_remove_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 7, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.amf_tnl_association_to_update_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 8, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.extended_amf_name {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 274, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        encode::encode_sequence_header(data, true, &BitString::new(), false)?;
        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for AmfConfigurationUpdate {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        AmfConfigurationUpdate::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("AmfConfigurationUpdate");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("AmfConfigurationUpdate");
            e
        })
    }
}
// AmfConfigurationUpdateAcknowledge
#[derive(Clone, Debug)]
pub struct AmfConfigurationUpdateAcknowledge {
    pub amf_tnl_association_setup_list: Option<AmfTnlAssociationSetupList>,
    pub amf_tnl_association_failed_to_setup_list: Option<TnlAssociationList>,
    pub criticality_diagnostics: Option<CriticalityDiagnostics>,
}

impl AmfConfigurationUpdateAcknowledge {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let _ = decode::decode_sequence_header(data, true, 0)?;
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut amf_tnl_association_setup_list: Option<AmfTnlAssociationSetupList> = None;
        let mut amf_tnl_association_failed_to_setup_list: Option<TnlAssociationList> = None;
        let mut criticality_diagnostics: Option<CriticalityDiagnostics> = None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                5 => {
                    amf_tnl_association_setup_list = Some(AmfTnlAssociationSetupList::decode(data)?)
                }
                4 => {
                    amf_tnl_association_failed_to_setup_list =
                        Some(TnlAssociationList::decode(data)?)
                }
                19 => criticality_diagnostics = Some(CriticalityDiagnostics::decode(data)?),
                x => return Err(PerCodecError::new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        Ok(Self {
            amf_tnl_association_setup_list,
            amf_tnl_association_failed_to_setup_list,
            criticality_diagnostics,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        if let Some(x) = &self.amf_tnl_association_setup_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 5, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.amf_tnl_association_failed_to_setup_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 4, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.criticality_diagnostics {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 19, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        encode::encode_sequence_header(data, true, &BitString::new(), false)?;
        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for AmfConfigurationUpdateAcknowledge {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        AmfConfigurationUpdateAcknowledge::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("AmfConfigurationUpdateAcknowledge");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("AmfConfigurationUpdateAcknowledge");
            e
        })
    }
}
// AmfConfigurationUpdateFailure
#[derive(Clone, Debug)]
pub struct AmfConfigurationUpdateFailure {
    pub cause: Cause,
    pub time_to_wait: Option<TimeToWait>,
    pub criticality_diagnostics: Option<CriticalityDiagnostics>,
}

impl AmfConfigurationUpdateFailure {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let _ = decode::decode_sequence_header(data, true, 0)?;
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut cause: Option<Cause> = None;
        let mut time_to_wait: Option<TimeToWait> = None;
        let mut criticality_diagnostics: Option<CriticalityDiagnostics> = None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                15 => cause = Some(Cause::decode(data)?),
                107 => time_to_wait = Some(TimeToWait::decode(data)?),
                19 => criticality_diagnostics = Some(CriticalityDiagnostics::decode(data)?),
                x => return Err(PerCodecError::new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        let cause = cause.ok_or(PerCodecError::new(format!("Missing mandatory IE cause")))?;
        Ok(Self {
            cause,
            time_to_wait,
            criticality_diagnostics,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        let ie = &mut Allocator::new_codec_data();
        self.cause.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 15, false)?;
        Criticality::Ignore.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        if let Some(x) = &self.time_to_wait {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 107, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.criticality_diagnostics {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 19, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        encode::encode_sequence_header(data, true, &BitString::new(), false)?;
        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for AmfConfigurationUpdateFailure {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        AmfConfigurationUpdateFailure::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("AmfConfigurationUpdateFailure");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("AmfConfigurationUpdateFailure");
            e
        })
    }
}
// AmfStatusIndication
#[derive(Clone, Debug)]
pub struct AmfStatusIndication {
    pub unavailable_guami_list: UnavailableGuamiList,
}

impl AmfStatusIndication {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let _ = decode::decode_sequence_header(data, true, 0)?;
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut unavailable_guami_list: Option<UnavailableGuamiList> = None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                120 => unavailable_guami_list = Some(UnavailableGuamiList::decode(data)?),
                x => return Err(PerCodecError::new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        let unavailable_guami_list = unavailable_guami_list.ok_or(PerCodecError::new(format!(
            "Missing mandatory IE unavailable_guami_list"
        )))?;
        Ok(Self {
            unavailable_guami_list,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        let ie = &mut Allocator::new_codec_data();
        self.unavailable_guami_list.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 120, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        encode::encode_sequence_header(data, true, &BitString::new(), false)?;
        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for AmfStatusIndication {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        AmfStatusIndication::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("AmfStatusIndication");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("AmfStatusIndication");
            e
        })
    }
}
// NgReset
#[derive(Clone, Debug)]
pub struct NgReset {
    pub cause: Cause,
    pub reset_type: ResetType,
}

impl NgReset {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let _ = decode::decode_sequence_header(data, true, 0)?;
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut cause: Option<Cause> = None;
        let mut reset_type: Option<ResetType> = None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                15 => cause = Some(Cause::decode(data)?),
                88 => reset_type = Some(ResetType::decode(data)?),
                x => return Err(PerCodecError::new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        let cause = cause.ok_or(PerCodecError::new(format!("Missing mandatory IE cause")))?;
        let reset_type = reset_type.ok_or(PerCodecError::new(format!(
            "Missing mandatory IE reset_type"
        )))?;
        Ok(Self { cause, reset_type })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        let ie = &mut Allocator::new_codec_data();
        self.cause.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 15, false)?;
        Criticality::Ignore.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.reset_type.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 88, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        encode::encode_sequence_header(data, true, &BitString::new(), false)?;
        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for NgReset {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        NgReset::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NgReset");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NgReset");
            e
        })
    }
}
// NgResetAcknowledge
#[derive(Clone, Debug)]
pub struct NgResetAcknowledge {
    pub ue_associated_logical_ng_connection_list: Option<UeAssociatedLogicalNgConnectionList>,
    pub criticality_diagnostics: Option<CriticalityDiagnostics>,
}

impl NgResetAcknowledge {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let _ = decode::decode_sequence_header(data, true, 0)?;
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut ue_associated_logical_ng_connection_list: Option<
            UeAssociatedLogicalNgConnectionList,
        > = None;
        let mut criticality_diagnostics: Option<CriticalityDiagnostics> = None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                111 => {
                    ue_associated_logical_ng_connection_list =
                        Some(UeAssociatedLogicalNgConnectionList::decode(data)?)
                }
                19 => criticality_diagnostics = Some(CriticalityDiagnostics::decode(data)?),
                x => return Err(PerCodecError::new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        Ok(Self {
            ue_associated_logical_ng_connection_list,
            criticality_diagnostics,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        if let Some(x) = &self.ue_associated_logical_ng_connection_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 111, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.criticality_diagnostics {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 19, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        encode::encode_sequence_header(data, true, &BitString::new(), false)?;
        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for NgResetAcknowledge {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        NgResetAcknowledge::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NgResetAcknowledge");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NgResetAcknowledge");
            e
        })
    }
}
// ErrorIndication
#[derive(Clone, Debug)]
pub struct ErrorIndication {
    pub amf_ue_ngap_id: Option<AmfUeNgapId>,
    pub ran_ue_ngap_id: Option<RanUeNgapId>,
    pub cause: Option<Cause>,
    pub criticality_diagnostics: Option<CriticalityDiagnostics>,
    pub five_g_s_tmsi: Option<FiveGSTmsi>,
}

impl ErrorIndication {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let _ = decode::decode_sequence_header(data, true, 0)?;
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut amf_ue_ngap_id: Option<AmfUeNgapId> = None;
        let mut ran_ue_ngap_id: Option<RanUeNgapId> = None;
        let mut cause: Option<Cause> = None;
        let mut criticality_diagnostics: Option<CriticalityDiagnostics> = None;
        let mut five_g_s_tmsi: Option<FiveGSTmsi> = None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                10 => amf_ue_ngap_id = Some(AmfUeNgapId::decode(data)?),
                85 => ran_ue_ngap_id = Some(RanUeNgapId::decode(data)?),
                15 => cause = Some(Cause::decode(data)?),
                19 => criticality_diagnostics = Some(CriticalityDiagnostics::decode(data)?),
                26 => five_g_s_tmsi = Some(FiveGSTmsi::decode(data)?),
                x => return Err(PerCodecError::new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        Ok(Self {
            amf_ue_ngap_id,
            ran_ue_ngap_id,
            cause,
            criticality_diagnostics,
            five_g_s_tmsi,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        if let Some(x) = &self.amf_ue_ngap_id {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 10, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.ran_ue_ngap_id {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 85, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.cause {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 15, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.criticality_diagnostics {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 19, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.five_g_s_tmsi {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 26, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        encode::encode_sequence_header(data, true, &BitString::new(), false)?;
        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for ErrorIndication {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        ErrorIndication::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ErrorIndication");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ErrorIndication");
            e
        })
    }
}
// OverloadStart
#[derive(Clone, Debug)]
pub struct OverloadStart {
    pub amf_overload_response: Option<OverloadResponse>,
    pub amf_traffic_load_reduction_indication: Option<TrafficLoadReductionIndication>,
    pub overload_start_nssai_list: Option<OverloadStartNssaiList>,
}

impl OverloadStart {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let _ = decode::decode_sequence_header(data, true, 0)?;
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut amf_overload_response: Option<OverloadResponse> = None;
        let mut amf_traffic_load_reduction_indication: Option<TrafficLoadReductionIndication> =
            None;
        let mut overload_start_nssai_list: Option<OverloadStartNssaiList> = None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                2 => amf_overload_response = Some(OverloadResponse::decode(data)?),
                9 => {
                    amf_traffic_load_reduction_indication =
                        Some(TrafficLoadReductionIndication::decode(data)?)
                }
                49 => overload_start_nssai_list = Some(OverloadStartNssaiList::decode(data)?),
                x => return Err(PerCodecError::new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        Ok(Self {
            amf_overload_response,
            amf_traffic_load_reduction_indication,
            overload_start_nssai_list,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        if let Some(x) = &self.amf_overload_response {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 2, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.amf_traffic_load_reduction_indication {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 9, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.overload_start_nssai_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 49, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        encode::encode_sequence_header(data, true, &BitString::new(), false)?;
        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for OverloadStart {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        OverloadStart::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("OverloadStart");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("OverloadStart");
            e
        })
    }
}
// OverloadStop
#[derive(Clone, Debug)]
pub struct OverloadStop {}

impl OverloadStop {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let _ = decode::decode_sequence_header(data, true, 0)?;
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                x => return Err(PerCodecError::new(format!("Unrecognised IE type {}", x))),
            }
        }
        Ok(Self {})
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        encode::encode_sequence_header(data, true, &BitString::new(), false)?;
        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for OverloadStop {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        OverloadStop::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("OverloadStop");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("OverloadStop");
            e
        })
    }
}
// UplinkRanConfigurationTransfer
#[derive(Clone, Debug)]
pub struct UplinkRanConfigurationTransfer {
    pub son_configuration_transfer_ul: Option<SonConfigurationTransfer>,
    pub endc_son_configuration_transfer_ul: Option<EnDcsonConfigurationTransfer>,
    pub intersystem_son_configuration_transfer_ul: Option<IntersystemSonConfigurationTransfer>,
}

impl UplinkRanConfigurationTransfer {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let _ = decode::decode_sequence_header(data, true, 0)?;
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut son_configuration_transfer_ul: Option<SonConfigurationTransfer> = None;
        let mut endc_son_configuration_transfer_ul: Option<EnDcsonConfigurationTransfer> = None;
        let mut intersystem_son_configuration_transfer_ul: Option<
            IntersystemSonConfigurationTransfer,
        > = None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                99 => son_configuration_transfer_ul = Some(SonConfigurationTransfer::decode(data)?),
                158 => {
                    endc_son_configuration_transfer_ul =
                        Some(EnDcsonConfigurationTransfer::decode(data)?)
                }
                251 => {
                    intersystem_son_configuration_transfer_ul =
                        Some(IntersystemSonConfigurationTransfer::decode(data)?)
                }
                x => return Err(PerCodecError::new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        Ok(Self {
            son_configuration_transfer_ul,
            endc_son_configuration_transfer_ul,
            intersystem_son_configuration_transfer_ul,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        if let Some(x) = &self.son_configuration_transfer_ul {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 99, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.endc_son_configuration_transfer_ul {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 158, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.intersystem_son_configuration_transfer_ul {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 251, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        encode::encode_sequence_header(data, true, &BitString::new(), false)?;
        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for UplinkRanConfigurationTransfer {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        UplinkRanConfigurationTransfer::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UplinkRanConfigurationTransfer");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UplinkRanConfigurationTransfer");
            e
        })
    }
}
// DownlinkRanConfigurationTransfer
#[derive(Clone, Debug)]
pub struct DownlinkRanConfigurationTransfer {
    pub son_configuration_transfer_dl: Option<SonConfigurationTransfer>,
    pub endc_son_configuration_transfer_dl: Option<EnDcsonConfigurationTransfer>,
    pub intersystem_son_configuration_transfer_dl: Option<IntersystemSonConfigurationTransfer>,
}

impl DownlinkRanConfigurationTransfer {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let _ = decode::decode_sequence_header(data, true, 0)?;
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut son_configuration_transfer_dl: Option<SonConfigurationTransfer> = None;
        let mut endc_son_configuration_transfer_dl: Option<EnDcsonConfigurationTransfer> = None;
        let mut intersystem_son_configuration_transfer_dl: Option<
            IntersystemSonConfigurationTransfer,
        > = None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                98 => son_configuration_transfer_dl = Some(SonConfigurationTransfer::decode(data)?),
                157 => {
                    endc_son_configuration_transfer_dl =
                        Some(EnDcsonConfigurationTransfer::decode(data)?)
                }
                250 => {
                    intersystem_son_configuration_transfer_dl =
                        Some(IntersystemSonConfigurationTransfer::decode(data)?)
                }
                x => return Err(PerCodecError::new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        Ok(Self {
            son_configuration_transfer_dl,
            endc_son_configuration_transfer_dl,
            intersystem_son_configuration_transfer_dl,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        if let Some(x) = &self.son_configuration_transfer_dl {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 98, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.endc_son_configuration_transfer_dl {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 157, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.intersystem_son_configuration_transfer_dl {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 250, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        encode::encode_sequence_header(data, true, &BitString::new(), false)?;
        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for DownlinkRanConfigurationTransfer {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        DownlinkRanConfigurationTransfer::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DownlinkRanConfigurationTransfer");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DownlinkRanConfigurationTransfer");
            e
        })
    }
}
// WriteReplaceWarningRequest
#[derive(Clone, Debug)]
pub struct WriteReplaceWarningRequest {
    pub message_identifier: MessageIdentifier,
    pub serial_number: SerialNumber,
    pub warning_area_list: Option<WarningAreaList>,
    pub repetition_period: RepetitionPeriod,
    pub number_of_broadcasts_requested: NumberOfBroadcastsRequested,
    pub warning_type: Option<WarningType>,
    pub warning_security_info: Option<WarningSecurityInfo>,
    pub data_coding_scheme: Option<DataCodingScheme>,
    pub warning_message_contents: Option<WarningMessageContents>,
    pub concurrent_warning_message_ind: Option<ConcurrentWarningMessageInd>,
    pub warning_area_coordinates: Option<WarningAreaCoordinates>,
}

impl WriteReplaceWarningRequest {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let _ = decode::decode_sequence_header(data, true, 0)?;
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut message_identifier: Option<MessageIdentifier> = None;
        let mut serial_number: Option<SerialNumber> = None;
        let mut warning_area_list: Option<WarningAreaList> = None;
        let mut repetition_period: Option<RepetitionPeriod> = None;
        let mut number_of_broadcasts_requested: Option<NumberOfBroadcastsRequested> = None;
        let mut warning_type: Option<WarningType> = None;
        let mut warning_security_info: Option<WarningSecurityInfo> = None;
        let mut data_coding_scheme: Option<DataCodingScheme> = None;
        let mut warning_message_contents: Option<WarningMessageContents> = None;
        let mut concurrent_warning_message_ind: Option<ConcurrentWarningMessageInd> = None;
        let mut warning_area_coordinates: Option<WarningAreaCoordinates> = None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                35 => message_identifier = Some(MessageIdentifier::decode(data)?),
                95 => serial_number = Some(SerialNumber::decode(data)?),
                122 => warning_area_list = Some(WarningAreaList::decode(data)?),
                87 => repetition_period = Some(RepetitionPeriod::decode(data)?),
                47 => {
                    number_of_broadcasts_requested =
                        Some(NumberOfBroadcastsRequested::decode(data)?)
                }
                125 => warning_type = Some(WarningType::decode(data)?),
                124 => warning_security_info = Some(WarningSecurityInfo::decode(data)?),
                20 => data_coding_scheme = Some(DataCodingScheme::decode(data)?),
                123 => warning_message_contents = Some(WarningMessageContents::decode(data)?),
                17 => {
                    concurrent_warning_message_ind =
                        Some(ConcurrentWarningMessageInd::decode(data)?)
                }
                141 => warning_area_coordinates = Some(WarningAreaCoordinates::decode(data)?),
                x => return Err(PerCodecError::new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        let message_identifier = message_identifier.ok_or(PerCodecError::new(format!(
            "Missing mandatory IE message_identifier"
        )))?;
        let serial_number = serial_number.ok_or(PerCodecError::new(format!(
            "Missing mandatory IE serial_number"
        )))?;
        let repetition_period = repetition_period.ok_or(PerCodecError::new(format!(
            "Missing mandatory IE repetition_period"
        )))?;
        let number_of_broadcasts_requested =
            number_of_broadcasts_requested.ok_or(PerCodecError::new(format!(
                "Missing mandatory IE number_of_broadcasts_requested"
            )))?;
        Ok(Self {
            message_identifier,
            serial_number,
            warning_area_list,
            repetition_period,
            number_of_broadcasts_requested,
            warning_type,
            warning_security_info,
            data_coding_scheme,
            warning_message_contents,
            concurrent_warning_message_ind,
            warning_area_coordinates,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        let ie = &mut Allocator::new_codec_data();
        self.message_identifier.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 35, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.serial_number.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 95, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        if let Some(x) = &self.warning_area_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 122, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        let ie = &mut Allocator::new_codec_data();
        self.repetition_period.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 87, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.number_of_broadcasts_requested.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 47, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        if let Some(x) = &self.warning_type {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 125, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.warning_security_info {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 124, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.data_coding_scheme {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 20, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.warning_message_contents {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 123, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.concurrent_warning_message_ind {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 17, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.warning_area_coordinates {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 141, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        encode::encode_sequence_header(data, true, &BitString::new(), false)?;
        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for WriteReplaceWarningRequest {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        WriteReplaceWarningRequest::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("WriteReplaceWarningRequest");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("WriteReplaceWarningRequest");
            e
        })
    }
}
// WriteReplaceWarningResponse
#[derive(Clone, Debug)]
pub struct WriteReplaceWarningResponse {
    pub message_identifier: MessageIdentifier,
    pub serial_number: SerialNumber,
    pub broadcast_completed_area_list: Option<BroadcastCompletedAreaList>,
    pub criticality_diagnostics: Option<CriticalityDiagnostics>,
}

impl WriteReplaceWarningResponse {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let _ = decode::decode_sequence_header(data, true, 0)?;
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut message_identifier: Option<MessageIdentifier> = None;
        let mut serial_number: Option<SerialNumber> = None;
        let mut broadcast_completed_area_list: Option<BroadcastCompletedAreaList> = None;
        let mut criticality_diagnostics: Option<CriticalityDiagnostics> = None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                35 => message_identifier = Some(MessageIdentifier::decode(data)?),
                95 => serial_number = Some(SerialNumber::decode(data)?),
                13 => {
                    broadcast_completed_area_list = Some(BroadcastCompletedAreaList::decode(data)?)
                }
                19 => criticality_diagnostics = Some(CriticalityDiagnostics::decode(data)?),
                x => return Err(PerCodecError::new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        let message_identifier = message_identifier.ok_or(PerCodecError::new(format!(
            "Missing mandatory IE message_identifier"
        )))?;
        let serial_number = serial_number.ok_or(PerCodecError::new(format!(
            "Missing mandatory IE serial_number"
        )))?;
        Ok(Self {
            message_identifier,
            serial_number,
            broadcast_completed_area_list,
            criticality_diagnostics,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        let ie = &mut Allocator::new_codec_data();
        self.message_identifier.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 35, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.serial_number.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 95, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        if let Some(x) = &self.broadcast_completed_area_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 13, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.criticality_diagnostics {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 19, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        encode::encode_sequence_header(data, true, &BitString::new(), false)?;
        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for WriteReplaceWarningResponse {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        WriteReplaceWarningResponse::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("WriteReplaceWarningResponse");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("WriteReplaceWarningResponse");
            e
        })
    }
}
// PwsCancelRequest
#[derive(Clone, Debug)]
pub struct PwsCancelRequest {
    pub message_identifier: MessageIdentifier,
    pub serial_number: SerialNumber,
    pub warning_area_list: Option<WarningAreaList>,
    pub cancel_all_warning_messages: Option<CancelAllWarningMessages>,
}

impl PwsCancelRequest {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let _ = decode::decode_sequence_header(data, true, 0)?;
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut message_identifier: Option<MessageIdentifier> = None;
        let mut serial_number: Option<SerialNumber> = None;
        let mut warning_area_list: Option<WarningAreaList> = None;
        let mut cancel_all_warning_messages: Option<CancelAllWarningMessages> = None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                35 => message_identifier = Some(MessageIdentifier::decode(data)?),
                95 => serial_number = Some(SerialNumber::decode(data)?),
                122 => warning_area_list = Some(WarningAreaList::decode(data)?),
                14 => cancel_all_warning_messages = Some(CancelAllWarningMessages::decode(data)?),
                x => return Err(PerCodecError::new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        let message_identifier = message_identifier.ok_or(PerCodecError::new(format!(
            "Missing mandatory IE message_identifier"
        )))?;
        let serial_number = serial_number.ok_or(PerCodecError::new(format!(
            "Missing mandatory IE serial_number"
        )))?;
        Ok(Self {
            message_identifier,
            serial_number,
            warning_area_list,
            cancel_all_warning_messages,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        let ie = &mut Allocator::new_codec_data();
        self.message_identifier.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 35, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.serial_number.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 95, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        if let Some(x) = &self.warning_area_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 122, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.cancel_all_warning_messages {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 14, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        encode::encode_sequence_header(data, true, &BitString::new(), false)?;
        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for PwsCancelRequest {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PwsCancelRequest::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PwsCancelRequest");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PwsCancelRequest");
            e
        })
    }
}
// PwsCancelResponse
#[derive(Clone, Debug)]
pub struct PwsCancelResponse {
    pub message_identifier: MessageIdentifier,
    pub serial_number: SerialNumber,
    pub broadcast_cancelled_area_list: Option<BroadcastCancelledAreaList>,
    pub criticality_diagnostics: Option<CriticalityDiagnostics>,
}

impl PwsCancelResponse {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let _ = decode::decode_sequence_header(data, true, 0)?;
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut message_identifier: Option<MessageIdentifier> = None;
        let mut serial_number: Option<SerialNumber> = None;
        let mut broadcast_cancelled_area_list: Option<BroadcastCancelledAreaList> = None;
        let mut criticality_diagnostics: Option<CriticalityDiagnostics> = None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                35 => message_identifier = Some(MessageIdentifier::decode(data)?),
                95 => serial_number = Some(SerialNumber::decode(data)?),
                12 => {
                    broadcast_cancelled_area_list = Some(BroadcastCancelledAreaList::decode(data)?)
                }
                19 => criticality_diagnostics = Some(CriticalityDiagnostics::decode(data)?),
                x => return Err(PerCodecError::new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        let message_identifier = message_identifier.ok_or(PerCodecError::new(format!(
            "Missing mandatory IE message_identifier"
        )))?;
        let serial_number = serial_number.ok_or(PerCodecError::new(format!(
            "Missing mandatory IE serial_number"
        )))?;
        Ok(Self {
            message_identifier,
            serial_number,
            broadcast_cancelled_area_list,
            criticality_diagnostics,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        let ie = &mut Allocator::new_codec_data();
        self.message_identifier.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 35, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.serial_number.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 95, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        if let Some(x) = &self.broadcast_cancelled_area_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 12, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.criticality_diagnostics {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 19, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        encode::encode_sequence_header(data, true, &BitString::new(), false)?;
        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for PwsCancelResponse {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PwsCancelResponse::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PwsCancelResponse");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PwsCancelResponse");
            e
        })
    }
}
// PwsRestartIndication
#[derive(Clone, Debug)]
pub struct PwsRestartIndication {
    pub cell_id_list_for_restart: CellIdListForRestart,
    pub global_ran_node_id: GlobalRanNodeId,
    pub tai_list_for_restart: TaiListForRestart,
    pub emergency_area_id_list_for_restart: Option<EmergencyAreaIdListForRestart>,
}

impl PwsRestartIndication {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let _ = decode::decode_sequence_header(data, true, 0)?;
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut cell_id_list_for_restart: Option<CellIdListForRestart> = None;
        let mut global_ran_node_id: Option<GlobalRanNodeId> = None;
        let mut tai_list_for_restart: Option<TaiListForRestart> = None;
        let mut emergency_area_id_list_for_restart: Option<EmergencyAreaIdListForRestart> = None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                16 => cell_id_list_for_restart = Some(CellIdListForRestart::decode(data)?),
                27 => global_ran_node_id = Some(GlobalRanNodeId::decode(data)?),
                104 => tai_list_for_restart = Some(TaiListForRestart::decode(data)?),
                23 => {
                    emergency_area_id_list_for_restart =
                        Some(EmergencyAreaIdListForRestart::decode(data)?)
                }
                x => return Err(PerCodecError::new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        let cell_id_list_for_restart = cell_id_list_for_restart.ok_or(PerCodecError::new(
            format!("Missing mandatory IE cell_id_list_for_restart"),
        ))?;
        let global_ran_node_id = global_ran_node_id.ok_or(PerCodecError::new(format!(
            "Missing mandatory IE global_ran_node_id"
        )))?;
        let tai_list_for_restart = tai_list_for_restart.ok_or(PerCodecError::new(format!(
            "Missing mandatory IE tai_list_for_restart"
        )))?;
        Ok(Self {
            cell_id_list_for_restart,
            global_ran_node_id,
            tai_list_for_restart,
            emergency_area_id_list_for_restart,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        let ie = &mut Allocator::new_codec_data();
        self.cell_id_list_for_restart.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 16, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.global_ran_node_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 27, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.tai_list_for_restart.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 104, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        if let Some(x) = &self.emergency_area_id_list_for_restart {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 23, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        encode::encode_sequence_header(data, true, &BitString::new(), false)?;
        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for PwsRestartIndication {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PwsRestartIndication::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PwsRestartIndication");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PwsRestartIndication");
            e
        })
    }
}
// PwsFailureIndication
#[derive(Clone, Debug)]
pub struct PwsFailureIndication {
    pub pws_failed_cell_id_list: PwsFailedCellIdList,
    pub global_ran_node_id: GlobalRanNodeId,
}

impl PwsFailureIndication {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let _ = decode::decode_sequence_header(data, true, 0)?;
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut pws_failed_cell_id_list: Option<PwsFailedCellIdList> = None;
        let mut global_ran_node_id: Option<GlobalRanNodeId> = None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                81 => pws_failed_cell_id_list = Some(PwsFailedCellIdList::decode(data)?),
                27 => global_ran_node_id = Some(GlobalRanNodeId::decode(data)?),
                x => return Err(PerCodecError::new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        let pws_failed_cell_id_list = pws_failed_cell_id_list.ok_or(PerCodecError::new(
            format!("Missing mandatory IE pws_failed_cell_id_list"),
        ))?;
        let global_ran_node_id = global_ran_node_id.ok_or(PerCodecError::new(format!(
            "Missing mandatory IE global_ran_node_id"
        )))?;
        Ok(Self {
            pws_failed_cell_id_list,
            global_ran_node_id,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        let ie = &mut Allocator::new_codec_data();
        self.pws_failed_cell_id_list.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 81, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.global_ran_node_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 27, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        encode::encode_sequence_header(data, true, &BitString::new(), false)?;
        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for PwsFailureIndication {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PwsFailureIndication::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PwsFailureIndication");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PwsFailureIndication");
            e
        })
    }
}
// DownlinkUeAssociatedNrPPaTransport
#[derive(Clone, Debug)]
pub struct DownlinkUeAssociatedNrPPaTransport {
    pub amf_ue_ngap_id: AmfUeNgapId,
    pub ran_ue_ngap_id: RanUeNgapId,
    pub routing_id: RoutingId,
    pub nr_p_pa_pdu: NrPPaPdu,
}

impl DownlinkUeAssociatedNrPPaTransport {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let _ = decode::decode_sequence_header(data, true, 0)?;
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut amf_ue_ngap_id: Option<AmfUeNgapId> = None;
        let mut ran_ue_ngap_id: Option<RanUeNgapId> = None;
        let mut routing_id: Option<RoutingId> = None;
        let mut nr_p_pa_pdu: Option<NrPPaPdu> = None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                10 => amf_ue_ngap_id = Some(AmfUeNgapId::decode(data)?),
                85 => ran_ue_ngap_id = Some(RanUeNgapId::decode(data)?),
                89 => routing_id = Some(RoutingId::decode(data)?),
                46 => nr_p_pa_pdu = Some(NrPPaPdu::decode(data)?),
                x => return Err(PerCodecError::new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        let amf_ue_ngap_id = amf_ue_ngap_id.ok_or(PerCodecError::new(format!(
            "Missing mandatory IE amf_ue_ngap_id"
        )))?;
        let ran_ue_ngap_id = ran_ue_ngap_id.ok_or(PerCodecError::new(format!(
            "Missing mandatory IE ran_ue_ngap_id"
        )))?;
        let routing_id = routing_id.ok_or(PerCodecError::new(format!(
            "Missing mandatory IE routing_id"
        )))?;
        let nr_p_pa_pdu = nr_p_pa_pdu.ok_or(PerCodecError::new(format!(
            "Missing mandatory IE nr_p_pa_pdu"
        )))?;
        Ok(Self {
            amf_ue_ngap_id,
            ran_ue_ngap_id,
            routing_id,
            nr_p_pa_pdu,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        let ie = &mut Allocator::new_codec_data();
        self.amf_ue_ngap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 10, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.ran_ue_ngap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 85, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.routing_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 89, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.nr_p_pa_pdu.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 46, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        encode::encode_sequence_header(data, true, &BitString::new(), false)?;
        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for DownlinkUeAssociatedNrPPaTransport {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        DownlinkUeAssociatedNrPPaTransport::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DownlinkUeAssociatedNrPPaTransport");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DownlinkUeAssociatedNrPPaTransport");
            e
        })
    }
}
// UplinkUeAssociatedNrPPaTransport
#[derive(Clone, Debug)]
pub struct UplinkUeAssociatedNrPPaTransport {
    pub amf_ue_ngap_id: AmfUeNgapId,
    pub ran_ue_ngap_id: RanUeNgapId,
    pub routing_id: RoutingId,
    pub nr_p_pa_pdu: NrPPaPdu,
}

impl UplinkUeAssociatedNrPPaTransport {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let _ = decode::decode_sequence_header(data, true, 0)?;
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut amf_ue_ngap_id: Option<AmfUeNgapId> = None;
        let mut ran_ue_ngap_id: Option<RanUeNgapId> = None;
        let mut routing_id: Option<RoutingId> = None;
        let mut nr_p_pa_pdu: Option<NrPPaPdu> = None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                10 => amf_ue_ngap_id = Some(AmfUeNgapId::decode(data)?),
                85 => ran_ue_ngap_id = Some(RanUeNgapId::decode(data)?),
                89 => routing_id = Some(RoutingId::decode(data)?),
                46 => nr_p_pa_pdu = Some(NrPPaPdu::decode(data)?),
                x => return Err(PerCodecError::new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        let amf_ue_ngap_id = amf_ue_ngap_id.ok_or(PerCodecError::new(format!(
            "Missing mandatory IE amf_ue_ngap_id"
        )))?;
        let ran_ue_ngap_id = ran_ue_ngap_id.ok_or(PerCodecError::new(format!(
            "Missing mandatory IE ran_ue_ngap_id"
        )))?;
        let routing_id = routing_id.ok_or(PerCodecError::new(format!(
            "Missing mandatory IE routing_id"
        )))?;
        let nr_p_pa_pdu = nr_p_pa_pdu.ok_or(PerCodecError::new(format!(
            "Missing mandatory IE nr_p_pa_pdu"
        )))?;
        Ok(Self {
            amf_ue_ngap_id,
            ran_ue_ngap_id,
            routing_id,
            nr_p_pa_pdu,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        let ie = &mut Allocator::new_codec_data();
        self.amf_ue_ngap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 10, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.ran_ue_ngap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 85, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.routing_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 89, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.nr_p_pa_pdu.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 46, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        encode::encode_sequence_header(data, true, &BitString::new(), false)?;
        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for UplinkUeAssociatedNrPPaTransport {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        UplinkUeAssociatedNrPPaTransport::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UplinkUeAssociatedNrPPaTransport");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UplinkUeAssociatedNrPPaTransport");
            e
        })
    }
}
// DownlinkNonUeAssociatedNrPPaTransport
#[derive(Clone, Debug)]
pub struct DownlinkNonUeAssociatedNrPPaTransport {
    pub routing_id: RoutingId,
    pub nr_p_pa_pdu: NrPPaPdu,
}

impl DownlinkNonUeAssociatedNrPPaTransport {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let _ = decode::decode_sequence_header(data, true, 0)?;
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut routing_id: Option<RoutingId> = None;
        let mut nr_p_pa_pdu: Option<NrPPaPdu> = None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                89 => routing_id = Some(RoutingId::decode(data)?),
                46 => nr_p_pa_pdu = Some(NrPPaPdu::decode(data)?),
                x => return Err(PerCodecError::new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        let routing_id = routing_id.ok_or(PerCodecError::new(format!(
            "Missing mandatory IE routing_id"
        )))?;
        let nr_p_pa_pdu = nr_p_pa_pdu.ok_or(PerCodecError::new(format!(
            "Missing mandatory IE nr_p_pa_pdu"
        )))?;
        Ok(Self {
            routing_id,
            nr_p_pa_pdu,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        let ie = &mut Allocator::new_codec_data();
        self.routing_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 89, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.nr_p_pa_pdu.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 46, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        encode::encode_sequence_header(data, true, &BitString::new(), false)?;
        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for DownlinkNonUeAssociatedNrPPaTransport {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        DownlinkNonUeAssociatedNrPPaTransport::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DownlinkNonUeAssociatedNrPPaTransport");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DownlinkNonUeAssociatedNrPPaTransport");
            e
        })
    }
}
// UplinkNonUeAssociatedNrPPaTransport
#[derive(Clone, Debug)]
pub struct UplinkNonUeAssociatedNrPPaTransport {
    pub routing_id: RoutingId,
    pub nr_p_pa_pdu: NrPPaPdu,
}

impl UplinkNonUeAssociatedNrPPaTransport {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let _ = decode::decode_sequence_header(data, true, 0)?;
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut routing_id: Option<RoutingId> = None;
        let mut nr_p_pa_pdu: Option<NrPPaPdu> = None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                89 => routing_id = Some(RoutingId::decode(data)?),
                46 => nr_p_pa_pdu = Some(NrPPaPdu::decode(data)?),
                x => return Err(PerCodecError::new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        let routing_id = routing_id.ok_or(PerCodecError::new(format!(
            "Missing mandatory IE routing_id"
        )))?;
        let nr_p_pa_pdu = nr_p_pa_pdu.ok_or(PerCodecError::new(format!(
            "Missing mandatory IE nr_p_pa_pdu"
        )))?;
        Ok(Self {
            routing_id,
            nr_p_pa_pdu,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        let ie = &mut Allocator::new_codec_data();
        self.routing_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 89, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.nr_p_pa_pdu.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 46, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        encode::encode_sequence_header(data, true, &BitString::new(), false)?;
        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for UplinkNonUeAssociatedNrPPaTransport {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        UplinkNonUeAssociatedNrPPaTransport::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UplinkNonUeAssociatedNrPPaTransport");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UplinkNonUeAssociatedNrPPaTransport");
            e
        })
    }
}
// TraceStart
#[derive(Clone, Debug)]
pub struct TraceStart {
    pub amf_ue_ngap_id: AmfUeNgapId,
    pub ran_ue_ngap_id: RanUeNgapId,
    pub trace_activation: TraceActivation,
}

impl TraceStart {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let _ = decode::decode_sequence_header(data, true, 0)?;
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut amf_ue_ngap_id: Option<AmfUeNgapId> = None;
        let mut ran_ue_ngap_id: Option<RanUeNgapId> = None;
        let mut trace_activation: Option<TraceActivation> = None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                10 => amf_ue_ngap_id = Some(AmfUeNgapId::decode(data)?),
                85 => ran_ue_ngap_id = Some(RanUeNgapId::decode(data)?),
                108 => trace_activation = Some(TraceActivation::decode(data)?),
                x => return Err(PerCodecError::new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        let amf_ue_ngap_id = amf_ue_ngap_id.ok_or(PerCodecError::new(format!(
            "Missing mandatory IE amf_ue_ngap_id"
        )))?;
        let ran_ue_ngap_id = ran_ue_ngap_id.ok_or(PerCodecError::new(format!(
            "Missing mandatory IE ran_ue_ngap_id"
        )))?;
        let trace_activation = trace_activation.ok_or(PerCodecError::new(format!(
            "Missing mandatory IE trace_activation"
        )))?;
        Ok(Self {
            amf_ue_ngap_id,
            ran_ue_ngap_id,
            trace_activation,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        let ie = &mut Allocator::new_codec_data();
        self.amf_ue_ngap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 10, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.ran_ue_ngap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 85, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.trace_activation.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 108, false)?;
        Criticality::Ignore.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        encode::encode_sequence_header(data, true, &BitString::new(), false)?;
        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for TraceStart {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        TraceStart::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TraceStart");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TraceStart");
            e
        })
    }
}
// TraceFailureIndication
#[derive(Clone, Debug)]
pub struct TraceFailureIndication {
    pub amf_ue_ngap_id: AmfUeNgapId,
    pub ran_ue_ngap_id: RanUeNgapId,
    pub ngran_trace_id: NgranTraceId,
    pub cause: Cause,
}

impl TraceFailureIndication {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let _ = decode::decode_sequence_header(data, true, 0)?;
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut amf_ue_ngap_id: Option<AmfUeNgapId> = None;
        let mut ran_ue_ngap_id: Option<RanUeNgapId> = None;
        let mut ngran_trace_id: Option<NgranTraceId> = None;
        let mut cause: Option<Cause> = None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                10 => amf_ue_ngap_id = Some(AmfUeNgapId::decode(data)?),
                85 => ran_ue_ngap_id = Some(RanUeNgapId::decode(data)?),
                44 => ngran_trace_id = Some(NgranTraceId::decode(data)?),
                15 => cause = Some(Cause::decode(data)?),
                x => return Err(PerCodecError::new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        let amf_ue_ngap_id = amf_ue_ngap_id.ok_or(PerCodecError::new(format!(
            "Missing mandatory IE amf_ue_ngap_id"
        )))?;
        let ran_ue_ngap_id = ran_ue_ngap_id.ok_or(PerCodecError::new(format!(
            "Missing mandatory IE ran_ue_ngap_id"
        )))?;
        let ngran_trace_id = ngran_trace_id.ok_or(PerCodecError::new(format!(
            "Missing mandatory IE ngran_trace_id"
        )))?;
        let cause = cause.ok_or(PerCodecError::new(format!("Missing mandatory IE cause")))?;
        Ok(Self {
            amf_ue_ngap_id,
            ran_ue_ngap_id,
            ngran_trace_id,
            cause,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        let ie = &mut Allocator::new_codec_data();
        self.amf_ue_ngap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 10, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.ran_ue_ngap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 85, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.ngran_trace_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 44, false)?;
        Criticality::Ignore.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.cause.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 15, false)?;
        Criticality::Ignore.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        encode::encode_sequence_header(data, true, &BitString::new(), false)?;
        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for TraceFailureIndication {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        TraceFailureIndication::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TraceFailureIndication");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TraceFailureIndication");
            e
        })
    }
}
// DeactivateTrace
#[derive(Clone, Debug)]
pub struct DeactivateTrace {
    pub amf_ue_ngap_id: AmfUeNgapId,
    pub ran_ue_ngap_id: RanUeNgapId,
    pub ngran_trace_id: NgranTraceId,
}

impl DeactivateTrace {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let _ = decode::decode_sequence_header(data, true, 0)?;
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut amf_ue_ngap_id: Option<AmfUeNgapId> = None;
        let mut ran_ue_ngap_id: Option<RanUeNgapId> = None;
        let mut ngran_trace_id: Option<NgranTraceId> = None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                10 => amf_ue_ngap_id = Some(AmfUeNgapId::decode(data)?),
                85 => ran_ue_ngap_id = Some(RanUeNgapId::decode(data)?),
                44 => ngran_trace_id = Some(NgranTraceId::decode(data)?),
                x => return Err(PerCodecError::new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        let amf_ue_ngap_id = amf_ue_ngap_id.ok_or(PerCodecError::new(format!(
            "Missing mandatory IE amf_ue_ngap_id"
        )))?;
        let ran_ue_ngap_id = ran_ue_ngap_id.ok_or(PerCodecError::new(format!(
            "Missing mandatory IE ran_ue_ngap_id"
        )))?;
        let ngran_trace_id = ngran_trace_id.ok_or(PerCodecError::new(format!(
            "Missing mandatory IE ngran_trace_id"
        )))?;
        Ok(Self {
            amf_ue_ngap_id,
            ran_ue_ngap_id,
            ngran_trace_id,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        let ie = &mut Allocator::new_codec_data();
        self.amf_ue_ngap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 10, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.ran_ue_ngap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 85, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.ngran_trace_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 44, false)?;
        Criticality::Ignore.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        encode::encode_sequence_header(data, true, &BitString::new(), false)?;
        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for DeactivateTrace {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        DeactivateTrace::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DeactivateTrace");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DeactivateTrace");
            e
        })
    }
}
// CellTrafficTrace
#[derive(Clone, Debug)]
pub struct CellTrafficTrace {
    pub amf_ue_ngap_id: AmfUeNgapId,
    pub ran_ue_ngap_id: RanUeNgapId,
    pub ngran_trace_id: NgranTraceId,
    pub ngran_cgi: NgranCgi,
    pub trace_collection_entity_ip_address: TransportLayerAddress,
    pub privacy_indicator: Option<PrivacyIndicator>,
    pub trace_collection_entity_uri: Option<UriAddress>,
}

impl CellTrafficTrace {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let _ = decode::decode_sequence_header(data, true, 0)?;
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut amf_ue_ngap_id: Option<AmfUeNgapId> = None;
        let mut ran_ue_ngap_id: Option<RanUeNgapId> = None;
        let mut ngran_trace_id: Option<NgranTraceId> = None;
        let mut ngran_cgi: Option<NgranCgi> = None;
        let mut trace_collection_entity_ip_address: Option<TransportLayerAddress> = None;
        let mut privacy_indicator: Option<PrivacyIndicator> = None;
        let mut trace_collection_entity_uri: Option<UriAddress> = None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                10 => amf_ue_ngap_id = Some(AmfUeNgapId::decode(data)?),
                85 => ran_ue_ngap_id = Some(RanUeNgapId::decode(data)?),
                44 => ngran_trace_id = Some(NgranTraceId::decode(data)?),
                43 => ngran_cgi = Some(NgranCgi::decode(data)?),
                109 => {
                    trace_collection_entity_ip_address = Some(TransportLayerAddress::decode(data)?)
                }
                256 => privacy_indicator = Some(PrivacyIndicator::decode(data)?),
                257 => trace_collection_entity_uri = Some(UriAddress::decode(data)?),
                x => return Err(PerCodecError::new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        let amf_ue_ngap_id = amf_ue_ngap_id.ok_or(PerCodecError::new(format!(
            "Missing mandatory IE amf_ue_ngap_id"
        )))?;
        let ran_ue_ngap_id = ran_ue_ngap_id.ok_or(PerCodecError::new(format!(
            "Missing mandatory IE ran_ue_ngap_id"
        )))?;
        let ngran_trace_id = ngran_trace_id.ok_or(PerCodecError::new(format!(
            "Missing mandatory IE ngran_trace_id"
        )))?;
        let ngran_cgi = ngran_cgi.ok_or(PerCodecError::new(format!(
            "Missing mandatory IE ngran_cgi"
        )))?;
        let trace_collection_entity_ip_address =
            trace_collection_entity_ip_address.ok_or(PerCodecError::new(format!(
                "Missing mandatory IE trace_collection_entity_ip_address"
            )))?;
        Ok(Self {
            amf_ue_ngap_id,
            ran_ue_ngap_id,
            ngran_trace_id,
            ngran_cgi,
            trace_collection_entity_ip_address,
            privacy_indicator,
            trace_collection_entity_uri,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        let ie = &mut Allocator::new_codec_data();
        self.amf_ue_ngap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 10, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.ran_ue_ngap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 85, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.ngran_trace_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 44, false)?;
        Criticality::Ignore.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.ngran_cgi.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 43, false)?;
        Criticality::Ignore.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.trace_collection_entity_ip_address.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 109, false)?;
        Criticality::Ignore.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        if let Some(x) = &self.privacy_indicator {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 256, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.trace_collection_entity_uri {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 257, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        encode::encode_sequence_header(data, true, &BitString::new(), false)?;
        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for CellTrafficTrace {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        CellTrafficTrace::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CellTrafficTrace");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CellTrafficTrace");
            e
        })
    }
}
// LocationReportingControl
#[derive(Clone, Debug)]
pub struct LocationReportingControl {
    pub amf_ue_ngap_id: AmfUeNgapId,
    pub ran_ue_ngap_id: RanUeNgapId,
    pub location_reporting_request_type: LocationReportingRequestType,
}

impl LocationReportingControl {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let _ = decode::decode_sequence_header(data, true, 0)?;
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut amf_ue_ngap_id: Option<AmfUeNgapId> = None;
        let mut ran_ue_ngap_id: Option<RanUeNgapId> = None;
        let mut location_reporting_request_type: Option<LocationReportingRequestType> = None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                10 => amf_ue_ngap_id = Some(AmfUeNgapId::decode(data)?),
                85 => ran_ue_ngap_id = Some(RanUeNgapId::decode(data)?),
                33 => {
                    location_reporting_request_type =
                        Some(LocationReportingRequestType::decode(data)?)
                }
                x => return Err(PerCodecError::new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        let amf_ue_ngap_id = amf_ue_ngap_id.ok_or(PerCodecError::new(format!(
            "Missing mandatory IE amf_ue_ngap_id"
        )))?;
        let ran_ue_ngap_id = ran_ue_ngap_id.ok_or(PerCodecError::new(format!(
            "Missing mandatory IE ran_ue_ngap_id"
        )))?;
        let location_reporting_request_type =
            location_reporting_request_type.ok_or(PerCodecError::new(format!(
                "Missing mandatory IE location_reporting_request_type"
            )))?;
        Ok(Self {
            amf_ue_ngap_id,
            ran_ue_ngap_id,
            location_reporting_request_type,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        let ie = &mut Allocator::new_codec_data();
        self.amf_ue_ngap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 10, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.ran_ue_ngap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 85, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.location_reporting_request_type.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 33, false)?;
        Criticality::Ignore.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        encode::encode_sequence_header(data, true, &BitString::new(), false)?;
        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for LocationReportingControl {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        LocationReportingControl::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("LocationReportingControl");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("LocationReportingControl");
            e
        })
    }
}
// LocationReportingFailureIndication
#[derive(Clone, Debug)]
pub struct LocationReportingFailureIndication {
    pub amf_ue_ngap_id: AmfUeNgapId,
    pub ran_ue_ngap_id: RanUeNgapId,
    pub cause: Cause,
}

impl LocationReportingFailureIndication {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let _ = decode::decode_sequence_header(data, true, 0)?;
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut amf_ue_ngap_id: Option<AmfUeNgapId> = None;
        let mut ran_ue_ngap_id: Option<RanUeNgapId> = None;
        let mut cause: Option<Cause> = None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                10 => amf_ue_ngap_id = Some(AmfUeNgapId::decode(data)?),
                85 => ran_ue_ngap_id = Some(RanUeNgapId::decode(data)?),
                15 => cause = Some(Cause::decode(data)?),
                x => return Err(PerCodecError::new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        let amf_ue_ngap_id = amf_ue_ngap_id.ok_or(PerCodecError::new(format!(
            "Missing mandatory IE amf_ue_ngap_id"
        )))?;
        let ran_ue_ngap_id = ran_ue_ngap_id.ok_or(PerCodecError::new(format!(
            "Missing mandatory IE ran_ue_ngap_id"
        )))?;
        let cause = cause.ok_or(PerCodecError::new(format!("Missing mandatory IE cause")))?;
        Ok(Self {
            amf_ue_ngap_id,
            ran_ue_ngap_id,
            cause,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        let ie = &mut Allocator::new_codec_data();
        self.amf_ue_ngap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 10, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.ran_ue_ngap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 85, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.cause.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 15, false)?;
        Criticality::Ignore.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        encode::encode_sequence_header(data, true, &BitString::new(), false)?;
        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for LocationReportingFailureIndication {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        LocationReportingFailureIndication::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("LocationReportingFailureIndication");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("LocationReportingFailureIndication");
            e
        })
    }
}
// LocationReport
#[derive(Clone, Debug)]
pub struct LocationReport {
    pub amf_ue_ngap_id: AmfUeNgapId,
    pub ran_ue_ngap_id: RanUeNgapId,
    pub user_location_information: UserLocationInformation,
    pub ue_presence_in_area_of_interest_list: Option<UePresenceInAreaOfInterestList>,
    pub location_reporting_request_type: LocationReportingRequestType,
}

impl LocationReport {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let _ = decode::decode_sequence_header(data, true, 0)?;
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut amf_ue_ngap_id: Option<AmfUeNgapId> = None;
        let mut ran_ue_ngap_id: Option<RanUeNgapId> = None;
        let mut user_location_information: Option<UserLocationInformation> = None;
        let mut ue_presence_in_area_of_interest_list: Option<UePresenceInAreaOfInterestList> = None;
        let mut location_reporting_request_type: Option<LocationReportingRequestType> = None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                10 => amf_ue_ngap_id = Some(AmfUeNgapId::decode(data)?),
                85 => ran_ue_ngap_id = Some(RanUeNgapId::decode(data)?),
                121 => user_location_information = Some(UserLocationInformation::decode(data)?),
                116 => {
                    ue_presence_in_area_of_interest_list =
                        Some(UePresenceInAreaOfInterestList::decode(data)?)
                }
                33 => {
                    location_reporting_request_type =
                        Some(LocationReportingRequestType::decode(data)?)
                }
                x => return Err(PerCodecError::new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        let amf_ue_ngap_id = amf_ue_ngap_id.ok_or(PerCodecError::new(format!(
            "Missing mandatory IE amf_ue_ngap_id"
        )))?;
        let ran_ue_ngap_id = ran_ue_ngap_id.ok_or(PerCodecError::new(format!(
            "Missing mandatory IE ran_ue_ngap_id"
        )))?;
        let user_location_information = user_location_information.ok_or(PerCodecError::new(
            format!("Missing mandatory IE user_location_information"),
        ))?;
        let location_reporting_request_type =
            location_reporting_request_type.ok_or(PerCodecError::new(format!(
                "Missing mandatory IE location_reporting_request_type"
            )))?;
        Ok(Self {
            amf_ue_ngap_id,
            ran_ue_ngap_id,
            user_location_information,
            ue_presence_in_area_of_interest_list,
            location_reporting_request_type,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        let ie = &mut Allocator::new_codec_data();
        self.amf_ue_ngap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 10, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.ran_ue_ngap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 85, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.user_location_information.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 121, false)?;
        Criticality::Ignore.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        if let Some(x) = &self.ue_presence_in_area_of_interest_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 116, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        let ie = &mut Allocator::new_codec_data();
        self.location_reporting_request_type.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 33, false)?;
        Criticality::Ignore.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        encode::encode_sequence_header(data, true, &BitString::new(), false)?;
        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for LocationReport {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        LocationReport::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("LocationReport");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("LocationReport");
            e
        })
    }
}
// UeTnlaBindingReleaseRequest
#[derive(Clone, Debug)]
pub struct UeTnlaBindingReleaseRequest {
    pub amf_ue_ngap_id: AmfUeNgapId,
    pub ran_ue_ngap_id: RanUeNgapId,
}

impl UeTnlaBindingReleaseRequest {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let _ = decode::decode_sequence_header(data, true, 0)?;
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut amf_ue_ngap_id: Option<AmfUeNgapId> = None;
        let mut ran_ue_ngap_id: Option<RanUeNgapId> = None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                10 => amf_ue_ngap_id = Some(AmfUeNgapId::decode(data)?),
                85 => ran_ue_ngap_id = Some(RanUeNgapId::decode(data)?),
                x => return Err(PerCodecError::new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        let amf_ue_ngap_id = amf_ue_ngap_id.ok_or(PerCodecError::new(format!(
            "Missing mandatory IE amf_ue_ngap_id"
        )))?;
        let ran_ue_ngap_id = ran_ue_ngap_id.ok_or(PerCodecError::new(format!(
            "Missing mandatory IE ran_ue_ngap_id"
        )))?;
        Ok(Self {
            amf_ue_ngap_id,
            ran_ue_ngap_id,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        let ie = &mut Allocator::new_codec_data();
        self.amf_ue_ngap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 10, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.ran_ue_ngap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 85, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        encode::encode_sequence_header(data, true, &BitString::new(), false)?;
        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for UeTnlaBindingReleaseRequest {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        UeTnlaBindingReleaseRequest::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UeTnlaBindingReleaseRequest");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UeTnlaBindingReleaseRequest");
            e
        })
    }
}
// UeRadioCapabilityInfoIndication
#[derive(Clone, Debug)]
pub struct UeRadioCapabilityInfoIndication {
    pub amf_ue_ngap_id: AmfUeNgapId,
    pub ran_ue_ngap_id: RanUeNgapId,
    pub ue_radio_capability: UeRadioCapability,
    pub ue_radio_capability_for_paging: Option<UeRadioCapabilityForPaging>,
    pub ue_radio_capability_eutra_format: Option<UeRadioCapability>,
}

impl UeRadioCapabilityInfoIndication {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let _ = decode::decode_sequence_header(data, true, 0)?;
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut amf_ue_ngap_id: Option<AmfUeNgapId> = None;
        let mut ran_ue_ngap_id: Option<RanUeNgapId> = None;
        let mut ue_radio_capability: Option<UeRadioCapability> = None;
        let mut ue_radio_capability_for_paging: Option<UeRadioCapabilityForPaging> = None;
        let mut ue_radio_capability_eutra_format: Option<UeRadioCapability> = None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                10 => amf_ue_ngap_id = Some(AmfUeNgapId::decode(data)?),
                85 => ran_ue_ngap_id = Some(RanUeNgapId::decode(data)?),
                117 => ue_radio_capability = Some(UeRadioCapability::decode(data)?),
                118 => {
                    ue_radio_capability_for_paging = Some(UeRadioCapabilityForPaging::decode(data)?)
                }
                265 => ue_radio_capability_eutra_format = Some(UeRadioCapability::decode(data)?),
                x => return Err(PerCodecError::new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        let amf_ue_ngap_id = amf_ue_ngap_id.ok_or(PerCodecError::new(format!(
            "Missing mandatory IE amf_ue_ngap_id"
        )))?;
        let ran_ue_ngap_id = ran_ue_ngap_id.ok_or(PerCodecError::new(format!(
            "Missing mandatory IE ran_ue_ngap_id"
        )))?;
        let ue_radio_capability = ue_radio_capability.ok_or(PerCodecError::new(format!(
            "Missing mandatory IE ue_radio_capability"
        )))?;
        Ok(Self {
            amf_ue_ngap_id,
            ran_ue_ngap_id,
            ue_radio_capability,
            ue_radio_capability_for_paging,
            ue_radio_capability_eutra_format,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        let ie = &mut Allocator::new_codec_data();
        self.amf_ue_ngap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 10, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.ran_ue_ngap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 85, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.ue_radio_capability.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 117, false)?;
        Criticality::Ignore.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        if let Some(x) = &self.ue_radio_capability_for_paging {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 118, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.ue_radio_capability_eutra_format {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 265, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        encode::encode_sequence_header(data, true, &BitString::new(), false)?;
        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for UeRadioCapabilityInfoIndication {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        UeRadioCapabilityInfoIndication::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UeRadioCapabilityInfoIndication");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UeRadioCapabilityInfoIndication");
            e
        })
    }
}
// UeRadioCapabilityCheckRequest
#[derive(Clone, Debug)]
pub struct UeRadioCapabilityCheckRequest {
    pub amf_ue_ngap_id: AmfUeNgapId,
    pub ran_ue_ngap_id: RanUeNgapId,
    pub ue_radio_capability: Option<UeRadioCapability>,
    pub ue_radio_capability_id: Option<UeRadioCapabilityId>,
}

impl UeRadioCapabilityCheckRequest {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let _ = decode::decode_sequence_header(data, true, 0)?;
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut amf_ue_ngap_id: Option<AmfUeNgapId> = None;
        let mut ran_ue_ngap_id: Option<RanUeNgapId> = None;
        let mut ue_radio_capability: Option<UeRadioCapability> = None;
        let mut ue_radio_capability_id: Option<UeRadioCapabilityId> = None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                10 => amf_ue_ngap_id = Some(AmfUeNgapId::decode(data)?),
                85 => ran_ue_ngap_id = Some(RanUeNgapId::decode(data)?),
                117 => ue_radio_capability = Some(UeRadioCapability::decode(data)?),
                264 => ue_radio_capability_id = Some(UeRadioCapabilityId::decode(data)?),
                x => return Err(PerCodecError::new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        let amf_ue_ngap_id = amf_ue_ngap_id.ok_or(PerCodecError::new(format!(
            "Missing mandatory IE amf_ue_ngap_id"
        )))?;
        let ran_ue_ngap_id = ran_ue_ngap_id.ok_or(PerCodecError::new(format!(
            "Missing mandatory IE ran_ue_ngap_id"
        )))?;
        Ok(Self {
            amf_ue_ngap_id,
            ran_ue_ngap_id,
            ue_radio_capability,
            ue_radio_capability_id,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        let ie = &mut Allocator::new_codec_data();
        self.amf_ue_ngap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 10, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.ran_ue_ngap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 85, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        if let Some(x) = &self.ue_radio_capability {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 117, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.ue_radio_capability_id {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 264, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        encode::encode_sequence_header(data, true, &BitString::new(), false)?;
        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for UeRadioCapabilityCheckRequest {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        UeRadioCapabilityCheckRequest::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UeRadioCapabilityCheckRequest");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UeRadioCapabilityCheckRequest");
            e
        })
    }
}
// UeRadioCapabilityCheckResponse
#[derive(Clone, Debug)]
pub struct UeRadioCapabilityCheckResponse {
    pub amf_ue_ngap_id: AmfUeNgapId,
    pub ran_ue_ngap_id: RanUeNgapId,
    pub ims_voice_support_indicator: ImsVoiceSupportIndicator,
    pub criticality_diagnostics: Option<CriticalityDiagnostics>,
}

impl UeRadioCapabilityCheckResponse {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let _ = decode::decode_sequence_header(data, true, 0)?;
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut amf_ue_ngap_id: Option<AmfUeNgapId> = None;
        let mut ran_ue_ngap_id: Option<RanUeNgapId> = None;
        let mut ims_voice_support_indicator: Option<ImsVoiceSupportIndicator> = None;
        let mut criticality_diagnostics: Option<CriticalityDiagnostics> = None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                10 => amf_ue_ngap_id = Some(AmfUeNgapId::decode(data)?),
                85 => ran_ue_ngap_id = Some(RanUeNgapId::decode(data)?),
                30 => ims_voice_support_indicator = Some(ImsVoiceSupportIndicator::decode(data)?),
                19 => criticality_diagnostics = Some(CriticalityDiagnostics::decode(data)?),
                x => return Err(PerCodecError::new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        let amf_ue_ngap_id = amf_ue_ngap_id.ok_or(PerCodecError::new(format!(
            "Missing mandatory IE amf_ue_ngap_id"
        )))?;
        let ran_ue_ngap_id = ran_ue_ngap_id.ok_or(PerCodecError::new(format!(
            "Missing mandatory IE ran_ue_ngap_id"
        )))?;
        let ims_voice_support_indicator = ims_voice_support_indicator.ok_or(PerCodecError::new(
            format!("Missing mandatory IE ims_voice_support_indicator"),
        ))?;
        Ok(Self {
            amf_ue_ngap_id,
            ran_ue_ngap_id,
            ims_voice_support_indicator,
            criticality_diagnostics,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        let ie = &mut Allocator::new_codec_data();
        self.amf_ue_ngap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 10, false)?;
        Criticality::Ignore.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.ran_ue_ngap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 85, false)?;
        Criticality::Ignore.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.ims_voice_support_indicator.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 30, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        if let Some(x) = &self.criticality_diagnostics {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 19, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        encode::encode_sequence_header(data, true, &BitString::new(), false)?;
        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for UeRadioCapabilityCheckResponse {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        UeRadioCapabilityCheckResponse::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UeRadioCapabilityCheckResponse");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UeRadioCapabilityCheckResponse");
            e
        })
    }
}
// PrivateMessage
#[derive(Clone, Debug)]
pub struct PrivateMessage {}

impl PrivateMessage {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (_optionals, _extensions_present) = decode::decode_sequence_header(data, true, 0)?;

        Ok(Self {})
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let optionals = BitString::new();

        encode::encode_sequence_header(data, true, &optionals, false)?;

        Ok(())
    }
}

impl PerCodec for PrivateMessage {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PrivateMessage::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PrivateMessage");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PrivateMessage");
            e
        })
    }
}
// SecondaryRatDataUsageReport
#[derive(Clone, Debug)]
pub struct SecondaryRatDataUsageReport {
    pub amf_ue_ngap_id: AmfUeNgapId,
    pub ran_ue_ngap_id: RanUeNgapId,
    pub pdu_session_resource_secondary_rat_usage_list: PduSessionResourceSecondaryRatUsageList,
    pub handover_flag: Option<HandoverFlag>,
    pub user_location_information: Option<UserLocationInformation>,
}

impl SecondaryRatDataUsageReport {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let _ = decode::decode_sequence_header(data, true, 0)?;
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut amf_ue_ngap_id: Option<AmfUeNgapId> = None;
        let mut ran_ue_ngap_id: Option<RanUeNgapId> = None;
        let mut pdu_session_resource_secondary_rat_usage_list: Option<
            PduSessionResourceSecondaryRatUsageList,
        > = None;
        let mut handover_flag: Option<HandoverFlag> = None;
        let mut user_location_information: Option<UserLocationInformation> = None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                10 => amf_ue_ngap_id = Some(AmfUeNgapId::decode(data)?),
                85 => ran_ue_ngap_id = Some(RanUeNgapId::decode(data)?),
                142 => {
                    pdu_session_resource_secondary_rat_usage_list =
                        Some(PduSessionResourceSecondaryRatUsageList::decode(data)?)
                }
                143 => handover_flag = Some(HandoverFlag::decode(data)?),
                121 => user_location_information = Some(UserLocationInformation::decode(data)?),
                x => return Err(PerCodecError::new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        let amf_ue_ngap_id = amf_ue_ngap_id.ok_or(PerCodecError::new(format!(
            "Missing mandatory IE amf_ue_ngap_id"
        )))?;
        let ran_ue_ngap_id = ran_ue_ngap_id.ok_or(PerCodecError::new(format!(
            "Missing mandatory IE ran_ue_ngap_id"
        )))?;
        let pdu_session_resource_secondary_rat_usage_list =
            pdu_session_resource_secondary_rat_usage_list.ok_or(PerCodecError::new(format!(
                "Missing mandatory IE pdu_session_resource_secondary_rat_usage_list"
            )))?;
        Ok(Self {
            amf_ue_ngap_id,
            ran_ue_ngap_id,
            pdu_session_resource_secondary_rat_usage_list,
            handover_flag,
            user_location_information,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        let ie = &mut Allocator::new_codec_data();
        self.amf_ue_ngap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 10, false)?;
        Criticality::Ignore.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.ran_ue_ngap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 85, false)?;
        Criticality::Ignore.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.pdu_session_resource_secondary_rat_usage_list
            .encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 142, false)?;
        Criticality::Ignore.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        if let Some(x) = &self.handover_flag {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 143, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.user_location_information {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 121, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        encode::encode_sequence_header(data, true, &BitString::new(), false)?;
        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for SecondaryRatDataUsageReport {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        SecondaryRatDataUsageReport::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SecondaryRatDataUsageReport");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SecondaryRatDataUsageReport");
            e
        })
    }
}
// UplinkRimInformationTransfer
#[derive(Clone, Debug)]
pub struct UplinkRimInformationTransfer {
    pub rim_information_transfer: Option<RimInformationTransfer>,
}

impl UplinkRimInformationTransfer {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let _ = decode::decode_sequence_header(data, true, 0)?;
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut rim_information_transfer: Option<RimInformationTransfer> = None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                175 => rim_information_transfer = Some(RimInformationTransfer::decode(data)?),
                x => return Err(PerCodecError::new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        Ok(Self {
            rim_information_transfer,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        if let Some(x) = &self.rim_information_transfer {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 175, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        encode::encode_sequence_header(data, true, &BitString::new(), false)?;
        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for UplinkRimInformationTransfer {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        UplinkRimInformationTransfer::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UplinkRimInformationTransfer");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UplinkRimInformationTransfer");
            e
        })
    }
}
// DownlinkRimInformationTransfer
#[derive(Clone, Debug)]
pub struct DownlinkRimInformationTransfer {
    pub rim_information_transfer: Option<RimInformationTransfer>,
}

impl DownlinkRimInformationTransfer {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let _ = decode::decode_sequence_header(data, true, 0)?;
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut rim_information_transfer: Option<RimInformationTransfer> = None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                175 => rim_information_transfer = Some(RimInformationTransfer::decode(data)?),
                x => return Err(PerCodecError::new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        Ok(Self {
            rim_information_transfer,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        if let Some(x) = &self.rim_information_transfer {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 175, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        encode::encode_sequence_header(data, true, &BitString::new(), false)?;
        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for DownlinkRimInformationTransfer {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        DownlinkRimInformationTransfer::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DownlinkRimInformationTransfer");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DownlinkRimInformationTransfer");
            e
        })
    }
}
// ConnectionEstablishmentIndication
#[derive(Clone, Debug)]
pub struct ConnectionEstablishmentIndication {
    pub amf_ue_ngap_id: AmfUeNgapId,
    pub ran_ue_ngap_id: RanUeNgapId,
    pub ue_radio_capability: Option<UeRadioCapability>,
    pub end_indication: Option<EndIndication>,
    pub snssai: Option<Snssai>,
    pub allowed_nssai: Option<AllowedNssai>,
    pub ue_differentiation_info: Option<UeDifferentiationInfo>,
    pub dl_cp_security_information: Option<DlCpSecurityInformation>,
    pub nb_iot_ue_priority: Option<NbIotUePriority>,
    pub enhanced_coverage_restriction: Option<EnhancedCoverageRestriction>,
    pub c_emode_brestricted: Option<CEmodeBrestricted>,
    pub ue_radio_capability_id: Option<UeRadioCapabilityId>,
}

impl ConnectionEstablishmentIndication {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let _ = decode::decode_sequence_header(data, true, 0)?;
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut amf_ue_ngap_id: Option<AmfUeNgapId> = None;
        let mut ran_ue_ngap_id: Option<RanUeNgapId> = None;
        let mut ue_radio_capability: Option<UeRadioCapability> = None;
        let mut end_indication: Option<EndIndication> = None;
        let mut snssai: Option<Snssai> = None;
        let mut allowed_nssai: Option<AllowedNssai> = None;
        let mut ue_differentiation_info: Option<UeDifferentiationInfo> = None;
        let mut dl_cp_security_information: Option<DlCpSecurityInformation> = None;
        let mut nb_iot_ue_priority: Option<NbIotUePriority> = None;
        let mut enhanced_coverage_restriction: Option<EnhancedCoverageRestriction> = None;
        let mut c_emode_brestricted: Option<CEmodeBrestricted> = None;
        let mut ue_radio_capability_id: Option<UeRadioCapabilityId> = None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                10 => amf_ue_ngap_id = Some(AmfUeNgapId::decode(data)?),
                85 => ran_ue_ngap_id = Some(RanUeNgapId::decode(data)?),
                117 => ue_radio_capability = Some(UeRadioCapability::decode(data)?),
                226 => end_indication = Some(EndIndication::decode(data)?),
                148 => snssai = Some(Snssai::decode(data)?),
                0 => allowed_nssai = Some(AllowedNssai::decode(data)?),
                209 => ue_differentiation_info = Some(UeDifferentiationInfo::decode(data)?),
                212 => dl_cp_security_information = Some(DlCpSecurityInformation::decode(data)?),
                210 => nb_iot_ue_priority = Some(NbIotUePriority::decode(data)?),
                205 => {
                    enhanced_coverage_restriction = Some(EnhancedCoverageRestriction::decode(data)?)
                }
                222 => c_emode_brestricted = Some(CEmodeBrestricted::decode(data)?),
                264 => ue_radio_capability_id = Some(UeRadioCapabilityId::decode(data)?),
                x => return Err(PerCodecError::new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        let amf_ue_ngap_id = amf_ue_ngap_id.ok_or(PerCodecError::new(format!(
            "Missing mandatory IE amf_ue_ngap_id"
        )))?;
        let ran_ue_ngap_id = ran_ue_ngap_id.ok_or(PerCodecError::new(format!(
            "Missing mandatory IE ran_ue_ngap_id"
        )))?;
        Ok(Self {
            amf_ue_ngap_id,
            ran_ue_ngap_id,
            ue_radio_capability,
            end_indication,
            snssai,
            allowed_nssai,
            ue_differentiation_info,
            dl_cp_security_information,
            nb_iot_ue_priority,
            enhanced_coverage_restriction,
            c_emode_brestricted,
            ue_radio_capability_id,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        let ie = &mut Allocator::new_codec_data();
        self.amf_ue_ngap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 10, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.ran_ue_ngap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 85, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        if let Some(x) = &self.ue_radio_capability {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 117, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.end_indication {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 226, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.snssai {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 148, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.allowed_nssai {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 0, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.ue_differentiation_info {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 209, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.dl_cp_security_information {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 212, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.nb_iot_ue_priority {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 210, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.enhanced_coverage_restriction {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 205, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.c_emode_brestricted {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 222, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.ue_radio_capability_id {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 264, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        encode::encode_sequence_header(data, true, &BitString::new(), false)?;
        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for ConnectionEstablishmentIndication {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        ConnectionEstablishmentIndication::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ConnectionEstablishmentIndication");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ConnectionEstablishmentIndication");
            e
        })
    }
}
// UeRadioCapabilityIdMappingRequest
#[derive(Clone, Debug)]
pub struct UeRadioCapabilityIdMappingRequest {
    pub ue_radio_capability_id: UeRadioCapabilityId,
}

impl UeRadioCapabilityIdMappingRequest {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let _ = decode::decode_sequence_header(data, true, 0)?;
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut ue_radio_capability_id: Option<UeRadioCapabilityId> = None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                264 => ue_radio_capability_id = Some(UeRadioCapabilityId::decode(data)?),
                x => return Err(PerCodecError::new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        let ue_radio_capability_id = ue_radio_capability_id.ok_or(PerCodecError::new(format!(
            "Missing mandatory IE ue_radio_capability_id"
        )))?;
        Ok(Self {
            ue_radio_capability_id,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        let ie = &mut Allocator::new_codec_data();
        self.ue_radio_capability_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 264, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        encode::encode_sequence_header(data, true, &BitString::new(), false)?;
        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for UeRadioCapabilityIdMappingRequest {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        UeRadioCapabilityIdMappingRequest::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UeRadioCapabilityIdMappingRequest");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UeRadioCapabilityIdMappingRequest");
            e
        })
    }
}
// UeRadioCapabilityIdMappingResponse
#[derive(Clone, Debug)]
pub struct UeRadioCapabilityIdMappingResponse {
    pub ue_radio_capability_id: UeRadioCapabilityId,
    pub ue_radio_capability: UeRadioCapability,
    pub criticality_diagnostics: Option<CriticalityDiagnostics>,
}

impl UeRadioCapabilityIdMappingResponse {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let _ = decode::decode_sequence_header(data, true, 0)?;
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut ue_radio_capability_id: Option<UeRadioCapabilityId> = None;
        let mut ue_radio_capability: Option<UeRadioCapability> = None;
        let mut criticality_diagnostics: Option<CriticalityDiagnostics> = None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                264 => ue_radio_capability_id = Some(UeRadioCapabilityId::decode(data)?),
                117 => ue_radio_capability = Some(UeRadioCapability::decode(data)?),
                19 => criticality_diagnostics = Some(CriticalityDiagnostics::decode(data)?),
                x => return Err(PerCodecError::new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        let ue_radio_capability_id = ue_radio_capability_id.ok_or(PerCodecError::new(format!(
            "Missing mandatory IE ue_radio_capability_id"
        )))?;
        let ue_radio_capability = ue_radio_capability.ok_or(PerCodecError::new(format!(
            "Missing mandatory IE ue_radio_capability"
        )))?;
        Ok(Self {
            ue_radio_capability_id,
            ue_radio_capability,
            criticality_diagnostics,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        let ie = &mut Allocator::new_codec_data();
        self.ue_radio_capability_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 264, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.ue_radio_capability.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 117, false)?;
        Criticality::Ignore.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        if let Some(x) = &self.criticality_diagnostics {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 19, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        encode::encode_sequence_header(data, true, &BitString::new(), false)?;
        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for UeRadioCapabilityIdMappingResponse {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        UeRadioCapabilityIdMappingResponse::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UeRadioCapabilityIdMappingResponse");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UeRadioCapabilityIdMappingResponse");
            e
        })
    }
}
// AmfcpRelocationIndication
#[derive(Clone, Debug)]
pub struct AmfcpRelocationIndication {
    pub amf_ue_ngap_id: AmfUeNgapId,
    pub ran_ue_ngap_id: RanUeNgapId,
    pub snssai: Option<Snssai>,
    pub allowed_nssai: Option<AllowedNssai>,
}

impl AmfcpRelocationIndication {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let _ = decode::decode_sequence_header(data, true, 0)?;
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut amf_ue_ngap_id: Option<AmfUeNgapId> = None;
        let mut ran_ue_ngap_id: Option<RanUeNgapId> = None;
        let mut snssai: Option<Snssai> = None;
        let mut allowed_nssai: Option<AllowedNssai> = None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                10 => amf_ue_ngap_id = Some(AmfUeNgapId::decode(data)?),
                85 => ran_ue_ngap_id = Some(RanUeNgapId::decode(data)?),
                148 => snssai = Some(Snssai::decode(data)?),
                0 => allowed_nssai = Some(AllowedNssai::decode(data)?),
                x => return Err(PerCodecError::new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        let amf_ue_ngap_id = amf_ue_ngap_id.ok_or(PerCodecError::new(format!(
            "Missing mandatory IE amf_ue_ngap_id"
        )))?;
        let ran_ue_ngap_id = ran_ue_ngap_id.ok_or(PerCodecError::new(format!(
            "Missing mandatory IE ran_ue_ngap_id"
        )))?;
        Ok(Self {
            amf_ue_ngap_id,
            ran_ue_ngap_id,
            snssai,
            allowed_nssai,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        let ie = &mut Allocator::new_codec_data();
        self.amf_ue_ngap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 10, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.ran_ue_ngap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 85, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        if let Some(x) = &self.snssai {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 148, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.allowed_nssai {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 0, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        encode::encode_sequence_header(data, true, &BitString::new(), false)?;
        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for AmfcpRelocationIndication {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        AmfcpRelocationIndication::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("AmfcpRelocationIndication");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("AmfcpRelocationIndication");
            e
        })
    }
}
