// Copyright (c) Nicholas Larkin
// Autogenerated from F1AP-CommonDataTypes.asn
use bitvec::prelude::*;
pub type BitString = BitVec<Msb0, u8>;
use asn1_codecs::aper::{self, AperCodec, AperCodecData, AperCodecError};
use num_enum::TryFromPrimitive;



// Criticality
#[derive(Clone, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum Criticality {
    Reject,
    Ignore,
    Notify,
}

impl AperCodec for Criticality {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self::Output, AperCodecError> {
        let (idx, extended) = aper::decode::decode_enumerated(data, Some(0), Some(2), false)?;
        if extended {
            return Err(aper::AperCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| AperCodecError::new("Unknown enum variant"))
    }
}


// Presence
#[derive(Clone, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum Presence {
    Optional,
    Conditional,
    Mandatory,
}

impl AperCodec for Presence {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self::Output, AperCodecError> {
        let (idx, extended) = aper::decode::decode_enumerated(data, Some(0), Some(2), false)?;
        if extended {
            return Err(aper::AperCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| AperCodecError::new("Unknown enum variant"))
    }
}


// PrivateIeId
#[derive(Clone)]
pub enum PrivateIeId {
    Local(u16),
    Global(Vec<u8>),
}

impl AperCodec for PrivateIeId {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self::Output, AperCodecError> {
        let (idx, extended) = aper::decode::decode_choice_idx(data, 0, 1, false)?;
        if extended {
            return Err(aper::AperCodecError::new("CHOICE additions not implemented"))
        }
        match idx {
            0 => Ok(Self::Local(aper::decode::decode_integer(data, Some(0), Some(65535), false)?.0 as u16)),
            1 => Ok(Self::Global(aper::decode::decode_octetstring(data, None, None, false)?)),
            _ => Err(AperCodecError::new("Unknown choice idx"))
        }
    }
}


// ProcedureCode
#[derive(Clone)]
pub struct ProcedureCode(pub u8);

impl AperCodec for ProcedureCode {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self::Output, AperCodecError> {
        Ok(Self(aper::decode::decode_integer(data, Some(0), Some(255), false)?.0 as u8))
    }
}


// ProtocolExtensionId
#[derive(Clone)]
pub struct ProtocolExtensionId(pub u16);

impl AperCodec for ProtocolExtensionId {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self::Output, AperCodecError> {
        Ok(Self(aper::decode::decode_integer(data, Some(0), Some(65535), false)?.0 as u16))
    }
}


// ProtocolIeId
#[derive(Clone)]
pub struct ProtocolIeId(pub u16);

impl AperCodec for ProtocolIeId {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self::Output, AperCodecError> {
        Ok(Self(aper::decode::decode_integer(data, Some(0), Some(65535), false)?.0 as u16))
    }
}


// TriggeringMessage
#[derive(Clone, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum TriggeringMessage {
    InitiatingMessage,
    SuccessfulOutcome,
    UnsuccessfulOutcome,
}

impl AperCodec for TriggeringMessage {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self::Output, AperCodecError> {
        let (idx, extended) = aper::decode::decode_enumerated(data, Some(0), Some(2), false)?;
        if extended {
            return Err(aper::AperCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| AperCodecError::new("Unknown enum variant"))
    }
}

