// Copyright (c) Nicholas Larkin
// Autogenerated from F1AP-IEs.asn
use super::common::*;
use asn1::BitString;
use asn1::aper::{
    APerElement, Constraint, Constraints, DecodeError, Decoder, EncodeError, Encoding,
    UNCONSTRAINED,
};
use num_derive::FromPrimitive;
use num_traits::FromPrimitive;
// UriAddress
pub struct UriAddress(pub String);

impl APerElement for UriAddress {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, constraints: Constraints) -> Result<Self, DecodeError> {
        Ok(Self(String::from_aper(decoder, Self::CONSTRAINTS)?))
    }
    fn to_aper(&self, constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&(self.0).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// VictimGnbSetId
pub struct VictimGnbSetId {
    pub victim_gnb_set_id: GnbSetId,
}

impl APerElement for VictimGnbSetId {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(1),
        }),
    };
    fn from_aper(decoder: &mut Decoder, constraints: Constraints) -> Result<Self, DecodeError> {
        
        let optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let victim_gnb_set_id = GnbSetId::from_aper(decoder, UNCONSTRAINED)?;

        Ok(Self {
            victim_gnb_set_id,
        })
    }
    fn to_aper(&self, constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(1);

        
        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&self.victim_gnb_set_id.to_aper(UNCONSTRAINED)?);

        Ok(enc)
    }
}

// VehicleUE
# [derive(Clone, Copy, FromPrimitive)]
pub enum VehicleUE {
    Authorized,
    NotAuthorized,
    Extended,
}

impl APerElement for VehicleUE {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, constraints: Constraints) -> Result<Self, DecodeError> {
        if bool::from_aper(decoder, Self::CONSTRAINTS)? {
            Ok(VehicleUE::Extended)
        } else {
            let v = u8::from_aper(decoder, Self::CONSTRAINTS)?;
            FromPrimitive::from_u8(v).ok_or(DecodeError::MalformedInt)
        }
    }
    fn to_aper(&self, constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&false.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&(*self as u8).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// PedestrianUE
# [derive(Clone, Copy, FromPrimitive)]
pub enum PedestrianUE {
    Authorized,
    NotAuthorized,
    Extended,
}

impl APerElement for PedestrianUE {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, constraints: Constraints) -> Result<Self, DecodeError> {
        if bool::from_aper(decoder, Self::CONSTRAINTS)? {
            Ok(PedestrianUE::Extended)
        } else {
            let v = u8::from_aper(decoder, Self::CONSTRAINTS)?;
            FromPrimitive::from_u8(v).ok_or(DecodeError::MalformedInt)
        }
    }
    fn to_aper(&self, constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&false.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&(*self as u8).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// LatitudeSign
# [derive(Clone, Copy, FromPrimitive)]
pub enum LatitudeSign {
    North,
    South,
}

impl APerElement for LatitudeSign {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, constraints: Constraints) -> Result<Self, DecodeError> {
        if bool::from_aper(decoder, Self::CONSTRAINTS)? {
            Ok(LatitudeSign::Extended)
        } else {
            let v = u8::from_aper(decoder, Self::CONSTRAINTS)?;
            FromPrimitive::from_u8(v).ok_or(DecodeError::MalformedInt)
        }
    }
    fn to_aper(&self, constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&false.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&(*self as u8).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// DirectionOfAltitude
# [derive(Clone, Copy, FromPrimitive)]
pub enum DirectionOfAltitude {
    Height,
    Depth,
}

impl APerElement for DirectionOfAltitude {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, constraints: Constraints) -> Result<Self, DecodeError> {
        if bool::from_aper(decoder, Self::CONSTRAINTS)? {
            Ok(DirectionOfAltitude::Extended)
        } else {
            let v = u8::from_aper(decoder, Self::CONSTRAINTS)?;
            FromPrimitive::from_u8(v).ok_or(DecodeError::MalformedInt)
        }
    }
    fn to_aper(&self, constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&false.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&(*self as u8).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// SubcarrierSpacing
# [derive(Clone, Copy, FromPrimitive)]
pub enum SubcarrierSpacing {
    KHz15,
    KHz30,
    KHz60,
    KHz120,
    Extended,
}

impl APerElement for SubcarrierSpacing {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, constraints: Constraints) -> Result<Self, DecodeError> {
        if bool::from_aper(decoder, Self::CONSTRAINTS)? {
            Ok(SubcarrierSpacing::Extended)
        } else {
            let v = u8::from_aper(decoder, Self::CONSTRAINTS)?;
            FromPrimitive::from_u8(v).ok_or(DecodeError::MalformedInt)
        }
    }
    fn to_aper(&self, constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&false.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&(*self as u8).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// CyclicPrefix
# [derive(Clone, Copy, FromPrimitive)]
pub enum CyclicPrefix {
    Normal,
    Extended,
}

impl APerElement for CyclicPrefix {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, constraints: Constraints) -> Result<Self, DecodeError> {
        if bool::from_aper(decoder, Self::CONSTRAINTS)? {
            Ok(CyclicPrefix::Extended)
        } else {
            let v = u8::from_aper(decoder, Self::CONSTRAINTS)?;
            FromPrimitive::from_u8(v).ok_or(DecodeError::MalformedInt)
        }
    }
    fn to_aper(&self, constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&false.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&(*self as u8).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// Shift7dot5kHz
# [derive(Clone, Copy, FromPrimitive)]
pub enum Shift7dot5kHz {
    True,
    Extended,
}

impl APerElement for Shift7dot5kHz {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, constraints: Constraints) -> Result<Self, DecodeError> {
        if bool::from_aper(decoder, Self::CONSTRAINTS)? {
            Ok(Shift7dot5kHz::Extended)
        } else {
            let v = u8::from_aper(decoder, Self::CONSTRAINTS)?;
            FromPrimitive::from_u8(v).ok_or(DecodeError::MalformedInt)
        }
    }
    fn to_aper(&self, constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&false.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&(*self as u8).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// Resolution
# [derive(Clone, Copy, FromPrimitive)]
pub enum Resolution {
    Deg0dot1,
    Extended,
}

impl APerElement for Resolution {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, constraints: Constraints) -> Result<Self, DecodeError> {
        if bool::from_aper(decoder, Self::CONSTRAINTS)? {
            Ok(Resolution::Extended)
        } else {
            let v = u8::from_aper(decoder, Self::CONSTRAINTS)?;
            FromPrimitive::from_u8(v).ok_or(DecodeError::MalformedInt)
        }
    }
    fn to_aper(&self, constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&false.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&(*self as u8).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// DelayCritical
# [derive(Clone, Copy, FromPrimitive)]
pub enum DelayCritical {
    DelayCritical,
    NonDelayCritical,
}

impl APerElement for DelayCritical {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, constraints: Constraints) -> Result<Self, DecodeError> {
        if bool::from_aper(decoder, Self::CONSTRAINTS)? {
            Ok(DelayCritical::Extended)
        } else {
            let v = u8::from_aper(decoder, Self::CONSTRAINTS)?;
            FromPrimitive::from_u8(v).ok_or(DecodeError::MalformedInt)
        }
    }
    fn to_aper(&self, constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&false.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&(*self as u8).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// ResourceType
# [derive(Clone, Copy, FromPrimitive)]
pub enum ResourceType {
    Gbr,
    NonGbr,
    DelayCriticalGrb,
    Extended,
}

impl APerElement for ResourceType {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, constraints: Constraints) -> Result<Self, DecodeError> {
        if bool::from_aper(decoder, Self::CONSTRAINTS)? {
            Ok(ResourceType::Extended)
        } else {
            let v = u8::from_aper(decoder, Self::CONSTRAINTS)?;
            FromPrimitive::from_u8(v).ok_or(DecodeError::MalformedInt)
        }
    }
    fn to_aper(&self, constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&false.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&(*self as u8).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// Nrscs
# [derive(Clone, Copy, FromPrimitive)]
pub enum Nrscs {
    Scs15,
    Scs30,
    Scs60,
    Scs120,
    Extended,
}

impl APerElement for Nrscs {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, constraints: Constraints) -> Result<Self, DecodeError> {
        if bool::from_aper(decoder, Self::CONSTRAINTS)? {
            Ok(Nrscs::Extended)
        } else {
            let v = u8::from_aper(decoder, Self::CONSTRAINTS)?;
            FromPrimitive::from_u8(v).ok_or(DecodeError::MalformedInt)
        }
    }
    fn to_aper(&self, constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&false.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&(*self as u8).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// Nrcp
# [derive(Clone, Copy, FromPrimitive)]
pub enum Nrcp {
    Normal,
    Extended,
    Extended,
}

impl APerElement for Nrcp {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, constraints: Constraints) -> Result<Self, DecodeError> {
        if bool::from_aper(decoder, Self::CONSTRAINTS)? {
            Ok(Nrcp::Extended)
        } else {
            let v = u8::from_aper(decoder, Self::CONSTRAINTS)?;
            FromPrimitive::from_u8(v).ok_or(DecodeError::MalformedInt)
        }
    }
    fn to_aper(&self, constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&false.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&(*self as u8).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// NrdlulTxPeriodicity
# [derive(Clone, Copy, FromPrimitive)]
pub enum NrdlulTxPeriodicity {
    Ms0p5,
    Ms0p625,
    Ms1,
    Ms1p25,
    Ms2,
    Ms2p5,
    Ms3,
    Ms4,
    Ms5,
    Ms10,
    Ms20,
    Ms40,
    Ms60,
    Ms80,
    Ms100,
    Ms120,
    Ms140,
    Ms160,
    Extended,
}

impl APerElement for NrdlulTxPeriodicity {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, constraints: Constraints) -> Result<Self, DecodeError> {
        if bool::from_aper(decoder, Self::CONSTRAINTS)? {
            Ok(NrdlulTxPeriodicity::Extended)
        } else {
            let v = u8::from_aper(decoder, Self::CONSTRAINTS)?;
            FromPrimitive::from_u8(v).ok_or(DecodeError::MalformedInt)
        }
    }
    fn to_aper(&self, constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&false.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&(*self as u8).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// Msg1scs
# [derive(Clone, Copy, FromPrimitive)]
pub enum Msg1scs {
    Scs15,
    Scs30,
    Scs60,
    Scs120,
    Extended,
}

impl APerElement for Msg1scs {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, constraints: Constraints) -> Result<Self, DecodeError> {
        if bool::from_aper(decoder, Self::CONSTRAINTS)? {
            Ok(Msg1scs::Extended)
        } else {
            let v = u8::from_aper(decoder, Self::CONSTRAINTS)?;
            FromPrimitive::from_u8(v).ok_or(DecodeError::MalformedInt)
        }
    }
    fn to_aper(&self, constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&false.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&(*self as u8).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// RestrictedSetConfig
# [derive(Clone, Copy, FromPrimitive)]
pub enum RestrictedSetConfig {
    UnrestrictedSet,
    RestrictedSetTypeA,
    RestrictedSetTypeB,
    Extended,
}

impl APerElement for RestrictedSetConfig {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, constraints: Constraints) -> Result<Self, DecodeError> {
        if bool::from_aper(decoder, Self::CONSTRAINTS)? {
            Ok(RestrictedSetConfig::Extended)
        } else {
            let v = u8::from_aper(decoder, Self::CONSTRAINTS)?;
            FromPrimitive::from_u8(v).ok_or(DecodeError::MalformedInt)
        }
    }
    fn to_aper(&self, constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&false.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&(*self as u8).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// Msg1fdm
# [derive(Clone, Copy, FromPrimitive)]
pub enum Msg1fdm {
    One,
    Two,
    Four,
    Eight,
    Extended,
}

impl APerElement for Msg1fdm {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, constraints: Constraints) -> Result<Self, DecodeError> {
        if bool::from_aper(decoder, Self::CONSTRAINTS)? {
            Ok(Msg1fdm::Extended)
        } else {
            let v = u8::from_aper(decoder, Self::CONSTRAINTS)?;
            FromPrimitive::from_u8(v).ok_or(DecodeError::MalformedInt)
        }
    }
    fn to_aper(&self, constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&false.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&(*self as u8).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// SsbPerRachOccasion
# [derive(Clone, Copy, FromPrimitive)]
pub enum SsbPerRachOccasion {
    OneEighth,
    OneFourth,
    OneHalf,
    One,
    Two,
    Four,
    Eight,
    Sixteen,
    Extended,
}

impl APerElement for SsbPerRachOccasion {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, constraints: Constraints) -> Result<Self, DecodeError> {
        if bool::from_aper(decoder, Self::CONSTRAINTS)? {
            Ok(SsbPerRachOccasion::Extended)
        } else {
            let v = u8::from_aper(decoder, Self::CONSTRAINTS)?;
            FromPrimitive::from_u8(v).ok_or(DecodeError::MalformedInt)
        }
    }
    fn to_aper(&self, constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&false.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&(*self as u8).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// PosperiodicSet
# [derive(Clone, Copy, FromPrimitive)]
pub enum PosperiodicSet {
    True,
    Extended,
}

impl APerElement for PosperiodicSet {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, constraints: Constraints) -> Result<Self, DecodeError> {
        if bool::from_aper(decoder, Self::CONSTRAINTS)? {
            Ok(PosperiodicSet::Extended)
        } else {
            let v = u8::from_aper(decoder, Self::CONSTRAINTS)?;
            FromPrimitive::from_u8(v).ok_or(DecodeError::MalformedInt)
        }
    }
    fn to_aper(&self, constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&false.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&(*self as u8).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// PossemiPersistentSet
# [derive(Clone, Copy, FromPrimitive)]
pub enum PossemiPersistentSet {
    True,
    Extended,
}

impl APerElement for PossemiPersistentSet {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, constraints: Constraints) -> Result<Self, DecodeError> {
        if bool::from_aper(decoder, Self::CONSTRAINTS)? {
            Ok(PossemiPersistentSet::Extended)
        } else {
            let v = u8::from_aper(decoder, Self::CONSTRAINTS)?;
            FromPrimitive::from_u8(v).ok_or(DecodeError::MalformedInt)
        }
    }
    fn to_aper(&self, constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&false.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&(*self as u8).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// NrofSymbols
# [derive(Clone, Copy, FromPrimitive)]
pub enum NrofSymbols {
    N1,
    N2,
    N4,
    N8,
    N12,
}

impl APerElement for NrofSymbols {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, constraints: Constraints) -> Result<Self, DecodeError> {
        if bool::from_aper(decoder, Self::CONSTRAINTS)? {
            Ok(NrofSymbols::Extended)
        } else {
            let v = u8::from_aper(decoder, Self::CONSTRAINTS)?;
            FromPrimitive::from_u8(v).ok_or(DecodeError::MalformedInt)
        }
    }
    fn to_aper(&self, constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&false.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&(*self as u8).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// GroupOrSequenceHopping
# [derive(Clone, Copy, FromPrimitive)]
pub enum GroupOrSequenceHopping {
    Neither,
    GroupHopping,
    SequenceHopping,
}

impl APerElement for GroupOrSequenceHopping {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, constraints: Constraints) -> Result<Self, DecodeError> {
        if bool::from_aper(decoder, Self::CONSTRAINTS)? {
            Ok(GroupOrSequenceHopping::Extended)
        } else {
            let v = u8::from_aper(decoder, Self::CONSTRAINTS)?;
            FromPrimitive::from_u8(v).ok_or(DecodeError::MalformedInt)
        }
    }
    fn to_aper(&self, constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&false.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&(*self as u8).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// MutingBitRepetitionFactor
# [derive(Clone, Copy, FromPrimitive)]
pub enum MutingBitRepetitionFactor {
    Rf1,
    Rf2,
    Rf4,
    Rf8,
    Extended,
}

impl APerElement for MutingBitRepetitionFactor {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, constraints: Constraints) -> Result<Self, DecodeError> {
        if bool::from_aper(decoder, Self::CONSTRAINTS)? {
            Ok(MutingBitRepetitionFactor::Extended)
        } else {
            let v = u8::from_aper(decoder, Self::CONSTRAINTS)?;
            FromPrimitive::from_u8(v).ok_or(DecodeError::MalformedInt)
        }
    }
    fn to_aper(&self, constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&false.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&(*self as u8).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// SubcarrierSpacing1
# [derive(Clone, Copy, FromPrimitive)]
pub enum SubcarrierSpacing1 {
    KHz15,
    KHz30,
    KHz60,
    KHz120,
    Extended,
}

impl APerElement for SubcarrierSpacing1 {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, constraints: Constraints) -> Result<Self, DecodeError> {
        if bool::from_aper(decoder, Self::CONSTRAINTS)? {
            Ok(SubcarrierSpacing1::Extended)
        } else {
            let v = u8::from_aper(decoder, Self::CONSTRAINTS)?;
            FromPrimitive::from_u8(v).ok_or(DecodeError::MalformedInt)
        }
    }
    fn to_aper(&self, constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&false.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&(*self as u8).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// CombSize
# [derive(Clone, Copy, FromPrimitive)]
pub enum CombSize {
    N2,
    N4,
    N6,
    N12,
    Extended,
}

impl APerElement for CombSize {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, constraints: Constraints) -> Result<Self, DecodeError> {
        if bool::from_aper(decoder, Self::CONSTRAINTS)? {
            Ok(CombSize::Extended)
        } else {
            let v = u8::from_aper(decoder, Self::CONSTRAINTS)?;
            FromPrimitive::from_u8(v).ok_or(DecodeError::MalformedInt)
        }
    }
    fn to_aper(&self, constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&false.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&(*self as u8).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// CpType
# [derive(Clone, Copy, FromPrimitive)]
pub enum CpType {
    Normal,
    Extended,
    Extended,
}

impl APerElement for CpType {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, constraints: Constraints) -> Result<Self, DecodeError> {
        if bool::from_aper(decoder, Self::CONSTRAINTS)? {
            Ok(CpType::Extended)
        } else {
            let v = u8::from_aper(decoder, Self::CONSTRAINTS)?;
            FromPrimitive::from_u8(v).ok_or(DecodeError::MalformedInt)
        }
    }
    fn to_aper(&self, constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&false.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&(*self as u8).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// ResourceSetPeriodicity
# [derive(Clone, Copy, FromPrimitive)]
pub enum ResourceSetPeriodicity {
    N4,
    N5,
    N8,
    N10,
    N16,
    N20,
    N32,
    N40,
    N64,
    N80,
    N160,
    N320,
    N640,
    N1280,
    N2560,
    N5120,
    N10240,
    N20480,
    N40960,
    N81920,
    Extended,
}

impl APerElement for ResourceSetPeriodicity {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, constraints: Constraints) -> Result<Self, DecodeError> {
        if bool::from_aper(decoder, Self::CONSTRAINTS)? {
            Ok(ResourceSetPeriodicity::Extended)
        } else {
            let v = u8::from_aper(decoder, Self::CONSTRAINTS)?;
            FromPrimitive::from_u8(v).ok_or(DecodeError::MalformedInt)
        }
    }
    fn to_aper(&self, constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&false.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&(*self as u8).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// ResourceRepetitionFactor
# [derive(Clone, Copy, FromPrimitive)]
pub enum ResourceRepetitionFactor {
    Rf1,
    Rf2,
    Rf4,
    Rf6,
    Rf8,
    Rf16,
    Rf32,
    Extended,
}

impl APerElement for ResourceRepetitionFactor {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, constraints: Constraints) -> Result<Self, DecodeError> {
        if bool::from_aper(decoder, Self::CONSTRAINTS)? {
            Ok(ResourceRepetitionFactor::Extended)
        } else {
            let v = u8::from_aper(decoder, Self::CONSTRAINTS)?;
            FromPrimitive::from_u8(v).ok_or(DecodeError::MalformedInt)
        }
    }
    fn to_aper(&self, constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&false.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&(*self as u8).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// ResourceTimeGap
# [derive(Clone, Copy, FromPrimitive)]
pub enum ResourceTimeGap {
    Tg1,
    Tg2,
    Tg4,
    Tg8,
    Tg16,
    Tg32,
    Extended,
}

impl APerElement for ResourceTimeGap {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, constraints: Constraints) -> Result<Self, DecodeError> {
        if bool::from_aper(decoder, Self::CONSTRAINTS)? {
            Ok(ResourceTimeGap::Extended)
        } else {
            let v = u8::from_aper(decoder, Self::CONSTRAINTS)?;
            FromPrimitive::from_u8(v).ok_or(DecodeError::MalformedInt)
        }
    }
    fn to_aper(&self, constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&false.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&(*self as u8).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// ResourceNumberofSymbols
# [derive(Clone, Copy, FromPrimitive)]
pub enum ResourceNumberofSymbols {
    N2,
    N4,
    N6,
    N12,
    Extended,
}

impl APerElement for ResourceNumberofSymbols {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, constraints: Constraints) -> Result<Self, DecodeError> {
        if bool::from_aper(decoder, Self::CONSTRAINTS)? {
            Ok(ResourceNumberofSymbols::Extended)
        } else {
            let v = u8::from_aper(decoder, Self::CONSTRAINTS)?;
            FromPrimitive::from_u8(v).ok_or(DecodeError::MalformedInt)
        }
    }
    fn to_aper(&self, constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&false.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&(*self as u8).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// ReflectiveQosAttribute
# [derive(Clone, Copy, FromPrimitive)]
pub enum ReflectiveQosAttribute {
    SubjectTo,
    Extended,
}

impl APerElement for ReflectiveQosAttribute {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, constraints: Constraints) -> Result<Self, DecodeError> {
        if bool::from_aper(decoder, Self::CONSTRAINTS)? {
            Ok(ReflectiveQosAttribute::Extended)
        } else {
            let v = u8::from_aper(decoder, Self::CONSTRAINTS)?;
            FromPrimitive::from_u8(v).ok_or(DecodeError::MalformedInt)
        }
    }
    fn to_aper(&self, constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&false.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&(*self as u8).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// XyZunit
# [derive(Clone, Copy, FromPrimitive)]
pub enum XyZunit {
    Mm,
    Cm,
    Dm,
    Extended,
}

impl APerElement for XyZunit {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, constraints: Constraints) -> Result<Self, DecodeError> {
        if bool::from_aper(decoder, Self::CONSTRAINTS)? {
            Ok(XyZunit::Extended)
        } else {
            let v = u8::from_aper(decoder, Self::CONSTRAINTS)?;
            FromPrimitive::from_u8(v).ok_or(DecodeError::MalformedInt)
        }
    }
    fn to_aper(&self, constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&false.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&(*self as u8).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// MilliArcSecondUnits
# [derive(Clone, Copy, FromPrimitive)]
pub enum MilliArcSecondUnits {
    Zerodot03,
    Zerodot3,
    Three,
    Extended,
}

impl APerElement for MilliArcSecondUnits {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, constraints: Constraints) -> Result<Self, DecodeError> {
        if bool::from_aper(decoder, Self::CONSTRAINTS)? {
            Ok(MilliArcSecondUnits::Extended)
        } else {
            let v = u8::from_aper(decoder, Self::CONSTRAINTS)?;
            FromPrimitive::from_u8(v).ok_or(DecodeError::MalformedInt)
        }
    }
    fn to_aper(&self, constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&false.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&(*self as u8).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// HeightUnits
# [derive(Clone, Copy, FromPrimitive)]
pub enum HeightUnits {
    Mm,
    Cm,
    M,
    Extended,
}

impl APerElement for HeightUnits {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, constraints: Constraints) -> Result<Self, DecodeError> {
        if bool::from_aper(decoder, Self::CONSTRAINTS)? {
            Ok(HeightUnits::Extended)
        } else {
            let v = u8::from_aper(decoder, Self::CONSTRAINTS)?;
            FromPrimitive::from_u8(v).ok_or(DecodeError::MalformedInt)
        }
    }
    fn to_aper(&self, constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&false.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&(*self as u8).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// ResourceType1
# [derive(Clone, Copy, FromPrimitive)]
pub enum ResourceType1 {
    Periodic,
    SemiPersistent,
    Aperiodic,
    Extended,
}

impl APerElement for ResourceType1 {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, constraints: Constraints) -> Result<Self, DecodeError> {
        if bool::from_aper(decoder, Self::CONSTRAINTS)? {
            Ok(ResourceType1::Extended)
        } else {
            let v = u8::from_aper(decoder, Self::CONSTRAINTS)?;
            FromPrimitive::from_u8(v).ok_or(DecodeError::MalformedInt)
        }
    }
    fn to_aper(&self, constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&false.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&(*self as u8).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// PeriodicSet
# [derive(Clone, Copy, FromPrimitive)]
pub enum PeriodicSet {
    True,
    Extended,
}

impl APerElement for PeriodicSet {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, constraints: Constraints) -> Result<Self, DecodeError> {
        if bool::from_aper(decoder, Self::CONSTRAINTS)? {
            Ok(PeriodicSet::Extended)
        } else {
            let v = u8::from_aper(decoder, Self::CONSTRAINTS)?;
            FromPrimitive::from_u8(v).ok_or(DecodeError::MalformedInt)
        }
    }
    fn to_aper(&self, constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&false.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&(*self as u8).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// SemiPersistentSet
# [derive(Clone, Copy, FromPrimitive)]
pub enum SemiPersistentSet {
    True,
    Extended,
}

impl APerElement for SemiPersistentSet {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, constraints: Constraints) -> Result<Self, DecodeError> {
        if bool::from_aper(decoder, Self::CONSTRAINTS)? {
            Ok(SemiPersistentSet::Extended)
        } else {
            let v = u8::from_aper(decoder, Self::CONSTRAINTS)?;
            FromPrimitive::from_u8(v).ok_or(DecodeError::MalformedInt)
        }
    }
    fn to_aper(&self, constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&false.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&(*self as u8).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// Periodicity
# [derive(Clone, Copy, FromPrimitive)]
pub enum Periodicity {
    Slot1,
    Slot2,
    Slot4,
    Slot5,
    Slot8,
    Slot10,
    Slot16,
    Slot20,
    Slot32,
    Slot40,
    Slot64,
    Slot80,
    Slot160,
    Slot320,
    Slot640,
    Slot1280,
    Slot2560,
    Extended,
}

impl APerElement for Periodicity {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, constraints: Constraints) -> Result<Self, DecodeError> {
        if bool::from_aper(decoder, Self::CONSTRAINTS)? {
            Ok(Periodicity::Extended)
        } else {
            let v = u8::from_aper(decoder, Self::CONSTRAINTS)?;
            FromPrimitive::from_u8(v).ok_or(DecodeError::MalformedInt)
        }
    }
    fn to_aper(&self, constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&false.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&(*self as u8).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// Periodicity1
# [derive(Clone, Copy, FromPrimitive)]
pub enum Periodicity1 {
    Slot1,
    Slot2,
    Slot4,
    Slot5,
    Slot8,
    Slot10,
    Slot16,
    Slot20,
    Slot32,
    Slot40,
    Slot64,
    Slot80,
    Slot160,
    Slot320,
    Slot640,
    Slot1280,
    Slot2560,
    Extended,
}

impl APerElement for Periodicity1 {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, constraints: Constraints) -> Result<Self, DecodeError> {
        if bool::from_aper(decoder, Self::CONSTRAINTS)? {
            Ok(Periodicity1::Extended)
        } else {
            let v = u8::from_aper(decoder, Self::CONSTRAINTS)?;
            FromPrimitive::from_u8(v).ok_or(DecodeError::MalformedInt)
        }
    }
    fn to_aper(&self, constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&false.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&(*self as u8).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// AperiodicResourceType
# [derive(Clone, Copy, FromPrimitive)]
pub enum AperiodicResourceType {
    True,
    Extended,
}

impl APerElement for AperiodicResourceType {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, constraints: Constraints) -> Result<Self, DecodeError> {
        if bool::from_aper(decoder, Self::CONSTRAINTS)? {
            Ok(AperiodicResourceType::Extended)
        } else {
            let v = u8::from_aper(decoder, Self::CONSTRAINTS)?;
            FromPrimitive::from_u8(v).ok_or(DecodeError::MalformedInt)
        }
    }
    fn to_aper(&self, constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&false.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&(*self as u8).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// Periodicity2
# [derive(Clone, Copy, FromPrimitive)]
pub enum Periodicity2 {
    Slot1,
    Slot2,
    Slot4,
    Slot5,
    Slot8,
    Slot10,
    Slot16,
    Slot20,
    Slot32,
    Slot40,
    Slot64,
    Slot80,
    Slot160,
    Slot320,
    Slot640,
    Slot1280,
    Slot2560,
    Slot5120,
    Slot10240,
    Slot40960,
    Slot81920,
    Extended,
}

impl APerElement for Periodicity2 {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, constraints: Constraints) -> Result<Self, DecodeError> {
        if bool::from_aper(decoder, Self::CONSTRAINTS)? {
            Ok(Periodicity2::Extended)
        } else {
            let v = u8::from_aper(decoder, Self::CONSTRAINTS)?;
            FromPrimitive::from_u8(v).ok_or(DecodeError::MalformedInt)
        }
    }
    fn to_aper(&self, constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&false.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&(*self as u8).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// Periodicity3
# [derive(Clone, Copy, FromPrimitive)]
pub enum Periodicity3 {
    Slot1,
    Slot2,
    Slot4,
    Slot5,
    Slot8,
    Slot10,
    Slot16,
    Slot20,
    Slot32,
    Slot40,
    Slot64,
    Slot80,
    Slot160,
    Slot320,
    Slot640,
    Slot1280,
    Slot2560,
    Slot5120,
    Slot10240,
    Slot40960,
    Slot81920,
    Extended,
}

impl APerElement for Periodicity3 {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, constraints: Constraints) -> Result<Self, DecodeError> {
        if bool::from_aper(decoder, Self::CONSTRAINTS)? {
            Ok(Periodicity3::Extended)
        } else {
            let v = u8::from_aper(decoder, Self::CONSTRAINTS)?;
            FromPrimitive::from_u8(v).ok_or(DecodeError::MalformedInt)
        }
    }
    fn to_aper(&self, constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&false.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&(*self as u8).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// SubcarrierSpacing2
# [derive(Clone, Copy, FromPrimitive)]
pub enum SubcarrierSpacing2 {
    KHz15,
    KHz30,
    KHz60,
    KHz120,
    Extended,
}

impl APerElement for SubcarrierSpacing2 {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, constraints: Constraints) -> Result<Self, DecodeError> {
        if bool::from_aper(decoder, Self::CONSTRAINTS)? {
            Ok(SubcarrierSpacing2::Extended)
        } else {
            let v = u8::from_aper(decoder, Self::CONSTRAINTS)?;
            FromPrimitive::from_u8(v).ok_or(DecodeError::MalformedInt)
        }
    }
    fn to_aper(&self, constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&false.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&(*self as u8).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// SwitchingOffOngoing
# [derive(Clone, Copy, FromPrimitive)]
pub enum SwitchingOffOngoing {
    True,
    Extended,
}

impl APerElement for SwitchingOffOngoing {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, constraints: Constraints) -> Result<Self, DecodeError> {
        if bool::from_aper(decoder, Self::CONSTRAINTS)? {
            Ok(SwitchingOffOngoing::Extended)
        } else {
            let v = u8::from_aper(decoder, Self::CONSTRAINTS)?;
            FromPrimitive::from_u8(v).ok_or(DecodeError::MalformedInt)
        }
    }
    fn to_aper(&self, constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&false.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&(*self as u8).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// NrofSrsPorts
# [derive(Clone, Copy, FromPrimitive)]
pub enum NrofSrsPorts {
    Port1,
    Ports2,
    Ports4,
}

impl APerElement for NrofSrsPorts {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, constraints: Constraints) -> Result<Self, DecodeError> {
        if bool::from_aper(decoder, Self::CONSTRAINTS)? {
            Ok(NrofSrsPorts::Extended)
        } else {
            let v = u8::from_aper(decoder, Self::CONSTRAINTS)?;
            FromPrimitive::from_u8(v).ok_or(DecodeError::MalformedInt)
        }
    }
    fn to_aper(&self, constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&false.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&(*self as u8).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// NrofSymbols1
# [derive(Clone, Copy, FromPrimitive)]
pub enum NrofSymbols1 {
    N1,
    N2,
    N4,
}

impl APerElement for NrofSymbols1 {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, constraints: Constraints) -> Result<Self, DecodeError> {
        if bool::from_aper(decoder, Self::CONSTRAINTS)? {
            Ok(NrofSymbols1::Extended)
        } else {
            let v = u8::from_aper(decoder, Self::CONSTRAINTS)?;
            FromPrimitive::from_u8(v).ok_or(DecodeError::MalformedInt)
        }
    }
    fn to_aper(&self, constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&false.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&(*self as u8).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// RepetitionFactor
# [derive(Clone, Copy, FromPrimitive)]
pub enum RepetitionFactor {
    N1,
    N2,
    N4,
}

impl APerElement for RepetitionFactor {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, constraints: Constraints) -> Result<Self, DecodeError> {
        if bool::from_aper(decoder, Self::CONSTRAINTS)? {
            Ok(RepetitionFactor::Extended)
        } else {
            let v = u8::from_aper(decoder, Self::CONSTRAINTS)?;
            FromPrimitive::from_u8(v).ok_or(DecodeError::MalformedInt)
        }
    }
    fn to_aper(&self, constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&false.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&(*self as u8).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// GroupOrSequenceHopping1
# [derive(Clone, Copy, FromPrimitive)]
pub enum GroupOrSequenceHopping1 {
    Neither,
    GroupHopping,
    SequenceHopping,
}

impl APerElement for GroupOrSequenceHopping1 {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, constraints: Constraints) -> Result<Self, DecodeError> {
        if bool::from_aper(decoder, Self::CONSTRAINTS)? {
            Ok(GroupOrSequenceHopping1::Extended)
        } else {
            let v = u8::from_aper(decoder, Self::CONSTRAINTS)?;
            FromPrimitive::from_u8(v).ok_or(DecodeError::MalformedInt)
        }
    }
    fn to_aper(&self, constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&false.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&(*self as u8).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// SsbSubcarrierSpacing
# [derive(Clone, Copy, FromPrimitive)]
pub enum SsbSubcarrierSpacing {
    KHz15,
    KHz30,
    KHz60,
    KHz120,
    KHz240,
    Extended,
}

impl APerElement for SsbSubcarrierSpacing {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, constraints: Constraints) -> Result<Self, DecodeError> {
        if bool::from_aper(decoder, Self::CONSTRAINTS)? {
            Ok(SsbSubcarrierSpacing::Extended)
        } else {
            let v = u8::from_aper(decoder, Self::CONSTRAINTS)?;
            FromPrimitive::from_u8(v).ok_or(DecodeError::MalformedInt)
        }
    }
    fn to_aper(&self, constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&false.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&(*self as u8).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// SsbPeriodicity
# [derive(Clone, Copy, FromPrimitive)]
pub enum SsbPeriodicity {
    Ms5,
    Ms10,
    Ms20,
    Ms40,
    Ms80,
    Ms160,
    Extended,
}

impl APerElement for SsbPeriodicity {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, constraints: Constraints) -> Result<Self, DecodeError> {
        if bool::from_aper(decoder, Self::CONSTRAINTS)? {
            Ok(SsbPeriodicity::Extended)
        } else {
            let v = u8::from_aper(decoder, Self::CONSTRAINTS)?;
            FromPrimitive::from_u8(v).ok_or(DecodeError::MalformedInt)
        }
    }
    fn to_aper(&self, constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&false.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&(*self as u8).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// Resolution1
# [derive(Clone, Copy, FromPrimitive)]
pub enum Resolution1 {
    M0dot1,
    M1,
    M10,
    M30,
    Extended,
}

impl APerElement for Resolution1 {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, constraints: Constraints) -> Result<Self, DecodeError> {
        if bool::from_aper(decoder, Self::CONSTRAINTS)? {
            Ok(Resolution1::Extended)
        } else {
            let v = u8::from_aper(decoder, Self::CONSTRAINTS)?;
            FromPrimitive::from_u8(v).ok_or(DecodeError::MalformedInt)
        }
    }
    fn to_aper(&self, constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&false.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&(*self as u8).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// N2
pub struct N2 {
    pub comb_offset_n_2: u8,
    pub cyclic_shift_n_2: u8,
}

impl APerElement for N2 {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, constraints: Constraints) -> Result<Self, DecodeError> {
        
        
        let comb_offset_n_2 = u8::from_aper(decoder, UNCONSTRAINED)?;
        let cyclic_shift_n_2 = u8::from_aper(decoder, UNCONSTRAINED)?;

        Ok(Self {
            comb_offset_n_2,
            cyclic_shift_n_2,
        })
    }
    fn to_aper(&self, constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        

        
        
        enc.append(&self.comb_offset_n_2.to_aper(UNCONSTRAINED)?);
        enc.append(&self.cyclic_shift_n_2.to_aper(UNCONSTRAINED)?);

        Ok(enc)
    }
}

// N4
pub struct N4 {
    pub comb_offset_n_4: u8,
    pub cyclic_shift_n_4: u8,
}

impl APerElement for N4 {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, constraints: Constraints) -> Result<Self, DecodeError> {
        
        
        let comb_offset_n_4 = u8::from_aper(decoder, UNCONSTRAINED)?;
        let cyclic_shift_n_4 = u8::from_aper(decoder, UNCONSTRAINED)?;

        Ok(Self {
            comb_offset_n_4,
            cyclic_shift_n_4,
        })
    }
    fn to_aper(&self, constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        

        
        
        enc.append(&self.comb_offset_n_4.to_aper(UNCONSTRAINED)?);
        enc.append(&self.cyclic_shift_n_4.to_aper(UNCONSTRAINED)?);

        Ok(enc)
    }
}

// N21
pub struct N21 {
    pub comb_offset_n_2: u8,
    pub cyclic_shift_n_2: u8,
}

impl APerElement for N21 {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, constraints: Constraints) -> Result<Self, DecodeError> {
        
        
        let comb_offset_n_2 = u8::from_aper(decoder, UNCONSTRAINED)?;
        let cyclic_shift_n_2 = u8::from_aper(decoder, UNCONSTRAINED)?;

        Ok(Self {
            comb_offset_n_2,
            cyclic_shift_n_2,
        })
    }
    fn to_aper(&self, constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        

        
        
        enc.append(&self.comb_offset_n_2.to_aper(UNCONSTRAINED)?);
        enc.append(&self.cyclic_shift_n_2.to_aper(UNCONSTRAINED)?);

        Ok(enc)
    }
}

// N41
pub struct N41 {
    pub comb_offset_n_4: u8,
    pub cyclic_shift_n_4: u8,
}

impl APerElement for N41 {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, constraints: Constraints) -> Result<Self, DecodeError> {
        
        
        let comb_offset_n_4 = u8::from_aper(decoder, UNCONSTRAINED)?;
        let cyclic_shift_n_4 = u8::from_aper(decoder, UNCONSTRAINED)?;

        Ok(Self {
            comb_offset_n_4,
            cyclic_shift_n_4,
        })
    }
    fn to_aper(&self, constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        

        
        
        enc.append(&self.comb_offset_n_4.to_aper(UNCONSTRAINED)?);
        enc.append(&self.cyclic_shift_n_4.to_aper(UNCONSTRAINED)?);

        Ok(enc)
    }
}

// N8
pub struct N8 {
    pub comb_offset_n_8: u8,
    pub cyclic_shift_n_8: u8,
}

impl APerElement for N8 {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, constraints: Constraints) -> Result<Self, DecodeError> {
        
        
        let comb_offset_n_8 = u8::from_aper(decoder, UNCONSTRAINED)?;
        let cyclic_shift_n_8 = u8::from_aper(decoder, UNCONSTRAINED)?;

        Ok(Self {
            comb_offset_n_8,
            cyclic_shift_n_8,
        })
    }
    fn to_aper(&self, constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        

        
        
        enc.append(&self.comb_offset_n_8.to_aper(UNCONSTRAINED)?);
        enc.append(&self.cyclic_shift_n_8.to_aper(UNCONSTRAINED)?);

        Ok(enc)
    }
}

