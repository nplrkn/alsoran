// Copyright (c) Nicholas Larkin
// Autogenerated from F1AP-IEs.asn
use super::common::*;

use asn1::aper::*;
#[allow(unused_imports)]
use asn1::BitString;
#[allow(unused_imports)]
use num_derive::FromPrimitive;
#[allow(unused_imports)]
use num_traits::FromPrimitive;
// AbortTransmission
#[derive(Clone)]
pub enum AbortTransmission {
    SrsResourceSetId(SrsResourceSetId),
    ReleaseAll,
    _Extended,
}

impl APerElement for AbortTransmission {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        match u8::from_aper(decoder, UNCONSTRAINED)? {
            0 => Ok(Self::SrsResourceSetId(SrsResourceSetId::from_aper(
                decoder,
                UNCONSTRAINED,
            )?)),
            1 => Ok(Self::ReleaseAll),
            2 => Err(DecodeError::NotImplemented),
            _ => Err(DecodeError::InvalidChoice),
        }
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        match self {
            Self::SrsResourceSetId(x) => {
                enc.append(&(0 as u8).to_aper(UNCONSTRAINED)?)?;
                enc.append(&x.to_aper(UNCONSTRAINED)?)?;
            }
            Self::ReleaseAll => {
                enc.append(&(1 as u8).to_aper(UNCONSTRAINED)?)?;
            }
            Self::_Extended => return Err(EncodeError::NotImplemented),
        }
        Ok(enc)
    }
}

// AccessPointPosition
#[derive(Clone)]
pub struct AccessPointPosition {
    pub latitude_sign: LatitudeSign,
    pub latitude: u32,
    pub longitude: u32,
    pub direction_of_altitude: DirectionOfAltitude,
    pub altitude: u16,
    pub uncertainty_semi_major: u8,
    pub uncertainty_semi_minor: u8,
    pub orientation_of_major_axis: u8,
    pub uncertainty_altitude: u8,
    pub confidence: u8,
}

impl APerElement for AccessPointPosition {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(1),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let _optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let latitude_sign = LatitudeSign::from_aper(decoder, UNCONSTRAINED)?;
        let latitude = u32::from_aper(decoder, UNCONSTRAINED)?;
        let longitude = u32::from_aper(decoder, UNCONSTRAINED)?;
        let direction_of_altitude = DirectionOfAltitude::from_aper(decoder, UNCONSTRAINED)?;
        let altitude = u16::from_aper(decoder, UNCONSTRAINED)?;
        let uncertainty_semi_major = u8::from_aper(decoder, UNCONSTRAINED)?;
        let uncertainty_semi_minor = u8::from_aper(decoder, UNCONSTRAINED)?;
        let orientation_of_major_axis = u8::from_aper(decoder, UNCONSTRAINED)?;
        let uncertainty_altitude = u8::from_aper(decoder, UNCONSTRAINED)?;
        let confidence = u8::from_aper(decoder, UNCONSTRAINED)?;

        Ok(Self {
            latitude_sign,
            latitude,
            longitude,
            direction_of_altitude,
            altitude,
            uncertainty_semi_major,
            uncertainty_semi_minor,
            orientation_of_major_axis,
            uncertainty_altitude,
            confidence,
        })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(1);
        optionals.set(0, false);

        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&self.latitude_sign.to_aper(UNCONSTRAINED)?)?;
        enc.append(&self.latitude.to_aper(UNCONSTRAINED)?)?;
        enc.append(&self.longitude.to_aper(UNCONSTRAINED)?)?;
        enc.append(&self.direction_of_altitude.to_aper(UNCONSTRAINED)?)?;
        enc.append(&self.altitude.to_aper(UNCONSTRAINED)?)?;
        enc.append(&self.uncertainty_semi_major.to_aper(UNCONSTRAINED)?)?;
        enc.append(&self.uncertainty_semi_minor.to_aper(UNCONSTRAINED)?)?;
        enc.append(&self.orientation_of_major_axis.to_aper(UNCONSTRAINED)?)?;
        enc.append(&self.uncertainty_altitude.to_aper(UNCONSTRAINED)?)?;
        enc.append(&self.confidence.to_aper(UNCONSTRAINED)?)?;

        Ok(enc)
    }
}

// ActivatedCellsToBeUpdatedList
#[derive(Clone)]
pub struct ActivatedCellsToBeUpdatedList(pub Vec<ActivatedCellsToBeUpdatedListItem>);

impl APerElement for ActivatedCellsToBeUpdatedList {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(1),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        Ok(Self(Vec::<ActivatedCellsToBeUpdatedListItem>::from_aper(
            decoder,
            Self::CONSTRAINTS,
        )?))
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&(self.0).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// ActivatedCellsToBeUpdatedListItem
#[derive(Clone)]
pub struct ActivatedCellsToBeUpdatedListItem {
    pub nrcgi: Nrcgi,
    pub iab_du_cell_resource_configuration_mode_info: IabDuCellResourceConfigurationModeInfo,
}

impl APerElement for ActivatedCellsToBeUpdatedListItem {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(1),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let _optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let nrcgi = Nrcgi::from_aper(decoder, UNCONSTRAINED)?;
        let iab_du_cell_resource_configuration_mode_info =
            IabDuCellResourceConfigurationModeInfo::from_aper(decoder, UNCONSTRAINED)?;

        Ok(Self {
            nrcgi,
            iab_du_cell_resource_configuration_mode_info,
        })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(1);
        optionals.set(0, false);

        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&self.nrcgi.to_aper(UNCONSTRAINED)?)?;
        enc.append(
            &self
                .iab_du_cell_resource_configuration_mode_info
                .to_aper(UNCONSTRAINED)?,
        )?;

        Ok(enc)
    }
}

// ActiveUlbwp
#[derive(Clone)]
pub struct ActiveUlbwp {
    pub location_and_bandwidth: u16,
    pub subcarrier_spacing: SubcarrierSpacing1,
    pub cyclic_prefix: CyclicPrefix,
    pub tx_direct_current_location: u16,
    pub shift7dot5k_hz: Option<Shift7dot5kHz>,
    pub srs_config: SrsConfig,
}

impl APerElement for ActiveUlbwp {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(2),
            max: Some(2),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let location_and_bandwidth = u16::from_aper(decoder, UNCONSTRAINED)?;
        let subcarrier_spacing = SubcarrierSpacing1::from_aper(decoder, UNCONSTRAINED)?;
        let cyclic_prefix = CyclicPrefix::from_aper(decoder, UNCONSTRAINED)?;
        let tx_direct_current_location = u16::from_aper(decoder, UNCONSTRAINED)?;
        let shift7dot5k_hz = if optionals.is_set(0) {
            Some(Shift7dot5kHz::from_aper(decoder, UNCONSTRAINED)?)
        } else {
            None
        };
        let srs_config = SrsConfig::from_aper(decoder, UNCONSTRAINED)?;

        Ok(Self {
            location_and_bandwidth,
            subcarrier_spacing,
            cyclic_prefix,
            tx_direct_current_location,
            shift7dot5k_hz,
            srs_config,
        })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(2);
        optionals.set(0, self.shift7dot5k_hz.is_some());
        optionals.set(1, false);

        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&self.location_and_bandwidth.to_aper(UNCONSTRAINED)?)?;
        enc.append(&self.subcarrier_spacing.to_aper(UNCONSTRAINED)?)?;
        enc.append(&self.cyclic_prefix.to_aper(UNCONSTRAINED)?)?;
        enc.append(&self.tx_direct_current_location.to_aper(UNCONSTRAINED)?)?;
        if let Some(x) = &self.shift7dot5k_hz {
            enc.append(&x.to_aper(UNCONSTRAINED)?)?;
        }
        enc.append(&self.srs_config.to_aper(UNCONSTRAINED)?)?;

        Ok(enc)
    }
}

// AdditionalDuplicationIndication
#[derive(Clone, Copy, FromPrimitive)]
pub enum AdditionalDuplicationIndication {
    Three,
    Four,
    _Extended,
}

impl APerElement for AdditionalDuplicationIndication {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        if bool::from_aper(decoder, Self::CONSTRAINTS)? {
            return Ok(AdditionalDuplicationIndication::_Extended);
        }
        let v = u8::from_aper(decoder, Self::CONSTRAINTS)?;
        FromPrimitive::from_u8(v).ok_or(DecodeError::MalformedInt)
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&false.to_aper(UNCONSTRAINED)?)?;
        enc.append(&(*self as u8).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// AdditionalPathList
#[derive(Clone)]
pub struct AdditionalPathList(pub Vec<AdditionalPathItem>);

impl APerElement for AdditionalPathList {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(1),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        Ok(Self(Vec::<AdditionalPathItem>::from_aper(
            decoder,
            Self::CONSTRAINTS,
        )?))
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&(self.0).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// AdditionalPathItem
#[derive(Clone)]
pub struct AdditionalPathItem {
    pub relative_path_delay: RelativePathDelay,
    pub path_quality: Option<TrpMeasurementQuality>,
}

impl APerElement for AdditionalPathItem {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(2),
            max: Some(2),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let relative_path_delay = RelativePathDelay::from_aper(decoder, UNCONSTRAINED)?;
        let path_quality = if optionals.is_set(0) {
            Some(TrpMeasurementQuality::from_aper(decoder, UNCONSTRAINED)?)
        } else {
            None
        };

        Ok(Self {
            relative_path_delay,
            path_quality,
        })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(2);
        optionals.set(0, self.path_quality.is_some());
        optionals.set(1, false);

        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&self.relative_path_delay.to_aper(UNCONSTRAINED)?)?;
        if let Some(x) = &self.path_quality {
            enc.append(&x.to_aper(UNCONSTRAINED)?)?;
        }

        Ok(enc)
    }
}

// AdditionalPdcpDuplicationTnlList
#[derive(Clone)]
pub struct AdditionalPdcpDuplicationTnlList(pub Vec<AdditionalPdcpDuplicationTnlItem>);

impl APerElement for AdditionalPdcpDuplicationTnlList {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(1),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        Ok(Self(Vec::<AdditionalPdcpDuplicationTnlItem>::from_aper(
            decoder,
            Self::CONSTRAINTS,
        )?))
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&(self.0).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// AdditionalPdcpDuplicationTnlItem
#[derive(Clone)]
pub struct AdditionalPdcpDuplicationTnlItem {
    pub additional_pdcp_duplication_uptnl_information: UpTransportLayerInformation,
}

impl APerElement for AdditionalPdcpDuplicationTnlItem {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(1),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let _extended = bool::from_aper(decoder, UNCONSTRAINED)?;
        let _optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let additional_pdcp_duplication_uptnl_information =
            UpTransportLayerInformation::from_aper(decoder, UNCONSTRAINED)?;

        Ok(Self {
            additional_pdcp_duplication_uptnl_information,
        })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(1);
        optionals.set(0, false);

        enc.append(&false.to_aper(UNCONSTRAINED)?)?;
        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(
            &self
                .additional_pdcp_duplication_uptnl_information
                .to_aper(UNCONSTRAINED)?,
        )?;

        Ok(enc)
    }
}

// AdditionalSibMessageList
#[derive(Clone)]
pub struct AdditionalSibMessageList(pub Vec<AdditionalSibMessageListItem>);

impl APerElement for AdditionalSibMessageList {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(1),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        Ok(Self(Vec::<AdditionalSibMessageListItem>::from_aper(
            decoder,
            Self::CONSTRAINTS,
        )?))
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&(self.0).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// AdditionalSibMessageListItem
#[derive(Clone)]
pub struct AdditionalSibMessageListItem {
    pub additional_sib: Vec<u8>,
}

impl APerElement for AdditionalSibMessageListItem {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(1),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let _optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let additional_sib = Vec::<u8>::from_aper(decoder, UNCONSTRAINED)?;

        Ok(Self { additional_sib })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(1);
        optionals.set(0, false);

        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&self.additional_sib.to_aper(UNCONSTRAINED)?)?;

        Ok(enc)
    }
}

// AdditionalRrmPriorityIndex
#[derive(Clone)]
pub struct AdditionalRrmPriorityIndex(pub BitString);

impl APerElement for AdditionalRrmPriorityIndex {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(32),
            max: Some(32),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        Ok(Self(BitString::from_aper(decoder, Self::CONSTRAINTS)?))
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&(self.0).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// AggressorCellList
#[derive(Clone)]
pub struct AggressorCellList(pub Vec<AggressorCellListItem>);

impl APerElement for AggressorCellList {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(1),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        Ok(Self(Vec::<AggressorCellListItem>::from_aper(
            decoder,
            Self::CONSTRAINTS,
        )?))
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&(self.0).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// AggressorCellListItem
#[derive(Clone)]
pub struct AggressorCellListItem {
    pub aggressor_cell_id: Nrcgi,
}

impl APerElement for AggressorCellListItem {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(1),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let _optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let aggressor_cell_id = Nrcgi::from_aper(decoder, UNCONSTRAINED)?;

        Ok(Self { aggressor_cell_id })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(1);
        optionals.set(0, false);

        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&self.aggressor_cell_id.to_aper(UNCONSTRAINED)?)?;

        Ok(enc)
    }
}

// AggressorGnbSetId
#[derive(Clone)]
pub struct AggressorGnbSetId {
    pub aggressor_gnb_set_id: GnbSetId,
}

impl APerElement for AggressorGnbSetId {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(1),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let _optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let aggressor_gnb_set_id = GnbSetId::from_aper(decoder, UNCONSTRAINED)?;

        Ok(Self {
            aggressor_gnb_set_id,
        })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(1);
        optionals.set(0, false);

        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&self.aggressor_gnb_set_id.to_aper(UNCONSTRAINED)?)?;

        Ok(enc)
    }
}

// AllocationAndRetentionPriority
#[derive(Clone)]
pub struct AllocationAndRetentionPriority {
    pub priority_level: PriorityLevel,
    pub pre_emption_capability: PreEmptionCapability,
    pub pre_emption_vulnerability: PreEmptionVulnerability,
}

impl APerElement for AllocationAndRetentionPriority {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(1),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let _extended = bool::from_aper(decoder, UNCONSTRAINED)?;
        let _optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let priority_level = PriorityLevel::from_aper(decoder, UNCONSTRAINED)?;
        let pre_emption_capability = PreEmptionCapability::from_aper(decoder, UNCONSTRAINED)?;
        let pre_emption_vulnerability = PreEmptionVulnerability::from_aper(decoder, UNCONSTRAINED)?;

        Ok(Self {
            priority_level,
            pre_emption_capability,
            pre_emption_vulnerability,
        })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(1);
        optionals.set(0, false);

        enc.append(&false.to_aper(UNCONSTRAINED)?)?;
        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&self.priority_level.to_aper(UNCONSTRAINED)?)?;
        enc.append(&self.pre_emption_capability.to_aper(UNCONSTRAINED)?)?;
        enc.append(&self.pre_emption_vulnerability.to_aper(UNCONSTRAINED)?)?;

        Ok(enc)
    }
}

// AlternativeQosParaSetList
#[derive(Clone)]
pub struct AlternativeQosParaSetList(pub Vec<AlternativeQosParaSetItem>);

impl APerElement for AlternativeQosParaSetList {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(1),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        Ok(Self(Vec::<AlternativeQosParaSetItem>::from_aper(
            decoder,
            Self::CONSTRAINTS,
        )?))
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&(self.0).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// AlternativeQosParaSetItem
#[derive(Clone)]
pub struct AlternativeQosParaSetItem {
    pub alternative_qos_para_set_index: QosParaSetIndex,
    pub guaranteed_flow_bit_rate_dl: Option<BitRate>,
    pub guaranteed_flow_bit_rate_ul: Option<BitRate>,
    pub packet_delay_budget: Option<PacketDelayBudget>,
    pub packet_error_rate: Option<PacketErrorRate>,
}

impl APerElement for AlternativeQosParaSetItem {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(5),
            max: Some(5),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let _extended = bool::from_aper(decoder, UNCONSTRAINED)?;
        let optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let alternative_qos_para_set_index = QosParaSetIndex::from_aper(decoder, UNCONSTRAINED)?;
        let guaranteed_flow_bit_rate_dl = if optionals.is_set(0) {
            Some(BitRate::from_aper(decoder, UNCONSTRAINED)?)
        } else {
            None
        };
        let guaranteed_flow_bit_rate_ul = if optionals.is_set(0) {
            Some(BitRate::from_aper(decoder, UNCONSTRAINED)?)
        } else {
            None
        };
        let packet_delay_budget = if optionals.is_set(0) {
            Some(PacketDelayBudget::from_aper(decoder, UNCONSTRAINED)?)
        } else {
            None
        };
        let packet_error_rate = if optionals.is_set(0) {
            Some(PacketErrorRate::from_aper(decoder, UNCONSTRAINED)?)
        } else {
            None
        };

        Ok(Self {
            alternative_qos_para_set_index,
            guaranteed_flow_bit_rate_dl,
            guaranteed_flow_bit_rate_ul,
            packet_delay_budget,
            packet_error_rate,
        })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(5);
        optionals.set(0, self.guaranteed_flow_bit_rate_dl.is_some());
        optionals.set(1, self.guaranteed_flow_bit_rate_ul.is_some());
        optionals.set(2, self.packet_delay_budget.is_some());
        optionals.set(3, self.packet_error_rate.is_some());
        optionals.set(4, false);

        enc.append(&false.to_aper(UNCONSTRAINED)?)?;
        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&self.alternative_qos_para_set_index.to_aper(UNCONSTRAINED)?)?;
        if let Some(x) = &self.guaranteed_flow_bit_rate_dl {
            enc.append(&x.to_aper(UNCONSTRAINED)?)?;
        }
        if let Some(x) = &self.guaranteed_flow_bit_rate_ul {
            enc.append(&x.to_aper(UNCONSTRAINED)?)?;
        }
        if let Some(x) = &self.packet_delay_budget {
            enc.append(&x.to_aper(UNCONSTRAINED)?)?;
        }
        if let Some(x) = &self.packet_error_rate {
            enc.append(&x.to_aper(UNCONSTRAINED)?)?;
        }

        Ok(enc)
    }
}

// AngleMeasurementQuality
#[derive(Clone)]
pub struct AngleMeasurementQuality {
    pub azimuth_quality: u8,
    pub zenith_quality: Option<u8>,
    pub resolution: Resolution,
}

impl APerElement for AngleMeasurementQuality {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(2),
            max: Some(2),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let azimuth_quality = u8::from_aper(decoder, UNCONSTRAINED)?;
        let zenith_quality = if optionals.is_set(0) {
            Some(u8::from_aper(decoder, UNCONSTRAINED)?)
        } else {
            None
        };
        let resolution = Resolution::from_aper(decoder, UNCONSTRAINED)?;

        Ok(Self {
            azimuth_quality,
            zenith_quality,
            resolution,
        })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(2);
        optionals.set(0, self.zenith_quality.is_some());
        optionals.set(1, false);

        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&self.azimuth_quality.to_aper(UNCONSTRAINED)?)?;
        if let Some(x) = &self.zenith_quality {
            enc.append(&x.to_aper(UNCONSTRAINED)?)?;
        }
        enc.append(&self.resolution.to_aper(UNCONSTRAINED)?)?;

        Ok(enc)
    }
}

// AperiodicSrsResourceTriggerList
#[derive(Clone)]
pub struct AperiodicSrsResourceTriggerList(pub Vec<AperiodicSrsResourceTrigger>);

impl APerElement for AperiodicSrsResourceTriggerList {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(1),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        Ok(Self(Vec::<AperiodicSrsResourceTrigger>::from_aper(
            decoder,
            Self::CONSTRAINTS,
        )?))
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&(self.0).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// AperiodicSrsResourceTrigger
#[derive(Clone)]
pub struct AperiodicSrsResourceTrigger(pub u8);

impl APerElement for AperiodicSrsResourceTrigger {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(1),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        Ok(Self(u8::from_aper(decoder, Self::CONSTRAINTS)?))
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&(self.0).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// AssociatedSCellItem
#[derive(Clone)]
pub struct AssociatedSCellItem {
    pub s_cell_id: Nrcgi,
}

impl APerElement for AssociatedSCellItem {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(1),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let _optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let s_cell_id = Nrcgi::from_aper(decoder, UNCONSTRAINED)?;

        Ok(Self { s_cell_id })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(1);
        optionals.set(0, false);

        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&self.s_cell_id.to_aper(UNCONSTRAINED)?)?;

        Ok(enc)
    }
}

// AvailablePlmnList
#[derive(Clone)]
pub struct AvailablePlmnList(pub Vec<AvailablePlmnListItem>);

impl APerElement for AvailablePlmnList {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(1),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        Ok(Self(Vec::<AvailablePlmnListItem>::from_aper(
            decoder,
            Self::CONSTRAINTS,
        )?))
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&(self.0).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// AvailablePlmnListItem
#[derive(Clone)]
pub struct AvailablePlmnListItem {
    pub plmn_identity: PlmnIdentity,
}

impl APerElement for AvailablePlmnListItem {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(1),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let _optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let plmn_identity = PlmnIdentity::from_aper(decoder, UNCONSTRAINED)?;

        Ok(Self { plmn_identity })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(1);
        optionals.set(0, false);

        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&self.plmn_identity.to_aper(UNCONSTRAINED)?)?;

        Ok(enc)
    }
}

// AvailableSnpnIdList
#[derive(Clone)]
pub struct AvailableSnpnIdList(pub Vec<AvailableSnpnIdListItem>);

impl APerElement for AvailableSnpnIdList {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(1),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        Ok(Self(Vec::<AvailableSnpnIdListItem>::from_aper(
            decoder,
            Self::CONSTRAINTS,
        )?))
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&(self.0).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// AvailableSnpnIdListItem
#[derive(Clone)]
pub struct AvailableSnpnIdListItem {
    pub plmn_identity: PlmnIdentity,
    pub available_nid_list: BroadcastNidList,
}

impl APerElement for AvailableSnpnIdListItem {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(1),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let _extended = bool::from_aper(decoder, UNCONSTRAINED)?;
        let _optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let plmn_identity = PlmnIdentity::from_aper(decoder, UNCONSTRAINED)?;
        let available_nid_list = BroadcastNidList::from_aper(decoder, UNCONSTRAINED)?;

        Ok(Self {
            plmn_identity,
            available_nid_list,
        })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(1);
        optionals.set(0, false);

        enc.append(&false.to_aper(UNCONSTRAINED)?)?;
        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&self.plmn_identity.to_aper(UNCONSTRAINED)?)?;
        enc.append(&self.available_nid_list.to_aper(UNCONSTRAINED)?)?;

        Ok(enc)
    }
}

// AveragingWindow
#[derive(Clone)]
pub struct AveragingWindow(pub u16);

impl APerElement for AveragingWindow {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(0),
            max: Some(4095),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        Ok(Self(u16::from_aper(decoder, Self::CONSTRAINTS)?))
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&(self.0).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// AreaScope
#[derive(Clone, Copy, FromPrimitive)]
pub enum AreaScope {
    True,
    _Extended,
}

impl APerElement for AreaScope {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        if bool::from_aper(decoder, Self::CONSTRAINTS)? {
            return Ok(AreaScope::_Extended);
        }
        let v = u8::from_aper(decoder, Self::CONSTRAINTS)?;
        FromPrimitive::from_u8(v).ok_or(DecodeError::MalformedInt)
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&false.to_aper(UNCONSTRAINED)?)?;
        enc.append(&(*self as u8).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// BandwidthSrs
#[derive(Clone)]
pub enum BandwidthSrs {
    Fr1(Fr1Bandwidth),
    Fr2(Fr2Bandwidth),
    _Extended,
}

impl APerElement for BandwidthSrs {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        match u8::from_aper(decoder, UNCONSTRAINED)? {
            0 => Ok(Self::Fr1(Fr1Bandwidth::from_aper(decoder, UNCONSTRAINED)?)),
            1 => Ok(Self::Fr2(Fr2Bandwidth::from_aper(decoder, UNCONSTRAINED)?)),
            2 => Err(DecodeError::NotImplemented),
            _ => Err(DecodeError::InvalidChoice),
        }
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        match self {
            Self::Fr1(x) => {
                enc.append(&(0 as u8).to_aper(UNCONSTRAINED)?)?;
                enc.append(&x.to_aper(UNCONSTRAINED)?)?;
            }
            Self::Fr2(x) => {
                enc.append(&(1 as u8).to_aper(UNCONSTRAINED)?)?;
                enc.append(&x.to_aper(UNCONSTRAINED)?)?;
            }
            Self::_Extended => return Err(EncodeError::NotImplemented),
        }
        Ok(enc)
    }
}

// BapAddress
#[derive(Clone)]
pub struct BapAddress(pub BitString);

impl APerElement for BapAddress {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(10),
            max: Some(10),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        Ok(Self(BitString::from_aper(decoder, Self::CONSTRAINTS)?))
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&(self.0).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// BapCtrlPduChannel
#[derive(Clone, Copy, FromPrimitive)]
pub enum BapCtrlPduChannel {
    True,
    _Extended,
}

impl APerElement for BapCtrlPduChannel {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        if bool::from_aper(decoder, Self::CONSTRAINTS)? {
            return Ok(BapCtrlPduChannel::_Extended);
        }
        let v = u8::from_aper(decoder, Self::CONSTRAINTS)?;
        FromPrimitive::from_u8(v).ok_or(DecodeError::MalformedInt)
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&false.to_aper(UNCONSTRAINED)?)?;
        enc.append(&(*self as u8).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// BaPlayerBhrlCchannelMappingInfo
#[derive(Clone)]
pub struct BaPlayerBhrlCchannelMappingInfo {
    pub ba_player_bhrl_cchannel_mapping_info_to_add: Option<BaPlayerBhrlCchannelMappingInfoList>,
    pub ba_player_bhrl_cchannel_mapping_info_to_remove: Option<MappingInformationtoRemove>,
}

impl APerElement for BaPlayerBhrlCchannelMappingInfo {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(3),
            max: Some(3),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let _extended = bool::from_aper(decoder, UNCONSTRAINED)?;
        let optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let ba_player_bhrl_cchannel_mapping_info_to_add = if optionals.is_set(0) {
            Some(BaPlayerBhrlCchannelMappingInfoList::from_aper(
                decoder,
                UNCONSTRAINED,
            )?)
        } else {
            None
        };
        let ba_player_bhrl_cchannel_mapping_info_to_remove = if optionals.is_set(0) {
            Some(MappingInformationtoRemove::from_aper(
                decoder,
                UNCONSTRAINED,
            )?)
        } else {
            None
        };

        Ok(Self {
            ba_player_bhrl_cchannel_mapping_info_to_add,
            ba_player_bhrl_cchannel_mapping_info_to_remove,
        })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(3);
        optionals.set(
            0,
            self.ba_player_bhrl_cchannel_mapping_info_to_add.is_some(),
        );
        optionals.set(
            1,
            self.ba_player_bhrl_cchannel_mapping_info_to_remove
                .is_some(),
        );
        optionals.set(2, false);

        enc.append(&false.to_aper(UNCONSTRAINED)?)?;
        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        if let Some(x) = &self.ba_player_bhrl_cchannel_mapping_info_to_add {
            enc.append(&x.to_aper(UNCONSTRAINED)?)?;
        }
        if let Some(x) = &self.ba_player_bhrl_cchannel_mapping_info_to_remove {
            enc.append(&x.to_aper(UNCONSTRAINED)?)?;
        }

        Ok(enc)
    }
}

// BaPlayerBhrlCchannelMappingInfoList
#[derive(Clone)]
pub struct BaPlayerBhrlCchannelMappingInfoList(pub Vec<BaPlayerBhrlCchannelMappingInfoItem>);

impl APerElement for BaPlayerBhrlCchannelMappingInfoList {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(1),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        Ok(Self(Vec::<BaPlayerBhrlCchannelMappingInfoItem>::from_aper(
            decoder,
            Self::CONSTRAINTS,
        )?))
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&(self.0).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// BaPlayerBhrlCchannelMappingInfoItem
#[derive(Clone)]
pub struct BaPlayerBhrlCchannelMappingInfoItem {
    pub mapping_information_index: MappingInformationIndex,
    pub prior_hop_bap_address: Option<BapAddress>,
    pub ingressb_hrlc_channel_id: Option<BhrlcChannelId>,
    pub next_hop_bap_address: Option<BapAddress>,
    pub egressb_hrlc_channel_id: Option<BhrlcChannelId>,
}

impl APerElement for BaPlayerBhrlCchannelMappingInfoItem {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(5),
            max: Some(5),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let _extended = bool::from_aper(decoder, UNCONSTRAINED)?;
        let optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let mapping_information_index = MappingInformationIndex::from_aper(decoder, UNCONSTRAINED)?;
        let prior_hop_bap_address = if optionals.is_set(0) {
            Some(BapAddress::from_aper(decoder, UNCONSTRAINED)?)
        } else {
            None
        };
        let ingressb_hrlc_channel_id = if optionals.is_set(0) {
            Some(BhrlcChannelId::from_aper(decoder, UNCONSTRAINED)?)
        } else {
            None
        };
        let next_hop_bap_address = if optionals.is_set(0) {
            Some(BapAddress::from_aper(decoder, UNCONSTRAINED)?)
        } else {
            None
        };
        let egressb_hrlc_channel_id = if optionals.is_set(0) {
            Some(BhrlcChannelId::from_aper(decoder, UNCONSTRAINED)?)
        } else {
            None
        };

        Ok(Self {
            mapping_information_index,
            prior_hop_bap_address,
            ingressb_hrlc_channel_id,
            next_hop_bap_address,
            egressb_hrlc_channel_id,
        })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(5);
        optionals.set(0, self.prior_hop_bap_address.is_some());
        optionals.set(1, self.ingressb_hrlc_channel_id.is_some());
        optionals.set(2, self.next_hop_bap_address.is_some());
        optionals.set(3, self.egressb_hrlc_channel_id.is_some());
        optionals.set(4, false);

        enc.append(&false.to_aper(UNCONSTRAINED)?)?;
        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&self.mapping_information_index.to_aper(UNCONSTRAINED)?)?;
        if let Some(x) = &self.prior_hop_bap_address {
            enc.append(&x.to_aper(UNCONSTRAINED)?)?;
        }
        if let Some(x) = &self.ingressb_hrlc_channel_id {
            enc.append(&x.to_aper(UNCONSTRAINED)?)?;
        }
        if let Some(x) = &self.next_hop_bap_address {
            enc.append(&x.to_aper(UNCONSTRAINED)?)?;
        }
        if let Some(x) = &self.egressb_hrlc_channel_id {
            enc.append(&x.to_aper(UNCONSTRAINED)?)?;
        }

        Ok(enc)
    }
}

// BapPathId
#[derive(Clone)]
pub struct BapPathId(pub BitString);

impl APerElement for BapPathId {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(10),
            max: Some(10),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        Ok(Self(BitString::from_aper(decoder, Self::CONSTRAINTS)?))
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&(self.0).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// BapRoutingId
#[derive(Clone)]
pub struct BapRoutingId {
    pub bap_address: BapAddress,
    pub bap_path_id: BapPathId,
}

impl APerElement for BapRoutingId {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(1),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let _optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let bap_address = BapAddress::from_aper(decoder, UNCONSTRAINED)?;
        let bap_path_id = BapPathId::from_aper(decoder, UNCONSTRAINED)?;

        Ok(Self {
            bap_address,
            bap_path_id,
        })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(1);
        optionals.set(0, false);

        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&self.bap_address.to_aper(UNCONSTRAINED)?)?;
        enc.append(&self.bap_path_id.to_aper(UNCONSTRAINED)?)?;

        Ok(enc)
    }
}

// BitRate
#[derive(Clone)]
pub struct BitRate(pub u64);

impl APerElement for BitRate {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(0),
            max: Some(4000000000000),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        Ok(Self(u64::from_aper(decoder, Self::CONSTRAINTS)?))
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&(self.0).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// BearerTypeChange
#[derive(Clone, Copy, FromPrimitive)]
pub enum BearerTypeChange {
    True,
    _Extended,
}

impl APerElement for BearerTypeChange {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        if bool::from_aper(decoder, Self::CONSTRAINTS)? {
            return Ok(BearerTypeChange::_Extended);
        }
        let v = u8::from_aper(decoder, Self::CONSTRAINTS)?;
        FromPrimitive::from_u8(v).ok_or(DecodeError::MalformedInt)
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&false.to_aper(UNCONSTRAINED)?)?;
        enc.append(&(*self as u8).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// BhrlcChannelId
#[derive(Clone)]
pub struct BhrlcChannelId(pub BitString);

impl APerElement for BhrlcChannelId {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(16),
            max: Some(16),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        Ok(Self(BitString::from_aper(decoder, Self::CONSTRAINTS)?))
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&(self.0).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// BhChannelsFailedToBeModifiedItem
#[derive(Clone)]
pub struct BhChannelsFailedToBeModifiedItem {
    pub bhrlc_channel_id: BhrlcChannelId,
    pub cause: Option<Cause>,
}

impl APerElement for BhChannelsFailedToBeModifiedItem {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(2),
            max: Some(2),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let bhrlc_channel_id = BhrlcChannelId::from_aper(decoder, UNCONSTRAINED)?;
        let cause = if optionals.is_set(0) {
            Some(Cause::from_aper(decoder, UNCONSTRAINED)?)
        } else {
            None
        };

        Ok(Self {
            bhrlc_channel_id,
            cause,
        })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(2);
        optionals.set(0, self.cause.is_some());
        optionals.set(1, false);

        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&self.bhrlc_channel_id.to_aper(UNCONSTRAINED)?)?;
        if let Some(x) = &self.cause {
            enc.append(&x.to_aper(UNCONSTRAINED)?)?;
        }

        Ok(enc)
    }
}

// BhChannelsFailedToBeSetupItem
#[derive(Clone)]
pub struct BhChannelsFailedToBeSetupItem {
    pub bhrlc_channel_id: BhrlcChannelId,
    pub cause: Option<Cause>,
}

impl APerElement for BhChannelsFailedToBeSetupItem {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(2),
            max: Some(2),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let bhrlc_channel_id = BhrlcChannelId::from_aper(decoder, UNCONSTRAINED)?;
        let cause = if optionals.is_set(0) {
            Some(Cause::from_aper(decoder, UNCONSTRAINED)?)
        } else {
            None
        };

        Ok(Self {
            bhrlc_channel_id,
            cause,
        })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(2);
        optionals.set(0, self.cause.is_some());
        optionals.set(1, false);

        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&self.bhrlc_channel_id.to_aper(UNCONSTRAINED)?)?;
        if let Some(x) = &self.cause {
            enc.append(&x.to_aper(UNCONSTRAINED)?)?;
        }

        Ok(enc)
    }
}

// BhChannelsFailedToBeSetupModItem
#[derive(Clone)]
pub struct BhChannelsFailedToBeSetupModItem {
    pub bhrlc_channel_id: BhrlcChannelId,
    pub cause: Option<Cause>,
}

impl APerElement for BhChannelsFailedToBeSetupModItem {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(2),
            max: Some(2),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let bhrlc_channel_id = BhrlcChannelId::from_aper(decoder, UNCONSTRAINED)?;
        let cause = if optionals.is_set(0) {
            Some(Cause::from_aper(decoder, UNCONSTRAINED)?)
        } else {
            None
        };

        Ok(Self {
            bhrlc_channel_id,
            cause,
        })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(2);
        optionals.set(0, self.cause.is_some());
        optionals.set(1, false);

        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&self.bhrlc_channel_id.to_aper(UNCONSTRAINED)?)?;
        if let Some(x) = &self.cause {
            enc.append(&x.to_aper(UNCONSTRAINED)?)?;
        }

        Ok(enc)
    }
}

// BhChannelsModifiedItem
#[derive(Clone)]
pub struct BhChannelsModifiedItem {
    pub bhrlc_channel_id: BhrlcChannelId,
}

impl APerElement for BhChannelsModifiedItem {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(1),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let _optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let bhrlc_channel_id = BhrlcChannelId::from_aper(decoder, UNCONSTRAINED)?;

        Ok(Self { bhrlc_channel_id })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(1);
        optionals.set(0, false);

        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&self.bhrlc_channel_id.to_aper(UNCONSTRAINED)?)?;

        Ok(enc)
    }
}

// BhChannelsRequiredToBeReleasedItem
#[derive(Clone)]
pub struct BhChannelsRequiredToBeReleasedItem {
    pub bhrlc_channel_id: BhrlcChannelId,
}

impl APerElement for BhChannelsRequiredToBeReleasedItem {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(1),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let _optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let bhrlc_channel_id = BhrlcChannelId::from_aper(decoder, UNCONSTRAINED)?;

        Ok(Self { bhrlc_channel_id })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(1);
        optionals.set(0, false);

        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&self.bhrlc_channel_id.to_aper(UNCONSTRAINED)?)?;

        Ok(enc)
    }
}

// BhChannelsSetupItem
#[derive(Clone)]
pub struct BhChannelsSetupItem {
    pub bhrlc_channel_id: BhrlcChannelId,
}

impl APerElement for BhChannelsSetupItem {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(1),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let _optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let bhrlc_channel_id = BhrlcChannelId::from_aper(decoder, UNCONSTRAINED)?;

        Ok(Self { bhrlc_channel_id })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(1);
        optionals.set(0, false);

        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&self.bhrlc_channel_id.to_aper(UNCONSTRAINED)?)?;

        Ok(enc)
    }
}

// BhChannelsSetupModItem
#[derive(Clone)]
pub struct BhChannelsSetupModItem {
    pub bhrlc_channel_id: BhrlcChannelId,
}

impl APerElement for BhChannelsSetupModItem {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(1),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let _optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let bhrlc_channel_id = BhrlcChannelId::from_aper(decoder, UNCONSTRAINED)?;

        Ok(Self { bhrlc_channel_id })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(1);
        optionals.set(0, false);

        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&self.bhrlc_channel_id.to_aper(UNCONSTRAINED)?)?;

        Ok(enc)
    }
}

// BhChannelsToBeModifiedItem
#[derive(Clone)]
pub struct BhChannelsToBeModifiedItem {
    pub bhrlc_channel_id: BhrlcChannelId,
    pub bh_qos_information: BhQosInformation,
    pub rl_cmode: Option<RlcMode>,
    pub bap_ctrl_pdu_channel: Option<BapCtrlPduChannel>,
    pub traffic_mapping_info: Option<TrafficMappingInfo>,
}

impl APerElement for BhChannelsToBeModifiedItem {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(4),
            max: Some(4),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let bhrlc_channel_id = BhrlcChannelId::from_aper(decoder, UNCONSTRAINED)?;
        let bh_qos_information = BhQosInformation::from_aper(decoder, UNCONSTRAINED)?;
        let rl_cmode = if optionals.is_set(0) {
            Some(RlcMode::from_aper(decoder, UNCONSTRAINED)?)
        } else {
            None
        };
        let bap_ctrl_pdu_channel = if optionals.is_set(0) {
            Some(BapCtrlPduChannel::from_aper(decoder, UNCONSTRAINED)?)
        } else {
            None
        };
        let traffic_mapping_info = if optionals.is_set(0) {
            Some(TrafficMappingInfo::from_aper(decoder, UNCONSTRAINED)?)
        } else {
            None
        };

        Ok(Self {
            bhrlc_channel_id,
            bh_qos_information,
            rl_cmode,
            bap_ctrl_pdu_channel,
            traffic_mapping_info,
        })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(4);
        optionals.set(0, self.rl_cmode.is_some());
        optionals.set(1, self.bap_ctrl_pdu_channel.is_some());
        optionals.set(2, self.traffic_mapping_info.is_some());
        optionals.set(3, false);

        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&self.bhrlc_channel_id.to_aper(UNCONSTRAINED)?)?;
        enc.append(&self.bh_qos_information.to_aper(UNCONSTRAINED)?)?;
        if let Some(x) = &self.rl_cmode {
            enc.append(&x.to_aper(UNCONSTRAINED)?)?;
        }
        if let Some(x) = &self.bap_ctrl_pdu_channel {
            enc.append(&x.to_aper(UNCONSTRAINED)?)?;
        }
        if let Some(x) = &self.traffic_mapping_info {
            enc.append(&x.to_aper(UNCONSTRAINED)?)?;
        }

        Ok(enc)
    }
}

// BhChannelsToBeReleasedItem
#[derive(Clone)]
pub struct BhChannelsToBeReleasedItem {
    pub bhrlc_channel_id: BhrlcChannelId,
}

impl APerElement for BhChannelsToBeReleasedItem {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(1),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let _optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let bhrlc_channel_id = BhrlcChannelId::from_aper(decoder, UNCONSTRAINED)?;

        Ok(Self { bhrlc_channel_id })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(1);
        optionals.set(0, false);

        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&self.bhrlc_channel_id.to_aper(UNCONSTRAINED)?)?;

        Ok(enc)
    }
}

// BhChannelsToBeSetupItem
#[derive(Clone)]
pub struct BhChannelsToBeSetupItem {
    pub bhrlc_channel_id: BhrlcChannelId,
    pub bh_qos_information: BhQosInformation,
    pub rl_cmode: RlcMode,
    pub bap_ctrl_pdu_channel: Option<BapCtrlPduChannel>,
    pub traffic_mapping_info: Option<TrafficMappingInfo>,
}

impl APerElement for BhChannelsToBeSetupItem {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(3),
            max: Some(3),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let bhrlc_channel_id = BhrlcChannelId::from_aper(decoder, UNCONSTRAINED)?;
        let bh_qos_information = BhQosInformation::from_aper(decoder, UNCONSTRAINED)?;
        let rl_cmode = RlcMode::from_aper(decoder, UNCONSTRAINED)?;
        let bap_ctrl_pdu_channel = if optionals.is_set(0) {
            Some(BapCtrlPduChannel::from_aper(decoder, UNCONSTRAINED)?)
        } else {
            None
        };
        let traffic_mapping_info = if optionals.is_set(0) {
            Some(TrafficMappingInfo::from_aper(decoder, UNCONSTRAINED)?)
        } else {
            None
        };

        Ok(Self {
            bhrlc_channel_id,
            bh_qos_information,
            rl_cmode,
            bap_ctrl_pdu_channel,
            traffic_mapping_info,
        })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(3);
        optionals.set(0, self.bap_ctrl_pdu_channel.is_some());
        optionals.set(1, self.traffic_mapping_info.is_some());
        optionals.set(2, false);

        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&self.bhrlc_channel_id.to_aper(UNCONSTRAINED)?)?;
        enc.append(&self.bh_qos_information.to_aper(UNCONSTRAINED)?)?;
        enc.append(&self.rl_cmode.to_aper(UNCONSTRAINED)?)?;
        if let Some(x) = &self.bap_ctrl_pdu_channel {
            enc.append(&x.to_aper(UNCONSTRAINED)?)?;
        }
        if let Some(x) = &self.traffic_mapping_info {
            enc.append(&x.to_aper(UNCONSTRAINED)?)?;
        }

        Ok(enc)
    }
}

// BhChannelsToBeSetupModItem
#[derive(Clone)]
pub struct BhChannelsToBeSetupModItem {
    pub bhrlc_channel_id: BhrlcChannelId,
    pub bh_qos_information: BhQosInformation,
    pub rl_cmode: RlcMode,
    pub bap_ctrl_pdu_channel: Option<BapCtrlPduChannel>,
    pub traffic_mapping_info: Option<TrafficMappingInfo>,
}

impl APerElement for BhChannelsToBeSetupModItem {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(3),
            max: Some(3),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let bhrlc_channel_id = BhrlcChannelId::from_aper(decoder, UNCONSTRAINED)?;
        let bh_qos_information = BhQosInformation::from_aper(decoder, UNCONSTRAINED)?;
        let rl_cmode = RlcMode::from_aper(decoder, UNCONSTRAINED)?;
        let bap_ctrl_pdu_channel = if optionals.is_set(0) {
            Some(BapCtrlPduChannel::from_aper(decoder, UNCONSTRAINED)?)
        } else {
            None
        };
        let traffic_mapping_info = if optionals.is_set(0) {
            Some(TrafficMappingInfo::from_aper(decoder, UNCONSTRAINED)?)
        } else {
            None
        };

        Ok(Self {
            bhrlc_channel_id,
            bh_qos_information,
            rl_cmode,
            bap_ctrl_pdu_channel,
            traffic_mapping_info,
        })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(3);
        optionals.set(0, self.bap_ctrl_pdu_channel.is_some());
        optionals.set(1, self.traffic_mapping_info.is_some());
        optionals.set(2, false);

        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&self.bhrlc_channel_id.to_aper(UNCONSTRAINED)?)?;
        enc.append(&self.bh_qos_information.to_aper(UNCONSTRAINED)?)?;
        enc.append(&self.rl_cmode.to_aper(UNCONSTRAINED)?)?;
        if let Some(x) = &self.bap_ctrl_pdu_channel {
            enc.append(&x.to_aper(UNCONSTRAINED)?)?;
        }
        if let Some(x) = &self.traffic_mapping_info {
            enc.append(&x.to_aper(UNCONSTRAINED)?)?;
        }

        Ok(enc)
    }
}

// BhInfo
#[derive(Clone)]
pub struct BhInfo {
    pub ba_prouting_id: Option<BapRoutingId>,
    pub egress_bhrlcch_list: Option<EgressBhrlcchList>,
}

impl APerElement for BhInfo {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(3),
            max: Some(3),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let ba_prouting_id = if optionals.is_set(0) {
            Some(BapRoutingId::from_aper(decoder, UNCONSTRAINED)?)
        } else {
            None
        };
        let egress_bhrlcch_list = if optionals.is_set(0) {
            Some(EgressBhrlcchList::from_aper(decoder, UNCONSTRAINED)?)
        } else {
            None
        };

        Ok(Self {
            ba_prouting_id,
            egress_bhrlcch_list,
        })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(3);
        optionals.set(0, self.ba_prouting_id.is_some());
        optionals.set(1, self.egress_bhrlcch_list.is_some());
        optionals.set(2, false);

        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        if let Some(x) = &self.ba_prouting_id {
            enc.append(&x.to_aper(UNCONSTRAINED)?)?;
        }
        if let Some(x) = &self.egress_bhrlcch_list {
            enc.append(&x.to_aper(UNCONSTRAINED)?)?;
        }

        Ok(enc)
    }
}

// BhQosInformation
#[derive(Clone)]
pub enum BhQosInformation {
    BhrlcchQos(QosFlowLevelQosParameters),
    EutranBhrlcchQos(EutranQos),
    CpTrafficType(CpTrafficType),
    _Extended,
}

impl APerElement for BhQosInformation {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        match u8::from_aper(decoder, UNCONSTRAINED)? {
            0 => Ok(Self::BhrlcchQos(QosFlowLevelQosParameters::from_aper(
                decoder,
                UNCONSTRAINED,
            )?)),
            1 => Ok(Self::EutranBhrlcchQos(EutranQos::from_aper(
                decoder,
                UNCONSTRAINED,
            )?)),
            2 => Ok(Self::CpTrafficType(CpTrafficType::from_aper(
                decoder,
                UNCONSTRAINED,
            )?)),
            3 => Err(DecodeError::NotImplemented),
            _ => Err(DecodeError::InvalidChoice),
        }
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        match self {
            Self::BhrlcchQos(x) => {
                enc.append(&(0 as u8).to_aper(UNCONSTRAINED)?)?;
                enc.append(&x.to_aper(UNCONSTRAINED)?)?;
            }
            Self::EutranBhrlcchQos(x) => {
                enc.append(&(1 as u8).to_aper(UNCONSTRAINED)?)?;
                enc.append(&x.to_aper(UNCONSTRAINED)?)?;
            }
            Self::CpTrafficType(x) => {
                enc.append(&(2 as u8).to_aper(UNCONSTRAINED)?)?;
                enc.append(&x.to_aper(UNCONSTRAINED)?)?;
            }
            Self::_Extended => return Err(EncodeError::NotImplemented),
        }
        Ok(enc)
    }
}

// BhRoutingInformationAddedListItem
#[derive(Clone)]
pub struct BhRoutingInformationAddedListItem {
    pub bap_routing_id: BapRoutingId,
    pub next_hop_bap_address: BapAddress,
}

impl APerElement for BhRoutingInformationAddedListItem {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(1),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let _optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let bap_routing_id = BapRoutingId::from_aper(decoder, UNCONSTRAINED)?;
        let next_hop_bap_address = BapAddress::from_aper(decoder, UNCONSTRAINED)?;

        Ok(Self {
            bap_routing_id,
            next_hop_bap_address,
        })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(1);
        optionals.set(0, false);

        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&self.bap_routing_id.to_aper(UNCONSTRAINED)?)?;
        enc.append(&self.next_hop_bap_address.to_aper(UNCONSTRAINED)?)?;

        Ok(enc)
    }
}

// BhRoutingInformationRemovedListItem
#[derive(Clone)]
pub struct BhRoutingInformationRemovedListItem {
    pub bap_routing_id: BapRoutingId,
}

impl APerElement for BhRoutingInformationRemovedListItem {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(1),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let _optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let bap_routing_id = BapRoutingId::from_aper(decoder, UNCONSTRAINED)?;

        Ok(Self { bap_routing_id })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(1);
        optionals.set(0, false);

        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&self.bap_routing_id.to_aper(UNCONSTRAINED)?)?;

        Ok(enc)
    }
}

// BPlmnIdInfoList
#[derive(Clone)]
pub struct BPlmnIdInfoList(pub Vec<BPlmnIdInfoItem>);

impl APerElement for BPlmnIdInfoList {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(1),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        Ok(Self(Vec::<BPlmnIdInfoItem>::from_aper(
            decoder,
            Self::CONSTRAINTS,
        )?))
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&(self.0).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// BPlmnIdInfoItem
#[derive(Clone)]
pub struct BPlmnIdInfoItem {
    pub plmn_identity_list: AvailablePlmnList,
    pub extended_plmn_identity_list: Option<ExtendedAvailablePlmnList>,
    pub five_gs_tac: Option<FiveGsTac>,
    pub nr_cell_id: NrCellIdentity,
    pub ranac: Option<Ranac>,
}

impl APerElement for BPlmnIdInfoItem {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(4),
            max: Some(4),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let _extended = bool::from_aper(decoder, UNCONSTRAINED)?;
        let optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let plmn_identity_list = AvailablePlmnList::from_aper(decoder, UNCONSTRAINED)?;
        let extended_plmn_identity_list = if optionals.is_set(0) {
            Some(ExtendedAvailablePlmnList::from_aper(
                decoder,
                UNCONSTRAINED,
            )?)
        } else {
            None
        };
        let five_gs_tac = if optionals.is_set(0) {
            Some(FiveGsTac::from_aper(decoder, UNCONSTRAINED)?)
        } else {
            None
        };
        let nr_cell_id = NrCellIdentity::from_aper(decoder, UNCONSTRAINED)?;
        let ranac = if optionals.is_set(0) {
            Some(Ranac::from_aper(decoder, UNCONSTRAINED)?)
        } else {
            None
        };

        Ok(Self {
            plmn_identity_list,
            extended_plmn_identity_list,
            five_gs_tac,
            nr_cell_id,
            ranac,
        })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(4);
        optionals.set(0, self.extended_plmn_identity_list.is_some());
        optionals.set(1, self.five_gs_tac.is_some());
        optionals.set(2, self.ranac.is_some());
        optionals.set(3, false);

        enc.append(&false.to_aper(UNCONSTRAINED)?)?;
        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&self.plmn_identity_list.to_aper(UNCONSTRAINED)?)?;
        if let Some(x) = &self.extended_plmn_identity_list {
            enc.append(&x.to_aper(UNCONSTRAINED)?)?;
        }
        if let Some(x) = &self.five_gs_tac {
            enc.append(&x.to_aper(UNCONSTRAINED)?)?;
        }
        enc.append(&self.nr_cell_id.to_aper(UNCONSTRAINED)?)?;
        if let Some(x) = &self.ranac {
            enc.append(&x.to_aper(UNCONSTRAINED)?)?;
        }

        Ok(enc)
    }
}

// ServedPlmnSList
#[derive(Clone)]
pub struct ServedPlmnSList(pub Vec<ServedPlmnSItem>);

impl APerElement for ServedPlmnSList {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(1),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        Ok(Self(Vec::<ServedPlmnSItem>::from_aper(
            decoder,
            Self::CONSTRAINTS,
        )?))
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&(self.0).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// ServedPlmnSItem
#[derive(Clone)]
pub struct ServedPlmnSItem {
    pub plmn_identity: PlmnIdentity,
}

impl APerElement for ServedPlmnSItem {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(1),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let _extended = bool::from_aper(decoder, UNCONSTRAINED)?;
        let _optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let plmn_identity = PlmnIdentity::from_aper(decoder, UNCONSTRAINED)?;

        Ok(Self { plmn_identity })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(1);
        optionals.set(0, false);

        enc.append(&false.to_aper(UNCONSTRAINED)?)?;
        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&self.plmn_identity.to_aper(UNCONSTRAINED)?)?;

        Ok(enc)
    }
}

// BroadcastCagList
#[derive(Clone)]
pub struct BroadcastCagList(pub Vec<Cagid>);

impl APerElement for BroadcastCagList {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(1),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        Ok(Self(Vec::<Cagid>::from_aper(decoder, Self::CONSTRAINTS)?))
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&(self.0).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// BroadcastNidList
#[derive(Clone)]
pub struct BroadcastNidList(pub Vec<Nid>);

impl APerElement for BroadcastNidList {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(1),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        Ok(Self(Vec::<Nid>::from_aper(decoder, Self::CONSTRAINTS)?))
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&(self.0).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// BroadcastSnpnIdList
#[derive(Clone)]
pub struct BroadcastSnpnIdList(pub Vec<BroadcastSnpnIdListItem>);

impl APerElement for BroadcastSnpnIdList {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(1),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        Ok(Self(Vec::<BroadcastSnpnIdListItem>::from_aper(
            decoder,
            Self::CONSTRAINTS,
        )?))
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&(self.0).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// BroadcastSnpnIdListItem
#[derive(Clone)]
pub struct BroadcastSnpnIdListItem {
    pub plmn_identity: PlmnIdentity,
    pub broadcast_nid_list: BroadcastNidList,
}

impl APerElement for BroadcastSnpnIdListItem {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(1),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let _extended = bool::from_aper(decoder, UNCONSTRAINED)?;
        let _optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let plmn_identity = PlmnIdentity::from_aper(decoder, UNCONSTRAINED)?;
        let broadcast_nid_list = BroadcastNidList::from_aper(decoder, UNCONSTRAINED)?;

        Ok(Self {
            plmn_identity,
            broadcast_nid_list,
        })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(1);
        optionals.set(0, false);

        enc.append(&false.to_aper(UNCONSTRAINED)?)?;
        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&self.plmn_identity.to_aper(UNCONSTRAINED)?)?;
        enc.append(&self.broadcast_nid_list.to_aper(UNCONSTRAINED)?)?;

        Ok(enc)
    }
}

// BroadcastPniNpnIdList
#[derive(Clone)]
pub struct BroadcastPniNpnIdList(pub Vec<BroadcastPniNpnIdListItem>);

impl APerElement for BroadcastPniNpnIdList {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(1),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        Ok(Self(Vec::<BroadcastPniNpnIdListItem>::from_aper(
            decoder,
            Self::CONSTRAINTS,
        )?))
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&(self.0).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// BroadcastPniNpnIdListItem
#[derive(Clone)]
pub struct BroadcastPniNpnIdListItem {
    pub plmn_identity: PlmnIdentity,
    pub broadcast_cag_list: BroadcastCagList,
}

impl APerElement for BroadcastPniNpnIdListItem {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(1),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let _extended = bool::from_aper(decoder, UNCONSTRAINED)?;
        let _optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let plmn_identity = PlmnIdentity::from_aper(decoder, UNCONSTRAINED)?;
        let broadcast_cag_list = BroadcastCagList::from_aper(decoder, UNCONSTRAINED)?;

        Ok(Self {
            plmn_identity,
            broadcast_cag_list,
        })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(1);
        optionals.set(0, false);

        enc.append(&false.to_aper(UNCONSTRAINED)?)?;
        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&self.plmn_identity.to_aper(UNCONSTRAINED)?)?;
        enc.append(&self.broadcast_cag_list.to_aper(UNCONSTRAINED)?)?;

        Ok(enc)
    }
}

// BurstArrivalTime
#[derive(Clone)]
pub struct BurstArrivalTime(pub Vec<u8>);

impl APerElement for BurstArrivalTime {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        Ok(Self(Vec::<u8>::from_aper(decoder, Self::CONSTRAINTS)?))
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&(self.0).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// Cagid
#[derive(Clone)]
pub struct Cagid(pub BitString);

impl APerElement for Cagid {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(32),
            max: Some(32),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        Ok(Self(BitString::from_aper(decoder, Self::CONSTRAINTS)?))
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&(self.0).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// CancelAllWarningMessagesIndicator
#[derive(Clone, Copy, FromPrimitive)]
pub enum CancelAllWarningMessagesIndicator {
    True,
    _Extended,
}

impl APerElement for CancelAllWarningMessagesIndicator {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        if bool::from_aper(decoder, Self::CONSTRAINTS)? {
            return Ok(CancelAllWarningMessagesIndicator::_Extended);
        }
        let v = u8::from_aper(decoder, Self::CONSTRAINTS)?;
        FromPrimitive::from_u8(v).ok_or(DecodeError::MalformedInt)
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&false.to_aper(UNCONSTRAINED)?)?;
        enc.append(&(*self as u8).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// CandidateSpCellItem
#[derive(Clone)]
pub struct CandidateSpCellItem {
    pub candidate_sp_cell_id: Nrcgi,
}

impl APerElement for CandidateSpCellItem {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(1),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let _extended = bool::from_aper(decoder, UNCONSTRAINED)?;
        let _optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let candidate_sp_cell_id = Nrcgi::from_aper(decoder, UNCONSTRAINED)?;

        Ok(Self {
            candidate_sp_cell_id,
        })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(1);
        optionals.set(0, false);

        enc.append(&false.to_aper(UNCONSTRAINED)?)?;
        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&self.candidate_sp_cell_id.to_aper(UNCONSTRAINED)?)?;

        Ok(enc)
    }
}

// CapacityValue
#[derive(Clone)]
pub struct CapacityValue {
    pub capacity_value: u8,
    pub ssb_area_capacity_value_list: Option<SsbAreaCapacityValueList>,
}

impl APerElement for CapacityValue {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(2),
            max: Some(2),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let capacity_value = u8::from_aper(decoder, UNCONSTRAINED)?;
        let ssb_area_capacity_value_list = if optionals.is_set(0) {
            Some(SsbAreaCapacityValueList::from_aper(decoder, UNCONSTRAINED)?)
        } else {
            None
        };

        Ok(Self {
            capacity_value,
            ssb_area_capacity_value_list,
        })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(2);
        optionals.set(0, self.ssb_area_capacity_value_list.is_some());
        optionals.set(1, false);

        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&self.capacity_value.to_aper(UNCONSTRAINED)?)?;
        if let Some(x) = &self.ssb_area_capacity_value_list {
            enc.append(&x.to_aper(UNCONSTRAINED)?)?;
        }

        Ok(enc)
    }
}

// Cause
#[derive(Clone)]
pub enum Cause {
    RadioNetwork(CauseRadioNetwork),
    Transport(CauseTransport),
    Protocol(CauseProtocol),
    Misc(CauseMisc),
    _Extended,
}

impl APerElement for Cause {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        match u8::from_aper(decoder, UNCONSTRAINED)? {
            0 => Ok(Self::RadioNetwork(CauseRadioNetwork::from_aper(
                decoder,
                UNCONSTRAINED,
            )?)),
            1 => Ok(Self::Transport(CauseTransport::from_aper(
                decoder,
                UNCONSTRAINED,
            )?)),
            2 => Ok(Self::Protocol(CauseProtocol::from_aper(
                decoder,
                UNCONSTRAINED,
            )?)),
            3 => Ok(Self::Misc(CauseMisc::from_aper(decoder, UNCONSTRAINED)?)),
            4 => Err(DecodeError::NotImplemented),
            _ => Err(DecodeError::InvalidChoice),
        }
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        match self {
            Self::RadioNetwork(x) => {
                enc.append(&(0 as u8).to_aper(UNCONSTRAINED)?)?;
                enc.append(&x.to_aper(UNCONSTRAINED)?)?;
            }
            Self::Transport(x) => {
                enc.append(&(1 as u8).to_aper(UNCONSTRAINED)?)?;
                enc.append(&x.to_aper(UNCONSTRAINED)?)?;
            }
            Self::Protocol(x) => {
                enc.append(&(2 as u8).to_aper(UNCONSTRAINED)?)?;
                enc.append(&x.to_aper(UNCONSTRAINED)?)?;
            }
            Self::Misc(x) => {
                enc.append(&(3 as u8).to_aper(UNCONSTRAINED)?)?;
                enc.append(&x.to_aper(UNCONSTRAINED)?)?;
            }
            Self::_Extended => return Err(EncodeError::NotImplemented),
        }
        Ok(enc)
    }
}

// CauseMisc
#[derive(Clone, Copy, FromPrimitive)]
pub enum CauseMisc {
    ControlProcessingOverload,
    NotEnoughUserPlaneProcessingResources,
    HardwareFailure,
    OmIntervention,
    Unspecified,
    _Extended,
}

impl APerElement for CauseMisc {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        if bool::from_aper(decoder, Self::CONSTRAINTS)? {
            return Ok(CauseMisc::_Extended);
        }
        let v = u8::from_aper(decoder, Self::CONSTRAINTS)?;
        FromPrimitive::from_u8(v).ok_or(DecodeError::MalformedInt)
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&false.to_aper(UNCONSTRAINED)?)?;
        enc.append(&(*self as u8).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// CauseProtocol
#[derive(Clone, Copy, FromPrimitive)]
pub enum CauseProtocol {
    TransferSyntaxError,
    AbstractSyntaxErrorReject,
    AbstractSyntaxErrorIgnoreAndNotify,
    MessageNotCompatibleWithReceiverState,
    SemanticError,
    AbstractSyntaxErrorFalselyConstructedMessage,
    Unspecified,
    _Extended,
}

impl APerElement for CauseProtocol {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        if bool::from_aper(decoder, Self::CONSTRAINTS)? {
            return Ok(CauseProtocol::_Extended);
        }
        let v = u8::from_aper(decoder, Self::CONSTRAINTS)?;
        FromPrimitive::from_u8(v).ok_or(DecodeError::MalformedInt)
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&false.to_aper(UNCONSTRAINED)?)?;
        enc.append(&(*self as u8).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// CauseRadioNetwork
#[derive(Clone, Copy, FromPrimitive)]
pub enum CauseRadioNetwork {
    Unspecified,
    RlFailureRlc,
    UnknownOrAlreadyAllocatedGnbCuUeF1apId,
    UnknownOrAlreadyAllocatedGnbDuUeF1apId,
    UnknownOrInconsistentPairOfUeF1apId,
    InteractionWithOtherProcedure,
    NotSupportedQciValue,
    ActionDesirableForRadioReasons,
    NoRadioResourcesAvailable,
    ProcedureCancelled,
    NormalRelease,
    _Extended,
}

impl APerElement for CauseRadioNetwork {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        if bool::from_aper(decoder, Self::CONSTRAINTS)? {
            return Ok(CauseRadioNetwork::_Extended);
        }
        let v = u8::from_aper(decoder, Self::CONSTRAINTS)?;
        FromPrimitive::from_u8(v).ok_or(DecodeError::MalformedInt)
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&false.to_aper(UNCONSTRAINED)?)?;
        enc.append(&(*self as u8).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// CauseTransport
#[derive(Clone, Copy, FromPrimitive)]
pub enum CauseTransport {
    Unspecified,
    TransportResourceUnavailable,
    _Extended,
}

impl APerElement for CauseTransport {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        if bool::from_aper(decoder, Self::CONSTRAINTS)? {
            return Ok(CauseTransport::_Extended);
        }
        let v = u8::from_aper(decoder, Self::CONSTRAINTS)?;
        FromPrimitive::from_u8(v).ok_or(DecodeError::MalformedInt)
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&false.to_aper(UNCONSTRAINED)?)?;
        enc.append(&(*self as u8).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// CellGroupConfig
#[derive(Clone)]
pub struct CellGroupConfig(pub Vec<u8>);

impl APerElement for CellGroupConfig {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        Ok(Self(Vec::<u8>::from_aper(decoder, Self::CONSTRAINTS)?))
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&(self.0).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// CellCapacityClassValue
#[derive(Clone)]
pub struct CellCapacityClassValue(pub u8);

impl APerElement for CellCapacityClassValue {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(100),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        Ok(Self(u8::from_aper(decoder, Self::CONSTRAINTS)?))
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&(self.0).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// CellDirection
#[derive(Clone, Copy, FromPrimitive)]
pub enum CellDirection {
    DlOnly,
    UlOnly,
}

impl APerElement for CellDirection {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let v = u8::from_aper(decoder, Self::CONSTRAINTS)?;
        FromPrimitive::from_u8(v).ok_or(DecodeError::MalformedInt)
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&(*self as u8).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// CellMeasurementResultList
#[derive(Clone)]
pub struct CellMeasurementResultList(pub Vec<CellMeasurementResultItem>);

impl APerElement for CellMeasurementResultList {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(1),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        Ok(Self(Vec::<CellMeasurementResultItem>::from_aper(
            decoder,
            Self::CONSTRAINTS,
        )?))
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&(self.0).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// CellMeasurementResultItem
#[derive(Clone)]
pub struct CellMeasurementResultItem {
    pub cell_id: Nrcgi,
    pub radio_resource_status: Option<RadioResourceStatus>,
    pub composite_available_capacity_group: Option<CompositeAvailableCapacityGroup>,
    pub slice_available_capacity: Option<SliceAvailableCapacity>,
    pub numberof_active_u_es: Option<NumberofActiveUEs>,
}

impl APerElement for CellMeasurementResultItem {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(5),
            max: Some(5),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let cell_id = Nrcgi::from_aper(decoder, UNCONSTRAINED)?;
        let radio_resource_status = if optionals.is_set(0) {
            Some(RadioResourceStatus::from_aper(decoder, UNCONSTRAINED)?)
        } else {
            None
        };
        let composite_available_capacity_group = if optionals.is_set(0) {
            Some(CompositeAvailableCapacityGroup::from_aper(
                decoder,
                UNCONSTRAINED,
            )?)
        } else {
            None
        };
        let slice_available_capacity = if optionals.is_set(0) {
            Some(SliceAvailableCapacity::from_aper(decoder, UNCONSTRAINED)?)
        } else {
            None
        };
        let numberof_active_u_es = if optionals.is_set(0) {
            Some(NumberofActiveUEs::from_aper(decoder, UNCONSTRAINED)?)
        } else {
            None
        };

        Ok(Self {
            cell_id,
            radio_resource_status,
            composite_available_capacity_group,
            slice_available_capacity,
            numberof_active_u_es,
        })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(5);
        optionals.set(0, self.radio_resource_status.is_some());
        optionals.set(1, self.composite_available_capacity_group.is_some());
        optionals.set(2, self.slice_available_capacity.is_some());
        optionals.set(3, self.numberof_active_u_es.is_some());
        optionals.set(4, false);

        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&self.cell_id.to_aper(UNCONSTRAINED)?)?;
        if let Some(x) = &self.radio_resource_status {
            enc.append(&x.to_aper(UNCONSTRAINED)?)?;
        }
        if let Some(x) = &self.composite_available_capacity_group {
            enc.append(&x.to_aper(UNCONSTRAINED)?)?;
        }
        if let Some(x) = &self.slice_available_capacity {
            enc.append(&x.to_aper(UNCONSTRAINED)?)?;
        }
        if let Some(x) = &self.numberof_active_u_es {
            enc.append(&x.to_aper(UNCONSTRAINED)?)?;
        }

        Ok(enc)
    }
}

// CellPortionId
#[derive(Clone)]
pub struct CellPortionId(pub u16);

impl APerElement for CellPortionId {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(0),
            max: Some(4095),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        Ok(Self(u16::from_aper(decoder, Self::CONSTRAINTS)?))
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&(self.0).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// CellsFailedToBeActivatedListItem
#[derive(Clone)]
pub struct CellsFailedToBeActivatedListItem {
    pub nrcgi: Nrcgi,
    pub cause: Cause,
}

impl APerElement for CellsFailedToBeActivatedListItem {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(1),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let _extended = bool::from_aper(decoder, UNCONSTRAINED)?;
        let _optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let nrcgi = Nrcgi::from_aper(decoder, UNCONSTRAINED)?;
        let cause = Cause::from_aper(decoder, UNCONSTRAINED)?;

        Ok(Self { nrcgi, cause })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(1);
        optionals.set(0, false);

        enc.append(&false.to_aper(UNCONSTRAINED)?)?;
        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&self.nrcgi.to_aper(UNCONSTRAINED)?)?;
        enc.append(&self.cause.to_aper(UNCONSTRAINED)?)?;

        Ok(enc)
    }
}

// CellsStatusItem
#[derive(Clone)]
pub struct CellsStatusItem {
    pub nrcgi: Nrcgi,
    pub service_status: ServiceStatus,
}

impl APerElement for CellsStatusItem {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(1),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let _extended = bool::from_aper(decoder, UNCONSTRAINED)?;
        let _optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let nrcgi = Nrcgi::from_aper(decoder, UNCONSTRAINED)?;
        let service_status = ServiceStatus::from_aper(decoder, UNCONSTRAINED)?;

        Ok(Self {
            nrcgi,
            service_status,
        })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(1);
        optionals.set(0, false);

        enc.append(&false.to_aper(UNCONSTRAINED)?)?;
        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&self.nrcgi.to_aper(UNCONSTRAINED)?)?;
        enc.append(&self.service_status.to_aper(UNCONSTRAINED)?)?;

        Ok(enc)
    }
}

// CellsToBeBroadcastItem
#[derive(Clone)]
pub struct CellsToBeBroadcastItem {
    pub nrcgi: Nrcgi,
}

impl APerElement for CellsToBeBroadcastItem {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(1),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let _extended = bool::from_aper(decoder, UNCONSTRAINED)?;
        let _optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let nrcgi = Nrcgi::from_aper(decoder, UNCONSTRAINED)?;

        Ok(Self { nrcgi })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(1);
        optionals.set(0, false);

        enc.append(&false.to_aper(UNCONSTRAINED)?)?;
        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&self.nrcgi.to_aper(UNCONSTRAINED)?)?;

        Ok(enc)
    }
}

// CellsBroadcastCompletedItem
#[derive(Clone)]
pub struct CellsBroadcastCompletedItem {
    pub nrcgi: Nrcgi,
}

impl APerElement for CellsBroadcastCompletedItem {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(1),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let _extended = bool::from_aper(decoder, UNCONSTRAINED)?;
        let _optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let nrcgi = Nrcgi::from_aper(decoder, UNCONSTRAINED)?;

        Ok(Self { nrcgi })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(1);
        optionals.set(0, false);

        enc.append(&false.to_aper(UNCONSTRAINED)?)?;
        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&self.nrcgi.to_aper(UNCONSTRAINED)?)?;

        Ok(enc)
    }
}

// BroadcastToBeCancelledItem
#[derive(Clone)]
pub struct BroadcastToBeCancelledItem {
    pub nrcgi: Nrcgi,
}

impl APerElement for BroadcastToBeCancelledItem {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(1),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let _extended = bool::from_aper(decoder, UNCONSTRAINED)?;
        let _optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let nrcgi = Nrcgi::from_aper(decoder, UNCONSTRAINED)?;

        Ok(Self { nrcgi })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(1);
        optionals.set(0, false);

        enc.append(&false.to_aper(UNCONSTRAINED)?)?;
        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&self.nrcgi.to_aper(UNCONSTRAINED)?)?;

        Ok(enc)
    }
}

// CellsBroadcastCancelledItem
#[derive(Clone)]
pub struct CellsBroadcastCancelledItem {
    pub nrcgi: Nrcgi,
    pub number_of_broadcasts: NumberOfBroadcasts,
}

impl APerElement for CellsBroadcastCancelledItem {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(1),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let _extended = bool::from_aper(decoder, UNCONSTRAINED)?;
        let _optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let nrcgi = Nrcgi::from_aper(decoder, UNCONSTRAINED)?;
        let number_of_broadcasts = NumberOfBroadcasts::from_aper(decoder, UNCONSTRAINED)?;

        Ok(Self {
            nrcgi,
            number_of_broadcasts,
        })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(1);
        optionals.set(0, false);

        enc.append(&false.to_aper(UNCONSTRAINED)?)?;
        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&self.nrcgi.to_aper(UNCONSTRAINED)?)?;
        enc.append(&self.number_of_broadcasts.to_aper(UNCONSTRAINED)?)?;

        Ok(enc)
    }
}

// CellsToBeActivatedListItem
#[derive(Clone)]
pub struct CellsToBeActivatedListItem {
    pub nrcgi: Nrcgi,
    pub nrpci: Option<Nrpci>,
}

impl APerElement for CellsToBeActivatedListItem {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(2),
            max: Some(2),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let _extended = bool::from_aper(decoder, UNCONSTRAINED)?;
        let optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let nrcgi = Nrcgi::from_aper(decoder, UNCONSTRAINED)?;
        let nrpci = if optionals.is_set(0) {
            Some(Nrpci::from_aper(decoder, UNCONSTRAINED)?)
        } else {
            None
        };

        Ok(Self { nrcgi, nrpci })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(2);
        optionals.set(0, self.nrpci.is_some());
        optionals.set(1, false);

        enc.append(&false.to_aper(UNCONSTRAINED)?)?;
        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&self.nrcgi.to_aper(UNCONSTRAINED)?)?;
        if let Some(x) = &self.nrpci {
            enc.append(&x.to_aper(UNCONSTRAINED)?)?;
        }

        Ok(enc)
    }
}

// CellsToBeDeactivatedListItem
#[derive(Clone)]
pub struct CellsToBeDeactivatedListItem {
    pub nrcgi: Nrcgi,
}

impl APerElement for CellsToBeDeactivatedListItem {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(1),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let _extended = bool::from_aper(decoder, UNCONSTRAINED)?;
        let _optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let nrcgi = Nrcgi::from_aper(decoder, UNCONSTRAINED)?;

        Ok(Self { nrcgi })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(1);
        optionals.set(0, false);

        enc.append(&false.to_aper(UNCONSTRAINED)?)?;
        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&self.nrcgi.to_aper(UNCONSTRAINED)?)?;

        Ok(enc)
    }
}

// CellsToBeBarredItem
#[derive(Clone)]
pub struct CellsToBeBarredItem {
    pub nrcgi: Nrcgi,
    pub cell_barred: CellBarred,
}

impl APerElement for CellsToBeBarredItem {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(1),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let _optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let nrcgi = Nrcgi::from_aper(decoder, UNCONSTRAINED)?;
        let cell_barred = CellBarred::from_aper(decoder, UNCONSTRAINED)?;

        Ok(Self { nrcgi, cell_barred })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(1);
        optionals.set(0, false);

        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&self.nrcgi.to_aper(UNCONSTRAINED)?)?;
        enc.append(&self.cell_barred.to_aper(UNCONSTRAINED)?)?;

        Ok(enc)
    }
}

// CellBarred
#[derive(Clone, Copy, FromPrimitive)]
pub enum CellBarred {
    Barred,
    NotBarred,
    _Extended,
}

impl APerElement for CellBarred {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        if bool::from_aper(decoder, Self::CONSTRAINTS)? {
            return Ok(CellBarred::_Extended);
        }
        let v = u8::from_aper(decoder, Self::CONSTRAINTS)?;
        FromPrimitive::from_u8(v).ok_or(DecodeError::MalformedInt)
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&false.to_aper(UNCONSTRAINED)?)?;
        enc.append(&(*self as u8).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// CellSize
#[derive(Clone, Copy, FromPrimitive)]
pub enum CellSize {
    Verysmall,
    Small,
    Medium,
    Large,
    _Extended,
}

impl APerElement for CellSize {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        if bool::from_aper(decoder, Self::CONSTRAINTS)? {
            return Ok(CellSize::_Extended);
        }
        let v = u8::from_aper(decoder, Self::CONSTRAINTS)?;
        FromPrimitive::from_u8(v).ok_or(DecodeError::MalformedInt)
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&false.to_aper(UNCONSTRAINED)?)?;
        enc.append(&(*self as u8).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// CellToReportList
#[derive(Clone)]
pub struct CellToReportList(pub Vec<CellToReportItem>);

impl APerElement for CellToReportList {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(1),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        Ok(Self(Vec::<CellToReportItem>::from_aper(
            decoder,
            Self::CONSTRAINTS,
        )?))
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&(self.0).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// CellToReportItem
#[derive(Clone)]
pub struct CellToReportItem {
    pub cell_id: Nrcgi,
    pub ssb_to_report_list: Option<SsbToReportList>,
    pub slice_to_report_list: Option<SliceToReportList>,
}

impl APerElement for CellToReportItem {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(3),
            max: Some(3),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let cell_id = Nrcgi::from_aper(decoder, UNCONSTRAINED)?;
        let ssb_to_report_list = if optionals.is_set(0) {
            Some(SsbToReportList::from_aper(decoder, UNCONSTRAINED)?)
        } else {
            None
        };
        let slice_to_report_list = if optionals.is_set(0) {
            Some(SliceToReportList::from_aper(decoder, UNCONSTRAINED)?)
        } else {
            None
        };

        Ok(Self {
            cell_id,
            ssb_to_report_list,
            slice_to_report_list,
        })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(3);
        optionals.set(0, self.ssb_to_report_list.is_some());
        optionals.set(1, self.slice_to_report_list.is_some());
        optionals.set(2, false);

        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&self.cell_id.to_aper(UNCONSTRAINED)?)?;
        if let Some(x) = &self.ssb_to_report_list {
            enc.append(&x.to_aper(UNCONSTRAINED)?)?;
        }
        if let Some(x) = &self.slice_to_report_list {
            enc.append(&x.to_aper(UNCONSTRAINED)?)?;
        }

        Ok(enc)
    }
}

// CellType
#[derive(Clone)]
pub struct CellType {
    pub cell_size: CellSize,
}

impl APerElement for CellType {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(1),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let _extended = bool::from_aper(decoder, UNCONSTRAINED)?;
        let _optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let cell_size = CellSize::from_aper(decoder, UNCONSTRAINED)?;

        Ok(Self { cell_size })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(1);
        optionals.set(0, false);

        enc.append(&false.to_aper(UNCONSTRAINED)?)?;
        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&self.cell_size.to_aper(UNCONSTRAINED)?)?;

        Ok(enc)
    }
}

// CellUlConfigured
#[derive(Clone, Copy, FromPrimitive)]
pub enum CellUlConfigured {
    None,
    Ul,
    Sul,
    UlAndSul,
    _Extended,
}

impl APerElement for CellUlConfigured {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        if bool::from_aper(decoder, Self::CONSTRAINTS)? {
            return Ok(CellUlConfigured::_Extended);
        }
        let v = u8::from_aper(decoder, Self::CONSTRAINTS)?;
        FromPrimitive::from_u8(v).ok_or(DecodeError::MalformedInt)
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&false.to_aper(UNCONSTRAINED)?)?;
        enc.append(&(*self as u8).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// ChildNodeCellsList
#[derive(Clone)]
pub struct ChildNodeCellsList(pub Vec<ChildNodeCellsListItem>);

impl APerElement for ChildNodeCellsList {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(1),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        Ok(Self(Vec::<ChildNodeCellsListItem>::from_aper(
            decoder,
            Self::CONSTRAINTS,
        )?))
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&(self.0).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// ChildNodeCellsListItem
#[derive(Clone)]
pub struct ChildNodeCellsListItem {
    pub nrcgi: Nrcgi,
    pub iab_du_cell_resource_configuration_mode_info:
        Option<IabDuCellResourceConfigurationModeInfo>,
    pub iab_stc_info: Option<IabStcInfo>,
    pub rach_config_common: Option<RachConfigCommon>,
    pub rach_config_common_iab: Option<RachConfigCommonIab>,
    pub csi_rs_configuration: Option<Vec<u8>>,
    pub sr_configuration: Option<Vec<u8>>,
    pub pdcch_config_sib1: Option<Vec<u8>>,
    pub scs_common: Option<Vec<u8>>,
    pub multiplexing_info: Option<MultiplexingInfo>,
}

impl APerElement for ChildNodeCellsListItem {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(10),
            max: Some(10),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let nrcgi = Nrcgi::from_aper(decoder, UNCONSTRAINED)?;
        let iab_du_cell_resource_configuration_mode_info = if optionals.is_set(0) {
            Some(IabDuCellResourceConfigurationModeInfo::from_aper(
                decoder,
                UNCONSTRAINED,
            )?)
        } else {
            None
        };
        let iab_stc_info = if optionals.is_set(0) {
            Some(IabStcInfo::from_aper(decoder, UNCONSTRAINED)?)
        } else {
            None
        };
        let rach_config_common = if optionals.is_set(0) {
            Some(RachConfigCommon::from_aper(decoder, UNCONSTRAINED)?)
        } else {
            None
        };
        let rach_config_common_iab = if optionals.is_set(0) {
            Some(RachConfigCommonIab::from_aper(decoder, UNCONSTRAINED)?)
        } else {
            None
        };
        let csi_rs_configuration = if optionals.is_set(0) {
            Some(Vec::<u8>::from_aper(decoder, UNCONSTRAINED)?)
        } else {
            None
        };
        let sr_configuration = if optionals.is_set(0) {
            Some(Vec::<u8>::from_aper(decoder, UNCONSTRAINED)?)
        } else {
            None
        };
        let pdcch_config_sib1 = if optionals.is_set(0) {
            Some(Vec::<u8>::from_aper(decoder, UNCONSTRAINED)?)
        } else {
            None
        };
        let scs_common = if optionals.is_set(0) {
            Some(Vec::<u8>::from_aper(decoder, UNCONSTRAINED)?)
        } else {
            None
        };
        let multiplexing_info = if optionals.is_set(0) {
            Some(MultiplexingInfo::from_aper(decoder, UNCONSTRAINED)?)
        } else {
            None
        };

        Ok(Self {
            nrcgi,
            iab_du_cell_resource_configuration_mode_info,
            iab_stc_info,
            rach_config_common,
            rach_config_common_iab,
            csi_rs_configuration,
            sr_configuration,
            pdcch_config_sib1,
            scs_common,
            multiplexing_info,
        })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(10);
        optionals.set(
            0,
            self.iab_du_cell_resource_configuration_mode_info.is_some(),
        );
        optionals.set(1, self.iab_stc_info.is_some());
        optionals.set(2, self.rach_config_common.is_some());
        optionals.set(3, self.rach_config_common_iab.is_some());
        optionals.set(4, self.csi_rs_configuration.is_some());
        optionals.set(5, self.sr_configuration.is_some());
        optionals.set(6, self.pdcch_config_sib1.is_some());
        optionals.set(7, self.scs_common.is_some());
        optionals.set(8, self.multiplexing_info.is_some());
        optionals.set(9, false);

        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&self.nrcgi.to_aper(UNCONSTRAINED)?)?;
        if let Some(x) = &self.iab_du_cell_resource_configuration_mode_info {
            enc.append(&x.to_aper(UNCONSTRAINED)?)?;
        }
        if let Some(x) = &self.iab_stc_info {
            enc.append(&x.to_aper(UNCONSTRAINED)?)?;
        }
        if let Some(x) = &self.rach_config_common {
            enc.append(&x.to_aper(UNCONSTRAINED)?)?;
        }
        if let Some(x) = &self.rach_config_common_iab {
            enc.append(&x.to_aper(UNCONSTRAINED)?)?;
        }
        if let Some(x) = &self.csi_rs_configuration {
            enc.append(&x.to_aper(UNCONSTRAINED)?)?;
        }
        if let Some(x) = &self.sr_configuration {
            enc.append(&x.to_aper(UNCONSTRAINED)?)?;
        }
        if let Some(x) = &self.pdcch_config_sib1 {
            enc.append(&x.to_aper(UNCONSTRAINED)?)?;
        }
        if let Some(x) = &self.scs_common {
            enc.append(&x.to_aper(UNCONSTRAINED)?)?;
        }
        if let Some(x) = &self.multiplexing_info {
            enc.append(&x.to_aper(UNCONSTRAINED)?)?;
        }

        Ok(enc)
    }
}

// ChildNodesList
#[derive(Clone)]
pub struct ChildNodesList(pub Vec<ChildNodesListItem>);

impl APerElement for ChildNodesList {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(1),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        Ok(Self(Vec::<ChildNodesListItem>::from_aper(
            decoder,
            Self::CONSTRAINTS,
        )?))
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&(self.0).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// ChildNodesListItem
#[derive(Clone)]
pub struct ChildNodesListItem {
    pub gnb_cu_ue_f1ap_id: GnbCuUeF1apId,
    pub gnb_du_ue_f1ap_id: GnbDuUeF1apId,
    pub child_node_cells_list: Option<ChildNodeCellsList>,
}

impl APerElement for ChildNodesListItem {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(2),
            max: Some(2),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let gnb_cu_ue_f1ap_id = GnbCuUeF1apId::from_aper(decoder, UNCONSTRAINED)?;
        let gnb_du_ue_f1ap_id = GnbDuUeF1apId::from_aper(decoder, UNCONSTRAINED)?;
        let child_node_cells_list = if optionals.is_set(0) {
            Some(ChildNodeCellsList::from_aper(decoder, UNCONSTRAINED)?)
        } else {
            None
        };

        Ok(Self {
            gnb_cu_ue_f1ap_id,
            gnb_du_ue_f1ap_id,
            child_node_cells_list,
        })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(2);
        optionals.set(0, self.child_node_cells_list.is_some());
        optionals.set(1, false);

        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&self.gnb_cu_ue_f1ap_id.to_aper(UNCONSTRAINED)?)?;
        enc.append(&self.gnb_du_ue_f1ap_id.to_aper(UNCONSTRAINED)?)?;
        if let Some(x) = &self.child_node_cells_list {
            enc.append(&x.to_aper(UNCONSTRAINED)?)?;
        }

        Ok(enc)
    }
}

// ChOtriggerInterDu
#[derive(Clone, Copy, FromPrimitive)]
pub enum ChOtriggerInterDu {
    ChoInitiation,
    ChoReplace,
    _Extended,
}

impl APerElement for ChOtriggerInterDu {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        if bool::from_aper(decoder, Self::CONSTRAINTS)? {
            return Ok(ChOtriggerInterDu::_Extended);
        }
        let v = u8::from_aper(decoder, Self::CONSTRAINTS)?;
        FromPrimitive::from_u8(v).ok_or(DecodeError::MalformedInt)
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&false.to_aper(UNCONSTRAINED)?)?;
        enc.append(&(*self as u8).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// ChOtriggerIntraDu
#[derive(Clone, Copy, FromPrimitive)]
pub enum ChOtriggerIntraDu {
    ChoInitiation,
    ChoReplace,
    ChoCancel,
    _Extended,
}

impl APerElement for ChOtriggerIntraDu {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        if bool::from_aper(decoder, Self::CONSTRAINTS)? {
            return Ok(ChOtriggerIntraDu::_Extended);
        }
        let v = u8::from_aper(decoder, Self::CONSTRAINTS)?;
        FromPrimitive::from_u8(v).ok_or(DecodeError::MalformedInt)
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&false.to_aper(UNCONSTRAINED)?)?;
        enc.append(&(*self as u8).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// CnuePagingIdentity
#[derive(Clone)]
pub enum CnuePagingIdentity {
    FiveGSTmsi(BitString),
    _Extended,
}

impl APerElement for CnuePagingIdentity {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        match u8::from_aper(decoder, UNCONSTRAINED)? {
            0 => Ok(Self::FiveGSTmsi(BitString::from_aper(
                decoder,
                Constraints {
                    value: None,
                    size: Some(Constraint::new(Some(48), Some(48))),
                },
            )?)),
            1 => Err(DecodeError::NotImplemented),
            _ => Err(DecodeError::InvalidChoice),
        }
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        match self {
            Self::FiveGSTmsi(x) => {
                enc.append(&(0 as u8).to_aper(UNCONSTRAINED)?)?;
                enc.append(&x.to_aper(Constraints {
                    value: None,
                    size: Some(Constraint::new(Some(48), Some(48))),
                })?)?;
            }
            Self::_Extended => return Err(EncodeError::NotImplemented),
        }
        Ok(enc)
    }
}

// CompositeAvailableCapacityGroup
#[derive(Clone)]
pub struct CompositeAvailableCapacityGroup {
    pub composite_available_capacity_downlink: CompositeAvailableCapacity,
    pub composite_available_capacity_uplink: CompositeAvailableCapacity,
}

impl APerElement for CompositeAvailableCapacityGroup {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(1),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let _optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let composite_available_capacity_downlink =
            CompositeAvailableCapacity::from_aper(decoder, UNCONSTRAINED)?;
        let composite_available_capacity_uplink =
            CompositeAvailableCapacity::from_aper(decoder, UNCONSTRAINED)?;

        Ok(Self {
            composite_available_capacity_downlink,
            composite_available_capacity_uplink,
        })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(1);
        optionals.set(0, false);

        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(
            &self
                .composite_available_capacity_downlink
                .to_aper(UNCONSTRAINED)?,
        )?;
        enc.append(
            &self
                .composite_available_capacity_uplink
                .to_aper(UNCONSTRAINED)?,
        )?;

        Ok(enc)
    }
}

// CompositeAvailableCapacity
#[derive(Clone)]
pub struct CompositeAvailableCapacity {
    pub cell_capacity_class_value: Option<CellCapacityClassValue>,
    pub capacity_value: CapacityValue,
}

impl APerElement for CompositeAvailableCapacity {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(2),
            max: Some(2),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let cell_capacity_class_value = if optionals.is_set(0) {
            Some(CellCapacityClassValue::from_aper(decoder, UNCONSTRAINED)?)
        } else {
            None
        };
        let capacity_value = CapacityValue::from_aper(decoder, UNCONSTRAINED)?;

        Ok(Self {
            cell_capacity_class_value,
            capacity_value,
        })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(2);
        optionals.set(0, self.cell_capacity_class_value.is_some());
        optionals.set(1, false);

        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        if let Some(x) = &self.cell_capacity_class_value {
            enc.append(&x.to_aper(UNCONSTRAINED)?)?;
        }
        enc.append(&self.capacity_value.to_aper(UNCONSTRAINED)?)?;

        Ok(enc)
    }
}

// ChoProbability
#[derive(Clone)]
pub struct ChoProbability(pub u8);

impl APerElement for ChoProbability {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(1),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        Ok(Self(u8::from_aper(decoder, Self::CONSTRAINTS)?))
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&(self.0).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// ConditionalInterDuMobilityInformation
#[derive(Clone)]
pub struct ConditionalInterDuMobilityInformation {
    pub cho_trigger: ChOtriggerInterDu,
    pub target_gnb_duuef1apid: Option<GnbDuUeF1apId>,
}

impl APerElement for ConditionalInterDuMobilityInformation {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(2),
            max: Some(2),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let _extended = bool::from_aper(decoder, UNCONSTRAINED)?;
        let optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let cho_trigger = ChOtriggerInterDu::from_aper(decoder, UNCONSTRAINED)?;
        let target_gnb_duuef1apid = if optionals.is_set(0) {
            Some(GnbDuUeF1apId::from_aper(decoder, UNCONSTRAINED)?)
        } else {
            None
        };

        Ok(Self {
            cho_trigger,
            target_gnb_duuef1apid,
        })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(2);
        optionals.set(0, self.target_gnb_duuef1apid.is_some());
        optionals.set(1, false);

        enc.append(&false.to_aper(UNCONSTRAINED)?)?;
        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&self.cho_trigger.to_aper(UNCONSTRAINED)?)?;
        if let Some(x) = &self.target_gnb_duuef1apid {
            enc.append(&x.to_aper(UNCONSTRAINED)?)?;
        }

        Ok(enc)
    }
}

// ConditionalIntraDuMobilityInformation
#[derive(Clone)]
pub struct ConditionalIntraDuMobilityInformation {
    pub cho_trigger: ChOtriggerIntraDu,
    pub target_cells_tocancel: Option<TargetCellList>,
}

impl APerElement for ConditionalIntraDuMobilityInformation {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(2),
            max: Some(2),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let _extended = bool::from_aper(decoder, UNCONSTRAINED)?;
        let optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let cho_trigger = ChOtriggerIntraDu::from_aper(decoder, UNCONSTRAINED)?;
        let target_cells_tocancel = if optionals.is_set(0) {
            Some(TargetCellList::from_aper(decoder, UNCONSTRAINED)?)
        } else {
            None
        };

        Ok(Self {
            cho_trigger,
            target_cells_tocancel,
        })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(2);
        optionals.set(0, self.target_cells_tocancel.is_some());
        optionals.set(1, false);

        enc.append(&false.to_aper(UNCONSTRAINED)?)?;
        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&self.cho_trigger.to_aper(UNCONSTRAINED)?)?;
        if let Some(x) = &self.target_cells_tocancel {
            enc.append(&x.to_aper(UNCONSTRAINED)?)?;
        }

        Ok(enc)
    }
}

// ConfiguredTacIndication
#[derive(Clone, Copy, FromPrimitive)]
pub enum ConfiguredTacIndication {
    True,
    _Extended,
}

impl APerElement for ConfiguredTacIndication {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        if bool::from_aper(decoder, Self::CONSTRAINTS)? {
            return Ok(ConfiguredTacIndication::_Extended);
        }
        let v = u8::from_aper(decoder, Self::CONSTRAINTS)?;
        FromPrimitive::from_u8(v).ok_or(DecodeError::MalformedInt)
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&false.to_aper(UNCONSTRAINED)?)?;
        enc.append(&(*self as u8).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// CoordinateId
#[derive(Clone)]
pub struct CoordinateId(pub u16);

impl APerElement for CoordinateId {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(0),
            max: Some(511),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        Ok(Self(u16::from_aper(decoder, Self::CONSTRAINTS)?))
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&(self.0).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// CpTransportLayerAddress
#[derive(Clone)]
pub enum CpTransportLayerAddress {
    EndpointIpAddress(TransportLayerAddress),
    EndpointIpAddressAndPort(EndpointIpAddressAndPort),
    _Extended,
}

impl APerElement for CpTransportLayerAddress {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        match u8::from_aper(decoder, UNCONSTRAINED)? {
            0 => Ok(Self::EndpointIpAddress(TransportLayerAddress::from_aper(
                decoder,
                UNCONSTRAINED,
            )?)),
            1 => Ok(Self::EndpointIpAddressAndPort(
                EndpointIpAddressAndPort::from_aper(decoder, UNCONSTRAINED)?,
            )),
            2 => Err(DecodeError::NotImplemented),
            _ => Err(DecodeError::InvalidChoice),
        }
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        match self {
            Self::EndpointIpAddress(x) => {
                enc.append(&(0 as u8).to_aper(UNCONSTRAINED)?)?;
                enc.append(&x.to_aper(UNCONSTRAINED)?)?;
            }
            Self::EndpointIpAddressAndPort(x) => {
                enc.append(&(1 as u8).to_aper(UNCONSTRAINED)?)?;
                enc.append(&x.to_aper(UNCONSTRAINED)?)?;
            }
            Self::_Extended => return Err(EncodeError::NotImplemented),
        }
        Ok(enc)
    }
}

// CpTrafficType
#[derive(Clone)]
pub struct CpTrafficType(pub u8);

impl APerElement for CpTrafficType {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(3),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        Ok(Self(u8::from_aper(decoder, Self::CONSTRAINTS)?))
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&(self.0).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// CriticalityDiagnostics
#[derive(Clone)]
pub struct CriticalityDiagnostics {
    pub procedure_code: Option<ProcedureCode>,
    pub triggering_message: Option<TriggeringMessage>,
    pub procedure_criticality: Option<Criticality>,
    pub transaction_id: Option<TransactionId>,
    pub i_es_criticality_diagnostics: Option<CriticalityDiagnosticsIeList>,
}

impl APerElement for CriticalityDiagnostics {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(6),
            max: Some(6),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let _extended = bool::from_aper(decoder, UNCONSTRAINED)?;
        let optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let procedure_code = if optionals.is_set(0) {
            Some(ProcedureCode::from_aper(decoder, UNCONSTRAINED)?)
        } else {
            None
        };
        let triggering_message = if optionals.is_set(0) {
            Some(TriggeringMessage::from_aper(decoder, UNCONSTRAINED)?)
        } else {
            None
        };
        let procedure_criticality = if optionals.is_set(0) {
            Some(Criticality::from_aper(decoder, UNCONSTRAINED)?)
        } else {
            None
        };
        let transaction_id = if optionals.is_set(0) {
            Some(TransactionId::from_aper(decoder, UNCONSTRAINED)?)
        } else {
            None
        };
        let i_es_criticality_diagnostics = if optionals.is_set(0) {
            Some(CriticalityDiagnosticsIeList::from_aper(
                decoder,
                UNCONSTRAINED,
            )?)
        } else {
            None
        };

        Ok(Self {
            procedure_code,
            triggering_message,
            procedure_criticality,
            transaction_id,
            i_es_criticality_diagnostics,
        })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(6);
        optionals.set(0, self.procedure_code.is_some());
        optionals.set(1, self.triggering_message.is_some());
        optionals.set(2, self.procedure_criticality.is_some());
        optionals.set(3, self.transaction_id.is_some());
        optionals.set(4, self.i_es_criticality_diagnostics.is_some());
        optionals.set(5, false);

        enc.append(&false.to_aper(UNCONSTRAINED)?)?;
        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        if let Some(x) = &self.procedure_code {
            enc.append(&x.to_aper(UNCONSTRAINED)?)?;
        }
        if let Some(x) = &self.triggering_message {
            enc.append(&x.to_aper(UNCONSTRAINED)?)?;
        }
        if let Some(x) = &self.procedure_criticality {
            enc.append(&x.to_aper(UNCONSTRAINED)?)?;
        }
        if let Some(x) = &self.transaction_id {
            enc.append(&x.to_aper(UNCONSTRAINED)?)?;
        }
        if let Some(x) = &self.i_es_criticality_diagnostics {
            enc.append(&x.to_aper(UNCONSTRAINED)?)?;
        }

        Ok(enc)
    }
}

// CriticalityDiagnosticsIeList
#[derive(Clone)]
pub struct CriticalityDiagnosticsIeList(pub Vec<CriticalityDiagnosticsIeItem>);

impl APerElement for CriticalityDiagnosticsIeList {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(1),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        Ok(Self(Vec::<CriticalityDiagnosticsIeItem>::from_aper(
            decoder,
            Self::CONSTRAINTS,
        )?))
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&(self.0).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// CriticalityDiagnosticsIeItem
#[derive(Clone)]
pub struct CriticalityDiagnosticsIeItem {
    pub ie_criticality: Criticality,
    pub ie_id: ProtocolIeId,
    pub type_of_error: TypeOfError,
}

impl APerElement for CriticalityDiagnosticsIeItem {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(1),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let _extended = bool::from_aper(decoder, UNCONSTRAINED)?;
        let _optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let ie_criticality = Criticality::from_aper(decoder, UNCONSTRAINED)?;
        let ie_id = ProtocolIeId::from_aper(decoder, UNCONSTRAINED)?;
        let type_of_error = TypeOfError::from_aper(decoder, UNCONSTRAINED)?;

        Ok(Self {
            ie_criticality,
            ie_id,
            type_of_error,
        })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(1);
        optionals.set(0, false);

        enc.append(&false.to_aper(UNCONSTRAINED)?)?;
        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&self.ie_criticality.to_aper(UNCONSTRAINED)?)?;
        enc.append(&self.ie_id.to_aper(UNCONSTRAINED)?)?;
        enc.append(&self.type_of_error.to_aper(UNCONSTRAINED)?)?;

        Ok(enc)
    }
}

// CRnti
#[derive(Clone)]
pub struct CRnti(pub u16);

impl APerElement for CRnti {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(0),
            max: Some(65535),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        Ok(Self(u16::from_aper(decoder, Self::CONSTRAINTS)?))
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&(self.0).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// CuduRadioInformationType
#[derive(Clone)]
pub enum CuduRadioInformationType {
    Rim(CudurimInformation),
    _Extended,
}

impl APerElement for CuduRadioInformationType {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        match u8::from_aper(decoder, UNCONSTRAINED)? {
            0 => Ok(Self::Rim(CudurimInformation::from_aper(
                decoder,
                UNCONSTRAINED,
            )?)),
            1 => Err(DecodeError::NotImplemented),
            _ => Err(DecodeError::InvalidChoice),
        }
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        match self {
            Self::Rim(x) => {
                enc.append(&(0 as u8).to_aper(UNCONSTRAINED)?)?;
                enc.append(&x.to_aper(UNCONSTRAINED)?)?;
            }
            Self::_Extended => return Err(EncodeError::NotImplemented),
        }
        Ok(enc)
    }
}

// CudurimInformation
#[derive(Clone)]
pub struct CudurimInformation {
    pub victim_gnb_set_id: GnbSetId,
    pub rimrs_detection_status: RimrsDetectionStatus,
}

impl APerElement for CudurimInformation {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(1),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let _optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let victim_gnb_set_id = GnbSetId::from_aper(decoder, UNCONSTRAINED)?;
        let rimrs_detection_status = RimrsDetectionStatus::from_aper(decoder, UNCONSTRAINED)?;

        Ok(Self {
            victim_gnb_set_id,
            rimrs_detection_status,
        })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(1);
        optionals.set(0, false);

        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&self.victim_gnb_set_id.to_aper(UNCONSTRAINED)?)?;
        enc.append(&self.rimrs_detection_status.to_aper(UNCONSTRAINED)?)?;

        Ok(enc)
    }
}

// CUtoDurrcInformation
#[derive(Clone)]
pub struct CUtoDurrcInformation {
    pub cg_config_info: Option<CgConfigInfo>,
    pub ue_capability_rat_container_list: Option<UeCapabilityRatContainerList>,
    pub meas_config: Option<MeasConfig>,
}

impl APerElement for CUtoDurrcInformation {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(4),
            max: Some(4),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let _extended = bool::from_aper(decoder, UNCONSTRAINED)?;
        let optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let cg_config_info = if optionals.is_set(0) {
            Some(CgConfigInfo::from_aper(decoder, UNCONSTRAINED)?)
        } else {
            None
        };
        let ue_capability_rat_container_list = if optionals.is_set(0) {
            Some(UeCapabilityRatContainerList::from_aper(
                decoder,
                UNCONSTRAINED,
            )?)
        } else {
            None
        };
        let meas_config = if optionals.is_set(0) {
            Some(MeasConfig::from_aper(decoder, UNCONSTRAINED)?)
        } else {
            None
        };

        Ok(Self {
            cg_config_info,
            ue_capability_rat_container_list,
            meas_config,
        })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(4);
        optionals.set(0, self.cg_config_info.is_some());
        optionals.set(1, self.ue_capability_rat_container_list.is_some());
        optionals.set(2, self.meas_config.is_some());
        optionals.set(3, false);

        enc.append(&false.to_aper(UNCONSTRAINED)?)?;
        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        if let Some(x) = &self.cg_config_info {
            enc.append(&x.to_aper(UNCONSTRAINED)?)?;
        }
        if let Some(x) = &self.ue_capability_rat_container_list {
            enc.append(&x.to_aper(UNCONSTRAINED)?)?;
        }
        if let Some(x) = &self.meas_config {
            enc.append(&x.to_aper(UNCONSTRAINED)?)?;
        }

        Ok(enc)
    }
}

// DcBasedDuplicationConfigured
#[derive(Clone, Copy, FromPrimitive)]
pub enum DcBasedDuplicationConfigured {
    True,
    _Extended,
}

impl APerElement for DcBasedDuplicationConfigured {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        if bool::from_aper(decoder, Self::CONSTRAINTS)? {
            return Ok(DcBasedDuplicationConfigured::_Extended);
        }
        let v = u8::from_aper(decoder, Self::CONSTRAINTS)?;
        FromPrimitive::from_u8(v).ok_or(DecodeError::MalformedInt)
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&false.to_aper(UNCONSTRAINED)?)?;
        enc.append(&(*self as u8).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// DedicatedSiDeliveryNeededUeItem
#[derive(Clone)]
pub struct DedicatedSiDeliveryNeededUeItem {
    pub gnb_cu_ue_f1ap_id: GnbCuUeF1apId,
    pub nrcgi: Nrcgi,
}

impl APerElement for DedicatedSiDeliveryNeededUeItem {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(1),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let _extended = bool::from_aper(decoder, UNCONSTRAINED)?;
        let _optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let gnb_cu_ue_f1ap_id = GnbCuUeF1apId::from_aper(decoder, UNCONSTRAINED)?;
        let nrcgi = Nrcgi::from_aper(decoder, UNCONSTRAINED)?;

        Ok(Self {
            gnb_cu_ue_f1ap_id,
            nrcgi,
        })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(1);
        optionals.set(0, false);

        enc.append(&false.to_aper(UNCONSTRAINED)?)?;
        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&self.gnb_cu_ue_f1ap_id.to_aper(UNCONSTRAINED)?)?;
        enc.append(&self.nrcgi.to_aper(UNCONSTRAINED)?)?;

        Ok(enc)
    }
}

// DlPrs
#[derive(Clone)]
pub struct DlPrs {
    pub prsid: u8,
    pub dl_prs_resource_set_id: PrsResourceSetId,
    pub dl_prs_resource_id: Option<PrsResourceId>,
}

impl APerElement for DlPrs {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(2),
            max: Some(2),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let prsid = u8::from_aper(decoder, UNCONSTRAINED)?;
        let dl_prs_resource_set_id = PrsResourceSetId::from_aper(decoder, UNCONSTRAINED)?;
        let dl_prs_resource_id = if optionals.is_set(0) {
            Some(PrsResourceId::from_aper(decoder, UNCONSTRAINED)?)
        } else {
            None
        };

        Ok(Self {
            prsid,
            dl_prs_resource_set_id,
            dl_prs_resource_id,
        })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(2);
        optionals.set(0, self.dl_prs_resource_id.is_some());
        optionals.set(1, false);

        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&self.prsid.to_aper(UNCONSTRAINED)?)?;
        enc.append(&self.dl_prs_resource_set_id.to_aper(UNCONSTRAINED)?)?;
        if let Some(x) = &self.dl_prs_resource_id {
            enc.append(&x.to_aper(UNCONSTRAINED)?)?;
        }

        Ok(enc)
    }
}

// DlPrsMutingPattern
#[derive(Clone)]
pub enum DlPrsMutingPattern {
    Two(BitString),
    Four(BitString),
    Six(BitString),
    Eight(BitString),
    Sixteen(BitString),
    ThirtyTwo(BitString),
    _Extended,
}

impl APerElement for DlPrsMutingPattern {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        match u8::from_aper(decoder, UNCONSTRAINED)? {
            0 => Ok(Self::Two(BitString::from_aper(
                decoder,
                Constraints {
                    value: None,
                    size: Some(Constraint::new(Some(2), Some(2))),
                },
            )?)),
            1 => Ok(Self::Four(BitString::from_aper(
                decoder,
                Constraints {
                    value: None,
                    size: Some(Constraint::new(Some(4), Some(4))),
                },
            )?)),
            2 => Ok(Self::Six(BitString::from_aper(
                decoder,
                Constraints {
                    value: None,
                    size: Some(Constraint::new(Some(6), Some(6))),
                },
            )?)),
            3 => Ok(Self::Eight(BitString::from_aper(
                decoder,
                Constraints {
                    value: None,
                    size: Some(Constraint::new(Some(8), Some(8))),
                },
            )?)),
            4 => Ok(Self::Sixteen(BitString::from_aper(
                decoder,
                Constraints {
                    value: None,
                    size: Some(Constraint::new(Some(16), Some(16))),
                },
            )?)),
            5 => Ok(Self::ThirtyTwo(BitString::from_aper(
                decoder,
                Constraints {
                    value: None,
                    size: Some(Constraint::new(Some(32), Some(32))),
                },
            )?)),
            6 => Err(DecodeError::NotImplemented),
            _ => Err(DecodeError::InvalidChoice),
        }
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        match self {
            Self::Two(x) => {
                enc.append(&(0 as u8).to_aper(UNCONSTRAINED)?)?;
                enc.append(&x.to_aper(Constraints {
                    value: None,
                    size: Some(Constraint::new(Some(2), Some(2))),
                })?)?;
            }
            Self::Four(x) => {
                enc.append(&(1 as u8).to_aper(UNCONSTRAINED)?)?;
                enc.append(&x.to_aper(Constraints {
                    value: None,
                    size: Some(Constraint::new(Some(4), Some(4))),
                })?)?;
            }
            Self::Six(x) => {
                enc.append(&(2 as u8).to_aper(UNCONSTRAINED)?)?;
                enc.append(&x.to_aper(Constraints {
                    value: None,
                    size: Some(Constraint::new(Some(6), Some(6))),
                })?)?;
            }
            Self::Eight(x) => {
                enc.append(&(3 as u8).to_aper(UNCONSTRAINED)?)?;
                enc.append(&x.to_aper(Constraints {
                    value: None,
                    size: Some(Constraint::new(Some(8), Some(8))),
                })?)?;
            }
            Self::Sixteen(x) => {
                enc.append(&(4 as u8).to_aper(UNCONSTRAINED)?)?;
                enc.append(&x.to_aper(Constraints {
                    value: None,
                    size: Some(Constraint::new(Some(16), Some(16))),
                })?)?;
            }
            Self::ThirtyTwo(x) => {
                enc.append(&(5 as u8).to_aper(UNCONSTRAINED)?)?;
                enc.append(&x.to_aper(Constraints {
                    value: None,
                    size: Some(Constraint::new(Some(32), Some(32))),
                })?)?;
            }
            Self::_Extended => return Err(EncodeError::NotImplemented),
        }
        Ok(enc)
    }
}

// DlprsResourceCoordinates
#[derive(Clone)]
pub struct DlprsResourceCoordinates {
    pub listof_dl_prs_resource_set_arp: Vec<DlprsResourceSetArp>,
}

impl APerElement for DlprsResourceCoordinates {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(1),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let _optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let listof_dl_prs_resource_set_arp = Vec::<DlprsResourceSetArp>::from_aper(
            decoder,
            Constraints {
                value: None,
                size: Some(Constraint::new(Some(1), Some(maxnoofPRS - ResourceSets))),
            },
        )?;

        Ok(Self {
            listof_dl_prs_resource_set_arp,
        })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(1);
        optionals.set(0, false);

        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&self.listof_dl_prs_resource_set_arp.to_aper(UNCONSTRAINED)?)?;

        Ok(enc)
    }
}

// DlprsResourceSetArp
#[derive(Clone)]
pub struct DlprsResourceSetArp {
    pub dl_prs_resource_set_id: PrsResourceSetId,
    pub dl_prs_resource_set_arp_location: DlPrsResourceSetArpLocation,
    pub listof_dl_prs_resource_arp: Vec<DlprsResourceArp>,
}

impl APerElement for DlprsResourceSetArp {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(1),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let _optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let dl_prs_resource_set_id = PrsResourceSetId::from_aper(decoder, UNCONSTRAINED)?;
        let dl_prs_resource_set_arp_location =
            DlPrsResourceSetArpLocation::from_aper(decoder, UNCONSTRAINED)?;
        let listof_dl_prs_resource_arp = Vec::<DlprsResourceArp>::from_aper(
            decoder,
            Constraints {
                value: None,
                size: Some(Constraint::new(Some(1), Some(maxnoofPRS - ResourcesPerSet))),
            },
        )?;

        Ok(Self {
            dl_prs_resource_set_id,
            dl_prs_resource_set_arp_location,
            listof_dl_prs_resource_arp,
        })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(1);
        optionals.set(0, false);

        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&self.dl_prs_resource_set_id.to_aper(UNCONSTRAINED)?)?;
        enc.append(
            &self
                .dl_prs_resource_set_arp_location
                .to_aper(UNCONSTRAINED)?,
        )?;
        enc.append(&self.listof_dl_prs_resource_arp.to_aper(UNCONSTRAINED)?)?;

        Ok(enc)
    }
}

// DlPrsResourceSetArpLocation
#[derive(Clone)]
pub enum DlPrsResourceSetArpLocation {
    RelativeGeodeticLocation(RelativeGeodeticLocation),
    RelativeCartesianLocation(RelativeCartesianLocation),
    _Extended,
}

impl APerElement for DlPrsResourceSetArpLocation {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        match u8::from_aper(decoder, UNCONSTRAINED)? {
            0 => Ok(Self::RelativeGeodeticLocation(
                RelativeGeodeticLocation::from_aper(decoder, UNCONSTRAINED)?,
            )),
            1 => Ok(Self::RelativeCartesianLocation(
                RelativeCartesianLocation::from_aper(decoder, UNCONSTRAINED)?,
            )),
            2 => Err(DecodeError::NotImplemented),
            _ => Err(DecodeError::InvalidChoice),
        }
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        match self {
            Self::RelativeGeodeticLocation(x) => {
                enc.append(&(0 as u8).to_aper(UNCONSTRAINED)?)?;
                enc.append(&x.to_aper(UNCONSTRAINED)?)?;
            }
            Self::RelativeCartesianLocation(x) => {
                enc.append(&(1 as u8).to_aper(UNCONSTRAINED)?)?;
                enc.append(&x.to_aper(UNCONSTRAINED)?)?;
            }
            Self::_Extended => return Err(EncodeError::NotImplemented),
        }
        Ok(enc)
    }
}

// DlprsResourceArp
#[derive(Clone)]
pub struct DlprsResourceArp {
    pub dl_prs_resource_id: PrsResourceId,
    pub dl_prs_resource_arp_location: DlPrsResourceArpLocation,
}

impl APerElement for DlprsResourceArp {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(1),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let _optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let dl_prs_resource_id = PrsResourceId::from_aper(decoder, UNCONSTRAINED)?;
        let dl_prs_resource_arp_location =
            DlPrsResourceArpLocation::from_aper(decoder, UNCONSTRAINED)?;

        Ok(Self {
            dl_prs_resource_id,
            dl_prs_resource_arp_location,
        })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(1);
        optionals.set(0, false);

        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&self.dl_prs_resource_id.to_aper(UNCONSTRAINED)?)?;
        enc.append(&self.dl_prs_resource_arp_location.to_aper(UNCONSTRAINED)?)?;

        Ok(enc)
    }
}

// DlPrsResourceArpLocation
#[derive(Clone)]
pub enum DlPrsResourceArpLocation {
    RelativeGeodeticLocation(RelativeGeodeticLocation),
    RelativeCartesianLocation(RelativeCartesianLocation),
    _Extended,
}

impl APerElement for DlPrsResourceArpLocation {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        match u8::from_aper(decoder, UNCONSTRAINED)? {
            0 => Ok(Self::RelativeGeodeticLocation(
                RelativeGeodeticLocation::from_aper(decoder, UNCONSTRAINED)?,
            )),
            1 => Ok(Self::RelativeCartesianLocation(
                RelativeCartesianLocation::from_aper(decoder, UNCONSTRAINED)?,
            )),
            2 => Err(DecodeError::NotImplemented),
            _ => Err(DecodeError::InvalidChoice),
        }
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        match self {
            Self::RelativeGeodeticLocation(x) => {
                enc.append(&(0 as u8).to_aper(UNCONSTRAINED)?)?;
                enc.append(&x.to_aper(UNCONSTRAINED)?)?;
            }
            Self::RelativeCartesianLocation(x) => {
                enc.append(&(1 as u8).to_aper(UNCONSTRAINED)?)?;
                enc.append(&x.to_aper(UNCONSTRAINED)?)?;
            }
            Self::_Extended => return Err(EncodeError::NotImplemented),
        }
        Ok(enc)
    }
}

// DlUpTnlAddressToUpdateListItem
#[derive(Clone)]
pub struct DlUpTnlAddressToUpdateListItem {
    pub old_ip_adress: TransportLayerAddress,
    pub new_ip_adress: TransportLayerAddress,
}

impl APerElement for DlUpTnlAddressToUpdateListItem {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(1),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let _extended = bool::from_aper(decoder, UNCONSTRAINED)?;
        let _optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let old_ip_adress = TransportLayerAddress::from_aper(decoder, UNCONSTRAINED)?;
        let new_ip_adress = TransportLayerAddress::from_aper(decoder, UNCONSTRAINED)?;

        Ok(Self {
            old_ip_adress,
            new_ip_adress,
        })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(1);
        optionals.set(0, false);

        enc.append(&false.to_aper(UNCONSTRAINED)?)?;
        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&self.old_ip_adress.to_aper(UNCONSTRAINED)?)?;
        enc.append(&self.new_ip_adress.to_aper(UNCONSTRAINED)?)?;

        Ok(enc)
    }
}

// DluptnlInformationToBeSetupList
#[derive(Clone)]
pub struct DluptnlInformationToBeSetupList(pub Vec<DluptnlInformationToBeSetupItem>);

impl APerElement for DluptnlInformationToBeSetupList {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(1),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        Ok(Self(Vec::<DluptnlInformationToBeSetupItem>::from_aper(
            decoder,
            Self::CONSTRAINTS,
        )?))
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&(self.0).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// DluptnlInformationToBeSetupItem
#[derive(Clone)]
pub struct DluptnlInformationToBeSetupItem {
    pub dluptnl_information: UpTransportLayerInformation,
}

impl APerElement for DluptnlInformationToBeSetupItem {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(1),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let _extended = bool::from_aper(decoder, UNCONSTRAINED)?;
        let _optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let dluptnl_information = UpTransportLayerInformation::from_aper(decoder, UNCONSTRAINED)?;

        Ok(Self {
            dluptnl_information,
        })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(1);
        optionals.set(0, false);

        enc.append(&false.to_aper(UNCONSTRAINED)?)?;
        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&self.dluptnl_information.to_aper(UNCONSTRAINED)?)?;

        Ok(enc)
    }
}

// DrbActivityItem
#[derive(Clone)]
pub struct DrbActivityItem {
    pub drbid: Drbid,
    pub drb_activity: Option<DrbActivity>,
}

impl APerElement for DrbActivityItem {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(2),
            max: Some(2),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let _extended = bool::from_aper(decoder, UNCONSTRAINED)?;
        let optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let drbid = Drbid::from_aper(decoder, UNCONSTRAINED)?;
        let drb_activity = if optionals.is_set(0) {
            Some(DrbActivity::from_aper(decoder, UNCONSTRAINED)?)
        } else {
            None
        };

        Ok(Self {
            drbid,
            drb_activity,
        })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(2);
        optionals.set(0, self.drb_activity.is_some());
        optionals.set(1, false);

        enc.append(&false.to_aper(UNCONSTRAINED)?)?;
        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&self.drbid.to_aper(UNCONSTRAINED)?)?;
        if let Some(x) = &self.drb_activity {
            enc.append(&x.to_aper(UNCONSTRAINED)?)?;
        }

        Ok(enc)
    }
}

// DrbActivity
#[derive(Clone, Copy, FromPrimitive)]
pub enum DrbActivity {
    Active,
    NotActive,
}

impl APerElement for DrbActivity {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let v = u8::from_aper(decoder, Self::CONSTRAINTS)?;
        FromPrimitive::from_u8(v).ok_or(DecodeError::MalformedInt)
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&(*self as u8).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// Drbid
#[derive(Clone)]
pub struct Drbid(pub u8);

impl APerElement for Drbid {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(32),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        Ok(Self(u8::from_aper(decoder, Self::CONSTRAINTS)?))
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&(self.0).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// DrBsFailedToBeModifiedItem
#[derive(Clone)]
pub struct DrBsFailedToBeModifiedItem {
    pub drbid: Drbid,
    pub cause: Option<Cause>,
}

impl APerElement for DrBsFailedToBeModifiedItem {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(2),
            max: Some(2),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let _extended = bool::from_aper(decoder, UNCONSTRAINED)?;
        let optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let drbid = Drbid::from_aper(decoder, UNCONSTRAINED)?;
        let cause = if optionals.is_set(0) {
            Some(Cause::from_aper(decoder, UNCONSTRAINED)?)
        } else {
            None
        };

        Ok(Self { drbid, cause })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(2);
        optionals.set(0, self.cause.is_some());
        optionals.set(1, false);

        enc.append(&false.to_aper(UNCONSTRAINED)?)?;
        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&self.drbid.to_aper(UNCONSTRAINED)?)?;
        if let Some(x) = &self.cause {
            enc.append(&x.to_aper(UNCONSTRAINED)?)?;
        }

        Ok(enc)
    }
}

// DrBsFailedToBeSetupItem
#[derive(Clone)]
pub struct DrBsFailedToBeSetupItem {
    pub drbid: Drbid,
    pub cause: Option<Cause>,
}

impl APerElement for DrBsFailedToBeSetupItem {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(2),
            max: Some(2),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let _extended = bool::from_aper(decoder, UNCONSTRAINED)?;
        let optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let drbid = Drbid::from_aper(decoder, UNCONSTRAINED)?;
        let cause = if optionals.is_set(0) {
            Some(Cause::from_aper(decoder, UNCONSTRAINED)?)
        } else {
            None
        };

        Ok(Self { drbid, cause })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(2);
        optionals.set(0, self.cause.is_some());
        optionals.set(1, false);

        enc.append(&false.to_aper(UNCONSTRAINED)?)?;
        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&self.drbid.to_aper(UNCONSTRAINED)?)?;
        if let Some(x) = &self.cause {
            enc.append(&x.to_aper(UNCONSTRAINED)?)?;
        }

        Ok(enc)
    }
}

// DrBsFailedToBeSetupModItem
#[derive(Clone)]
pub struct DrBsFailedToBeSetupModItem {
    pub drbid: Drbid,
    pub cause: Option<Cause>,
}

impl APerElement for DrBsFailedToBeSetupModItem {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(2),
            max: Some(2),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let _extended = bool::from_aper(decoder, UNCONSTRAINED)?;
        let optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let drbid = Drbid::from_aper(decoder, UNCONSTRAINED)?;
        let cause = if optionals.is_set(0) {
            Some(Cause::from_aper(decoder, UNCONSTRAINED)?)
        } else {
            None
        };

        Ok(Self { drbid, cause })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(2);
        optionals.set(0, self.cause.is_some());
        optionals.set(1, false);

        enc.append(&false.to_aper(UNCONSTRAINED)?)?;
        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&self.drbid.to_aper(UNCONSTRAINED)?)?;
        if let Some(x) = &self.cause {
            enc.append(&x.to_aper(UNCONSTRAINED)?)?;
        }

        Ok(enc)
    }
}

// DrbInformation
#[derive(Clone)]
pub struct DrbInformation {
    pub drb_qos: QosFlowLevelQosParameters,
    pub snssai: Snssai,
    pub notification_control: Option<NotificationControl>,
    pub flows_mapped_to_drb_list: FlowsMappedToDrbList,
}

impl APerElement for DrbInformation {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(2),
            max: Some(2),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let drb_qos = QosFlowLevelQosParameters::from_aper(decoder, UNCONSTRAINED)?;
        let snssai = Snssai::from_aper(decoder, UNCONSTRAINED)?;
        let notification_control = if optionals.is_set(0) {
            Some(NotificationControl::from_aper(decoder, UNCONSTRAINED)?)
        } else {
            None
        };
        let flows_mapped_to_drb_list = FlowsMappedToDrbList::from_aper(decoder, UNCONSTRAINED)?;

        Ok(Self {
            drb_qos,
            snssai,
            notification_control,
            flows_mapped_to_drb_list,
        })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(2);
        optionals.set(0, self.notification_control.is_some());
        optionals.set(1, false);

        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&self.drb_qos.to_aper(UNCONSTRAINED)?)?;
        enc.append(&self.snssai.to_aper(UNCONSTRAINED)?)?;
        if let Some(x) = &self.notification_control {
            enc.append(&x.to_aper(UNCONSTRAINED)?)?;
        }
        enc.append(&self.flows_mapped_to_drb_list.to_aper(UNCONSTRAINED)?)?;

        Ok(enc)
    }
}

// DrBsModifiedItem
#[derive(Clone)]
pub struct DrBsModifiedItem {
    pub drbid: Drbid,
    pub lcid: Option<Lcid>,
    pub dluptnl_information_to_be_setup_list: DluptnlInformationToBeSetupList,
}

impl APerElement for DrBsModifiedItem {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(2),
            max: Some(2),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let _extended = bool::from_aper(decoder, UNCONSTRAINED)?;
        let optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let drbid = Drbid::from_aper(decoder, UNCONSTRAINED)?;
        let lcid = if optionals.is_set(0) {
            Some(Lcid::from_aper(decoder, UNCONSTRAINED)?)
        } else {
            None
        };
        let dluptnl_information_to_be_setup_list =
            DluptnlInformationToBeSetupList::from_aper(decoder, UNCONSTRAINED)?;

        Ok(Self {
            drbid,
            lcid,
            dluptnl_information_to_be_setup_list,
        })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(2);
        optionals.set(0, self.lcid.is_some());
        optionals.set(1, false);

        enc.append(&false.to_aper(UNCONSTRAINED)?)?;
        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&self.drbid.to_aper(UNCONSTRAINED)?)?;
        if let Some(x) = &self.lcid {
            enc.append(&x.to_aper(UNCONSTRAINED)?)?;
        }
        enc.append(
            &self
                .dluptnl_information_to_be_setup_list
                .to_aper(UNCONSTRAINED)?,
        )?;

        Ok(enc)
    }
}

// DrBsModifiedConfItem
#[derive(Clone)]
pub struct DrBsModifiedConfItem {
    pub drbid: Drbid,
    pub uluptnl_information_to_be_setup_list: UluptnlInformationToBeSetupList,
}

impl APerElement for DrBsModifiedConfItem {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(1),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let _extended = bool::from_aper(decoder, UNCONSTRAINED)?;
        let _optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let drbid = Drbid::from_aper(decoder, UNCONSTRAINED)?;
        let uluptnl_information_to_be_setup_list =
            UluptnlInformationToBeSetupList::from_aper(decoder, UNCONSTRAINED)?;

        Ok(Self {
            drbid,
            uluptnl_information_to_be_setup_list,
        })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(1);
        optionals.set(0, false);

        enc.append(&false.to_aper(UNCONSTRAINED)?)?;
        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&self.drbid.to_aper(UNCONSTRAINED)?)?;
        enc.append(
            &self
                .uluptnl_information_to_be_setup_list
                .to_aper(UNCONSTRAINED)?,
        )?;

        Ok(enc)
    }
}

// DrbNotifyItem
#[derive(Clone)]
pub struct DrbNotifyItem {
    pub drbid: Drbid,
    pub notification_cause: NotificationCause,
}

impl APerElement for DrbNotifyItem {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(1),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let _extended = bool::from_aper(decoder, UNCONSTRAINED)?;
        let _optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let drbid = Drbid::from_aper(decoder, UNCONSTRAINED)?;
        let notification_cause = NotificationCause::from_aper(decoder, UNCONSTRAINED)?;

        Ok(Self {
            drbid,
            notification_cause,
        })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(1);
        optionals.set(0, false);

        enc.append(&false.to_aper(UNCONSTRAINED)?)?;
        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&self.drbid.to_aper(UNCONSTRAINED)?)?;
        enc.append(&self.notification_cause.to_aper(UNCONSTRAINED)?)?;

        Ok(enc)
    }
}

// DrBsRequiredToBeModifiedItem
#[derive(Clone)]
pub struct DrBsRequiredToBeModifiedItem {
    pub drbid: Drbid,
    pub dluptnl_information_to_be_setup_list: DluptnlInformationToBeSetupList,
}

impl APerElement for DrBsRequiredToBeModifiedItem {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(1),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let _extended = bool::from_aper(decoder, UNCONSTRAINED)?;
        let _optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let drbid = Drbid::from_aper(decoder, UNCONSTRAINED)?;
        let dluptnl_information_to_be_setup_list =
            DluptnlInformationToBeSetupList::from_aper(decoder, UNCONSTRAINED)?;

        Ok(Self {
            drbid,
            dluptnl_information_to_be_setup_list,
        })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(1);
        optionals.set(0, false);

        enc.append(&false.to_aper(UNCONSTRAINED)?)?;
        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&self.drbid.to_aper(UNCONSTRAINED)?)?;
        enc.append(
            &self
                .dluptnl_information_to_be_setup_list
                .to_aper(UNCONSTRAINED)?,
        )?;

        Ok(enc)
    }
}

// DrBsRequiredToBeReleasedItem
#[derive(Clone)]
pub struct DrBsRequiredToBeReleasedItem {
    pub drbid: Drbid,
}

impl APerElement for DrBsRequiredToBeReleasedItem {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(1),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let _extended = bool::from_aper(decoder, UNCONSTRAINED)?;
        let _optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let drbid = Drbid::from_aper(decoder, UNCONSTRAINED)?;

        Ok(Self { drbid })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(1);
        optionals.set(0, false);

        enc.append(&false.to_aper(UNCONSTRAINED)?)?;
        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&self.drbid.to_aper(UNCONSTRAINED)?)?;

        Ok(enc)
    }
}

// DrBsSetupItem
#[derive(Clone)]
pub struct DrBsSetupItem {
    pub drbid: Drbid,
    pub lcid: Option<Lcid>,
    pub dluptnl_information_to_be_setup_list: DluptnlInformationToBeSetupList,
}

impl APerElement for DrBsSetupItem {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(2),
            max: Some(2),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let _extended = bool::from_aper(decoder, UNCONSTRAINED)?;
        let optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let drbid = Drbid::from_aper(decoder, UNCONSTRAINED)?;
        let lcid = if optionals.is_set(0) {
            Some(Lcid::from_aper(decoder, UNCONSTRAINED)?)
        } else {
            None
        };
        let dluptnl_information_to_be_setup_list =
            DluptnlInformationToBeSetupList::from_aper(decoder, UNCONSTRAINED)?;

        Ok(Self {
            drbid,
            lcid,
            dluptnl_information_to_be_setup_list,
        })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(2);
        optionals.set(0, self.lcid.is_some());
        optionals.set(1, false);

        enc.append(&false.to_aper(UNCONSTRAINED)?)?;
        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&self.drbid.to_aper(UNCONSTRAINED)?)?;
        if let Some(x) = &self.lcid {
            enc.append(&x.to_aper(UNCONSTRAINED)?)?;
        }
        enc.append(
            &self
                .dluptnl_information_to_be_setup_list
                .to_aper(UNCONSTRAINED)?,
        )?;

        Ok(enc)
    }
}

// DrBsSetupModItem
#[derive(Clone)]
pub struct DrBsSetupModItem {
    pub drbid: Drbid,
    pub lcid: Option<Lcid>,
    pub dluptnl_information_to_be_setup_list: DluptnlInformationToBeSetupList,
}

impl APerElement for DrBsSetupModItem {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(2),
            max: Some(2),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let _extended = bool::from_aper(decoder, UNCONSTRAINED)?;
        let optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let drbid = Drbid::from_aper(decoder, UNCONSTRAINED)?;
        let lcid = if optionals.is_set(0) {
            Some(Lcid::from_aper(decoder, UNCONSTRAINED)?)
        } else {
            None
        };
        let dluptnl_information_to_be_setup_list =
            DluptnlInformationToBeSetupList::from_aper(decoder, UNCONSTRAINED)?;

        Ok(Self {
            drbid,
            lcid,
            dluptnl_information_to_be_setup_list,
        })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(2);
        optionals.set(0, self.lcid.is_some());
        optionals.set(1, false);

        enc.append(&false.to_aper(UNCONSTRAINED)?)?;
        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&self.drbid.to_aper(UNCONSTRAINED)?)?;
        if let Some(x) = &self.lcid {
            enc.append(&x.to_aper(UNCONSTRAINED)?)?;
        }
        enc.append(
            &self
                .dluptnl_information_to_be_setup_list
                .to_aper(UNCONSTRAINED)?,
        )?;

        Ok(enc)
    }
}

// DrBsToBeModifiedItem
#[derive(Clone)]
pub struct DrBsToBeModifiedItem {
    pub drbid: Drbid,
    pub qos_information: Option<QosInformation>,
    pub uluptnl_information_to_be_setup_list: UluptnlInformationToBeSetupList,
    pub ul_configuration: Option<UlConfiguration>,
}

impl APerElement for DrBsToBeModifiedItem {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(3),
            max: Some(3),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let _extended = bool::from_aper(decoder, UNCONSTRAINED)?;
        let optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let drbid = Drbid::from_aper(decoder, UNCONSTRAINED)?;
        let qos_information = if optionals.is_set(0) {
            Some(QosInformation::from_aper(decoder, UNCONSTRAINED)?)
        } else {
            None
        };
        let uluptnl_information_to_be_setup_list =
            UluptnlInformationToBeSetupList::from_aper(decoder, UNCONSTRAINED)?;
        let ul_configuration = if optionals.is_set(0) {
            Some(UlConfiguration::from_aper(decoder, UNCONSTRAINED)?)
        } else {
            None
        };

        Ok(Self {
            drbid,
            qos_information,
            uluptnl_information_to_be_setup_list,
            ul_configuration,
        })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(3);
        optionals.set(0, self.qos_information.is_some());
        optionals.set(1, self.ul_configuration.is_some());
        optionals.set(2, false);

        enc.append(&false.to_aper(UNCONSTRAINED)?)?;
        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&self.drbid.to_aper(UNCONSTRAINED)?)?;
        if let Some(x) = &self.qos_information {
            enc.append(&x.to_aper(UNCONSTRAINED)?)?;
        }
        enc.append(
            &self
                .uluptnl_information_to_be_setup_list
                .to_aper(UNCONSTRAINED)?,
        )?;
        if let Some(x) = &self.ul_configuration {
            enc.append(&x.to_aper(UNCONSTRAINED)?)?;
        }

        Ok(enc)
    }
}

// DrBsToBeReleasedItem
#[derive(Clone)]
pub struct DrBsToBeReleasedItem {
    pub drbid: Drbid,
}

impl APerElement for DrBsToBeReleasedItem {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(1),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let _extended = bool::from_aper(decoder, UNCONSTRAINED)?;
        let _optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let drbid = Drbid::from_aper(decoder, UNCONSTRAINED)?;

        Ok(Self { drbid })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(1);
        optionals.set(0, false);

        enc.append(&false.to_aper(UNCONSTRAINED)?)?;
        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&self.drbid.to_aper(UNCONSTRAINED)?)?;

        Ok(enc)
    }
}

// DrBsToBeSetupItem
#[derive(Clone)]
pub struct DrBsToBeSetupItem {
    pub drbid: Drbid,
    pub qos_information: QosInformation,
    pub uluptnl_information_to_be_setup_list: UluptnlInformationToBeSetupList,
    pub rlc_mode: RlcMode,
    pub ul_configuration: Option<UlConfiguration>,
    pub duplication_activation: Option<DuplicationActivation>,
}

impl APerElement for DrBsToBeSetupItem {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(3),
            max: Some(3),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let _extended = bool::from_aper(decoder, UNCONSTRAINED)?;
        let optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let drbid = Drbid::from_aper(decoder, UNCONSTRAINED)?;
        let qos_information = QosInformation::from_aper(decoder, UNCONSTRAINED)?;
        let uluptnl_information_to_be_setup_list =
            UluptnlInformationToBeSetupList::from_aper(decoder, UNCONSTRAINED)?;
        let rlc_mode = RlcMode::from_aper(decoder, UNCONSTRAINED)?;
        let ul_configuration = if optionals.is_set(0) {
            Some(UlConfiguration::from_aper(decoder, UNCONSTRAINED)?)
        } else {
            None
        };
        let duplication_activation = if optionals.is_set(0) {
            Some(DuplicationActivation::from_aper(decoder, UNCONSTRAINED)?)
        } else {
            None
        };

        Ok(Self {
            drbid,
            qos_information,
            uluptnl_information_to_be_setup_list,
            rlc_mode,
            ul_configuration,
            duplication_activation,
        })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(3);
        optionals.set(0, self.ul_configuration.is_some());
        optionals.set(1, self.duplication_activation.is_some());
        optionals.set(2, false);

        enc.append(&false.to_aper(UNCONSTRAINED)?)?;
        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&self.drbid.to_aper(UNCONSTRAINED)?)?;
        enc.append(&self.qos_information.to_aper(UNCONSTRAINED)?)?;
        enc.append(
            &self
                .uluptnl_information_to_be_setup_list
                .to_aper(UNCONSTRAINED)?,
        )?;
        enc.append(&self.rlc_mode.to_aper(UNCONSTRAINED)?)?;
        if let Some(x) = &self.ul_configuration {
            enc.append(&x.to_aper(UNCONSTRAINED)?)?;
        }
        if let Some(x) = &self.duplication_activation {
            enc.append(&x.to_aper(UNCONSTRAINED)?)?;
        }

        Ok(enc)
    }
}

// DrBsToBeSetupModItem
#[derive(Clone)]
pub struct DrBsToBeSetupModItem {
    pub drbid: Drbid,
    pub qos_information: QosInformation,
    pub uluptnl_information_to_be_setup_list: UluptnlInformationToBeSetupList,
    pub rlc_mode: RlcMode,
    pub ul_configuration: Option<UlConfiguration>,
    pub duplication_activation: Option<DuplicationActivation>,
}

impl APerElement for DrBsToBeSetupModItem {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(3),
            max: Some(3),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let _extended = bool::from_aper(decoder, UNCONSTRAINED)?;
        let optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let drbid = Drbid::from_aper(decoder, UNCONSTRAINED)?;
        let qos_information = QosInformation::from_aper(decoder, UNCONSTRAINED)?;
        let uluptnl_information_to_be_setup_list =
            UluptnlInformationToBeSetupList::from_aper(decoder, UNCONSTRAINED)?;
        let rlc_mode = RlcMode::from_aper(decoder, UNCONSTRAINED)?;
        let ul_configuration = if optionals.is_set(0) {
            Some(UlConfiguration::from_aper(decoder, UNCONSTRAINED)?)
        } else {
            None
        };
        let duplication_activation = if optionals.is_set(0) {
            Some(DuplicationActivation::from_aper(decoder, UNCONSTRAINED)?)
        } else {
            None
        };

        Ok(Self {
            drbid,
            qos_information,
            uluptnl_information_to_be_setup_list,
            rlc_mode,
            ul_configuration,
            duplication_activation,
        })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(3);
        optionals.set(0, self.ul_configuration.is_some());
        optionals.set(1, self.duplication_activation.is_some());
        optionals.set(2, false);

        enc.append(&false.to_aper(UNCONSTRAINED)?)?;
        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&self.drbid.to_aper(UNCONSTRAINED)?)?;
        enc.append(&self.qos_information.to_aper(UNCONSTRAINED)?)?;
        enc.append(
            &self
                .uluptnl_information_to_be_setup_list
                .to_aper(UNCONSTRAINED)?,
        )?;
        enc.append(&self.rlc_mode.to_aper(UNCONSTRAINED)?)?;
        if let Some(x) = &self.ul_configuration {
            enc.append(&x.to_aper(UNCONSTRAINED)?)?;
        }
        if let Some(x) = &self.duplication_activation {
            enc.append(&x.to_aper(UNCONSTRAINED)?)?;
        }

        Ok(enc)
    }
}

// DrxCycle
#[derive(Clone)]
pub struct DrxCycle {
    pub long_drx_cycle_length: LongDrxCycleLength,
    pub short_drx_cycle_length: Option<ShortDrxCycleLength>,
    pub short_drx_cycle_timer: Option<ShortDrxCycleTimer>,
}

impl APerElement for DrxCycle {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(3),
            max: Some(3),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let _extended = bool::from_aper(decoder, UNCONSTRAINED)?;
        let optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let long_drx_cycle_length = LongDrxCycleLength::from_aper(decoder, UNCONSTRAINED)?;
        let short_drx_cycle_length = if optionals.is_set(0) {
            Some(ShortDrxCycleLength::from_aper(decoder, UNCONSTRAINED)?)
        } else {
            None
        };
        let short_drx_cycle_timer = if optionals.is_set(0) {
            Some(ShortDrxCycleTimer::from_aper(decoder, UNCONSTRAINED)?)
        } else {
            None
        };

        Ok(Self {
            long_drx_cycle_length,
            short_drx_cycle_length,
            short_drx_cycle_timer,
        })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(3);
        optionals.set(0, self.short_drx_cycle_length.is_some());
        optionals.set(1, self.short_drx_cycle_timer.is_some());
        optionals.set(2, false);

        enc.append(&false.to_aper(UNCONSTRAINED)?)?;
        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&self.long_drx_cycle_length.to_aper(UNCONSTRAINED)?)?;
        if let Some(x) = &self.short_drx_cycle_length {
            enc.append(&x.to_aper(UNCONSTRAINED)?)?;
        }
        if let Some(x) = &self.short_drx_cycle_timer {
            enc.append(&x.to_aper(UNCONSTRAINED)?)?;
        }

        Ok(enc)
    }
}

// DrxConfig
#[derive(Clone)]
pub struct DrxConfig(pub Vec<u8>);

impl APerElement for DrxConfig {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        Ok(Self(Vec::<u8>::from_aper(decoder, Self::CONSTRAINTS)?))
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&(self.0).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// DrxConfigurationIndicator
#[derive(Clone, Copy, FromPrimitive)]
pub enum DrxConfigurationIndicator {
    Release,
    _Extended,
}

impl APerElement for DrxConfigurationIndicator {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        if bool::from_aper(decoder, Self::CONSTRAINTS)? {
            return Ok(DrxConfigurationIndicator::_Extended);
        }
        let v = u8::from_aper(decoder, Self::CONSTRAINTS)?;
        FromPrimitive::from_u8(v).ok_or(DecodeError::MalformedInt)
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&false.to_aper(UNCONSTRAINED)?)?;
        enc.append(&(*self as u8).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// DrxLongCycleStartOffset
#[derive(Clone)]
pub struct DrxLongCycleStartOffset(pub u16);

impl APerElement for DrxLongCycleStartOffset {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(0),
            max: Some(0),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        Ok(Self(u16::from_aper(decoder, Self::CONSTRAINTS)?))
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&(self.0).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// DsInformationList
#[derive(Clone)]
pub struct DsInformationList(pub Vec<Dscp>);

impl APerElement for DsInformationList {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(0),
            max: Some(0),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        Ok(Self(Vec::<Dscp>::from_aper(decoder, Self::CONSTRAINTS)?))
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&(self.0).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// Dscp
#[derive(Clone)]
pub struct Dscp(pub BitString);

impl APerElement for Dscp {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(6),
            max: Some(6),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        Ok(Self(BitString::from_aper(decoder, Self::CONSTRAINTS)?))
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&(self.0).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// DUtoCurrcContainer
#[derive(Clone)]
pub struct DUtoCurrcContainer(pub Vec<u8>);

impl APerElement for DUtoCurrcContainer {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        Ok(Self(Vec::<u8>::from_aper(decoder, Self::CONSTRAINTS)?))
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&(self.0).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// DucuRadioInformationType
#[derive(Clone)]
pub enum DucuRadioInformationType {
    Rim(DucurimInformation),
    _Extended,
}

impl APerElement for DucuRadioInformationType {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        match u8::from_aper(decoder, UNCONSTRAINED)? {
            0 => Ok(Self::Rim(DucurimInformation::from_aper(
                decoder,
                UNCONSTRAINED,
            )?)),
            1 => Err(DecodeError::NotImplemented),
            _ => Err(DecodeError::InvalidChoice),
        }
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        match self {
            Self::Rim(x) => {
                enc.append(&(0 as u8).to_aper(UNCONSTRAINED)?)?;
                enc.append(&x.to_aper(UNCONSTRAINED)?)?;
            }
            Self::_Extended => return Err(EncodeError::NotImplemented),
        }
        Ok(enc)
    }
}

// DucurimInformation
#[derive(Clone)]
pub struct DucurimInformation {
    pub victim_gnb_set_id: GnbSetId,
    pub rimrs_detection_status: RimrsDetectionStatus,
    pub aggressor_cell_list: AggressorCellList,
}

impl APerElement for DucurimInformation {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(1),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let _optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let victim_gnb_set_id = GnbSetId::from_aper(decoder, UNCONSTRAINED)?;
        let rimrs_detection_status = RimrsDetectionStatus::from_aper(decoder, UNCONSTRAINED)?;
        let aggressor_cell_list = AggressorCellList::from_aper(decoder, UNCONSTRAINED)?;

        Ok(Self {
            victim_gnb_set_id,
            rimrs_detection_status,
            aggressor_cell_list,
        })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(1);
        optionals.set(0, false);

        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&self.victim_gnb_set_id.to_aper(UNCONSTRAINED)?)?;
        enc.append(&self.rimrs_detection_status.to_aper(UNCONSTRAINED)?)?;
        enc.append(&self.aggressor_cell_list.to_aper(UNCONSTRAINED)?)?;

        Ok(enc)
    }
}

// DufSlotConfigItem
#[derive(Clone)]
pub enum DufSlotConfigItem {
    ExplicitFormat(ExplicitFormat),
    ImplicitFormat(ImplicitFormat),
    _Extended,
}

impl APerElement for DufSlotConfigItem {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        match u8::from_aper(decoder, UNCONSTRAINED)? {
            0 => Ok(Self::ExplicitFormat(ExplicitFormat::from_aper(
                decoder,
                UNCONSTRAINED,
            )?)),
            1 => Ok(Self::ImplicitFormat(ImplicitFormat::from_aper(
                decoder,
                UNCONSTRAINED,
            )?)),
            2 => Err(DecodeError::NotImplemented),
            _ => Err(DecodeError::InvalidChoice),
        }
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        match self {
            Self::ExplicitFormat(x) => {
                enc.append(&(0 as u8).to_aper(UNCONSTRAINED)?)?;
                enc.append(&x.to_aper(UNCONSTRAINED)?)?;
            }
            Self::ImplicitFormat(x) => {
                enc.append(&(1 as u8).to_aper(UNCONSTRAINED)?)?;
                enc.append(&x.to_aper(UNCONSTRAINED)?)?;
            }
            Self::_Extended => return Err(EncodeError::NotImplemented),
        }
        Ok(enc)
    }
}

// DufSlotConfigList
#[derive(Clone)]
pub struct DufSlotConfigList(pub Vec<DufSlotConfigItem>);

impl APerElement for DufSlotConfigList {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(1),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        Ok(Self(Vec::<DufSlotConfigItem>::from_aper(
            decoder,
            Self::CONSTRAINTS,
        )?))
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&(self.0).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// DufSlotformatIndex
#[derive(Clone)]
pub struct DufSlotformatIndex(pub u8);

impl APerElement for DufSlotformatIndex {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(0),
            max: Some(0),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        Ok(Self(u8::from_aper(decoder, Self::CONSTRAINTS)?))
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&(self.0).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// DufTransmissionPeriodicity
#[derive(Clone, Copy, FromPrimitive)]
pub enum DufTransmissionPeriodicity {
    Ms0p5,
    Ms0p625,
    Ms1,
    Ms1p25,
    Ms2,
    Ms2p5,
    Ms5,
    Ms10,
    _Extended,
}

impl APerElement for DufTransmissionPeriodicity {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        if bool::from_aper(decoder, Self::CONSTRAINTS)? {
            return Ok(DufTransmissionPeriodicity::_Extended);
        }
        let v = u8::from_aper(decoder, Self::CONSTRAINTS)?;
        FromPrimitive::from_u8(v).ok_or(DecodeError::MalformedInt)
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&false.to_aper(UNCONSTRAINED)?)?;
        enc.append(&(*self as u8).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// DuRxMtRx
#[derive(Clone, Copy, FromPrimitive)]
pub enum DuRxMtRx {
    Supported,
    NotSupported,
}

impl APerElement for DuRxMtRx {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let v = u8::from_aper(decoder, Self::CONSTRAINTS)?;
        FromPrimitive::from_u8(v).ok_or(DecodeError::MalformedInt)
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&(*self as u8).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// DuTxMtTx
#[derive(Clone, Copy, FromPrimitive)]
pub enum DuTxMtTx {
    Supported,
    NotSupported,
}

impl APerElement for DuTxMtTx {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let v = u8::from_aper(decoder, Self::CONSTRAINTS)?;
        FromPrimitive::from_u8(v).ok_or(DecodeError::MalformedInt)
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&(*self as u8).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// DuRxMtTx
#[derive(Clone, Copy, FromPrimitive)]
pub enum DuRxMtTx {
    Supported,
    NotSupported,
}

impl APerElement for DuRxMtTx {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let v = u8::from_aper(decoder, Self::CONSTRAINTS)?;
        FromPrimitive::from_u8(v).ok_or(DecodeError::MalformedInt)
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&(*self as u8).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// DuTxMtRx
#[derive(Clone, Copy, FromPrimitive)]
pub enum DuTxMtRx {
    Supported,
    NotSupported,
}

impl APerElement for DuTxMtRx {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let v = u8::from_aper(decoder, Self::CONSTRAINTS)?;
        FromPrimitive::from_u8(v).ok_or(DecodeError::MalformedInt)
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&(*self as u8).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// DUtoCurrcInformation
#[derive(Clone)]
pub struct DUtoCurrcInformation {
    pub cell_group_config: CellGroupConfig,
    pub meas_gap_config: Option<MeasGapConfig>,
    pub requested_p_max_fr1: Option<Vec<u8>>,
}

impl APerElement for DUtoCurrcInformation {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(3),
            max: Some(3),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let _extended = bool::from_aper(decoder, UNCONSTRAINED)?;
        let optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let cell_group_config = CellGroupConfig::from_aper(decoder, UNCONSTRAINED)?;
        let meas_gap_config = if optionals.is_set(0) {
            Some(MeasGapConfig::from_aper(decoder, UNCONSTRAINED)?)
        } else {
            None
        };
        let requested_p_max_fr1 = if optionals.is_set(0) {
            Some(Vec::<u8>::from_aper(decoder, UNCONSTRAINED)?)
        } else {
            None
        };

        Ok(Self {
            cell_group_config,
            meas_gap_config,
            requested_p_max_fr1,
        })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(3);
        optionals.set(0, self.meas_gap_config.is_some());
        optionals.set(1, self.requested_p_max_fr1.is_some());
        optionals.set(2, false);

        enc.append(&false.to_aper(UNCONSTRAINED)?)?;
        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&self.cell_group_config.to_aper(UNCONSTRAINED)?)?;
        if let Some(x) = &self.meas_gap_config {
            enc.append(&x.to_aper(UNCONSTRAINED)?)?;
        }
        if let Some(x) = &self.requested_p_max_fr1 {
            enc.append(&x.to_aper(UNCONSTRAINED)?)?;
        }

        Ok(enc)
    }
}

// DuplicationActivation
#[derive(Clone, Copy, FromPrimitive)]
pub enum DuplicationActivation {
    Active,
    Inactive,
    _Extended,
}

impl APerElement for DuplicationActivation {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        if bool::from_aper(decoder, Self::CONSTRAINTS)? {
            return Ok(DuplicationActivation::_Extended);
        }
        let v = u8::from_aper(decoder, Self::CONSTRAINTS)?;
        FromPrimitive::from_u8(v).ok_or(DecodeError::MalformedInt)
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&false.to_aper(UNCONSTRAINED)?)?;
        enc.append(&(*self as u8).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// DuplicationIndication
#[derive(Clone, Copy, FromPrimitive)]
pub enum DuplicationIndication {
    True,
    _Extended,
}

impl APerElement for DuplicationIndication {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        if bool::from_aper(decoder, Self::CONSTRAINTS)? {
            return Ok(DuplicationIndication::_Extended);
        }
        let v = u8::from_aper(decoder, Self::CONSTRAINTS)?;
        FromPrimitive::from_u8(v).ok_or(DecodeError::MalformedInt)
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&false.to_aper(UNCONSTRAINED)?)?;
        enc.append(&(*self as u8).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// DuplicationState
#[derive(Clone, Copy, FromPrimitive)]
pub enum DuplicationState {
    Active,
    Inactive,
    _Extended,
}

impl APerElement for DuplicationState {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        if bool::from_aper(decoder, Self::CONSTRAINTS)? {
            return Ok(DuplicationState::_Extended);
        }
        let v = u8::from_aper(decoder, Self::CONSTRAINTS)?;
        FromPrimitive::from_u8(v).ok_or(DecodeError::MalformedInt)
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&false.to_aper(UNCONSTRAINED)?)?;
        enc.append(&(*self as u8).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// Dynamic5qiDescriptor
#[derive(Clone)]
pub struct Dynamic5qiDescriptor {
    pub qos_priority_level: u8,
    pub packet_delay_budget: PacketDelayBudget,
    pub packet_error_rate: PacketErrorRate,
    pub five_qi: Option<u8>,
    pub delay_critical: Option<DelayCritical>,
    pub averaging_window: Option<AveragingWindow>,
    pub max_data_burst_volume: Option<MaxDataBurstVolume>,
}

impl APerElement for Dynamic5qiDescriptor {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(5),
            max: Some(5),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let qos_priority_level = u8::from_aper(decoder, UNCONSTRAINED)?;
        let packet_delay_budget = PacketDelayBudget::from_aper(decoder, UNCONSTRAINED)?;
        let packet_error_rate = PacketErrorRate::from_aper(decoder, UNCONSTRAINED)?;
        let five_qi = if optionals.is_set(0) {
            Some(u8::from_aper(decoder, UNCONSTRAINED)?)
        } else {
            None
        };
        let delay_critical = if optionals.is_set(0) {
            Some(DelayCritical::from_aper(decoder, UNCONSTRAINED)?)
        } else {
            None
        };
        let averaging_window = if optionals.is_set(0) {
            Some(AveragingWindow::from_aper(decoder, UNCONSTRAINED)?)
        } else {
            None
        };
        let max_data_burst_volume = if optionals.is_set(0) {
            Some(MaxDataBurstVolume::from_aper(decoder, UNCONSTRAINED)?)
        } else {
            None
        };

        Ok(Self {
            qos_priority_level,
            packet_delay_budget,
            packet_error_rate,
            five_qi,
            delay_critical,
            averaging_window,
            max_data_burst_volume,
        })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(5);
        optionals.set(0, self.five_qi.is_some());
        optionals.set(1, self.delay_critical.is_some());
        optionals.set(2, self.averaging_window.is_some());
        optionals.set(3, self.max_data_burst_volume.is_some());
        optionals.set(4, false);

        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&self.qos_priority_level.to_aper(UNCONSTRAINED)?)?;
        enc.append(&self.packet_delay_budget.to_aper(UNCONSTRAINED)?)?;
        enc.append(&self.packet_error_rate.to_aper(UNCONSTRAINED)?)?;
        if let Some(x) = &self.five_qi {
            enc.append(&x.to_aper(UNCONSTRAINED)?)?;
        }
        if let Some(x) = &self.delay_critical {
            enc.append(&x.to_aper(UNCONSTRAINED)?)?;
        }
        if let Some(x) = &self.averaging_window {
            enc.append(&x.to_aper(UNCONSTRAINED)?)?;
        }
        if let Some(x) = &self.max_data_burst_volume {
            enc.append(&x.to_aper(UNCONSTRAINED)?)?;
        }

        Ok(enc)
    }
}

// DynamicPqiDescriptor
#[derive(Clone)]
pub struct DynamicPqiDescriptor {
    pub resource_type: Option<ResourceType1>,
    pub qos_priority_level: u8,
    pub packet_delay_budget: PacketDelayBudget,
    pub packet_error_rate: PacketErrorRate,
    pub averaging_window: Option<AveragingWindow>,
    pub max_data_burst_volume: Option<MaxDataBurstVolume>,
}

impl APerElement for DynamicPqiDescriptor {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(4),
            max: Some(4),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let resource_type = if optionals.is_set(0) {
            Some(ResourceType1::from_aper(decoder, UNCONSTRAINED)?)
        } else {
            None
        };
        let qos_priority_level = u8::from_aper(decoder, UNCONSTRAINED)?;
        let packet_delay_budget = PacketDelayBudget::from_aper(decoder, UNCONSTRAINED)?;
        let packet_error_rate = PacketErrorRate::from_aper(decoder, UNCONSTRAINED)?;
        let averaging_window = if optionals.is_set(0) {
            Some(AveragingWindow::from_aper(decoder, UNCONSTRAINED)?)
        } else {
            None
        };
        let max_data_burst_volume = if optionals.is_set(0) {
            Some(MaxDataBurstVolume::from_aper(decoder, UNCONSTRAINED)?)
        } else {
            None
        };

        Ok(Self {
            resource_type,
            qos_priority_level,
            packet_delay_budget,
            packet_error_rate,
            averaging_window,
            max_data_burst_volume,
        })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(4);
        optionals.set(0, self.resource_type.is_some());
        optionals.set(1, self.averaging_window.is_some());
        optionals.set(2, self.max_data_burst_volume.is_some());
        optionals.set(3, false);

        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        if let Some(x) = &self.resource_type {
            enc.append(&x.to_aper(UNCONSTRAINED)?)?;
        }
        enc.append(&self.qos_priority_level.to_aper(UNCONSTRAINED)?)?;
        enc.append(&self.packet_delay_budget.to_aper(UNCONSTRAINED)?)?;
        enc.append(&self.packet_error_rate.to_aper(UNCONSTRAINED)?)?;
        if let Some(x) = &self.averaging_window {
            enc.append(&x.to_aper(UNCONSTRAINED)?)?;
        }
        if let Some(x) = &self.max_data_burst_volume {
            enc.append(&x.to_aper(UNCONSTRAINED)?)?;
        }

        Ok(enc)
    }
}

// ECidMeasurementQuantities
#[derive(Clone)]
pub struct ECidMeasurementQuantities(pub Vec<ECidMeasurementQuantitiesItem>);

impl APerElement for ECidMeasurementQuantities {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(1),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        Ok(Self(Vec::<ECidMeasurementQuantitiesItem>::from_aper(
            decoder,
            Self::CONSTRAINTS,
        )?))
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&(self.0).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// ECidMeasurementQuantitiesItem
#[derive(Clone)]
pub struct ECidMeasurementQuantitiesItem {
    pub e_ci_dmeasurement_quantities_value: ECidMeasurementQuantitiesValue,
}

impl APerElement for ECidMeasurementQuantitiesItem {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(1),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let _optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let e_ci_dmeasurement_quantities_value =
            ECidMeasurementQuantitiesValue::from_aper(decoder, UNCONSTRAINED)?;

        Ok(Self {
            e_ci_dmeasurement_quantities_value,
        })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(1);
        optionals.set(0, false);

        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(
            &self
                .e_ci_dmeasurement_quantities_value
                .to_aper(UNCONSTRAINED)?,
        )?;

        Ok(enc)
    }
}

// ECidMeasurementQuantitiesValue
#[derive(Clone, Copy, FromPrimitive)]
pub enum ECidMeasurementQuantitiesValue {
    Default,
    AngleOfArrivalNr,
    _Extended,
}

impl APerElement for ECidMeasurementQuantitiesValue {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        if bool::from_aper(decoder, Self::CONSTRAINTS)? {
            return Ok(ECidMeasurementQuantitiesValue::_Extended);
        }
        let v = u8::from_aper(decoder, Self::CONSTRAINTS)?;
        FromPrimitive::from_u8(v).ok_or(DecodeError::MalformedInt)
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&false.to_aper(UNCONSTRAINED)?)?;
        enc.append(&(*self as u8).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// ECidMeasurementResult
#[derive(Clone)]
pub struct ECidMeasurementResult {
    pub geographical_coordinates: Option<GeographicalCoordinates>,
    pub measured_results_list: Option<ECidMeasuredResultsList>,
}

impl APerElement for ECidMeasurementResult {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(3),
            max: Some(3),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let geographical_coordinates = if optionals.is_set(0) {
            Some(GeographicalCoordinates::from_aper(decoder, UNCONSTRAINED)?)
        } else {
            None
        };
        let measured_results_list = if optionals.is_set(0) {
            Some(ECidMeasuredResultsList::from_aper(decoder, UNCONSTRAINED)?)
        } else {
            None
        };

        Ok(Self {
            geographical_coordinates,
            measured_results_list,
        })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(3);
        optionals.set(0, self.geographical_coordinates.is_some());
        optionals.set(1, self.measured_results_list.is_some());
        optionals.set(2, false);

        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        if let Some(x) = &self.geographical_coordinates {
            enc.append(&x.to_aper(UNCONSTRAINED)?)?;
        }
        if let Some(x) = &self.measured_results_list {
            enc.append(&x.to_aper(UNCONSTRAINED)?)?;
        }

        Ok(enc)
    }
}

// ECidMeasuredResultsList
#[derive(Clone)]
pub struct ECidMeasuredResultsList(pub Vec<ECidMeasuredResultsItem>);

impl APerElement for ECidMeasuredResultsList {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(1),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        Ok(Self(Vec::<ECidMeasuredResultsItem>::from_aper(
            decoder,
            Self::CONSTRAINTS,
        )?))
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&(self.0).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// ECidMeasuredResultsItem
#[derive(Clone)]
pub struct ECidMeasuredResultsItem {
    pub e_cid_measured_results_value: ECidMeasuredResultsValue,
}

impl APerElement for ECidMeasuredResultsItem {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(1),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let _optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let e_cid_measured_results_value =
            ECidMeasuredResultsValue::from_aper(decoder, UNCONSTRAINED)?;

        Ok(Self {
            e_cid_measured_results_value,
        })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(1);
        optionals.set(0, false);

        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&self.e_cid_measured_results_value.to_aper(UNCONSTRAINED)?)?;

        Ok(enc)
    }
}

// ECidMeasuredResultsValue
#[derive(Clone)]
pub enum ECidMeasuredResultsValue {
    ValueAngleofArrivalNr(UlAoA),
    _Extended,
}

impl APerElement for ECidMeasuredResultsValue {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        match u8::from_aper(decoder, UNCONSTRAINED)? {
            0 => Ok(Self::ValueAngleofArrivalNr(UlAoA::from_aper(
                decoder,
                UNCONSTRAINED,
            )?)),
            1 => Err(DecodeError::NotImplemented),
            _ => Err(DecodeError::InvalidChoice),
        }
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        match self {
            Self::ValueAngleofArrivalNr(x) => {
                enc.append(&(0 as u8).to_aper(UNCONSTRAINED)?)?;
                enc.append(&x.to_aper(UNCONSTRAINED)?)?;
            }
            Self::_Extended => return Err(EncodeError::NotImplemented),
        }
        Ok(enc)
    }
}

// ECidReportCharacteristics
#[derive(Clone, Copy, FromPrimitive)]
pub enum ECidReportCharacteristics {
    OnDemand,
    Periodic,
    _Extended,
}

impl APerElement for ECidReportCharacteristics {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        if bool::from_aper(decoder, Self::CONSTRAINTS)? {
            return Ok(ECidReportCharacteristics::_Extended);
        }
        let v = u8::from_aper(decoder, Self::CONSTRAINTS)?;
        FromPrimitive::from_u8(v).ok_or(DecodeError::MalformedInt)
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&false.to_aper(UNCONSTRAINED)?)?;
        enc.append(&(*self as u8).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// EgressBhrlcchList
#[derive(Clone)]
pub struct EgressBhrlcchList(pub Vec<EgressBhrlcchItem>);

impl APerElement for EgressBhrlcchList {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(1),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        Ok(Self(Vec::<EgressBhrlcchItem>::from_aper(
            decoder,
            Self::CONSTRAINTS,
        )?))
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&(self.0).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// EgressBhrlcchItem
#[derive(Clone)]
pub struct EgressBhrlcchItem {
    pub next_hop_bap_address: BapAddress,
    pub bhrlc_channel_id: BhrlcChannelId,
}

impl APerElement for EgressBhrlcchItem {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(1),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let _optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let next_hop_bap_address = BapAddress::from_aper(decoder, UNCONSTRAINED)?;
        let bhrlc_channel_id = BhrlcChannelId::from_aper(decoder, UNCONSTRAINED)?;

        Ok(Self {
            next_hop_bap_address,
            bhrlc_channel_id,
        })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(1);
        optionals.set(0, false);

        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&self.next_hop_bap_address.to_aper(UNCONSTRAINED)?)?;
        enc.append(&self.bhrlc_channel_id.to_aper(UNCONSTRAINED)?)?;

        Ok(enc)
    }
}

// EndpointIpAddressAndPort
#[derive(Clone)]
pub struct EndpointIpAddressAndPort {
    pub endpoint_ip_address: TransportLayerAddress,
}

impl APerElement for EndpointIpAddressAndPort {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(1),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let _optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let endpoint_ip_address = TransportLayerAddress::from_aper(decoder, UNCONSTRAINED)?;

        Ok(Self {
            endpoint_ip_address,
        })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(1);
        optionals.set(0, false);

        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&self.endpoint_ip_address.to_aper(UNCONSTRAINED)?)?;

        Ok(enc)
    }
}

// ExtendedAvailablePlmnList
#[derive(Clone)]
pub struct ExtendedAvailablePlmnList(pub Vec<ExtendedAvailablePlmnItem>);

impl APerElement for ExtendedAvailablePlmnList {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(1),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        Ok(Self(Vec::<ExtendedAvailablePlmnItem>::from_aper(
            decoder,
            Self::CONSTRAINTS,
        )?))
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&(self.0).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// ExtendedAvailablePlmnItem
#[derive(Clone)]
pub struct ExtendedAvailablePlmnItem {
    pub plmn_identity: PlmnIdentity,
}

impl APerElement for ExtendedAvailablePlmnItem {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(1),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let _optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let plmn_identity = PlmnIdentity::from_aper(decoder, UNCONSTRAINED)?;

        Ok(Self { plmn_identity })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(1);
        optionals.set(0, false);

        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&self.plmn_identity.to_aper(UNCONSTRAINED)?)?;

        Ok(enc)
    }
}

// ExplicitFormat
#[derive(Clone)]
pub struct ExplicitFormat {
    pub permutation: Permutation,
    pub noof_downlink_symbols: Option<NoofDownlinkSymbols>,
    pub noof_uplink_symbols: Option<NoofUplinkSymbols>,
}

impl APerElement for ExplicitFormat {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(3),
            max: Some(3),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let permutation = Permutation::from_aper(decoder, UNCONSTRAINED)?;
        let noof_downlink_symbols = if optionals.is_set(0) {
            Some(NoofDownlinkSymbols::from_aper(decoder, UNCONSTRAINED)?)
        } else {
            None
        };
        let noof_uplink_symbols = if optionals.is_set(0) {
            Some(NoofUplinkSymbols::from_aper(decoder, UNCONSTRAINED)?)
        } else {
            None
        };

        Ok(Self {
            permutation,
            noof_downlink_symbols,
            noof_uplink_symbols,
        })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(3);
        optionals.set(0, self.noof_downlink_symbols.is_some());
        optionals.set(1, self.noof_uplink_symbols.is_some());
        optionals.set(2, false);

        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&self.permutation.to_aper(UNCONSTRAINED)?)?;
        if let Some(x) = &self.noof_downlink_symbols {
            enc.append(&x.to_aper(UNCONSTRAINED)?)?;
        }
        if let Some(x) = &self.noof_uplink_symbols {
            enc.append(&x.to_aper(UNCONSTRAINED)?)?;
        }

        Ok(enc)
    }
}

// ExtendedServedPlmnSList
#[derive(Clone)]
pub struct ExtendedServedPlmnSList(pub Vec<ExtendedServedPlmnSItem>);

impl APerElement for ExtendedServedPlmnSList {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(1),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        Ok(Self(Vec::<ExtendedServedPlmnSItem>::from_aper(
            decoder,
            Self::CONSTRAINTS,
        )?))
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&(self.0).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// ExtendedServedPlmnSItem
#[derive(Clone)]
pub struct ExtendedServedPlmnSItem {
    pub plmn_identity: PlmnIdentity,
    pub tai_slice_support_list: Option<SliceSupportList>,
}

impl APerElement for ExtendedServedPlmnSItem {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(2),
            max: Some(2),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let _extended = bool::from_aper(decoder, UNCONSTRAINED)?;
        let optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let plmn_identity = PlmnIdentity::from_aper(decoder, UNCONSTRAINED)?;
        let tai_slice_support_list = if optionals.is_set(0) {
            Some(SliceSupportList::from_aper(decoder, UNCONSTRAINED)?)
        } else {
            None
        };

        Ok(Self {
            plmn_identity,
            tai_slice_support_list,
        })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(2);
        optionals.set(0, self.tai_slice_support_list.is_some());
        optionals.set(1, false);

        enc.append(&false.to_aper(UNCONSTRAINED)?)?;
        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&self.plmn_identity.to_aper(UNCONSTRAINED)?)?;
        if let Some(x) = &self.tai_slice_support_list {
            enc.append(&x.to_aper(UNCONSTRAINED)?)?;
        }

        Ok(enc)
    }
}

// ExtendedSliceSupportList
#[derive(Clone)]
pub struct ExtendedSliceSupportList(pub Vec<SliceSupportItem>);

impl APerElement for ExtendedSliceSupportList {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(1),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        Ok(Self(Vec::<SliceSupportItem>::from_aper(
            decoder,
            Self::CONSTRAINTS,
        )?))
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&(self.0).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// EutraCellsList
#[derive(Clone)]
pub struct EutraCellsList(pub Vec<EutraCellsListItem>);

impl APerElement for EutraCellsList {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(1),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        Ok(Self(Vec::<EutraCellsListItem>::from_aper(
            decoder,
            Self::CONSTRAINTS,
        )?))
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&(self.0).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// EutraCellsListItem
#[derive(Clone)]
pub struct EutraCellsListItem {
    pub eutra_cell_id: EutraCellId,
    pub served_eutra_cells_information: ServedEutraCellsInformation,
}

impl APerElement for EutraCellsListItem {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(1),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let _optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let eutra_cell_id = EutraCellId::from_aper(decoder, UNCONSTRAINED)?;
        let served_eutra_cells_information =
            ServedEutraCellsInformation::from_aper(decoder, UNCONSTRAINED)?;

        Ok(Self {
            eutra_cell_id,
            served_eutra_cells_information,
        })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(1);
        optionals.set(0, false);

        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&self.eutra_cell_id.to_aper(UNCONSTRAINED)?)?;
        enc.append(&self.served_eutra_cells_information.to_aper(UNCONSTRAINED)?)?;

        Ok(enc)
    }
}

// EutraCellId
#[derive(Clone)]
pub struct EutraCellId(pub BitString);

impl APerElement for EutraCellId {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(28),
            max: Some(28),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        Ok(Self(BitString::from_aper(decoder, Self::CONSTRAINTS)?))
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&(self.0).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// EutraCoexFddInfo
#[derive(Clone)]
pub struct EutraCoexFddInfo {
    pub ul_earfcn: Option<ExtendedEarfcn>,
    pub dl_earfcn: ExtendedEarfcn,
    pub ul_transmission_bandwidth: Option<EutraTransmissionBandwidth>,
    pub dl_transmission_bandwidth: EutraTransmissionBandwidth,
}

impl APerElement for EutraCoexFddInfo {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(3),
            max: Some(3),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let _extended = bool::from_aper(decoder, UNCONSTRAINED)?;
        let optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let ul_earfcn = if optionals.is_set(0) {
            Some(ExtendedEarfcn::from_aper(decoder, UNCONSTRAINED)?)
        } else {
            None
        };
        let dl_earfcn = ExtendedEarfcn::from_aper(decoder, UNCONSTRAINED)?;
        let ul_transmission_bandwidth = if optionals.is_set(0) {
            Some(EutraTransmissionBandwidth::from_aper(
                decoder,
                UNCONSTRAINED,
            )?)
        } else {
            None
        };
        let dl_transmission_bandwidth =
            EutraTransmissionBandwidth::from_aper(decoder, UNCONSTRAINED)?;

        Ok(Self {
            ul_earfcn,
            dl_earfcn,
            ul_transmission_bandwidth,
            dl_transmission_bandwidth,
        })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(3);
        optionals.set(0, self.ul_earfcn.is_some());
        optionals.set(1, self.ul_transmission_bandwidth.is_some());
        optionals.set(2, false);

        enc.append(&false.to_aper(UNCONSTRAINED)?)?;
        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        if let Some(x) = &self.ul_earfcn {
            enc.append(&x.to_aper(UNCONSTRAINED)?)?;
        }
        enc.append(&self.dl_earfcn.to_aper(UNCONSTRAINED)?)?;
        if let Some(x) = &self.ul_transmission_bandwidth {
            enc.append(&x.to_aper(UNCONSTRAINED)?)?;
        }
        enc.append(&self.dl_transmission_bandwidth.to_aper(UNCONSTRAINED)?)?;

        Ok(enc)
    }
}

// EutraCoexModeInfo
#[derive(Clone)]
pub enum EutraCoexModeInfo {
    Fdd(EutraCoexFddInfo),
    Tdd(EutraCoexTddInfo),
}

impl APerElement for EutraCoexModeInfo {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        match u8::from_aper(decoder, UNCONSTRAINED)? {
            0 => Ok(Self::Fdd(EutraCoexFddInfo::from_aper(
                decoder,
                UNCONSTRAINED,
            )?)),
            1 => Ok(Self::Tdd(EutraCoexTddInfo::from_aper(
                decoder,
                UNCONSTRAINED,
            )?)),
            _ => Err(DecodeError::InvalidChoice),
        }
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        match self {
            Self::Fdd(x) => {
                enc.append(&(0 as u8).to_aper(UNCONSTRAINED)?)?;
                enc.append(&x.to_aper(UNCONSTRAINED)?)?;
            }
            Self::Tdd(x) => {
                enc.append(&(1 as u8).to_aper(UNCONSTRAINED)?)?;
                enc.append(&x.to_aper(UNCONSTRAINED)?)?;
            }
        }
        Ok(enc)
    }
}

// EutraCoexTddInfo
#[derive(Clone)]
pub struct EutraCoexTddInfo {
    pub earfcn: ExtendedEarfcn,
    pub transmission_bandwidth: EutraTransmissionBandwidth,
    pub subframe_assignment: EutraSubframeAssignment,
    pub special_subframe_info: EutraSpecialSubframeInfo,
}

impl APerElement for EutraCoexTddInfo {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(1),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let _extended = bool::from_aper(decoder, UNCONSTRAINED)?;
        let _optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let earfcn = ExtendedEarfcn::from_aper(decoder, UNCONSTRAINED)?;
        let transmission_bandwidth = EutraTransmissionBandwidth::from_aper(decoder, UNCONSTRAINED)?;
        let subframe_assignment = EutraSubframeAssignment::from_aper(decoder, UNCONSTRAINED)?;
        let special_subframe_info = EutraSpecialSubframeInfo::from_aper(decoder, UNCONSTRAINED)?;

        Ok(Self {
            earfcn,
            transmission_bandwidth,
            subframe_assignment,
            special_subframe_info,
        })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(1);
        optionals.set(0, false);

        enc.append(&false.to_aper(UNCONSTRAINED)?)?;
        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&self.earfcn.to_aper(UNCONSTRAINED)?)?;
        enc.append(&self.transmission_bandwidth.to_aper(UNCONSTRAINED)?)?;
        enc.append(&self.subframe_assignment.to_aper(UNCONSTRAINED)?)?;
        enc.append(&self.special_subframe_info.to_aper(UNCONSTRAINED)?)?;

        Ok(enc)
    }
}

// EutraCyclicPrefixDl
#[derive(Clone, Copy, FromPrimitive)]
pub enum EutraCyclicPrefixDl {
    Normal,
    Extended,
    _Extended,
}

impl APerElement for EutraCyclicPrefixDl {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        if bool::from_aper(decoder, Self::CONSTRAINTS)? {
            return Ok(EutraCyclicPrefixDl::_Extended);
        }
        let v = u8::from_aper(decoder, Self::CONSTRAINTS)?;
        FromPrimitive::from_u8(v).ok_or(DecodeError::MalformedInt)
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&false.to_aper(UNCONSTRAINED)?)?;
        enc.append(&(*self as u8).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// EutraCyclicPrefixUl
#[derive(Clone, Copy, FromPrimitive)]
pub enum EutraCyclicPrefixUl {
    Normal,
    Extended,
    _Extended,
}

impl APerElement for EutraCyclicPrefixUl {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        if bool::from_aper(decoder, Self::CONSTRAINTS)? {
            return Ok(EutraCyclicPrefixUl::_Extended);
        }
        let v = u8::from_aper(decoder, Self::CONSTRAINTS)?;
        FromPrimitive::from_u8(v).ok_or(DecodeError::MalformedInt)
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&false.to_aper(UNCONSTRAINED)?)?;
        enc.append(&(*self as u8).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// EutraPrachConfiguration
#[derive(Clone)]
pub struct EutraPrachConfiguration {
    pub root_sequence_index: u16,
    pub zero_correlation_index: u8,
    pub high_speed_flag: bool,
    pub prach_freq_offset: u8,
    pub prach_config_index: Option<u8>,
}

impl APerElement for EutraPrachConfiguration {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(2),
            max: Some(2),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let _extended = bool::from_aper(decoder, UNCONSTRAINED)?;
        let optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let root_sequence_index = u16::from_aper(decoder, UNCONSTRAINED)?;
        let zero_correlation_index = u8::from_aper(decoder, UNCONSTRAINED)?;
        let high_speed_flag = bool::from_aper(decoder, UNCONSTRAINED)?;
        let prach_freq_offset = u8::from_aper(decoder, UNCONSTRAINED)?;
        let prach_config_index = if optionals.is_set(0) {
            Some(u8::from_aper(decoder, UNCONSTRAINED)?)
        } else {
            None
        };

        Ok(Self {
            root_sequence_index,
            zero_correlation_index,
            high_speed_flag,
            prach_freq_offset,
            prach_config_index,
        })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(2);
        optionals.set(0, self.prach_config_index.is_some());
        optionals.set(1, false);

        enc.append(&false.to_aper(UNCONSTRAINED)?)?;
        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&self.root_sequence_index.to_aper(UNCONSTRAINED)?)?;
        enc.append(&self.zero_correlation_index.to_aper(UNCONSTRAINED)?)?;
        enc.append(&self.high_speed_flag.to_aper(UNCONSTRAINED)?)?;
        enc.append(&self.prach_freq_offset.to_aper(UNCONSTRAINED)?)?;
        if let Some(x) = &self.prach_config_index {
            enc.append(&x.to_aper(UNCONSTRAINED)?)?;
        }

        Ok(enc)
    }
}

// EutraSpecialSubframeInfo
#[derive(Clone)]
pub struct EutraSpecialSubframeInfo {
    pub special_subframe_patterns: EutraSpecialSubframePatterns,
    pub cyclic_prefix_dl: EutraCyclicPrefixDl,
    pub cyclic_prefix_ul: EutraCyclicPrefixUl,
}

impl APerElement for EutraSpecialSubframeInfo {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(1),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let _extended = bool::from_aper(decoder, UNCONSTRAINED)?;
        let _optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let special_subframe_patterns =
            EutraSpecialSubframePatterns::from_aper(decoder, UNCONSTRAINED)?;
        let cyclic_prefix_dl = EutraCyclicPrefixDl::from_aper(decoder, UNCONSTRAINED)?;
        let cyclic_prefix_ul = EutraCyclicPrefixUl::from_aper(decoder, UNCONSTRAINED)?;

        Ok(Self {
            special_subframe_patterns,
            cyclic_prefix_dl,
            cyclic_prefix_ul,
        })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(1);
        optionals.set(0, false);

        enc.append(&false.to_aper(UNCONSTRAINED)?)?;
        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&self.special_subframe_patterns.to_aper(UNCONSTRAINED)?)?;
        enc.append(&self.cyclic_prefix_dl.to_aper(UNCONSTRAINED)?)?;
        enc.append(&self.cyclic_prefix_ul.to_aper(UNCONSTRAINED)?)?;

        Ok(enc)
    }
}

// EutraSpecialSubframePatterns
#[derive(Clone, Copy, FromPrimitive)]
pub enum EutraSpecialSubframePatterns {
    Ssp0,
    Ssp1,
    Ssp2,
    Ssp3,
    Ssp4,
    Ssp5,
    Ssp6,
    Ssp7,
    Ssp8,
    Ssp9,
    Ssp10,
    _Extended,
}

impl APerElement for EutraSpecialSubframePatterns {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        if bool::from_aper(decoder, Self::CONSTRAINTS)? {
            return Ok(EutraSpecialSubframePatterns::_Extended);
        }
        let v = u8::from_aper(decoder, Self::CONSTRAINTS)?;
        FromPrimitive::from_u8(v).ok_or(DecodeError::MalformedInt)
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&false.to_aper(UNCONSTRAINED)?)?;
        enc.append(&(*self as u8).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// EutraSubframeAssignment
#[derive(Clone, Copy, FromPrimitive)]
pub enum EutraSubframeAssignment {
    Sa0,
    Sa1,
    Sa2,
    Sa3,
    Sa4,
    Sa5,
    Sa6,
    _Extended,
}

impl APerElement for EutraSubframeAssignment {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        if bool::from_aper(decoder, Self::CONSTRAINTS)? {
            return Ok(EutraSubframeAssignment::_Extended);
        }
        let v = u8::from_aper(decoder, Self::CONSTRAINTS)?;
        FromPrimitive::from_u8(v).ok_or(DecodeError::MalformedInt)
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&false.to_aper(UNCONSTRAINED)?)?;
        enc.append(&(*self as u8).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// EutraTransmissionBandwidth
#[derive(Clone, Copy, FromPrimitive)]
pub enum EutraTransmissionBandwidth {
    Bw6,
    Bw15,
    Bw25,
    Bw50,
    Bw75,
    Bw100,
    _Extended,
}

impl APerElement for EutraTransmissionBandwidth {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        if bool::from_aper(decoder, Self::CONSTRAINTS)? {
            return Ok(EutraTransmissionBandwidth::_Extended);
        }
        let v = u8::from_aper(decoder, Self::CONSTRAINTS)?;
        FromPrimitive::from_u8(v).ok_or(DecodeError::MalformedInt)
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&false.to_aper(UNCONSTRAINED)?)?;
        enc.append(&(*self as u8).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// EutranQos
#[derive(Clone)]
pub struct EutranQos {
    pub qci: Qci,
    pub allocation_and_retention_priority: AllocationAndRetentionPriority,
    pub gbr_qos_information: Option<GbrQosInformation>,
}

impl APerElement for EutranQos {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(2),
            max: Some(2),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let _extended = bool::from_aper(decoder, UNCONSTRAINED)?;
        let optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let qci = Qci::from_aper(decoder, UNCONSTRAINED)?;
        let allocation_and_retention_priority =
            AllocationAndRetentionPriority::from_aper(decoder, UNCONSTRAINED)?;
        let gbr_qos_information = if optionals.is_set(0) {
            Some(GbrQosInformation::from_aper(decoder, UNCONSTRAINED)?)
        } else {
            None
        };

        Ok(Self {
            qci,
            allocation_and_retention_priority,
            gbr_qos_information,
        })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(2);
        optionals.set(0, self.gbr_qos_information.is_some());
        optionals.set(1, false);

        enc.append(&false.to_aper(UNCONSTRAINED)?)?;
        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&self.qci.to_aper(UNCONSTRAINED)?)?;
        enc.append(
            &self
                .allocation_and_retention_priority
                .to_aper(UNCONSTRAINED)?,
        )?;
        if let Some(x) = &self.gbr_qos_information {
            enc.append(&x.to_aper(UNCONSTRAINED)?)?;
        }

        Ok(enc)
    }
}

// ExecuteDuplication
#[derive(Clone, Copy, FromPrimitive)]
pub enum ExecuteDuplication {
    True,
    _Extended,
}

impl APerElement for ExecuteDuplication {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        if bool::from_aper(decoder, Self::CONSTRAINTS)? {
            return Ok(ExecuteDuplication::_Extended);
        }
        let v = u8::from_aper(decoder, Self::CONSTRAINTS)?;
        FromPrimitive::from_u8(v).ok_or(DecodeError::MalformedInt)
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&false.to_aper(UNCONSTRAINED)?)?;
        enc.append(&(*self as u8).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// ExtendedEarfcn
#[derive(Clone)]
pub struct ExtendedEarfcn(pub u32);

impl APerElement for ExtendedEarfcn {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(0),
            max: Some(0),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        Ok(Self(u32::from_aper(decoder, Self::CONSTRAINTS)?))
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&(self.0).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// EutraModeInfo
#[derive(Clone)]
pub enum EutraModeInfo {
    Eutrafdd(EutraFddInfo),
    Eutratdd(EutraTddInfo),
    _Extended,
}

impl APerElement for EutraModeInfo {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        match u8::from_aper(decoder, UNCONSTRAINED)? {
            0 => Ok(Self::Eutrafdd(EutraFddInfo::from_aper(
                decoder,
                UNCONSTRAINED,
            )?)),
            1 => Ok(Self::Eutratdd(EutraTddInfo::from_aper(
                decoder,
                UNCONSTRAINED,
            )?)),
            2 => Err(DecodeError::NotImplemented),
            _ => Err(DecodeError::InvalidChoice),
        }
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        match self {
            Self::Eutrafdd(x) => {
                enc.append(&(0 as u8).to_aper(UNCONSTRAINED)?)?;
                enc.append(&x.to_aper(UNCONSTRAINED)?)?;
            }
            Self::Eutratdd(x) => {
                enc.append(&(1 as u8).to_aper(UNCONSTRAINED)?)?;
                enc.append(&x.to_aper(UNCONSTRAINED)?)?;
            }
            Self::_Extended => return Err(EncodeError::NotImplemented),
        }
        Ok(enc)
    }
}

// EutraNrCellResourceCoordinationReqContainer
#[derive(Clone)]
pub struct EutraNrCellResourceCoordinationReqContainer(pub Vec<u8>);

impl APerElement for EutraNrCellResourceCoordinationReqContainer {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        Ok(Self(Vec::<u8>::from_aper(decoder, Self::CONSTRAINTS)?))
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&(self.0).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// EutraNrCellResourceCoordinationReqAckContainer
#[derive(Clone)]
pub struct EutraNrCellResourceCoordinationReqAckContainer(pub Vec<u8>);

impl APerElement for EutraNrCellResourceCoordinationReqAckContainer {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        Ok(Self(Vec::<u8>::from_aper(decoder, Self::CONSTRAINTS)?))
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&(self.0).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// EutraFddInfo
#[derive(Clone)]
pub struct EutraFddInfo {
    pub ul_offset_to_point_a: OffsetToPointA,
    pub dl_offset_to_point_a: OffsetToPointA,
}

impl APerElement for EutraFddInfo {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(1),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let _extended = bool::from_aper(decoder, UNCONSTRAINED)?;
        let _optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let ul_offset_to_point_a = OffsetToPointA::from_aper(decoder, UNCONSTRAINED)?;
        let dl_offset_to_point_a = OffsetToPointA::from_aper(decoder, UNCONSTRAINED)?;

        Ok(Self {
            ul_offset_to_point_a,
            dl_offset_to_point_a,
        })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(1);
        optionals.set(0, false);

        enc.append(&false.to_aper(UNCONSTRAINED)?)?;
        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&self.ul_offset_to_point_a.to_aper(UNCONSTRAINED)?)?;
        enc.append(&self.dl_offset_to_point_a.to_aper(UNCONSTRAINED)?)?;

        Ok(enc)
    }
}

// EutraTddInfo
#[derive(Clone)]
pub struct EutraTddInfo {
    pub offset_to_point_a: OffsetToPointA,
}

impl APerElement for EutraTddInfo {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(1),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let _extended = bool::from_aper(decoder, UNCONSTRAINED)?;
        let _optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let offset_to_point_a = OffsetToPointA::from_aper(decoder, UNCONSTRAINED)?;

        Ok(Self { offset_to_point_a })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(1);
        optionals.set(0, false);

        enc.append(&false.to_aper(UNCONSTRAINED)?)?;
        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&self.offset_to_point_a.to_aper(UNCONSTRAINED)?)?;

        Ok(enc)
    }
}

// EventType
#[derive(Clone, Copy, FromPrimitive)]
pub enum EventType {
    OnDemand,
    Periodic,
    Stop,
    _Extended,
}

impl APerElement for EventType {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        if bool::from_aper(decoder, Self::CONSTRAINTS)? {
            return Ok(EventType::_Extended);
        }
        let v = u8::from_aper(decoder, Self::CONSTRAINTS)?;
        FromPrimitive::from_u8(v).ok_or(DecodeError::MalformedInt)
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&false.to_aper(UNCONSTRAINED)?)?;
        enc.append(&(*self as u8).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// ExtendedPacketDelayBudget
#[derive(Clone)]
pub struct ExtendedPacketDelayBudget(pub u16);

impl APerElement for ExtendedPacketDelayBudget {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(65535),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        Ok(Self(u16::from_aper(decoder, Self::CONSTRAINTS)?))
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&(self.0).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// F1cPathNsa
#[derive(Clone, Copy, FromPrimitive)]
pub enum F1cPathNsa {
    Lte,
    Nr,
    Both,
}

impl APerElement for F1cPathNsa {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let v = u8::from_aper(decoder, Self::CONSTRAINTS)?;
        FromPrimitive::from_u8(v).ok_or(DecodeError::MalformedInt)
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&(*self as u8).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// F1cTransferPath
#[derive(Clone)]
pub struct F1cTransferPath {
    pub f1c_path_nsa: F1cPathNsa,
}

impl APerElement for F1cTransferPath {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(1),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let _extended = bool::from_aper(decoder, UNCONSTRAINED)?;
        let _optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let f1c_path_nsa = F1cPathNsa::from_aper(decoder, UNCONSTRAINED)?;

        Ok(Self { f1c_path_nsa })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(1);
        optionals.set(0, false);

        enc.append(&false.to_aper(UNCONSTRAINED)?)?;
        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&self.f1c_path_nsa.to_aper(UNCONSTRAINED)?)?;

        Ok(enc)
    }
}

// FddInfo
#[derive(Clone)]
pub struct FddInfo {
    pub ul_nr_freq_info: NrFreqInfo,
    pub dl_nr_freq_info: NrFreqInfo,
    pub ul_transmission_bandwidth: TransmissionBandwidth,
    pub dl_transmission_bandwidth: TransmissionBandwidth,
}

impl APerElement for FddInfo {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(1),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let _extended = bool::from_aper(decoder, UNCONSTRAINED)?;
        let _optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let ul_nr_freq_info = NrFreqInfo::from_aper(decoder, UNCONSTRAINED)?;
        let dl_nr_freq_info = NrFreqInfo::from_aper(decoder, UNCONSTRAINED)?;
        let ul_transmission_bandwidth = TransmissionBandwidth::from_aper(decoder, UNCONSTRAINED)?;
        let dl_transmission_bandwidth = TransmissionBandwidth::from_aper(decoder, UNCONSTRAINED)?;

        Ok(Self {
            ul_nr_freq_info,
            dl_nr_freq_info,
            ul_transmission_bandwidth,
            dl_transmission_bandwidth,
        })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(1);
        optionals.set(0, false);

        enc.append(&false.to_aper(UNCONSTRAINED)?)?;
        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&self.ul_nr_freq_info.to_aper(UNCONSTRAINED)?)?;
        enc.append(&self.dl_nr_freq_info.to_aper(UNCONSTRAINED)?)?;
        enc.append(&self.ul_transmission_bandwidth.to_aper(UNCONSTRAINED)?)?;
        enc.append(&self.dl_transmission_bandwidth.to_aper(UNCONSTRAINED)?)?;

        Ok(enc)
    }
}

// FlowsMappedToDrbList
#[derive(Clone)]
pub struct FlowsMappedToDrbList(pub Vec<FlowsMappedToDrbItem>);

impl APerElement for FlowsMappedToDrbList {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(1),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        Ok(Self(Vec::<FlowsMappedToDrbItem>::from_aper(
            decoder,
            Self::CONSTRAINTS,
        )?))
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&(self.0).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// FlowsMappedToDrbItem
#[derive(Clone)]
pub struct FlowsMappedToDrbItem {
    pub qos_flow_identifier: QosFlowIdentifier,
    pub qos_flow_level_qos_parameters: QosFlowLevelQosParameters,
}

impl APerElement for FlowsMappedToDrbItem {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(1),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let _optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let qos_flow_identifier = QosFlowIdentifier::from_aper(decoder, UNCONSTRAINED)?;
        let qos_flow_level_qos_parameters =
            QosFlowLevelQosParameters::from_aper(decoder, UNCONSTRAINED)?;

        Ok(Self {
            qos_flow_identifier,
            qos_flow_level_qos_parameters,
        })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(1);
        optionals.set(0, false);

        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&self.qos_flow_identifier.to_aper(UNCONSTRAINED)?)?;
        enc.append(&self.qos_flow_level_qos_parameters.to_aper(UNCONSTRAINED)?)?;

        Ok(enc)
    }
}

// Fr1Bandwidth
#[derive(Clone, Copy, FromPrimitive)]
pub enum Fr1Bandwidth {
    Bw5,
    Bw10,
    Bw20,
    Bw40,
    Bw50,
    Bw80,
    Bw100,
    _Extended,
}

impl APerElement for Fr1Bandwidth {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        if bool::from_aper(decoder, Self::CONSTRAINTS)? {
            return Ok(Fr1Bandwidth::_Extended);
        }
        let v = u8::from_aper(decoder, Self::CONSTRAINTS)?;
        FromPrimitive::from_u8(v).ok_or(DecodeError::MalformedInt)
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&false.to_aper(UNCONSTRAINED)?)?;
        enc.append(&(*self as u8).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// Fr2Bandwidth
#[derive(Clone, Copy, FromPrimitive)]
pub enum Fr2Bandwidth {
    Bw50,
    Bw100,
    Bw200,
    Bw400,
    _Extended,
}

impl APerElement for Fr2Bandwidth {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        if bool::from_aper(decoder, Self::CONSTRAINTS)? {
            return Ok(Fr2Bandwidth::_Extended);
        }
        let v = u8::from_aper(decoder, Self::CONSTRAINTS)?;
        FromPrimitive::from_u8(v).ok_or(DecodeError::MalformedInt)
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&false.to_aper(UNCONSTRAINED)?)?;
        enc.append(&(*self as u8).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// FreqBandNrItem
#[derive(Clone)]
pub struct FreqBandNrItem {
    pub freq_band_indicator_nr: u16,
    pub supported_sul_band_list: Vec<SupportedSulFreqBandItem>,
}

impl APerElement for FreqBandNrItem {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(1),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let _extended = bool::from_aper(decoder, UNCONSTRAINED)?;
        let _optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let freq_band_indicator_nr = u16::from_aper(decoder, UNCONSTRAINED)?;
        let supported_sul_band_list = Vec::<SupportedSulFreqBandItem>::from_aper(
            decoder,
            Constraints {
                value: None,
                size: Some(Constraint::new(Some(0), Some(maxnoofNrCellBands))),
            },
        )?;

        Ok(Self {
            freq_band_indicator_nr,
            supported_sul_band_list,
        })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(1);
        optionals.set(0, false);

        enc.append(&false.to_aper(UNCONSTRAINED)?)?;
        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&self.freq_band_indicator_nr.to_aper(UNCONSTRAINED)?)?;
        enc.append(&self.supported_sul_band_list.to_aper(UNCONSTRAINED)?)?;

        Ok(enc)
    }
}

// FreqDomainLength
#[derive(Clone)]
pub enum FreqDomainLength {
    L839(L839Info),
    L139(L139Info),
    _Extended,
}

impl APerElement for FreqDomainLength {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        match u8::from_aper(decoder, UNCONSTRAINED)? {
            0 => Ok(Self::L839(L839Info::from_aper(decoder, UNCONSTRAINED)?)),
            1 => Ok(Self::L139(L139Info::from_aper(decoder, UNCONSTRAINED)?)),
            2 => Err(DecodeError::NotImplemented),
            _ => Err(DecodeError::InvalidChoice),
        }
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        match self {
            Self::L839(x) => {
                enc.append(&(0 as u8).to_aper(UNCONSTRAINED)?)?;
                enc.append(&x.to_aper(UNCONSTRAINED)?)?;
            }
            Self::L139(x) => {
                enc.append(&(1 as u8).to_aper(UNCONSTRAINED)?)?;
                enc.append(&x.to_aper(UNCONSTRAINED)?)?;
            }
            Self::_Extended => return Err(EncodeError::NotImplemented),
        }
        Ok(enc)
    }
}

// FrequencyShift7p5khz
#[derive(Clone, Copy, FromPrimitive)]
pub enum FrequencyShift7p5khz {
    False,
    True,
    _Extended,
}

impl APerElement for FrequencyShift7p5khz {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        if bool::from_aper(decoder, Self::CONSTRAINTS)? {
            return Ok(FrequencyShift7p5khz::_Extended);
        }
        let v = u8::from_aper(decoder, Self::CONSTRAINTS)?;
        FromPrimitive::from_u8(v).ok_or(DecodeError::MalformedInt)
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&false.to_aper(UNCONSTRAINED)?)?;
        enc.append(&(*self as u8).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// FullConfiguration
#[derive(Clone, Copy, FromPrimitive)]
pub enum FullConfiguration {
    Full,
    _Extended,
}

impl APerElement for FullConfiguration {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        if bool::from_aper(decoder, Self::CONSTRAINTS)? {
            return Ok(FullConfiguration::_Extended);
        }
        let v = u8::from_aper(decoder, Self::CONSTRAINTS)?;
        FromPrimitive::from_u8(v).ok_or(DecodeError::MalformedInt)
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&false.to_aper(UNCONSTRAINED)?)?;
        enc.append(&(*self as u8).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// FlowsMappedToSldrbList
#[derive(Clone)]
pub struct FlowsMappedToSldrbList(pub Vec<FlowsMappedToSldrbItem>);

impl APerElement for FlowsMappedToSldrbList {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(1),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        Ok(Self(Vec::<FlowsMappedToSldrbItem>::from_aper(
            decoder,
            Self::CONSTRAINTS,
        )?))
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&(self.0).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// FlowsMappedToSldrbItem
#[derive(Clone)]
pub struct FlowsMappedToSldrbItem {
    pub pc_5_qos_flow_identifier: Pc5QosFlowIdentifier,
}

impl APerElement for FlowsMappedToSldrbItem {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(1),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let _extended = bool::from_aper(decoder, UNCONSTRAINED)?;
        let _optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let pc_5_qos_flow_identifier = Pc5QosFlowIdentifier::from_aper(decoder, UNCONSTRAINED)?;

        Ok(Self {
            pc_5_qos_flow_identifier,
        })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(1);
        optionals.set(0, false);

        enc.append(&false.to_aper(UNCONSTRAINED)?)?;
        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&self.pc_5_qos_flow_identifier.to_aper(UNCONSTRAINED)?)?;

        Ok(enc)
    }
}

// GbrQosInformation
#[derive(Clone)]
pub struct GbrQosInformation {
    pub e_rab_maximum_bitrate_dl: BitRate,
    pub e_rab_maximum_bitrate_ul: BitRate,
    pub e_rab_guaranteed_bitrate_dl: BitRate,
    pub e_rab_guaranteed_bitrate_ul: BitRate,
}

impl APerElement for GbrQosInformation {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(1),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let _extended = bool::from_aper(decoder, UNCONSTRAINED)?;
        let _optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let e_rab_maximum_bitrate_dl = BitRate::from_aper(decoder, UNCONSTRAINED)?;
        let e_rab_maximum_bitrate_ul = BitRate::from_aper(decoder, UNCONSTRAINED)?;
        let e_rab_guaranteed_bitrate_dl = BitRate::from_aper(decoder, UNCONSTRAINED)?;
        let e_rab_guaranteed_bitrate_ul = BitRate::from_aper(decoder, UNCONSTRAINED)?;

        Ok(Self {
            e_rab_maximum_bitrate_dl,
            e_rab_maximum_bitrate_ul,
            e_rab_guaranteed_bitrate_dl,
            e_rab_guaranteed_bitrate_ul,
        })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(1);
        optionals.set(0, false);

        enc.append(&false.to_aper(UNCONSTRAINED)?)?;
        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&self.e_rab_maximum_bitrate_dl.to_aper(UNCONSTRAINED)?)?;
        enc.append(&self.e_rab_maximum_bitrate_ul.to_aper(UNCONSTRAINED)?)?;
        enc.append(&self.e_rab_guaranteed_bitrate_dl.to_aper(UNCONSTRAINED)?)?;
        enc.append(&self.e_rab_guaranteed_bitrate_ul.to_aper(UNCONSTRAINED)?)?;

        Ok(enc)
    }
}

// GbrQosFlowInformation
#[derive(Clone)]
pub struct GbrQosFlowInformation {
    pub max_flow_bit_rate_downlink: BitRate,
    pub max_flow_bit_rate_uplink: BitRate,
    pub guaranteed_flow_bit_rate_downlink: BitRate,
    pub guaranteed_flow_bit_rate_uplink: BitRate,
    pub max_packet_loss_rate_downlink: Option<MaxPacketLossRate>,
    pub max_packet_loss_rate_uplink: Option<MaxPacketLossRate>,
}

impl APerElement for GbrQosFlowInformation {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(3),
            max: Some(3),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let _extended = bool::from_aper(decoder, UNCONSTRAINED)?;
        let optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let max_flow_bit_rate_downlink = BitRate::from_aper(decoder, UNCONSTRAINED)?;
        let max_flow_bit_rate_uplink = BitRate::from_aper(decoder, UNCONSTRAINED)?;
        let guaranteed_flow_bit_rate_downlink = BitRate::from_aper(decoder, UNCONSTRAINED)?;
        let guaranteed_flow_bit_rate_uplink = BitRate::from_aper(decoder, UNCONSTRAINED)?;
        let max_packet_loss_rate_downlink = if optionals.is_set(0) {
            Some(MaxPacketLossRate::from_aper(decoder, UNCONSTRAINED)?)
        } else {
            None
        };
        let max_packet_loss_rate_uplink = if optionals.is_set(0) {
            Some(MaxPacketLossRate::from_aper(decoder, UNCONSTRAINED)?)
        } else {
            None
        };

        Ok(Self {
            max_flow_bit_rate_downlink,
            max_flow_bit_rate_uplink,
            guaranteed_flow_bit_rate_downlink,
            guaranteed_flow_bit_rate_uplink,
            max_packet_loss_rate_downlink,
            max_packet_loss_rate_uplink,
        })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(3);
        optionals.set(0, self.max_packet_loss_rate_downlink.is_some());
        optionals.set(1, self.max_packet_loss_rate_uplink.is_some());
        optionals.set(2, false);

        enc.append(&false.to_aper(UNCONSTRAINED)?)?;
        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&self.max_flow_bit_rate_downlink.to_aper(UNCONSTRAINED)?)?;
        enc.append(&self.max_flow_bit_rate_uplink.to_aper(UNCONSTRAINED)?)?;
        enc.append(
            &self
                .guaranteed_flow_bit_rate_downlink
                .to_aper(UNCONSTRAINED)?,
        )?;
        enc.append(
            &self
                .guaranteed_flow_bit_rate_uplink
                .to_aper(UNCONSTRAINED)?,
        )?;
        if let Some(x) = &self.max_packet_loss_rate_downlink {
            enc.append(&x.to_aper(UNCONSTRAINED)?)?;
        }
        if let Some(x) = &self.max_packet_loss_rate_uplink {
            enc.append(&x.to_aper(UNCONSTRAINED)?)?;
        }

        Ok(enc)
    }
}

// CgConfig
#[derive(Clone)]
pub struct CgConfig(pub Vec<u8>);

impl APerElement for CgConfig {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        Ok(Self(Vec::<u8>::from_aper(decoder, Self::CONSTRAINTS)?))
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&(self.0).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// GeographicalCoordinates
#[derive(Clone)]
pub struct GeographicalCoordinates {
    pub trp_position_definition_type: TrpPositionDefinitionType,
    pub dlprs_resource_coordinates: Option<DlprsResourceCoordinates>,
}

impl APerElement for GeographicalCoordinates {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(2),
            max: Some(2),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let trp_position_definition_type =
            TrpPositionDefinitionType::from_aper(decoder, UNCONSTRAINED)?;
        let dlprs_resource_coordinates = if optionals.is_set(0) {
            Some(DlprsResourceCoordinates::from_aper(decoder, UNCONSTRAINED)?)
        } else {
            None
        };

        Ok(Self {
            trp_position_definition_type,
            dlprs_resource_coordinates,
        })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(2);
        optionals.set(0, self.dlprs_resource_coordinates.is_some());
        optionals.set(1, false);

        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&self.trp_position_definition_type.to_aper(UNCONSTRAINED)?)?;
        if let Some(x) = &self.dlprs_resource_coordinates {
            enc.append(&x.to_aper(UNCONSTRAINED)?)?;
        }

        Ok(enc)
    }
}

// GnbCuMeasurementId
#[derive(Clone)]
pub struct GnbCuMeasurementId(pub u16);

impl APerElement for GnbCuMeasurementId {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(0),
            max: Some(4095),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        Ok(Self(u16::from_aper(decoder, Self::CONSTRAINTS)?))
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&(self.0).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// GnbDuMeasurementId
#[derive(Clone)]
pub struct GnbDuMeasurementId(pub u16);

impl APerElement for GnbDuMeasurementId {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(0),
            max: Some(4095),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        Ok(Self(u16::from_aper(decoder, Self::CONSTRAINTS)?))
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&(self.0).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// GnbCuSystemInformation
#[derive(Clone)]
pub struct GnbCuSystemInformation {
    pub sibtypetobeupdatedlist: Vec<SibtypetobeupdatedListItem>,
}

impl APerElement for GnbCuSystemInformation {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(1),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let _extended = bool::from_aper(decoder, UNCONSTRAINED)?;
        let _optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let sibtypetobeupdatedlist = Vec::<SibtypetobeupdatedListItem>::from_aper(
            decoder,
            Constraints {
                value: None,
                size: Some(Constraint::new(Some(1), Some(maxnoofSIBTypes))),
            },
        )?;

        Ok(Self {
            sibtypetobeupdatedlist,
        })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(1);
        optionals.set(0, false);

        enc.append(&false.to_aper(UNCONSTRAINED)?)?;
        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&self.sibtypetobeupdatedlist.to_aper(UNCONSTRAINED)?)?;

        Ok(enc)
    }
}

// GnbCuTnlAssociationSetupItem
#[derive(Clone)]
pub struct GnbCuTnlAssociationSetupItem {
    pub tnl_association_transport_layer_address: CpTransportLayerAddress,
}

impl APerElement for GnbCuTnlAssociationSetupItem {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(1),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let _optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let tnl_association_transport_layer_address =
            CpTransportLayerAddress::from_aper(decoder, UNCONSTRAINED)?;

        Ok(Self {
            tnl_association_transport_layer_address,
        })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(1);
        optionals.set(0, false);

        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(
            &self
                .tnl_association_transport_layer_address
                .to_aper(UNCONSTRAINED)?,
        )?;

        Ok(enc)
    }
}

// GnbCuTnlAssociationFailedToSetupItem
#[derive(Clone)]
pub struct GnbCuTnlAssociationFailedToSetupItem {
    pub tnl_association_transport_layer_address: CpTransportLayerAddress,
    pub cause: Cause,
}

impl APerElement for GnbCuTnlAssociationFailedToSetupItem {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(1),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let _optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let tnl_association_transport_layer_address =
            CpTransportLayerAddress::from_aper(decoder, UNCONSTRAINED)?;
        let cause = Cause::from_aper(decoder, UNCONSTRAINED)?;

        Ok(Self {
            tnl_association_transport_layer_address,
            cause,
        })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(1);
        optionals.set(0, false);

        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(
            &self
                .tnl_association_transport_layer_address
                .to_aper(UNCONSTRAINED)?,
        )?;
        enc.append(&self.cause.to_aper(UNCONSTRAINED)?)?;

        Ok(enc)
    }
}

// GnbCuTnlAssociationToAddItem
#[derive(Clone)]
pub struct GnbCuTnlAssociationToAddItem {
    pub tnl_association_transport_layer_address: CpTransportLayerAddress,
    pub tnl_association_usage: TnlAssociationUsage,
}

impl APerElement for GnbCuTnlAssociationToAddItem {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(1),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let _optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let tnl_association_transport_layer_address =
            CpTransportLayerAddress::from_aper(decoder, UNCONSTRAINED)?;
        let tnl_association_usage = TnlAssociationUsage::from_aper(decoder, UNCONSTRAINED)?;

        Ok(Self {
            tnl_association_transport_layer_address,
            tnl_association_usage,
        })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(1);
        optionals.set(0, false);

        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(
            &self
                .tnl_association_transport_layer_address
                .to_aper(UNCONSTRAINED)?,
        )?;
        enc.append(&self.tnl_association_usage.to_aper(UNCONSTRAINED)?)?;

        Ok(enc)
    }
}

// GnbCuTnlAssociationToRemoveItem
#[derive(Clone)]
pub struct GnbCuTnlAssociationToRemoveItem {
    pub tnl_association_transport_layer_address: CpTransportLayerAddress,
}

impl APerElement for GnbCuTnlAssociationToRemoveItem {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(1),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let _optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let tnl_association_transport_layer_address =
            CpTransportLayerAddress::from_aper(decoder, UNCONSTRAINED)?;

        Ok(Self {
            tnl_association_transport_layer_address,
        })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(1);
        optionals.set(0, false);

        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(
            &self
                .tnl_association_transport_layer_address
                .to_aper(UNCONSTRAINED)?,
        )?;

        Ok(enc)
    }
}

// GnbCuTnlAssociationToUpdateItem
#[derive(Clone)]
pub struct GnbCuTnlAssociationToUpdateItem {
    pub tnl_association_transport_layer_address: CpTransportLayerAddress,
    pub tnl_association_usage: Option<TnlAssociationUsage>,
}

impl APerElement for GnbCuTnlAssociationToUpdateItem {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(2),
            max: Some(2),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let tnl_association_transport_layer_address =
            CpTransportLayerAddress::from_aper(decoder, UNCONSTRAINED)?;
        let tnl_association_usage = if optionals.is_set(0) {
            Some(TnlAssociationUsage::from_aper(decoder, UNCONSTRAINED)?)
        } else {
            None
        };

        Ok(Self {
            tnl_association_transport_layer_address,
            tnl_association_usage,
        })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(2);
        optionals.set(0, self.tnl_association_usage.is_some());
        optionals.set(1, false);

        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(
            &self
                .tnl_association_transport_layer_address
                .to_aper(UNCONSTRAINED)?,
        )?;
        if let Some(x) = &self.tnl_association_usage {
            enc.append(&x.to_aper(UNCONSTRAINED)?)?;
        }

        Ok(enc)
    }
}

// GnbCuUeF1apId
#[derive(Clone)]
pub struct GnbCuUeF1apId(pub u64);

impl APerElement for GnbCuUeF1apId {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(0),
            max: Some(0),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        Ok(Self(u64::from_aper(decoder, Self::CONSTRAINTS)?))
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&(self.0).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// GnbDuCellResourceConfiguration
#[derive(Clone)]
pub struct GnbDuCellResourceConfiguration {
    pub subcarrier_spacing: SubcarrierSpacing,
    pub duf_transmission_periodicity: Option<DufTransmissionPeriodicity>,
    pub duf_slot_config_list: Option<DufSlotConfigList>,
    pub hsna_transmission_periodicity: HsnaTransmissionPeriodicity,
    pub hnsa_slot_config_list: Option<HsnaSlotConfigList>,
}

impl APerElement for GnbDuCellResourceConfiguration {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(4),
            max: Some(4),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let subcarrier_spacing = SubcarrierSpacing::from_aper(decoder, UNCONSTRAINED)?;
        let duf_transmission_periodicity = if optionals.is_set(0) {
            Some(DufTransmissionPeriodicity::from_aper(
                decoder,
                UNCONSTRAINED,
            )?)
        } else {
            None
        };
        let duf_slot_config_list = if optionals.is_set(0) {
            Some(DufSlotConfigList::from_aper(decoder, UNCONSTRAINED)?)
        } else {
            None
        };
        let hsna_transmission_periodicity =
            HsnaTransmissionPeriodicity::from_aper(decoder, UNCONSTRAINED)?;
        let hnsa_slot_config_list = if optionals.is_set(0) {
            Some(HsnaSlotConfigList::from_aper(decoder, UNCONSTRAINED)?)
        } else {
            None
        };

        Ok(Self {
            subcarrier_spacing,
            duf_transmission_periodicity,
            duf_slot_config_list,
            hsna_transmission_periodicity,
            hnsa_slot_config_list,
        })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(4);
        optionals.set(0, self.duf_transmission_periodicity.is_some());
        optionals.set(1, self.duf_slot_config_list.is_some());
        optionals.set(2, self.hnsa_slot_config_list.is_some());
        optionals.set(3, false);

        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&self.subcarrier_spacing.to_aper(UNCONSTRAINED)?)?;
        if let Some(x) = &self.duf_transmission_periodicity {
            enc.append(&x.to_aper(UNCONSTRAINED)?)?;
        }
        if let Some(x) = &self.duf_slot_config_list {
            enc.append(&x.to_aper(UNCONSTRAINED)?)?;
        }
        enc.append(&self.hsna_transmission_periodicity.to_aper(UNCONSTRAINED)?)?;
        if let Some(x) = &self.hnsa_slot_config_list {
            enc.append(&x.to_aper(UNCONSTRAINED)?)?;
        }

        Ok(enc)
    }
}

// GnbDuUeF1apId
#[derive(Clone)]
pub struct GnbDuUeF1apId(pub u64);

impl APerElement for GnbDuUeF1apId {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(0),
            max: Some(0),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        Ok(Self(u64::from_aper(decoder, Self::CONSTRAINTS)?))
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&(self.0).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// GnbDuId
#[derive(Clone)]
pub struct GnbDuId(pub u64);

impl APerElement for GnbDuId {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(0),
            max: Some(0),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        Ok(Self(u64::from_aper(decoder, Self::CONSTRAINTS)?))
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&(self.0).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// GnbCuName
#[derive(Clone)]
pub struct GnbCuName(pub PrintableString);

impl APerElement for GnbCuName {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(150),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        Ok(Self(PrintableString::from_aper(
            decoder,
            Self::CONSTRAINTS,
        )?))
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&(self.0).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// GnbDuName
#[derive(Clone)]
pub struct GnbDuName(pub PrintableString);

impl APerElement for GnbDuName {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(150),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        Ok(Self(PrintableString::from_aper(
            decoder,
            Self::CONSTRAINTS,
        )?))
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&(self.0).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// ExtendedGnbCuName
#[derive(Clone)]
pub struct ExtendedGnbCuName {
    pub gnb_cu_name_visible_string: Option<GnbCuNameVisibleString>,
    pub gnb_cu_name_utf8_string: Option<GnbCuNameUtf8String>,
}

impl APerElement for ExtendedGnbCuName {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(3),
            max: Some(3),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let _extended = bool::from_aper(decoder, UNCONSTRAINED)?;
        let optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let gnb_cu_name_visible_string = if optionals.is_set(0) {
            Some(GnbCuNameVisibleString::from_aper(decoder, UNCONSTRAINED)?)
        } else {
            None
        };
        let gnb_cu_name_utf8_string = if optionals.is_set(0) {
            Some(GnbCuNameUtf8String::from_aper(decoder, UNCONSTRAINED)?)
        } else {
            None
        };

        Ok(Self {
            gnb_cu_name_visible_string,
            gnb_cu_name_utf8_string,
        })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(3);
        optionals.set(0, self.gnb_cu_name_visible_string.is_some());
        optionals.set(1, self.gnb_cu_name_utf8_string.is_some());
        optionals.set(2, false);

        enc.append(&false.to_aper(UNCONSTRAINED)?)?;
        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        if let Some(x) = &self.gnb_cu_name_visible_string {
            enc.append(&x.to_aper(UNCONSTRAINED)?)?;
        }
        if let Some(x) = &self.gnb_cu_name_utf8_string {
            enc.append(&x.to_aper(UNCONSTRAINED)?)?;
        }

        Ok(enc)
    }
}

// GnbCuNameVisibleString
#[derive(Clone)]
pub struct GnbCuNameVisibleString(pub VisibleString);

impl APerElement for GnbCuNameVisibleString {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(150),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        Ok(Self(VisibleString::from_aper(decoder, Self::CONSTRAINTS)?))
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&(self.0).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// GnbCuNameUtf8String
#[derive(Clone)]
pub struct GnbCuNameUtf8String(pub Utf8String);

impl APerElement for GnbCuNameUtf8String {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(150),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        Ok(Self(Utf8String::from_aper(decoder, Self::CONSTRAINTS)?))
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&(self.0).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// ExtendedGnbDuName
#[derive(Clone)]
pub struct ExtendedGnbDuName {
    pub gnb_du_name_visible_string: Option<GnbDuNameVisibleString>,
    pub gnb_du_name_utf8_string: Option<GnbDuNameUtf8String>,
}

impl APerElement for ExtendedGnbDuName {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(3),
            max: Some(3),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let _extended = bool::from_aper(decoder, UNCONSTRAINED)?;
        let optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let gnb_du_name_visible_string = if optionals.is_set(0) {
            Some(GnbDuNameVisibleString::from_aper(decoder, UNCONSTRAINED)?)
        } else {
            None
        };
        let gnb_du_name_utf8_string = if optionals.is_set(0) {
            Some(GnbDuNameUtf8String::from_aper(decoder, UNCONSTRAINED)?)
        } else {
            None
        };

        Ok(Self {
            gnb_du_name_visible_string,
            gnb_du_name_utf8_string,
        })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(3);
        optionals.set(0, self.gnb_du_name_visible_string.is_some());
        optionals.set(1, self.gnb_du_name_utf8_string.is_some());
        optionals.set(2, false);

        enc.append(&false.to_aper(UNCONSTRAINED)?)?;
        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        if let Some(x) = &self.gnb_du_name_visible_string {
            enc.append(&x.to_aper(UNCONSTRAINED)?)?;
        }
        if let Some(x) = &self.gnb_du_name_utf8_string {
            enc.append(&x.to_aper(UNCONSTRAINED)?)?;
        }

        Ok(enc)
    }
}

// GnbDuNameVisibleString
#[derive(Clone)]
pub struct GnbDuNameVisibleString(pub VisibleString);

impl APerElement for GnbDuNameVisibleString {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(150),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        Ok(Self(VisibleString::from_aper(decoder, Self::CONSTRAINTS)?))
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&(self.0).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// GnbDuNameUtf8String
#[derive(Clone)]
pub struct GnbDuNameUtf8String(pub Utf8String);

impl APerElement for GnbDuNameUtf8String {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(150),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        Ok(Self(Utf8String::from_aper(decoder, Self::CONSTRAINTS)?))
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&(self.0).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// GnbDuServedCellsItem
#[derive(Clone)]
pub struct GnbDuServedCellsItem {
    pub served_cell_information: ServedCellInformation,
    pub gnb_du_system_information: Option<GnbDuSystemInformation>,
}

impl APerElement for GnbDuServedCellsItem {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(2),
            max: Some(2),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let _extended = bool::from_aper(decoder, UNCONSTRAINED)?;
        let optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let served_cell_information = ServedCellInformation::from_aper(decoder, UNCONSTRAINED)?;
        let gnb_du_system_information = if optionals.is_set(0) {
            Some(GnbDuSystemInformation::from_aper(decoder, UNCONSTRAINED)?)
        } else {
            None
        };

        Ok(Self {
            served_cell_information,
            gnb_du_system_information,
        })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(2);
        optionals.set(0, self.gnb_du_system_information.is_some());
        optionals.set(1, false);

        enc.append(&false.to_aper(UNCONSTRAINED)?)?;
        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&self.served_cell_information.to_aper(UNCONSTRAINED)?)?;
        if let Some(x) = &self.gnb_du_system_information {
            enc.append(&x.to_aper(UNCONSTRAINED)?)?;
        }

        Ok(enc)
    }
}

// GnbDuSystemInformation
#[derive(Clone)]
pub struct GnbDuSystemInformation {
    pub mib_message: MibMessage,
    pub sib1_message: Sib1Message,
}

impl APerElement for GnbDuSystemInformation {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(1),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let _extended = bool::from_aper(decoder, UNCONSTRAINED)?;
        let _optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let mib_message = MibMessage::from_aper(decoder, UNCONSTRAINED)?;
        let sib1_message = Sib1Message::from_aper(decoder, UNCONSTRAINED)?;

        Ok(Self {
            mib_message,
            sib1_message,
        })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(1);
        optionals.set(0, false);

        enc.append(&false.to_aper(UNCONSTRAINED)?)?;
        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&self.mib_message.to_aper(UNCONSTRAINED)?)?;
        enc.append(&self.sib1_message.to_aper(UNCONSTRAINED)?)?;

        Ok(enc)
    }
}

// GnbDuConfigurationQuery
#[derive(Clone, Copy, FromPrimitive)]
pub enum GnbDuConfigurationQuery {
    True,
    _Extended,
}

impl APerElement for GnbDuConfigurationQuery {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        if bool::from_aper(decoder, Self::CONSTRAINTS)? {
            return Ok(GnbDuConfigurationQuery::_Extended);
        }
        let v = u8::from_aper(decoder, Self::CONSTRAINTS)?;
        FromPrimitive::from_u8(v).ok_or(DecodeError::MalformedInt)
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&false.to_aper(UNCONSTRAINED)?)?;
        enc.append(&(*self as u8).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// GnbDuOverloadInformation
#[derive(Clone, Copy, FromPrimitive)]
pub enum GnbDuOverloadInformation {
    Overloaded,
    NotOverloaded,
}

impl APerElement for GnbDuOverloadInformation {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let v = u8::from_aper(decoder, Self::CONSTRAINTS)?;
        FromPrimitive::from_u8(v).ok_or(DecodeError::MalformedInt)
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&(*self as u8).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// GnbDuTnlAssociationToRemoveItem
#[derive(Clone)]
pub struct GnbDuTnlAssociationToRemoveItem {
    pub tnl_association_transport_layer_address: CpTransportLayerAddress,
    pub tnl_association_transport_layer_address_gnb_cu: Option<CpTransportLayerAddress>,
}

impl APerElement for GnbDuTnlAssociationToRemoveItem {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(2),
            max: Some(2),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let tnl_association_transport_layer_address =
            CpTransportLayerAddress::from_aper(decoder, UNCONSTRAINED)?;
        let tnl_association_transport_layer_address_gnb_cu = if optionals.is_set(0) {
            Some(CpTransportLayerAddress::from_aper(decoder, UNCONSTRAINED)?)
        } else {
            None
        };

        Ok(Self {
            tnl_association_transport_layer_address,
            tnl_association_transport_layer_address_gnb_cu,
        })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(2);
        optionals.set(
            0,
            self.tnl_association_transport_layer_address_gnb_cu
                .is_some(),
        );
        optionals.set(1, false);

        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(
            &self
                .tnl_association_transport_layer_address
                .to_aper(UNCONSTRAINED)?,
        )?;
        if let Some(x) = &self.tnl_association_transport_layer_address_gnb_cu {
            enc.append(&x.to_aper(UNCONSTRAINED)?)?;
        }

        Ok(enc)
    }
}

// GnbRxTxTimeDiff
#[derive(Clone)]
pub struct GnbRxTxTimeDiff {
    pub rx_tx_time_diff: GnbRxTxTimeDiffMeas,
    pub additional_path_list: Option<AdditionalPathList>,
}

impl APerElement for GnbRxTxTimeDiff {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(2),
            max: Some(2),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let rx_tx_time_diff = GnbRxTxTimeDiffMeas::from_aper(decoder, UNCONSTRAINED)?;
        let additional_path_list = if optionals.is_set(0) {
            Some(AdditionalPathList::from_aper(decoder, UNCONSTRAINED)?)
        } else {
            None
        };

        Ok(Self {
            rx_tx_time_diff,
            additional_path_list,
        })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(2);
        optionals.set(0, self.additional_path_list.is_some());
        optionals.set(1, false);

        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&self.rx_tx_time_diff.to_aper(UNCONSTRAINED)?)?;
        if let Some(x) = &self.additional_path_list {
            enc.append(&x.to_aper(UNCONSTRAINED)?)?;
        }

        Ok(enc)
    }
}

// GnbRxTxTimeDiffMeas
#[derive(Clone)]
pub enum GnbRxTxTimeDiffMeas {
    K0(u32),
    K1(u32),
    K2(u32),
    K3(u32),
    K4(u32),
    K5(u16),
    _Extended,
}

impl APerElement for GnbRxTxTimeDiffMeas {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        match u8::from_aper(decoder, UNCONSTRAINED)? {
            0 => Ok(Self::K0(u32::from_aper(decoder, UNCONSTRAINED)?)),
            1 => Ok(Self::K1(u32::from_aper(decoder, UNCONSTRAINED)?)),
            2 => Ok(Self::K2(u32::from_aper(decoder, UNCONSTRAINED)?)),
            3 => Ok(Self::K3(u32::from_aper(decoder, UNCONSTRAINED)?)),
            4 => Ok(Self::K4(u32::from_aper(decoder, UNCONSTRAINED)?)),
            5 => Ok(Self::K5(u16::from_aper(decoder, UNCONSTRAINED)?)),
            6 => Err(DecodeError::NotImplemented),
            _ => Err(DecodeError::InvalidChoice),
        }
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        match self {
            Self::K0(x) => {
                enc.append(&(0 as u8).to_aper(UNCONSTRAINED)?)?;
                enc.append(&x.to_aper(UNCONSTRAINED)?)?;
            }
            Self::K1(x) => {
                enc.append(&(1 as u8).to_aper(UNCONSTRAINED)?)?;
                enc.append(&x.to_aper(UNCONSTRAINED)?)?;
            }
            Self::K2(x) => {
                enc.append(&(2 as u8).to_aper(UNCONSTRAINED)?)?;
                enc.append(&x.to_aper(UNCONSTRAINED)?)?;
            }
            Self::K3(x) => {
                enc.append(&(3 as u8).to_aper(UNCONSTRAINED)?)?;
                enc.append(&x.to_aper(UNCONSTRAINED)?)?;
            }
            Self::K4(x) => {
                enc.append(&(4 as u8).to_aper(UNCONSTRAINED)?)?;
                enc.append(&x.to_aper(UNCONSTRAINED)?)?;
            }
            Self::K5(x) => {
                enc.append(&(5 as u8).to_aper(UNCONSTRAINED)?)?;
                enc.append(&x.to_aper(UNCONSTRAINED)?)?;
            }
            Self::_Extended => return Err(EncodeError::NotImplemented),
        }
        Ok(enc)
    }
}

// GnbSetId
#[derive(Clone)]
pub struct GnbSetId(pub BitString);

impl APerElement for GnbSetId {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(22),
            max: Some(22),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        Ok(Self(BitString::from_aper(decoder, Self::CONSTRAINTS)?))
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&(self.0).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// GtpTeid
#[derive(Clone)]
pub struct GtpTeid(pub Vec<u8>);

impl APerElement for GtpTeid {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(4),
            max: Some(4),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        Ok(Self(Vec::<u8>::from_aper(decoder, Self::CONSTRAINTS)?))
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&(self.0).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// GtptlAs
#[derive(Clone)]
pub struct GtptlAs(pub Vec<GtptlaItem>);

impl APerElement for GtptlAs {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(1),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        Ok(Self(Vec::<GtptlaItem>::from_aper(
            decoder,
            Self::CONSTRAINTS,
        )?))
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&(self.0).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// GtptlaItem
#[derive(Clone)]
pub struct GtptlaItem {
    pub gtp_transport_layer_address: TransportLayerAddress,
}

impl APerElement for GtptlaItem {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(1),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let _optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let gtp_transport_layer_address = TransportLayerAddress::from_aper(decoder, UNCONSTRAINED)?;

        Ok(Self {
            gtp_transport_layer_address,
        })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(1);
        optionals.set(0, false);

        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&self.gtp_transport_layer_address.to_aper(UNCONSTRAINED)?)?;

        Ok(enc)
    }
}

// GtpTunnel
#[derive(Clone)]
pub struct GtpTunnel {
    pub transport_layer_address: TransportLayerAddress,
    pub gtp_teid: GtpTeid,
}

impl APerElement for GtpTunnel {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(1),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let _extended = bool::from_aper(decoder, UNCONSTRAINED)?;
        let _optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let transport_layer_address = TransportLayerAddress::from_aper(decoder, UNCONSTRAINED)?;
        let gtp_teid = GtpTeid::from_aper(decoder, UNCONSTRAINED)?;

        Ok(Self {
            transport_layer_address,
            gtp_teid,
        })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(1);
        optionals.set(0, false);

        enc.append(&false.to_aper(UNCONSTRAINED)?)?;
        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&self.transport_layer_address.to_aper(UNCONSTRAINED)?)?;
        enc.append(&self.gtp_teid.to_aper(UNCONSTRAINED)?)?;

        Ok(enc)
    }
}

// HandoverPreparationInformation
#[derive(Clone)]
pub struct HandoverPreparationInformation(pub Vec<u8>);

impl APerElement for HandoverPreparationInformation {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        Ok(Self(Vec::<u8>::from_aper(decoder, Self::CONSTRAINTS)?))
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&(self.0).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// HardwareLoadIndicator
#[derive(Clone)]
pub struct HardwareLoadIndicator {
    pub dl_hardware_load_indicator: u8,
    pub ul_hardware_load_indicator: u8,
}

impl APerElement for HardwareLoadIndicator {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(1),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let _extended = bool::from_aper(decoder, UNCONSTRAINED)?;
        let _optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let dl_hardware_load_indicator = u8::from_aper(decoder, UNCONSTRAINED)?;
        let ul_hardware_load_indicator = u8::from_aper(decoder, UNCONSTRAINED)?;

        Ok(Self {
            dl_hardware_load_indicator,
            ul_hardware_load_indicator,
        })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(1);
        optionals.set(0, false);

        enc.append(&false.to_aper(UNCONSTRAINED)?)?;
        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&self.dl_hardware_load_indicator.to_aper(UNCONSTRAINED)?)?;
        enc.append(&self.ul_hardware_load_indicator.to_aper(UNCONSTRAINED)?)?;

        Ok(enc)
    }
}

// HsnaSlotConfigList
#[derive(Clone)]
pub struct HsnaSlotConfigList(pub Vec<HsnaSlotConfigItem>);

impl APerElement for HsnaSlotConfigList {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(1),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        Ok(Self(Vec::<HsnaSlotConfigItem>::from_aper(
            decoder,
            Self::CONSTRAINTS,
        )?))
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&(self.0).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// HsnaSlotConfigItem
#[derive(Clone)]
pub struct HsnaSlotConfigItem {
    pub hsna_downlink: Option<HsnaDownlink>,
    pub hsna_uplink: Option<HsnaUplink>,
    pub hsna_flexible: Option<HsnaFlexible>,
}

impl APerElement for HsnaSlotConfigItem {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(4),
            max: Some(4),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let hsna_downlink = if optionals.is_set(0) {
            Some(HsnaDownlink::from_aper(decoder, UNCONSTRAINED)?)
        } else {
            None
        };
        let hsna_uplink = if optionals.is_set(0) {
            Some(HsnaUplink::from_aper(decoder, UNCONSTRAINED)?)
        } else {
            None
        };
        let hsna_flexible = if optionals.is_set(0) {
            Some(HsnaFlexible::from_aper(decoder, UNCONSTRAINED)?)
        } else {
            None
        };

        Ok(Self {
            hsna_downlink,
            hsna_uplink,
            hsna_flexible,
        })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(4);
        optionals.set(0, self.hsna_downlink.is_some());
        optionals.set(1, self.hsna_uplink.is_some());
        optionals.set(2, self.hsna_flexible.is_some());
        optionals.set(3, false);

        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        if let Some(x) = &self.hsna_downlink {
            enc.append(&x.to_aper(UNCONSTRAINED)?)?;
        }
        if let Some(x) = &self.hsna_uplink {
            enc.append(&x.to_aper(UNCONSTRAINED)?)?;
        }
        if let Some(x) = &self.hsna_flexible {
            enc.append(&x.to_aper(UNCONSTRAINED)?)?;
        }

        Ok(enc)
    }
}

// HsnaDownlink
#[derive(Clone, Copy, FromPrimitive)]
pub enum HsnaDownlink {
    Hard,
    Soft,
    Notavailable,
}

impl APerElement for HsnaDownlink {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let v = u8::from_aper(decoder, Self::CONSTRAINTS)?;
        FromPrimitive::from_u8(v).ok_or(DecodeError::MalformedInt)
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&(*self as u8).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// HsnaFlexible
#[derive(Clone, Copy, FromPrimitive)]
pub enum HsnaFlexible {
    Hard,
    Soft,
    Notavailable,
}

impl APerElement for HsnaFlexible {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let v = u8::from_aper(decoder, Self::CONSTRAINTS)?;
        FromPrimitive::from_u8(v).ok_or(DecodeError::MalformedInt)
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&(*self as u8).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// HsnaUplink
#[derive(Clone, Copy, FromPrimitive)]
pub enum HsnaUplink {
    Hard,
    Soft,
    Notavailable,
}

impl APerElement for HsnaUplink {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let v = u8::from_aper(decoder, Self::CONSTRAINTS)?;
        FromPrimitive::from_u8(v).ok_or(DecodeError::MalformedInt)
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&(*self as u8).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// HsnaTransmissionPeriodicity
#[derive(Clone, Copy, FromPrimitive)]
pub enum HsnaTransmissionPeriodicity {
    Ms0p5,
    Ms0p625,
    Ms1,
    Ms1p25,
    Ms2,
    Ms2p5,
    Ms5,
    Ms10,
    Ms20,
    Ms40,
    Ms80,
    Ms160,
    _Extended,
}

impl APerElement for HsnaTransmissionPeriodicity {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        if bool::from_aper(decoder, Self::CONSTRAINTS)? {
            return Ok(HsnaTransmissionPeriodicity::_Extended);
        }
        let v = u8::from_aper(decoder, Self::CONSTRAINTS)?;
        FromPrimitive::from_u8(v).ok_or(DecodeError::MalformedInt)
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&false.to_aper(UNCONSTRAINED)?)?;
        enc.append(&(*self as u8).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// IabBarred
#[derive(Clone, Copy, FromPrimitive)]
pub enum IabBarred {
    Barred,
    NotBarred,
    _Extended,
}

impl APerElement for IabBarred {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        if bool::from_aper(decoder, Self::CONSTRAINTS)? {
            return Ok(IabBarred::_Extended);
        }
        let v = u8::from_aper(decoder, Self::CONSTRAINTS)?;
        FromPrimitive::from_u8(v).ok_or(DecodeError::MalformedInt)
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&false.to_aper(UNCONSTRAINED)?)?;
        enc.append(&(*self as u8).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// IabInfoIabDonorCu
#[derive(Clone)]
pub struct IabInfoIabDonorCu {
    pub iab_stc_info: Option<IabStcInfo>,
}

impl APerElement for IabInfoIabDonorCu {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(2),
            max: Some(2),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let iab_stc_info = if optionals.is_set(0) {
            Some(IabStcInfo::from_aper(decoder, UNCONSTRAINED)?)
        } else {
            None
        };

        Ok(Self { iab_stc_info })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(2);
        optionals.set(0, self.iab_stc_info.is_some());
        optionals.set(1, false);

        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        if let Some(x) = &self.iab_stc_info {
            enc.append(&x.to_aper(UNCONSTRAINED)?)?;
        }

        Ok(enc)
    }
}

// IabInfoIabDu
#[derive(Clone)]
pub struct IabInfoIabDu {
    pub multiplexing_info: Option<MultiplexingInfo>,
    pub iab_stc_info: Option<IabStcInfo>,
}

impl APerElement for IabInfoIabDu {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(3),
            max: Some(3),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let multiplexing_info = if optionals.is_set(0) {
            Some(MultiplexingInfo::from_aper(decoder, UNCONSTRAINED)?)
        } else {
            None
        };
        let iab_stc_info = if optionals.is_set(0) {
            Some(IabStcInfo::from_aper(decoder, UNCONSTRAINED)?)
        } else {
            None
        };

        Ok(Self {
            multiplexing_info,
            iab_stc_info,
        })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(3);
        optionals.set(0, self.multiplexing_info.is_some());
        optionals.set(1, self.iab_stc_info.is_some());
        optionals.set(2, false);

        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        if let Some(x) = &self.multiplexing_info {
            enc.append(&x.to_aper(UNCONSTRAINED)?)?;
        }
        if let Some(x) = &self.iab_stc_info {
            enc.append(&x.to_aper(UNCONSTRAINED)?)?;
        }

        Ok(enc)
    }
}

// IabMtCellList
#[derive(Clone)]
pub struct IabMtCellList(pub Vec<IabMtCellListItem>);

impl APerElement for IabMtCellList {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(1),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        Ok(Self(Vec::<IabMtCellListItem>::from_aper(
            decoder,
            Self::CONSTRAINTS,
        )?))
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&(self.0).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// IabMtCellListItem
#[derive(Clone)]
pub struct IabMtCellListItem {
    pub nr_cell_identity: NrCellIdentity,
    pub du_rx_mt_rx: DuRxMtRx,
    pub du_tx_mt_tx: DuTxMtTx,
    pub du_rx_mt_tx: DuRxMtTx,
    pub du_tx_mt_rx: DuTxMtRx,
}

impl APerElement for IabMtCellListItem {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(1),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let _optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let nr_cell_identity = NrCellIdentity::from_aper(decoder, UNCONSTRAINED)?;
        let du_rx_mt_rx = DuRxMtRx::from_aper(decoder, UNCONSTRAINED)?;
        let du_tx_mt_tx = DuTxMtTx::from_aper(decoder, UNCONSTRAINED)?;
        let du_rx_mt_tx = DuRxMtTx::from_aper(decoder, UNCONSTRAINED)?;
        let du_tx_mt_rx = DuTxMtRx::from_aper(decoder, UNCONSTRAINED)?;

        Ok(Self {
            nr_cell_identity,
            du_rx_mt_rx,
            du_tx_mt_tx,
            du_rx_mt_tx,
            du_tx_mt_rx,
        })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(1);
        optionals.set(0, false);

        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&self.nr_cell_identity.to_aper(UNCONSTRAINED)?)?;
        enc.append(&self.du_rx_mt_rx.to_aper(UNCONSTRAINED)?)?;
        enc.append(&self.du_tx_mt_tx.to_aper(UNCONSTRAINED)?)?;
        enc.append(&self.du_rx_mt_tx.to_aper(UNCONSTRAINED)?)?;
        enc.append(&self.du_tx_mt_rx.to_aper(UNCONSTRAINED)?)?;

        Ok(enc)
    }
}

// IabStcInfo
#[derive(Clone)]
pub struct IabStcInfo {
    pub iab_stc_info_list: IabStcInfoList,
}

impl APerElement for IabStcInfo {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(1),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let _optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let iab_stc_info_list = IabStcInfoList::from_aper(decoder, UNCONSTRAINED)?;

        Ok(Self { iab_stc_info_list })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(1);
        optionals.set(0, false);

        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&self.iab_stc_info_list.to_aper(UNCONSTRAINED)?)?;

        Ok(enc)
    }
}

// IabStcInfoList
#[derive(Clone)]
pub struct IabStcInfoList(pub Vec<IabStcInfoItem>);

impl APerElement for IabStcInfoList {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(1),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        Ok(Self(Vec::<IabStcInfoItem>::from_aper(
            decoder,
            Self::CONSTRAINTS,
        )?))
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&(self.0).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// IabStcInfoItem
#[derive(Clone)]
pub struct IabStcInfoItem {
    pub ssb_freq_info: SsbFreqInfo,
    pub ssb_subcarrier_spacing: SsbSubcarrierSpacing,
    pub ssb_transmission_periodicity: SsbTransmissionPeriodicity,
    pub ssb_transmission_timing_offset: SsbTransmissionTimingOffset,
    pub ssb_transmission_bitmap: SsbTransmissionBitmap,
}

impl APerElement for IabStcInfoItem {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(1),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let _optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let ssb_freq_info = SsbFreqInfo::from_aper(decoder, UNCONSTRAINED)?;
        let ssb_subcarrier_spacing = SsbSubcarrierSpacing::from_aper(decoder, UNCONSTRAINED)?;
        let ssb_transmission_periodicity =
            SsbTransmissionPeriodicity::from_aper(decoder, UNCONSTRAINED)?;
        let ssb_transmission_timing_offset =
            SsbTransmissionTimingOffset::from_aper(decoder, UNCONSTRAINED)?;
        let ssb_transmission_bitmap = SsbTransmissionBitmap::from_aper(decoder, UNCONSTRAINED)?;

        Ok(Self {
            ssb_freq_info,
            ssb_subcarrier_spacing,
            ssb_transmission_periodicity,
            ssb_transmission_timing_offset,
            ssb_transmission_bitmap,
        })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(1);
        optionals.set(0, false);

        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&self.ssb_freq_info.to_aper(UNCONSTRAINED)?)?;
        enc.append(&self.ssb_subcarrier_spacing.to_aper(UNCONSTRAINED)?)?;
        enc.append(&self.ssb_transmission_periodicity.to_aper(UNCONSTRAINED)?)?;
        enc.append(&self.ssb_transmission_timing_offset.to_aper(UNCONSTRAINED)?)?;
        enc.append(&self.ssb_transmission_bitmap.to_aper(UNCONSTRAINED)?)?;

        Ok(enc)
    }
}

// IabAllocatedTnlAddressItem
#[derive(Clone)]
pub struct IabAllocatedTnlAddressItem {
    pub iabtnl_address: IabtnlAddress,
    pub iabtnl_address_usage: Option<IabtnlAddressUsage>,
}

impl APerElement for IabAllocatedTnlAddressItem {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(2),
            max: Some(2),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let iabtnl_address = IabtnlAddress::from_aper(decoder, UNCONSTRAINED)?;
        let iabtnl_address_usage = if optionals.is_set(0) {
            Some(IabtnlAddressUsage::from_aper(decoder, UNCONSTRAINED)?)
        } else {
            None
        };

        Ok(Self {
            iabtnl_address,
            iabtnl_address_usage,
        })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(2);
        optionals.set(0, self.iabtnl_address_usage.is_some());
        optionals.set(1, false);

        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&self.iabtnl_address.to_aper(UNCONSTRAINED)?)?;
        if let Some(x) = &self.iabtnl_address_usage {
            enc.append(&x.to_aper(UNCONSTRAINED)?)?;
        }

        Ok(enc)
    }
}

// IabDuCellResourceConfigurationModeInfo
#[derive(Clone)]
pub enum IabDuCellResourceConfigurationModeInfo {
    Fdd(IabDuCellResourceConfigurationFddInfo),
    Tdd(IabDuCellResourceConfigurationTddInfo),
    _Extended,
}

impl APerElement for IabDuCellResourceConfigurationModeInfo {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        match u8::from_aper(decoder, UNCONSTRAINED)? {
            0 => Ok(Self::Fdd(IabDuCellResourceConfigurationFddInfo::from_aper(
                decoder,
                UNCONSTRAINED,
            )?)),
            1 => Ok(Self::Tdd(IabDuCellResourceConfigurationTddInfo::from_aper(
                decoder,
                UNCONSTRAINED,
            )?)),
            2 => Err(DecodeError::NotImplemented),
            _ => Err(DecodeError::InvalidChoice),
        }
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        match self {
            Self::Fdd(x) => {
                enc.append(&(0 as u8).to_aper(UNCONSTRAINED)?)?;
                enc.append(&x.to_aper(UNCONSTRAINED)?)?;
            }
            Self::Tdd(x) => {
                enc.append(&(1 as u8).to_aper(UNCONSTRAINED)?)?;
                enc.append(&x.to_aper(UNCONSTRAINED)?)?;
            }
            Self::_Extended => return Err(EncodeError::NotImplemented),
        }
        Ok(enc)
    }
}

// IabDuCellResourceConfigurationFddInfo
#[derive(Clone)]
pub struct IabDuCellResourceConfigurationFddInfo {
    pub gnb_du_cell_resource_configuration_fdd_ul: GnbDuCellResourceConfiguration,
    pub gnb_du_cell_resource_configuration_fdd_dl: GnbDuCellResourceConfiguration,
}

impl APerElement for IabDuCellResourceConfigurationFddInfo {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(1),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let _extended = bool::from_aper(decoder, UNCONSTRAINED)?;
        let _optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let gnb_du_cell_resource_configuration_fdd_ul =
            GnbDuCellResourceConfiguration::from_aper(decoder, UNCONSTRAINED)?;
        let gnb_du_cell_resource_configuration_fdd_dl =
            GnbDuCellResourceConfiguration::from_aper(decoder, UNCONSTRAINED)?;

        Ok(Self {
            gnb_du_cell_resource_configuration_fdd_ul,
            gnb_du_cell_resource_configuration_fdd_dl,
        })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(1);
        optionals.set(0, false);

        enc.append(&false.to_aper(UNCONSTRAINED)?)?;
        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(
            &self
                .gnb_du_cell_resource_configuration_fdd_ul
                .to_aper(UNCONSTRAINED)?,
        )?;
        enc.append(
            &self
                .gnb_du_cell_resource_configuration_fdd_dl
                .to_aper(UNCONSTRAINED)?,
        )?;

        Ok(enc)
    }
}

// IabDuCellResourceConfigurationTddInfo
#[derive(Clone)]
pub struct IabDuCellResourceConfigurationTddInfo {
    pub gnb_du_cell_resourc_configuration_tdd: GnbDuCellResourceConfiguration,
}

impl APerElement for IabDuCellResourceConfigurationTddInfo {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(1),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let _extended = bool::from_aper(decoder, UNCONSTRAINED)?;
        let _optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let gnb_du_cell_resourc_configuration_tdd =
            GnbDuCellResourceConfiguration::from_aper(decoder, UNCONSTRAINED)?;

        Ok(Self {
            gnb_du_cell_resourc_configuration_tdd,
        })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(1);
        optionals.set(0, false);

        enc.append(&false.to_aper(UNCONSTRAINED)?)?;
        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(
            &self
                .gnb_du_cell_resourc_configuration_tdd
                .to_aper(UNCONSTRAINED)?,
        )?;

        Ok(enc)
    }
}

// IabiPv6RequestType
#[derive(Clone)]
pub enum IabiPv6RequestType {
    IPv6Address(IabtnlAddressesRequested),
    IPv6Prefix(IabtnlAddressesRequested),
    _Extended,
}

impl APerElement for IabiPv6RequestType {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        match u8::from_aper(decoder, UNCONSTRAINED)? {
            0 => Ok(Self::IPv6Address(IabtnlAddressesRequested::from_aper(
                decoder,
                UNCONSTRAINED,
            )?)),
            1 => Ok(Self::IPv6Prefix(IabtnlAddressesRequested::from_aper(
                decoder,
                UNCONSTRAINED,
            )?)),
            2 => Err(DecodeError::NotImplemented),
            _ => Err(DecodeError::InvalidChoice),
        }
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        match self {
            Self::IPv6Address(x) => {
                enc.append(&(0 as u8).to_aper(UNCONSTRAINED)?)?;
                enc.append(&x.to_aper(UNCONSTRAINED)?)?;
            }
            Self::IPv6Prefix(x) => {
                enc.append(&(1 as u8).to_aper(UNCONSTRAINED)?)?;
                enc.append(&x.to_aper(UNCONSTRAINED)?)?;
            }
            Self::_Extended => return Err(EncodeError::NotImplemented),
        }
        Ok(enc)
    }
}

// IabtnlAddress
#[derive(Clone)]
pub enum IabtnlAddress {
    IPv4Address(BitString),
    IPv6Address(BitString),
    IPv6Prefix(BitString),
    _Extended,
}

impl APerElement for IabtnlAddress {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        match u8::from_aper(decoder, UNCONSTRAINED)? {
            0 => Ok(Self::IPv4Address(BitString::from_aper(
                decoder,
                Constraints {
                    value: None,
                    size: Some(Constraint::new(Some(32), Some(32))),
                },
            )?)),
            1 => Ok(Self::IPv6Address(BitString::from_aper(
                decoder,
                Constraints {
                    value: None,
                    size: Some(Constraint::new(Some(128), Some(128))),
                },
            )?)),
            2 => Ok(Self::IPv6Prefix(BitString::from_aper(
                decoder,
                Constraints {
                    value: None,
                    size: Some(Constraint::new(Some(64), Some(64))),
                },
            )?)),
            3 => Err(DecodeError::NotImplemented),
            _ => Err(DecodeError::InvalidChoice),
        }
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        match self {
            Self::IPv4Address(x) => {
                enc.append(&(0 as u8).to_aper(UNCONSTRAINED)?)?;
                enc.append(&x.to_aper(Constraints {
                    value: None,
                    size: Some(Constraint::new(Some(32), Some(32))),
                })?)?;
            }
            Self::IPv6Address(x) => {
                enc.append(&(1 as u8).to_aper(UNCONSTRAINED)?)?;
                enc.append(&x.to_aper(Constraints {
                    value: None,
                    size: Some(Constraint::new(Some(128), Some(128))),
                })?)?;
            }
            Self::IPv6Prefix(x) => {
                enc.append(&(2 as u8).to_aper(UNCONSTRAINED)?)?;
                enc.append(&x.to_aper(Constraints {
                    value: None,
                    size: Some(Constraint::new(Some(64), Some(64))),
                })?)?;
            }
            Self::_Extended => return Err(EncodeError::NotImplemented),
        }
        Ok(enc)
    }
}

// IabtnlAddressesRequested
#[derive(Clone)]
pub struct IabtnlAddressesRequested {
    pub tnl_addresses_or_prefixes_requested_all_traffic: Option<u8>,
    pub tnl_addresses_or_prefixes_requested_f1_c: Option<u8>,
    pub tnl_addresses_or_prefixes_requested_f1_u: Option<u8>,
    pub tnl_addresses_or_prefixes_requested_no_nf1: Option<u8>,
}

impl APerElement for IabtnlAddressesRequested {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(5),
            max: Some(5),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let tnl_addresses_or_prefixes_requested_all_traffic = if optionals.is_set(0) {
            Some(u8::from_aper(decoder, UNCONSTRAINED)?)
        } else {
            None
        };
        let tnl_addresses_or_prefixes_requested_f1_c = if optionals.is_set(0) {
            Some(u8::from_aper(decoder, UNCONSTRAINED)?)
        } else {
            None
        };
        let tnl_addresses_or_prefixes_requested_f1_u = if optionals.is_set(0) {
            Some(u8::from_aper(decoder, UNCONSTRAINED)?)
        } else {
            None
        };
        let tnl_addresses_or_prefixes_requested_no_nf1 = if optionals.is_set(0) {
            Some(u8::from_aper(decoder, UNCONSTRAINED)?)
        } else {
            None
        };

        Ok(Self {
            tnl_addresses_or_prefixes_requested_all_traffic,
            tnl_addresses_or_prefixes_requested_f1_c,
            tnl_addresses_or_prefixes_requested_f1_u,
            tnl_addresses_or_prefixes_requested_no_nf1,
        })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(5);
        optionals.set(
            0,
            self.tnl_addresses_or_prefixes_requested_all_traffic
                .is_some(),
        );
        optionals.set(1, self.tnl_addresses_or_prefixes_requested_f1_c.is_some());
        optionals.set(2, self.tnl_addresses_or_prefixes_requested_f1_u.is_some());
        optionals.set(3, self.tnl_addresses_or_prefixes_requested_no_nf1.is_some());
        optionals.set(4, false);

        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        if let Some(x) = &self.tnl_addresses_or_prefixes_requested_all_traffic {
            enc.append(&x.to_aper(UNCONSTRAINED)?)?;
        }
        if let Some(x) = &self.tnl_addresses_or_prefixes_requested_f1_c {
            enc.append(&x.to_aper(UNCONSTRAINED)?)?;
        }
        if let Some(x) = &self.tnl_addresses_or_prefixes_requested_f1_u {
            enc.append(&x.to_aper(UNCONSTRAINED)?)?;
        }
        if let Some(x) = &self.tnl_addresses_or_prefixes_requested_no_nf1 {
            enc.append(&x.to_aper(UNCONSTRAINED)?)?;
        }

        Ok(enc)
    }
}

// IabTnlAddressesToRemoveItem
#[derive(Clone)]
pub struct IabTnlAddressesToRemoveItem {
    pub iabtnl_address: IabtnlAddress,
}

impl APerElement for IabTnlAddressesToRemoveItem {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(1),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let _optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let iabtnl_address = IabtnlAddress::from_aper(decoder, UNCONSTRAINED)?;

        Ok(Self { iabtnl_address })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(1);
        optionals.set(0, false);

        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&self.iabtnl_address.to_aper(UNCONSTRAINED)?)?;

        Ok(enc)
    }
}

// IabtnlAddressUsage
#[derive(Clone, Copy, FromPrimitive)]
pub enum IabtnlAddressUsage {
    F1C,
    F1U,
    NonF1,
    _Extended,
}

impl APerElement for IabtnlAddressUsage {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        if bool::from_aper(decoder, Self::CONSTRAINTS)? {
            return Ok(IabtnlAddressUsage::_Extended);
        }
        let v = u8::from_aper(decoder, Self::CONSTRAINTS)?;
        FromPrimitive::from_u8(v).ok_or(DecodeError::MalformedInt)
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&false.to_aper(UNCONSTRAINED)?)?;
        enc.append(&(*self as u8).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// IaBv4AddressesRequested
#[derive(Clone)]
pub struct IaBv4AddressesRequested {
    pub ia_bv_4_addresses_requested: IabtnlAddressesRequested,
}

impl APerElement for IaBv4AddressesRequested {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(1),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let _optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let ia_bv_4_addresses_requested =
            IabtnlAddressesRequested::from_aper(decoder, UNCONSTRAINED)?;

        Ok(Self {
            ia_bv_4_addresses_requested,
        })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(1);
        optionals.set(0, false);

        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&self.ia_bv_4_addresses_requested.to_aper(UNCONSTRAINED)?)?;

        Ok(enc)
    }
}

// ImplicitFormat
#[derive(Clone)]
pub struct ImplicitFormat {
    pub duf_slotformat_index: DufSlotformatIndex,
}

impl APerElement for ImplicitFormat {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(1),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let _optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let duf_slotformat_index = DufSlotformatIndex::from_aper(decoder, UNCONSTRAINED)?;

        Ok(Self {
            duf_slotformat_index,
        })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(1);
        optionals.set(0, false);

        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&self.duf_slotformat_index.to_aper(UNCONSTRAINED)?)?;

        Ok(enc)
    }
}

// IgnorePrachConfiguration
#[derive(Clone, Copy, FromPrimitive)]
pub enum IgnorePrachConfiguration {
    True,
    _Extended,
}

impl APerElement for IgnorePrachConfiguration {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        if bool::from_aper(decoder, Self::CONSTRAINTS)? {
            return Ok(IgnorePrachConfiguration::_Extended);
        }
        let v = u8::from_aper(decoder, Self::CONSTRAINTS)?;
        FromPrimitive::from_u8(v).ok_or(DecodeError::MalformedInt)
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&false.to_aper(UNCONSTRAINED)?)?;
        enc.append(&(*self as u8).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// IgnoreResourceCoordinationContainer
#[derive(Clone, Copy, FromPrimitive)]
pub enum IgnoreResourceCoordinationContainer {
    Yes,
    _Extended,
}

impl APerElement for IgnoreResourceCoordinationContainer {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        if bool::from_aper(decoder, Self::CONSTRAINTS)? {
            return Ok(IgnoreResourceCoordinationContainer::_Extended);
        }
        let v = u8::from_aper(decoder, Self::CONSTRAINTS)?;
        FromPrimitive::from_u8(v).ok_or(DecodeError::MalformedInt)
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&false.to_aper(UNCONSTRAINED)?)?;
        enc.append(&(*self as u8).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// InactivityMonitoringRequest
#[derive(Clone, Copy, FromPrimitive)]
pub enum InactivityMonitoringRequest {
    True,
    _Extended,
}

impl APerElement for InactivityMonitoringRequest {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        if bool::from_aper(decoder, Self::CONSTRAINTS)? {
            return Ok(InactivityMonitoringRequest::_Extended);
        }
        let v = u8::from_aper(decoder, Self::CONSTRAINTS)?;
        FromPrimitive::from_u8(v).ok_or(DecodeError::MalformedInt)
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&false.to_aper(UNCONSTRAINED)?)?;
        enc.append(&(*self as u8).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// InactivityMonitoringResponse
#[derive(Clone, Copy, FromPrimitive)]
pub enum InactivityMonitoringResponse {
    NotSupported,
    _Extended,
}

impl APerElement for InactivityMonitoringResponse {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        if bool::from_aper(decoder, Self::CONSTRAINTS)? {
            return Ok(InactivityMonitoringResponse::_Extended);
        }
        let v = u8::from_aper(decoder, Self::CONSTRAINTS)?;
        FromPrimitive::from_u8(v).ok_or(DecodeError::MalformedInt)
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&false.to_aper(UNCONSTRAINED)?)?;
        enc.append(&(*self as u8).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// InterfacesToTrace
#[derive(Clone)]
pub struct InterfacesToTrace(pub BitString);

impl APerElement for InterfacesToTrace {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(8),
            max: Some(8),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        Ok(Self(BitString::from_aper(decoder, Self::CONSTRAINTS)?))
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&(self.0).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// IntendedTddDlUlConfig
#[derive(Clone)]
pub struct IntendedTddDlUlConfig {
    pub nrscs: Nrscs1,
    pub nrcp: Nrcp,
    pub nrdlul_tx_periodicity: NrdlulTxPeriodicity,
    pub slot_configuration_list: SlotConfigurationList,
}

impl APerElement for IntendedTddDlUlConfig {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(1),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let _optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let nrscs = Nrscs1::from_aper(decoder, UNCONSTRAINED)?;
        let nrcp = Nrcp::from_aper(decoder, UNCONSTRAINED)?;
        let nrdlul_tx_periodicity = NrdlulTxPeriodicity::from_aper(decoder, UNCONSTRAINED)?;
        let slot_configuration_list = SlotConfigurationList::from_aper(decoder, UNCONSTRAINED)?;

        Ok(Self {
            nrscs,
            nrcp,
            nrdlul_tx_periodicity,
            slot_configuration_list,
        })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(1);
        optionals.set(0, false);

        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&self.nrscs.to_aper(UNCONSTRAINED)?)?;
        enc.append(&self.nrcp.to_aper(UNCONSTRAINED)?)?;
        enc.append(&self.nrdlul_tx_periodicity.to_aper(UNCONSTRAINED)?)?;
        enc.append(&self.slot_configuration_list.to_aper(UNCONSTRAINED)?)?;

        Ok(enc)
    }
}

// IpHeaderInformation
#[derive(Clone)]
pub struct IpHeaderInformation {
    pub destination_iabtnl_address: IabtnlAddress,
    pub ds_information_list: Option<DsInformationList>,
    pub i_pv_6_flow_label: Option<BitString>,
}

impl APerElement for IpHeaderInformation {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(3),
            max: Some(3),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let _extended = bool::from_aper(decoder, UNCONSTRAINED)?;
        let optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let destination_iabtnl_address = IabtnlAddress::from_aper(decoder, UNCONSTRAINED)?;
        let ds_information_list = if optionals.is_set(0) {
            Some(DsInformationList::from_aper(decoder, UNCONSTRAINED)?)
        } else {
            None
        };
        let i_pv_6_flow_label = if optionals.is_set(0) {
            Some(BitString::from_aper(
                decoder,
                Constraints {
                    value: None,
                    size: Some(Constraint::new(Some(20), Some(20))),
                },
            )?)
        } else {
            None
        };

        Ok(Self {
            destination_iabtnl_address,
            ds_information_list,
            i_pv_6_flow_label,
        })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(3);
        optionals.set(0, self.ds_information_list.is_some());
        optionals.set(1, self.i_pv_6_flow_label.is_some());
        optionals.set(2, false);

        enc.append(&false.to_aper(UNCONSTRAINED)?)?;
        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&self.destination_iabtnl_address.to_aper(UNCONSTRAINED)?)?;
        if let Some(x) = &self.ds_information_list {
            enc.append(&x.to_aper(UNCONSTRAINED)?)?;
        }
        if let Some(x) = &self.i_pv_6_flow_label {
            enc.append(&x.to_aper(UNCONSTRAINED)?)?;
        }

        Ok(enc)
    }
}

// IPtolayer2TrafficMappingInfo
#[derive(Clone)]
pub struct IPtolayer2TrafficMappingInfo {
    pub i_ptolayer_2_traffic_mapping_info_to_add: Option<IPtolayer2TrafficMappingInfoList>,
    pub i_ptolayer_2_traffic_mapping_info_to_remove: Option<MappingInformationtoRemove>,
}

impl APerElement for IPtolayer2TrafficMappingInfo {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(3),
            max: Some(3),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let _extended = bool::from_aper(decoder, UNCONSTRAINED)?;
        let optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let i_ptolayer_2_traffic_mapping_info_to_add = if optionals.is_set(0) {
            Some(IPtolayer2TrafficMappingInfoList::from_aper(
                decoder,
                UNCONSTRAINED,
            )?)
        } else {
            None
        };
        let i_ptolayer_2_traffic_mapping_info_to_remove = if optionals.is_set(0) {
            Some(MappingInformationtoRemove::from_aper(
                decoder,
                UNCONSTRAINED,
            )?)
        } else {
            None
        };

        Ok(Self {
            i_ptolayer_2_traffic_mapping_info_to_add,
            i_ptolayer_2_traffic_mapping_info_to_remove,
        })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(3);
        optionals.set(0, self.i_ptolayer_2_traffic_mapping_info_to_add.is_some());
        optionals.set(
            1,
            self.i_ptolayer_2_traffic_mapping_info_to_remove.is_some(),
        );
        optionals.set(2, false);

        enc.append(&false.to_aper(UNCONSTRAINED)?)?;
        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        if let Some(x) = &self.i_ptolayer_2_traffic_mapping_info_to_add {
            enc.append(&x.to_aper(UNCONSTRAINED)?)?;
        }
        if let Some(x) = &self.i_ptolayer_2_traffic_mapping_info_to_remove {
            enc.append(&x.to_aper(UNCONSTRAINED)?)?;
        }

        Ok(enc)
    }
}

// IPtolayer2TrafficMappingInfoList
#[derive(Clone)]
pub struct IPtolayer2TrafficMappingInfoList(pub Vec<IPtolayer2TrafficMappingInfoItem>);

impl APerElement for IPtolayer2TrafficMappingInfoList {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(1),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        Ok(Self(Vec::<IPtolayer2TrafficMappingInfoItem>::from_aper(
            decoder,
            Self::CONSTRAINTS,
        )?))
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&(self.0).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// IPtolayer2TrafficMappingInfoItem
#[derive(Clone)]
pub struct IPtolayer2TrafficMappingInfoItem {
    pub mapping_information_index: MappingInformationIndex,
    pub ip_header_information: IpHeaderInformation,
    pub bh_info: BhInfo,
}

impl APerElement for IPtolayer2TrafficMappingInfoItem {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(1),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let _extended = bool::from_aper(decoder, UNCONSTRAINED)?;
        let _optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let mapping_information_index = MappingInformationIndex::from_aper(decoder, UNCONSTRAINED)?;
        let ip_header_information = IpHeaderInformation::from_aper(decoder, UNCONSTRAINED)?;
        let bh_info = BhInfo::from_aper(decoder, UNCONSTRAINED)?;

        Ok(Self {
            mapping_information_index,
            ip_header_information,
            bh_info,
        })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(1);
        optionals.set(0, false);

        enc.append(&false.to_aper(UNCONSTRAINED)?)?;
        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&self.mapping_information_index.to_aper(UNCONSTRAINED)?)?;
        enc.append(&self.ip_header_information.to_aper(UNCONSTRAINED)?)?;
        enc.append(&self.bh_info.to_aper(UNCONSTRAINED)?)?;

        Ok(enc)
    }
}

// L139Info
#[derive(Clone)]
pub struct L139Info {
    pub msg_1scs: Msg1scs,
    pub root_sequence_index: Option<u8>,
}

impl APerElement for L139Info {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(2),
            max: Some(2),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let _extended = bool::from_aper(decoder, UNCONSTRAINED)?;
        let optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let msg_1scs = Msg1scs::from_aper(decoder, UNCONSTRAINED)?;
        let root_sequence_index = if optionals.is_set(0) {
            Some(u8::from_aper(decoder, UNCONSTRAINED)?)
        } else {
            None
        };

        Ok(Self {
            msg_1scs,
            root_sequence_index,
        })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(2);
        optionals.set(0, self.root_sequence_index.is_some());
        optionals.set(1, false);

        enc.append(&false.to_aper(UNCONSTRAINED)?)?;
        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&self.msg_1scs.to_aper(UNCONSTRAINED)?)?;
        if let Some(x) = &self.root_sequence_index {
            enc.append(&x.to_aper(UNCONSTRAINED)?)?;
        }

        Ok(enc)
    }
}

// L839Info
#[derive(Clone)]
pub struct L839Info {
    pub root_sequence_index: u16,
    pub restricted_set_config: RestrictedSetConfig,
}

impl APerElement for L839Info {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(1),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let _extended = bool::from_aper(decoder, UNCONSTRAINED)?;
        let _optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let root_sequence_index = u16::from_aper(decoder, UNCONSTRAINED)?;
        let restricted_set_config = RestrictedSetConfig::from_aper(decoder, UNCONSTRAINED)?;

        Ok(Self {
            root_sequence_index,
            restricted_set_config,
        })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(1);
        optionals.set(0, false);

        enc.append(&false.to_aper(UNCONSTRAINED)?)?;
        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&self.root_sequence_index.to_aper(UNCONSTRAINED)?)?;
        enc.append(&self.restricted_set_config.to_aper(UNCONSTRAINED)?)?;

        Ok(enc)
    }
}

// Lcid
#[derive(Clone)]
pub struct Lcid(pub u8);

impl APerElement for Lcid {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(32),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        Ok(Self(u8::from_aper(decoder, Self::CONSTRAINTS)?))
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&(self.0).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// LcsToGcsTranslationAoA
#[derive(Clone)]
pub struct LcsToGcsTranslationAoA {
    pub alpha: u16,
    pub beta: u16,
    pub gamma: u16,
}

impl APerElement for LcsToGcsTranslationAoA {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(1),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let _extended = bool::from_aper(decoder, UNCONSTRAINED)?;
        let _optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let alpha = u16::from_aper(decoder, UNCONSTRAINED)?;
        let beta = u16::from_aper(decoder, UNCONSTRAINED)?;
        let gamma = u16::from_aper(decoder, UNCONSTRAINED)?;

        Ok(Self { alpha, beta, gamma })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(1);
        optionals.set(0, false);

        enc.append(&false.to_aper(UNCONSTRAINED)?)?;
        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&self.alpha.to_aper(UNCONSTRAINED)?)?;
        enc.append(&self.beta.to_aper(UNCONSTRAINED)?)?;
        enc.append(&self.gamma.to_aper(UNCONSTRAINED)?)?;

        Ok(enc)
    }
}

// LcStoGcsTranslationList
#[derive(Clone)]
pub struct LcStoGcsTranslationList(pub Vec<LcStoGcsTranslation>);

impl APerElement for LcStoGcsTranslationList {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(1),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        Ok(Self(Vec::<LcStoGcsTranslation>::from_aper(
            decoder,
            Self::CONSTRAINTS,
        )?))
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&(self.0).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// LcStoGcsTranslation
#[derive(Clone)]
pub struct LcStoGcsTranslation {
    pub alpha: u16,
    pub alpha_fine: Option<u8>,
    pub beta: u16,
    pub beta_fine: Option<u8>,
    pub gamma: u16,
    pub gamma_fine: Option<u8>,
}

impl APerElement for LcStoGcsTranslation {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(4),
            max: Some(4),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let alpha = u16::from_aper(decoder, UNCONSTRAINED)?;
        let alpha_fine = if optionals.is_set(0) {
            Some(u8::from_aper(decoder, UNCONSTRAINED)?)
        } else {
            None
        };
        let beta = u16::from_aper(decoder, UNCONSTRAINED)?;
        let beta_fine = if optionals.is_set(0) {
            Some(u8::from_aper(decoder, UNCONSTRAINED)?)
        } else {
            None
        };
        let gamma = u16::from_aper(decoder, UNCONSTRAINED)?;
        let gamma_fine = if optionals.is_set(0) {
            Some(u8::from_aper(decoder, UNCONSTRAINED)?)
        } else {
            None
        };

        Ok(Self {
            alpha,
            alpha_fine,
            beta,
            beta_fine,
            gamma,
            gamma_fine,
        })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(4);
        optionals.set(0, self.alpha_fine.is_some());
        optionals.set(1, self.beta_fine.is_some());
        optionals.set(2, self.gamma_fine.is_some());
        optionals.set(3, false);

        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&self.alpha.to_aper(UNCONSTRAINED)?)?;
        if let Some(x) = &self.alpha_fine {
            enc.append(&x.to_aper(UNCONSTRAINED)?)?;
        }
        enc.append(&self.beta.to_aper(UNCONSTRAINED)?)?;
        if let Some(x) = &self.beta_fine {
            enc.append(&x.to_aper(UNCONSTRAINED)?)?;
        }
        enc.append(&self.gamma.to_aper(UNCONSTRAINED)?)?;
        if let Some(x) = &self.gamma_fine {
            enc.append(&x.to_aper(UNCONSTRAINED)?)?;
        }

        Ok(enc)
    }
}

// LmfMeasurementId
#[derive(Clone)]
pub struct LmfMeasurementId(pub u16);

impl APerElement for LmfMeasurementId {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(65536),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        Ok(Self(u16::from_aper(decoder, Self::CONSTRAINTS)?))
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&(self.0).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// LmfUeMeasurementId
#[derive(Clone)]
pub struct LmfUeMeasurementId(pub u8);

impl APerElement for LmfUeMeasurementId {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(256),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        Ok(Self(u8::from_aper(decoder, Self::CONSTRAINTS)?))
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&(self.0).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// LocationUncertainty
#[derive(Clone)]
pub struct LocationUncertainty {
    pub horizontal_uncertainty: u8,
    pub horizontal_confidence: u8,
    pub vertical_uncertainty: u8,
    pub vertical_confidence: u8,
}

impl APerElement for LocationUncertainty {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(1),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let _optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let horizontal_uncertainty = u8::from_aper(decoder, UNCONSTRAINED)?;
        let horizontal_confidence = u8::from_aper(decoder, UNCONSTRAINED)?;
        let vertical_uncertainty = u8::from_aper(decoder, UNCONSTRAINED)?;
        let vertical_confidence = u8::from_aper(decoder, UNCONSTRAINED)?;

        Ok(Self {
            horizontal_uncertainty,
            horizontal_confidence,
            vertical_uncertainty,
            vertical_confidence,
        })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(1);
        optionals.set(0, false);

        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&self.horizontal_uncertainty.to_aper(UNCONSTRAINED)?)?;
        enc.append(&self.horizontal_confidence.to_aper(UNCONSTRAINED)?)?;
        enc.append(&self.vertical_uncertainty.to_aper(UNCONSTRAINED)?)?;
        enc.append(&self.vertical_confidence.to_aper(UNCONSTRAINED)?)?;

        Ok(enc)
    }
}

// LongDrxCycleLength
#[derive(Clone, Copy, FromPrimitive)]
pub enum LongDrxCycleLength {
    Ms10,
    Ms20,
    Ms32,
    Ms40,
    Ms60,
    Ms64,
    Ms70,
    Ms80,
    Ms128,
    Ms160,
    Ms256,
    Ms320,
    Ms512,
    Ms640,
    Ms1024,
    Ms1280,
    Ms2048,
    Ms2560,
    Ms5120,
    Ms10240,
    _Extended,
}

impl APerElement for LongDrxCycleLength {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        if bool::from_aper(decoder, Self::CONSTRAINTS)? {
            return Ok(LongDrxCycleLength::_Extended);
        }
        let v = u8::from_aper(decoder, Self::CONSTRAINTS)?;
        FromPrimitive::from_u8(v).ok_or(DecodeError::MalformedInt)
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&false.to_aper(UNCONSTRAINED)?)?;
        enc.append(&(*self as u8).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// LowerLayerPresenceStatusChange
#[derive(Clone, Copy, FromPrimitive)]
pub enum LowerLayerPresenceStatusChange {
    SuspendLowerLayers,
    ResumeLowerLayers,
    _Extended,
}

impl APerElement for LowerLayerPresenceStatusChange {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        if bool::from_aper(decoder, Self::CONSTRAINTS)? {
            return Ok(LowerLayerPresenceStatusChange::_Extended);
        }
        let v = u8::from_aper(decoder, Self::CONSTRAINTS)?;
        FromPrimitive::from_u8(v).ok_or(DecodeError::MalformedInt)
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&false.to_aper(UNCONSTRAINED)?)?;
        enc.append(&(*self as u8).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// LteueSidelinkAggregateMaximumBitrate
#[derive(Clone)]
pub struct LteueSidelinkAggregateMaximumBitrate {
    pub uelte_sidelink_aggregate_maximum_bitrate: BitRate,
}

impl APerElement for LteueSidelinkAggregateMaximumBitrate {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(1),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let _optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let uelte_sidelink_aggregate_maximum_bitrate = BitRate::from_aper(decoder, UNCONSTRAINED)?;

        Ok(Self {
            uelte_sidelink_aggregate_maximum_bitrate,
        })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(1);
        optionals.set(0, false);

        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(
            &self
                .uelte_sidelink_aggregate_maximum_bitrate
                .to_aper(UNCONSTRAINED)?,
        )?;

        Ok(enc)
    }
}

// Ltev2xServicesAuthorized
#[derive(Clone)]
pub struct Ltev2xServicesAuthorized {
    pub vehicle_ue: Option<VehicleUe>,
    pub pedestrian_ue: Option<PedestrianUe>,
}

impl APerElement for Ltev2xServicesAuthorized {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(3),
            max: Some(3),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let vehicle_ue = if optionals.is_set(0) {
            Some(VehicleUe::from_aper(decoder, UNCONSTRAINED)?)
        } else {
            None
        };
        let pedestrian_ue = if optionals.is_set(0) {
            Some(PedestrianUe::from_aper(decoder, UNCONSTRAINED)?)
        } else {
            None
        };

        Ok(Self {
            vehicle_ue,
            pedestrian_ue,
        })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(3);
        optionals.set(0, self.vehicle_ue.is_some());
        optionals.set(1, self.pedestrian_ue.is_some());
        optionals.set(2, false);

        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        if let Some(x) = &self.vehicle_ue {
            enc.append(&x.to_aper(UNCONSTRAINED)?)?;
        }
        if let Some(x) = &self.pedestrian_ue {
            enc.append(&x.to_aper(UNCONSTRAINED)?)?;
        }

        Ok(enc)
    }
}

// MappingInformationIndex
#[derive(Clone)]
pub struct MappingInformationIndex(pub BitString);

impl APerElement for MappingInformationIndex {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(26),
            max: Some(26),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        Ok(Self(BitString::from_aper(decoder, Self::CONSTRAINTS)?))
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&(self.0).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// MappingInformationtoRemove
#[derive(Clone)]
pub struct MappingInformationtoRemove(pub Vec<MappingInformationIndex>);

impl APerElement for MappingInformationtoRemove {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(1),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        Ok(Self(Vec::<MappingInformationIndex>::from_aper(
            decoder,
            Self::CONSTRAINTS,
        )?))
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&(self.0).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// MaskedImeisv
#[derive(Clone)]
pub struct MaskedImeisv(pub BitString);

impl APerElement for MaskedImeisv {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(64),
            max: Some(64),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        Ok(Self(BitString::from_aper(decoder, Self::CONSTRAINTS)?))
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&(self.0).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// MaxDataBurstVolume
#[derive(Clone)]
pub struct MaxDataBurstVolume(pub u16);

impl APerElement for MaxDataBurstVolume {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(0),
            max: Some(4095),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        Ok(Self(u16::from_aper(decoder, Self::CONSTRAINTS)?))
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&(self.0).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// MaxPacketLossRate
#[derive(Clone)]
pub struct MaxPacketLossRate(pub u16);

impl APerElement for MaxPacketLossRate {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(0),
            max: Some(0),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        Ok(Self(u16::from_aper(decoder, Self::CONSTRAINTS)?))
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&(self.0).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// MibMessage
#[derive(Clone)]
pub struct MibMessage(pub Vec<u8>);

impl APerElement for MibMessage {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        Ok(Self(Vec::<u8>::from_aper(decoder, Self::CONSTRAINTS)?))
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&(self.0).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// MeasConfig
#[derive(Clone)]
pub struct MeasConfig(pub Vec<u8>);

impl APerElement for MeasConfig {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        Ok(Self(Vec::<u8>::from_aper(decoder, Self::CONSTRAINTS)?))
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&(self.0).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// MeasGapConfig
#[derive(Clone)]
pub struct MeasGapConfig(pub Vec<u8>);

impl APerElement for MeasGapConfig {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        Ok(Self(Vec::<u8>::from_aper(decoder, Self::CONSTRAINTS)?))
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&(self.0).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// MeasGapSharingConfig
#[derive(Clone)]
pub struct MeasGapSharingConfig(pub Vec<u8>);

impl APerElement for MeasGapSharingConfig {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        Ok(Self(Vec::<u8>::from_aper(decoder, Self::CONSTRAINTS)?))
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&(self.0).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// MeasurementBeamInfoRequest
#[derive(Clone, Copy, FromPrimitive)]
pub enum MeasurementBeamInfoRequest {
    True,
    _Extended,
}

impl APerElement for MeasurementBeamInfoRequest {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        if bool::from_aper(decoder, Self::CONSTRAINTS)? {
            return Ok(MeasurementBeamInfoRequest::_Extended);
        }
        let v = u8::from_aper(decoder, Self::CONSTRAINTS)?;
        FromPrimitive::from_u8(v).ok_or(DecodeError::MalformedInt)
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&false.to_aper(UNCONSTRAINED)?)?;
        enc.append(&(*self as u8).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// MeasurementBeamInfo
#[derive(Clone)]
pub struct MeasurementBeamInfo {
    pub prs_resource_id: Option<PrsResourceId>,
    pub prs_resource_set_id: Option<PrsResourceSetId>,
    pub ssb_index: Option<SsbIndex>,
}

impl APerElement for MeasurementBeamInfo {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(4),
            max: Some(4),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let prs_resource_id = if optionals.is_set(0) {
            Some(PrsResourceId::from_aper(decoder, UNCONSTRAINED)?)
        } else {
            None
        };
        let prs_resource_set_id = if optionals.is_set(0) {
            Some(PrsResourceSetId::from_aper(decoder, UNCONSTRAINED)?)
        } else {
            None
        };
        let ssb_index = if optionals.is_set(0) {
            Some(SsbIndex::from_aper(decoder, UNCONSTRAINED)?)
        } else {
            None
        };

        Ok(Self {
            prs_resource_id,
            prs_resource_set_id,
            ssb_index,
        })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(4);
        optionals.set(0, self.prs_resource_id.is_some());
        optionals.set(1, self.prs_resource_set_id.is_some());
        optionals.set(2, self.ssb_index.is_some());
        optionals.set(3, false);

        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        if let Some(x) = &self.prs_resource_id {
            enc.append(&x.to_aper(UNCONSTRAINED)?)?;
        }
        if let Some(x) = &self.prs_resource_set_id {
            enc.append(&x.to_aper(UNCONSTRAINED)?)?;
        }
        if let Some(x) = &self.ssb_index {
            enc.append(&x.to_aper(UNCONSTRAINED)?)?;
        }

        Ok(enc)
    }
}

// MeasurementTimingConfiguration
#[derive(Clone)]
pub struct MeasurementTimingConfiguration(pub Vec<u8>);

impl APerElement for MeasurementTimingConfiguration {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        Ok(Self(Vec::<u8>::from_aper(decoder, Self::CONSTRAINTS)?))
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&(self.0).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// MessageIdentifier
#[derive(Clone)]
pub struct MessageIdentifier(pub BitString);

impl APerElement for MessageIdentifier {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(16),
            max: Some(16),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        Ok(Self(BitString::from_aper(decoder, Self::CONSTRAINTS)?))
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&(self.0).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// MultiplexingInfo
#[derive(Clone)]
pub struct MultiplexingInfo {
    pub iab_mt_cell_list: IabMtCellList,
}

impl APerElement for MultiplexingInfo {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(1),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let _optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let iab_mt_cell_list = IabMtCellList::from_aper(decoder, UNCONSTRAINED)?;

        Ok(Self { iab_mt_cell_list })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(1);
        optionals.set(0, false);

        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&self.iab_mt_cell_list.to_aper(UNCONSTRAINED)?)?;

        Ok(enc)
    }
}

// M2Configuration
#[derive(Clone, Copy, FromPrimitive)]
pub enum M2Configuration {
    True,
    _Extended,
}

impl APerElement for M2Configuration {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        if bool::from_aper(decoder, Self::CONSTRAINTS)? {
            return Ok(M2Configuration::_Extended);
        }
        let v = u8::from_aper(decoder, Self::CONSTRAINTS)?;
        FromPrimitive::from_u8(v).ok_or(DecodeError::MalformedInt)
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&false.to_aper(UNCONSTRAINED)?)?;
        enc.append(&(*self as u8).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// M5Configuration
#[derive(Clone)]
pub struct M5Configuration {
    pub m5period: M5period,
    pub m5_links_to_log: M5LinksToLog,
}

impl APerElement for M5Configuration {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(1),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let _extended = bool::from_aper(decoder, UNCONSTRAINED)?;
        let _optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let m5period = M5period::from_aper(decoder, UNCONSTRAINED)?;
        let m5_links_to_log = M5LinksToLog::from_aper(decoder, UNCONSTRAINED)?;

        Ok(Self {
            m5period,
            m5_links_to_log,
        })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(1);
        optionals.set(0, false);

        enc.append(&false.to_aper(UNCONSTRAINED)?)?;
        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&self.m5period.to_aper(UNCONSTRAINED)?)?;
        enc.append(&self.m5_links_to_log.to_aper(UNCONSTRAINED)?)?;

        Ok(enc)
    }
}

// M5period
#[derive(Clone, Copy, FromPrimitive)]
pub enum M5period {
    Ms1024,
    Ms2048,
    Ms5120,
    Ms10240,
    Min1,
    _Extended,
}

impl APerElement for M5period {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        if bool::from_aper(decoder, Self::CONSTRAINTS)? {
            return Ok(M5period::_Extended);
        }
        let v = u8::from_aper(decoder, Self::CONSTRAINTS)?;
        FromPrimitive::from_u8(v).ok_or(DecodeError::MalformedInt)
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&false.to_aper(UNCONSTRAINED)?)?;
        enc.append(&(*self as u8).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// M5LinksToLog
#[derive(Clone, Copy, FromPrimitive)]
pub enum M5LinksToLog {
    Uplink,
    Downlink,
    BothUplinkAndDownlink,
    _Extended,
}

impl APerElement for M5LinksToLog {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        if bool::from_aper(decoder, Self::CONSTRAINTS)? {
            return Ok(M5LinksToLog::_Extended);
        }
        let v = u8::from_aper(decoder, Self::CONSTRAINTS)?;
        FromPrimitive::from_u8(v).ok_or(DecodeError::MalformedInt)
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&false.to_aper(UNCONSTRAINED)?)?;
        enc.append(&(*self as u8).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// M6Configuration
#[derive(Clone)]
pub struct M6Configuration {
    pub m6report_interval: M6reportInterval,
    pub m6_links_to_log: M6LinksToLog,
}

impl APerElement for M6Configuration {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(1),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let _extended = bool::from_aper(decoder, UNCONSTRAINED)?;
        let _optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let m6report_interval = M6reportInterval::from_aper(decoder, UNCONSTRAINED)?;
        let m6_links_to_log = M6LinksToLog::from_aper(decoder, UNCONSTRAINED)?;

        Ok(Self {
            m6report_interval,
            m6_links_to_log,
        })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(1);
        optionals.set(0, false);

        enc.append(&false.to_aper(UNCONSTRAINED)?)?;
        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&self.m6report_interval.to_aper(UNCONSTRAINED)?)?;
        enc.append(&self.m6_links_to_log.to_aper(UNCONSTRAINED)?)?;

        Ok(enc)
    }
}

// M6reportInterval
#[derive(Clone, Copy, FromPrimitive)]
pub enum M6reportInterval {
    Ms120,
    Ms240,
    Ms640,
    Ms1024,
    Ms2048,
    Ms5120,
    Ms10240,
    Ms20480,
    Ms40960,
    Min1,
    Min6,
    Min12,
    Min30,
    _Extended,
}

impl APerElement for M6reportInterval {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        if bool::from_aper(decoder, Self::CONSTRAINTS)? {
            return Ok(M6reportInterval::_Extended);
        }
        let v = u8::from_aper(decoder, Self::CONSTRAINTS)?;
        FromPrimitive::from_u8(v).ok_or(DecodeError::MalformedInt)
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&false.to_aper(UNCONSTRAINED)?)?;
        enc.append(&(*self as u8).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// M6LinksToLog
#[derive(Clone, Copy, FromPrimitive)]
pub enum M6LinksToLog {
    Uplink,
    Downlink,
    BothUplinkAndDownlink,
    _Extended,
}

impl APerElement for M6LinksToLog {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        if bool::from_aper(decoder, Self::CONSTRAINTS)? {
            return Ok(M6LinksToLog::_Extended);
        }
        let v = u8::from_aper(decoder, Self::CONSTRAINTS)?;
        FromPrimitive::from_u8(v).ok_or(DecodeError::MalformedInt)
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&false.to_aper(UNCONSTRAINED)?)?;
        enc.append(&(*self as u8).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// M7Configuration
#[derive(Clone)]
pub struct M7Configuration {
    pub m7period: M7period,
    pub m7_links_to_log: M7LinksToLog,
}

impl APerElement for M7Configuration {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(1),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let _extended = bool::from_aper(decoder, UNCONSTRAINED)?;
        let _optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let m7period = M7period::from_aper(decoder, UNCONSTRAINED)?;
        let m7_links_to_log = M7LinksToLog::from_aper(decoder, UNCONSTRAINED)?;

        Ok(Self {
            m7period,
            m7_links_to_log,
        })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(1);
        optionals.set(0, false);

        enc.append(&false.to_aper(UNCONSTRAINED)?)?;
        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&self.m7period.to_aper(UNCONSTRAINED)?)?;
        enc.append(&self.m7_links_to_log.to_aper(UNCONSTRAINED)?)?;

        Ok(enc)
    }
}

// M7period
#[derive(Clone)]
pub struct M7period(pub u8);

impl APerElement for M7period {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(60),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        Ok(Self(u8::from_aper(decoder, Self::CONSTRAINTS)?))
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&(self.0).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// M7LinksToLog
#[derive(Clone, Copy, FromPrimitive)]
pub enum M7LinksToLog {
    Downlink,
    _Extended,
}

impl APerElement for M7LinksToLog {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        if bool::from_aper(decoder, Self::CONSTRAINTS)? {
            return Ok(M7LinksToLog::_Extended);
        }
        let v = u8::from_aper(decoder, Self::CONSTRAINTS)?;
        FromPrimitive::from_u8(v).ok_or(DecodeError::MalformedInt)
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&false.to_aper(UNCONSTRAINED)?)?;
        enc.append(&(*self as u8).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// MdtActivation
#[derive(Clone, Copy, FromPrimitive)]
pub enum MdtActivation {
    ImmediateMdtOnly,
    ImmediateMdtAndTrace,
    _Extended,
}

impl APerElement for MdtActivation {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        if bool::from_aper(decoder, Self::CONSTRAINTS)? {
            return Ok(MdtActivation::_Extended);
        }
        let v = u8::from_aper(decoder, Self::CONSTRAINTS)?;
        FromPrimitive::from_u8(v).ok_or(DecodeError::MalformedInt)
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&false.to_aper(UNCONSTRAINED)?)?;
        enc.append(&(*self as u8).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// MdtConfiguration
#[derive(Clone)]
pub struct MdtConfiguration {
    pub mdt_activation: MdtActivation,
    pub measurements_to_activate: MeasurementsToActivate,
    pub m2_configuration: Option<M2Configuration>,
    pub m5_configuration: Option<M5Configuration>,
    pub m6_configuration: Option<M6Configuration>,
    pub m7_configuration: Option<M7Configuration>,
}

impl APerElement for MdtConfiguration {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(5),
            max: Some(5),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let _extended = bool::from_aper(decoder, UNCONSTRAINED)?;
        let optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let mdt_activation = MdtActivation::from_aper(decoder, UNCONSTRAINED)?;
        let measurements_to_activate = MeasurementsToActivate::from_aper(decoder, UNCONSTRAINED)?;
        let m2_configuration = if optionals.is_set(0) {
            Some(M2Configuration::from_aper(decoder, UNCONSTRAINED)?)
        } else {
            None
        };
        let m5_configuration = if optionals.is_set(0) {
            Some(M5Configuration::from_aper(decoder, UNCONSTRAINED)?)
        } else {
            None
        };
        let m6_configuration = if optionals.is_set(0) {
            Some(M6Configuration::from_aper(decoder, UNCONSTRAINED)?)
        } else {
            None
        };
        let m7_configuration = if optionals.is_set(0) {
            Some(M7Configuration::from_aper(decoder, UNCONSTRAINED)?)
        } else {
            None
        };

        Ok(Self {
            mdt_activation,
            measurements_to_activate,
            m2_configuration,
            m5_configuration,
            m6_configuration,
            m7_configuration,
        })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(5);
        optionals.set(0, self.m2_configuration.is_some());
        optionals.set(1, self.m5_configuration.is_some());
        optionals.set(2, self.m6_configuration.is_some());
        optionals.set(3, self.m7_configuration.is_some());
        optionals.set(4, false);

        enc.append(&false.to_aper(UNCONSTRAINED)?)?;
        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&self.mdt_activation.to_aper(UNCONSTRAINED)?)?;
        enc.append(&self.measurements_to_activate.to_aper(UNCONSTRAINED)?)?;
        if let Some(x) = &self.m2_configuration {
            enc.append(&x.to_aper(UNCONSTRAINED)?)?;
        }
        if let Some(x) = &self.m5_configuration {
            enc.append(&x.to_aper(UNCONSTRAINED)?)?;
        }
        if let Some(x) = &self.m6_configuration {
            enc.append(&x.to_aper(UNCONSTRAINED)?)?;
        }
        if let Some(x) = &self.m7_configuration {
            enc.append(&x.to_aper(UNCONSTRAINED)?)?;
        }

        Ok(enc)
    }
}

// MdtPlmnList
#[derive(Clone)]
pub struct MdtPlmnList(pub Vec<PlmnIdentity>);

impl APerElement for MdtPlmnList {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(1),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        Ok(Self(Vec::<PlmnIdentity>::from_aper(
            decoder,
            Self::CONSTRAINTS,
        )?))
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&(self.0).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// MeasuredResultsValue
#[derive(Clone)]
pub enum MeasuredResultsValue {
    UlAngleOfArrival(UlAoA),
    UlSrsRsrp(UlSrsRsrp),
    UlRtoa(UlRtoaMeasurement),
    GnbRxTxTimeDiff(GnbRxTxTimeDiff),
    _Extended,
}

impl APerElement for MeasuredResultsValue {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        match u8::from_aper(decoder, UNCONSTRAINED)? {
            0 => Ok(Self::UlAngleOfArrival(UlAoA::from_aper(
                decoder,
                UNCONSTRAINED,
            )?)),
            1 => Ok(Self::UlSrsRsrp(UlSrsRsrp::from_aper(
                decoder,
                UNCONSTRAINED,
            )?)),
            2 => Ok(Self::UlRtoa(UlRtoaMeasurement::from_aper(
                decoder,
                UNCONSTRAINED,
            )?)),
            3 => Ok(Self::GnbRxTxTimeDiff(GnbRxTxTimeDiff::from_aper(
                decoder,
                UNCONSTRAINED,
            )?)),
            4 => Err(DecodeError::NotImplemented),
            _ => Err(DecodeError::InvalidChoice),
        }
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        match self {
            Self::UlAngleOfArrival(x) => {
                enc.append(&(0 as u8).to_aper(UNCONSTRAINED)?)?;
                enc.append(&x.to_aper(UNCONSTRAINED)?)?;
            }
            Self::UlSrsRsrp(x) => {
                enc.append(&(1 as u8).to_aper(UNCONSTRAINED)?)?;
                enc.append(&x.to_aper(UNCONSTRAINED)?)?;
            }
            Self::UlRtoa(x) => {
                enc.append(&(2 as u8).to_aper(UNCONSTRAINED)?)?;
                enc.append(&x.to_aper(UNCONSTRAINED)?)?;
            }
            Self::GnbRxTxTimeDiff(x) => {
                enc.append(&(3 as u8).to_aper(UNCONSTRAINED)?)?;
                enc.append(&x.to_aper(UNCONSTRAINED)?)?;
            }
            Self::_Extended => return Err(EncodeError::NotImplemented),
        }
        Ok(enc)
    }
}

// MeasurementsToActivate
#[derive(Clone)]
pub struct MeasurementsToActivate(pub BitString);

impl APerElement for MeasurementsToActivate {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(8),
            max: Some(8),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        Ok(Self(BitString::from_aper(decoder, Self::CONSTRAINTS)?))
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&(self.0).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// NeedforGap
#[derive(Clone, Copy, FromPrimitive)]
pub enum NeedforGap {
    True,
    _Extended,
}

impl APerElement for NeedforGap {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        if bool::from_aper(decoder, Self::CONSTRAINTS)? {
            return Ok(NeedforGap::_Extended);
        }
        let v = u8::from_aper(decoder, Self::CONSTRAINTS)?;
        FromPrimitive::from_u8(v).ok_or(DecodeError::MalformedInt)
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&false.to_aper(UNCONSTRAINED)?)?;
        enc.append(&(*self as u8).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// NeighbourCellInformationItem
#[derive(Clone)]
pub struct NeighbourCellInformationItem {
    pub nrcgi: Nrcgi,
    pub intended_tdd_dl_ul_config: Option<IntendedTddDlUlConfig>,
}

impl APerElement for NeighbourCellInformationItem {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(2),
            max: Some(2),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let nrcgi = Nrcgi::from_aper(decoder, UNCONSTRAINED)?;
        let intended_tdd_dl_ul_config = if optionals.is_set(0) {
            Some(IntendedTddDlUlConfig::from_aper(decoder, UNCONSTRAINED)?)
        } else {
            None
        };

        Ok(Self {
            nrcgi,
            intended_tdd_dl_ul_config,
        })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(2);
        optionals.set(0, self.intended_tdd_dl_ul_config.is_some());
        optionals.set(1, false);

        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&self.nrcgi.to_aper(UNCONSTRAINED)?)?;
        if let Some(x) = &self.intended_tdd_dl_ul_config {
            enc.append(&x.to_aper(UNCONSTRAINED)?)?;
        }

        Ok(enc)
    }
}

// NgranAllocationAndRetentionPriority
#[derive(Clone)]
pub struct NgranAllocationAndRetentionPriority {
    pub priority_level: PriorityLevel,
    pub pre_emption_capability: PreEmptionCapability,
    pub pre_emption_vulnerability: PreEmptionVulnerability,
}

impl APerElement for NgranAllocationAndRetentionPriority {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(1),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let _optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let priority_level = PriorityLevel::from_aper(decoder, UNCONSTRAINED)?;
        let pre_emption_capability = PreEmptionCapability::from_aper(decoder, UNCONSTRAINED)?;
        let pre_emption_vulnerability = PreEmptionVulnerability::from_aper(decoder, UNCONSTRAINED)?;

        Ok(Self {
            priority_level,
            pre_emption_capability,
            pre_emption_vulnerability,
        })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(1);
        optionals.set(0, false);

        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&self.priority_level.to_aper(UNCONSTRAINED)?)?;
        enc.append(&self.pre_emption_capability.to_aper(UNCONSTRAINED)?)?;
        enc.append(&self.pre_emption_vulnerability.to_aper(UNCONSTRAINED)?)?;

        Ok(enc)
    }
}

// NgranHighAccuracyAccessPointPosition
#[derive(Clone)]
pub struct NgranHighAccuracyAccessPointPosition {
    pub latitude: u64,
    pub longitude: u64,
    pub altitude: u32,
    pub uncertainty_semi_major: u8,
    pub uncertainty_semi_minor: u8,
    pub orientation_of_major_axis: u8,
    pub horizontal_confidence: u8,
    pub uncertainty_altitude: u8,
    pub vertical_confidence: u8,
}

impl APerElement for NgranHighAccuracyAccessPointPosition {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(1),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let _optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let latitude = u64::from_aper(decoder, UNCONSTRAINED)?;
        let longitude = u64::from_aper(decoder, UNCONSTRAINED)?;
        let altitude = u32::from_aper(decoder, UNCONSTRAINED)?;
        let uncertainty_semi_major = u8::from_aper(decoder, UNCONSTRAINED)?;
        let uncertainty_semi_minor = u8::from_aper(decoder, UNCONSTRAINED)?;
        let orientation_of_major_axis = u8::from_aper(decoder, UNCONSTRAINED)?;
        let horizontal_confidence = u8::from_aper(decoder, UNCONSTRAINED)?;
        let uncertainty_altitude = u8::from_aper(decoder, UNCONSTRAINED)?;
        let vertical_confidence = u8::from_aper(decoder, UNCONSTRAINED)?;

        Ok(Self {
            latitude,
            longitude,
            altitude,
            uncertainty_semi_major,
            uncertainty_semi_minor,
            orientation_of_major_axis,
            horizontal_confidence,
            uncertainty_altitude,
            vertical_confidence,
        })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(1);
        optionals.set(0, false);

        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&self.latitude.to_aper(UNCONSTRAINED)?)?;
        enc.append(&self.longitude.to_aper(UNCONSTRAINED)?)?;
        enc.append(&self.altitude.to_aper(UNCONSTRAINED)?)?;
        enc.append(&self.uncertainty_semi_major.to_aper(UNCONSTRAINED)?)?;
        enc.append(&self.uncertainty_semi_minor.to_aper(UNCONSTRAINED)?)?;
        enc.append(&self.orientation_of_major_axis.to_aper(UNCONSTRAINED)?)?;
        enc.append(&self.horizontal_confidence.to_aper(UNCONSTRAINED)?)?;
        enc.append(&self.uncertainty_altitude.to_aper(UNCONSTRAINED)?)?;
        enc.append(&self.vertical_confidence.to_aper(UNCONSTRAINED)?)?;

        Ok(enc)
    }
}

// Nid
#[derive(Clone)]
pub struct Nid(pub BitString);

impl APerElement for Nid {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(44),
            max: Some(44),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        Ok(Self(BitString::from_aper(decoder, Self::CONSTRAINTS)?))
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&(self.0).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// NrCgiListForRestartItem
#[derive(Clone)]
pub struct NrCgiListForRestartItem {
    pub nrcgi: Nrcgi,
}

impl APerElement for NrCgiListForRestartItem {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(1),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let _extended = bool::from_aper(decoder, UNCONSTRAINED)?;
        let _optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let nrcgi = Nrcgi::from_aper(decoder, UNCONSTRAINED)?;

        Ok(Self { nrcgi })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(1);
        optionals.set(0, false);

        enc.append(&false.to_aper(UNCONSTRAINED)?)?;
        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&self.nrcgi.to_aper(UNCONSTRAINED)?)?;

        Ok(enc)
    }
}

// NrPrsBeamInformation
#[derive(Clone)]
pub struct NrPrsBeamInformation {
    pub nr_prs_beam_information_list: NrPrsBeamInformationList,
    pub lc_sto_gcs_translation_list: Option<LcStoGcsTranslationList>,
}

impl APerElement for NrPrsBeamInformation {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(2),
            max: Some(2),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let nr_prs_beam_information_list =
            NrPrsBeamInformationList::from_aper(decoder, UNCONSTRAINED)?;
        let lc_sto_gcs_translation_list = if optionals.is_set(0) {
            Some(LcStoGcsTranslationList::from_aper(decoder, UNCONSTRAINED)?)
        } else {
            None
        };

        Ok(Self {
            nr_prs_beam_information_list,
            lc_sto_gcs_translation_list,
        })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(2);
        optionals.set(0, self.lc_sto_gcs_translation_list.is_some());
        optionals.set(1, false);

        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&self.nr_prs_beam_information_list.to_aper(UNCONSTRAINED)?)?;
        if let Some(x) = &self.lc_sto_gcs_translation_list {
            enc.append(&x.to_aper(UNCONSTRAINED)?)?;
        }

        Ok(enc)
    }
}

// NrPrsBeamInformationList
#[derive(Clone)]
pub struct NrPrsBeamInformationList(pub Vec<NrPrsBeamInformationItem>);

impl APerElement for NrPrsBeamInformationList {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(1),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        Ok(Self(Vec::<NrPrsBeamInformationItem>::from_aper(
            decoder,
            Self::CONSTRAINTS,
        )?))
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&(self.0).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// NrPrsBeamInformationItem
#[derive(Clone)]
pub struct NrPrsBeamInformationItem {
    pub prs_resource_set_id: PrsResourceSetId,
    pub prs_angle_list: PrsAngleList,
}

impl APerElement for NrPrsBeamInformationItem {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(1),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let _optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let prs_resource_set_id = PrsResourceSetId::from_aper(decoder, UNCONSTRAINED)?;
        let prs_angle_list = PrsAngleList::from_aper(decoder, UNCONSTRAINED)?;

        Ok(Self {
            prs_resource_set_id,
            prs_angle_list,
        })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(1);
        optionals.set(0, false);

        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&self.prs_resource_set_id.to_aper(UNCONSTRAINED)?)?;
        enc.append(&self.prs_angle_list.to_aper(UNCONSTRAINED)?)?;

        Ok(enc)
    }
}

// NonDynamic5qiDescriptor
#[derive(Clone)]
pub struct NonDynamic5qiDescriptor {
    pub five_qi: u8,
    pub qos_priority_level: Option<u8>,
    pub averaging_window: Option<AveragingWindow>,
    pub max_data_burst_volume: Option<MaxDataBurstVolume>,
}

impl APerElement for NonDynamic5qiDescriptor {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(4),
            max: Some(4),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let five_qi = u8::from_aper(decoder, UNCONSTRAINED)?;
        let qos_priority_level = if optionals.is_set(0) {
            Some(u8::from_aper(decoder, UNCONSTRAINED)?)
        } else {
            None
        };
        let averaging_window = if optionals.is_set(0) {
            Some(AveragingWindow::from_aper(decoder, UNCONSTRAINED)?)
        } else {
            None
        };
        let max_data_burst_volume = if optionals.is_set(0) {
            Some(MaxDataBurstVolume::from_aper(decoder, UNCONSTRAINED)?)
        } else {
            None
        };

        Ok(Self {
            five_qi,
            qos_priority_level,
            averaging_window,
            max_data_burst_volume,
        })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(4);
        optionals.set(0, self.qos_priority_level.is_some());
        optionals.set(1, self.averaging_window.is_some());
        optionals.set(2, self.max_data_burst_volume.is_some());
        optionals.set(3, false);

        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&self.five_qi.to_aper(UNCONSTRAINED)?)?;
        if let Some(x) = &self.qos_priority_level {
            enc.append(&x.to_aper(UNCONSTRAINED)?)?;
        }
        if let Some(x) = &self.averaging_window {
            enc.append(&x.to_aper(UNCONSTRAINED)?)?;
        }
        if let Some(x) = &self.max_data_burst_volume {
            enc.append(&x.to_aper(UNCONSTRAINED)?)?;
        }

        Ok(enc)
    }
}

// NonDynamicPqiDescriptor
#[derive(Clone)]
pub struct NonDynamicPqiDescriptor {
    pub five_qi: u8,
    pub qos_priority_level: Option<u8>,
    pub averaging_window: Option<AveragingWindow>,
    pub max_data_burst_volume: Option<MaxDataBurstVolume>,
}

impl APerElement for NonDynamicPqiDescriptor {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(4),
            max: Some(4),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let five_qi = u8::from_aper(decoder, UNCONSTRAINED)?;
        let qos_priority_level = if optionals.is_set(0) {
            Some(u8::from_aper(decoder, UNCONSTRAINED)?)
        } else {
            None
        };
        let averaging_window = if optionals.is_set(0) {
            Some(AveragingWindow::from_aper(decoder, UNCONSTRAINED)?)
        } else {
            None
        };
        let max_data_burst_volume = if optionals.is_set(0) {
            Some(MaxDataBurstVolume::from_aper(decoder, UNCONSTRAINED)?)
        } else {
            None
        };

        Ok(Self {
            five_qi,
            qos_priority_level,
            averaging_window,
            max_data_burst_volume,
        })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(4);
        optionals.set(0, self.qos_priority_level.is_some());
        optionals.set(1, self.averaging_window.is_some());
        optionals.set(2, self.max_data_burst_volume.is_some());
        optionals.set(3, false);

        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&self.five_qi.to_aper(UNCONSTRAINED)?)?;
        if let Some(x) = &self.qos_priority_level {
            enc.append(&x.to_aper(UNCONSTRAINED)?)?;
        }
        if let Some(x) = &self.averaging_window {
            enc.append(&x.to_aper(UNCONSTRAINED)?)?;
        }
        if let Some(x) = &self.max_data_burst_volume {
            enc.append(&x.to_aper(UNCONSTRAINED)?)?;
        }

        Ok(enc)
    }
}

// NonUpTrafficType
#[derive(Clone, Copy, FromPrimitive)]
pub enum NonUpTrafficType {
    UeAssociated,
    NonUeAssociated,
    NonF1,
    BapControlPdu,
    _Extended,
}

impl APerElement for NonUpTrafficType {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        if bool::from_aper(decoder, Self::CONSTRAINTS)? {
            return Ok(NonUpTrafficType::_Extended);
        }
        let v = u8::from_aper(decoder, Self::CONSTRAINTS)?;
        FromPrimitive::from_u8(v).ok_or(DecodeError::MalformedInt)
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&false.to_aper(UNCONSTRAINED)?)?;
        enc.append(&(*self as u8).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// NoofDownlinkSymbols
#[derive(Clone)]
pub struct NoofDownlinkSymbols(pub u8);

impl APerElement for NoofDownlinkSymbols {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(0),
            max: Some(0),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        Ok(Self(u8::from_aper(decoder, Self::CONSTRAINTS)?))
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&(self.0).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// NoofUplinkSymbols
#[derive(Clone)]
pub struct NoofUplinkSymbols(pub u8);

impl APerElement for NoofUplinkSymbols {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(0),
            max: Some(0),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        Ok(Self(u8::from_aper(decoder, Self::CONSTRAINTS)?))
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&(self.0).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// NotificationCause
#[derive(Clone, Copy, FromPrimitive)]
pub enum NotificationCause {
    Fulfilled,
    NotFulfilled,
    _Extended,
}

impl APerElement for NotificationCause {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        if bool::from_aper(decoder, Self::CONSTRAINTS)? {
            return Ok(NotificationCause::_Extended);
        }
        let v = u8::from_aper(decoder, Self::CONSTRAINTS)?;
        FromPrimitive::from_u8(v).ok_or(DecodeError::MalformedInt)
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&false.to_aper(UNCONSTRAINED)?)?;
        enc.append(&(*self as u8).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// NotificationControl
#[derive(Clone, Copy, FromPrimitive)]
pub enum NotificationControl {
    Active,
    NotActive,
    _Extended,
}

impl APerElement for NotificationControl {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        if bool::from_aper(decoder, Self::CONSTRAINTS)? {
            return Ok(NotificationControl::_Extended);
        }
        let v = u8::from_aper(decoder, Self::CONSTRAINTS)?;
        FromPrimitive::from_u8(v).ok_or(DecodeError::MalformedInt)
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&false.to_aper(UNCONSTRAINED)?)?;
        enc.append(&(*self as u8).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// NotificationInformation
#[derive(Clone)]
pub struct NotificationInformation {
    pub message_identifier: MessageIdentifier,
    pub serial_number: SerialNumber,
}

impl APerElement for NotificationInformation {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(1),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let _extended = bool::from_aper(decoder, UNCONSTRAINED)?;
        let _optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let message_identifier = MessageIdentifier::from_aper(decoder, UNCONSTRAINED)?;
        let serial_number = SerialNumber::from_aper(decoder, UNCONSTRAINED)?;

        Ok(Self {
            message_identifier,
            serial_number,
        })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(1);
        optionals.set(0, false);

        enc.append(&false.to_aper(UNCONSTRAINED)?)?;
        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&self.message_identifier.to_aper(UNCONSTRAINED)?)?;
        enc.append(&self.serial_number.to_aper(UNCONSTRAINED)?)?;

        Ok(enc)
    }
}

// NpnBroadcastInformation
#[derive(Clone)]
pub enum NpnBroadcastInformation {
    SnpnBroadcastInformation(NpnBroadcastInformationSnpn),
    PniNpnBroadcastInformation(NpnBroadcastInformationPniNpn),
    _Extended,
}

impl APerElement for NpnBroadcastInformation {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        match u8::from_aper(decoder, UNCONSTRAINED)? {
            0 => Ok(Self::SnpnBroadcastInformation(
                NpnBroadcastInformationSnpn::from_aper(decoder, UNCONSTRAINED)?,
            )),
            1 => Ok(Self::PniNpnBroadcastInformation(
                NpnBroadcastInformationPniNpn::from_aper(decoder, UNCONSTRAINED)?,
            )),
            2 => Err(DecodeError::NotImplemented),
            _ => Err(DecodeError::InvalidChoice),
        }
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        match self {
            Self::SnpnBroadcastInformation(x) => {
                enc.append(&(0 as u8).to_aper(UNCONSTRAINED)?)?;
                enc.append(&x.to_aper(UNCONSTRAINED)?)?;
            }
            Self::PniNpnBroadcastInformation(x) => {
                enc.append(&(1 as u8).to_aper(UNCONSTRAINED)?)?;
                enc.append(&x.to_aper(UNCONSTRAINED)?)?;
            }
            Self::_Extended => return Err(EncodeError::NotImplemented),
        }
        Ok(enc)
    }
}

// NpnBroadcastInformationSnpn
#[derive(Clone)]
pub struct NpnBroadcastInformationSnpn {
    pub broadcast_snpnid_list: BroadcastSnpnIdList,
}

impl APerElement for NpnBroadcastInformationSnpn {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(1),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let _extended = bool::from_aper(decoder, UNCONSTRAINED)?;
        let _optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let broadcast_snpnid_list = BroadcastSnpnIdList::from_aper(decoder, UNCONSTRAINED)?;

        Ok(Self {
            broadcast_snpnid_list,
        })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(1);
        optionals.set(0, false);

        enc.append(&false.to_aper(UNCONSTRAINED)?)?;
        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&self.broadcast_snpnid_list.to_aper(UNCONSTRAINED)?)?;

        Ok(enc)
    }
}

// NpnBroadcastInformationPniNpn
#[derive(Clone)]
pub struct NpnBroadcastInformationPniNpn {
    pub broadcast_pni_npn_id_information: BroadcastPniNpnIdList,
}

impl APerElement for NpnBroadcastInformationPniNpn {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(1),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let _extended = bool::from_aper(decoder, UNCONSTRAINED)?;
        let _optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let broadcast_pni_npn_id_information =
            BroadcastPniNpnIdList::from_aper(decoder, UNCONSTRAINED)?;

        Ok(Self {
            broadcast_pni_npn_id_information,
        })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(1);
        optionals.set(0, false);

        enc.append(&false.to_aper(UNCONSTRAINED)?)?;
        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(
            &self
                .broadcast_pni_npn_id_information
                .to_aper(UNCONSTRAINED)?,
        )?;

        Ok(enc)
    }
}

// NpnSupportInfo
#[derive(Clone)]
pub enum NpnSupportInfo {
    SnpnInformation(Nid),
    _Extended,
}

impl APerElement for NpnSupportInfo {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        match u8::from_aper(decoder, UNCONSTRAINED)? {
            0 => Ok(Self::SnpnInformation(Nid::from_aper(
                decoder,
                UNCONSTRAINED,
            )?)),
            1 => Err(DecodeError::NotImplemented),
            _ => Err(DecodeError::InvalidChoice),
        }
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        match self {
            Self::SnpnInformation(x) => {
                enc.append(&(0 as u8).to_aper(UNCONSTRAINED)?)?;
                enc.append(&x.to_aper(UNCONSTRAINED)?)?;
            }
            Self::_Extended => return Err(EncodeError::NotImplemented),
        }
        Ok(enc)
    }
}

// NrCarrierList
#[derive(Clone)]
pub struct NrCarrierList(pub Vec<NrCarrierItem>);

impl APerElement for NrCarrierList {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(1),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        Ok(Self(Vec::<NrCarrierItem>::from_aper(
            decoder,
            Self::CONSTRAINTS,
        )?))
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&(self.0).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// NrCarrierItem
#[derive(Clone)]
pub struct NrCarrierItem {
    pub carrier_scs: Nrscs,
    pub offset_to_carrier: u16,
    pub carrier_bandwidth: u16,
}

impl APerElement for NrCarrierItem {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(1),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let _extended = bool::from_aper(decoder, UNCONSTRAINED)?;
        let _optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let carrier_scs = Nrscs::from_aper(decoder, UNCONSTRAINED)?;
        let offset_to_carrier = u16::from_aper(decoder, UNCONSTRAINED)?;
        let carrier_bandwidth = u16::from_aper(decoder, UNCONSTRAINED)?;

        Ok(Self {
            carrier_scs,
            offset_to_carrier,
            carrier_bandwidth,
        })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(1);
        optionals.set(0, false);

        enc.append(&false.to_aper(UNCONSTRAINED)?)?;
        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&self.carrier_scs.to_aper(UNCONSTRAINED)?)?;
        enc.append(&self.offset_to_carrier.to_aper(UNCONSTRAINED)?)?;
        enc.append(&self.carrier_bandwidth.to_aper(UNCONSTRAINED)?)?;

        Ok(enc)
    }
}

// NrFreqInfo
#[derive(Clone)]
pub struct NrFreqInfo {
    pub nrarfcn: u32,
    pub sul_information: Option<SulInformation>,
    pub freq_band_list_nr: Vec<FreqBandNrItem>,
}

impl APerElement for NrFreqInfo {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(2),
            max: Some(2),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let _extended = bool::from_aper(decoder, UNCONSTRAINED)?;
        let optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let nrarfcn = u32::from_aper(decoder, UNCONSTRAINED)?;
        let sul_information = if optionals.is_set(0) {
            Some(SulInformation::from_aper(decoder, UNCONSTRAINED)?)
        } else {
            None
        };
        let freq_band_list_nr = Vec::<FreqBandNrItem>::from_aper(
            decoder,
            Constraints {
                value: None,
                size: Some(Constraint::new(Some(1), Some(maxnoofNrCellBands))),
            },
        )?;

        Ok(Self {
            nrarfcn,
            sul_information,
            freq_band_list_nr,
        })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(2);
        optionals.set(0, self.sul_information.is_some());
        optionals.set(1, false);

        enc.append(&false.to_aper(UNCONSTRAINED)?)?;
        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&self.nrarfcn.to_aper(UNCONSTRAINED)?)?;
        if let Some(x) = &self.sul_information {
            enc.append(&x.to_aper(UNCONSTRAINED)?)?;
        }
        enc.append(&self.freq_band_list_nr.to_aper(UNCONSTRAINED)?)?;

        Ok(enc)
    }
}

// Nrcgi
#[derive(Clone)]
pub struct Nrcgi {
    pub plmn_identity: PlmnIdentity,
    pub nr_cell_identity: NrCellIdentity,
}

impl APerElement for Nrcgi {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(1),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let _extended = bool::from_aper(decoder, UNCONSTRAINED)?;
        let _optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let plmn_identity = PlmnIdentity::from_aper(decoder, UNCONSTRAINED)?;
        let nr_cell_identity = NrCellIdentity::from_aper(decoder, UNCONSTRAINED)?;

        Ok(Self {
            plmn_identity,
            nr_cell_identity,
        })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(1);
        optionals.set(0, false);

        enc.append(&false.to_aper(UNCONSTRAINED)?)?;
        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&self.plmn_identity.to_aper(UNCONSTRAINED)?)?;
        enc.append(&self.nr_cell_identity.to_aper(UNCONSTRAINED)?)?;

        Ok(enc)
    }
}

// NrModeInfo
#[derive(Clone)]
pub enum NrModeInfo {
    Fdd(FddInfo),
    Tdd(TddInfo),
    _Extended,
}

impl APerElement for NrModeInfo {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        match u8::from_aper(decoder, UNCONSTRAINED)? {
            0 => Ok(Self::Fdd(FddInfo::from_aper(decoder, UNCONSTRAINED)?)),
            1 => Ok(Self::Tdd(TddInfo::from_aper(decoder, UNCONSTRAINED)?)),
            2 => Err(DecodeError::NotImplemented),
            _ => Err(DecodeError::InvalidChoice),
        }
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        match self {
            Self::Fdd(x) => {
                enc.append(&(0 as u8).to_aper(UNCONSTRAINED)?)?;
                enc.append(&x.to_aper(UNCONSTRAINED)?)?;
            }
            Self::Tdd(x) => {
                enc.append(&(1 as u8).to_aper(UNCONSTRAINED)?)?;
                enc.append(&x.to_aper(UNCONSTRAINED)?)?;
            }
            Self::_Extended => return Err(EncodeError::NotImplemented),
        }
        Ok(enc)
    }
}

// NrprachConfig
#[derive(Clone)]
pub struct NrprachConfig {
    pub ul_prach_config_list: Option<NrprachConfigList>,
    pub sul_prach_config_list: Option<NrprachConfigList>,
}

impl APerElement for NrprachConfig {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(3),
            max: Some(3),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let _extended = bool::from_aper(decoder, UNCONSTRAINED)?;
        let optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let ul_prach_config_list = if optionals.is_set(0) {
            Some(NrprachConfigList::from_aper(decoder, UNCONSTRAINED)?)
        } else {
            None
        };
        let sul_prach_config_list = if optionals.is_set(0) {
            Some(NrprachConfigList::from_aper(decoder, UNCONSTRAINED)?)
        } else {
            None
        };

        Ok(Self {
            ul_prach_config_list,
            sul_prach_config_list,
        })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(3);
        optionals.set(0, self.ul_prach_config_list.is_some());
        optionals.set(1, self.sul_prach_config_list.is_some());
        optionals.set(2, false);

        enc.append(&false.to_aper(UNCONSTRAINED)?)?;
        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        if let Some(x) = &self.ul_prach_config_list {
            enc.append(&x.to_aper(UNCONSTRAINED)?)?;
        }
        if let Some(x) = &self.sul_prach_config_list {
            enc.append(&x.to_aper(UNCONSTRAINED)?)?;
        }

        Ok(enc)
    }
}

// NrCellIdentity
#[derive(Clone)]
pub struct NrCellIdentity(pub BitString);

impl APerElement for NrCellIdentity {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(36),
            max: Some(36),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        Ok(Self(BitString::from_aper(decoder, Self::CONSTRAINTS)?))
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&(self.0).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// Nrnrb
#[derive(Clone, Copy, FromPrimitive)]
pub enum Nrnrb {
    Nrb11,
    Nrb18,
    Nrb24,
    Nrb25,
    Nrb31,
    Nrb32,
    Nrb38,
    Nrb51,
    Nrb52,
    Nrb65,
    Nrb66,
    Nrb78,
    Nrb79,
    Nrb93,
    Nrb106,
    Nrb107,
    Nrb121,
    Nrb132,
    Nrb133,
    Nrb135,
    Nrb160,
    Nrb162,
    Nrb189,
    Nrb216,
    Nrb217,
    Nrb245,
    Nrb264,
    Nrb270,
    Nrb273,
    _Extended,
}

impl APerElement for Nrnrb {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        if bool::from_aper(decoder, Self::CONSTRAINTS)? {
            return Ok(Nrnrb::_Extended);
        }
        let v = u8::from_aper(decoder, Self::CONSTRAINTS)?;
        FromPrimitive::from_u8(v).ok_or(DecodeError::MalformedInt)
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&false.to_aper(UNCONSTRAINED)?)?;
        enc.append(&(*self as u8).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// Nrpci
#[derive(Clone)]
pub struct Nrpci(pub u16);

impl APerElement for Nrpci {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(0),
            max: Some(0),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        Ok(Self(u16::from_aper(decoder, Self::CONSTRAINTS)?))
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&(self.0).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// NrprachConfigList
#[derive(Clone)]
pub struct NrprachConfigList(pub Vec<NrprachConfigItem>);

impl APerElement for NrprachConfigList {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(0),
            max: Some(0),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        Ok(Self(Vec::<NrprachConfigItem>::from_aper(
            decoder,
            Self::CONSTRAINTS,
        )?))
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&(self.0).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// NrprachConfigItem
#[derive(Clone)]
pub struct NrprachConfigItem {
    pub nrscs: Nrscs,
    pub prach_freq_startfrom_carrier: u16,
    pub msg_1fdm: Msg1fdm,
    pub parch_config_index: u8,
    pub ssb_per_rach_occasion: SsbPerRachOccasion,
    pub freq_domain_length: FreqDomainLength,
    pub zero_correl_zone_config: u8,
}

impl APerElement for NrprachConfigItem {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(1),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let _extended = bool::from_aper(decoder, UNCONSTRAINED)?;
        let _optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let nrscs = Nrscs::from_aper(decoder, UNCONSTRAINED)?;
        let prach_freq_startfrom_carrier = u16::from_aper(decoder, UNCONSTRAINED)?;
        let msg_1fdm = Msg1fdm::from_aper(decoder, UNCONSTRAINED)?;
        let parch_config_index = u8::from_aper(decoder, UNCONSTRAINED)?;
        let ssb_per_rach_occasion = SsbPerRachOccasion::from_aper(decoder, UNCONSTRAINED)?;
        let freq_domain_length = FreqDomainLength::from_aper(decoder, UNCONSTRAINED)?;
        let zero_correl_zone_config = u8::from_aper(decoder, UNCONSTRAINED)?;

        Ok(Self {
            nrscs,
            prach_freq_startfrom_carrier,
            msg_1fdm,
            parch_config_index,
            ssb_per_rach_occasion,
            freq_domain_length,
            zero_correl_zone_config,
        })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(1);
        optionals.set(0, false);

        enc.append(&false.to_aper(UNCONSTRAINED)?)?;
        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&self.nrscs.to_aper(UNCONSTRAINED)?)?;
        enc.append(&self.prach_freq_startfrom_carrier.to_aper(UNCONSTRAINED)?)?;
        enc.append(&self.msg_1fdm.to_aper(UNCONSTRAINED)?)?;
        enc.append(&self.parch_config_index.to_aper(UNCONSTRAINED)?)?;
        enc.append(&self.ssb_per_rach_occasion.to_aper(UNCONSTRAINED)?)?;
        enc.append(&self.freq_domain_length.to_aper(UNCONSTRAINED)?)?;
        enc.append(&self.zero_correl_zone_config.to_aper(UNCONSTRAINED)?)?;

        Ok(enc)
    }
}

// Nrscs
#[derive(Clone, Copy, FromPrimitive)]
pub enum Nrscs {
    Scs15,
    Scs30,
    Scs60,
    Scs120,
    _Extended,
}

impl APerElement for Nrscs {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        if bool::from_aper(decoder, Self::CONSTRAINTS)? {
            return Ok(Nrscs::_Extended);
        }
        let v = u8::from_aper(decoder, Self::CONSTRAINTS)?;
        FromPrimitive::from_u8(v).ok_or(DecodeError::MalformedInt)
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&false.to_aper(UNCONSTRAINED)?)?;
        enc.append(&(*self as u8).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// NrueRlfReportContainer
#[derive(Clone)]
pub struct NrueRlfReportContainer(pub Vec<u8>);

impl APerElement for NrueRlfReportContainer {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        Ok(Self(Vec::<u8>::from_aper(decoder, Self::CONSTRAINTS)?))
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&(self.0).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// NumberofActiveUEs
#[derive(Clone)]
pub struct NumberofActiveUEs(pub u32);

impl APerElement for NumberofActiveUEs {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(0),
            max: Some(16777215),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        Ok(Self(u32::from_aper(decoder, Self::CONSTRAINTS)?))
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&(self.0).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// NumberOfBroadcasts
#[derive(Clone)]
pub struct NumberOfBroadcasts(pub u16);

impl APerElement for NumberOfBroadcasts {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(0),
            max: Some(0),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        Ok(Self(u16::from_aper(decoder, Self::CONSTRAINTS)?))
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&(self.0).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// NumberofBroadcastRequest
#[derive(Clone)]
pub struct NumberofBroadcastRequest(pub u16);

impl APerElement for NumberofBroadcastRequest {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(0),
            max: Some(0),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        Ok(Self(u16::from_aper(decoder, Self::CONSTRAINTS)?))
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&(self.0).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// NumDlulSymbols
#[derive(Clone)]
pub struct NumDlulSymbols {
    pub num_dl_symbols: u8,
    pub num_ul_symbols: u8,
}

impl APerElement for NumDlulSymbols {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(1),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let _optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let num_dl_symbols = u8::from_aper(decoder, UNCONSTRAINED)?;
        let num_ul_symbols = u8::from_aper(decoder, UNCONSTRAINED)?;

        Ok(Self {
            num_dl_symbols,
            num_ul_symbols,
        })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(1);
        optionals.set(0, false);

        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&self.num_dl_symbols.to_aper(UNCONSTRAINED)?)?;
        enc.append(&self.num_ul_symbols.to_aper(UNCONSTRAINED)?)?;

        Ok(enc)
    }
}

// Nrv2xServicesAuthorized
#[derive(Clone)]
pub struct Nrv2xServicesAuthorized {
    pub vehicle_ue: Option<VehicleUe>,
    pub pedestrian_ue: Option<PedestrianUe>,
}

impl APerElement for Nrv2xServicesAuthorized {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(3),
            max: Some(3),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let vehicle_ue = if optionals.is_set(0) {
            Some(VehicleUe::from_aper(decoder, UNCONSTRAINED)?)
        } else {
            None
        };
        let pedestrian_ue = if optionals.is_set(0) {
            Some(PedestrianUe::from_aper(decoder, UNCONSTRAINED)?)
        } else {
            None
        };

        Ok(Self {
            vehicle_ue,
            pedestrian_ue,
        })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(3);
        optionals.set(0, self.vehicle_ue.is_some());
        optionals.set(1, self.pedestrian_ue.is_some());
        optionals.set(2, false);

        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        if let Some(x) = &self.vehicle_ue {
            enc.append(&x.to_aper(UNCONSTRAINED)?)?;
        }
        if let Some(x) = &self.pedestrian_ue {
            enc.append(&x.to_aper(UNCONSTRAINED)?)?;
        }

        Ok(enc)
    }
}

// NrueSidelinkAggregateMaximumBitrate
#[derive(Clone)]
pub struct NrueSidelinkAggregateMaximumBitrate {
    pub uenr_sidelink_aggregate_maximum_bitrate: BitRate,
}

impl APerElement for NrueSidelinkAggregateMaximumBitrate {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(1),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let _optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let uenr_sidelink_aggregate_maximum_bitrate = BitRate::from_aper(decoder, UNCONSTRAINED)?;

        Ok(Self {
            uenr_sidelink_aggregate_maximum_bitrate,
        })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(1);
        optionals.set(0, false);

        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(
            &self
                .uenr_sidelink_aggregate_maximum_bitrate
                .to_aper(UNCONSTRAINED)?,
        )?;

        Ok(enc)
    }
}

// NzpCsiRsResourceId
#[derive(Clone)]
pub struct NzpCsiRsResourceId(pub u8);

impl APerElement for NzpCsiRsResourceId {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(0),
            max: Some(0),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        Ok(Self(u8::from_aper(decoder, Self::CONSTRAINTS)?))
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&(self.0).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// OffsetToPointA
#[derive(Clone)]
pub struct OffsetToPointA(pub u16);

impl APerElement for OffsetToPointA {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(0),
            max: Some(2199),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        Ok(Self(u16::from_aper(decoder, Self::CONSTRAINTS)?))
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&(self.0).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// PacketDelayBudget
#[derive(Clone)]
pub struct PacketDelayBudget(pub u16);

impl APerElement for PacketDelayBudget {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(0),
            max: Some(1023),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        Ok(Self(u16::from_aper(decoder, Self::CONSTRAINTS)?))
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&(self.0).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// PacketErrorRate
#[derive(Clone)]
pub struct PacketErrorRate {
    pub per_scalar: PerScalar,
    pub per_exponent: PerExponent,
}

impl APerElement for PacketErrorRate {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(1),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let _extended = bool::from_aper(decoder, UNCONSTRAINED)?;
        let _optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let per_scalar = PerScalar::from_aper(decoder, UNCONSTRAINED)?;
        let per_exponent = PerExponent::from_aper(decoder, UNCONSTRAINED)?;

        Ok(Self {
            per_scalar,
            per_exponent,
        })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(1);
        optionals.set(0, false);

        enc.append(&false.to_aper(UNCONSTRAINED)?)?;
        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&self.per_scalar.to_aper(UNCONSTRAINED)?)?;
        enc.append(&self.per_exponent.to_aper(UNCONSTRAINED)?)?;

        Ok(enc)
    }
}

// PerScalar
#[derive(Clone)]
pub struct PerScalar(pub u8);

impl APerElement for PerScalar {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(0),
            max: Some(9),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        Ok(Self(u8::from_aper(decoder, Self::CONSTRAINTS)?))
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&(self.0).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// PerExponent
#[derive(Clone)]
pub struct PerExponent(pub u8);

impl APerElement for PerExponent {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(0),
            max: Some(9),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        Ok(Self(u8::from_aper(decoder, Self::CONSTRAINTS)?))
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&(self.0).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// PagingCellItem
#[derive(Clone)]
pub struct PagingCellItem {
    pub nrcgi: Nrcgi,
}

impl APerElement for PagingCellItem {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(1),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let _optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let nrcgi = Nrcgi::from_aper(decoder, UNCONSTRAINED)?;

        Ok(Self { nrcgi })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(1);
        optionals.set(0, false);

        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&self.nrcgi.to_aper(UNCONSTRAINED)?)?;

        Ok(enc)
    }
}

// PagingDrx
#[derive(Clone, Copy, FromPrimitive)]
pub enum PagingDrx {
    V32,
    V64,
    V128,
    V256,
    _Extended,
}

impl APerElement for PagingDrx {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        if bool::from_aper(decoder, Self::CONSTRAINTS)? {
            return Ok(PagingDrx::_Extended);
        }
        let v = u8::from_aper(decoder, Self::CONSTRAINTS)?;
        FromPrimitive::from_u8(v).ok_or(DecodeError::MalformedInt)
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&false.to_aper(UNCONSTRAINED)?)?;
        enc.append(&(*self as u8).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// PagingIdentity
#[derive(Clone)]
pub enum PagingIdentity {
    RanuePagingIdentity(RanuePagingIdentity),
    CnuePagingIdentity(CnuePagingIdentity),
    _Extended,
}

impl APerElement for PagingIdentity {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        match u8::from_aper(decoder, UNCONSTRAINED)? {
            0 => Ok(Self::RanuePagingIdentity(RanuePagingIdentity::from_aper(
                decoder,
                UNCONSTRAINED,
            )?)),
            1 => Ok(Self::CnuePagingIdentity(CnuePagingIdentity::from_aper(
                decoder,
                UNCONSTRAINED,
            )?)),
            2 => Err(DecodeError::NotImplemented),
            _ => Err(DecodeError::InvalidChoice),
        }
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        match self {
            Self::RanuePagingIdentity(x) => {
                enc.append(&(0 as u8).to_aper(UNCONSTRAINED)?)?;
                enc.append(&x.to_aper(UNCONSTRAINED)?)?;
            }
            Self::CnuePagingIdentity(x) => {
                enc.append(&(1 as u8).to_aper(UNCONSTRAINED)?)?;
                enc.append(&x.to_aper(UNCONSTRAINED)?)?;
            }
            Self::_Extended => return Err(EncodeError::NotImplemented),
        }
        Ok(enc)
    }
}

// PagingOrigin
#[derive(Clone, Copy, FromPrimitive)]
pub enum PagingOrigin {
    Non3gpp,
    _Extended,
}

impl APerElement for PagingOrigin {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        if bool::from_aper(decoder, Self::CONSTRAINTS)? {
            return Ok(PagingOrigin::_Extended);
        }
        let v = u8::from_aper(decoder, Self::CONSTRAINTS)?;
        FromPrimitive::from_u8(v).ok_or(DecodeError::MalformedInt)
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&false.to_aper(UNCONSTRAINED)?)?;
        enc.append(&(*self as u8).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// PagingPriority
#[derive(Clone, Copy, FromPrimitive)]
pub enum PagingPriority {
    Priolevel1,
    Priolevel2,
    Priolevel3,
    Priolevel4,
    Priolevel5,
    Priolevel6,
    Priolevel7,
    Priolevel8,
    _Extended,
}

impl APerElement for PagingPriority {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        if bool::from_aper(decoder, Self::CONSTRAINTS)? {
            return Ok(PagingPriority::_Extended);
        }
        let v = u8::from_aper(decoder, Self::CONSTRAINTS)?;
        FromPrimitive::from_u8(v).ok_or(DecodeError::MalformedInt)
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&false.to_aper(UNCONSTRAINED)?)?;
        enc.append(&(*self as u8).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// RelativePathDelay
#[derive(Clone)]
pub enum RelativePathDelay {
    K0(u16),
    K1(u16),
    K2(u16),
    K3(u16),
    K4(u16),
    K5(u16),
    _Extended,
}

impl APerElement for RelativePathDelay {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        match u8::from_aper(decoder, UNCONSTRAINED)? {
            0 => Ok(Self::K0(u16::from_aper(decoder, UNCONSTRAINED)?)),
            1 => Ok(Self::K1(u16::from_aper(decoder, UNCONSTRAINED)?)),
            2 => Ok(Self::K2(u16::from_aper(decoder, UNCONSTRAINED)?)),
            3 => Ok(Self::K3(u16::from_aper(decoder, UNCONSTRAINED)?)),
            4 => Ok(Self::K4(u16::from_aper(decoder, UNCONSTRAINED)?)),
            5 => Ok(Self::K5(u16::from_aper(decoder, UNCONSTRAINED)?)),
            6 => Err(DecodeError::NotImplemented),
            _ => Err(DecodeError::InvalidChoice),
        }
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        match self {
            Self::K0(x) => {
                enc.append(&(0 as u8).to_aper(UNCONSTRAINED)?)?;
                enc.append(&x.to_aper(UNCONSTRAINED)?)?;
            }
            Self::K1(x) => {
                enc.append(&(1 as u8).to_aper(UNCONSTRAINED)?)?;
                enc.append(&x.to_aper(UNCONSTRAINED)?)?;
            }
            Self::K2(x) => {
                enc.append(&(2 as u8).to_aper(UNCONSTRAINED)?)?;
                enc.append(&x.to_aper(UNCONSTRAINED)?)?;
            }
            Self::K3(x) => {
                enc.append(&(3 as u8).to_aper(UNCONSTRAINED)?)?;
                enc.append(&x.to_aper(UNCONSTRAINED)?)?;
            }
            Self::K4(x) => {
                enc.append(&(4 as u8).to_aper(UNCONSTRAINED)?)?;
                enc.append(&x.to_aper(UNCONSTRAINED)?)?;
            }
            Self::K5(x) => {
                enc.append(&(5 as u8).to_aper(UNCONSTRAINED)?)?;
                enc.append(&x.to_aper(UNCONSTRAINED)?)?;
            }
            Self::_Extended => return Err(EncodeError::NotImplemented),
        }
        Ok(enc)
    }
}

// PathlossReferenceInfo
#[derive(Clone)]
pub struct PathlossReferenceInfo {
    pub pathloss_reference_signal: PathlossReferenceSignal,
}

impl APerElement for PathlossReferenceInfo {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(1),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let _optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let pathloss_reference_signal = PathlossReferenceSignal::from_aper(decoder, UNCONSTRAINED)?;

        Ok(Self {
            pathloss_reference_signal,
        })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(1);
        optionals.set(0, false);

        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&self.pathloss_reference_signal.to_aper(UNCONSTRAINED)?)?;

        Ok(enc)
    }
}

// PathlossReferenceSignal
#[derive(Clone)]
pub enum PathlossReferenceSignal {
    Ssb(Ssb),
    DlPrs(DlPrs),
    _Extended,
}

impl APerElement for PathlossReferenceSignal {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        match u8::from_aper(decoder, UNCONSTRAINED)? {
            0 => Ok(Self::Ssb(Ssb::from_aper(decoder, UNCONSTRAINED)?)),
            1 => Ok(Self::DlPrs(DlPrs::from_aper(decoder, UNCONSTRAINED)?)),
            2 => Err(DecodeError::NotImplemented),
            _ => Err(DecodeError::InvalidChoice),
        }
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        match self {
            Self::Ssb(x) => {
                enc.append(&(0 as u8).to_aper(UNCONSTRAINED)?)?;
                enc.append(&x.to_aper(UNCONSTRAINED)?)?;
            }
            Self::DlPrs(x) => {
                enc.append(&(1 as u8).to_aper(UNCONSTRAINED)?)?;
                enc.append(&x.to_aper(UNCONSTRAINED)?)?;
            }
            Self::_Extended => return Err(EncodeError::NotImplemented),
        }
        Ok(enc)
    }
}

// Pc5QosFlowIdentifier
#[derive(Clone)]
pub struct Pc5QosFlowIdentifier(pub u16);

impl APerElement for Pc5QosFlowIdentifier {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(1),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        Ok(Self(u16::from_aper(decoder, Self::CONSTRAINTS)?))
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&(self.0).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// Pc5QosCharacteristics
#[derive(Clone)]
pub enum Pc5QosCharacteristics {
    NonDynamicPqi(NonDynamicPqiDescriptor),
    DynamicPqi(DynamicPqiDescriptor),
    _Extended,
}

impl APerElement for Pc5QosCharacteristics {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        match u8::from_aper(decoder, UNCONSTRAINED)? {
            0 => Ok(Self::NonDynamicPqi(NonDynamicPqiDescriptor::from_aper(
                decoder,
                UNCONSTRAINED,
            )?)),
            1 => Ok(Self::DynamicPqi(DynamicPqiDescriptor::from_aper(
                decoder,
                UNCONSTRAINED,
            )?)),
            2 => Err(DecodeError::NotImplemented),
            _ => Err(DecodeError::InvalidChoice),
        }
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        match self {
            Self::NonDynamicPqi(x) => {
                enc.append(&(0 as u8).to_aper(UNCONSTRAINED)?)?;
                enc.append(&x.to_aper(UNCONSTRAINED)?)?;
            }
            Self::DynamicPqi(x) => {
                enc.append(&(1 as u8).to_aper(UNCONSTRAINED)?)?;
                enc.append(&x.to_aper(UNCONSTRAINED)?)?;
            }
            Self::_Extended => return Err(EncodeError::NotImplemented),
        }
        Ok(enc)
    }
}

// Pc5QosParameters
#[derive(Clone)]
pub struct Pc5QosParameters {
    pub pc5_qos_characteristics: Pc5QosCharacteristics,
    pub pc5_qos_flow_bit_rates: Option<Pc5FlowBitRates>,
}

impl APerElement for Pc5QosParameters {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(2),
            max: Some(2),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let _extended = bool::from_aper(decoder, UNCONSTRAINED)?;
        let optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let pc5_qos_characteristics = Pc5QosCharacteristics::from_aper(decoder, UNCONSTRAINED)?;
        let pc5_qos_flow_bit_rates = if optionals.is_set(0) {
            Some(Pc5FlowBitRates::from_aper(decoder, UNCONSTRAINED)?)
        } else {
            None
        };

        Ok(Self {
            pc5_qos_characteristics,
            pc5_qos_flow_bit_rates,
        })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(2);
        optionals.set(0, self.pc5_qos_flow_bit_rates.is_some());
        optionals.set(1, false);

        enc.append(&false.to_aper(UNCONSTRAINED)?)?;
        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&self.pc5_qos_characteristics.to_aper(UNCONSTRAINED)?)?;
        if let Some(x) = &self.pc5_qos_flow_bit_rates {
            enc.append(&x.to_aper(UNCONSTRAINED)?)?;
        }

        Ok(enc)
    }
}

// Pc5FlowBitRates
#[derive(Clone)]
pub struct Pc5FlowBitRates {
    pub guaranteed_flow_bit_rate: BitRate,
    pub maximum_flow_bit_rate: BitRate,
}

impl APerElement for Pc5FlowBitRates {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(1),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let _extended = bool::from_aper(decoder, UNCONSTRAINED)?;
        let _optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let guaranteed_flow_bit_rate = BitRate::from_aper(decoder, UNCONSTRAINED)?;
        let maximum_flow_bit_rate = BitRate::from_aper(decoder, UNCONSTRAINED)?;

        Ok(Self {
            guaranteed_flow_bit_rate,
            maximum_flow_bit_rate,
        })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(1);
        optionals.set(0, false);

        enc.append(&false.to_aper(UNCONSTRAINED)?)?;
        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&self.guaranteed_flow_bit_rate.to_aper(UNCONSTRAINED)?)?;
        enc.append(&self.maximum_flow_bit_rate.to_aper(UNCONSTRAINED)?)?;

        Ok(enc)
    }
}

// PdcchBlindDetectionScg
#[derive(Clone)]
pub struct PdcchBlindDetectionScg(pub Vec<u8>);

impl APerElement for PdcchBlindDetectionScg {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        Ok(Self(Vec::<u8>::from_aper(decoder, Self::CONSTRAINTS)?))
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&(self.0).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// PdcpSn
#[derive(Clone)]
pub struct PdcpSn(pub u16);

impl APerElement for PdcpSn {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(0),
            max: Some(0),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        Ok(Self(u16::from_aper(decoder, Self::CONSTRAINTS)?))
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&(self.0).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// PdcpsnLength
#[derive(Clone, Copy, FromPrimitive)]
pub enum PdcpsnLength {
    TwelveBits,
    EighteenBits,
    _Extended,
}

impl APerElement for PdcpsnLength {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        if bool::from_aper(decoder, Self::CONSTRAINTS)? {
            return Ok(PdcpsnLength::_Extended);
        }
        let v = u8::from_aper(decoder, Self::CONSTRAINTS)?;
        FromPrimitive::from_u8(v).ok_or(DecodeError::MalformedInt)
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&false.to_aper(UNCONSTRAINED)?)?;
        enc.append(&(*self as u8).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// PduSessionId
#[derive(Clone)]
pub struct PduSessionId(pub u8);

impl APerElement for PduSessionId {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(0),
            max: Some(0),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        Ok(Self(u8::from_aper(decoder, Self::CONSTRAINTS)?))
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&(self.0).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// ReportingPeriodicityValue
#[derive(Clone)]
pub struct ReportingPeriodicityValue(pub u16);

impl APerElement for ReportingPeriodicityValue {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(0),
            max: Some(512),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        Ok(Self(u16::from_aper(decoder, Self::CONSTRAINTS)?))
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&(self.0).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// Periodicity
#[derive(Clone)]
pub struct Periodicity(pub u32);

impl APerElement for Periodicity {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(0),
            max: Some(640000),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        Ok(Self(u32::from_aper(decoder, Self::CONSTRAINTS)?))
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&(self.0).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// PeriodicitySrs
#[derive(Clone, Copy, FromPrimitive)]
pub enum PeriodicitySrs {
    Ms0p125,
    Ms0p25,
    Ms0p5,
    Ms0p625,
    Ms1,
    Ms1p25,
    Ms2,
    Ms2p5,
    Ms4,
    Ms5,
    Ms8,
    Ms10,
    Ms16,
    Ms20,
    Ms32,
    Ms40,
    Ms64,
    Ms80,
    Ms160,
    Ms320,
    Ms640,
    Ms1280,
    Ms2560,
    Ms5120,
    Ms10240,
    _Extended,
}

impl APerElement for PeriodicitySrs {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        if bool::from_aper(decoder, Self::CONSTRAINTS)? {
            return Ok(PeriodicitySrs::_Extended);
        }
        let v = u8::from_aper(decoder, Self::CONSTRAINTS)?;
        FromPrimitive::from_u8(v).ok_or(DecodeError::MalformedInt)
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&false.to_aper(UNCONSTRAINED)?)?;
        enc.append(&(*self as u8).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// PeriodicityList
#[derive(Clone)]
pub struct PeriodicityList(pub Vec<PeriodicityListItem>);

impl APerElement for PeriodicityList {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(1),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        Ok(Self(Vec::<PeriodicityListItem>::from_aper(
            decoder,
            Self::CONSTRAINTS,
        )?))
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&(self.0).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// PeriodicityListItem
#[derive(Clone)]
pub struct PeriodicityListItem {
    pub periodicity_srs: PeriodicitySrs,
}

impl APerElement for PeriodicityListItem {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(1),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let _optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let periodicity_srs = PeriodicitySrs::from_aper(decoder, UNCONSTRAINED)?;

        Ok(Self { periodicity_srs })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(1);
        optionals.set(0, false);

        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&self.periodicity_srs.to_aper(UNCONSTRAINED)?)?;

        Ok(enc)
    }
}

// Permutation
#[derive(Clone, Copy, FromPrimitive)]
pub enum Permutation {
    Dfu,
    Ufd,
    _Extended,
}

impl APerElement for Permutation {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        if bool::from_aper(decoder, Self::CONSTRAINTS)? {
            return Ok(Permutation::_Extended);
        }
        let v = u8::from_aper(decoder, Self::CONSTRAINTS)?;
        FromPrimitive::from_u8(v).ok_or(DecodeError::MalformedInt)
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&false.to_aper(UNCONSTRAINED)?)?;
        enc.append(&(*self as u8).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// PhInfoMcg
#[derive(Clone)]
pub struct PhInfoMcg(pub Vec<u8>);

impl APerElement for PhInfoMcg {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        Ok(Self(Vec::<u8>::from_aper(decoder, Self::CONSTRAINTS)?))
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&(self.0).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// PhInfoScg
#[derive(Clone)]
pub struct PhInfoScg(pub Vec<u8>);

impl APerElement for PhInfoScg {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        Ok(Self(Vec::<u8>::from_aper(decoder, Self::CONSTRAINTS)?))
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&(self.0).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// PlmnIdentity
#[derive(Clone)]
pub struct PlmnIdentity(pub Vec<u8>);

impl APerElement for PlmnIdentity {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(3),
            max: Some(3),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        Ok(Self(Vec::<u8>::from_aper(decoder, Self::CONSTRAINTS)?))
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&(self.0).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// PortNumber
#[derive(Clone)]
pub struct PortNumber(pub BitString);

impl APerElement for PortNumber {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(16),
            max: Some(16),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        Ok(Self(BitString::from_aper(decoder, Self::CONSTRAINTS)?))
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&(self.0).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// PosAssistanceInformation
#[derive(Clone)]
pub struct PosAssistanceInformation(pub Vec<u8>);

impl APerElement for PosAssistanceInformation {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        Ok(Self(Vec::<u8>::from_aper(decoder, Self::CONSTRAINTS)?))
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&(self.0).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// PosAssistanceInformationFailureList
#[derive(Clone)]
pub struct PosAssistanceInformationFailureList(pub Vec<u8>);

impl APerElement for PosAssistanceInformationFailureList {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        Ok(Self(Vec::<u8>::from_aper(decoder, Self::CONSTRAINTS)?))
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&(self.0).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// PosBroadcast
#[derive(Clone, Copy, FromPrimitive)]
pub enum PosBroadcast {
    Start,
    Stop,
    _Extended,
}

impl APerElement for PosBroadcast {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        if bool::from_aper(decoder, Self::CONSTRAINTS)? {
            return Ok(PosBroadcast::_Extended);
        }
        let v = u8::from_aper(decoder, Self::CONSTRAINTS)?;
        FromPrimitive::from_u8(v).ok_or(DecodeError::MalformedInt)
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&false.to_aper(UNCONSTRAINED)?)?;
        enc.append(&(*self as u8).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// PositioningBroadcastCells
#[derive(Clone)]
pub struct PositioningBroadcastCells(pub Vec<Nrcgi>);

impl APerElement for PositioningBroadcastCells {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(1),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        Ok(Self(Vec::<Nrcgi>::from_aper(decoder, Self::CONSTRAINTS)?))
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&(self.0).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// MeasurementPeriodicity
#[derive(Clone, Copy, FromPrimitive)]
pub enum MeasurementPeriodicity {
    Ms120,
    Ms240,
    Ms480,
    Ms640,
    Ms1024,
    Ms2048,
    Ms5120,
    Ms10240,
    Min1,
    Min6,
    Min12,
    Min30,
    _Extended,
}

impl APerElement for MeasurementPeriodicity {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        if bool::from_aper(decoder, Self::CONSTRAINTS)? {
            return Ok(MeasurementPeriodicity::_Extended);
        }
        let v = u8::from_aper(decoder, Self::CONSTRAINTS)?;
        FromPrimitive::from_u8(v).ok_or(DecodeError::MalformedInt)
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&false.to_aper(UNCONSTRAINED)?)?;
        enc.append(&(*self as u8).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// PosMeasurementQuantities
#[derive(Clone)]
pub struct PosMeasurementQuantities(pub Vec<PosMeasurementQuantitiesItem>);

impl APerElement for PosMeasurementQuantities {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(1),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        Ok(Self(Vec::<PosMeasurementQuantitiesItem>::from_aper(
            decoder,
            Self::CONSTRAINTS,
        )?))
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&(self.0).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// PosMeasurementQuantitiesItem
#[derive(Clone)]
pub struct PosMeasurementQuantitiesItem {
    pub pos_measurement_type: PosMeasurementType,
    pub timing_reporting_granularity_factor: Option<u8>,
}

impl APerElement for PosMeasurementQuantitiesItem {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(2),
            max: Some(2),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let pos_measurement_type = PosMeasurementType::from_aper(decoder, UNCONSTRAINED)?;
        let timing_reporting_granularity_factor = if optionals.is_set(0) {
            Some(u8::from_aper(decoder, UNCONSTRAINED)?)
        } else {
            None
        };

        Ok(Self {
            pos_measurement_type,
            timing_reporting_granularity_factor,
        })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(2);
        optionals.set(0, self.timing_reporting_granularity_factor.is_some());
        optionals.set(1, false);

        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&self.pos_measurement_type.to_aper(UNCONSTRAINED)?)?;
        if let Some(x) = &self.timing_reporting_granularity_factor {
            enc.append(&x.to_aper(UNCONSTRAINED)?)?;
        }

        Ok(enc)
    }
}

// PosMeasurementResult
#[derive(Clone)]
pub struct PosMeasurementResult(pub Vec<PosMeasurementResultItem>);

impl APerElement for PosMeasurementResult {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(1),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        Ok(Self(Vec::<PosMeasurementResultItem>::from_aper(
            decoder,
            Self::CONSTRAINTS,
        )?))
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&(self.0).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// PosMeasurementResultItem
#[derive(Clone)]
pub struct PosMeasurementResultItem {
    pub measured_results_value: MeasuredResultsValue,
    pub time_stamp: TimeStamp,
    pub measurement_quality: Option<TrpMeasurementQuality>,
    pub measurement_beam_info: Option<MeasurementBeamInfo>,
}

impl APerElement for PosMeasurementResultItem {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(3),
            max: Some(3),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let measured_results_value = MeasuredResultsValue::from_aper(decoder, UNCONSTRAINED)?;
        let time_stamp = TimeStamp::from_aper(decoder, UNCONSTRAINED)?;
        let measurement_quality = if optionals.is_set(0) {
            Some(TrpMeasurementQuality::from_aper(decoder, UNCONSTRAINED)?)
        } else {
            None
        };
        let measurement_beam_info = if optionals.is_set(0) {
            Some(MeasurementBeamInfo::from_aper(decoder, UNCONSTRAINED)?)
        } else {
            None
        };

        Ok(Self {
            measured_results_value,
            time_stamp,
            measurement_quality,
            measurement_beam_info,
        })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(3);
        optionals.set(0, self.measurement_quality.is_some());
        optionals.set(1, self.measurement_beam_info.is_some());
        optionals.set(2, false);

        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&self.measured_results_value.to_aper(UNCONSTRAINED)?)?;
        enc.append(&self.time_stamp.to_aper(UNCONSTRAINED)?)?;
        if let Some(x) = &self.measurement_quality {
            enc.append(&x.to_aper(UNCONSTRAINED)?)?;
        }
        if let Some(x) = &self.measurement_beam_info {
            enc.append(&x.to_aper(UNCONSTRAINED)?)?;
        }

        Ok(enc)
    }
}

// PosMeasurementResultList
#[derive(Clone)]
pub struct PosMeasurementResultList(pub Vec<PosMeasurementResultListItem>);

impl APerElement for PosMeasurementResultList {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(1),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        Ok(Self(Vec::<PosMeasurementResultListItem>::from_aper(
            decoder,
            Self::CONSTRAINTS,
        )?))
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&(self.0).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// PosMeasurementResultListItem
#[derive(Clone)]
pub struct PosMeasurementResultListItem {
    pub pos_measurement_result: PosMeasurementResult,
    pub trpid: Trpid,
}

impl APerElement for PosMeasurementResultListItem {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(1),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let _optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let pos_measurement_result = PosMeasurementResult::from_aper(decoder, UNCONSTRAINED)?;
        let trpid = Trpid::from_aper(decoder, UNCONSTRAINED)?;

        Ok(Self {
            pos_measurement_result,
            trpid,
        })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(1);
        optionals.set(0, false);

        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&self.pos_measurement_result.to_aper(UNCONSTRAINED)?)?;
        enc.append(&self.trpid.to_aper(UNCONSTRAINED)?)?;

        Ok(enc)
    }
}

// PosMeasurementType
#[derive(Clone, Copy, FromPrimitive)]
pub enum PosMeasurementType {
    GnbRxTx,
    UlSrsRsrp,
    UlAoa,
    UlRtoa,
    _Extended,
}

impl APerElement for PosMeasurementType {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        if bool::from_aper(decoder, Self::CONSTRAINTS)? {
            return Ok(PosMeasurementType::_Extended);
        }
        let v = u8::from_aper(decoder, Self::CONSTRAINTS)?;
        FromPrimitive::from_u8(v).ok_or(DecodeError::MalformedInt)
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&false.to_aper(UNCONSTRAINED)?)?;
        enc.append(&(*self as u8).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// PosReportCharacteristics
#[derive(Clone, Copy, FromPrimitive)]
pub enum PosReportCharacteristics {
    Ondemand,
    Periodic,
    _Extended,
}

impl APerElement for PosReportCharacteristics {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        if bool::from_aper(decoder, Self::CONSTRAINTS)? {
            return Ok(PosReportCharacteristics::_Extended);
        }
        let v = u8::from_aper(decoder, Self::CONSTRAINTS)?;
        FromPrimitive::from_u8(v).ok_or(DecodeError::MalformedInt)
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&false.to_aper(UNCONSTRAINED)?)?;
        enc.append(&(*self as u8).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// PosResourceSetType
#[derive(Clone)]
pub enum PosResourceSetType {
    Periodic(PosResourceSetTypePr),
    SemiPersistent(PosResourceSetTypeSp),
    Aperiodic(PosResourceSetTypeAp),
    _Extended,
}

impl APerElement for PosResourceSetType {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        match u8::from_aper(decoder, UNCONSTRAINED)? {
            0 => Ok(Self::Periodic(PosResourceSetTypePr::from_aper(
                decoder,
                UNCONSTRAINED,
            )?)),
            1 => Ok(Self::SemiPersistent(PosResourceSetTypeSp::from_aper(
                decoder,
                UNCONSTRAINED,
            )?)),
            2 => Ok(Self::Aperiodic(PosResourceSetTypeAp::from_aper(
                decoder,
                UNCONSTRAINED,
            )?)),
            3 => Err(DecodeError::NotImplemented),
            _ => Err(DecodeError::InvalidChoice),
        }
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        match self {
            Self::Periodic(x) => {
                enc.append(&(0 as u8).to_aper(UNCONSTRAINED)?)?;
                enc.append(&x.to_aper(UNCONSTRAINED)?)?;
            }
            Self::SemiPersistent(x) => {
                enc.append(&(1 as u8).to_aper(UNCONSTRAINED)?)?;
                enc.append(&x.to_aper(UNCONSTRAINED)?)?;
            }
            Self::Aperiodic(x) => {
                enc.append(&(2 as u8).to_aper(UNCONSTRAINED)?)?;
                enc.append(&x.to_aper(UNCONSTRAINED)?)?;
            }
            Self::_Extended => return Err(EncodeError::NotImplemented),
        }
        Ok(enc)
    }
}

// PosResourceSetTypePr
#[derive(Clone)]
pub struct PosResourceSetTypePr {
    pub posperiodic_set: PosperiodicSet,
}

impl APerElement for PosResourceSetTypePr {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(1),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let _optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let posperiodic_set = PosperiodicSet::from_aper(decoder, UNCONSTRAINED)?;

        Ok(Self { posperiodic_set })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(1);
        optionals.set(0, false);

        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&self.posperiodic_set.to_aper(UNCONSTRAINED)?)?;

        Ok(enc)
    }
}

// PosResourceSetTypeSp
#[derive(Clone)]
pub struct PosResourceSetTypeSp {
    pub possemi_persistent_set: PossemiPersistentSet,
}

impl APerElement for PosResourceSetTypeSp {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(1),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let _optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let possemi_persistent_set = PossemiPersistentSet::from_aper(decoder, UNCONSTRAINED)?;

        Ok(Self {
            possemi_persistent_set,
        })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(1);
        optionals.set(0, false);

        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&self.possemi_persistent_set.to_aper(UNCONSTRAINED)?)?;

        Ok(enc)
    }
}

// PosResourceSetTypeAp
#[derive(Clone)]
pub struct PosResourceSetTypeAp {
    pub srs_resource_trigger_list: u8,
}

impl APerElement for PosResourceSetTypeAp {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(1),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let _optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let srs_resource_trigger_list = u8::from_aper(decoder, UNCONSTRAINED)?;

        Ok(Self {
            srs_resource_trigger_list,
        })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(1);
        optionals.set(0, false);

        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&self.srs_resource_trigger_list.to_aper(UNCONSTRAINED)?)?;

        Ok(enc)
    }
}

// PosSrsResourceIdList
#[derive(Clone)]
pub struct PosSrsResourceIdList(pub Vec<SrsPosResourceId>);

impl APerElement for PosSrsResourceIdList {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(1),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        Ok(Self(Vec::<SrsPosResourceId>::from_aper(
            decoder,
            Self::CONSTRAINTS,
        )?))
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&(self.0).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// PosSrsResourceItem
#[derive(Clone)]
pub struct PosSrsResourceItem {
    pub srs_pos_resource_id: SrsPosResourceId,
    pub transmission_comb_pos: TransmissionCombPos,
    pub start_position: u8,
    pub nrof_symbols: NrofSymbols,
    pub freq_domain_shift: u16,
    pub c_srs: u8,
    pub group_or_sequence_hopping: GroupOrSequenceHopping,
    pub resource_type_pos: ResourceTypePos,
    pub sequence_id: u16,
    pub spatial_relation_pos: Option<SpatialRelationPos>,
}

impl APerElement for PosSrsResourceItem {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(2),
            max: Some(2),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let srs_pos_resource_id = SrsPosResourceId::from_aper(decoder, UNCONSTRAINED)?;
        let transmission_comb_pos = TransmissionCombPos::from_aper(decoder, UNCONSTRAINED)?;
        let start_position = u8::from_aper(decoder, UNCONSTRAINED)?;
        let nrof_symbols = NrofSymbols::from_aper(decoder, UNCONSTRAINED)?;
        let freq_domain_shift = u16::from_aper(decoder, UNCONSTRAINED)?;
        let c_srs = u8::from_aper(decoder, UNCONSTRAINED)?;
        let group_or_sequence_hopping = GroupOrSequenceHopping::from_aper(decoder, UNCONSTRAINED)?;
        let resource_type_pos = ResourceTypePos::from_aper(decoder, UNCONSTRAINED)?;
        let sequence_id = u16::from_aper(decoder, UNCONSTRAINED)?;
        let spatial_relation_pos = if optionals.is_set(0) {
            Some(SpatialRelationPos::from_aper(decoder, UNCONSTRAINED)?)
        } else {
            None
        };

        Ok(Self {
            srs_pos_resource_id,
            transmission_comb_pos,
            start_position,
            nrof_symbols,
            freq_domain_shift,
            c_srs,
            group_or_sequence_hopping,
            resource_type_pos,
            sequence_id,
            spatial_relation_pos,
        })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(2);
        optionals.set(0, self.spatial_relation_pos.is_some());
        optionals.set(1, false);

        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&self.srs_pos_resource_id.to_aper(UNCONSTRAINED)?)?;
        enc.append(&self.transmission_comb_pos.to_aper(UNCONSTRAINED)?)?;
        enc.append(&self.start_position.to_aper(UNCONSTRAINED)?)?;
        enc.append(&self.nrof_symbols.to_aper(UNCONSTRAINED)?)?;
        enc.append(&self.freq_domain_shift.to_aper(UNCONSTRAINED)?)?;
        enc.append(&self.c_srs.to_aper(UNCONSTRAINED)?)?;
        enc.append(&self.group_or_sequence_hopping.to_aper(UNCONSTRAINED)?)?;
        enc.append(&self.resource_type_pos.to_aper(UNCONSTRAINED)?)?;
        enc.append(&self.sequence_id.to_aper(UNCONSTRAINED)?)?;
        if let Some(x) = &self.spatial_relation_pos {
            enc.append(&x.to_aper(UNCONSTRAINED)?)?;
        }

        Ok(enc)
    }
}

// PosSrsResourceList
#[derive(Clone)]
pub struct PosSrsResourceList(pub Vec<PosSrsResourceItem>);

impl APerElement for PosSrsResourceList {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(1),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        Ok(Self(Vec::<PosSrsResourceItem>::from_aper(
            decoder,
            Self::CONSTRAINTS,
        )?))
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&(self.0).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// PosSrsResourceSetItem
#[derive(Clone)]
pub struct PosSrsResourceSetItem {
    pub possrs_resource_set_id: u8,
    pub poss_rs_resource_id_list: PosSrsResourceIdList,
    pub posresource_set_type: PosResourceSetType,
}

impl APerElement for PosSrsResourceSetItem {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(1),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let _optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let possrs_resource_set_id = u8::from_aper(decoder, UNCONSTRAINED)?;
        let poss_rs_resource_id_list = PosSrsResourceIdList::from_aper(decoder, UNCONSTRAINED)?;
        let posresource_set_type = PosResourceSetType::from_aper(decoder, UNCONSTRAINED)?;

        Ok(Self {
            possrs_resource_set_id,
            poss_rs_resource_id_list,
            posresource_set_type,
        })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(1);
        optionals.set(0, false);

        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&self.possrs_resource_set_id.to_aper(UNCONSTRAINED)?)?;
        enc.append(&self.poss_rs_resource_id_list.to_aper(UNCONSTRAINED)?)?;
        enc.append(&self.posresource_set_type.to_aper(UNCONSTRAINED)?)?;

        Ok(enc)
    }
}

// PosSrsResourceSetList
#[derive(Clone)]
pub struct PosSrsResourceSetList(pub Vec<PosSrsResourceSetItem>);

impl APerElement for PosSrsResourceSetList {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(1),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        Ok(Self(Vec::<PosSrsResourceSetItem>::from_aper(
            decoder,
            Self::CONSTRAINTS,
        )?))
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&(self.0).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// PrimaryPathIndication
#[derive(Clone, Copy, FromPrimitive)]
pub enum PrimaryPathIndication {
    True,
    False,
    _Extended,
}

impl APerElement for PrimaryPathIndication {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        if bool::from_aper(decoder, Self::CONSTRAINTS)? {
            return Ok(PrimaryPathIndication::_Extended);
        }
        let v = u8::from_aper(decoder, Self::CONSTRAINTS)?;
        FromPrimitive::from_u8(v).ok_or(DecodeError::MalformedInt)
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&false.to_aper(UNCONSTRAINED)?)?;
        enc.append(&(*self as u8).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// PreEmptionCapability
#[derive(Clone, Copy, FromPrimitive)]
pub enum PreEmptionCapability {
    ShallNotTriggerPreEmption,
    MayTriggerPreEmption,
}

impl APerElement for PreEmptionCapability {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let v = u8::from_aper(decoder, Self::CONSTRAINTS)?;
        FromPrimitive::from_u8(v).ok_or(DecodeError::MalformedInt)
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&(*self as u8).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// PreEmptionVulnerability
#[derive(Clone, Copy, FromPrimitive)]
pub enum PreEmptionVulnerability {
    NotPreEmptable,
    PreEmptable,
}

impl APerElement for PreEmptionVulnerability {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let v = u8::from_aper(decoder, Self::CONSTRAINTS)?;
        FromPrimitive::from_u8(v).ok_or(DecodeError::MalformedInt)
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&(*self as u8).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// PriorityLevel
#[derive(Clone)]
pub struct PriorityLevel(pub u8);

impl APerElement for PriorityLevel {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(0),
            max: Some(0),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        Ok(Self(u8::from_aper(decoder, Self::CONSTRAINTS)?))
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&(self.0).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// ProtectedEutraResourceIndication
#[derive(Clone)]
pub struct ProtectedEutraResourceIndication(pub Vec<u8>);

impl APerElement for ProtectedEutraResourceIndication {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        Ok(Self(Vec::<u8>::from_aper(decoder, Self::CONSTRAINTS)?))
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&(self.0).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// ProtectedEutraResourcesItem
#[derive(Clone)]
pub struct ProtectedEutraResourcesItem {
    pub spectrum_sharing_group_id: SpectrumSharingGroupId,
    pub eutra_cells_list: EutraCellsList,
}

impl APerElement for ProtectedEutraResourcesItem {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(1),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let _optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let spectrum_sharing_group_id = SpectrumSharingGroupId::from_aper(decoder, UNCONSTRAINED)?;
        let eutra_cells_list = EutraCellsList::from_aper(decoder, UNCONSTRAINED)?;

        Ok(Self {
            spectrum_sharing_group_id,
            eutra_cells_list,
        })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(1);
        optionals.set(0, false);

        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&self.spectrum_sharing_group_id.to_aper(UNCONSTRAINED)?)?;
        enc.append(&self.eutra_cells_list.to_aper(UNCONSTRAINED)?)?;

        Ok(enc)
    }
}

// PrsConfiguration
#[derive(Clone)]
pub struct PrsConfiguration {
    pub prs_resource_set_list: PrsResourceSetList,
}

impl APerElement for PrsConfiguration {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(1),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let _optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let prs_resource_set_list = PrsResourceSetList::from_aper(decoder, UNCONSTRAINED)?;

        Ok(Self {
            prs_resource_set_list,
        })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(1);
        optionals.set(0, false);

        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&self.prs_resource_set_list.to_aper(UNCONSTRAINED)?)?;

        Ok(enc)
    }
}

// PrsInformationPos
#[derive(Clone)]
pub struct PrsInformationPos {
    pub prs_id_pos: u8,
    pub prs_resource_set_id_pos: u8,
    pub prs_resource_id_pos: Option<u8>,
}

impl APerElement for PrsInformationPos {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(2),
            max: Some(2),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let prs_id_pos = u8::from_aper(decoder, UNCONSTRAINED)?;
        let prs_resource_set_id_pos = u8::from_aper(decoder, UNCONSTRAINED)?;
        let prs_resource_id_pos = if optionals.is_set(0) {
            Some(u8::from_aper(decoder, UNCONSTRAINED)?)
        } else {
            None
        };

        Ok(Self {
            prs_id_pos,
            prs_resource_set_id_pos,
            prs_resource_id_pos,
        })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(2);
        optionals.set(0, self.prs_resource_id_pos.is_some());
        optionals.set(1, false);

        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&self.prs_id_pos.to_aper(UNCONSTRAINED)?)?;
        enc.append(&self.prs_resource_set_id_pos.to_aper(UNCONSTRAINED)?)?;
        if let Some(x) = &self.prs_resource_id_pos {
            enc.append(&x.to_aper(UNCONSTRAINED)?)?;
        }

        Ok(enc)
    }
}

// PotentialSpCellItem
#[derive(Clone)]
pub struct PotentialSpCellItem {
    pub potential_sp_cell_id: Nrcgi,
}

impl APerElement for PotentialSpCellItem {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(1),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let _extended = bool::from_aper(decoder, UNCONSTRAINED)?;
        let _optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let potential_sp_cell_id = Nrcgi::from_aper(decoder, UNCONSTRAINED)?;

        Ok(Self {
            potential_sp_cell_id,
        })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(1);
        optionals.set(0, false);

        enc.append(&false.to_aper(UNCONSTRAINED)?)?;
        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&self.potential_sp_cell_id.to_aper(UNCONSTRAINED)?)?;

        Ok(enc)
    }
}

// PrsAngleList
#[derive(Clone)]
pub struct PrsAngleList(pub Vec<PrsAngleItem>);

impl APerElement for PrsAngleList {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(1),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        Ok(Self(Vec::<PrsAngleItem>::from_aper(
            decoder,
            Self::CONSTRAINTS,
        )?))
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&(self.0).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// PrsAngleItem
#[derive(Clone)]
pub struct PrsAngleItem {
    pub nr_prs_azimuth: u16,
    pub nr_prs_azimuth_fine: u8,
    pub nr_prs_elevation: u8,
    pub nr_prs_elevation_fine: u8,
}

impl APerElement for PrsAngleItem {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(1),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let _optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let nr_prs_azimuth = u16::from_aper(decoder, UNCONSTRAINED)?;
        let nr_prs_azimuth_fine = u8::from_aper(decoder, UNCONSTRAINED)?;
        let nr_prs_elevation = u8::from_aper(decoder, UNCONSTRAINED)?;
        let nr_prs_elevation_fine = u8::from_aper(decoder, UNCONSTRAINED)?;

        Ok(Self {
            nr_prs_azimuth,
            nr_prs_azimuth_fine,
            nr_prs_elevation,
            nr_prs_elevation_fine,
        })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(1);
        optionals.set(0, false);

        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&self.nr_prs_azimuth.to_aper(UNCONSTRAINED)?)?;
        enc.append(&self.nr_prs_azimuth_fine.to_aper(UNCONSTRAINED)?)?;
        enc.append(&self.nr_prs_elevation.to_aper(UNCONSTRAINED)?)?;
        enc.append(&self.nr_prs_elevation_fine.to_aper(UNCONSTRAINED)?)?;

        Ok(enc)
    }
}

// PrsMuting
#[derive(Clone)]
pub struct PrsMuting {
    pub prs_muting_option_1: PrsMutingOption1,
    pub prs_muting_option_2: PrsMutingOption2,
}

impl APerElement for PrsMuting {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(1),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let _optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let prs_muting_option_1 = PrsMutingOption1::from_aper(decoder, UNCONSTRAINED)?;
        let prs_muting_option_2 = PrsMutingOption2::from_aper(decoder, UNCONSTRAINED)?;

        Ok(Self {
            prs_muting_option_1,
            prs_muting_option_2,
        })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(1);
        optionals.set(0, false);

        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&self.prs_muting_option_1.to_aper(UNCONSTRAINED)?)?;
        enc.append(&self.prs_muting_option_2.to_aper(UNCONSTRAINED)?)?;

        Ok(enc)
    }
}

// PrsMutingOption1
#[derive(Clone)]
pub struct PrsMutingOption1 {
    pub muting_pattern: DlPrsMutingPattern,
    pub muting_bit_repetition_factor: MutingBitRepetitionFactor,
}

impl APerElement for PrsMutingOption1 {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(1),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let _optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let muting_pattern = DlPrsMutingPattern::from_aper(decoder, UNCONSTRAINED)?;
        let muting_bit_repetition_factor =
            MutingBitRepetitionFactor::from_aper(decoder, UNCONSTRAINED)?;

        Ok(Self {
            muting_pattern,
            muting_bit_repetition_factor,
        })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(1);
        optionals.set(0, false);

        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&self.muting_pattern.to_aper(UNCONSTRAINED)?)?;
        enc.append(&self.muting_bit_repetition_factor.to_aper(UNCONSTRAINED)?)?;

        Ok(enc)
    }
}

// PrsMutingOption2
#[derive(Clone)]
pub struct PrsMutingOption2 {
    pub muting_pattern: DlPrsMutingPattern,
}

impl APerElement for PrsMutingOption2 {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(1),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let _optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let muting_pattern = DlPrsMutingPattern::from_aper(decoder, UNCONSTRAINED)?;

        Ok(Self { muting_pattern })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(1);
        optionals.set(0, false);

        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&self.muting_pattern.to_aper(UNCONSTRAINED)?)?;

        Ok(enc)
    }
}

// PrsResourceId
#[derive(Clone)]
pub struct PrsResourceId(pub u8);

impl APerElement for PrsResourceId {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(0),
            max: Some(0),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        Ok(Self(u8::from_aper(decoder, Self::CONSTRAINTS)?))
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&(self.0).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// PrsResourceList
#[derive(Clone)]
pub struct PrsResourceList(pub Vec<PrsResourceItem>);

impl APerElement for PrsResourceList {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(1),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        Ok(Self(Vec::<PrsResourceItem>::from_aper(
            decoder,
            Self::CONSTRAINTS,
        )?))
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&(self.0).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// PrsResourceItem
#[derive(Clone)]
pub struct PrsResourceItem {
    pub prs_resource_id: PrsResourceId,
    pub sequence_id: u16,
    pub re_offset: u8,
    pub resource_slot_offset: u16,
    pub resource_symbol_offset: u8,
    pub qcl_info: Option<PrsResourceQclInfo>,
}

impl APerElement for PrsResourceItem {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(2),
            max: Some(2),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let prs_resource_id = PrsResourceId::from_aper(decoder, UNCONSTRAINED)?;
        let sequence_id = u16::from_aper(decoder, UNCONSTRAINED)?;
        let re_offset = u8::from_aper(decoder, UNCONSTRAINED)?;
        let resource_slot_offset = u16::from_aper(decoder, UNCONSTRAINED)?;
        let resource_symbol_offset = u8::from_aper(decoder, UNCONSTRAINED)?;
        let qcl_info = if optionals.is_set(0) {
            Some(PrsResourceQclInfo::from_aper(decoder, UNCONSTRAINED)?)
        } else {
            None
        };

        Ok(Self {
            prs_resource_id,
            sequence_id,
            re_offset,
            resource_slot_offset,
            resource_symbol_offset,
            qcl_info,
        })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(2);
        optionals.set(0, self.qcl_info.is_some());
        optionals.set(1, false);

        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&self.prs_resource_id.to_aper(UNCONSTRAINED)?)?;
        enc.append(&self.sequence_id.to_aper(UNCONSTRAINED)?)?;
        enc.append(&self.re_offset.to_aper(UNCONSTRAINED)?)?;
        enc.append(&self.resource_slot_offset.to_aper(UNCONSTRAINED)?)?;
        enc.append(&self.resource_symbol_offset.to_aper(UNCONSTRAINED)?)?;
        if let Some(x) = &self.qcl_info {
            enc.append(&x.to_aper(UNCONSTRAINED)?)?;
        }

        Ok(enc)
    }
}

// PrsResourceQclInfo
#[derive(Clone)]
pub enum PrsResourceQclInfo {
    QclSourceSsb(PrsResourceQclSourceSsb),
    QclSourcePrs(PrsResourceQclSourcePrs),
    _Extended,
}

impl APerElement for PrsResourceQclInfo {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        match u8::from_aper(decoder, UNCONSTRAINED)? {
            0 => Ok(Self::QclSourceSsb(PrsResourceQclSourceSsb::from_aper(
                decoder,
                UNCONSTRAINED,
            )?)),
            1 => Ok(Self::QclSourcePrs(PrsResourceQclSourcePrs::from_aper(
                decoder,
                UNCONSTRAINED,
            )?)),
            2 => Err(DecodeError::NotImplemented),
            _ => Err(DecodeError::InvalidChoice),
        }
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        match self {
            Self::QclSourceSsb(x) => {
                enc.append(&(0 as u8).to_aper(UNCONSTRAINED)?)?;
                enc.append(&x.to_aper(UNCONSTRAINED)?)?;
            }
            Self::QclSourcePrs(x) => {
                enc.append(&(1 as u8).to_aper(UNCONSTRAINED)?)?;
                enc.append(&x.to_aper(UNCONSTRAINED)?)?;
            }
            Self::_Extended => return Err(EncodeError::NotImplemented),
        }
        Ok(enc)
    }
}

// PrsResourceQclSourceSsb
#[derive(Clone)]
pub struct PrsResourceQclSourceSsb {
    pub pci_nr: u16,
    pub ssb_index: Option<SsbIndex>,
}

impl APerElement for PrsResourceQclSourceSsb {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(2),
            max: Some(2),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let _extended = bool::from_aper(decoder, UNCONSTRAINED)?;
        let optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let pci_nr = u16::from_aper(decoder, UNCONSTRAINED)?;
        let ssb_index = if optionals.is_set(0) {
            Some(SsbIndex::from_aper(decoder, UNCONSTRAINED)?)
        } else {
            None
        };

        Ok(Self { pci_nr, ssb_index })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(2);
        optionals.set(0, self.ssb_index.is_some());
        optionals.set(1, false);

        enc.append(&false.to_aper(UNCONSTRAINED)?)?;
        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&self.pci_nr.to_aper(UNCONSTRAINED)?)?;
        if let Some(x) = &self.ssb_index {
            enc.append(&x.to_aper(UNCONSTRAINED)?)?;
        }

        Ok(enc)
    }
}

// PrsResourceQclSourcePrs
#[derive(Clone)]
pub struct PrsResourceQclSourcePrs {
    pub qcl_source_prs_resource_set_id: PrsResourceSetId,
    pub qcl_source_prs_resource_id: Option<PrsResourceId>,
}

impl APerElement for PrsResourceQclSourcePrs {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(2),
            max: Some(2),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let qcl_source_prs_resource_set_id = PrsResourceSetId::from_aper(decoder, UNCONSTRAINED)?;
        let qcl_source_prs_resource_id = if optionals.is_set(0) {
            Some(PrsResourceId::from_aper(decoder, UNCONSTRAINED)?)
        } else {
            None
        };

        Ok(Self {
            qcl_source_prs_resource_set_id,
            qcl_source_prs_resource_id,
        })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(2);
        optionals.set(0, self.qcl_source_prs_resource_id.is_some());
        optionals.set(1, false);

        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&self.qcl_source_prs_resource_set_id.to_aper(UNCONSTRAINED)?)?;
        if let Some(x) = &self.qcl_source_prs_resource_id {
            enc.append(&x.to_aper(UNCONSTRAINED)?)?;
        }

        Ok(enc)
    }
}

// PrsResourceSetId
#[derive(Clone)]
pub struct PrsResourceSetId(pub u8);

impl APerElement for PrsResourceSetId {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(0),
            max: Some(0),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        Ok(Self(u8::from_aper(decoder, Self::CONSTRAINTS)?))
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&(self.0).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// PrsResourceSetList
#[derive(Clone)]
pub struct PrsResourceSetList(pub Vec<PrsResourceSetItem>);

impl APerElement for PrsResourceSetList {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(1),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        Ok(Self(Vec::<PrsResourceSetItem>::from_aper(
            decoder,
            Self::CONSTRAINTS,
        )?))
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&(self.0).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// PrsResourceSetItem
#[derive(Clone)]
pub struct PrsResourceSetItem {
    pub prs_resource_set_id: PrsResourceSetId,
    pub subcarrier_spacing: SubcarrierSpacing2,
    pub pr_sbandwidth: u8,
    pub start_prb: u16,
    pub point_a: u32,
    pub comb_size: CombSize,
    pub cp_type: CpType,
    pub resource_set_periodicity: ResourceSetPeriodicity,
    pub resource_set_slot_offset: u32,
    pub resource_repetition_factor: ResourceRepetitionFactor,
    pub resource_time_gap: ResourceTimeGap,
    pub resource_numberof_symbols: ResourceNumberofSymbols,
    pub prs_muting: Option<PrsMuting>,
    pub prs_resource_transmit_power: u8,
    pub prs_resource_list: PrsResourceList,
}

impl APerElement for PrsResourceSetItem {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(2),
            max: Some(2),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let prs_resource_set_id = PrsResourceSetId::from_aper(decoder, UNCONSTRAINED)?;
        let subcarrier_spacing = SubcarrierSpacing2::from_aper(decoder, UNCONSTRAINED)?;
        let pr_sbandwidth = u8::from_aper(decoder, UNCONSTRAINED)?;
        let start_prb = u16::from_aper(decoder, UNCONSTRAINED)?;
        let point_a = u32::from_aper(decoder, UNCONSTRAINED)?;
        let comb_size = CombSize::from_aper(decoder, UNCONSTRAINED)?;
        let cp_type = CpType::from_aper(decoder, UNCONSTRAINED)?;
        let resource_set_periodicity = ResourceSetPeriodicity::from_aper(decoder, UNCONSTRAINED)?;
        let resource_set_slot_offset = u32::from_aper(decoder, UNCONSTRAINED)?;
        let resource_repetition_factor =
            ResourceRepetitionFactor::from_aper(decoder, UNCONSTRAINED)?;
        let resource_time_gap = ResourceTimeGap::from_aper(decoder, UNCONSTRAINED)?;
        let resource_numberof_symbols = ResourceNumberofSymbols::from_aper(decoder, UNCONSTRAINED)?;
        let prs_muting = if optionals.is_set(0) {
            Some(PrsMuting::from_aper(decoder, UNCONSTRAINED)?)
        } else {
            None
        };
        let prs_resource_transmit_power = u8::from_aper(decoder, UNCONSTRAINED)?;
        let prs_resource_list = PrsResourceList::from_aper(decoder, UNCONSTRAINED)?;

        Ok(Self {
            prs_resource_set_id,
            subcarrier_spacing,
            pr_sbandwidth,
            start_prb,
            point_a,
            comb_size,
            cp_type,
            resource_set_periodicity,
            resource_set_slot_offset,
            resource_repetition_factor,
            resource_time_gap,
            resource_numberof_symbols,
            prs_muting,
            prs_resource_transmit_power,
            prs_resource_list,
        })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(2);
        optionals.set(0, self.prs_muting.is_some());
        optionals.set(1, false);

        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&self.prs_resource_set_id.to_aper(UNCONSTRAINED)?)?;
        enc.append(&self.subcarrier_spacing.to_aper(UNCONSTRAINED)?)?;
        enc.append(&self.pr_sbandwidth.to_aper(UNCONSTRAINED)?)?;
        enc.append(&self.start_prb.to_aper(UNCONSTRAINED)?)?;
        enc.append(&self.point_a.to_aper(UNCONSTRAINED)?)?;
        enc.append(&self.comb_size.to_aper(UNCONSTRAINED)?)?;
        enc.append(&self.cp_type.to_aper(UNCONSTRAINED)?)?;
        enc.append(&self.resource_set_periodicity.to_aper(UNCONSTRAINED)?)?;
        enc.append(&self.resource_set_slot_offset.to_aper(UNCONSTRAINED)?)?;
        enc.append(&self.resource_repetition_factor.to_aper(UNCONSTRAINED)?)?;
        enc.append(&self.resource_time_gap.to_aper(UNCONSTRAINED)?)?;
        enc.append(&self.resource_numberof_symbols.to_aper(UNCONSTRAINED)?)?;
        if let Some(x) = &self.prs_muting {
            enc.append(&x.to_aper(UNCONSTRAINED)?)?;
        }
        enc.append(&self.prs_resource_transmit_power.to_aper(UNCONSTRAINED)?)?;
        enc.append(&self.prs_resource_list.to_aper(UNCONSTRAINED)?)?;

        Ok(enc)
    }
}

// PwsFailedNrCgiItem
#[derive(Clone)]
pub struct PwsFailedNrCgiItem {
    pub nrcgi: Nrcgi,
    pub number_of_broadcasts: NumberOfBroadcasts,
}

impl APerElement for PwsFailedNrCgiItem {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(1),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let _extended = bool::from_aper(decoder, UNCONSTRAINED)?;
        let _optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let nrcgi = Nrcgi::from_aper(decoder, UNCONSTRAINED)?;
        let number_of_broadcasts = NumberOfBroadcasts::from_aper(decoder, UNCONSTRAINED)?;

        Ok(Self {
            nrcgi,
            number_of_broadcasts,
        })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(1);
        optionals.set(0, false);

        enc.append(&false.to_aper(UNCONSTRAINED)?)?;
        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&self.nrcgi.to_aper(UNCONSTRAINED)?)?;
        enc.append(&self.number_of_broadcasts.to_aper(UNCONSTRAINED)?)?;

        Ok(enc)
    }
}

// PwsSystemInformation
#[derive(Clone)]
pub struct PwsSystemInformation {
    pub si_btype: SibTypePws,
    pub si_bmessage: Vec<u8>,
}

impl APerElement for PwsSystemInformation {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(1),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let _extended = bool::from_aper(decoder, UNCONSTRAINED)?;
        let _optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let si_btype = SibTypePws::from_aper(decoder, UNCONSTRAINED)?;
        let si_bmessage = Vec::<u8>::from_aper(decoder, UNCONSTRAINED)?;

        Ok(Self {
            si_btype,
            si_bmessage,
        })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(1);
        optionals.set(0, false);

        enc.append(&false.to_aper(UNCONSTRAINED)?)?;
        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&self.si_btype.to_aper(UNCONSTRAINED)?)?;
        enc.append(&self.si_bmessage.to_aper(UNCONSTRAINED)?)?;

        Ok(enc)
    }
}

// PrivacyIndicator
#[derive(Clone, Copy, FromPrimitive)]
pub enum PrivacyIndicator {
    ImmediateMdt,
    LoggedMdt,
    _Extended,
}

impl APerElement for PrivacyIndicator {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        if bool::from_aper(decoder, Self::CONSTRAINTS)? {
            return Ok(PrivacyIndicator::_Extended);
        }
        let v = u8::from_aper(decoder, Self::CONSTRAINTS)?;
        FromPrimitive::from_u8(v).ok_or(DecodeError::MalformedInt)
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&false.to_aper(UNCONSTRAINED)?)?;
        enc.append(&(*self as u8).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// Qci
#[derive(Clone)]
pub struct Qci(pub u8);

impl APerElement for Qci {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(0),
            max: Some(0),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        Ok(Self(u8::from_aper(decoder, Self::CONSTRAINTS)?))
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&(self.0).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// QosCharacteristics
#[derive(Clone)]
pub enum QosCharacteristics {
    NonDynamic5qi(NonDynamic5qiDescriptor),
    Dynamic5qi(Dynamic5qiDescriptor),
    _Extended,
}

impl APerElement for QosCharacteristics {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        match u8::from_aper(decoder, UNCONSTRAINED)? {
            0 => Ok(Self::NonDynamic5qi(NonDynamic5qiDescriptor::from_aper(
                decoder,
                UNCONSTRAINED,
            )?)),
            1 => Ok(Self::Dynamic5qi(Dynamic5qiDescriptor::from_aper(
                decoder,
                UNCONSTRAINED,
            )?)),
            2 => Err(DecodeError::NotImplemented),
            _ => Err(DecodeError::InvalidChoice),
        }
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        match self {
            Self::NonDynamic5qi(x) => {
                enc.append(&(0 as u8).to_aper(UNCONSTRAINED)?)?;
                enc.append(&x.to_aper(UNCONSTRAINED)?)?;
            }
            Self::Dynamic5qi(x) => {
                enc.append(&(1 as u8).to_aper(UNCONSTRAINED)?)?;
                enc.append(&x.to_aper(UNCONSTRAINED)?)?;
            }
            Self::_Extended => return Err(EncodeError::NotImplemented),
        }
        Ok(enc)
    }
}

// QosFlowIdentifier
#[derive(Clone)]
pub struct QosFlowIdentifier(pub u8);

impl APerElement for QosFlowIdentifier {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(0),
            max: Some(0),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        Ok(Self(u8::from_aper(decoder, Self::CONSTRAINTS)?))
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&(self.0).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// QosFlowLevelQosParameters
#[derive(Clone)]
pub struct QosFlowLevelQosParameters {
    pub qos_characteristics: QosCharacteristics,
    pub ngran_allocation_retention_priority: NgranAllocationAndRetentionPriority,
    pub gbr_qos_flow_information: Option<GbrQosFlowInformation>,
    pub reflective_qos_attribute: Option<ReflectiveQosAttribute>,
}

impl APerElement for QosFlowLevelQosParameters {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(3),
            max: Some(3),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let qos_characteristics = QosCharacteristics::from_aper(decoder, UNCONSTRAINED)?;
        let ngran_allocation_retention_priority =
            NgranAllocationAndRetentionPriority::from_aper(decoder, UNCONSTRAINED)?;
        let gbr_qos_flow_information = if optionals.is_set(0) {
            Some(GbrQosFlowInformation::from_aper(decoder, UNCONSTRAINED)?)
        } else {
            None
        };
        let reflective_qos_attribute = if optionals.is_set(0) {
            Some(ReflectiveQosAttribute::from_aper(decoder, UNCONSTRAINED)?)
        } else {
            None
        };

        Ok(Self {
            qos_characteristics,
            ngran_allocation_retention_priority,
            gbr_qos_flow_information,
            reflective_qos_attribute,
        })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(3);
        optionals.set(0, self.gbr_qos_flow_information.is_some());
        optionals.set(1, self.reflective_qos_attribute.is_some());
        optionals.set(2, false);

        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&self.qos_characteristics.to_aper(UNCONSTRAINED)?)?;
        enc.append(
            &self
                .ngran_allocation_retention_priority
                .to_aper(UNCONSTRAINED)?,
        )?;
        if let Some(x) = &self.gbr_qos_flow_information {
            enc.append(&x.to_aper(UNCONSTRAINED)?)?;
        }
        if let Some(x) = &self.reflective_qos_attribute {
            enc.append(&x.to_aper(UNCONSTRAINED)?)?;
        }

        Ok(enc)
    }
}

// QosFlowMappingIndication
#[derive(Clone, Copy, FromPrimitive)]
pub enum QosFlowMappingIndication {
    Ul,
    Dl,
    _Extended,
}

impl APerElement for QosFlowMappingIndication {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        if bool::from_aper(decoder, Self::CONSTRAINTS)? {
            return Ok(QosFlowMappingIndication::_Extended);
        }
        let v = u8::from_aper(decoder, Self::CONSTRAINTS)?;
        FromPrimitive::from_u8(v).ok_or(DecodeError::MalformedInt)
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&false.to_aper(UNCONSTRAINED)?)?;
        enc.append(&(*self as u8).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// QosInformation
#[derive(Clone)]
pub enum QosInformation {
    EutranQos(EutranQos),
    _Extended,
}

impl APerElement for QosInformation {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        match u8::from_aper(decoder, UNCONSTRAINED)? {
            0 => Ok(Self::EutranQos(EutranQos::from_aper(
                decoder,
                UNCONSTRAINED,
            )?)),
            1 => Err(DecodeError::NotImplemented),
            _ => Err(DecodeError::InvalidChoice),
        }
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        match self {
            Self::EutranQos(x) => {
                enc.append(&(0 as u8).to_aper(UNCONSTRAINED)?)?;
                enc.append(&x.to_aper(UNCONSTRAINED)?)?;
            }
            Self::_Extended => return Err(EncodeError::NotImplemented),
        }
        Ok(enc)
    }
}

// QosMonitoringRequest
#[derive(Clone, Copy, FromPrimitive)]
pub enum QosMonitoringRequest {
    Ul,
    Dl,
    Both,
    _Extended,
}

impl APerElement for QosMonitoringRequest {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        if bool::from_aper(decoder, Self::CONSTRAINTS)? {
            return Ok(QosMonitoringRequest::_Extended);
        }
        let v = u8::from_aper(decoder, Self::CONSTRAINTS)?;
        FromPrimitive::from_u8(v).ok_or(DecodeError::MalformedInt)
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&false.to_aper(UNCONSTRAINED)?)?;
        enc.append(&(*self as u8).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// QosParaSetIndex
#[derive(Clone)]
pub struct QosParaSetIndex(pub u8);

impl APerElement for QosParaSetIndex {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(8),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        Ok(Self(u8::from_aper(decoder, Self::CONSTRAINTS)?))
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&(self.0).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// QosParaSetNotifyIndex
#[derive(Clone)]
pub struct QosParaSetNotifyIndex(pub u8);

impl APerElement for QosParaSetNotifyIndex {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(0),
            max: Some(8),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        Ok(Self(u8::from_aper(decoder, Self::CONSTRAINTS)?))
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&(self.0).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// RachConfigCommon
#[derive(Clone)]
pub struct RachConfigCommon(pub Vec<u8>);

impl APerElement for RachConfigCommon {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        Ok(Self(Vec::<u8>::from_aper(decoder, Self::CONSTRAINTS)?))
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&(self.0).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// RachConfigCommonIab
#[derive(Clone)]
pub struct RachConfigCommonIab(pub Vec<u8>);

impl APerElement for RachConfigCommonIab {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        Ok(Self(Vec::<u8>::from_aper(decoder, Self::CONSTRAINTS)?))
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&(self.0).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// RachReportContainer
#[derive(Clone)]
pub struct RachReportContainer(pub Vec<u8>);

impl APerElement for RachReportContainer {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        Ok(Self(Vec::<u8>::from_aper(decoder, Self::CONSTRAINTS)?))
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&(self.0).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// RachReportInformationList
#[derive(Clone)]
pub struct RachReportInformationList(pub Vec<RachReportInformationItem>);

impl APerElement for RachReportInformationList {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(1),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        Ok(Self(Vec::<RachReportInformationItem>::from_aper(
            decoder,
            Self::CONSTRAINTS,
        )?))
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&(self.0).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// RachReportInformationItem
#[derive(Clone)]
pub struct RachReportInformationItem {
    pub rach_report_container: RachReportContainer,
    pub ue_assitant_identifier: Option<GnbDuUeF1apId>,
}

impl APerElement for RachReportInformationItem {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(2),
            max: Some(2),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let _extended = bool::from_aper(decoder, UNCONSTRAINED)?;
        let optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let rach_report_container = RachReportContainer::from_aper(decoder, UNCONSTRAINED)?;
        let ue_assitant_identifier = if optionals.is_set(0) {
            Some(GnbDuUeF1apId::from_aper(decoder, UNCONSTRAINED)?)
        } else {
            None
        };

        Ok(Self {
            rach_report_container,
            ue_assitant_identifier,
        })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(2);
        optionals.set(0, self.ue_assitant_identifier.is_some());
        optionals.set(1, false);

        enc.append(&false.to_aper(UNCONSTRAINED)?)?;
        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&self.rach_report_container.to_aper(UNCONSTRAINED)?)?;
        if let Some(x) = &self.ue_assitant_identifier {
            enc.append(&x.to_aper(UNCONSTRAINED)?)?;
        }

        Ok(enc)
    }
}

// RadioResourceStatus
#[derive(Clone)]
pub struct RadioResourceStatus {
    pub ssb_area_radio_resource_status_list: SsbAreaRadioResourceStatusList,
}

impl APerElement for RadioResourceStatus {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(1),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let _optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let ssb_area_radio_resource_status_list =
            SsbAreaRadioResourceStatusList::from_aper(decoder, UNCONSTRAINED)?;

        Ok(Self {
            ssb_area_radio_resource_status_list,
        })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(1);
        optionals.set(0, false);

        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(
            &self
                .ssb_area_radio_resource_status_list
                .to_aper(UNCONSTRAINED)?,
        )?;

        Ok(enc)
    }
}

// Ranac
#[derive(Clone)]
pub struct Ranac(pub u8);

impl APerElement for Ranac {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(0),
            max: Some(0),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        Ok(Self(u8::from_aper(decoder, Self::CONSTRAINTS)?))
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&(self.0).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// RanMeasurementId
#[derive(Clone)]
pub struct RanMeasurementId(pub u16);

impl APerElement for RanMeasurementId {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(65536),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        Ok(Self(u16::from_aper(decoder, Self::CONSTRAINTS)?))
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&(self.0).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// RanUeMeasurementId
#[derive(Clone)]
pub struct RanUeMeasurementId(pub u8);

impl APerElement for RanUeMeasurementId {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(256),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        Ok(Self(u8::from_aper(decoder, Self::CONSTRAINTS)?))
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&(self.0).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// Ranueid
#[derive(Clone)]
pub struct Ranueid(pub Vec<u8>);

impl APerElement for Ranueid {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(8),
            max: Some(8),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        Ok(Self(Vec::<u8>::from_aper(decoder, Self::CONSTRAINTS)?))
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&(self.0).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// RanuePagingIdentity
#[derive(Clone)]
pub struct RanuePagingIdentity {
    pub irnti: BitString,
}

impl APerElement for RanuePagingIdentity {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(1),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let _optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let irnti = BitString::from_aper(
            decoder,
            Constraints {
                value: None,
                size: Some(Constraint::new(Some(40), Some(40))),
            },
        )?;

        Ok(Self { irnti })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(1);
        optionals.set(0, false);

        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&self.irnti.to_aper(UNCONSTRAINED)?)?;

        Ok(enc)
    }
}

// RatFrequencyPriorityInformation
#[derive(Clone)]
pub enum RatFrequencyPriorityInformation {
    Endc(SubscriberProfileIDforRfp),
    Ngran(RatFrequencySelectionPriority),
    _Extended,
}

impl APerElement for RatFrequencyPriorityInformation {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        match u8::from_aper(decoder, UNCONSTRAINED)? {
            0 => Ok(Self::Endc(SubscriberProfileIDforRfp::from_aper(
                decoder,
                UNCONSTRAINED,
            )?)),
            1 => Ok(Self::Ngran(RatFrequencySelectionPriority::from_aper(
                decoder,
                UNCONSTRAINED,
            )?)),
            2 => Err(DecodeError::NotImplemented),
            _ => Err(DecodeError::InvalidChoice),
        }
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        match self {
            Self::Endc(x) => {
                enc.append(&(0 as u8).to_aper(UNCONSTRAINED)?)?;
                enc.append(&x.to_aper(UNCONSTRAINED)?)?;
            }
            Self::Ngran(x) => {
                enc.append(&(1 as u8).to_aper(UNCONSTRAINED)?)?;
                enc.append(&x.to_aper(UNCONSTRAINED)?)?;
            }
            Self::_Extended => return Err(EncodeError::NotImplemented),
        }
        Ok(enc)
    }
}

// RatFrequencySelectionPriority
#[derive(Clone)]
pub struct RatFrequencySelectionPriority(pub u8);

impl APerElement for RatFrequencySelectionPriority {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(256),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        Ok(Self(u8::from_aper(decoder, Self::CONSTRAINTS)?))
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&(self.0).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// ReestablishmentIndication
#[derive(Clone, Copy, FromPrimitive)]
pub enum ReestablishmentIndication {
    Reestablished,
    _Extended,
}

impl APerElement for ReestablishmentIndication {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        if bool::from_aper(decoder, Self::CONSTRAINTS)? {
            return Ok(ReestablishmentIndication::_Extended);
        }
        let v = u8::from_aper(decoder, Self::CONSTRAINTS)?;
        FromPrimitive::from_u8(v).ok_or(DecodeError::MalformedInt)
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&false.to_aper(UNCONSTRAINED)?)?;
        enc.append(&(*self as u8).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// ReferencePoint
#[derive(Clone)]
pub enum ReferencePoint {
    CoordinateId(CoordinateId),
    ReferencePointCoordinate(AccessPointPosition),
    ReferencePointCoordinateHa(NgranHighAccuracyAccessPointPosition),
    _Extended,
}

impl APerElement for ReferencePoint {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        match u8::from_aper(decoder, UNCONSTRAINED)? {
            0 => Ok(Self::CoordinateId(CoordinateId::from_aper(
                decoder,
                UNCONSTRAINED,
            )?)),
            1 => Ok(Self::ReferencePointCoordinate(
                AccessPointPosition::from_aper(decoder, UNCONSTRAINED)?,
            )),
            2 => Ok(Self::ReferencePointCoordinateHa(
                NgranHighAccuracyAccessPointPosition::from_aper(decoder, UNCONSTRAINED)?,
            )),
            3 => Err(DecodeError::NotImplemented),
            _ => Err(DecodeError::InvalidChoice),
        }
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        match self {
            Self::CoordinateId(x) => {
                enc.append(&(0 as u8).to_aper(UNCONSTRAINED)?)?;
                enc.append(&x.to_aper(UNCONSTRAINED)?)?;
            }
            Self::ReferencePointCoordinate(x) => {
                enc.append(&(1 as u8).to_aper(UNCONSTRAINED)?)?;
                enc.append(&x.to_aper(UNCONSTRAINED)?)?;
            }
            Self::ReferencePointCoordinateHa(x) => {
                enc.append(&(2 as u8).to_aper(UNCONSTRAINED)?)?;
                enc.append(&x.to_aper(UNCONSTRAINED)?)?;
            }
            Self::_Extended => return Err(EncodeError::NotImplemented),
        }
        Ok(enc)
    }
}

// ReferenceSfn
#[derive(Clone)]
pub struct ReferenceSfn(pub u16);

impl APerElement for ReferenceSfn {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(0),
            max: Some(0),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        Ok(Self(u16::from_aper(decoder, Self::CONSTRAINTS)?))
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&(self.0).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// ReferenceSignal
#[derive(Clone)]
pub enum ReferenceSignal {
    NzpCsiRs(NzpCsiRsResourceId),
    Ssb(Ssb),
    Srs(SrsResourceId),
    PositioningSrs(SrsPosResourceId),
    DlPrs(DlPrs),
    _Extended,
}

impl APerElement for ReferenceSignal {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        match u8::from_aper(decoder, UNCONSTRAINED)? {
            0 => Ok(Self::NzpCsiRs(NzpCsiRsResourceId::from_aper(
                decoder,
                UNCONSTRAINED,
            )?)),
            1 => Ok(Self::Ssb(Ssb::from_aper(decoder, UNCONSTRAINED)?)),
            2 => Ok(Self::Srs(SrsResourceId::from_aper(decoder, UNCONSTRAINED)?)),
            3 => Ok(Self::PositioningSrs(SrsPosResourceId::from_aper(
                decoder,
                UNCONSTRAINED,
            )?)),
            4 => Ok(Self::DlPrs(DlPrs::from_aper(decoder, UNCONSTRAINED)?)),
            5 => Err(DecodeError::NotImplemented),
            _ => Err(DecodeError::InvalidChoice),
        }
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        match self {
            Self::NzpCsiRs(x) => {
                enc.append(&(0 as u8).to_aper(UNCONSTRAINED)?)?;
                enc.append(&x.to_aper(UNCONSTRAINED)?)?;
            }
            Self::Ssb(x) => {
                enc.append(&(1 as u8).to_aper(UNCONSTRAINED)?)?;
                enc.append(&x.to_aper(UNCONSTRAINED)?)?;
            }
            Self::Srs(x) => {
                enc.append(&(2 as u8).to_aper(UNCONSTRAINED)?)?;
                enc.append(&x.to_aper(UNCONSTRAINED)?)?;
            }
            Self::PositioningSrs(x) => {
                enc.append(&(3 as u8).to_aper(UNCONSTRAINED)?)?;
                enc.append(&x.to_aper(UNCONSTRAINED)?)?;
            }
            Self::DlPrs(x) => {
                enc.append(&(4 as u8).to_aper(UNCONSTRAINED)?)?;
                enc.append(&x.to_aper(UNCONSTRAINED)?)?;
            }
            Self::_Extended => return Err(EncodeError::NotImplemented),
        }
        Ok(enc)
    }
}

// RelativeCartesianLocation
#[derive(Clone)]
pub struct RelativeCartesianLocation {
    pub xy_zunit: XyZunit,
    pub xvalue: u32,
    pub yvalue: u32,
    pub zvalue: u16,
    pub location_uncertainty: LocationUncertainty,
}

impl APerElement for RelativeCartesianLocation {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(1),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let _optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let xy_zunit = XyZunit::from_aper(decoder, UNCONSTRAINED)?;
        let xvalue = u32::from_aper(decoder, UNCONSTRAINED)?;
        let yvalue = u32::from_aper(decoder, UNCONSTRAINED)?;
        let zvalue = u16::from_aper(decoder, UNCONSTRAINED)?;
        let location_uncertainty = LocationUncertainty::from_aper(decoder, UNCONSTRAINED)?;

        Ok(Self {
            xy_zunit,
            xvalue,
            yvalue,
            zvalue,
            location_uncertainty,
        })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(1);
        optionals.set(0, false);

        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&self.xy_zunit.to_aper(UNCONSTRAINED)?)?;
        enc.append(&self.xvalue.to_aper(UNCONSTRAINED)?)?;
        enc.append(&self.yvalue.to_aper(UNCONSTRAINED)?)?;
        enc.append(&self.zvalue.to_aper(UNCONSTRAINED)?)?;
        enc.append(&self.location_uncertainty.to_aper(UNCONSTRAINED)?)?;

        Ok(enc)
    }
}

// RelativeGeodeticLocation
#[derive(Clone)]
pub struct RelativeGeodeticLocation {
    pub milli_arc_second_units: MilliArcSecondUnits,
    pub height_units: HeightUnits,
    pub delta_latitude: u16,
    pub delta_longitude: u16,
    pub delta_height: u16,
    pub location_uncertainty: LocationUncertainty,
}

impl APerElement for RelativeGeodeticLocation {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(1),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let _optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let milli_arc_second_units = MilliArcSecondUnits::from_aper(decoder, UNCONSTRAINED)?;
        let height_units = HeightUnits::from_aper(decoder, UNCONSTRAINED)?;
        let delta_latitude = u16::from_aper(decoder, UNCONSTRAINED)?;
        let delta_longitude = u16::from_aper(decoder, UNCONSTRAINED)?;
        let delta_height = u16::from_aper(decoder, UNCONSTRAINED)?;
        let location_uncertainty = LocationUncertainty::from_aper(decoder, UNCONSTRAINED)?;

        Ok(Self {
            milli_arc_second_units,
            height_units,
            delta_latitude,
            delta_longitude,
            delta_height,
            location_uncertainty,
        })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(1);
        optionals.set(0, false);

        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&self.milli_arc_second_units.to_aper(UNCONSTRAINED)?)?;
        enc.append(&self.height_units.to_aper(UNCONSTRAINED)?)?;
        enc.append(&self.delta_latitude.to_aper(UNCONSTRAINED)?)?;
        enc.append(&self.delta_longitude.to_aper(UNCONSTRAINED)?)?;
        enc.append(&self.delta_height.to_aper(UNCONSTRAINED)?)?;
        enc.append(&self.location_uncertainty.to_aper(UNCONSTRAINED)?)?;

        Ok(enc)
    }
}

// ReferenceTime
#[derive(Clone)]
pub struct ReferenceTime(pub Vec<u8>);

impl APerElement for ReferenceTime {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        Ok(Self(Vec::<u8>::from_aper(decoder, Self::CONSTRAINTS)?))
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&(self.0).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// RegistrationRequest
#[derive(Clone, Copy, FromPrimitive)]
pub enum RegistrationRequest {
    Start,
    Stop,
    Add,
    _Extended,
}

impl APerElement for RegistrationRequest {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        if bool::from_aper(decoder, Self::CONSTRAINTS)? {
            return Ok(RegistrationRequest::_Extended);
        }
        let v = u8::from_aper(decoder, Self::CONSTRAINTS)?;
        FromPrimitive::from_u8(v).ok_or(DecodeError::MalformedInt)
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&false.to_aper(UNCONSTRAINED)?)?;
        enc.append(&(*self as u8).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// ReportCharacteristics
#[derive(Clone)]
pub struct ReportCharacteristics(pub BitString);

impl APerElement for ReportCharacteristics {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(32),
            max: Some(32),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        Ok(Self(BitString::from_aper(decoder, Self::CONSTRAINTS)?))
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&(self.0).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// ReportingPeriodicity
#[derive(Clone, Copy, FromPrimitive)]
pub enum ReportingPeriodicity {
    Ms500,
    Ms1000,
    Ms2000,
    Ms5000,
    Ms10000,
    _Extended,
}

impl APerElement for ReportingPeriodicity {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        if bool::from_aper(decoder, Self::CONSTRAINTS)? {
            return Ok(ReportingPeriodicity::_Extended);
        }
        let v = u8::from_aper(decoder, Self::CONSTRAINTS)?;
        FromPrimitive::from_u8(v).ok_or(DecodeError::MalformedInt)
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&false.to_aper(UNCONSTRAINED)?)?;
        enc.append(&(*self as u8).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// RequestedBandCombinationIndex
#[derive(Clone)]
pub struct RequestedBandCombinationIndex(pub Vec<u8>);

impl APerElement for RequestedBandCombinationIndex {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        Ok(Self(Vec::<u8>::from_aper(decoder, Self::CONSTRAINTS)?))
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&(self.0).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// RequestedFeatureSetEntryIndex
#[derive(Clone)]
pub struct RequestedFeatureSetEntryIndex(pub Vec<u8>);

impl APerElement for RequestedFeatureSetEntryIndex {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        Ok(Self(Vec::<u8>::from_aper(decoder, Self::CONSTRAINTS)?))
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&(self.0).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// RequestedPMaxFr2
#[derive(Clone)]
pub struct RequestedPMaxFr2(pub Vec<u8>);

impl APerElement for RequestedPMaxFr2 {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        Ok(Self(Vec::<u8>::from_aper(decoder, Self::CONSTRAINTS)?))
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&(self.0).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// RequestedPdcchBlindDetectionScg
#[derive(Clone)]
pub struct RequestedPdcchBlindDetectionScg(pub Vec<u8>);

impl APerElement for RequestedPdcchBlindDetectionScg {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        Ok(Self(Vec::<u8>::from_aper(decoder, Self::CONSTRAINTS)?))
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&(self.0).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// RequestedSrsTransmissionCharacteristics
#[derive(Clone)]
pub struct RequestedSrsTransmissionCharacteristics {
    pub number_of_transmissions: Option<u16>,
    pub resource_type: ResourceType2,
    pub bandwidth_srs: BandwidthSrs,
    pub srs_resource_set_list: Option<SrsResourceSetList>,
    pub ssb_information: Option<SsbInformation>,
}

impl APerElement for RequestedSrsTransmissionCharacteristics {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(4),
            max: Some(4),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let number_of_transmissions = if optionals.is_set(0) {
            Some(u16::from_aper(decoder, UNCONSTRAINED)?)
        } else {
            None
        };
        let resource_type = ResourceType2::from_aper(decoder, UNCONSTRAINED)?;
        let bandwidth_srs = BandwidthSrs::from_aper(decoder, UNCONSTRAINED)?;
        let srs_resource_set_list = if optionals.is_set(0) {
            Some(SrsResourceSetList::from_aper(decoder, UNCONSTRAINED)?)
        } else {
            None
        };
        let ssb_information = if optionals.is_set(0) {
            Some(SsbInformation::from_aper(decoder, UNCONSTRAINED)?)
        } else {
            None
        };

        Ok(Self {
            number_of_transmissions,
            resource_type,
            bandwidth_srs,
            srs_resource_set_list,
            ssb_information,
        })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(4);
        optionals.set(0, self.number_of_transmissions.is_some());
        optionals.set(1, self.srs_resource_set_list.is_some());
        optionals.set(2, self.ssb_information.is_some());
        optionals.set(3, false);

        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        if let Some(x) = &self.number_of_transmissions {
            enc.append(&x.to_aper(UNCONSTRAINED)?)?;
        }
        enc.append(&self.resource_type.to_aper(UNCONSTRAINED)?)?;
        enc.append(&self.bandwidth_srs.to_aper(UNCONSTRAINED)?)?;
        if let Some(x) = &self.srs_resource_set_list {
            enc.append(&x.to_aper(UNCONSTRAINED)?)?;
        }
        if let Some(x) = &self.ssb_information {
            enc.append(&x.to_aper(UNCONSTRAINED)?)?;
        }

        Ok(enc)
    }
}

// RequestType
#[derive(Clone, Copy, FromPrimitive)]
pub enum RequestType {
    Offer,
    Execution,
    _Extended,
}

impl APerElement for RequestType {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        if bool::from_aper(decoder, Self::CONSTRAINTS)? {
            return Ok(RequestType::_Extended);
        }
        let v = u8::from_aper(decoder, Self::CONSTRAINTS)?;
        FromPrimitive::from_u8(v).ok_or(DecodeError::MalformedInt)
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&false.to_aper(UNCONSTRAINED)?)?;
        enc.append(&(*self as u8).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// ResourceCoordinationEutraCellInfo
#[derive(Clone)]
pub struct ResourceCoordinationEutraCellInfo {
    pub eutra_mode_info: EutraCoexModeInfo,
    pub eutra_prach_configuration: EutraPrachConfiguration,
}

impl APerElement for ResourceCoordinationEutraCellInfo {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(1),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let _extended = bool::from_aper(decoder, UNCONSTRAINED)?;
        let _optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let eutra_mode_info = EutraCoexModeInfo::from_aper(decoder, UNCONSTRAINED)?;
        let eutra_prach_configuration = EutraPrachConfiguration::from_aper(decoder, UNCONSTRAINED)?;

        Ok(Self {
            eutra_mode_info,
            eutra_prach_configuration,
        })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(1);
        optionals.set(0, false);

        enc.append(&false.to_aper(UNCONSTRAINED)?)?;
        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&self.eutra_mode_info.to_aper(UNCONSTRAINED)?)?;
        enc.append(&self.eutra_prach_configuration.to_aper(UNCONSTRAINED)?)?;

        Ok(enc)
    }
}

// ResourceCoordinationTransferInformation
#[derive(Clone)]
pub struct ResourceCoordinationTransferInformation {
    pub m_enb_cell_id: EutraCellId,
    pub resource_coordination_eutra_cell_info: Option<ResourceCoordinationEutraCellInfo>,
}

impl APerElement for ResourceCoordinationTransferInformation {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(2),
            max: Some(2),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let _extended = bool::from_aper(decoder, UNCONSTRAINED)?;
        let optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let m_enb_cell_id = EutraCellId::from_aper(decoder, UNCONSTRAINED)?;
        let resource_coordination_eutra_cell_info = if optionals.is_set(0) {
            Some(ResourceCoordinationEutraCellInfo::from_aper(
                decoder,
                UNCONSTRAINED,
            )?)
        } else {
            None
        };

        Ok(Self {
            m_enb_cell_id,
            resource_coordination_eutra_cell_info,
        })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(2);
        optionals.set(0, self.resource_coordination_eutra_cell_info.is_some());
        optionals.set(1, false);

        enc.append(&false.to_aper(UNCONSTRAINED)?)?;
        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&self.m_enb_cell_id.to_aper(UNCONSTRAINED)?)?;
        if let Some(x) = &self.resource_coordination_eutra_cell_info {
            enc.append(&x.to_aper(UNCONSTRAINED)?)?;
        }

        Ok(enc)
    }
}

// ResourceCoordinationTransferContainer
#[derive(Clone)]
pub struct ResourceCoordinationTransferContainer(pub Vec<u8>);

impl APerElement for ResourceCoordinationTransferContainer {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        Ok(Self(Vec::<u8>::from_aper(decoder, Self::CONSTRAINTS)?))
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&(self.0).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// ResourceSetType
#[derive(Clone)]
pub enum ResourceSetType {
    Periodic(ResourceSetTypePeriodic),
    SemiPersistent(ResourceSetTypeSemiPersistent),
    Aperiodic(ResourceSetTypeAperiodic),
    _Extended,
}

impl APerElement for ResourceSetType {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        match u8::from_aper(decoder, UNCONSTRAINED)? {
            0 => Ok(Self::Periodic(ResourceSetTypePeriodic::from_aper(
                decoder,
                UNCONSTRAINED,
            )?)),
            1 => Ok(Self::SemiPersistent(
                ResourceSetTypeSemiPersistent::from_aper(decoder, UNCONSTRAINED)?,
            )),
            2 => Ok(Self::Aperiodic(ResourceSetTypeAperiodic::from_aper(
                decoder,
                UNCONSTRAINED,
            )?)),
            3 => Err(DecodeError::NotImplemented),
            _ => Err(DecodeError::InvalidChoice),
        }
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        match self {
            Self::Periodic(x) => {
                enc.append(&(0 as u8).to_aper(UNCONSTRAINED)?)?;
                enc.append(&x.to_aper(UNCONSTRAINED)?)?;
            }
            Self::SemiPersistent(x) => {
                enc.append(&(1 as u8).to_aper(UNCONSTRAINED)?)?;
                enc.append(&x.to_aper(UNCONSTRAINED)?)?;
            }
            Self::Aperiodic(x) => {
                enc.append(&(2 as u8).to_aper(UNCONSTRAINED)?)?;
                enc.append(&x.to_aper(UNCONSTRAINED)?)?;
            }
            Self::_Extended => return Err(EncodeError::NotImplemented),
        }
        Ok(enc)
    }
}

// ResourceSetTypePeriodic
#[derive(Clone)]
pub struct ResourceSetTypePeriodic {
    pub periodic_set: PeriodicSet,
}

impl APerElement for ResourceSetTypePeriodic {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(1),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let _optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let periodic_set = PeriodicSet::from_aper(decoder, UNCONSTRAINED)?;

        Ok(Self { periodic_set })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(1);
        optionals.set(0, false);

        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&self.periodic_set.to_aper(UNCONSTRAINED)?)?;

        Ok(enc)
    }
}

// ResourceSetTypeSemiPersistent
#[derive(Clone)]
pub struct ResourceSetTypeSemiPersistent {
    pub semi_persistent_set: SemiPersistentSet,
}

impl APerElement for ResourceSetTypeSemiPersistent {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(1),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let _optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let semi_persistent_set = SemiPersistentSet::from_aper(decoder, UNCONSTRAINED)?;

        Ok(Self {
            semi_persistent_set,
        })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(1);
        optionals.set(0, false);

        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&self.semi_persistent_set.to_aper(UNCONSTRAINED)?)?;

        Ok(enc)
    }
}

// ResourceSetTypeAperiodic
#[derive(Clone)]
pub struct ResourceSetTypeAperiodic {
    pub srs_resource_trigger_list: u8,
    pub slotoffset: u8,
}

impl APerElement for ResourceSetTypeAperiodic {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(1),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let _optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let srs_resource_trigger_list = u8::from_aper(decoder, UNCONSTRAINED)?;
        let slotoffset = u8::from_aper(decoder, UNCONSTRAINED)?;

        Ok(Self {
            srs_resource_trigger_list,
            slotoffset,
        })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(1);
        optionals.set(0, false);

        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&self.srs_resource_trigger_list.to_aper(UNCONSTRAINED)?)?;
        enc.append(&self.slotoffset.to_aper(UNCONSTRAINED)?)?;

        Ok(enc)
    }
}

// RepetitionPeriod
#[derive(Clone)]
pub struct RepetitionPeriod(pub u32);

impl APerElement for RepetitionPeriod {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(0),
            max: Some(131071),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        Ok(Self(u32::from_aper(decoder, Self::CONSTRAINTS)?))
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&(self.0).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// ReportingRequestType
#[derive(Clone)]
pub struct ReportingRequestType {
    pub event_type: EventType,
    pub reporting_periodicity_value: Option<ReportingPeriodicityValue>,
}

impl APerElement for ReportingRequestType {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(2),
            max: Some(2),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let event_type = EventType::from_aper(decoder, UNCONSTRAINED)?;
        let reporting_periodicity_value = if optionals.is_set(0) {
            Some(ReportingPeriodicityValue::from_aper(
                decoder,
                UNCONSTRAINED,
            )?)
        } else {
            None
        };

        Ok(Self {
            event_type,
            reporting_periodicity_value,
        })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(2);
        optionals.set(0, self.reporting_periodicity_value.is_some());
        optionals.set(1, false);

        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&self.event_type.to_aper(UNCONSTRAINED)?)?;
        if let Some(x) = &self.reporting_periodicity_value {
            enc.append(&x.to_aper(UNCONSTRAINED)?)?;
        }

        Ok(enc)
    }
}

// ResourceType
#[derive(Clone)]
pub enum ResourceType {
    Periodic(ResourceTypePeriodic),
    SemiPersistent(ResourceTypeSemiPersistent),
    Aperiodic(ResourceTypeAperiodic),
    _Extended,
}

impl APerElement for ResourceType {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        match u8::from_aper(decoder, UNCONSTRAINED)? {
            0 => Ok(Self::Periodic(ResourceTypePeriodic::from_aper(
                decoder,
                UNCONSTRAINED,
            )?)),
            1 => Ok(Self::SemiPersistent(ResourceTypeSemiPersistent::from_aper(
                decoder,
                UNCONSTRAINED,
            )?)),
            2 => Ok(Self::Aperiodic(ResourceTypeAperiodic::from_aper(
                decoder,
                UNCONSTRAINED,
            )?)),
            3 => Err(DecodeError::NotImplemented),
            _ => Err(DecodeError::InvalidChoice),
        }
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        match self {
            Self::Periodic(x) => {
                enc.append(&(0 as u8).to_aper(UNCONSTRAINED)?)?;
                enc.append(&x.to_aper(UNCONSTRAINED)?)?;
            }
            Self::SemiPersistent(x) => {
                enc.append(&(1 as u8).to_aper(UNCONSTRAINED)?)?;
                enc.append(&x.to_aper(UNCONSTRAINED)?)?;
            }
            Self::Aperiodic(x) => {
                enc.append(&(2 as u8).to_aper(UNCONSTRAINED)?)?;
                enc.append(&x.to_aper(UNCONSTRAINED)?)?;
            }
            Self::_Extended => return Err(EncodeError::NotImplemented),
        }
        Ok(enc)
    }
}

// ResourceTypePeriodic
#[derive(Clone)]
pub struct ResourceTypePeriodic {
    pub periodicity: Periodicity1,
    pub offset: u16,
}

impl APerElement for ResourceTypePeriodic {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(1),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let _optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let periodicity = Periodicity1::from_aper(decoder, UNCONSTRAINED)?;
        let offset = u16::from_aper(decoder, UNCONSTRAINED)?;

        Ok(Self {
            periodicity,
            offset,
        })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(1);
        optionals.set(0, false);

        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&self.periodicity.to_aper(UNCONSTRAINED)?)?;
        enc.append(&self.offset.to_aper(UNCONSTRAINED)?)?;

        Ok(enc)
    }
}

// ResourceTypeSemiPersistent
#[derive(Clone)]
pub struct ResourceTypeSemiPersistent {
    pub periodicity: Periodicity2,
    pub offset: u16,
}

impl APerElement for ResourceTypeSemiPersistent {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(1),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let _optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let periodicity = Periodicity2::from_aper(decoder, UNCONSTRAINED)?;
        let offset = u16::from_aper(decoder, UNCONSTRAINED)?;

        Ok(Self {
            periodicity,
            offset,
        })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(1);
        optionals.set(0, false);

        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&self.periodicity.to_aper(UNCONSTRAINED)?)?;
        enc.append(&self.offset.to_aper(UNCONSTRAINED)?)?;

        Ok(enc)
    }
}

// ResourceTypeAperiodic
#[derive(Clone)]
pub struct ResourceTypeAperiodic {
    pub aperiodic_resource_type: AperiodicResourceType,
}

impl APerElement for ResourceTypeAperiodic {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(1),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let _optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let aperiodic_resource_type = AperiodicResourceType::from_aper(decoder, UNCONSTRAINED)?;

        Ok(Self {
            aperiodic_resource_type,
        })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(1);
        optionals.set(0, false);

        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&self.aperiodic_resource_type.to_aper(UNCONSTRAINED)?)?;

        Ok(enc)
    }
}

// ResourceTypePos
#[derive(Clone)]
pub enum ResourceTypePos {
    Periodic(ResourceTypePeriodicPos),
    SemiPersistent(ResourceTypeSemiPersistentPos),
    Aperiodic(ResourceTypeAperiodicPos),
    _Extended,
}

impl APerElement for ResourceTypePos {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        match u8::from_aper(decoder, UNCONSTRAINED)? {
            0 => Ok(Self::Periodic(ResourceTypePeriodicPos::from_aper(
                decoder,
                UNCONSTRAINED,
            )?)),
            1 => Ok(Self::SemiPersistent(
                ResourceTypeSemiPersistentPos::from_aper(decoder, UNCONSTRAINED)?,
            )),
            2 => Ok(Self::Aperiodic(ResourceTypeAperiodicPos::from_aper(
                decoder,
                UNCONSTRAINED,
            )?)),
            3 => Err(DecodeError::NotImplemented),
            _ => Err(DecodeError::InvalidChoice),
        }
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        match self {
            Self::Periodic(x) => {
                enc.append(&(0 as u8).to_aper(UNCONSTRAINED)?)?;
                enc.append(&x.to_aper(UNCONSTRAINED)?)?;
            }
            Self::SemiPersistent(x) => {
                enc.append(&(1 as u8).to_aper(UNCONSTRAINED)?)?;
                enc.append(&x.to_aper(UNCONSTRAINED)?)?;
            }
            Self::Aperiodic(x) => {
                enc.append(&(2 as u8).to_aper(UNCONSTRAINED)?)?;
                enc.append(&x.to_aper(UNCONSTRAINED)?)?;
            }
            Self::_Extended => return Err(EncodeError::NotImplemented),
        }
        Ok(enc)
    }
}

// ResourceTypePeriodicPos
#[derive(Clone)]
pub struct ResourceTypePeriodicPos {
    pub periodicity: Periodicity3,
    pub offset: u32,
}

impl APerElement for ResourceTypePeriodicPos {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(1),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let _optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let periodicity = Periodicity3::from_aper(decoder, UNCONSTRAINED)?;
        let offset = u32::from_aper(decoder, UNCONSTRAINED)?;

        Ok(Self {
            periodicity,
            offset,
        })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(1);
        optionals.set(0, false);

        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&self.periodicity.to_aper(UNCONSTRAINED)?)?;
        enc.append(&self.offset.to_aper(UNCONSTRAINED)?)?;

        Ok(enc)
    }
}

// ResourceTypeSemiPersistentPos
#[derive(Clone)]
pub struct ResourceTypeSemiPersistentPos {
    pub periodicity: Periodicity4,
    pub offset: u32,
}

impl APerElement for ResourceTypeSemiPersistentPos {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(1),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let _optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let periodicity = Periodicity4::from_aper(decoder, UNCONSTRAINED)?;
        let offset = u32::from_aper(decoder, UNCONSTRAINED)?;

        Ok(Self {
            periodicity,
            offset,
        })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(1);
        optionals.set(0, false);

        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&self.periodicity.to_aper(UNCONSTRAINED)?)?;
        enc.append(&self.offset.to_aper(UNCONSTRAINED)?)?;

        Ok(enc)
    }
}

// ResourceTypeAperiodicPos
#[derive(Clone)]
pub struct ResourceTypeAperiodicPos {
    pub slot_offset: u8,
}

impl APerElement for ResourceTypeAperiodicPos {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(1),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let _optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let slot_offset = u8::from_aper(decoder, UNCONSTRAINED)?;

        Ok(Self { slot_offset })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(1);
        optionals.set(0, false);

        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&self.slot_offset.to_aper(UNCONSTRAINED)?)?;

        Ok(enc)
    }
}

// RlcDuplicationInformation
#[derive(Clone)]
pub struct RlcDuplicationInformation {
    pub rlc_duplication_state_list: RlcDuplicationStateList,
    pub primary_path_indication: Option<PrimaryPathIndication>,
}

impl APerElement for RlcDuplicationInformation {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(2),
            max: Some(2),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let rlc_duplication_state_list =
            RlcDuplicationStateList::from_aper(decoder, UNCONSTRAINED)?;
        let primary_path_indication = if optionals.is_set(0) {
            Some(PrimaryPathIndication::from_aper(decoder, UNCONSTRAINED)?)
        } else {
            None
        };

        Ok(Self {
            rlc_duplication_state_list,
            primary_path_indication,
        })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(2);
        optionals.set(0, self.primary_path_indication.is_some());
        optionals.set(1, false);

        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&self.rlc_duplication_state_list.to_aper(UNCONSTRAINED)?)?;
        if let Some(x) = &self.primary_path_indication {
            enc.append(&x.to_aper(UNCONSTRAINED)?)?;
        }

        Ok(enc)
    }
}

// RlcDuplicationStateList
#[derive(Clone)]
pub struct RlcDuplicationStateList(pub Vec<RlcDuplicationStateItem>);

impl APerElement for RlcDuplicationStateList {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(1),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        Ok(Self(Vec::<RlcDuplicationStateItem>::from_aper(
            decoder,
            Self::CONSTRAINTS,
        )?))
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&(self.0).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// RlcDuplicationStateItem
#[derive(Clone)]
pub struct RlcDuplicationStateItem {
    pub duplication_state: DuplicationState,
}

impl APerElement for RlcDuplicationStateItem {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(1),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let _extended = bool::from_aper(decoder, UNCONSTRAINED)?;
        let _optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let duplication_state = DuplicationState::from_aper(decoder, UNCONSTRAINED)?;

        Ok(Self { duplication_state })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(1);
        optionals.set(0, false);

        enc.append(&false.to_aper(UNCONSTRAINED)?)?;
        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&self.duplication_state.to_aper(UNCONSTRAINED)?)?;

        Ok(enc)
    }
}

// RlcFailureIndication
#[derive(Clone)]
pub struct RlcFailureIndication {
    pub assocated_lcid: Lcid,
}

impl APerElement for RlcFailureIndication {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(1),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let _optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let assocated_lcid = Lcid::from_aper(decoder, UNCONSTRAINED)?;

        Ok(Self { assocated_lcid })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(1);
        optionals.set(0, false);

        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&self.assocated_lcid.to_aper(UNCONSTRAINED)?)?;

        Ok(enc)
    }
}

// RlcMode
#[derive(Clone, Copy, FromPrimitive)]
pub enum RlcMode {
    RlcAm,
    RlcUmBidirectional,
    RlcUmUnidirectionalUl,
    RlcUmUnidirectionalDl,
    _Extended,
}

impl APerElement for RlcMode {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        if bool::from_aper(decoder, Self::CONSTRAINTS)? {
            return Ok(RlcMode::_Extended);
        }
        let v = u8::from_aper(decoder, Self::CONSTRAINTS)?;
        FromPrimitive::from_u8(v).ok_or(DecodeError::MalformedInt)
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&false.to_aper(UNCONSTRAINED)?)?;
        enc.append(&(*self as u8).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// RlcStatus
#[derive(Clone)]
pub struct RlcStatus {
    pub reestablishment_indication: ReestablishmentIndication,
}

impl APerElement for RlcStatus {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(1),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let _extended = bool::from_aper(decoder, UNCONSTRAINED)?;
        let _optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let reestablishment_indication =
            ReestablishmentIndication::from_aper(decoder, UNCONSTRAINED)?;

        Ok(Self {
            reestablishment_indication,
        })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(1);
        optionals.set(0, false);

        enc.append(&false.to_aper(UNCONSTRAINED)?)?;
        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&self.reestablishment_indication.to_aper(UNCONSTRAINED)?)?;

        Ok(enc)
    }
}

// RlfReportInformationList
#[derive(Clone)]
pub struct RlfReportInformationList(pub Vec<RlfReportInformationItem>);

impl APerElement for RlfReportInformationList {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(1),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        Ok(Self(Vec::<RlfReportInformationItem>::from_aper(
            decoder,
            Self::CONSTRAINTS,
        )?))
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&(self.0).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// RlfReportInformationItem
#[derive(Clone)]
pub struct RlfReportInformationItem {
    pub nrue_rlf_report_container: NrueRlfReportContainer,
    pub ue_assitant_identifier: Option<GnbDuUeF1apId>,
}

impl APerElement for RlfReportInformationItem {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(2),
            max: Some(2),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let _extended = bool::from_aper(decoder, UNCONSTRAINED)?;
        let optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let nrue_rlf_report_container = NrueRlfReportContainer::from_aper(decoder, UNCONSTRAINED)?;
        let ue_assitant_identifier = if optionals.is_set(0) {
            Some(GnbDuUeF1apId::from_aper(decoder, UNCONSTRAINED)?)
        } else {
            None
        };

        Ok(Self {
            nrue_rlf_report_container,
            ue_assitant_identifier,
        })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(2);
        optionals.set(0, self.ue_assitant_identifier.is_some());
        optionals.set(1, false);

        enc.append(&false.to_aper(UNCONSTRAINED)?)?;
        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&self.nrue_rlf_report_container.to_aper(UNCONSTRAINED)?)?;
        if let Some(x) = &self.ue_assitant_identifier {
            enc.append(&x.to_aper(UNCONSTRAINED)?)?;
        }

        Ok(enc)
    }
}

// RimrsDetectionStatus
#[derive(Clone, Copy, FromPrimitive)]
pub enum RimrsDetectionStatus {
    RsDetected,
    RsDisappeared,
    _Extended,
}

impl APerElement for RimrsDetectionStatus {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        if bool::from_aper(decoder, Self::CONSTRAINTS)? {
            return Ok(RimrsDetectionStatus::_Extended);
        }
        let v = u8::from_aper(decoder, Self::CONSTRAINTS)?;
        FromPrimitive::from_u8(v).ok_or(DecodeError::MalformedInt)
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&false.to_aper(UNCONSTRAINED)?)?;
        enc.append(&(*self as u8).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// RrcContainer
#[derive(Clone)]
pub struct RrcContainer(pub Vec<u8>);

impl APerElement for RrcContainer {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        Ok(Self(Vec::<u8>::from_aper(decoder, Self::CONSTRAINTS)?))
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&(self.0).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// RrcContainerRrcSetupComplete
#[derive(Clone)]
pub struct RrcContainerRrcSetupComplete(pub Vec<u8>);

impl APerElement for RrcContainerRrcSetupComplete {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        Ok(Self(Vec::<u8>::from_aper(decoder, Self::CONSTRAINTS)?))
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&(self.0).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// RrcDeliveryStatus
#[derive(Clone)]
pub struct RrcDeliveryStatus {
    pub delivery_status: PdcpSn,
    pub triggering_message: PdcpSn,
}

impl APerElement for RrcDeliveryStatus {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(1),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let _optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let delivery_status = PdcpSn::from_aper(decoder, UNCONSTRAINED)?;
        let triggering_message = PdcpSn::from_aper(decoder, UNCONSTRAINED)?;

        Ok(Self {
            delivery_status,
            triggering_message,
        })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(1);
        optionals.set(0, false);

        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&self.delivery_status.to_aper(UNCONSTRAINED)?)?;
        enc.append(&self.triggering_message.to_aper(UNCONSTRAINED)?)?;

        Ok(enc)
    }
}

// RrcDeliveryStatusRequest
#[derive(Clone, Copy, FromPrimitive)]
pub enum RrcDeliveryStatusRequest {
    True,
    _Extended,
}

impl APerElement for RrcDeliveryStatusRequest {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        if bool::from_aper(decoder, Self::CONSTRAINTS)? {
            return Ok(RrcDeliveryStatusRequest::_Extended);
        }
        let v = u8::from_aper(decoder, Self::CONSTRAINTS)?;
        FromPrimitive::from_u8(v).ok_or(DecodeError::MalformedInt)
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&false.to_aper(UNCONSTRAINED)?)?;
        enc.append(&(*self as u8).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// RrcReconfigurationCompleteIndicator
#[derive(Clone, Copy, FromPrimitive)]
pub enum RrcReconfigurationCompleteIndicator {
    True,
    _Extended,
}

impl APerElement for RrcReconfigurationCompleteIndicator {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        if bool::from_aper(decoder, Self::CONSTRAINTS)? {
            return Ok(RrcReconfigurationCompleteIndicator::_Extended);
        }
        let v = u8::from_aper(decoder, Self::CONSTRAINTS)?;
        FromPrimitive::from_u8(v).ok_or(DecodeError::MalformedInt)
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&false.to_aper(UNCONSTRAINED)?)?;
        enc.append(&(*self as u8).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// RrcVersion
#[derive(Clone)]
pub struct RrcVersion {
    pub latest_rrc_version: BitString,
}

impl APerElement for RrcVersion {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(1),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let _optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let latest_rrc_version = BitString::from_aper(
            decoder,
            Constraints {
                value: None,
                size: Some(Constraint::new(Some(3), Some(3))),
            },
        )?;

        Ok(Self { latest_rrc_version })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(1);
        optionals.set(0, false);

        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&self.latest_rrc_version.to_aper(UNCONSTRAINED)?)?;

        Ok(enc)
    }
}

// RoutingId
#[derive(Clone)]
pub struct RoutingId(pub Vec<u8>);

impl APerElement for RoutingId {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        Ok(Self(Vec::<u8>::from_aper(decoder, Self::CONSTRAINTS)?))
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&(self.0).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// SCellFailedtoSetupItem
#[derive(Clone)]
pub struct SCellFailedtoSetupItem {
    pub s_cell_id: Nrcgi,
    pub cause: Option<Cause>,
}

impl APerElement for SCellFailedtoSetupItem {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(2),
            max: Some(2),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let _extended = bool::from_aper(decoder, UNCONSTRAINED)?;
        let optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let s_cell_id = Nrcgi::from_aper(decoder, UNCONSTRAINED)?;
        let cause = if optionals.is_set(0) {
            Some(Cause::from_aper(decoder, UNCONSTRAINED)?)
        } else {
            None
        };

        Ok(Self { s_cell_id, cause })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(2);
        optionals.set(0, self.cause.is_some());
        optionals.set(1, false);

        enc.append(&false.to_aper(UNCONSTRAINED)?)?;
        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&self.s_cell_id.to_aper(UNCONSTRAINED)?)?;
        if let Some(x) = &self.cause {
            enc.append(&x.to_aper(UNCONSTRAINED)?)?;
        }

        Ok(enc)
    }
}

// SCellFailedtoSetupModItem
#[derive(Clone)]
pub struct SCellFailedtoSetupModItem {
    pub s_cell_id: Nrcgi,
    pub cause: Option<Cause>,
}

impl APerElement for SCellFailedtoSetupModItem {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(2),
            max: Some(2),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let _extended = bool::from_aper(decoder, UNCONSTRAINED)?;
        let optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let s_cell_id = Nrcgi::from_aper(decoder, UNCONSTRAINED)?;
        let cause = if optionals.is_set(0) {
            Some(Cause::from_aper(decoder, UNCONSTRAINED)?)
        } else {
            None
        };

        Ok(Self { s_cell_id, cause })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(2);
        optionals.set(0, self.cause.is_some());
        optionals.set(1, false);

        enc.append(&false.to_aper(UNCONSTRAINED)?)?;
        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&self.s_cell_id.to_aper(UNCONSTRAINED)?)?;
        if let Some(x) = &self.cause {
            enc.append(&x.to_aper(UNCONSTRAINED)?)?;
        }

        Ok(enc)
    }
}

// SCellToBeRemovedItem
#[derive(Clone)]
pub struct SCellToBeRemovedItem {
    pub s_cell_id: Nrcgi,
}

impl APerElement for SCellToBeRemovedItem {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(1),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let _extended = bool::from_aper(decoder, UNCONSTRAINED)?;
        let _optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let s_cell_id = Nrcgi::from_aper(decoder, UNCONSTRAINED)?;

        Ok(Self { s_cell_id })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(1);
        optionals.set(0, false);

        enc.append(&false.to_aper(UNCONSTRAINED)?)?;
        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&self.s_cell_id.to_aper(UNCONSTRAINED)?)?;

        Ok(enc)
    }
}

// SCellToBeSetupItem
#[derive(Clone)]
pub struct SCellToBeSetupItem {
    pub s_cell_id: Nrcgi,
    pub s_cell_index: SCellIndex,
    pub s_cell_ul_configured: Option<CellUlConfigured>,
}

impl APerElement for SCellToBeSetupItem {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(2),
            max: Some(2),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let _extended = bool::from_aper(decoder, UNCONSTRAINED)?;
        let optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let s_cell_id = Nrcgi::from_aper(decoder, UNCONSTRAINED)?;
        let s_cell_index = SCellIndex::from_aper(decoder, UNCONSTRAINED)?;
        let s_cell_ul_configured = if optionals.is_set(0) {
            Some(CellUlConfigured::from_aper(decoder, UNCONSTRAINED)?)
        } else {
            None
        };

        Ok(Self {
            s_cell_id,
            s_cell_index,
            s_cell_ul_configured,
        })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(2);
        optionals.set(0, self.s_cell_ul_configured.is_some());
        optionals.set(1, false);

        enc.append(&false.to_aper(UNCONSTRAINED)?)?;
        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&self.s_cell_id.to_aper(UNCONSTRAINED)?)?;
        enc.append(&self.s_cell_index.to_aper(UNCONSTRAINED)?)?;
        if let Some(x) = &self.s_cell_ul_configured {
            enc.append(&x.to_aper(UNCONSTRAINED)?)?;
        }

        Ok(enc)
    }
}

// SCellToBeSetupModItem
#[derive(Clone)]
pub struct SCellToBeSetupModItem {
    pub s_cell_id: Nrcgi,
    pub s_cell_index: SCellIndex,
    pub s_cell_ul_configured: Option<CellUlConfigured>,
}

impl APerElement for SCellToBeSetupModItem {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(2),
            max: Some(2),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let _extended = bool::from_aper(decoder, UNCONSTRAINED)?;
        let optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let s_cell_id = Nrcgi::from_aper(decoder, UNCONSTRAINED)?;
        let s_cell_index = SCellIndex::from_aper(decoder, UNCONSTRAINED)?;
        let s_cell_ul_configured = if optionals.is_set(0) {
            Some(CellUlConfigured::from_aper(decoder, UNCONSTRAINED)?)
        } else {
            None
        };

        Ok(Self {
            s_cell_id,
            s_cell_index,
            s_cell_ul_configured,
        })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(2);
        optionals.set(0, self.s_cell_ul_configured.is_some());
        optionals.set(1, false);

        enc.append(&false.to_aper(UNCONSTRAINED)?)?;
        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&self.s_cell_id.to_aper(UNCONSTRAINED)?)?;
        enc.append(&self.s_cell_index.to_aper(UNCONSTRAINED)?)?;
        if let Some(x) = &self.s_cell_ul_configured {
            enc.append(&x.to_aper(UNCONSTRAINED)?)?;
        }

        Ok(enc)
    }
}

// SCellIndex
#[derive(Clone)]
pub struct SCellIndex(pub u8);

impl APerElement for SCellIndex {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(31),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        Ok(Self(u8::from_aper(decoder, Self::CONSTRAINTS)?))
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&(self.0).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// ScgIndicator
#[derive(Clone, Copy, FromPrimitive)]
pub enum ScgIndicator {
    Released,
    _Extended,
}

impl APerElement for ScgIndicator {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        if bool::from_aper(decoder, Self::CONSTRAINTS)? {
            return Ok(ScgIndicator::_Extended);
        }
        let v = u8::from_aper(decoder, Self::CONSTRAINTS)?;
        FromPrimitive::from_u8(v).ok_or(DecodeError::MalformedInt)
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&false.to_aper(UNCONSTRAINED)?)?;
        enc.append(&(*self as u8).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// ScsSpecificCarrier
#[derive(Clone)]
pub struct ScsSpecificCarrier {
    pub offset_to_carrier: u16,
    pub subcarrier_spacing: SubcarrierSpacing3,
    pub carrier_bandwidth: u16,
}

impl APerElement for ScsSpecificCarrier {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(1),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let _optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let offset_to_carrier = u16::from_aper(decoder, UNCONSTRAINED)?;
        let subcarrier_spacing = SubcarrierSpacing3::from_aper(decoder, UNCONSTRAINED)?;
        let carrier_bandwidth = u16::from_aper(decoder, UNCONSTRAINED)?;

        Ok(Self {
            offset_to_carrier,
            subcarrier_spacing,
            carrier_bandwidth,
        })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(1);
        optionals.set(0, false);

        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&self.offset_to_carrier.to_aper(UNCONSTRAINED)?)?;
        enc.append(&self.subcarrier_spacing.to_aper(UNCONSTRAINED)?)?;
        enc.append(&self.carrier_bandwidth.to_aper(UNCONSTRAINED)?)?;

        Ok(enc)
    }
}

// SearchWindowInformation
#[derive(Clone)]
pub struct SearchWindowInformation {
    pub expected_propagation_delay: u16,
    pub delay_uncertainty: u8,
}

impl APerElement for SearchWindowInformation {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(1),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let _optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let expected_propagation_delay = u16::from_aper(decoder, UNCONSTRAINED)?;
        let delay_uncertainty = u8::from_aper(decoder, UNCONSTRAINED)?;

        Ok(Self {
            expected_propagation_delay,
            delay_uncertainty,
        })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(1);
        optionals.set(0, false);

        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&self.expected_propagation_delay.to_aper(UNCONSTRAINED)?)?;
        enc.append(&self.delay_uncertainty.to_aper(UNCONSTRAINED)?)?;

        Ok(enc)
    }
}

// SerialNumber
#[derive(Clone)]
pub struct SerialNumber(pub BitString);

impl APerElement for SerialNumber {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(16),
            max: Some(16),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        Ok(Self(BitString::from_aper(decoder, Self::CONSTRAINTS)?))
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&(self.0).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// SibTypePws
#[derive(Clone)]
pub struct SibTypePws(pub u8);

impl APerElement for SibTypePws {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(6),
            max: Some(8),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        Ok(Self(u8::from_aper(decoder, Self::CONSTRAINTS)?))
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&(self.0).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// SelectedBandCombinationIndex
#[derive(Clone)]
pub struct SelectedBandCombinationIndex(pub Vec<u8>);

impl APerElement for SelectedBandCombinationIndex {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        Ok(Self(Vec::<u8>::from_aper(decoder, Self::CONSTRAINTS)?))
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&(self.0).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// SelectedFeatureSetEntryIndex
#[derive(Clone)]
pub struct SelectedFeatureSetEntryIndex(pub Vec<u8>);

impl APerElement for SelectedFeatureSetEntryIndex {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        Ok(Self(Vec::<u8>::from_aper(decoder, Self::CONSTRAINTS)?))
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&(self.0).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// CgConfigInfo
#[derive(Clone)]
pub struct CgConfigInfo(pub Vec<u8>);

impl APerElement for CgConfigInfo {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        Ok(Self(Vec::<u8>::from_aper(decoder, Self::CONSTRAINTS)?))
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&(self.0).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// ServCellIndex
#[derive(Clone)]
pub struct ServCellIndex(pub u8);

impl APerElement for ServCellIndex {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(0),
            max: Some(31),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        Ok(Self(u8::from_aper(decoder, Self::CONSTRAINTS)?))
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&(self.0).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// ServingCellMo
#[derive(Clone)]
pub struct ServingCellMo(pub u8);

impl APerElement for ServingCellMo {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(64),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        Ok(Self(u8::from_aper(decoder, Self::CONSTRAINTS)?))
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&(self.0).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// ServedCellInformation
#[derive(Clone)]
pub struct ServedCellInformation {
    pub nrcgi: Nrcgi,
    pub nrpci: Nrpci,
    pub five_gs_tac: Option<FiveGsTac>,
    pub configured_eps_tac: Option<ConfiguredEpsTac>,
    pub served_plmn_s: ServedPlmnSList,
    pub nr_mode_info: NrModeInfo,
    pub measurement_timing_configuration: Vec<u8>,
}

impl APerElement for ServedCellInformation {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(3),
            max: Some(3),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let _extended = bool::from_aper(decoder, UNCONSTRAINED)?;
        let optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let nrcgi = Nrcgi::from_aper(decoder, UNCONSTRAINED)?;
        let nrpci = Nrpci::from_aper(decoder, UNCONSTRAINED)?;
        let five_gs_tac = if optionals.is_set(0) {
            Some(FiveGsTac::from_aper(decoder, UNCONSTRAINED)?)
        } else {
            None
        };
        let configured_eps_tac = if optionals.is_set(0) {
            Some(ConfiguredEpsTac::from_aper(decoder, UNCONSTRAINED)?)
        } else {
            None
        };
        let served_plmn_s = ServedPlmnSList::from_aper(decoder, UNCONSTRAINED)?;
        let nr_mode_info = NrModeInfo::from_aper(decoder, UNCONSTRAINED)?;
        let measurement_timing_configuration = Vec::<u8>::from_aper(decoder, UNCONSTRAINED)?;

        Ok(Self {
            nrcgi,
            nrpci,
            five_gs_tac,
            configured_eps_tac,
            served_plmn_s,
            nr_mode_info,
            measurement_timing_configuration,
        })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(3);
        optionals.set(0, self.five_gs_tac.is_some());
        optionals.set(1, self.configured_eps_tac.is_some());
        optionals.set(2, false);

        enc.append(&false.to_aper(UNCONSTRAINED)?)?;
        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&self.nrcgi.to_aper(UNCONSTRAINED)?)?;
        enc.append(&self.nrpci.to_aper(UNCONSTRAINED)?)?;
        if let Some(x) = &self.five_gs_tac {
            enc.append(&x.to_aper(UNCONSTRAINED)?)?;
        }
        if let Some(x) = &self.configured_eps_tac {
            enc.append(&x.to_aper(UNCONSTRAINED)?)?;
        }
        enc.append(&self.served_plmn_s.to_aper(UNCONSTRAINED)?)?;
        enc.append(&self.nr_mode_info.to_aper(UNCONSTRAINED)?)?;
        enc.append(
            &self
                .measurement_timing_configuration
                .to_aper(UNCONSTRAINED)?,
        )?;

        Ok(enc)
    }
}

// SfnOffset
#[derive(Clone)]
pub struct SfnOffset {
    pub sfn_time_offset: BitString,
}

impl APerElement for SfnOffset {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(1),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let _extended = bool::from_aper(decoder, UNCONSTRAINED)?;
        let _optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let sfn_time_offset = BitString::from_aper(
            decoder,
            Constraints {
                value: None,
                size: Some(Constraint::new(Some(24), Some(24))),
            },
        )?;

        Ok(Self { sfn_time_offset })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(1);
        optionals.set(0, false);

        enc.append(&false.to_aper(UNCONSTRAINED)?)?;
        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&self.sfn_time_offset.to_aper(UNCONSTRAINED)?)?;

        Ok(enc)
    }
}

// ServedCellsToAddItem
#[derive(Clone)]
pub struct ServedCellsToAddItem {
    pub served_cell_information: ServedCellInformation,
    pub gnb_du_system_information: Option<GnbDuSystemInformation>,
}

impl APerElement for ServedCellsToAddItem {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(2),
            max: Some(2),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let _extended = bool::from_aper(decoder, UNCONSTRAINED)?;
        let optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let served_cell_information = ServedCellInformation::from_aper(decoder, UNCONSTRAINED)?;
        let gnb_du_system_information = if optionals.is_set(0) {
            Some(GnbDuSystemInformation::from_aper(decoder, UNCONSTRAINED)?)
        } else {
            None
        };

        Ok(Self {
            served_cell_information,
            gnb_du_system_information,
        })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(2);
        optionals.set(0, self.gnb_du_system_information.is_some());
        optionals.set(1, false);

        enc.append(&false.to_aper(UNCONSTRAINED)?)?;
        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&self.served_cell_information.to_aper(UNCONSTRAINED)?)?;
        if let Some(x) = &self.gnb_du_system_information {
            enc.append(&x.to_aper(UNCONSTRAINED)?)?;
        }

        Ok(enc)
    }
}

// ServedCellsToDeleteItem
#[derive(Clone)]
pub struct ServedCellsToDeleteItem {
    pub old_nrcgi: Nrcgi,
}

impl APerElement for ServedCellsToDeleteItem {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(1),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let _extended = bool::from_aper(decoder, UNCONSTRAINED)?;
        let _optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let old_nrcgi = Nrcgi::from_aper(decoder, UNCONSTRAINED)?;

        Ok(Self { old_nrcgi })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(1);
        optionals.set(0, false);

        enc.append(&false.to_aper(UNCONSTRAINED)?)?;
        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&self.old_nrcgi.to_aper(UNCONSTRAINED)?)?;

        Ok(enc)
    }
}

// ServedCellsToModifyItem
#[derive(Clone)]
pub struct ServedCellsToModifyItem {
    pub old_nrcgi: Nrcgi,
    pub served_cell_information: ServedCellInformation,
    pub gnb_du_system_information: Option<GnbDuSystemInformation>,
}

impl APerElement for ServedCellsToModifyItem {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(2),
            max: Some(2),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let _extended = bool::from_aper(decoder, UNCONSTRAINED)?;
        let optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let old_nrcgi = Nrcgi::from_aper(decoder, UNCONSTRAINED)?;
        let served_cell_information = ServedCellInformation::from_aper(decoder, UNCONSTRAINED)?;
        let gnb_du_system_information = if optionals.is_set(0) {
            Some(GnbDuSystemInformation::from_aper(decoder, UNCONSTRAINED)?)
        } else {
            None
        };

        Ok(Self {
            old_nrcgi,
            served_cell_information,
            gnb_du_system_information,
        })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(2);
        optionals.set(0, self.gnb_du_system_information.is_some());
        optionals.set(1, false);

        enc.append(&false.to_aper(UNCONSTRAINED)?)?;
        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&self.old_nrcgi.to_aper(UNCONSTRAINED)?)?;
        enc.append(&self.served_cell_information.to_aper(UNCONSTRAINED)?)?;
        if let Some(x) = &self.gnb_du_system_information {
            enc.append(&x.to_aper(UNCONSTRAINED)?)?;
        }

        Ok(enc)
    }
}

// ServedEutraCellsInformation
#[derive(Clone)]
pub struct ServedEutraCellsInformation {
    pub eutra_mode_info: EutraModeInfo,
    pub protected_eutra_resource_indication: ProtectedEutraResourceIndication,
}

impl APerElement for ServedEutraCellsInformation {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(1),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let _extended = bool::from_aper(decoder, UNCONSTRAINED)?;
        let _optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let eutra_mode_info = EutraModeInfo::from_aper(decoder, UNCONSTRAINED)?;
        let protected_eutra_resource_indication =
            ProtectedEutraResourceIndication::from_aper(decoder, UNCONSTRAINED)?;

        Ok(Self {
            eutra_mode_info,
            protected_eutra_resource_indication,
        })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(1);
        optionals.set(0, false);

        enc.append(&false.to_aper(UNCONSTRAINED)?)?;
        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&self.eutra_mode_info.to_aper(UNCONSTRAINED)?)?;
        enc.append(
            &self
                .protected_eutra_resource_indication
                .to_aper(UNCONSTRAINED)?,
        )?;

        Ok(enc)
    }
}

// ServiceState
#[derive(Clone, Copy, FromPrimitive)]
pub enum ServiceState {
    InService,
    OutOfService,
    _Extended,
}

impl APerElement for ServiceState {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        if bool::from_aper(decoder, Self::CONSTRAINTS)? {
            return Ok(ServiceState::_Extended);
        }
        let v = u8::from_aper(decoder, Self::CONSTRAINTS)?;
        FromPrimitive::from_u8(v).ok_or(DecodeError::MalformedInt)
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&false.to_aper(UNCONSTRAINED)?)?;
        enc.append(&(*self as u8).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// ServiceStatus
#[derive(Clone)]
pub struct ServiceStatus {
    pub service_state: ServiceState,
    pub switching_off_ongoing: Option<SwitchingOffOngoing>,
}

impl APerElement for ServiceStatus {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(2),
            max: Some(2),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let _extended = bool::from_aper(decoder, UNCONSTRAINED)?;
        let optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let service_state = ServiceState::from_aper(decoder, UNCONSTRAINED)?;
        let switching_off_ongoing = if optionals.is_set(0) {
            Some(SwitchingOffOngoing::from_aper(decoder, UNCONSTRAINED)?)
        } else {
            None
        };

        Ok(Self {
            service_state,
            switching_off_ongoing,
        })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(2);
        optionals.set(0, self.switching_off_ongoing.is_some());
        optionals.set(1, false);

        enc.append(&false.to_aper(UNCONSTRAINED)?)?;
        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&self.service_state.to_aper(UNCONSTRAINED)?)?;
        if let Some(x) = &self.switching_off_ongoing {
            enc.append(&x.to_aper(UNCONSTRAINED)?)?;
        }

        Ok(enc)
    }
}

// RelativeTime1900
#[derive(Clone)]
pub struct RelativeTime1900(pub BitString);

impl APerElement for RelativeTime1900 {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(64),
            max: Some(64),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        Ok(Self(BitString::from_aper(decoder, Self::CONSTRAINTS)?))
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&(self.0).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// ShortDrxCycleLength
#[derive(Clone, Copy, FromPrimitive)]
pub enum ShortDrxCycleLength {
    Ms2,
    Ms3,
    Ms4,
    Ms5,
    Ms6,
    Ms7,
    Ms8,
    Ms10,
    Ms14,
    Ms16,
    Ms20,
    Ms30,
    Ms32,
    Ms35,
    Ms40,
    Ms64,
    Ms80,
    Ms128,
    Ms160,
    Ms256,
    Ms320,
    Ms512,
    Ms640,
    _Extended,
}

impl APerElement for ShortDrxCycleLength {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        if bool::from_aper(decoder, Self::CONSTRAINTS)? {
            return Ok(ShortDrxCycleLength::_Extended);
        }
        let v = u8::from_aper(decoder, Self::CONSTRAINTS)?;
        FromPrimitive::from_u8(v).ok_or(DecodeError::MalformedInt)
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&false.to_aper(UNCONSTRAINED)?)?;
        enc.append(&(*self as u8).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// ShortDrxCycleTimer
#[derive(Clone)]
pub struct ShortDrxCycleTimer(pub u8);

impl APerElement for ShortDrxCycleTimer {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(1),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        Ok(Self(u8::from_aper(decoder, Self::CONSTRAINTS)?))
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&(self.0).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// Sib1Message
#[derive(Clone)]
pub struct Sib1Message(pub Vec<u8>);

impl APerElement for Sib1Message {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        Ok(Self(Vec::<u8>::from_aper(decoder, Self::CONSTRAINTS)?))
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&(self.0).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// Sib10Message
#[derive(Clone)]
pub struct Sib10Message(pub Vec<u8>);

impl APerElement for Sib10Message {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        Ok(Self(Vec::<u8>::from_aper(decoder, Self::CONSTRAINTS)?))
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&(self.0).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// Sib12Message
#[derive(Clone)]
pub struct Sib12Message(pub Vec<u8>);

impl APerElement for Sib12Message {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        Ok(Self(Vec::<u8>::from_aper(decoder, Self::CONSTRAINTS)?))
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&(self.0).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// Sib13Message
#[derive(Clone)]
pub struct Sib13Message(pub Vec<u8>);

impl APerElement for Sib13Message {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        Ok(Self(Vec::<u8>::from_aper(decoder, Self::CONSTRAINTS)?))
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&(self.0).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// Sib14Message
#[derive(Clone)]
pub struct Sib14Message(pub Vec<u8>);

impl APerElement for Sib14Message {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        Ok(Self(Vec::<u8>::from_aper(decoder, Self::CONSTRAINTS)?))
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&(self.0).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// SItype
#[derive(Clone)]
pub struct SItype(pub u8);

impl APerElement for SItype {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(32),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        Ok(Self(u8::from_aper(decoder, Self::CONSTRAINTS)?))
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&(self.0).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// SItypeList
#[derive(Clone)]
pub struct SItypeList(pub Vec<SItypeItem>);

impl APerElement for SItypeList {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(1),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        Ok(Self(Vec::<SItypeItem>::from_aper(
            decoder,
            Self::CONSTRAINTS,
        )?))
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&(self.0).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// SItypeItem
#[derive(Clone)]
pub struct SItypeItem {
    pub s_itype: SItype,
}

impl APerElement for SItypeItem {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(1),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let _optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let s_itype = SItype::from_aper(decoder, UNCONSTRAINED)?;

        Ok(Self { s_itype })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(1);
        optionals.set(0, false);

        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&self.s_itype.to_aper(UNCONSTRAINED)?)?;

        Ok(enc)
    }
}

// SibtypetobeupdatedListItem
#[derive(Clone)]
pub struct SibtypetobeupdatedListItem {
    pub si_btype: u8,
    pub si_bmessage: Vec<u8>,
    pub value_tag: u8,
}

impl APerElement for SibtypetobeupdatedListItem {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(1),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let _extended = bool::from_aper(decoder, UNCONSTRAINED)?;
        let _optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let si_btype = u8::from_aper(decoder, UNCONSTRAINED)?;
        let si_bmessage = Vec::<u8>::from_aper(decoder, UNCONSTRAINED)?;
        let value_tag = u8::from_aper(decoder, UNCONSTRAINED)?;

        Ok(Self {
            si_btype,
            si_bmessage,
            value_tag,
        })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(1);
        optionals.set(0, false);

        enc.append(&false.to_aper(UNCONSTRAINED)?)?;
        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&self.si_btype.to_aper(UNCONSTRAINED)?)?;
        enc.append(&self.si_bmessage.to_aper(UNCONSTRAINED)?)?;
        enc.append(&self.value_tag.to_aper(UNCONSTRAINED)?)?;

        Ok(enc)
    }
}

// Sldrbid
#[derive(Clone)]
pub struct Sldrbid(pub u16);

impl APerElement for Sldrbid {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(512),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        Ok(Self(u16::from_aper(decoder, Self::CONSTRAINTS)?))
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&(self.0).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// SldrbInformation
#[derive(Clone)]
pub struct SldrbInformation {
    pub sldrb_qos: Pc5QosParameters,
    pub flows_mapped_to_sldrb_list: FlowsMappedToSldrbList,
}

impl APerElement for SldrbInformation {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let _extended = bool::from_aper(decoder, UNCONSTRAINED)?;

        let sldrb_qos = Pc5QosParameters::from_aper(decoder, UNCONSTRAINED)?;
        let flows_mapped_to_sldrb_list = FlowsMappedToSldrbList::from_aper(decoder, UNCONSTRAINED)?;

        Ok(Self {
            sldrb_qos,
            flows_mapped_to_sldrb_list,
        })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();

        enc.append(&false.to_aper(UNCONSTRAINED)?)?;

        enc.append(&self.sldrb_qos.to_aper(UNCONSTRAINED)?)?;
        enc.append(&self.flows_mapped_to_sldrb_list.to_aper(UNCONSTRAINED)?)?;

        Ok(enc)
    }
}

// SldrBsFailedToBeModifiedItem
#[derive(Clone)]
pub struct SldrBsFailedToBeModifiedItem {
    pub sldrbid: Sldrbid,
    pub cause: Option<Cause>,
}

impl APerElement for SldrBsFailedToBeModifiedItem {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(2),
            max: Some(2),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let sldrbid = Sldrbid::from_aper(decoder, UNCONSTRAINED)?;
        let cause = if optionals.is_set(0) {
            Some(Cause::from_aper(decoder, UNCONSTRAINED)?)
        } else {
            None
        };

        Ok(Self { sldrbid, cause })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(2);
        optionals.set(0, self.cause.is_some());
        optionals.set(1, false);

        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&self.sldrbid.to_aper(UNCONSTRAINED)?)?;
        if let Some(x) = &self.cause {
            enc.append(&x.to_aper(UNCONSTRAINED)?)?;
        }

        Ok(enc)
    }
}

// SldrBsFailedToBeSetupItem
#[derive(Clone)]
pub struct SldrBsFailedToBeSetupItem {
    pub sldrbid: Sldrbid,
    pub cause: Option<Cause>,
}

impl APerElement for SldrBsFailedToBeSetupItem {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(2),
            max: Some(2),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let sldrbid = Sldrbid::from_aper(decoder, UNCONSTRAINED)?;
        let cause = if optionals.is_set(0) {
            Some(Cause::from_aper(decoder, UNCONSTRAINED)?)
        } else {
            None
        };

        Ok(Self { sldrbid, cause })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(2);
        optionals.set(0, self.cause.is_some());
        optionals.set(1, false);

        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&self.sldrbid.to_aper(UNCONSTRAINED)?)?;
        if let Some(x) = &self.cause {
            enc.append(&x.to_aper(UNCONSTRAINED)?)?;
        }

        Ok(enc)
    }
}

// SldrBsFailedToBeSetupModItem
#[derive(Clone)]
pub struct SldrBsFailedToBeSetupModItem {
    pub sldrbid: Sldrbid,
    pub cause: Option<Cause>,
}

impl APerElement for SldrBsFailedToBeSetupModItem {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(2),
            max: Some(2),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let sldrbid = Sldrbid::from_aper(decoder, UNCONSTRAINED)?;
        let cause = if optionals.is_set(0) {
            Some(Cause::from_aper(decoder, UNCONSTRAINED)?)
        } else {
            None
        };

        Ok(Self { sldrbid, cause })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(2);
        optionals.set(0, self.cause.is_some());
        optionals.set(1, false);

        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&self.sldrbid.to_aper(UNCONSTRAINED)?)?;
        if let Some(x) = &self.cause {
            enc.append(&x.to_aper(UNCONSTRAINED)?)?;
        }

        Ok(enc)
    }
}

// SldrBsModifiedItem
#[derive(Clone)]
pub struct SldrBsModifiedItem {
    pub sldrbid: Sldrbid,
}

impl APerElement for SldrBsModifiedItem {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(1),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let _optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let sldrbid = Sldrbid::from_aper(decoder, UNCONSTRAINED)?;

        Ok(Self { sldrbid })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(1);
        optionals.set(0, false);

        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&self.sldrbid.to_aper(UNCONSTRAINED)?)?;

        Ok(enc)
    }
}

// SldrBsModifiedConfItem
#[derive(Clone)]
pub struct SldrBsModifiedConfItem {
    pub sldrbid: Sldrbid,
}

impl APerElement for SldrBsModifiedConfItem {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(1),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let _optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let sldrbid = Sldrbid::from_aper(decoder, UNCONSTRAINED)?;

        Ok(Self { sldrbid })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(1);
        optionals.set(0, false);

        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&self.sldrbid.to_aper(UNCONSTRAINED)?)?;

        Ok(enc)
    }
}

// SldrBsRequiredToBeModifiedItem
#[derive(Clone)]
pub struct SldrBsRequiredToBeModifiedItem {
    pub sldrbid: Sldrbid,
}

impl APerElement for SldrBsRequiredToBeModifiedItem {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(1),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let _optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let sldrbid = Sldrbid::from_aper(decoder, UNCONSTRAINED)?;

        Ok(Self { sldrbid })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(1);
        optionals.set(0, false);

        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&self.sldrbid.to_aper(UNCONSTRAINED)?)?;

        Ok(enc)
    }
}

// SldrBsRequiredToBeReleasedItem
#[derive(Clone)]
pub struct SldrBsRequiredToBeReleasedItem {
    pub sldrbid: Sldrbid,
}

impl APerElement for SldrBsRequiredToBeReleasedItem {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(1),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let _optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let sldrbid = Sldrbid::from_aper(decoder, UNCONSTRAINED)?;

        Ok(Self { sldrbid })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(1);
        optionals.set(0, false);

        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&self.sldrbid.to_aper(UNCONSTRAINED)?)?;

        Ok(enc)
    }
}

// SldrBsSetupItem
#[derive(Clone)]
pub struct SldrBsSetupItem {
    pub sldrbid: Sldrbid,
}

impl APerElement for SldrBsSetupItem {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(1),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let _optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let sldrbid = Sldrbid::from_aper(decoder, UNCONSTRAINED)?;

        Ok(Self { sldrbid })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(1);
        optionals.set(0, false);

        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&self.sldrbid.to_aper(UNCONSTRAINED)?)?;

        Ok(enc)
    }
}

// SldrBsSetupModItem
#[derive(Clone)]
pub struct SldrBsSetupModItem {
    pub sldrbid: Sldrbid,
}

impl APerElement for SldrBsSetupModItem {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(1),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let _optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let sldrbid = Sldrbid::from_aper(decoder, UNCONSTRAINED)?;

        Ok(Self { sldrbid })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(1);
        optionals.set(0, false);

        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&self.sldrbid.to_aper(UNCONSTRAINED)?)?;

        Ok(enc)
    }
}

// SldrBsToBeModifiedItem
#[derive(Clone)]
pub struct SldrBsToBeModifiedItem {
    pub sldrbid: Sldrbid,
    pub sldrb_information: Option<SldrbInformation>,
    pub rlc_mode: Option<RlcMode>,
}

impl APerElement for SldrBsToBeModifiedItem {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(3),
            max: Some(3),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let sldrbid = Sldrbid::from_aper(decoder, UNCONSTRAINED)?;
        let sldrb_information = if optionals.is_set(0) {
            Some(SldrbInformation::from_aper(decoder, UNCONSTRAINED)?)
        } else {
            None
        };
        let rlc_mode = if optionals.is_set(0) {
            Some(RlcMode::from_aper(decoder, UNCONSTRAINED)?)
        } else {
            None
        };

        Ok(Self {
            sldrbid,
            sldrb_information,
            rlc_mode,
        })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(3);
        optionals.set(0, self.sldrb_information.is_some());
        optionals.set(1, self.rlc_mode.is_some());
        optionals.set(2, false);

        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&self.sldrbid.to_aper(UNCONSTRAINED)?)?;
        if let Some(x) = &self.sldrb_information {
            enc.append(&x.to_aper(UNCONSTRAINED)?)?;
        }
        if let Some(x) = &self.rlc_mode {
            enc.append(&x.to_aper(UNCONSTRAINED)?)?;
        }

        Ok(enc)
    }
}

// SldrBsToBeReleasedItem
#[derive(Clone)]
pub struct SldrBsToBeReleasedItem {
    pub sldrbid: Sldrbid,
}

impl APerElement for SldrBsToBeReleasedItem {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(1),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let _optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let sldrbid = Sldrbid::from_aper(decoder, UNCONSTRAINED)?;

        Ok(Self { sldrbid })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(1);
        optionals.set(0, false);

        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&self.sldrbid.to_aper(UNCONSTRAINED)?)?;

        Ok(enc)
    }
}

// SldrBsToBeSetupItem
#[derive(Clone)]
pub struct SldrBsToBeSetupItem {
    pub sldrbid: Sldrbid,
    pub sldrb_information: SldrbInformation,
    pub rlc_mode: RlcMode,
}

impl APerElement for SldrBsToBeSetupItem {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(1),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let _optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let sldrbid = Sldrbid::from_aper(decoder, UNCONSTRAINED)?;
        let sldrb_information = SldrbInformation::from_aper(decoder, UNCONSTRAINED)?;
        let rlc_mode = RlcMode::from_aper(decoder, UNCONSTRAINED)?;

        Ok(Self {
            sldrbid,
            sldrb_information,
            rlc_mode,
        })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(1);
        optionals.set(0, false);

        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&self.sldrbid.to_aper(UNCONSTRAINED)?)?;
        enc.append(&self.sldrb_information.to_aper(UNCONSTRAINED)?)?;
        enc.append(&self.rlc_mode.to_aper(UNCONSTRAINED)?)?;

        Ok(enc)
    }
}

// SldrBsToBeSetupModItem
#[derive(Clone)]
pub struct SldrBsToBeSetupModItem {
    pub sldrbid: Sldrbid,
    pub sldrb_information: SldrbInformation,
    pub rlc_mode: Option<RlcMode>,
}

impl APerElement for SldrBsToBeSetupModItem {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(2),
            max: Some(2),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let sldrbid = Sldrbid::from_aper(decoder, UNCONSTRAINED)?;
        let sldrb_information = SldrbInformation::from_aper(decoder, UNCONSTRAINED)?;
        let rlc_mode = if optionals.is_set(0) {
            Some(RlcMode::from_aper(decoder, UNCONSTRAINED)?)
        } else {
            None
        };

        Ok(Self {
            sldrbid,
            sldrb_information,
            rlc_mode,
        })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(2);
        optionals.set(0, self.rlc_mode.is_some());
        optionals.set(1, false);

        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&self.sldrbid.to_aper(UNCONSTRAINED)?)?;
        enc.append(&self.sldrb_information.to_aper(UNCONSTRAINED)?)?;
        if let Some(x) = &self.rlc_mode {
            enc.append(&x.to_aper(UNCONSTRAINED)?)?;
        }

        Ok(enc)
    }
}

// SlPhyMacRlcConfig
#[derive(Clone)]
pub struct SlPhyMacRlcConfig(pub Vec<u8>);

impl APerElement for SlPhyMacRlcConfig {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        Ok(Self(Vec::<u8>::from_aper(decoder, Self::CONSTRAINTS)?))
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&(self.0).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// SlConfigDedicatedEutraInfo
#[derive(Clone)]
pub struct SlConfigDedicatedEutraInfo(pub Vec<u8>);

impl APerElement for SlConfigDedicatedEutraInfo {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        Ok(Self(Vec::<u8>::from_aper(decoder, Self::CONSTRAINTS)?))
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&(self.0).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// SliceAvailableCapacity
#[derive(Clone)]
pub struct SliceAvailableCapacity {
    pub slice_available_capacity_list: SliceAvailableCapacityList,
}

impl APerElement for SliceAvailableCapacity {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(1),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let _optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let slice_available_capacity_list =
            SliceAvailableCapacityList::from_aper(decoder, UNCONSTRAINED)?;

        Ok(Self {
            slice_available_capacity_list,
        })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(1);
        optionals.set(0, false);

        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&self.slice_available_capacity_list.to_aper(UNCONSTRAINED)?)?;

        Ok(enc)
    }
}

// SliceAvailableCapacityList
#[derive(Clone)]
pub struct SliceAvailableCapacityList(pub Vec<SliceAvailableCapacityItem>);

impl APerElement for SliceAvailableCapacityList {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(1),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        Ok(Self(Vec::<SliceAvailableCapacityItem>::from_aper(
            decoder,
            Self::CONSTRAINTS,
        )?))
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&(self.0).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// SliceAvailableCapacityItem
#[derive(Clone)]
pub struct SliceAvailableCapacityItem {
    pub plmn_identity: PlmnIdentity,
    pub snssai_available_capacity_list: SnssaiAvailableCapacityList,
}

impl APerElement for SliceAvailableCapacityItem {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(1),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let _optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let plmn_identity = PlmnIdentity::from_aper(decoder, UNCONSTRAINED)?;
        let snssai_available_capacity_list =
            SnssaiAvailableCapacityList::from_aper(decoder, UNCONSTRAINED)?;

        Ok(Self {
            plmn_identity,
            snssai_available_capacity_list,
        })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(1);
        optionals.set(0, false);

        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&self.plmn_identity.to_aper(UNCONSTRAINED)?)?;
        enc.append(&self.snssai_available_capacity_list.to_aper(UNCONSTRAINED)?)?;

        Ok(enc)
    }
}

// SnssaiAvailableCapacityList
#[derive(Clone)]
pub struct SnssaiAvailableCapacityList(pub Vec<SnssaiAvailableCapacityItem>);

impl APerElement for SnssaiAvailableCapacityList {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(1),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        Ok(Self(Vec::<SnssaiAvailableCapacityItem>::from_aper(
            decoder,
            Self::CONSTRAINTS,
        )?))
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&(self.0).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// SnssaiAvailableCapacityItem
#[derive(Clone)]
pub struct SnssaiAvailableCapacityItem {
    pub snssai: Snssai,
    pub slice_available_capacity_value_downlink: Option<u8>,
    pub slice_available_capacity_value_uplink: Option<u8>,
}

impl APerElement for SnssaiAvailableCapacityItem {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(3),
            max: Some(3),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let snssai = Snssai::from_aper(decoder, UNCONSTRAINED)?;
        let slice_available_capacity_value_downlink = if optionals.is_set(0) {
            Some(u8::from_aper(decoder, UNCONSTRAINED)?)
        } else {
            None
        };
        let slice_available_capacity_value_uplink = if optionals.is_set(0) {
            Some(u8::from_aper(decoder, UNCONSTRAINED)?)
        } else {
            None
        };

        Ok(Self {
            snssai,
            slice_available_capacity_value_downlink,
            slice_available_capacity_value_uplink,
        })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(3);
        optionals.set(0, self.slice_available_capacity_value_downlink.is_some());
        optionals.set(1, self.slice_available_capacity_value_uplink.is_some());
        optionals.set(2, false);

        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&self.snssai.to_aper(UNCONSTRAINED)?)?;
        if let Some(x) = &self.slice_available_capacity_value_downlink {
            enc.append(&x.to_aper(UNCONSTRAINED)?)?;
        }
        if let Some(x) = &self.slice_available_capacity_value_uplink {
            enc.append(&x.to_aper(UNCONSTRAINED)?)?;
        }

        Ok(enc)
    }
}

// SliceSupportList
#[derive(Clone)]
pub struct SliceSupportList(pub Vec<SliceSupportItem>);

impl APerElement for SliceSupportList {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(1),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        Ok(Self(Vec::<SliceSupportItem>::from_aper(
            decoder,
            Self::CONSTRAINTS,
        )?))
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&(self.0).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// SliceSupportItem
#[derive(Clone)]
pub struct SliceSupportItem {
    pub snssai: Snssai,
}

impl APerElement for SliceSupportItem {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(1),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let _optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let snssai = Snssai::from_aper(decoder, UNCONSTRAINED)?;

        Ok(Self { snssai })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(1);
        optionals.set(0, false);

        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&self.snssai.to_aper(UNCONSTRAINED)?)?;

        Ok(enc)
    }
}

// SliceToReportList
#[derive(Clone)]
pub struct SliceToReportList(pub Vec<SliceToReportItem>);

impl APerElement for SliceToReportList {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(1),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        Ok(Self(Vec::<SliceToReportItem>::from_aper(
            decoder,
            Self::CONSTRAINTS,
        )?))
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&(self.0).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// SliceToReportItem
#[derive(Clone)]
pub struct SliceToReportItem {
    pub plmn_identity: PlmnIdentity,
    pub snssa_ilist: SnssaiList,
}

impl APerElement for SliceToReportItem {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(1),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let _optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let plmn_identity = PlmnIdentity::from_aper(decoder, UNCONSTRAINED)?;
        let snssa_ilist = SnssaiList::from_aper(decoder, UNCONSTRAINED)?;

        Ok(Self {
            plmn_identity,
            snssa_ilist,
        })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(1);
        optionals.set(0, false);

        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&self.plmn_identity.to_aper(UNCONSTRAINED)?)?;
        enc.append(&self.snssa_ilist.to_aper(UNCONSTRAINED)?)?;

        Ok(enc)
    }
}

// SlotNumber
#[derive(Clone)]
pub struct SlotNumber(pub u8);

impl APerElement for SlotNumber {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(0),
            max: Some(0),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        Ok(Self(u8::from_aper(decoder, Self::CONSTRAINTS)?))
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&(self.0).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// SnssaiList
#[derive(Clone)]
pub struct SnssaiList(pub Vec<SnssaiItem>);

impl APerElement for SnssaiList {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(1),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        Ok(Self(Vec::<SnssaiItem>::from_aper(
            decoder,
            Self::CONSTRAINTS,
        )?))
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&(self.0).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// SnssaiItem
#[derive(Clone)]
pub struct SnssaiItem {
    pub snssai: Snssai,
}

impl APerElement for SnssaiItem {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(1),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let _optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let snssai = Snssai::from_aper(decoder, UNCONSTRAINED)?;

        Ok(Self { snssai })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(1);
        optionals.set(0, false);

        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&self.snssai.to_aper(UNCONSTRAINED)?)?;

        Ok(enc)
    }
}

// SlotConfigurationList
#[derive(Clone)]
pub struct SlotConfigurationList(pub Vec<SlotConfigurationItem>);

impl APerElement for SlotConfigurationList {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(1),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        Ok(Self(Vec::<SlotConfigurationItem>::from_aper(
            decoder,
            Self::CONSTRAINTS,
        )?))
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&(self.0).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// SlotConfigurationItem
#[derive(Clone)]
pub struct SlotConfigurationItem {
    pub slot_index: u16,
    pub symbol_alloc_in_slot: SymbolAllocInSlot,
}

impl APerElement for SlotConfigurationItem {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(1),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let _optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let slot_index = u16::from_aper(decoder, UNCONSTRAINED)?;
        let symbol_alloc_in_slot = SymbolAllocInSlot::from_aper(decoder, UNCONSTRAINED)?;

        Ok(Self {
            slot_index,
            symbol_alloc_in_slot,
        })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(1);
        optionals.set(0, false);

        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&self.slot_index.to_aper(UNCONSTRAINED)?)?;
        enc.append(&self.symbol_alloc_in_slot.to_aper(UNCONSTRAINED)?)?;

        Ok(enc)
    }
}

// Snssai
#[derive(Clone)]
pub struct Snssai {
    pub sst: Vec<u8>,
    pub sd: Option<Vec<u8>>,
}

impl APerElement for Snssai {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(2),
            max: Some(2),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let sst = Vec::<u8>::from_aper(
            decoder,
            Constraints {
                value: None,
                size: Some(Constraint::new(Some(1), Some(1))),
            },
        )?;
        let sd = if optionals.is_set(0) {
            Some(Vec::<u8>::from_aper(
                decoder,
                Constraints {
                    value: None,
                    size: Some(Constraint::new(Some(3), Some(3))),
                },
            )?)
        } else {
            None
        };

        Ok(Self { sst, sd })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(2);
        optionals.set(0, self.sd.is_some());
        optionals.set(1, false);

        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&self.sst.to_aper(UNCONSTRAINED)?)?;
        if let Some(x) = &self.sd {
            enc.append(&x.to_aper(UNCONSTRAINED)?)?;
        }

        Ok(enc)
    }
}

// SpatialDirectionInformation
#[derive(Clone)]
pub struct SpatialDirectionInformation {
    pub nr_prs_beam_information: NrPrsBeamInformation,
}

impl APerElement for SpatialDirectionInformation {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(1),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let _optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let nr_prs_beam_information = NrPrsBeamInformation::from_aper(decoder, UNCONSTRAINED)?;

        Ok(Self {
            nr_prs_beam_information,
        })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(1);
        optionals.set(0, false);

        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&self.nr_prs_beam_information.to_aper(UNCONSTRAINED)?)?;

        Ok(enc)
    }
}

// SpatialRelationInfo
#[derive(Clone)]
pub struct SpatialRelationInfo {
    pub spatial_relationfor_resource_id: SpatialRelationforResourceId,
}

impl APerElement for SpatialRelationInfo {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(1),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let _optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let spatial_relationfor_resource_id =
            SpatialRelationforResourceId::from_aper(decoder, UNCONSTRAINED)?;

        Ok(Self {
            spatial_relationfor_resource_id,
        })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(1);
        optionals.set(0, false);

        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(
            &self
                .spatial_relationfor_resource_id
                .to_aper(UNCONSTRAINED)?,
        )?;

        Ok(enc)
    }
}

// SpatialRelationforResourceId
#[derive(Clone)]
pub struct SpatialRelationforResourceId(pub Vec<SpatialRelationforResourceIdItem>);

impl APerElement for SpatialRelationforResourceId {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(1),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        Ok(Self(Vec::<SpatialRelationforResourceIdItem>::from_aper(
            decoder,
            Self::CONSTRAINTS,
        )?))
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&(self.0).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// SpatialRelationforResourceIdItem
#[derive(Clone)]
pub struct SpatialRelationforResourceIdItem {
    pub reference_signal: ReferenceSignal,
}

impl APerElement for SpatialRelationforResourceIdItem {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(1),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let _optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let reference_signal = ReferenceSignal::from_aper(decoder, UNCONSTRAINED)?;

        Ok(Self { reference_signal })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(1);
        optionals.set(0, false);

        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&self.reference_signal.to_aper(UNCONSTRAINED)?)?;

        Ok(enc)
    }
}

// SpatialRelationPos
#[derive(Clone)]
pub enum SpatialRelationPos {
    SsbPos(Ssb),
    PrsInformationPos(PrsInformationPos),
    _Extended,
}

impl APerElement for SpatialRelationPos {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        match u8::from_aper(decoder, UNCONSTRAINED)? {
            0 => Ok(Self::SsbPos(Ssb::from_aper(decoder, UNCONSTRAINED)?)),
            1 => Ok(Self::PrsInformationPos(PrsInformationPos::from_aper(
                decoder,
                UNCONSTRAINED,
            )?)),
            2 => Err(DecodeError::NotImplemented),
            _ => Err(DecodeError::InvalidChoice),
        }
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        match self {
            Self::SsbPos(x) => {
                enc.append(&(0 as u8).to_aper(UNCONSTRAINED)?)?;
                enc.append(&x.to_aper(UNCONSTRAINED)?)?;
            }
            Self::PrsInformationPos(x) => {
                enc.append(&(1 as u8).to_aper(UNCONSTRAINED)?)?;
                enc.append(&x.to_aper(UNCONSTRAINED)?)?;
            }
            Self::_Extended => return Err(EncodeError::NotImplemented),
        }
        Ok(enc)
    }
}

// SpectrumSharingGroupId
#[derive(Clone)]
pub struct SpectrumSharingGroupId(pub u8);

impl APerElement for SpectrumSharingGroupId {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(1),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        Ok(Self(u8::from_aper(decoder, Self::CONSTRAINTS)?))
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&(self.0).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// Srbid
#[derive(Clone)]
pub struct Srbid(pub u8);

impl APerElement for Srbid {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(0),
            max: Some(3),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        Ok(Self(u8::from_aper(decoder, Self::CONSTRAINTS)?))
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&(self.0).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// SrBsFailedToBeSetupItem
#[derive(Clone)]
pub struct SrBsFailedToBeSetupItem {
    pub srbid: Srbid,
    pub cause: Option<Cause>,
}

impl APerElement for SrBsFailedToBeSetupItem {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(2),
            max: Some(2),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let _extended = bool::from_aper(decoder, UNCONSTRAINED)?;
        let optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let srbid = Srbid::from_aper(decoder, UNCONSTRAINED)?;
        let cause = if optionals.is_set(0) {
            Some(Cause::from_aper(decoder, UNCONSTRAINED)?)
        } else {
            None
        };

        Ok(Self { srbid, cause })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(2);
        optionals.set(0, self.cause.is_some());
        optionals.set(1, false);

        enc.append(&false.to_aper(UNCONSTRAINED)?)?;
        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&self.srbid.to_aper(UNCONSTRAINED)?)?;
        if let Some(x) = &self.cause {
            enc.append(&x.to_aper(UNCONSTRAINED)?)?;
        }

        Ok(enc)
    }
}

// SrBsFailedToBeSetupModItem
#[derive(Clone)]
pub struct SrBsFailedToBeSetupModItem {
    pub srbid: Srbid,
    pub cause: Option<Cause>,
}

impl APerElement for SrBsFailedToBeSetupModItem {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(2),
            max: Some(2),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let _extended = bool::from_aper(decoder, UNCONSTRAINED)?;
        let optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let srbid = Srbid::from_aper(decoder, UNCONSTRAINED)?;
        let cause = if optionals.is_set(0) {
            Some(Cause::from_aper(decoder, UNCONSTRAINED)?)
        } else {
            None
        };

        Ok(Self { srbid, cause })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(2);
        optionals.set(0, self.cause.is_some());
        optionals.set(1, false);

        enc.append(&false.to_aper(UNCONSTRAINED)?)?;
        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&self.srbid.to_aper(UNCONSTRAINED)?)?;
        if let Some(x) = &self.cause {
            enc.append(&x.to_aper(UNCONSTRAINED)?)?;
        }

        Ok(enc)
    }
}

// SrBsModifiedItem
#[derive(Clone)]
pub struct SrBsModifiedItem {
    pub srbid: Srbid,
    pub lcid: Lcid,
}

impl APerElement for SrBsModifiedItem {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(1),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let _extended = bool::from_aper(decoder, UNCONSTRAINED)?;
        let _optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let srbid = Srbid::from_aper(decoder, UNCONSTRAINED)?;
        let lcid = Lcid::from_aper(decoder, UNCONSTRAINED)?;

        Ok(Self { srbid, lcid })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(1);
        optionals.set(0, false);

        enc.append(&false.to_aper(UNCONSTRAINED)?)?;
        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&self.srbid.to_aper(UNCONSTRAINED)?)?;
        enc.append(&self.lcid.to_aper(UNCONSTRAINED)?)?;

        Ok(enc)
    }
}

// SrBsRequiredToBeReleasedItem
#[derive(Clone)]
pub struct SrBsRequiredToBeReleasedItem {
    pub srbid: Srbid,
}

impl APerElement for SrBsRequiredToBeReleasedItem {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(1),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let _extended = bool::from_aper(decoder, UNCONSTRAINED)?;
        let _optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let srbid = Srbid::from_aper(decoder, UNCONSTRAINED)?;

        Ok(Self { srbid })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(1);
        optionals.set(0, false);

        enc.append(&false.to_aper(UNCONSTRAINED)?)?;
        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&self.srbid.to_aper(UNCONSTRAINED)?)?;

        Ok(enc)
    }
}

// SrBsSetupItem
#[derive(Clone)]
pub struct SrBsSetupItem {
    pub srbid: Srbid,
    pub lcid: Lcid,
}

impl APerElement for SrBsSetupItem {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(1),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let _extended = bool::from_aper(decoder, UNCONSTRAINED)?;
        let _optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let srbid = Srbid::from_aper(decoder, UNCONSTRAINED)?;
        let lcid = Lcid::from_aper(decoder, UNCONSTRAINED)?;

        Ok(Self { srbid, lcid })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(1);
        optionals.set(0, false);

        enc.append(&false.to_aper(UNCONSTRAINED)?)?;
        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&self.srbid.to_aper(UNCONSTRAINED)?)?;
        enc.append(&self.lcid.to_aper(UNCONSTRAINED)?)?;

        Ok(enc)
    }
}

// SrBsSetupModItem
#[derive(Clone)]
pub struct SrBsSetupModItem {
    pub srbid: Srbid,
    pub lcid: Lcid,
}

impl APerElement for SrBsSetupModItem {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(1),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let _extended = bool::from_aper(decoder, UNCONSTRAINED)?;
        let _optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let srbid = Srbid::from_aper(decoder, UNCONSTRAINED)?;
        let lcid = Lcid::from_aper(decoder, UNCONSTRAINED)?;

        Ok(Self { srbid, lcid })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(1);
        optionals.set(0, false);

        enc.append(&false.to_aper(UNCONSTRAINED)?)?;
        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&self.srbid.to_aper(UNCONSTRAINED)?)?;
        enc.append(&self.lcid.to_aper(UNCONSTRAINED)?)?;

        Ok(enc)
    }
}

// SrBsToBeReleasedItem
#[derive(Clone)]
pub struct SrBsToBeReleasedItem {
    pub srbid: Srbid,
}

impl APerElement for SrBsToBeReleasedItem {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(1),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let _extended = bool::from_aper(decoder, UNCONSTRAINED)?;
        let _optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let srbid = Srbid::from_aper(decoder, UNCONSTRAINED)?;

        Ok(Self { srbid })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(1);
        optionals.set(0, false);

        enc.append(&false.to_aper(UNCONSTRAINED)?)?;
        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&self.srbid.to_aper(UNCONSTRAINED)?)?;

        Ok(enc)
    }
}

// SrBsToBeSetupItem
#[derive(Clone)]
pub struct SrBsToBeSetupItem {
    pub srbid: Srbid,
    pub duplication_indication: Option<DuplicationIndication>,
}

impl APerElement for SrBsToBeSetupItem {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(2),
            max: Some(2),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let _extended = bool::from_aper(decoder, UNCONSTRAINED)?;
        let optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let srbid = Srbid::from_aper(decoder, UNCONSTRAINED)?;
        let duplication_indication = if optionals.is_set(0) {
            Some(DuplicationIndication::from_aper(decoder, UNCONSTRAINED)?)
        } else {
            None
        };

        Ok(Self {
            srbid,
            duplication_indication,
        })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(2);
        optionals.set(0, self.duplication_indication.is_some());
        optionals.set(1, false);

        enc.append(&false.to_aper(UNCONSTRAINED)?)?;
        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&self.srbid.to_aper(UNCONSTRAINED)?)?;
        if let Some(x) = &self.duplication_indication {
            enc.append(&x.to_aper(UNCONSTRAINED)?)?;
        }

        Ok(enc)
    }
}

// SrBsToBeSetupModItem
#[derive(Clone)]
pub struct SrBsToBeSetupModItem {
    pub srbid: Srbid,
    pub duplication_indication: Option<DuplicationIndication>,
}

impl APerElement for SrBsToBeSetupModItem {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(2),
            max: Some(2),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let _extended = bool::from_aper(decoder, UNCONSTRAINED)?;
        let optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let srbid = Srbid::from_aper(decoder, UNCONSTRAINED)?;
        let duplication_indication = if optionals.is_set(0) {
            Some(DuplicationIndication::from_aper(decoder, UNCONSTRAINED)?)
        } else {
            None
        };

        Ok(Self {
            srbid,
            duplication_indication,
        })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(2);
        optionals.set(0, self.duplication_indication.is_some());
        optionals.set(1, false);

        enc.append(&false.to_aper(UNCONSTRAINED)?)?;
        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&self.srbid.to_aper(UNCONSTRAINED)?)?;
        if let Some(x) = &self.duplication_indication {
            enc.append(&x.to_aper(UNCONSTRAINED)?)?;
        }

        Ok(enc)
    }
}

// SrsCarrierList
#[derive(Clone)]
pub struct SrsCarrierList(pub Vec<SrsCarrierListItem>);

impl APerElement for SrsCarrierList {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(1),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        Ok(Self(Vec::<SrsCarrierListItem>::from_aper(
            decoder,
            Self::CONSTRAINTS,
        )?))
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&(self.0).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// SrsCarrierListItem
#[derive(Clone)]
pub struct SrsCarrierListItem {
    pub point_a: u32,
    pub uplink_channel_bw_per_scs_list: UplinkChannelBwPerScsList,
    pub active_ulbwp: ActiveUlbwp,
    pub pci: Option<Nrpci>,
}

impl APerElement for SrsCarrierListItem {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(2),
            max: Some(2),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let point_a = u32::from_aper(decoder, UNCONSTRAINED)?;
        let uplink_channel_bw_per_scs_list =
            UplinkChannelBwPerScsList::from_aper(decoder, UNCONSTRAINED)?;
        let active_ulbwp = ActiveUlbwp::from_aper(decoder, UNCONSTRAINED)?;
        let pci = if optionals.is_set(0) {
            Some(Nrpci::from_aper(decoder, UNCONSTRAINED)?)
        } else {
            None
        };

        Ok(Self {
            point_a,
            uplink_channel_bw_per_scs_list,
            active_ulbwp,
            pci,
        })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(2);
        optionals.set(0, self.pci.is_some());
        optionals.set(1, false);

        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&self.point_a.to_aper(UNCONSTRAINED)?)?;
        enc.append(&self.uplink_channel_bw_per_scs_list.to_aper(UNCONSTRAINED)?)?;
        enc.append(&self.active_ulbwp.to_aper(UNCONSTRAINED)?)?;
        if let Some(x) = &self.pci {
            enc.append(&x.to_aper(UNCONSTRAINED)?)?;
        }

        Ok(enc)
    }
}

// SrsConfig
#[derive(Clone)]
pub struct SrsConfig {
    pub srs_resource_list: Option<SrsResourceList>,
    pub pos_srs_resource_list: Option<PosSrsResourceList>,
    pub srs_resource_set_list: Option<SrsResourceSetList1>,
    pub pos_srs_resource_set_list: Option<PosSrsResourceSetList>,
}

impl APerElement for SrsConfig {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(5),
            max: Some(5),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let srs_resource_list = if optionals.is_set(0) {
            Some(SrsResourceList::from_aper(decoder, UNCONSTRAINED)?)
        } else {
            None
        };
        let pos_srs_resource_list = if optionals.is_set(0) {
            Some(PosSrsResourceList::from_aper(decoder, UNCONSTRAINED)?)
        } else {
            None
        };
        let srs_resource_set_list = if optionals.is_set(0) {
            Some(SrsResourceSetList1::from_aper(decoder, UNCONSTRAINED)?)
        } else {
            None
        };
        let pos_srs_resource_set_list = if optionals.is_set(0) {
            Some(PosSrsResourceSetList::from_aper(decoder, UNCONSTRAINED)?)
        } else {
            None
        };

        Ok(Self {
            srs_resource_list,
            pos_srs_resource_list,
            srs_resource_set_list,
            pos_srs_resource_set_list,
        })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(5);
        optionals.set(0, self.srs_resource_list.is_some());
        optionals.set(1, self.pos_srs_resource_list.is_some());
        optionals.set(2, self.srs_resource_set_list.is_some());
        optionals.set(3, self.pos_srs_resource_set_list.is_some());
        optionals.set(4, false);

        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        if let Some(x) = &self.srs_resource_list {
            enc.append(&x.to_aper(UNCONSTRAINED)?)?;
        }
        if let Some(x) = &self.pos_srs_resource_list {
            enc.append(&x.to_aper(UNCONSTRAINED)?)?;
        }
        if let Some(x) = &self.srs_resource_set_list {
            enc.append(&x.to_aper(UNCONSTRAINED)?)?;
        }
        if let Some(x) = &self.pos_srs_resource_set_list {
            enc.append(&x.to_aper(UNCONSTRAINED)?)?;
        }

        Ok(enc)
    }
}

// SrsConfiguration
#[derive(Clone)]
pub struct SrsConfiguration {
    pub srs_carrier_list: SrsCarrierList,
}

impl APerElement for SrsConfiguration {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(1),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let _optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let srs_carrier_list = SrsCarrierList::from_aper(decoder, UNCONSTRAINED)?;

        Ok(Self { srs_carrier_list })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(1);
        optionals.set(0, false);

        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&self.srs_carrier_list.to_aper(UNCONSTRAINED)?)?;

        Ok(enc)
    }
}

// SrsFrequency
#[derive(Clone)]
pub struct SrsFrequency(pub u32);

impl APerElement for SrsFrequency {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(0),
            max: Some(0),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        Ok(Self(u32::from_aper(decoder, Self::CONSTRAINTS)?))
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&(self.0).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// SrsPosResourceId
#[derive(Clone)]
pub struct SrsPosResourceId(pub u8);

impl APerElement for SrsPosResourceId {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(0),
            max: Some(0),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        Ok(Self(u8::from_aper(decoder, Self::CONSTRAINTS)?))
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&(self.0).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// SrsResource
#[derive(Clone)]
pub struct SrsResource {
    pub srs_resource_id: SrsResourceId,
    pub nrof_srs_ports: NrofSrsPorts,
    pub transmission_comb: TransmissionComb,
    pub start_position: u8,
    pub nrof_symbols: NrofSymbols1,
    pub repetition_factor: RepetitionFactor,
    pub freq_domain_position: u8,
    pub freq_domain_shift: u16,
    pub c_srs: u8,
    pub b_srs: u8,
    pub b_hop: u8,
    pub group_or_sequence_hopping: GroupOrSequenceHopping1,
    pub resource_type: ResourceType,
    pub sequence_id: u16,
}

impl APerElement for SrsResource {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(1),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let _optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let srs_resource_id = SrsResourceId::from_aper(decoder, UNCONSTRAINED)?;
        let nrof_srs_ports = NrofSrsPorts::from_aper(decoder, UNCONSTRAINED)?;
        let transmission_comb = TransmissionComb::from_aper(decoder, UNCONSTRAINED)?;
        let start_position = u8::from_aper(decoder, UNCONSTRAINED)?;
        let nrof_symbols = NrofSymbols1::from_aper(decoder, UNCONSTRAINED)?;
        let repetition_factor = RepetitionFactor::from_aper(decoder, UNCONSTRAINED)?;
        let freq_domain_position = u8::from_aper(decoder, UNCONSTRAINED)?;
        let freq_domain_shift = u16::from_aper(decoder, UNCONSTRAINED)?;
        let c_srs = u8::from_aper(decoder, UNCONSTRAINED)?;
        let b_srs = u8::from_aper(decoder, UNCONSTRAINED)?;
        let b_hop = u8::from_aper(decoder, UNCONSTRAINED)?;
        let group_or_sequence_hopping = GroupOrSequenceHopping1::from_aper(decoder, UNCONSTRAINED)?;
        let resource_type = ResourceType::from_aper(decoder, UNCONSTRAINED)?;
        let sequence_id = u16::from_aper(decoder, UNCONSTRAINED)?;

        Ok(Self {
            srs_resource_id,
            nrof_srs_ports,
            transmission_comb,
            start_position,
            nrof_symbols,
            repetition_factor,
            freq_domain_position,
            freq_domain_shift,
            c_srs,
            b_srs,
            b_hop,
            group_or_sequence_hopping,
            resource_type,
            sequence_id,
        })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(1);
        optionals.set(0, false);

        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&self.srs_resource_id.to_aper(UNCONSTRAINED)?)?;
        enc.append(&self.nrof_srs_ports.to_aper(UNCONSTRAINED)?)?;
        enc.append(&self.transmission_comb.to_aper(UNCONSTRAINED)?)?;
        enc.append(&self.start_position.to_aper(UNCONSTRAINED)?)?;
        enc.append(&self.nrof_symbols.to_aper(UNCONSTRAINED)?)?;
        enc.append(&self.repetition_factor.to_aper(UNCONSTRAINED)?)?;
        enc.append(&self.freq_domain_position.to_aper(UNCONSTRAINED)?)?;
        enc.append(&self.freq_domain_shift.to_aper(UNCONSTRAINED)?)?;
        enc.append(&self.c_srs.to_aper(UNCONSTRAINED)?)?;
        enc.append(&self.b_srs.to_aper(UNCONSTRAINED)?)?;
        enc.append(&self.b_hop.to_aper(UNCONSTRAINED)?)?;
        enc.append(&self.group_or_sequence_hopping.to_aper(UNCONSTRAINED)?)?;
        enc.append(&self.resource_type.to_aper(UNCONSTRAINED)?)?;
        enc.append(&self.sequence_id.to_aper(UNCONSTRAINED)?)?;

        Ok(enc)
    }
}

// SrsResourceId
#[derive(Clone)]
pub struct SrsResourceId(pub u8);

impl APerElement for SrsResourceId {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(0),
            max: Some(0),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        Ok(Self(u8::from_aper(decoder, Self::CONSTRAINTS)?))
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&(self.0).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// SrsResourceIdList
#[derive(Clone)]
pub struct SrsResourceIdList(pub Vec<SrsResourceId>);

impl APerElement for SrsResourceIdList {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(1),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        Ok(Self(Vec::<SrsResourceId>::from_aper(
            decoder,
            Self::CONSTRAINTS,
        )?))
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&(self.0).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// SrsResourceList
#[derive(Clone)]
pub struct SrsResourceList(pub Vec<SrsResource>);

impl APerElement for SrsResourceList {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(1),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        Ok(Self(Vec::<SrsResource>::from_aper(
            decoder,
            Self::CONSTRAINTS,
        )?))
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&(self.0).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// SrsResourceSet
#[derive(Clone)]
pub struct SrsResourceSet {
    pub srs_resource_set_id: SrsResourceSetId,
    pub srs_resource_id_list: SrsResourceIdList,
    pub resource_set_type: ResourceSetType,
}

impl APerElement for SrsResourceSet {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(1),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let _optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let srs_resource_set_id = SrsResourceSetId::from_aper(decoder, UNCONSTRAINED)?;
        let srs_resource_id_list = SrsResourceIdList::from_aper(decoder, UNCONSTRAINED)?;
        let resource_set_type = ResourceSetType::from_aper(decoder, UNCONSTRAINED)?;

        Ok(Self {
            srs_resource_set_id,
            srs_resource_id_list,
            resource_set_type,
        })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(1);
        optionals.set(0, false);

        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&self.srs_resource_set_id.to_aper(UNCONSTRAINED)?)?;
        enc.append(&self.srs_resource_id_list.to_aper(UNCONSTRAINED)?)?;
        enc.append(&self.resource_set_type.to_aper(UNCONSTRAINED)?)?;

        Ok(enc)
    }
}

// SrsResourceSetId
#[derive(Clone)]
pub struct SrsResourceSetId(pub u8);

impl APerElement for SrsResourceSetId {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(0),
            max: Some(15),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        Ok(Self(u8::from_aper(decoder, Self::CONSTRAINTS)?))
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&(self.0).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// SrsResourceSetList
#[derive(Clone)]
pub struct SrsResourceSetList(pub Vec<SrsResourceSetItem>);

impl APerElement for SrsResourceSetList {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(1),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        Ok(Self(Vec::<SrsResourceSetItem>::from_aper(
            decoder,
            Self::CONSTRAINTS,
        )?))
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&(self.0).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// SrsResourceSetItem
#[derive(Clone)]
pub struct SrsResourceSetItem {
    pub num_sr_sresourcesperset: Option<u8>,
    pub periodicity_list: Option<PeriodicityList>,
    pub spatial_relation_info: Option<SpatialRelationInfo>,
    pub pathloss_reference_info: Option<PathlossReferenceInfo>,
}

impl APerElement for SrsResourceSetItem {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(5),
            max: Some(5),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let num_sr_sresourcesperset = if optionals.is_set(0) {
            Some(u8::from_aper(decoder, UNCONSTRAINED)?)
        } else {
            None
        };
        let periodicity_list = if optionals.is_set(0) {
            Some(PeriodicityList::from_aper(decoder, UNCONSTRAINED)?)
        } else {
            None
        };
        let spatial_relation_info = if optionals.is_set(0) {
            Some(SpatialRelationInfo::from_aper(decoder, UNCONSTRAINED)?)
        } else {
            None
        };
        let pathloss_reference_info = if optionals.is_set(0) {
            Some(PathlossReferenceInfo::from_aper(decoder, UNCONSTRAINED)?)
        } else {
            None
        };

        Ok(Self {
            num_sr_sresourcesperset,
            periodicity_list,
            spatial_relation_info,
            pathloss_reference_info,
        })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(5);
        optionals.set(0, self.num_sr_sresourcesperset.is_some());
        optionals.set(1, self.periodicity_list.is_some());
        optionals.set(2, self.spatial_relation_info.is_some());
        optionals.set(3, self.pathloss_reference_info.is_some());
        optionals.set(4, false);

        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        if let Some(x) = &self.num_sr_sresourcesperset {
            enc.append(&x.to_aper(UNCONSTRAINED)?)?;
        }
        if let Some(x) = &self.periodicity_list {
            enc.append(&x.to_aper(UNCONSTRAINED)?)?;
        }
        if let Some(x) = &self.spatial_relation_info {
            enc.append(&x.to_aper(UNCONSTRAINED)?)?;
        }
        if let Some(x) = &self.pathloss_reference_info {
            enc.append(&x.to_aper(UNCONSTRAINED)?)?;
        }

        Ok(enc)
    }
}

// SrsResourceSetList1
#[derive(Clone)]
pub struct SrsResourceSetList1(pub Vec<SrsResourceSet>);

impl APerElement for SrsResourceSetList1 {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(1),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        Ok(Self(Vec::<SrsResourceSet>::from_aper(
            decoder,
            Self::CONSTRAINTS,
        )?))
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&(self.0).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// SrsResourceTrigger
#[derive(Clone)]
pub struct SrsResourceTrigger {
    pub aperiodic_srs_resource_trigger_list: AperiodicSrsResourceTriggerList,
}

impl APerElement for SrsResourceTrigger {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(1),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let _optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let aperiodic_srs_resource_trigger_list =
            AperiodicSrsResourceTriggerList::from_aper(decoder, UNCONSTRAINED)?;

        Ok(Self {
            aperiodic_srs_resource_trigger_list,
        })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(1);
        optionals.set(0, false);

        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(
            &self
                .aperiodic_srs_resource_trigger_list
                .to_aper(UNCONSTRAINED)?,
        )?;

        Ok(enc)
    }
}

// Ssb
#[derive(Clone)]
pub struct Ssb {
    pub pci_nr: Nrpci,
    pub ssb_index: Option<SsbIndex>,
}

impl APerElement for Ssb {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(2),
            max: Some(2),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let pci_nr = Nrpci::from_aper(decoder, UNCONSTRAINED)?;
        let ssb_index = if optionals.is_set(0) {
            Some(SsbIndex::from_aper(decoder, UNCONSTRAINED)?)
        } else {
            None
        };

        Ok(Self { pci_nr, ssb_index })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(2);
        optionals.set(0, self.ssb_index.is_some());
        optionals.set(1, false);

        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&self.pci_nr.to_aper(UNCONSTRAINED)?)?;
        if let Some(x) = &self.ssb_index {
            enc.append(&x.to_aper(UNCONSTRAINED)?)?;
        }

        Ok(enc)
    }
}

// SsbFreqInfo
#[derive(Clone)]
pub struct SsbFreqInfo(pub u32);

impl APerElement for SsbFreqInfo {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(0),
            max: Some(0),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        Ok(Self(u32::from_aper(decoder, Self::CONSTRAINTS)?))
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&(self.0).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// SsbIndex
#[derive(Clone)]
pub struct SsbIndex(pub u8);

impl APerElement for SsbIndex {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(0),
            max: Some(0),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        Ok(Self(u8::from_aper(decoder, Self::CONSTRAINTS)?))
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&(self.0).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// SsbSubcarrierSpacing
#[derive(Clone, Copy, FromPrimitive)]
pub enum SsbSubcarrierSpacing {
    KHz15,
    KHz30,
    KHz120,
    KHz240,
    Spare3,
    Spare2,
    Spare1,
    _Extended,
}

impl APerElement for SsbSubcarrierSpacing {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        if bool::from_aper(decoder, Self::CONSTRAINTS)? {
            return Ok(SsbSubcarrierSpacing::_Extended);
        }
        let v = u8::from_aper(decoder, Self::CONSTRAINTS)?;
        FromPrimitive::from_u8(v).ok_or(DecodeError::MalformedInt)
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&false.to_aper(UNCONSTRAINED)?)?;
        enc.append(&(*self as u8).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// SsbTransmissionPeriodicity
#[derive(Clone, Copy, FromPrimitive)]
pub enum SsbTransmissionPeriodicity {
    Sf10,
    Sf20,
    Sf40,
    Sf80,
    Sf160,
    Sf320,
    Sf640,
    _Extended,
}

impl APerElement for SsbTransmissionPeriodicity {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        if bool::from_aper(decoder, Self::CONSTRAINTS)? {
            return Ok(SsbTransmissionPeriodicity::_Extended);
        }
        let v = u8::from_aper(decoder, Self::CONSTRAINTS)?;
        FromPrimitive::from_u8(v).ok_or(DecodeError::MalformedInt)
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&false.to_aper(UNCONSTRAINED)?)?;
        enc.append(&(*self as u8).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// SsbTransmissionTimingOffset
#[derive(Clone)]
pub struct SsbTransmissionTimingOffset(pub u8);

impl APerElement for SsbTransmissionTimingOffset {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(0),
            max: Some(127),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        Ok(Self(u8::from_aper(decoder, Self::CONSTRAINTS)?))
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&(self.0).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// SsbTransmissionBitmap
#[derive(Clone)]
pub enum SsbTransmissionBitmap {
    ShortBitmap(BitString),
    MediumBitmap(BitString),
    LongBitmap(BitString),
    _Extended,
}

impl APerElement for SsbTransmissionBitmap {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        match u8::from_aper(decoder, UNCONSTRAINED)? {
            0 => Ok(Self::ShortBitmap(BitString::from_aper(
                decoder,
                Constraints {
                    value: None,
                    size: Some(Constraint::new(Some(4), Some(4))),
                },
            )?)),
            1 => Ok(Self::MediumBitmap(BitString::from_aper(
                decoder,
                Constraints {
                    value: None,
                    size: Some(Constraint::new(Some(8), Some(8))),
                },
            )?)),
            2 => Ok(Self::LongBitmap(BitString::from_aper(
                decoder,
                Constraints {
                    value: None,
                    size: Some(Constraint::new(Some(64), Some(64))),
                },
            )?)),
            3 => Err(DecodeError::NotImplemented),
            _ => Err(DecodeError::InvalidChoice),
        }
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        match self {
            Self::ShortBitmap(x) => {
                enc.append(&(0 as u8).to_aper(UNCONSTRAINED)?)?;
                enc.append(&x.to_aper(Constraints {
                    value: None,
                    size: Some(Constraint::new(Some(4), Some(4))),
                })?)?;
            }
            Self::MediumBitmap(x) => {
                enc.append(&(1 as u8).to_aper(UNCONSTRAINED)?)?;
                enc.append(&x.to_aper(Constraints {
                    value: None,
                    size: Some(Constraint::new(Some(8), Some(8))),
                })?)?;
            }
            Self::LongBitmap(x) => {
                enc.append(&(2 as u8).to_aper(UNCONSTRAINED)?)?;
                enc.append(&x.to_aper(Constraints {
                    value: None,
                    size: Some(Constraint::new(Some(64), Some(64))),
                })?)?;
            }
            Self::_Extended => return Err(EncodeError::NotImplemented),
        }
        Ok(enc)
    }
}

// SsbAreaCapacityValueList
#[derive(Clone)]
pub struct SsbAreaCapacityValueList(pub Vec<SsbAreaCapacityValueItem>);

impl APerElement for SsbAreaCapacityValueList {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(1),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        Ok(Self(Vec::<SsbAreaCapacityValueItem>::from_aper(
            decoder,
            Self::CONSTRAINTS,
        )?))
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&(self.0).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// SsbAreaCapacityValueItem
#[derive(Clone)]
pub struct SsbAreaCapacityValueItem {
    pub ssb_index: u8,
    pub ssb_area_capacity_value: u8,
}

impl APerElement for SsbAreaCapacityValueItem {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(1),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let _optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let ssb_index = u8::from_aper(decoder, UNCONSTRAINED)?;
        let ssb_area_capacity_value = u8::from_aper(decoder, UNCONSTRAINED)?;

        Ok(Self {
            ssb_index,
            ssb_area_capacity_value,
        })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(1);
        optionals.set(0, false);

        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&self.ssb_index.to_aper(UNCONSTRAINED)?)?;
        enc.append(&self.ssb_area_capacity_value.to_aper(UNCONSTRAINED)?)?;

        Ok(enc)
    }
}

// SsbAreaRadioResourceStatusList
#[derive(Clone)]
pub struct SsbAreaRadioResourceStatusList(pub Vec<SsbAreaRadioResourceStatusItem>);

impl APerElement for SsbAreaRadioResourceStatusList {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(1),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        Ok(Self(Vec::<SsbAreaRadioResourceStatusItem>::from_aper(
            decoder,
            Self::CONSTRAINTS,
        )?))
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&(self.0).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// SsbAreaRadioResourceStatusItem
#[derive(Clone)]
pub struct SsbAreaRadioResourceStatusItem {
    pub ssb_index: u8,
    pub ssb_area_dlgbrpr_busage: u8,
    pub ssb_area_ulgbrpr_busage: u8,
    pub ssb_area_d_lnon_gbrpr_busage: u8,
    pub ssb_area_u_lnon_gbrpr_busage: u8,
    pub ssb_area_dl_total_pr_busage: u8,
    pub ssb_area_ul_total_pr_busage: u8,
    pub d_lscheduling_pdcchcc_eusage: Option<u8>,
    pub u_lscheduling_pdcchcc_eusage: Option<u8>,
}

impl APerElement for SsbAreaRadioResourceStatusItem {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(3),
            max: Some(3),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let ssb_index = u8::from_aper(decoder, UNCONSTRAINED)?;
        let ssb_area_dlgbrpr_busage = u8::from_aper(decoder, UNCONSTRAINED)?;
        let ssb_area_ulgbrpr_busage = u8::from_aper(decoder, UNCONSTRAINED)?;
        let ssb_area_d_lnon_gbrpr_busage = u8::from_aper(decoder, UNCONSTRAINED)?;
        let ssb_area_u_lnon_gbrpr_busage = u8::from_aper(decoder, UNCONSTRAINED)?;
        let ssb_area_dl_total_pr_busage = u8::from_aper(decoder, UNCONSTRAINED)?;
        let ssb_area_ul_total_pr_busage = u8::from_aper(decoder, UNCONSTRAINED)?;
        let d_lscheduling_pdcchcc_eusage = if optionals.is_set(0) {
            Some(u8::from_aper(decoder, UNCONSTRAINED)?)
        } else {
            None
        };
        let u_lscheduling_pdcchcc_eusage = if optionals.is_set(0) {
            Some(u8::from_aper(decoder, UNCONSTRAINED)?)
        } else {
            None
        };

        Ok(Self {
            ssb_index,
            ssb_area_dlgbrpr_busage,
            ssb_area_ulgbrpr_busage,
            ssb_area_d_lnon_gbrpr_busage,
            ssb_area_u_lnon_gbrpr_busage,
            ssb_area_dl_total_pr_busage,
            ssb_area_ul_total_pr_busage,
            d_lscheduling_pdcchcc_eusage,
            u_lscheduling_pdcchcc_eusage,
        })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(3);
        optionals.set(0, self.d_lscheduling_pdcchcc_eusage.is_some());
        optionals.set(1, self.u_lscheduling_pdcchcc_eusage.is_some());
        optionals.set(2, false);

        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&self.ssb_index.to_aper(UNCONSTRAINED)?)?;
        enc.append(&self.ssb_area_dlgbrpr_busage.to_aper(UNCONSTRAINED)?)?;
        enc.append(&self.ssb_area_ulgbrpr_busage.to_aper(UNCONSTRAINED)?)?;
        enc.append(&self.ssb_area_d_lnon_gbrpr_busage.to_aper(UNCONSTRAINED)?)?;
        enc.append(&self.ssb_area_u_lnon_gbrpr_busage.to_aper(UNCONSTRAINED)?)?;
        enc.append(&self.ssb_area_dl_total_pr_busage.to_aper(UNCONSTRAINED)?)?;
        enc.append(&self.ssb_area_ul_total_pr_busage.to_aper(UNCONSTRAINED)?)?;
        if let Some(x) = &self.d_lscheduling_pdcchcc_eusage {
            enc.append(&x.to_aper(UNCONSTRAINED)?)?;
        }
        if let Some(x) = &self.u_lscheduling_pdcchcc_eusage {
            enc.append(&x.to_aper(UNCONSTRAINED)?)?;
        }

        Ok(enc)
    }
}

// SsbInformation
#[derive(Clone)]
pub struct SsbInformation {
    pub ssb_information_list: SsbInformationList,
}

impl APerElement for SsbInformation {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(1),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let _optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let ssb_information_list = SsbInformationList::from_aper(decoder, UNCONSTRAINED)?;

        Ok(Self {
            ssb_information_list,
        })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(1);
        optionals.set(0, false);

        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&self.ssb_information_list.to_aper(UNCONSTRAINED)?)?;

        Ok(enc)
    }
}

// SsbInformationList
#[derive(Clone)]
pub struct SsbInformationList(pub Vec<SsbInformationItem>);

impl APerElement for SsbInformationList {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(1),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        Ok(Self(Vec::<SsbInformationItem>::from_aper(
            decoder,
            Self::CONSTRAINTS,
        )?))
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&(self.0).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// SsbInformationItem
#[derive(Clone)]
pub struct SsbInformationItem {
    pub ssb_configuration: SsbTfConfiguration,
    pub pci_nr: Nrpci,
}

impl APerElement for SsbInformationItem {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(1),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let _optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let ssb_configuration = SsbTfConfiguration::from_aper(decoder, UNCONSTRAINED)?;
        let pci_nr = Nrpci::from_aper(decoder, UNCONSTRAINED)?;

        Ok(Self {
            ssb_configuration,
            pci_nr,
        })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(1);
        optionals.set(0, false);

        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&self.ssb_configuration.to_aper(UNCONSTRAINED)?)?;
        enc.append(&self.pci_nr.to_aper(UNCONSTRAINED)?)?;

        Ok(enc)
    }
}

// SsbPositionsInBurst
#[derive(Clone)]
pub enum SsbPositionsInBurst {
    ShortBitmap(BitString),
    MediumBitmap(BitString),
    LongBitmap(BitString),
    _Extended,
}

impl APerElement for SsbPositionsInBurst {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        match u8::from_aper(decoder, UNCONSTRAINED)? {
            0 => Ok(Self::ShortBitmap(BitString::from_aper(
                decoder,
                Constraints {
                    value: None,
                    size: Some(Constraint::new(Some(4), Some(4))),
                },
            )?)),
            1 => Ok(Self::MediumBitmap(BitString::from_aper(
                decoder,
                Constraints {
                    value: None,
                    size: Some(Constraint::new(Some(8), Some(8))),
                },
            )?)),
            2 => Ok(Self::LongBitmap(BitString::from_aper(
                decoder,
                Constraints {
                    value: None,
                    size: Some(Constraint::new(Some(64), Some(64))),
                },
            )?)),
            3 => Err(DecodeError::NotImplemented),
            _ => Err(DecodeError::InvalidChoice),
        }
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        match self {
            Self::ShortBitmap(x) => {
                enc.append(&(0 as u8).to_aper(UNCONSTRAINED)?)?;
                enc.append(&x.to_aper(Constraints {
                    value: None,
                    size: Some(Constraint::new(Some(4), Some(4))),
                })?)?;
            }
            Self::MediumBitmap(x) => {
                enc.append(&(1 as u8).to_aper(UNCONSTRAINED)?)?;
                enc.append(&x.to_aper(Constraints {
                    value: None,
                    size: Some(Constraint::new(Some(8), Some(8))),
                })?)?;
            }
            Self::LongBitmap(x) => {
                enc.append(&(2 as u8).to_aper(UNCONSTRAINED)?)?;
                enc.append(&x.to_aper(Constraints {
                    value: None,
                    size: Some(Constraint::new(Some(64), Some(64))),
                })?)?;
            }
            Self::_Extended => return Err(EncodeError::NotImplemented),
        }
        Ok(enc)
    }
}

// SsbTfConfiguration
#[derive(Clone)]
pub struct SsbTfConfiguration {
    pub ssb_frequency: u32,
    pub ssb_subcarrier_spacing: SsbSubcarrierSpacing1,
    pub ssb_transmit_power: u8,
    pub ssb_periodicity: SsbPeriodicity,
    pub ssb_half_frame_offset: u8,
    pub ssb_sfn_offset: u8,
    pub ssb_position_in_burst: Option<SsbPositionsInBurst>,
    pub sfn_initialisation_time: Option<RelativeTime1900>,
}

impl APerElement for SsbTfConfiguration {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(3),
            max: Some(3),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let ssb_frequency = u32::from_aper(decoder, UNCONSTRAINED)?;
        let ssb_subcarrier_spacing = SsbSubcarrierSpacing1::from_aper(decoder, UNCONSTRAINED)?;
        let ssb_transmit_power = u8::from_aper(decoder, UNCONSTRAINED)?;
        let ssb_periodicity = SsbPeriodicity::from_aper(decoder, UNCONSTRAINED)?;
        let ssb_half_frame_offset = u8::from_aper(decoder, UNCONSTRAINED)?;
        let ssb_sfn_offset = u8::from_aper(decoder, UNCONSTRAINED)?;
        let ssb_position_in_burst = if optionals.is_set(0) {
            Some(SsbPositionsInBurst::from_aper(decoder, UNCONSTRAINED)?)
        } else {
            None
        };
        let sfn_initialisation_time = if optionals.is_set(0) {
            Some(RelativeTime1900::from_aper(decoder, UNCONSTRAINED)?)
        } else {
            None
        };

        Ok(Self {
            ssb_frequency,
            ssb_subcarrier_spacing,
            ssb_transmit_power,
            ssb_periodicity,
            ssb_half_frame_offset,
            ssb_sfn_offset,
            ssb_position_in_burst,
            sfn_initialisation_time,
        })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(3);
        optionals.set(0, self.ssb_position_in_burst.is_some());
        optionals.set(1, self.sfn_initialisation_time.is_some());
        optionals.set(2, false);

        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&self.ssb_frequency.to_aper(UNCONSTRAINED)?)?;
        enc.append(&self.ssb_subcarrier_spacing.to_aper(UNCONSTRAINED)?)?;
        enc.append(&self.ssb_transmit_power.to_aper(UNCONSTRAINED)?)?;
        enc.append(&self.ssb_periodicity.to_aper(UNCONSTRAINED)?)?;
        enc.append(&self.ssb_half_frame_offset.to_aper(UNCONSTRAINED)?)?;
        enc.append(&self.ssb_sfn_offset.to_aper(UNCONSTRAINED)?)?;
        if let Some(x) = &self.ssb_position_in_burst {
            enc.append(&x.to_aper(UNCONSTRAINED)?)?;
        }
        if let Some(x) = &self.sfn_initialisation_time {
            enc.append(&x.to_aper(UNCONSTRAINED)?)?;
        }

        Ok(enc)
    }
}

// SsbToReportList
#[derive(Clone)]
pub struct SsbToReportList(pub Vec<SsbToReportItem>);

impl APerElement for SsbToReportList {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(1),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        Ok(Self(Vec::<SsbToReportItem>::from_aper(
            decoder,
            Self::CONSTRAINTS,
        )?))
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&(self.0).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// SsbToReportItem
#[derive(Clone)]
pub struct SsbToReportItem {
    pub ssb_index: u8,
}

impl APerElement for SsbToReportItem {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(1),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let _optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let ssb_index = u8::from_aper(decoder, UNCONSTRAINED)?;

        Ok(Self { ssb_index })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(1);
        optionals.set(0, false);

        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&self.ssb_index.to_aper(UNCONSTRAINED)?)?;

        Ok(enc)
    }
}

// SulInformation
#[derive(Clone)]
pub struct SulInformation {
    pub sul_nrarfcn: u32,
    pub sul_transmission_bandwidth: TransmissionBandwidth,
}

impl APerElement for SulInformation {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(1),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let _extended = bool::from_aper(decoder, UNCONSTRAINED)?;
        let _optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let sul_nrarfcn = u32::from_aper(decoder, UNCONSTRAINED)?;
        let sul_transmission_bandwidth = TransmissionBandwidth::from_aper(decoder, UNCONSTRAINED)?;

        Ok(Self {
            sul_nrarfcn,
            sul_transmission_bandwidth,
        })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(1);
        optionals.set(0, false);

        enc.append(&false.to_aper(UNCONSTRAINED)?)?;
        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&self.sul_nrarfcn.to_aper(UNCONSTRAINED)?)?;
        enc.append(&self.sul_transmission_bandwidth.to_aper(UNCONSTRAINED)?)?;

        Ok(enc)
    }
}

// SubcarrierSpacing
#[derive(Clone, Copy, FromPrimitive)]
pub enum SubcarrierSpacing {
    KHz15,
    KHz30,
    KHz60,
    KHz120,
    KHz240,
    Spare3,
    Spare2,
    Spare1,
    _Extended,
}

impl APerElement for SubcarrierSpacing {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        if bool::from_aper(decoder, Self::CONSTRAINTS)? {
            return Ok(SubcarrierSpacing::_Extended);
        }
        let v = u8::from_aper(decoder, Self::CONSTRAINTS)?;
        FromPrimitive::from_u8(v).ok_or(DecodeError::MalformedInt)
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&false.to_aper(UNCONSTRAINED)?)?;
        enc.append(&(*self as u8).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// SubscriberProfileIDforRfp
#[derive(Clone)]
pub struct SubscriberProfileIDforRfp(pub u8);

impl APerElement for SubscriberProfileIDforRfp {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(256),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        Ok(Self(u8::from_aper(decoder, Self::CONSTRAINTS)?))
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&(self.0).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// SulAccessIndication
#[derive(Clone, Copy, FromPrimitive)]
pub enum SulAccessIndication {
    True,
    _Extended,
}

impl APerElement for SulAccessIndication {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        if bool::from_aper(decoder, Self::CONSTRAINTS)? {
            return Ok(SulAccessIndication::_Extended);
        }
        let v = u8::from_aper(decoder, Self::CONSTRAINTS)?;
        FromPrimitive::from_u8(v).ok_or(DecodeError::MalformedInt)
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&false.to_aper(UNCONSTRAINED)?)?;
        enc.append(&(*self as u8).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// SupportedSulFreqBandItem
#[derive(Clone)]
pub struct SupportedSulFreqBandItem {
    pub freq_band_indicator_nr: u16,
}

impl APerElement for SupportedSulFreqBandItem {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(1),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let _extended = bool::from_aper(decoder, UNCONSTRAINED)?;
        let _optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let freq_band_indicator_nr = u16::from_aper(decoder, UNCONSTRAINED)?;

        Ok(Self {
            freq_band_indicator_nr,
        })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(1);
        optionals.set(0, false);

        enc.append(&false.to_aper(UNCONSTRAINED)?)?;
        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&self.freq_band_indicator_nr.to_aper(UNCONSTRAINED)?)?;

        Ok(enc)
    }
}

// SymbolAllocInSlot
#[derive(Clone)]
pub enum SymbolAllocInSlot {
    AllDl,
    AllUl,
    BothDlAndUl(NumDlulSymbols),
    _Extended,
}

impl APerElement for SymbolAllocInSlot {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        match u8::from_aper(decoder, UNCONSTRAINED)? {
            0 => Ok(Self::AllDl),
            1 => Ok(Self::AllUl),
            2 => Ok(Self::BothDlAndUl(NumDlulSymbols::from_aper(
                decoder,
                UNCONSTRAINED,
            )?)),
            3 => Err(DecodeError::NotImplemented),
            _ => Err(DecodeError::InvalidChoice),
        }
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        match self {
            Self::AllDl => {
                enc.append(&(0 as u8).to_aper(UNCONSTRAINED)?)?;
            }
            Self::AllUl => {
                enc.append(&(1 as u8).to_aper(UNCONSTRAINED)?)?;
            }
            Self::BothDlAndUl(x) => {
                enc.append(&(2 as u8).to_aper(UNCONSTRAINED)?)?;
                enc.append(&x.to_aper(UNCONSTRAINED)?)?;
            }
            Self::_Extended => return Err(EncodeError::NotImplemented),
        }
        Ok(enc)
    }
}

// SystemFrameNumber
#[derive(Clone)]
pub struct SystemFrameNumber(pub u16);

impl APerElement for SystemFrameNumber {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(0),
            max: Some(0),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        Ok(Self(u16::from_aper(decoder, Self::CONSTRAINTS)?))
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&(self.0).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// SystemInformationAreaId
#[derive(Clone)]
pub struct SystemInformationAreaId(pub BitString);

impl APerElement for SystemInformationAreaId {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(24),
            max: Some(24),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        Ok(Self(BitString::from_aper(decoder, Self::CONSTRAINTS)?))
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&(self.0).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// FiveGsTac
#[derive(Clone)]
pub struct FiveGsTac(pub Vec<u8>);

impl APerElement for FiveGsTac {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(3),
            max: Some(3),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        Ok(Self(Vec::<u8>::from_aper(decoder, Self::CONSTRAINTS)?))
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&(self.0).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// ConfiguredEpsTac
#[derive(Clone)]
pub struct ConfiguredEpsTac(pub Vec<u8>);

impl APerElement for ConfiguredEpsTac {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(2),
            max: Some(2),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        Ok(Self(Vec::<u8>::from_aper(decoder, Self::CONSTRAINTS)?))
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&(self.0).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// TargetCellList
#[derive(Clone)]
pub struct TargetCellList(pub Vec<TargetCellListItem>);

impl APerElement for TargetCellList {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(1),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        Ok(Self(Vec::<TargetCellListItem>::from_aper(
            decoder,
            Self::CONSTRAINTS,
        )?))
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&(self.0).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// TargetCellListItem
#[derive(Clone)]
pub struct TargetCellListItem {
    pub target_cell: Nrcgi,
}

impl APerElement for TargetCellListItem {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(1),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let _optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let target_cell = Nrcgi::from_aper(decoder, UNCONSTRAINED)?;

        Ok(Self { target_cell })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(1);
        optionals.set(0, false);

        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&self.target_cell.to_aper(UNCONSTRAINED)?)?;

        Ok(enc)
    }
}

// TddInfo
#[derive(Clone)]
pub struct TddInfo {
    pub nr_freq_info: NrFreqInfo,
    pub transmission_bandwidth: TransmissionBandwidth,
}

impl APerElement for TddInfo {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(1),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let _extended = bool::from_aper(decoder, UNCONSTRAINED)?;
        let _optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let nr_freq_info = NrFreqInfo::from_aper(decoder, UNCONSTRAINED)?;
        let transmission_bandwidth = TransmissionBandwidth::from_aper(decoder, UNCONSTRAINED)?;

        Ok(Self {
            nr_freq_info,
            transmission_bandwidth,
        })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(1);
        optionals.set(0, false);

        enc.append(&false.to_aper(UNCONSTRAINED)?)?;
        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&self.nr_freq_info.to_aper(UNCONSTRAINED)?)?;
        enc.append(&self.transmission_bandwidth.to_aper(UNCONSTRAINED)?)?;

        Ok(enc)
    }
}

// TddUlDlConfigCommonNr
#[derive(Clone)]
pub struct TddUlDlConfigCommonNr(pub Vec<u8>);

impl APerElement for TddUlDlConfigCommonNr {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        Ok(Self(Vec::<u8>::from_aper(decoder, Self::CONSTRAINTS)?))
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&(self.0).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// TimeReferenceInformation
#[derive(Clone)]
pub struct TimeReferenceInformation {
    pub reference_time: ReferenceTime,
    pub reference_sfn: ReferenceSfn,
    pub uncertainty: Uncertainty,
    pub time_information_type: TimeInformationType,
}

impl APerElement for TimeReferenceInformation {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(1),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let _optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let reference_time = ReferenceTime::from_aper(decoder, UNCONSTRAINED)?;
        let reference_sfn = ReferenceSfn::from_aper(decoder, UNCONSTRAINED)?;
        let uncertainty = Uncertainty::from_aper(decoder, UNCONSTRAINED)?;
        let time_information_type = TimeInformationType::from_aper(decoder, UNCONSTRAINED)?;

        Ok(Self {
            reference_time,
            reference_sfn,
            uncertainty,
            time_information_type,
        })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(1);
        optionals.set(0, false);

        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&self.reference_time.to_aper(UNCONSTRAINED)?)?;
        enc.append(&self.reference_sfn.to_aper(UNCONSTRAINED)?)?;
        enc.append(&self.uncertainty.to_aper(UNCONSTRAINED)?)?;
        enc.append(&self.time_information_type.to_aper(UNCONSTRAINED)?)?;

        Ok(enc)
    }
}

// TimeInformationType
#[derive(Clone, Copy, FromPrimitive)]
pub enum TimeInformationType {
    LocalClock,
}

impl APerElement for TimeInformationType {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let v = u8::from_aper(decoder, Self::CONSTRAINTS)?;
        FromPrimitive::from_u8(v).ok_or(DecodeError::MalformedInt)
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&(*self as u8).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// TimeStamp
#[derive(Clone)]
pub struct TimeStamp {
    pub system_frame_number: SystemFrameNumber,
    pub slot_index: TimeStampSlotIndex,
    pub measurement_time: Option<RelativeTime1900>,
}

impl APerElement for TimeStamp {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(2),
            max: Some(2),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let system_frame_number = SystemFrameNumber::from_aper(decoder, UNCONSTRAINED)?;
        let slot_index = TimeStampSlotIndex::from_aper(decoder, UNCONSTRAINED)?;
        let measurement_time = if optionals.is_set(0) {
            Some(RelativeTime1900::from_aper(decoder, UNCONSTRAINED)?)
        } else {
            None
        };

        Ok(Self {
            system_frame_number,
            slot_index,
            measurement_time,
        })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(2);
        optionals.set(0, self.measurement_time.is_some());
        optionals.set(1, false);

        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&self.system_frame_number.to_aper(UNCONSTRAINED)?)?;
        enc.append(&self.slot_index.to_aper(UNCONSTRAINED)?)?;
        if let Some(x) = &self.measurement_time {
            enc.append(&x.to_aper(UNCONSTRAINED)?)?;
        }

        Ok(enc)
    }
}

// TimeStampSlotIndex
#[derive(Clone)]
pub enum TimeStampSlotIndex {
    Scs15(u8),
    Scs30(u8),
    Scs60(u8),
    Scs120(u8),
    _Extended,
}

impl APerElement for TimeStampSlotIndex {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        match u8::from_aper(decoder, UNCONSTRAINED)? {
            0 => Ok(Self::Scs15(u8::from_aper(decoder, UNCONSTRAINED)?)),
            1 => Ok(Self::Scs30(u8::from_aper(decoder, UNCONSTRAINED)?)),
            2 => Ok(Self::Scs60(u8::from_aper(decoder, UNCONSTRAINED)?)),
            3 => Ok(Self::Scs120(u8::from_aper(decoder, UNCONSTRAINED)?)),
            4 => Err(DecodeError::NotImplemented),
            _ => Err(DecodeError::InvalidChoice),
        }
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        match self {
            Self::Scs15(x) => {
                enc.append(&(0 as u8).to_aper(UNCONSTRAINED)?)?;
                enc.append(&x.to_aper(UNCONSTRAINED)?)?;
            }
            Self::Scs30(x) => {
                enc.append(&(1 as u8).to_aper(UNCONSTRAINED)?)?;
                enc.append(&x.to_aper(UNCONSTRAINED)?)?;
            }
            Self::Scs60(x) => {
                enc.append(&(2 as u8).to_aper(UNCONSTRAINED)?)?;
                enc.append(&x.to_aper(UNCONSTRAINED)?)?;
            }
            Self::Scs120(x) => {
                enc.append(&(3 as u8).to_aper(UNCONSTRAINED)?)?;
                enc.append(&x.to_aper(UNCONSTRAINED)?)?;
            }
            Self::_Extended => return Err(EncodeError::NotImplemented),
        }
        Ok(enc)
    }
}

// TimeToWait
#[derive(Clone, Copy, FromPrimitive)]
pub enum TimeToWait {
    V1s,
    V2s,
    V5s,
    V10s,
    V20s,
    V60s,
    _Extended,
}

impl APerElement for TimeToWait {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        if bool::from_aper(decoder, Self::CONSTRAINTS)? {
            return Ok(TimeToWait::_Extended);
        }
        let v = u8::from_aper(decoder, Self::CONSTRAINTS)?;
        FromPrimitive::from_u8(v).ok_or(DecodeError::MalformedInt)
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&false.to_aper(UNCONSTRAINED)?)?;
        enc.append(&(*self as u8).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// TimingMeasurementQuality
#[derive(Clone)]
pub struct TimingMeasurementQuality {
    pub measurement_quality: u8,
    pub resolution: Resolution1,
}

impl APerElement for TimingMeasurementQuality {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(1),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let _optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let measurement_quality = u8::from_aper(decoder, UNCONSTRAINED)?;
        let resolution = Resolution1::from_aper(decoder, UNCONSTRAINED)?;

        Ok(Self {
            measurement_quality,
            resolution,
        })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(1);
        optionals.set(0, false);

        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&self.measurement_quality.to_aper(UNCONSTRAINED)?)?;
        enc.append(&self.resolution.to_aper(UNCONSTRAINED)?)?;

        Ok(enc)
    }
}

// TnlAssociationUsage
#[derive(Clone, Copy, FromPrimitive)]
pub enum TnlAssociationUsage {
    Ue,
    NonUe,
    Both,
    _Extended,
}

impl APerElement for TnlAssociationUsage {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        if bool::from_aper(decoder, Self::CONSTRAINTS)? {
            return Ok(TnlAssociationUsage::_Extended);
        }
        let v = u8::from_aper(decoder, Self::CONSTRAINTS)?;
        FromPrimitive::from_u8(v).ok_or(DecodeError::MalformedInt)
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&false.to_aper(UNCONSTRAINED)?)?;
        enc.append(&(*self as u8).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// TnlCapacityIndicator
#[derive(Clone)]
pub struct TnlCapacityIndicator {
    pub dltnl_offered_capacity: u32,
    pub dltnl_available_capacity: u8,
    pub ultnl_offered_capacity: u32,
    pub ultnl_available_capacity: u8,
}

impl APerElement for TnlCapacityIndicator {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(1),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let _optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let dltnl_offered_capacity = u32::from_aper(decoder, UNCONSTRAINED)?;
        let dltnl_available_capacity = u8::from_aper(decoder, UNCONSTRAINED)?;
        let ultnl_offered_capacity = u32::from_aper(decoder, UNCONSTRAINED)?;
        let ultnl_available_capacity = u8::from_aper(decoder, UNCONSTRAINED)?;

        Ok(Self {
            dltnl_offered_capacity,
            dltnl_available_capacity,
            ultnl_offered_capacity,
            ultnl_available_capacity,
        })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(1);
        optionals.set(0, false);

        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&self.dltnl_offered_capacity.to_aper(UNCONSTRAINED)?)?;
        enc.append(&self.dltnl_available_capacity.to_aper(UNCONSTRAINED)?)?;
        enc.append(&self.ultnl_offered_capacity.to_aper(UNCONSTRAINED)?)?;
        enc.append(&self.ultnl_available_capacity.to_aper(UNCONSTRAINED)?)?;

        Ok(enc)
    }
}

// TraceActivation
#[derive(Clone)]
pub struct TraceActivation {
    pub trace_id: TraceId,
    pub interfaces_to_trace: InterfacesToTrace,
    pub trace_depth: TraceDepth,
    pub trace_collection_entity_ip_address: TransportLayerAddress,
}

impl APerElement for TraceActivation {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(1),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let _optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let trace_id = TraceId::from_aper(decoder, UNCONSTRAINED)?;
        let interfaces_to_trace = InterfacesToTrace::from_aper(decoder, UNCONSTRAINED)?;
        let trace_depth = TraceDepth::from_aper(decoder, UNCONSTRAINED)?;
        let trace_collection_entity_ip_address =
            TransportLayerAddress::from_aper(decoder, UNCONSTRAINED)?;

        Ok(Self {
            trace_id,
            interfaces_to_trace,
            trace_depth,
            trace_collection_entity_ip_address,
        })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(1);
        optionals.set(0, false);

        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&self.trace_id.to_aper(UNCONSTRAINED)?)?;
        enc.append(&self.interfaces_to_trace.to_aper(UNCONSTRAINED)?)?;
        enc.append(&self.trace_depth.to_aper(UNCONSTRAINED)?)?;
        enc.append(
            &self
                .trace_collection_entity_ip_address
                .to_aper(UNCONSTRAINED)?,
        )?;

        Ok(enc)
    }
}

// TraceDepth
#[derive(Clone, Copy, FromPrimitive)]
pub enum TraceDepth {
    Minimum,
    Medium,
    Maximum,
    MinimumWithoutVendorSpecificExtension,
    MediumWithoutVendorSpecificExtension,
    MaximumWithoutVendorSpecificExtension,
    _Extended,
}

impl APerElement for TraceDepth {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        if bool::from_aper(decoder, Self::CONSTRAINTS)? {
            return Ok(TraceDepth::_Extended);
        }
        let v = u8::from_aper(decoder, Self::CONSTRAINTS)?;
        FromPrimitive::from_u8(v).ok_or(DecodeError::MalformedInt)
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&false.to_aper(UNCONSTRAINED)?)?;
        enc.append(&(*self as u8).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// TraceId
#[derive(Clone)]
pub struct TraceId(pub Vec<u8>);

impl APerElement for TraceId {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(8),
            max: Some(8),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        Ok(Self(Vec::<u8>::from_aper(decoder, Self::CONSTRAINTS)?))
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&(self.0).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// TrafficMappingInfo
#[derive(Clone)]
pub enum TrafficMappingInfo {
    IPtolayer2TrafficMappingInfo(IPtolayer2TrafficMappingInfo),
    BaPlayerBhrlCchannelMappingInfo(BaPlayerBhrlCchannelMappingInfo),
    _Extended,
}

impl APerElement for TrafficMappingInfo {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        match u8::from_aper(decoder, UNCONSTRAINED)? {
            0 => Ok(Self::IPtolayer2TrafficMappingInfo(
                IPtolayer2TrafficMappingInfo::from_aper(decoder, UNCONSTRAINED)?,
            )),
            1 => Ok(Self::BaPlayerBhrlCchannelMappingInfo(
                BaPlayerBhrlCchannelMappingInfo::from_aper(decoder, UNCONSTRAINED)?,
            )),
            2 => Err(DecodeError::NotImplemented),
            _ => Err(DecodeError::InvalidChoice),
        }
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        match self {
            Self::IPtolayer2TrafficMappingInfo(x) => {
                enc.append(&(0 as u8).to_aper(UNCONSTRAINED)?)?;
                enc.append(&x.to_aper(UNCONSTRAINED)?)?;
            }
            Self::BaPlayerBhrlCchannelMappingInfo(x) => {
                enc.append(&(1 as u8).to_aper(UNCONSTRAINED)?)?;
                enc.append(&x.to_aper(UNCONSTRAINED)?)?;
            }
            Self::_Extended => return Err(EncodeError::NotImplemented),
        }
        Ok(enc)
    }
}

// TransportLayerAddress
#[derive(Clone)]
pub struct TransportLayerAddress(pub BitString);

impl APerElement for TransportLayerAddress {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(160),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        Ok(Self(BitString::from_aper(decoder, Self::CONSTRAINTS)?))
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&(self.0).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// TransactionId
#[derive(Clone)]
pub struct TransactionId(pub u8);

impl APerElement for TransactionId {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(0),
            max: Some(255),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        Ok(Self(u8::from_aper(decoder, Self::CONSTRAINTS)?))
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&(self.0).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// TransmissionBandwidth
#[derive(Clone)]
pub struct TransmissionBandwidth {
    pub nrscs: Nrscs,
    pub nrnrb: Nrnrb,
}

impl APerElement for TransmissionBandwidth {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(1),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let _extended = bool::from_aper(decoder, UNCONSTRAINED)?;
        let _optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let nrscs = Nrscs::from_aper(decoder, UNCONSTRAINED)?;
        let nrnrb = Nrnrb::from_aper(decoder, UNCONSTRAINED)?;

        Ok(Self { nrscs, nrnrb })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(1);
        optionals.set(0, false);

        enc.append(&false.to_aper(UNCONSTRAINED)?)?;
        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&self.nrscs.to_aper(UNCONSTRAINED)?)?;
        enc.append(&self.nrnrb.to_aper(UNCONSTRAINED)?)?;

        Ok(enc)
    }
}

// TransmissionComb
#[derive(Clone)]
pub enum TransmissionComb {
    N2(N2),
    N4(N4),
    _Extended,
}

impl APerElement for TransmissionComb {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        match u8::from_aper(decoder, UNCONSTRAINED)? {
            0 => Ok(Self::N2(N2::from_aper(decoder, UNCONSTRAINED)?)),
            1 => Ok(Self::N4(N4::from_aper(decoder, UNCONSTRAINED)?)),
            2 => Err(DecodeError::NotImplemented),
            _ => Err(DecodeError::InvalidChoice),
        }
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        match self {
            Self::N2(x) => {
                enc.append(&(0 as u8).to_aper(UNCONSTRAINED)?)?;
                enc.append(&x.to_aper(UNCONSTRAINED)?)?;
            }
            Self::N4(x) => {
                enc.append(&(1 as u8).to_aper(UNCONSTRAINED)?)?;
                enc.append(&x.to_aper(UNCONSTRAINED)?)?;
            }
            Self::_Extended => return Err(EncodeError::NotImplemented),
        }
        Ok(enc)
    }
}

// TransmissionCombPos
#[derive(Clone)]
pub enum TransmissionCombPos {
    N2(N21),
    N4(N41),
    N8(N8),
    _Extended,
}

impl APerElement for TransmissionCombPos {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        match u8::from_aper(decoder, UNCONSTRAINED)? {
            0 => Ok(Self::N2(N21::from_aper(decoder, UNCONSTRAINED)?)),
            1 => Ok(Self::N4(N41::from_aper(decoder, UNCONSTRAINED)?)),
            2 => Ok(Self::N8(N8::from_aper(decoder, UNCONSTRAINED)?)),
            3 => Err(DecodeError::NotImplemented),
            _ => Err(DecodeError::InvalidChoice),
        }
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        match self {
            Self::N2(x) => {
                enc.append(&(0 as u8).to_aper(UNCONSTRAINED)?)?;
                enc.append(&x.to_aper(UNCONSTRAINED)?)?;
            }
            Self::N4(x) => {
                enc.append(&(1 as u8).to_aper(UNCONSTRAINED)?)?;
                enc.append(&x.to_aper(UNCONSTRAINED)?)?;
            }
            Self::N8(x) => {
                enc.append(&(2 as u8).to_aper(UNCONSTRAINED)?)?;
                enc.append(&x.to_aper(UNCONSTRAINED)?)?;
            }
            Self::_Extended => return Err(EncodeError::NotImplemented),
        }
        Ok(enc)
    }
}

// TransmissionStopIndicator
#[derive(Clone, Copy, FromPrimitive)]
pub enum TransmissionStopIndicator {
    True,
    _Extended,
}

impl APerElement for TransmissionStopIndicator {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        if bool::from_aper(decoder, Self::CONSTRAINTS)? {
            return Ok(TransmissionStopIndicator::_Extended);
        }
        let v = u8::from_aper(decoder, Self::CONSTRAINTS)?;
        FromPrimitive::from_u8(v).ok_or(DecodeError::MalformedInt)
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&false.to_aper(UNCONSTRAINED)?)?;
        enc.append(&(*self as u8).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// TransportUpLayerAddressInfoToAddList
#[derive(Clone)]
pub struct TransportUpLayerAddressInfoToAddList(pub Vec<TransportUpLayerAddressInfoToAddItem>);

impl APerElement for TransportUpLayerAddressInfoToAddList {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(1),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        Ok(Self(
            Vec::<TransportUpLayerAddressInfoToAddItem>::from_aper(decoder, Self::CONSTRAINTS)?,
        ))
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&(self.0).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// TransportUpLayerAddressInfoToAddItem
#[derive(Clone)]
pub struct TransportUpLayerAddressInfoToAddItem {
    pub ip_sec_transport_layer_address: TransportLayerAddress,
    pub gtp_transport_layer_address_to_add: Option<GtptlAs>,
}

impl APerElement for TransportUpLayerAddressInfoToAddItem {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(2),
            max: Some(2),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let ip_sec_transport_layer_address =
            TransportLayerAddress::from_aper(decoder, UNCONSTRAINED)?;
        let gtp_transport_layer_address_to_add = if optionals.is_set(0) {
            Some(GtptlAs::from_aper(decoder, UNCONSTRAINED)?)
        } else {
            None
        };

        Ok(Self {
            ip_sec_transport_layer_address,
            gtp_transport_layer_address_to_add,
        })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(2);
        optionals.set(0, self.gtp_transport_layer_address_to_add.is_some());
        optionals.set(1, false);

        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&self.ip_sec_transport_layer_address.to_aper(UNCONSTRAINED)?)?;
        if let Some(x) = &self.gtp_transport_layer_address_to_add {
            enc.append(&x.to_aper(UNCONSTRAINED)?)?;
        }

        Ok(enc)
    }
}

// TransportUpLayerAddressInfoToRemoveList
#[derive(Clone)]
pub struct TransportUpLayerAddressInfoToRemoveList(
    pub Vec<TransportUpLayerAddressInfoToRemoveItem>,
);

impl APerElement for TransportUpLayerAddressInfoToRemoveList {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(1),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        Ok(Self(
            Vec::<TransportUpLayerAddressInfoToRemoveItem>::from_aper(decoder, Self::CONSTRAINTS)?,
        ))
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&(self.0).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// TransportUpLayerAddressInfoToRemoveItem
#[derive(Clone)]
pub struct TransportUpLayerAddressInfoToRemoveItem {
    pub ip_sec_transport_layer_address: TransportLayerAddress,
    pub gtp_transport_layer_address_to_remove: Option<GtptlAs>,
}

impl APerElement for TransportUpLayerAddressInfoToRemoveItem {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(2),
            max: Some(2),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let ip_sec_transport_layer_address =
            TransportLayerAddress::from_aper(decoder, UNCONSTRAINED)?;
        let gtp_transport_layer_address_to_remove = if optionals.is_set(0) {
            Some(GtptlAs::from_aper(decoder, UNCONSTRAINED)?)
        } else {
            None
        };

        Ok(Self {
            ip_sec_transport_layer_address,
            gtp_transport_layer_address_to_remove,
        })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(2);
        optionals.set(0, self.gtp_transport_layer_address_to_remove.is_some());
        optionals.set(1, false);

        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&self.ip_sec_transport_layer_address.to_aper(UNCONSTRAINED)?)?;
        if let Some(x) = &self.gtp_transport_layer_address_to_remove {
            enc.append(&x.to_aper(UNCONSTRAINED)?)?;
        }

        Ok(enc)
    }
}

// TransmissionActionIndicator
#[derive(Clone, Copy, FromPrimitive)]
pub enum TransmissionActionIndicator {
    Stop,
    _Extended,
}

impl APerElement for TransmissionActionIndicator {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        if bool::from_aper(decoder, Self::CONSTRAINTS)? {
            return Ok(TransmissionActionIndicator::_Extended);
        }
        let v = u8::from_aper(decoder, Self::CONSTRAINTS)?;
        FromPrimitive::from_u8(v).ok_or(DecodeError::MalformedInt)
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&false.to_aper(UNCONSTRAINED)?)?;
        enc.append(&(*self as u8).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// Trpid
#[derive(Clone)]
pub struct Trpid(pub u16);

impl APerElement for Trpid {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(0),
            max: Some(65535),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        Ok(Self(u16::from_aper(decoder, Self::CONSTRAINTS)?))
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&(self.0).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// TrpInformation
#[derive(Clone)]
pub struct TrpInformation {
    pub trpid: Trpid,
    pub trp_information_type_response_list: TrpInformationTypeResponseList,
}

impl APerElement for TrpInformation {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(1),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let _optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let trpid = Trpid::from_aper(decoder, UNCONSTRAINED)?;
        let trp_information_type_response_list =
            TrpInformationTypeResponseList::from_aper(decoder, UNCONSTRAINED)?;

        Ok(Self {
            trpid,
            trp_information_type_response_list,
        })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(1);
        optionals.set(0, false);

        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&self.trpid.to_aper(UNCONSTRAINED)?)?;
        enc.append(
            &self
                .trp_information_type_response_list
                .to_aper(UNCONSTRAINED)?,
        )?;

        Ok(enc)
    }
}

// TrpInformationItem
#[derive(Clone)]
pub struct TrpInformationItem {
    pub trp_information: TrpInformation,
}

impl APerElement for TrpInformationItem {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(1),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let _optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let trp_information = TrpInformation::from_aper(decoder, UNCONSTRAINED)?;

        Ok(Self { trp_information })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(1);
        optionals.set(0, false);

        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&self.trp_information.to_aper(UNCONSTRAINED)?)?;

        Ok(enc)
    }
}

// TrpInformationTypeItem
#[derive(Clone, Copy, FromPrimitive)]
pub enum TrpInformationTypeItem {
    NrPci,
    NgRanCgi,
    Arfcn,
    PrsConfig,
    SsbConfig,
    SfnInitTime,
    SpatialDirectInfo,
    GeoCoord,
    _Extended,
}

impl APerElement for TrpInformationTypeItem {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        if bool::from_aper(decoder, Self::CONSTRAINTS)? {
            return Ok(TrpInformationTypeItem::_Extended);
        }
        let v = u8::from_aper(decoder, Self::CONSTRAINTS)?;
        FromPrimitive::from_u8(v).ok_or(DecodeError::MalformedInt)
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&false.to_aper(UNCONSTRAINED)?)?;
        enc.append(&(*self as u8).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// TrpInformationTypeResponseList
#[derive(Clone)]
pub struct TrpInformationTypeResponseList(pub Vec<TrpInformationTypeResponseItem>);

impl APerElement for TrpInformationTypeResponseList {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(1),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        Ok(Self(Vec::<TrpInformationTypeResponseItem>::from_aper(
            decoder,
            Self::CONSTRAINTS,
        )?))
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&(self.0).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// TrpInformationTypeResponseItem
#[derive(Clone)]
pub enum TrpInformationTypeResponseItem {
    PciNr(Nrpci),
    NgRanCgi(Nrcgi),
    Nrarfcn(u32),
    PrsConfiguration(PrsConfiguration),
    SsBinformation(SsbInformation),
    SfnInitialisationTime(RelativeTime1900),
    SpatialDirectionInformation(SpatialDirectionInformation),
    GeographicalCoordinates(GeographicalCoordinates),
    _Extended,
}

impl APerElement for TrpInformationTypeResponseItem {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        match u8::from_aper(decoder, UNCONSTRAINED)? {
            0 => Ok(Self::PciNr(Nrpci::from_aper(decoder, UNCONSTRAINED)?)),
            1 => Ok(Self::NgRanCgi(Nrcgi::from_aper(decoder, UNCONSTRAINED)?)),
            2 => Ok(Self::Nrarfcn(u32::from_aper(decoder, UNCONSTRAINED)?)),
            3 => Ok(Self::PrsConfiguration(PrsConfiguration::from_aper(
                decoder,
                UNCONSTRAINED,
            )?)),
            4 => Ok(Self::SsBinformation(SsbInformation::from_aper(
                decoder,
                UNCONSTRAINED,
            )?)),
            5 => Ok(Self::SfnInitialisationTime(RelativeTime1900::from_aper(
                decoder,
                UNCONSTRAINED,
            )?)),
            6 => Ok(Self::SpatialDirectionInformation(
                SpatialDirectionInformation::from_aper(decoder, UNCONSTRAINED)?,
            )),
            7 => Ok(Self::GeographicalCoordinates(
                GeographicalCoordinates::from_aper(decoder, UNCONSTRAINED)?,
            )),
            8 => Err(DecodeError::NotImplemented),
            _ => Err(DecodeError::InvalidChoice),
        }
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        match self {
            Self::PciNr(x) => {
                enc.append(&(0 as u8).to_aper(UNCONSTRAINED)?)?;
                enc.append(&x.to_aper(UNCONSTRAINED)?)?;
            }
            Self::NgRanCgi(x) => {
                enc.append(&(1 as u8).to_aper(UNCONSTRAINED)?)?;
                enc.append(&x.to_aper(UNCONSTRAINED)?)?;
            }
            Self::Nrarfcn(x) => {
                enc.append(&(2 as u8).to_aper(UNCONSTRAINED)?)?;
                enc.append(&x.to_aper(UNCONSTRAINED)?)?;
            }
            Self::PrsConfiguration(x) => {
                enc.append(&(3 as u8).to_aper(UNCONSTRAINED)?)?;
                enc.append(&x.to_aper(UNCONSTRAINED)?)?;
            }
            Self::SsBinformation(x) => {
                enc.append(&(4 as u8).to_aper(UNCONSTRAINED)?)?;
                enc.append(&x.to_aper(UNCONSTRAINED)?)?;
            }
            Self::SfnInitialisationTime(x) => {
                enc.append(&(5 as u8).to_aper(UNCONSTRAINED)?)?;
                enc.append(&x.to_aper(UNCONSTRAINED)?)?;
            }
            Self::SpatialDirectionInformation(x) => {
                enc.append(&(6 as u8).to_aper(UNCONSTRAINED)?)?;
                enc.append(&x.to_aper(UNCONSTRAINED)?)?;
            }
            Self::GeographicalCoordinates(x) => {
                enc.append(&(7 as u8).to_aper(UNCONSTRAINED)?)?;
                enc.append(&x.to_aper(UNCONSTRAINED)?)?;
            }
            Self::_Extended => return Err(EncodeError::NotImplemented),
        }
        Ok(enc)
    }
}

// TrpList
#[derive(Clone)]
pub struct TrpList(pub Vec<TrpListItem>);

impl APerElement for TrpList {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(1),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        Ok(Self(Vec::<TrpListItem>::from_aper(
            decoder,
            Self::CONSTRAINTS,
        )?))
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&(self.0).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// TrpListItem
#[derive(Clone)]
pub struct TrpListItem {
    pub trpid: Trpid,
}

impl APerElement for TrpListItem {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(1),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let _optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let trpid = Trpid::from_aper(decoder, UNCONSTRAINED)?;

        Ok(Self { trpid })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(1);
        optionals.set(0, false);

        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&self.trpid.to_aper(UNCONSTRAINED)?)?;

        Ok(enc)
    }
}

// TrpMeasurementQuality
#[derive(Clone)]
pub struct TrpMeasurementQuality {
    pub tr_pmeasurement_quality_item: TrpMeasurementQualityItem,
}

impl APerElement for TrpMeasurementQuality {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(1),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let _optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let tr_pmeasurement_quality_item =
            TrpMeasurementQualityItem::from_aper(decoder, UNCONSTRAINED)?;

        Ok(Self {
            tr_pmeasurement_quality_item,
        })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(1);
        optionals.set(0, false);

        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&self.tr_pmeasurement_quality_item.to_aper(UNCONSTRAINED)?)?;

        Ok(enc)
    }
}

// TrpMeasurementQualityItem
#[derive(Clone)]
pub enum TrpMeasurementQualityItem {
    TimingMeasurementQuality(TimingMeasurementQuality),
    AngleMeasurementQuality(AngleMeasurementQuality),
    _Extended,
}

impl APerElement for TrpMeasurementQualityItem {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        match u8::from_aper(decoder, UNCONSTRAINED)? {
            0 => Ok(Self::TimingMeasurementQuality(
                TimingMeasurementQuality::from_aper(decoder, UNCONSTRAINED)?,
            )),
            1 => Ok(Self::AngleMeasurementQuality(
                AngleMeasurementQuality::from_aper(decoder, UNCONSTRAINED)?,
            )),
            2 => Err(DecodeError::NotImplemented),
            _ => Err(DecodeError::InvalidChoice),
        }
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        match self {
            Self::TimingMeasurementQuality(x) => {
                enc.append(&(0 as u8).to_aper(UNCONSTRAINED)?)?;
                enc.append(&x.to_aper(UNCONSTRAINED)?)?;
            }
            Self::AngleMeasurementQuality(x) => {
                enc.append(&(1 as u8).to_aper(UNCONSTRAINED)?)?;
                enc.append(&x.to_aper(UNCONSTRAINED)?)?;
            }
            Self::_Extended => return Err(EncodeError::NotImplemented),
        }
        Ok(enc)
    }
}

// TrpMeasurementRequestList
#[derive(Clone)]
pub struct TrpMeasurementRequestList(pub Vec<TrpMeasurementRequestItem>);

impl APerElement for TrpMeasurementRequestList {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(1),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        Ok(Self(Vec::<TrpMeasurementRequestItem>::from_aper(
            decoder,
            Self::CONSTRAINTS,
        )?))
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&(self.0).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// TrpMeasurementRequestItem
#[derive(Clone)]
pub struct TrpMeasurementRequestItem {
    pub trpid: Trpid,
    pub search_window_information: Option<SearchWindowInformation>,
}

impl APerElement for TrpMeasurementRequestItem {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(2),
            max: Some(2),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let trpid = Trpid::from_aper(decoder, UNCONSTRAINED)?;
        let search_window_information = if optionals.is_set(0) {
            Some(SearchWindowInformation::from_aper(decoder, UNCONSTRAINED)?)
        } else {
            None
        };

        Ok(Self {
            trpid,
            search_window_information,
        })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(2);
        optionals.set(0, self.search_window_information.is_some());
        optionals.set(1, false);

        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&self.trpid.to_aper(UNCONSTRAINED)?)?;
        if let Some(x) = &self.search_window_information {
            enc.append(&x.to_aper(UNCONSTRAINED)?)?;
        }

        Ok(enc)
    }
}

// TrpPositionDefinitionType
#[derive(Clone)]
pub enum TrpPositionDefinitionType {
    Direct(TrpPositionDirect),
    Referenced(TrpPositionReferenced),
    _Extended,
}

impl APerElement for TrpPositionDefinitionType {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        match u8::from_aper(decoder, UNCONSTRAINED)? {
            0 => Ok(Self::Direct(TrpPositionDirect::from_aper(
                decoder,
                UNCONSTRAINED,
            )?)),
            1 => Ok(Self::Referenced(TrpPositionReferenced::from_aper(
                decoder,
                UNCONSTRAINED,
            )?)),
            2 => Err(DecodeError::NotImplemented),
            _ => Err(DecodeError::InvalidChoice),
        }
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        match self {
            Self::Direct(x) => {
                enc.append(&(0 as u8).to_aper(UNCONSTRAINED)?)?;
                enc.append(&x.to_aper(UNCONSTRAINED)?)?;
            }
            Self::Referenced(x) => {
                enc.append(&(1 as u8).to_aper(UNCONSTRAINED)?)?;
                enc.append(&x.to_aper(UNCONSTRAINED)?)?;
            }
            Self::_Extended => return Err(EncodeError::NotImplemented),
        }
        Ok(enc)
    }
}

// TrpPositionDirect
#[derive(Clone)]
pub struct TrpPositionDirect {
    pub accuracy: TrpPositionDirectAccuracy,
}

impl APerElement for TrpPositionDirect {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(1),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let _optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let accuracy = TrpPositionDirectAccuracy::from_aper(decoder, UNCONSTRAINED)?;

        Ok(Self { accuracy })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(1);
        optionals.set(0, false);

        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&self.accuracy.to_aper(UNCONSTRAINED)?)?;

        Ok(enc)
    }
}

// TrpPositionDirectAccuracy
#[derive(Clone)]
pub enum TrpPositionDirectAccuracy {
    TrpPosition(AccessPointPosition),
    TrphAposition(NgranHighAccuracyAccessPointPosition),
    _Extended,
}

impl APerElement for TrpPositionDirectAccuracy {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        match u8::from_aper(decoder, UNCONSTRAINED)? {
            0 => Ok(Self::TrpPosition(AccessPointPosition::from_aper(
                decoder,
                UNCONSTRAINED,
            )?)),
            1 => Ok(Self::TrphAposition(
                NgranHighAccuracyAccessPointPosition::from_aper(decoder, UNCONSTRAINED)?,
            )),
            2 => Err(DecodeError::NotImplemented),
            _ => Err(DecodeError::InvalidChoice),
        }
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        match self {
            Self::TrpPosition(x) => {
                enc.append(&(0 as u8).to_aper(UNCONSTRAINED)?)?;
                enc.append(&x.to_aper(UNCONSTRAINED)?)?;
            }
            Self::TrphAposition(x) => {
                enc.append(&(1 as u8).to_aper(UNCONSTRAINED)?)?;
                enc.append(&x.to_aper(UNCONSTRAINED)?)?;
            }
            Self::_Extended => return Err(EncodeError::NotImplemented),
        }
        Ok(enc)
    }
}

// TrpPositionReferenced
#[derive(Clone)]
pub struct TrpPositionReferenced {
    pub reference_point: ReferencePoint,
    pub reference_point_type: TrpReferencePointType,
}

impl APerElement for TrpPositionReferenced {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(1),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let _optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let reference_point = ReferencePoint::from_aper(decoder, UNCONSTRAINED)?;
        let reference_point_type = TrpReferencePointType::from_aper(decoder, UNCONSTRAINED)?;

        Ok(Self {
            reference_point,
            reference_point_type,
        })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(1);
        optionals.set(0, false);

        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&self.reference_point.to_aper(UNCONSTRAINED)?)?;
        enc.append(&self.reference_point_type.to_aper(UNCONSTRAINED)?)?;

        Ok(enc)
    }
}

// TrpReferencePointType
#[derive(Clone)]
pub enum TrpReferencePointType {
    TrpPositionRelativeGeodetic(RelativeGeodeticLocation),
    TrpPositionRelativeCartesian(RelativeCartesianLocation),
    _Extended,
}

impl APerElement for TrpReferencePointType {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        match u8::from_aper(decoder, UNCONSTRAINED)? {
            0 => Ok(Self::TrpPositionRelativeGeodetic(
                RelativeGeodeticLocation::from_aper(decoder, UNCONSTRAINED)?,
            )),
            1 => Ok(Self::TrpPositionRelativeCartesian(
                RelativeCartesianLocation::from_aper(decoder, UNCONSTRAINED)?,
            )),
            2 => Err(DecodeError::NotImplemented),
            _ => Err(DecodeError::InvalidChoice),
        }
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        match self {
            Self::TrpPositionRelativeGeodetic(x) => {
                enc.append(&(0 as u8).to_aper(UNCONSTRAINED)?)?;
                enc.append(&x.to_aper(UNCONSTRAINED)?)?;
            }
            Self::TrpPositionRelativeCartesian(x) => {
                enc.append(&(1 as u8).to_aper(UNCONSTRAINED)?)?;
                enc.append(&x.to_aper(UNCONSTRAINED)?)?;
            }
            Self::_Extended => return Err(EncodeError::NotImplemented),
        }
        Ok(enc)
    }
}

// TypeOfError
#[derive(Clone, Copy, FromPrimitive)]
pub enum TypeOfError {
    NotUnderstood,
    Missing,
    _Extended,
}

impl APerElement for TypeOfError {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        if bool::from_aper(decoder, Self::CONSTRAINTS)? {
            return Ok(TypeOfError::_Extended);
        }
        let v = u8::from_aper(decoder, Self::CONSTRAINTS)?;
        FromPrimitive::from_u8(v).ok_or(DecodeError::MalformedInt)
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&false.to_aper(UNCONSTRAINED)?)?;
        enc.append(&(*self as u8).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// TransportLayerAddressInfo
#[derive(Clone)]
pub struct TransportLayerAddressInfo {
    pub transport_up_layer_address_info_to_add_list: Option<TransportUpLayerAddressInfoToAddList>,
    pub transport_up_layer_address_info_to_remove_list:
        Option<TransportUpLayerAddressInfoToRemoveList>,
}

impl APerElement for TransportLayerAddressInfo {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(3),
            max: Some(3),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let transport_up_layer_address_info_to_add_list = if optionals.is_set(0) {
            Some(TransportUpLayerAddressInfoToAddList::from_aper(
                decoder,
                UNCONSTRAINED,
            )?)
        } else {
            None
        };
        let transport_up_layer_address_info_to_remove_list = if optionals.is_set(0) {
            Some(TransportUpLayerAddressInfoToRemoveList::from_aper(
                decoder,
                UNCONSTRAINED,
            )?)
        } else {
            None
        };

        Ok(Self {
            transport_up_layer_address_info_to_add_list,
            transport_up_layer_address_info_to_remove_list,
        })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(3);
        optionals.set(
            0,
            self.transport_up_layer_address_info_to_add_list.is_some(),
        );
        optionals.set(
            1,
            self.transport_up_layer_address_info_to_remove_list
                .is_some(),
        );
        optionals.set(2, false);

        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        if let Some(x) = &self.transport_up_layer_address_info_to_add_list {
            enc.append(&x.to_aper(UNCONSTRAINED)?)?;
        }
        if let Some(x) = &self.transport_up_layer_address_info_to_remove_list {
            enc.append(&x.to_aper(UNCONSTRAINED)?)?;
        }

        Ok(enc)
    }
}

// TscAssistanceInformation
#[derive(Clone)]
pub struct TscAssistanceInformation {
    pub periodicity: Periodicity,
    pub burst_arrival_time: Option<BurstArrivalTime>,
}

impl APerElement for TscAssistanceInformation {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(2),
            max: Some(2),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let _extended = bool::from_aper(decoder, UNCONSTRAINED)?;
        let optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let periodicity = Periodicity::from_aper(decoder, UNCONSTRAINED)?;
        let burst_arrival_time = if optionals.is_set(0) {
            Some(BurstArrivalTime::from_aper(decoder, UNCONSTRAINED)?)
        } else {
            None
        };

        Ok(Self {
            periodicity,
            burst_arrival_time,
        })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(2);
        optionals.set(0, self.burst_arrival_time.is_some());
        optionals.set(1, false);

        enc.append(&false.to_aper(UNCONSTRAINED)?)?;
        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&self.periodicity.to_aper(UNCONSTRAINED)?)?;
        if let Some(x) = &self.burst_arrival_time {
            enc.append(&x.to_aper(UNCONSTRAINED)?)?;
        }

        Ok(enc)
    }
}

// TscTrafficCharacteristics
#[derive(Clone)]
pub struct TscTrafficCharacteristics {
    pub tsc_assistance_information_dl: Option<TscAssistanceInformation>,
    pub tsc_assistance_information_ul: Option<TscAssistanceInformation>,
}

impl APerElement for TscTrafficCharacteristics {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(3),
            max: Some(3),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let _extended = bool::from_aper(decoder, UNCONSTRAINED)?;
        let optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let tsc_assistance_information_dl = if optionals.is_set(0) {
            Some(TscAssistanceInformation::from_aper(decoder, UNCONSTRAINED)?)
        } else {
            None
        };
        let tsc_assistance_information_ul = if optionals.is_set(0) {
            Some(TscAssistanceInformation::from_aper(decoder, UNCONSTRAINED)?)
        } else {
            None
        };

        Ok(Self {
            tsc_assistance_information_dl,
            tsc_assistance_information_ul,
        })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(3);
        optionals.set(0, self.tsc_assistance_information_dl.is_some());
        optionals.set(1, self.tsc_assistance_information_ul.is_some());
        optionals.set(2, false);

        enc.append(&false.to_aper(UNCONSTRAINED)?)?;
        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        if let Some(x) = &self.tsc_assistance_information_dl {
            enc.append(&x.to_aper(UNCONSTRAINED)?)?;
        }
        if let Some(x) = &self.tsc_assistance_information_ul {
            enc.append(&x.to_aper(UNCONSTRAINED)?)?;
        }

        Ok(enc)
    }
}

// UacAssistanceInfo
#[derive(Clone)]
pub struct UacAssistanceInfo {
    pub uac_plmn_list: UacPlmnList,
}

impl APerElement for UacAssistanceInfo {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(1),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let _optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let uac_plmn_list = UacPlmnList::from_aper(decoder, UNCONSTRAINED)?;

        Ok(Self { uac_plmn_list })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(1);
        optionals.set(0, false);

        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&self.uac_plmn_list.to_aper(UNCONSTRAINED)?)?;

        Ok(enc)
    }
}

// UacPlmnList
#[derive(Clone)]
pub struct UacPlmnList(pub Vec<UacPlmnItem>);

impl APerElement for UacPlmnList {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(1),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        Ok(Self(Vec::<UacPlmnItem>::from_aper(
            decoder,
            Self::CONSTRAINTS,
        )?))
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&(self.0).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// UacPlmnItem
#[derive(Clone)]
pub struct UacPlmnItem {
    pub plmn_identity: PlmnIdentity,
    pub uac_type_list: UacTypeList,
}

impl APerElement for UacPlmnItem {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(1),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let _optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let plmn_identity = PlmnIdentity::from_aper(decoder, UNCONSTRAINED)?;
        let uac_type_list = UacTypeList::from_aper(decoder, UNCONSTRAINED)?;

        Ok(Self {
            plmn_identity,
            uac_type_list,
        })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(1);
        optionals.set(0, false);

        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&self.plmn_identity.to_aper(UNCONSTRAINED)?)?;
        enc.append(&self.uac_type_list.to_aper(UNCONSTRAINED)?)?;

        Ok(enc)
    }
}

// UacTypeList
#[derive(Clone)]
pub struct UacTypeList(pub Vec<UacTypeItem>);

impl APerElement for UacTypeList {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(1),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        Ok(Self(Vec::<UacTypeItem>::from_aper(
            decoder,
            Self::CONSTRAINTS,
        )?))
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&(self.0).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// UacTypeItem
#[derive(Clone)]
pub struct UacTypeItem {
    pub uac_reduction_indication: UacReductionIndication,
    pub uac_category_type: UacCategoryType,
}

impl APerElement for UacTypeItem {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(1),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let _optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let uac_reduction_indication = UacReductionIndication::from_aper(decoder, UNCONSTRAINED)?;
        let uac_category_type = UacCategoryType::from_aper(decoder, UNCONSTRAINED)?;

        Ok(Self {
            uac_reduction_indication,
            uac_category_type,
        })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(1);
        optionals.set(0, false);

        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&self.uac_reduction_indication.to_aper(UNCONSTRAINED)?)?;
        enc.append(&self.uac_category_type.to_aper(UNCONSTRAINED)?)?;

        Ok(enc)
    }
}

// UacCategoryType
#[derive(Clone)]
pub enum UacCategoryType {
    UaCstandardized(UacAction),
    UacOperatorDefined(UacOperatorDefined),
    _Extended,
}

impl APerElement for UacCategoryType {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        match u8::from_aper(decoder, UNCONSTRAINED)? {
            0 => Ok(Self::UaCstandardized(UacAction::from_aper(
                decoder,
                UNCONSTRAINED,
            )?)),
            1 => Ok(Self::UacOperatorDefined(UacOperatorDefined::from_aper(
                decoder,
                UNCONSTRAINED,
            )?)),
            2 => Err(DecodeError::NotImplemented),
            _ => Err(DecodeError::InvalidChoice),
        }
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        match self {
            Self::UaCstandardized(x) => {
                enc.append(&(0 as u8).to_aper(UNCONSTRAINED)?)?;
                enc.append(&x.to_aper(UNCONSTRAINED)?)?;
            }
            Self::UacOperatorDefined(x) => {
                enc.append(&(1 as u8).to_aper(UNCONSTRAINED)?)?;
                enc.append(&x.to_aper(UNCONSTRAINED)?)?;
            }
            Self::_Extended => return Err(EncodeError::NotImplemented),
        }
        Ok(enc)
    }
}

// UacOperatorDefined
#[derive(Clone)]
pub struct UacOperatorDefined {
    pub access_category: u8,
    pub access_identity: BitString,
}

impl APerElement for UacOperatorDefined {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(1),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let _optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let access_category = u8::from_aper(decoder, UNCONSTRAINED)?;
        let access_identity = BitString::from_aper(
            decoder,
            Constraints {
                value: None,
                size: Some(Constraint::new(Some(7), Some(7))),
            },
        )?;

        Ok(Self {
            access_category,
            access_identity,
        })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(1);
        optionals.set(0, false);

        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&self.access_category.to_aper(UNCONSTRAINED)?)?;
        enc.append(&self.access_identity.to_aper(UNCONSTRAINED)?)?;

        Ok(enc)
    }
}

// UacAction
#[derive(Clone, Copy, FromPrimitive)]
pub enum UacAction {
    RejectNonEmergencyMoDt,
    RejectRrcCrSignalling,
    PermitEmergencySessionsAndMobileTerminatedServicesOnly,
    PermitHighPrioritySessionsAndMobileTerminatedServicesOnly,
    _Extended,
}

impl APerElement for UacAction {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        if bool::from_aper(decoder, Self::CONSTRAINTS)? {
            return Ok(UacAction::_Extended);
        }
        let v = u8::from_aper(decoder, Self::CONSTRAINTS)?;
        FromPrimitive::from_u8(v).ok_or(DecodeError::MalformedInt)
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&false.to_aper(UNCONSTRAINED)?)?;
        enc.append(&(*self as u8).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// UacReductionIndication
#[derive(Clone)]
pub struct UacReductionIndication(pub u8);

impl APerElement for UacReductionIndication {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(0),
            max: Some(0),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        Ok(Self(u8::from_aper(decoder, Self::CONSTRAINTS)?))
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&(self.0).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// UeAssociatedLogicalF1ConnectionItem
#[derive(Clone)]
pub struct UeAssociatedLogicalF1ConnectionItem {
    pub gnb_cu_ue_f1ap_id: Option<GnbCuUeF1apId>,
    pub gnb_du_ue_f1ap_id: Option<GnbDuUeF1apId>,
}

impl APerElement for UeAssociatedLogicalF1ConnectionItem {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(3),
            max: Some(3),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let _extended = bool::from_aper(decoder, UNCONSTRAINED)?;
        let optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let gnb_cu_ue_f1ap_id = if optionals.is_set(0) {
            Some(GnbCuUeF1apId::from_aper(decoder, UNCONSTRAINED)?)
        } else {
            None
        };
        let gnb_du_ue_f1ap_id = if optionals.is_set(0) {
            Some(GnbDuUeF1apId::from_aper(decoder, UNCONSTRAINED)?)
        } else {
            None
        };

        Ok(Self {
            gnb_cu_ue_f1ap_id,
            gnb_du_ue_f1ap_id,
        })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(3);
        optionals.set(0, self.gnb_cu_ue_f1ap_id.is_some());
        optionals.set(1, self.gnb_du_ue_f1ap_id.is_some());
        optionals.set(2, false);

        enc.append(&false.to_aper(UNCONSTRAINED)?)?;
        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        if let Some(x) = &self.gnb_cu_ue_f1ap_id {
            enc.append(&x.to_aper(UNCONSTRAINED)?)?;
        }
        if let Some(x) = &self.gnb_du_ue_f1ap_id {
            enc.append(&x.to_aper(UNCONSTRAINED)?)?;
        }

        Ok(enc)
    }
}

// UeAssistanceInformation
#[derive(Clone)]
pub struct UeAssistanceInformation(pub Vec<u8>);

impl APerElement for UeAssistanceInformation {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        Ok(Self(Vec::<u8>::from_aper(decoder, Self::CONSTRAINTS)?))
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&(self.0).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// UeAssistanceInformationEutra
#[derive(Clone)]
pub struct UeAssistanceInformationEutra(pub Vec<u8>);

impl APerElement for UeAssistanceInformationEutra {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        Ok(Self(Vec::<u8>::from_aper(decoder, Self::CONSTRAINTS)?))
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&(self.0).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// UeCapabilityRatContainerList
#[derive(Clone)]
pub struct UeCapabilityRatContainerList(pub Vec<u8>);

impl APerElement for UeCapabilityRatContainerList {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        Ok(Self(Vec::<u8>::from_aper(decoder, Self::CONSTRAINTS)?))
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&(self.0).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// UeContextNotRetrievable
#[derive(Clone, Copy, FromPrimitive)]
pub enum UeContextNotRetrievable {
    True,
    _Extended,
}

impl APerElement for UeContextNotRetrievable {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        if bool::from_aper(decoder, Self::CONSTRAINTS)? {
            return Ok(UeContextNotRetrievable::_Extended);
        }
        let v = u8::from_aper(decoder, Self::CONSTRAINTS)?;
        FromPrimitive::from_u8(v).ok_or(DecodeError::MalformedInt)
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&false.to_aper(UNCONSTRAINED)?)?;
        enc.append(&(*self as u8).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// UeIdentityIndexValue
#[derive(Clone)]
pub enum UeIdentityIndexValue {
    IndexLength10(BitString),
    _Extended,
}

impl APerElement for UeIdentityIndexValue {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        match u8::from_aper(decoder, UNCONSTRAINED)? {
            0 => Ok(Self::IndexLength10(BitString::from_aper(
                decoder,
                Constraints {
                    value: None,
                    size: Some(Constraint::new(Some(10), Some(10))),
                },
            )?)),
            1 => Err(DecodeError::NotImplemented),
            _ => Err(DecodeError::InvalidChoice),
        }
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        match self {
            Self::IndexLength10(x) => {
                enc.append(&(0 as u8).to_aper(UNCONSTRAINED)?)?;
                enc.append(&x.to_aper(Constraints {
                    value: None,
                    size: Some(Constraint::new(Some(10), Some(10))),
                })?)?;
            }
            Self::_Extended => return Err(EncodeError::NotImplemented),
        }
        Ok(enc)
    }
}

// UlAoA
#[derive(Clone)]
pub struct UlAoA {
    pub azimuth_ao_a: u16,
    pub zenith_ao_a: Option<u16>,
    pub lcs_to_gcs_translation_ao_a: Option<LcsToGcsTranslationAoA>,
}

impl APerElement for UlAoA {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(3),
            max: Some(3),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let azimuth_ao_a = u16::from_aper(decoder, UNCONSTRAINED)?;
        let zenith_ao_a = if optionals.is_set(0) {
            Some(u16::from_aper(decoder, UNCONSTRAINED)?)
        } else {
            None
        };
        let lcs_to_gcs_translation_ao_a = if optionals.is_set(0) {
            Some(LcsToGcsTranslationAoA::from_aper(decoder, UNCONSTRAINED)?)
        } else {
            None
        };

        Ok(Self {
            azimuth_ao_a,
            zenith_ao_a,
            lcs_to_gcs_translation_ao_a,
        })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(3);
        optionals.set(0, self.zenith_ao_a.is_some());
        optionals.set(1, self.lcs_to_gcs_translation_ao_a.is_some());
        optionals.set(2, false);

        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&self.azimuth_ao_a.to_aper(UNCONSTRAINED)?)?;
        if let Some(x) = &self.zenith_ao_a {
            enc.append(&x.to_aper(UNCONSTRAINED)?)?;
        }
        if let Some(x) = &self.lcs_to_gcs_translation_ao_a {
            enc.append(&x.to_aper(UNCONSTRAINED)?)?;
        }

        Ok(enc)
    }
}

// UlBhNonUpTrafficMapping
#[derive(Clone)]
pub struct UlBhNonUpTrafficMapping {
    pub ul_bh_non_up_traffic_mapping_list: UlBhNonUpTrafficMappingList,
}

impl APerElement for UlBhNonUpTrafficMapping {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(1),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let _optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let ul_bh_non_up_traffic_mapping_list =
            UlBhNonUpTrafficMappingList::from_aper(decoder, UNCONSTRAINED)?;

        Ok(Self {
            ul_bh_non_up_traffic_mapping_list,
        })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(1);
        optionals.set(0, false);

        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(
            &self
                .ul_bh_non_up_traffic_mapping_list
                .to_aper(UNCONSTRAINED)?,
        )?;

        Ok(enc)
    }
}

// UlBhNonUpTrafficMappingList
#[derive(Clone)]
pub struct UlBhNonUpTrafficMappingList(pub Vec<UlBhNonUpTrafficMappingItem>);

impl APerElement for UlBhNonUpTrafficMappingList {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(1),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        Ok(Self(Vec::<UlBhNonUpTrafficMappingItem>::from_aper(
            decoder,
            Self::CONSTRAINTS,
        )?))
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&(self.0).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// UlBhNonUpTrafficMappingItem
#[derive(Clone)]
pub struct UlBhNonUpTrafficMappingItem {
    pub non_up_traffic_type: NonUpTrafficType,
    pub bh_info: BhInfo,
}

impl APerElement for UlBhNonUpTrafficMappingItem {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(1),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let _optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let non_up_traffic_type = NonUpTrafficType::from_aper(decoder, UNCONSTRAINED)?;
        let bh_info = BhInfo::from_aper(decoder, UNCONSTRAINED)?;

        Ok(Self {
            non_up_traffic_type,
            bh_info,
        })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(1);
        optionals.set(0, false);

        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&self.non_up_traffic_type.to_aper(UNCONSTRAINED)?)?;
        enc.append(&self.bh_info.to_aper(UNCONSTRAINED)?)?;

        Ok(enc)
    }
}

// UlConfiguration
#[derive(Clone)]
pub struct UlConfiguration {
    pub ulue_configuration: UlueConfiguration,
}

impl APerElement for UlConfiguration {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(1),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let _extended = bool::from_aper(decoder, UNCONSTRAINED)?;
        let _optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let ulue_configuration = UlueConfiguration::from_aper(decoder, UNCONSTRAINED)?;

        Ok(Self { ulue_configuration })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(1);
        optionals.set(0, false);

        enc.append(&false.to_aper(UNCONSTRAINED)?)?;
        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&self.ulue_configuration.to_aper(UNCONSTRAINED)?)?;

        Ok(enc)
    }
}

// UlRtoaMeasurement
#[derive(Clone)]
pub struct UlRtoaMeasurement {
    pub ul_rtoa_measurement_item: UlRtoaMeasurementItem,
    pub additional_path_list: Option<AdditionalPathList>,
}

impl APerElement for UlRtoaMeasurement {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(2),
            max: Some(2),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let ul_rtoa_measurement_item = UlRtoaMeasurementItem::from_aper(decoder, UNCONSTRAINED)?;
        let additional_path_list = if optionals.is_set(0) {
            Some(AdditionalPathList::from_aper(decoder, UNCONSTRAINED)?)
        } else {
            None
        };

        Ok(Self {
            ul_rtoa_measurement_item,
            additional_path_list,
        })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(2);
        optionals.set(0, self.additional_path_list.is_some());
        optionals.set(1, false);

        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&self.ul_rtoa_measurement_item.to_aper(UNCONSTRAINED)?)?;
        if let Some(x) = &self.additional_path_list {
            enc.append(&x.to_aper(UNCONSTRAINED)?)?;
        }

        Ok(enc)
    }
}

// UlRtoaMeasurementItem
#[derive(Clone)]
pub enum UlRtoaMeasurementItem {
    K0(u32),
    K1(u32),
    K2(u32),
    K3(u32),
    K4(u32),
    K5(u16),
    _Extended,
}

impl APerElement for UlRtoaMeasurementItem {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        match u8::from_aper(decoder, UNCONSTRAINED)? {
            0 => Ok(Self::K0(u32::from_aper(decoder, UNCONSTRAINED)?)),
            1 => Ok(Self::K1(u32::from_aper(decoder, UNCONSTRAINED)?)),
            2 => Ok(Self::K2(u32::from_aper(decoder, UNCONSTRAINED)?)),
            3 => Ok(Self::K3(u32::from_aper(decoder, UNCONSTRAINED)?)),
            4 => Ok(Self::K4(u32::from_aper(decoder, UNCONSTRAINED)?)),
            5 => Ok(Self::K5(u16::from_aper(decoder, UNCONSTRAINED)?)),
            6 => Err(DecodeError::NotImplemented),
            _ => Err(DecodeError::InvalidChoice),
        }
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        match self {
            Self::K0(x) => {
                enc.append(&(0 as u8).to_aper(UNCONSTRAINED)?)?;
                enc.append(&x.to_aper(UNCONSTRAINED)?)?;
            }
            Self::K1(x) => {
                enc.append(&(1 as u8).to_aper(UNCONSTRAINED)?)?;
                enc.append(&x.to_aper(UNCONSTRAINED)?)?;
            }
            Self::K2(x) => {
                enc.append(&(2 as u8).to_aper(UNCONSTRAINED)?)?;
                enc.append(&x.to_aper(UNCONSTRAINED)?)?;
            }
            Self::K3(x) => {
                enc.append(&(3 as u8).to_aper(UNCONSTRAINED)?)?;
                enc.append(&x.to_aper(UNCONSTRAINED)?)?;
            }
            Self::K4(x) => {
                enc.append(&(4 as u8).to_aper(UNCONSTRAINED)?)?;
                enc.append(&x.to_aper(UNCONSTRAINED)?)?;
            }
            Self::K5(x) => {
                enc.append(&(5 as u8).to_aper(UNCONSTRAINED)?)?;
                enc.append(&x.to_aper(UNCONSTRAINED)?)?;
            }
            Self::_Extended => return Err(EncodeError::NotImplemented),
        }
        Ok(enc)
    }
}

// UlSrsRsrp
#[derive(Clone)]
pub struct UlSrsRsrp(pub u8);

impl APerElement for UlSrsRsrp {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(0),
            max: Some(0),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        Ok(Self(u8::from_aper(decoder, Self::CONSTRAINTS)?))
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&(self.0).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// UlueConfiguration
#[derive(Clone, Copy, FromPrimitive)]
pub enum UlueConfiguration {
    NoData,
    Shared,
    Only,
    _Extended,
}

impl APerElement for UlueConfiguration {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        if bool::from_aper(decoder, Self::CONSTRAINTS)? {
            return Ok(UlueConfiguration::_Extended);
        }
        let v = u8::from_aper(decoder, Self::CONSTRAINTS)?;
        FromPrimitive::from_u8(v).ok_or(DecodeError::MalformedInt)
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&false.to_aper(UNCONSTRAINED)?)?;
        enc.append(&(*self as u8).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// UlUpTnlInformationToUpdateListItem
#[derive(Clone)]
pub struct UlUpTnlInformationToUpdateListItem {
    pub uluptnl_information: UpTransportLayerInformation,
    pub new_uluptnl_information: Option<UpTransportLayerInformation>,
    pub bh_info: BhInfo,
}

impl APerElement for UlUpTnlInformationToUpdateListItem {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(2),
            max: Some(2),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let _extended = bool::from_aper(decoder, UNCONSTRAINED)?;
        let optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let uluptnl_information = UpTransportLayerInformation::from_aper(decoder, UNCONSTRAINED)?;
        let new_uluptnl_information = if optionals.is_set(0) {
            Some(UpTransportLayerInformation::from_aper(
                decoder,
                UNCONSTRAINED,
            )?)
        } else {
            None
        };
        let bh_info = BhInfo::from_aper(decoder, UNCONSTRAINED)?;

        Ok(Self {
            uluptnl_information,
            new_uluptnl_information,
            bh_info,
        })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(2);
        optionals.set(0, self.new_uluptnl_information.is_some());
        optionals.set(1, false);

        enc.append(&false.to_aper(UNCONSTRAINED)?)?;
        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&self.uluptnl_information.to_aper(UNCONSTRAINED)?)?;
        if let Some(x) = &self.new_uluptnl_information {
            enc.append(&x.to_aper(UNCONSTRAINED)?)?;
        }
        enc.append(&self.bh_info.to_aper(UNCONSTRAINED)?)?;

        Ok(enc)
    }
}

// UlUpTnlAddressToUpdateListItem
#[derive(Clone)]
pub struct UlUpTnlAddressToUpdateListItem {
    pub old_ip_adress: TransportLayerAddress,
    pub new_ip_adress: TransportLayerAddress,
}

impl APerElement for UlUpTnlAddressToUpdateListItem {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(1),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let _extended = bool::from_aper(decoder, UNCONSTRAINED)?;
        let _optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let old_ip_adress = TransportLayerAddress::from_aper(decoder, UNCONSTRAINED)?;
        let new_ip_adress = TransportLayerAddress::from_aper(decoder, UNCONSTRAINED)?;

        Ok(Self {
            old_ip_adress,
            new_ip_adress,
        })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(1);
        optionals.set(0, false);

        enc.append(&false.to_aper(UNCONSTRAINED)?)?;
        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&self.old_ip_adress.to_aper(UNCONSTRAINED)?)?;
        enc.append(&self.new_ip_adress.to_aper(UNCONSTRAINED)?)?;

        Ok(enc)
    }
}

// UluptnlInformationToBeSetupList
#[derive(Clone)]
pub struct UluptnlInformationToBeSetupList(pub Vec<UluptnlInformationToBeSetupItem>);

impl APerElement for UluptnlInformationToBeSetupList {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(1),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        Ok(Self(Vec::<UluptnlInformationToBeSetupItem>::from_aper(
            decoder,
            Self::CONSTRAINTS,
        )?))
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&(self.0).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// UluptnlInformationToBeSetupItem
#[derive(Clone)]
pub struct UluptnlInformationToBeSetupItem {
    pub uluptnl_information: UpTransportLayerInformation,
}

impl APerElement for UluptnlInformationToBeSetupItem {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(1),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let _extended = bool::from_aper(decoder, UNCONSTRAINED)?;
        let _optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let uluptnl_information = UpTransportLayerInformation::from_aper(decoder, UNCONSTRAINED)?;

        Ok(Self {
            uluptnl_information,
        })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(1);
        optionals.set(0, false);

        enc.append(&false.to_aper(UNCONSTRAINED)?)?;
        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&self.uluptnl_information.to_aper(UNCONSTRAINED)?)?;

        Ok(enc)
    }
}

// Uncertainty
#[derive(Clone)]
pub struct Uncertainty(pub u16);

impl APerElement for Uncertainty {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(0),
            max: Some(32767),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        Ok(Self(u16::from_aper(decoder, Self::CONSTRAINTS)?))
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&(self.0).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// UplinkChannelBwPerScsList
#[derive(Clone)]
pub struct UplinkChannelBwPerScsList(pub Vec<ScsSpecificCarrier>);

impl APerElement for UplinkChannelBwPerScsList {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(1),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        Ok(Self(Vec::<ScsSpecificCarrier>::from_aper(
            decoder,
            Self::CONSTRAINTS,
        )?))
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&(self.0).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// UplinkTxDirectCurrentListInformation
#[derive(Clone)]
pub struct UplinkTxDirectCurrentListInformation(pub Vec<u8>);

impl APerElement for UplinkTxDirectCurrentListInformation {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        Ok(Self(Vec::<u8>::from_aper(decoder, Self::CONSTRAINTS)?))
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&(self.0).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// UpTransportLayerInformation
#[derive(Clone)]
pub enum UpTransportLayerInformation {
    GtpTunnel(GtpTunnel),
    _Extended,
}

impl APerElement for UpTransportLayerInformation {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        match u8::from_aper(decoder, UNCONSTRAINED)? {
            0 => Ok(Self::GtpTunnel(GtpTunnel::from_aper(
                decoder,
                UNCONSTRAINED,
            )?)),
            1 => Err(DecodeError::NotImplemented),
            _ => Err(DecodeError::InvalidChoice),
        }
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        match self {
            Self::GtpTunnel(x) => {
                enc.append(&(0 as u8).to_aper(UNCONSTRAINED)?)?;
                enc.append(&x.to_aper(UNCONSTRAINED)?)?;
            }
            Self::_Extended => return Err(EncodeError::NotImplemented),
        }
        Ok(enc)
    }
}

// UriAddress
#[derive(Clone)]
pub struct UriAddress(pub VisibleString);

impl APerElement for UriAddress {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        Ok(Self(VisibleString::from_aper(decoder, Self::CONSTRAINTS)?))
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&(self.0).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// VictimGnbSetId
#[derive(Clone)]
pub struct VictimGnbSetId {
    pub victim_gnb_set_id: GnbSetId,
}

impl APerElement for VictimGnbSetId {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(1),
        }),
    };
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let _optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let victim_gnb_set_id = GnbSetId::from_aper(decoder, UNCONSTRAINED)?;

        Ok(Self { victim_gnb_set_id })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(1);
        optionals.set(0, false);

        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&self.victim_gnb_set_id.to_aper(UNCONSTRAINED)?)?;

        Ok(enc)
    }
}

// VehicleUe
#[derive(Clone, Copy, FromPrimitive)]
pub enum VehicleUe {
    Authorized,
    NotAuthorized,
    _Extended,
}

impl APerElement for VehicleUe {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        if bool::from_aper(decoder, Self::CONSTRAINTS)? {
            return Ok(VehicleUe::_Extended);
        }
        let v = u8::from_aper(decoder, Self::CONSTRAINTS)?;
        FromPrimitive::from_u8(v).ok_or(DecodeError::MalformedInt)
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&false.to_aper(UNCONSTRAINED)?)?;
        enc.append(&(*self as u8).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// PedestrianUe
#[derive(Clone, Copy, FromPrimitive)]
pub enum PedestrianUe {
    Authorized,
    NotAuthorized,
    _Extended,
}

impl APerElement for PedestrianUe {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        if bool::from_aper(decoder, Self::CONSTRAINTS)? {
            return Ok(PedestrianUe::_Extended);
        }
        let v = u8::from_aper(decoder, Self::CONSTRAINTS)?;
        FromPrimitive::from_u8(v).ok_or(DecodeError::MalformedInt)
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&false.to_aper(UNCONSTRAINED)?)?;
        enc.append(&(*self as u8).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// LatitudeSign
#[derive(Clone, Copy, FromPrimitive)]
pub enum LatitudeSign {
    North,
    South,
}

impl APerElement for LatitudeSign {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let v = u8::from_aper(decoder, Self::CONSTRAINTS)?;
        FromPrimitive::from_u8(v).ok_or(DecodeError::MalformedInt)
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&(*self as u8).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// DirectionOfAltitude
#[derive(Clone, Copy, FromPrimitive)]
pub enum DirectionOfAltitude {
    Height,
    Depth,
}

impl APerElement for DirectionOfAltitude {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let v = u8::from_aper(decoder, Self::CONSTRAINTS)?;
        FromPrimitive::from_u8(v).ok_or(DecodeError::MalformedInt)
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&(*self as u8).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// SubcarrierSpacing1
#[derive(Clone, Copy, FromPrimitive)]
pub enum SubcarrierSpacing1 {
    KHz15,
    KHz30,
    KHz60,
    KHz120,
    _Extended,
}

impl APerElement for SubcarrierSpacing1 {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        if bool::from_aper(decoder, Self::CONSTRAINTS)? {
            return Ok(SubcarrierSpacing1::_Extended);
        }
        let v = u8::from_aper(decoder, Self::CONSTRAINTS)?;
        FromPrimitive::from_u8(v).ok_or(DecodeError::MalformedInt)
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&false.to_aper(UNCONSTRAINED)?)?;
        enc.append(&(*self as u8).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// CyclicPrefix
#[derive(Clone, Copy, FromPrimitive)]
pub enum CyclicPrefix {
    Normal,
    Extended,
}

impl APerElement for CyclicPrefix {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let v = u8::from_aper(decoder, Self::CONSTRAINTS)?;
        FromPrimitive::from_u8(v).ok_or(DecodeError::MalformedInt)
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&(*self as u8).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// Shift7dot5kHz
#[derive(Clone, Copy, FromPrimitive)]
pub enum Shift7dot5kHz {
    True,
    _Extended,
}

impl APerElement for Shift7dot5kHz {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        if bool::from_aper(decoder, Self::CONSTRAINTS)? {
            return Ok(Shift7dot5kHz::_Extended);
        }
        let v = u8::from_aper(decoder, Self::CONSTRAINTS)?;
        FromPrimitive::from_u8(v).ok_or(DecodeError::MalformedInt)
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&false.to_aper(UNCONSTRAINED)?)?;
        enc.append(&(*self as u8).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// Resolution
#[derive(Clone, Copy, FromPrimitive)]
pub enum Resolution {
    Deg0dot1,
    _Extended,
}

impl APerElement for Resolution {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        if bool::from_aper(decoder, Self::CONSTRAINTS)? {
            return Ok(Resolution::_Extended);
        }
        let v = u8::from_aper(decoder, Self::CONSTRAINTS)?;
        FromPrimitive::from_u8(v).ok_or(DecodeError::MalformedInt)
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&false.to_aper(UNCONSTRAINED)?)?;
        enc.append(&(*self as u8).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// DelayCritical
#[derive(Clone, Copy, FromPrimitive)]
pub enum DelayCritical {
    DelayCritical,
    NonDelayCritical,
}

impl APerElement for DelayCritical {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let v = u8::from_aper(decoder, Self::CONSTRAINTS)?;
        FromPrimitive::from_u8(v).ok_or(DecodeError::MalformedInt)
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&(*self as u8).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// ResourceType1
#[derive(Clone, Copy, FromPrimitive)]
pub enum ResourceType1 {
    Gbr,
    NonGbr,
    DelayCriticalGrb,
    _Extended,
}

impl APerElement for ResourceType1 {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        if bool::from_aper(decoder, Self::CONSTRAINTS)? {
            return Ok(ResourceType1::_Extended);
        }
        let v = u8::from_aper(decoder, Self::CONSTRAINTS)?;
        FromPrimitive::from_u8(v).ok_or(DecodeError::MalformedInt)
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&false.to_aper(UNCONSTRAINED)?)?;
        enc.append(&(*self as u8).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// Nrscs1
#[derive(Clone, Copy, FromPrimitive)]
pub enum Nrscs1 {
    Scs15,
    Scs30,
    Scs60,
    Scs120,
    _Extended,
}

impl APerElement for Nrscs1 {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        if bool::from_aper(decoder, Self::CONSTRAINTS)? {
            return Ok(Nrscs1::_Extended);
        }
        let v = u8::from_aper(decoder, Self::CONSTRAINTS)?;
        FromPrimitive::from_u8(v).ok_or(DecodeError::MalformedInt)
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&false.to_aper(UNCONSTRAINED)?)?;
        enc.append(&(*self as u8).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// Nrcp
#[derive(Clone, Copy, FromPrimitive)]
pub enum Nrcp {
    Normal,
    Extended,
    _Extended,
}

impl APerElement for Nrcp {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        if bool::from_aper(decoder, Self::CONSTRAINTS)? {
            return Ok(Nrcp::_Extended);
        }
        let v = u8::from_aper(decoder, Self::CONSTRAINTS)?;
        FromPrimitive::from_u8(v).ok_or(DecodeError::MalformedInt)
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&false.to_aper(UNCONSTRAINED)?)?;
        enc.append(&(*self as u8).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// NrdlulTxPeriodicity
#[derive(Clone, Copy, FromPrimitive)]
pub enum NrdlulTxPeriodicity {
    Ms0p5,
    Ms0p625,
    Ms1,
    Ms1p25,
    Ms2,
    Ms2p5,
    Ms3,
    Ms4,
    Ms5,
    Ms10,
    Ms20,
    Ms40,
    Ms60,
    Ms80,
    Ms100,
    Ms120,
    Ms140,
    Ms160,
    _Extended,
}

impl APerElement for NrdlulTxPeriodicity {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        if bool::from_aper(decoder, Self::CONSTRAINTS)? {
            return Ok(NrdlulTxPeriodicity::_Extended);
        }
        let v = u8::from_aper(decoder, Self::CONSTRAINTS)?;
        FromPrimitive::from_u8(v).ok_or(DecodeError::MalformedInt)
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&false.to_aper(UNCONSTRAINED)?)?;
        enc.append(&(*self as u8).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// Msg1scs
#[derive(Clone, Copy, FromPrimitive)]
pub enum Msg1scs {
    Scs15,
    Scs30,
    Scs60,
    Scs120,
    _Extended,
}

impl APerElement for Msg1scs {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        if bool::from_aper(decoder, Self::CONSTRAINTS)? {
            return Ok(Msg1scs::_Extended);
        }
        let v = u8::from_aper(decoder, Self::CONSTRAINTS)?;
        FromPrimitive::from_u8(v).ok_or(DecodeError::MalformedInt)
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&false.to_aper(UNCONSTRAINED)?)?;
        enc.append(&(*self as u8).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// RestrictedSetConfig
#[derive(Clone, Copy, FromPrimitive)]
pub enum RestrictedSetConfig {
    UnrestrictedSet,
    RestrictedSetTypeA,
    RestrictedSetTypeB,
    _Extended,
}

impl APerElement for RestrictedSetConfig {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        if bool::from_aper(decoder, Self::CONSTRAINTS)? {
            return Ok(RestrictedSetConfig::_Extended);
        }
        let v = u8::from_aper(decoder, Self::CONSTRAINTS)?;
        FromPrimitive::from_u8(v).ok_or(DecodeError::MalformedInt)
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&false.to_aper(UNCONSTRAINED)?)?;
        enc.append(&(*self as u8).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// Msg1fdm
#[derive(Clone, Copy, FromPrimitive)]
pub enum Msg1fdm {
    One,
    Two,
    Four,
    Eight,
    _Extended,
}

impl APerElement for Msg1fdm {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        if bool::from_aper(decoder, Self::CONSTRAINTS)? {
            return Ok(Msg1fdm::_Extended);
        }
        let v = u8::from_aper(decoder, Self::CONSTRAINTS)?;
        FromPrimitive::from_u8(v).ok_or(DecodeError::MalformedInt)
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&false.to_aper(UNCONSTRAINED)?)?;
        enc.append(&(*self as u8).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// SsbPerRachOccasion
#[derive(Clone, Copy, FromPrimitive)]
pub enum SsbPerRachOccasion {
    OneEighth,
    OneFourth,
    OneHalf,
    One,
    Two,
    Four,
    Eight,
    Sixteen,
    _Extended,
}

impl APerElement for SsbPerRachOccasion {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        if bool::from_aper(decoder, Self::CONSTRAINTS)? {
            return Ok(SsbPerRachOccasion::_Extended);
        }
        let v = u8::from_aper(decoder, Self::CONSTRAINTS)?;
        FromPrimitive::from_u8(v).ok_or(DecodeError::MalformedInt)
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&false.to_aper(UNCONSTRAINED)?)?;
        enc.append(&(*self as u8).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// PosperiodicSet
#[derive(Clone, Copy, FromPrimitive)]
pub enum PosperiodicSet {
    True,
    _Extended,
}

impl APerElement for PosperiodicSet {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        if bool::from_aper(decoder, Self::CONSTRAINTS)? {
            return Ok(PosperiodicSet::_Extended);
        }
        let v = u8::from_aper(decoder, Self::CONSTRAINTS)?;
        FromPrimitive::from_u8(v).ok_or(DecodeError::MalformedInt)
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&false.to_aper(UNCONSTRAINED)?)?;
        enc.append(&(*self as u8).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// PossemiPersistentSet
#[derive(Clone, Copy, FromPrimitive)]
pub enum PossemiPersistentSet {
    True,
    _Extended,
}

impl APerElement for PossemiPersistentSet {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        if bool::from_aper(decoder, Self::CONSTRAINTS)? {
            return Ok(PossemiPersistentSet::_Extended);
        }
        let v = u8::from_aper(decoder, Self::CONSTRAINTS)?;
        FromPrimitive::from_u8(v).ok_or(DecodeError::MalformedInt)
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&false.to_aper(UNCONSTRAINED)?)?;
        enc.append(&(*self as u8).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// NrofSymbols
#[derive(Clone, Copy, FromPrimitive)]
pub enum NrofSymbols {
    N1,
    N2,
    N4,
    N8,
    N12,
}

impl APerElement for NrofSymbols {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let v = u8::from_aper(decoder, Self::CONSTRAINTS)?;
        FromPrimitive::from_u8(v).ok_or(DecodeError::MalformedInt)
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&(*self as u8).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// GroupOrSequenceHopping
#[derive(Clone, Copy, FromPrimitive)]
pub enum GroupOrSequenceHopping {
    Neither,
    GroupHopping,
    SequenceHopping,
}

impl APerElement for GroupOrSequenceHopping {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let v = u8::from_aper(decoder, Self::CONSTRAINTS)?;
        FromPrimitive::from_u8(v).ok_or(DecodeError::MalformedInt)
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&(*self as u8).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// MutingBitRepetitionFactor
#[derive(Clone, Copy, FromPrimitive)]
pub enum MutingBitRepetitionFactor {
    Rf1,
    Rf2,
    Rf4,
    Rf8,
    _Extended,
}

impl APerElement for MutingBitRepetitionFactor {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        if bool::from_aper(decoder, Self::CONSTRAINTS)? {
            return Ok(MutingBitRepetitionFactor::_Extended);
        }
        let v = u8::from_aper(decoder, Self::CONSTRAINTS)?;
        FromPrimitive::from_u8(v).ok_or(DecodeError::MalformedInt)
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&false.to_aper(UNCONSTRAINED)?)?;
        enc.append(&(*self as u8).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// SubcarrierSpacing2
#[derive(Clone, Copy, FromPrimitive)]
pub enum SubcarrierSpacing2 {
    KHz15,
    KHz30,
    KHz60,
    KHz120,
    _Extended,
}

impl APerElement for SubcarrierSpacing2 {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        if bool::from_aper(decoder, Self::CONSTRAINTS)? {
            return Ok(SubcarrierSpacing2::_Extended);
        }
        let v = u8::from_aper(decoder, Self::CONSTRAINTS)?;
        FromPrimitive::from_u8(v).ok_or(DecodeError::MalformedInt)
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&false.to_aper(UNCONSTRAINED)?)?;
        enc.append(&(*self as u8).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// CombSize
#[derive(Clone, Copy, FromPrimitive)]
pub enum CombSize {
    N2,
    N4,
    N6,
    N12,
    _Extended,
}

impl APerElement for CombSize {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        if bool::from_aper(decoder, Self::CONSTRAINTS)? {
            return Ok(CombSize::_Extended);
        }
        let v = u8::from_aper(decoder, Self::CONSTRAINTS)?;
        FromPrimitive::from_u8(v).ok_or(DecodeError::MalformedInt)
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&false.to_aper(UNCONSTRAINED)?)?;
        enc.append(&(*self as u8).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// CpType
#[derive(Clone, Copy, FromPrimitive)]
pub enum CpType {
    Normal,
    Extended,
    _Extended,
}

impl APerElement for CpType {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        if bool::from_aper(decoder, Self::CONSTRAINTS)? {
            return Ok(CpType::_Extended);
        }
        let v = u8::from_aper(decoder, Self::CONSTRAINTS)?;
        FromPrimitive::from_u8(v).ok_or(DecodeError::MalformedInt)
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&false.to_aper(UNCONSTRAINED)?)?;
        enc.append(&(*self as u8).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// ResourceSetPeriodicity
#[derive(Clone, Copy, FromPrimitive)]
pub enum ResourceSetPeriodicity {
    N4,
    N5,
    N8,
    N10,
    N16,
    N20,
    N32,
    N40,
    N64,
    N80,
    N160,
    N320,
    N640,
    N1280,
    N2560,
    N5120,
    N10240,
    N20480,
    N40960,
    N81920,
    _Extended,
}

impl APerElement for ResourceSetPeriodicity {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        if bool::from_aper(decoder, Self::CONSTRAINTS)? {
            return Ok(ResourceSetPeriodicity::_Extended);
        }
        let v = u8::from_aper(decoder, Self::CONSTRAINTS)?;
        FromPrimitive::from_u8(v).ok_or(DecodeError::MalformedInt)
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&false.to_aper(UNCONSTRAINED)?)?;
        enc.append(&(*self as u8).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// ResourceRepetitionFactor
#[derive(Clone, Copy, FromPrimitive)]
pub enum ResourceRepetitionFactor {
    Rf1,
    Rf2,
    Rf4,
    Rf6,
    Rf8,
    Rf16,
    Rf32,
    _Extended,
}

impl APerElement for ResourceRepetitionFactor {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        if bool::from_aper(decoder, Self::CONSTRAINTS)? {
            return Ok(ResourceRepetitionFactor::_Extended);
        }
        let v = u8::from_aper(decoder, Self::CONSTRAINTS)?;
        FromPrimitive::from_u8(v).ok_or(DecodeError::MalformedInt)
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&false.to_aper(UNCONSTRAINED)?)?;
        enc.append(&(*self as u8).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// ResourceTimeGap
#[derive(Clone, Copy, FromPrimitive)]
pub enum ResourceTimeGap {
    Tg1,
    Tg2,
    Tg4,
    Tg8,
    Tg16,
    Tg32,
    _Extended,
}

impl APerElement for ResourceTimeGap {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        if bool::from_aper(decoder, Self::CONSTRAINTS)? {
            return Ok(ResourceTimeGap::_Extended);
        }
        let v = u8::from_aper(decoder, Self::CONSTRAINTS)?;
        FromPrimitive::from_u8(v).ok_or(DecodeError::MalformedInt)
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&false.to_aper(UNCONSTRAINED)?)?;
        enc.append(&(*self as u8).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// ResourceNumberofSymbols
#[derive(Clone, Copy, FromPrimitive)]
pub enum ResourceNumberofSymbols {
    N2,
    N4,
    N6,
    N12,
    _Extended,
}

impl APerElement for ResourceNumberofSymbols {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        if bool::from_aper(decoder, Self::CONSTRAINTS)? {
            return Ok(ResourceNumberofSymbols::_Extended);
        }
        let v = u8::from_aper(decoder, Self::CONSTRAINTS)?;
        FromPrimitive::from_u8(v).ok_or(DecodeError::MalformedInt)
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&false.to_aper(UNCONSTRAINED)?)?;
        enc.append(&(*self as u8).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// ReflectiveQosAttribute
#[derive(Clone, Copy, FromPrimitive)]
pub enum ReflectiveQosAttribute {
    SubjectTo,
    _Extended,
}

impl APerElement for ReflectiveQosAttribute {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        if bool::from_aper(decoder, Self::CONSTRAINTS)? {
            return Ok(ReflectiveQosAttribute::_Extended);
        }
        let v = u8::from_aper(decoder, Self::CONSTRAINTS)?;
        FromPrimitive::from_u8(v).ok_or(DecodeError::MalformedInt)
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&false.to_aper(UNCONSTRAINED)?)?;
        enc.append(&(*self as u8).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// XyZunit
#[derive(Clone, Copy, FromPrimitive)]
pub enum XyZunit {
    Mm,
    Cm,
    Dm,
    _Extended,
}

impl APerElement for XyZunit {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        if bool::from_aper(decoder, Self::CONSTRAINTS)? {
            return Ok(XyZunit::_Extended);
        }
        let v = u8::from_aper(decoder, Self::CONSTRAINTS)?;
        FromPrimitive::from_u8(v).ok_or(DecodeError::MalformedInt)
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&false.to_aper(UNCONSTRAINED)?)?;
        enc.append(&(*self as u8).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// MilliArcSecondUnits
#[derive(Clone, Copy, FromPrimitive)]
pub enum MilliArcSecondUnits {
    Zerodot03,
    Zerodot3,
    Three,
    _Extended,
}

impl APerElement for MilliArcSecondUnits {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        if bool::from_aper(decoder, Self::CONSTRAINTS)? {
            return Ok(MilliArcSecondUnits::_Extended);
        }
        let v = u8::from_aper(decoder, Self::CONSTRAINTS)?;
        FromPrimitive::from_u8(v).ok_or(DecodeError::MalformedInt)
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&false.to_aper(UNCONSTRAINED)?)?;
        enc.append(&(*self as u8).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// HeightUnits
#[derive(Clone, Copy, FromPrimitive)]
pub enum HeightUnits {
    Mm,
    Cm,
    M,
    _Extended,
}

impl APerElement for HeightUnits {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        if bool::from_aper(decoder, Self::CONSTRAINTS)? {
            return Ok(HeightUnits::_Extended);
        }
        let v = u8::from_aper(decoder, Self::CONSTRAINTS)?;
        FromPrimitive::from_u8(v).ok_or(DecodeError::MalformedInt)
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&false.to_aper(UNCONSTRAINED)?)?;
        enc.append(&(*self as u8).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// ResourceType2
#[derive(Clone, Copy, FromPrimitive)]
pub enum ResourceType2 {
    Periodic,
    SemiPersistent,
    Aperiodic,
    _Extended,
}

impl APerElement for ResourceType2 {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        if bool::from_aper(decoder, Self::CONSTRAINTS)? {
            return Ok(ResourceType2::_Extended);
        }
        let v = u8::from_aper(decoder, Self::CONSTRAINTS)?;
        FromPrimitive::from_u8(v).ok_or(DecodeError::MalformedInt)
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&false.to_aper(UNCONSTRAINED)?)?;
        enc.append(&(*self as u8).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// PeriodicSet
#[derive(Clone, Copy, FromPrimitive)]
pub enum PeriodicSet {
    True,
    _Extended,
}

impl APerElement for PeriodicSet {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        if bool::from_aper(decoder, Self::CONSTRAINTS)? {
            return Ok(PeriodicSet::_Extended);
        }
        let v = u8::from_aper(decoder, Self::CONSTRAINTS)?;
        FromPrimitive::from_u8(v).ok_or(DecodeError::MalformedInt)
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&false.to_aper(UNCONSTRAINED)?)?;
        enc.append(&(*self as u8).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// SemiPersistentSet
#[derive(Clone, Copy, FromPrimitive)]
pub enum SemiPersistentSet {
    True,
    _Extended,
}

impl APerElement for SemiPersistentSet {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        if bool::from_aper(decoder, Self::CONSTRAINTS)? {
            return Ok(SemiPersistentSet::_Extended);
        }
        let v = u8::from_aper(decoder, Self::CONSTRAINTS)?;
        FromPrimitive::from_u8(v).ok_or(DecodeError::MalformedInt)
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&false.to_aper(UNCONSTRAINED)?)?;
        enc.append(&(*self as u8).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// Periodicity1
#[derive(Clone, Copy, FromPrimitive)]
pub enum Periodicity1 {
    Slot1,
    Slot2,
    Slot4,
    Slot5,
    Slot8,
    Slot10,
    Slot16,
    Slot20,
    Slot32,
    Slot40,
    Slot64,
    Slot80,
    Slot160,
    Slot320,
    Slot640,
    Slot1280,
    Slot2560,
    _Extended,
}

impl APerElement for Periodicity1 {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        if bool::from_aper(decoder, Self::CONSTRAINTS)? {
            return Ok(Periodicity1::_Extended);
        }
        let v = u8::from_aper(decoder, Self::CONSTRAINTS)?;
        FromPrimitive::from_u8(v).ok_or(DecodeError::MalformedInt)
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&false.to_aper(UNCONSTRAINED)?)?;
        enc.append(&(*self as u8).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// Periodicity2
#[derive(Clone, Copy, FromPrimitive)]
pub enum Periodicity2 {
    Slot1,
    Slot2,
    Slot4,
    Slot5,
    Slot8,
    Slot10,
    Slot16,
    Slot20,
    Slot32,
    Slot40,
    Slot64,
    Slot80,
    Slot160,
    Slot320,
    Slot640,
    Slot1280,
    Slot2560,
    _Extended,
}

impl APerElement for Periodicity2 {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        if bool::from_aper(decoder, Self::CONSTRAINTS)? {
            return Ok(Periodicity2::_Extended);
        }
        let v = u8::from_aper(decoder, Self::CONSTRAINTS)?;
        FromPrimitive::from_u8(v).ok_or(DecodeError::MalformedInt)
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&false.to_aper(UNCONSTRAINED)?)?;
        enc.append(&(*self as u8).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// AperiodicResourceType
#[derive(Clone, Copy, FromPrimitive)]
pub enum AperiodicResourceType {
    True,
    _Extended,
}

impl APerElement for AperiodicResourceType {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        if bool::from_aper(decoder, Self::CONSTRAINTS)? {
            return Ok(AperiodicResourceType::_Extended);
        }
        let v = u8::from_aper(decoder, Self::CONSTRAINTS)?;
        FromPrimitive::from_u8(v).ok_or(DecodeError::MalformedInt)
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&false.to_aper(UNCONSTRAINED)?)?;
        enc.append(&(*self as u8).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// Periodicity3
#[derive(Clone, Copy, FromPrimitive)]
pub enum Periodicity3 {
    Slot1,
    Slot2,
    Slot4,
    Slot5,
    Slot8,
    Slot10,
    Slot16,
    Slot20,
    Slot32,
    Slot40,
    Slot64,
    Slot80,
    Slot160,
    Slot320,
    Slot640,
    Slot1280,
    Slot2560,
    Slot5120,
    Slot10240,
    Slot40960,
    Slot81920,
    _Extended,
}

impl APerElement for Periodicity3 {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        if bool::from_aper(decoder, Self::CONSTRAINTS)? {
            return Ok(Periodicity3::_Extended);
        }
        let v = u8::from_aper(decoder, Self::CONSTRAINTS)?;
        FromPrimitive::from_u8(v).ok_or(DecodeError::MalformedInt)
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&false.to_aper(UNCONSTRAINED)?)?;
        enc.append(&(*self as u8).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// Periodicity4
#[derive(Clone, Copy, FromPrimitive)]
pub enum Periodicity4 {
    Slot1,
    Slot2,
    Slot4,
    Slot5,
    Slot8,
    Slot10,
    Slot16,
    Slot20,
    Slot32,
    Slot40,
    Slot64,
    Slot80,
    Slot160,
    Slot320,
    Slot640,
    Slot1280,
    Slot2560,
    Slot5120,
    Slot10240,
    Slot40960,
    Slot81920,
    _Extended,
}

impl APerElement for Periodicity4 {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        if bool::from_aper(decoder, Self::CONSTRAINTS)? {
            return Ok(Periodicity4::_Extended);
        }
        let v = u8::from_aper(decoder, Self::CONSTRAINTS)?;
        FromPrimitive::from_u8(v).ok_or(DecodeError::MalformedInt)
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&false.to_aper(UNCONSTRAINED)?)?;
        enc.append(&(*self as u8).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// SubcarrierSpacing3
#[derive(Clone, Copy, FromPrimitive)]
pub enum SubcarrierSpacing3 {
    KHz15,
    KHz30,
    KHz60,
    KHz120,
    _Extended,
}

impl APerElement for SubcarrierSpacing3 {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        if bool::from_aper(decoder, Self::CONSTRAINTS)? {
            return Ok(SubcarrierSpacing3::_Extended);
        }
        let v = u8::from_aper(decoder, Self::CONSTRAINTS)?;
        FromPrimitive::from_u8(v).ok_or(DecodeError::MalformedInt)
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&false.to_aper(UNCONSTRAINED)?)?;
        enc.append(&(*self as u8).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// SwitchingOffOngoing
#[derive(Clone, Copy, FromPrimitive)]
pub enum SwitchingOffOngoing {
    True,
    _Extended,
}

impl APerElement for SwitchingOffOngoing {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        if bool::from_aper(decoder, Self::CONSTRAINTS)? {
            return Ok(SwitchingOffOngoing::_Extended);
        }
        let v = u8::from_aper(decoder, Self::CONSTRAINTS)?;
        FromPrimitive::from_u8(v).ok_or(DecodeError::MalformedInt)
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&false.to_aper(UNCONSTRAINED)?)?;
        enc.append(&(*self as u8).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// NrofSrsPorts
#[derive(Clone, Copy, FromPrimitive)]
pub enum NrofSrsPorts {
    Port1,
    Ports2,
    Ports4,
}

impl APerElement for NrofSrsPorts {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let v = u8::from_aper(decoder, Self::CONSTRAINTS)?;
        FromPrimitive::from_u8(v).ok_or(DecodeError::MalformedInt)
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&(*self as u8).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// NrofSymbols1
#[derive(Clone, Copy, FromPrimitive)]
pub enum NrofSymbols1 {
    N1,
    N2,
    N4,
}

impl APerElement for NrofSymbols1 {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let v = u8::from_aper(decoder, Self::CONSTRAINTS)?;
        FromPrimitive::from_u8(v).ok_or(DecodeError::MalformedInt)
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&(*self as u8).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// RepetitionFactor
#[derive(Clone, Copy, FromPrimitive)]
pub enum RepetitionFactor {
    N1,
    N2,
    N4,
}

impl APerElement for RepetitionFactor {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let v = u8::from_aper(decoder, Self::CONSTRAINTS)?;
        FromPrimitive::from_u8(v).ok_or(DecodeError::MalformedInt)
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&(*self as u8).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// GroupOrSequenceHopping1
#[derive(Clone, Copy, FromPrimitive)]
pub enum GroupOrSequenceHopping1 {
    Neither,
    GroupHopping,
    SequenceHopping,
}

impl APerElement for GroupOrSequenceHopping1 {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let v = u8::from_aper(decoder, Self::CONSTRAINTS)?;
        FromPrimitive::from_u8(v).ok_or(DecodeError::MalformedInt)
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&(*self as u8).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// SsbSubcarrierSpacing1
#[derive(Clone, Copy, FromPrimitive)]
pub enum SsbSubcarrierSpacing1 {
    KHz15,
    KHz30,
    KHz60,
    KHz120,
    KHz240,
    _Extended,
}

impl APerElement for SsbSubcarrierSpacing1 {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        if bool::from_aper(decoder, Self::CONSTRAINTS)? {
            return Ok(SsbSubcarrierSpacing1::_Extended);
        }
        let v = u8::from_aper(decoder, Self::CONSTRAINTS)?;
        FromPrimitive::from_u8(v).ok_or(DecodeError::MalformedInt)
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&false.to_aper(UNCONSTRAINED)?)?;
        enc.append(&(*self as u8).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// SsbPeriodicity
#[derive(Clone, Copy, FromPrimitive)]
pub enum SsbPeriodicity {
    Ms5,
    Ms10,
    Ms20,
    Ms40,
    Ms80,
    Ms160,
    _Extended,
}

impl APerElement for SsbPeriodicity {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        if bool::from_aper(decoder, Self::CONSTRAINTS)? {
            return Ok(SsbPeriodicity::_Extended);
        }
        let v = u8::from_aper(decoder, Self::CONSTRAINTS)?;
        FromPrimitive::from_u8(v).ok_or(DecodeError::MalformedInt)
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&false.to_aper(UNCONSTRAINED)?)?;
        enc.append(&(*self as u8).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// Resolution1
#[derive(Clone, Copy, FromPrimitive)]
pub enum Resolution1 {
    M0dot1,
    M1,
    M10,
    M30,
    _Extended,
}

impl APerElement for Resolution1 {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        if bool::from_aper(decoder, Self::CONSTRAINTS)? {
            return Ok(Resolution1::_Extended);
        }
        let v = u8::from_aper(decoder, Self::CONSTRAINTS)?;
        FromPrimitive::from_u8(v).ok_or(DecodeError::MalformedInt)
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&false.to_aper(UNCONSTRAINED)?)?;
        enc.append(&(*self as u8).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// N2
#[derive(Clone)]
pub struct N2 {
    pub comb_offset_n_2: u8,
    pub cyclic_shift_n_2: u8,
}

impl APerElement for N2 {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let comb_offset_n_2 = u8::from_aper(decoder, UNCONSTRAINED)?;
        let cyclic_shift_n_2 = u8::from_aper(decoder, UNCONSTRAINED)?;

        Ok(Self {
            comb_offset_n_2,
            cyclic_shift_n_2,
        })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();

        enc.append(&self.comb_offset_n_2.to_aper(UNCONSTRAINED)?)?;
        enc.append(&self.cyclic_shift_n_2.to_aper(UNCONSTRAINED)?)?;

        Ok(enc)
    }
}

// N4
#[derive(Clone)]
pub struct N4 {
    pub comb_offset_n_4: u8,
    pub cyclic_shift_n_4: u8,
}

impl APerElement for N4 {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let comb_offset_n_4 = u8::from_aper(decoder, UNCONSTRAINED)?;
        let cyclic_shift_n_4 = u8::from_aper(decoder, UNCONSTRAINED)?;

        Ok(Self {
            comb_offset_n_4,
            cyclic_shift_n_4,
        })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();

        enc.append(&self.comb_offset_n_4.to_aper(UNCONSTRAINED)?)?;
        enc.append(&self.cyclic_shift_n_4.to_aper(UNCONSTRAINED)?)?;

        Ok(enc)
    }
}

// N21
#[derive(Clone)]
pub struct N21 {
    pub comb_offset_n_2: u8,
    pub cyclic_shift_n_2: u8,
}

impl APerElement for N21 {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let comb_offset_n_2 = u8::from_aper(decoder, UNCONSTRAINED)?;
        let cyclic_shift_n_2 = u8::from_aper(decoder, UNCONSTRAINED)?;

        Ok(Self {
            comb_offset_n_2,
            cyclic_shift_n_2,
        })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();

        enc.append(&self.comb_offset_n_2.to_aper(UNCONSTRAINED)?)?;
        enc.append(&self.cyclic_shift_n_2.to_aper(UNCONSTRAINED)?)?;

        Ok(enc)
    }
}

// N41
#[derive(Clone)]
pub struct N41 {
    pub comb_offset_n_4: u8,
    pub cyclic_shift_n_4: u8,
}

impl APerElement for N41 {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let comb_offset_n_4 = u8::from_aper(decoder, UNCONSTRAINED)?;
        let cyclic_shift_n_4 = u8::from_aper(decoder, UNCONSTRAINED)?;

        Ok(Self {
            comb_offset_n_4,
            cyclic_shift_n_4,
        })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();

        enc.append(&self.comb_offset_n_4.to_aper(UNCONSTRAINED)?)?;
        enc.append(&self.cyclic_shift_n_4.to_aper(UNCONSTRAINED)?)?;

        Ok(enc)
    }
}

// N8
#[derive(Clone)]
pub struct N8 {
    pub comb_offset_n_8: u8,
    pub cyclic_shift_n_8: u8,
}

impl APerElement for N8 {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, _constraints: Constraints) -> Result<Self, DecodeError> {
        let comb_offset_n_8 = u8::from_aper(decoder, UNCONSTRAINED)?;
        let cyclic_shift_n_8 = u8::from_aper(decoder, UNCONSTRAINED)?;

        Ok(Self {
            comb_offset_n_8,
            cyclic_shift_n_8,
        })
    }
    fn to_aper(&self, _constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();

        enc.append(&self.comb_offset_n_8.to_aper(UNCONSTRAINED)?)?;
        enc.append(&self.cyclic_shift_n_8.to_aper(UNCONSTRAINED)?)?;

        Ok(enc)
    }
}
