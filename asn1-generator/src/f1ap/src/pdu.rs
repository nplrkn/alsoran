// Copyright (c) Nicholas Larkin
// Autogenerated from F1AP-PDU-Contents.asn
use asn1::BitString;
use asn1::aper::{
    APerElement, Constraint, Constraints, DecodeError, Decoder, EncodeError, Encoding,
    UNCONSTRAINED,
};
use num_derive::FromPrimitive;
use num_traits::FromPrimitive;use super::ies::*;

// TrpInformationListTrpResp
pub struct TrpInformationListTrpResp(pub Vec<TrpInformationItemTrpResp>);

impl APerElement for TrpInformationListTrpResp {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(1),
        }),
    };
    fn from_aper(decoder: &mut Decoder, constraints: Constraints) -> Result<Self, DecodeError> {
        Ok(Self(Vec<TrpInformationItemTrpResp>::from_aper(decoder, Self::CONSTRAINTS)?))
    }
    fn to_aper(&self, constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&(self.0).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// SemipersistentSrs
pub struct SemipersistentSrs {
    pub srs_resource_set_id: SrsResourceSetId,
    pub srs_spatial_relation: Option<SpatialRelationInfo>,
}

impl APerElement for SemipersistentSrs {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(2),
            max: Some(2),
        }),
    };
    fn from_aper(decoder: &mut Decoder, constraints: Constraints) -> Result<Self, DecodeError> {
        let _extended = bool::from_aper(decoder, UNCONSTRAINED)?;
        let optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let srs_resource_set_id = SrsResourceSetId::from_aper(decoder, UNCONSTRAINED)?;
        let srs_spatial_relation = if optionals.is_set(0) {
            Some(SpatialRelationInfo::from_aper(decoder, UNCONSTRAINED)?)
        } else {
            None
        };

        Ok(Self {
            srs_resource_set_id,
            srs_spatial_relation,
        })
    }
    fn to_aper(&self, constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(2);
        optionals.set(0, self.srs_spatial_relation.is_some());

        enc.append(&false.to_aper(UNCONSTRAINED)?)?;
        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&self.srs_resource_set_id.to_aper(UNCONSTRAINED)?);
        if let Some(x) = self.srs_spatial_relation {
            enc.append(&x.to_aper(UNCONSTRAINED)?);
        }

        Ok(enc)
    }
}

// AperiodicSrs
pub struct AperiodicSrs {
    pub aperiodic: Aperiodic,
    pub srs_resource_trigger: Option<SrsResourceTrigger>,
}

impl APerElement for AperiodicSrs {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(2),
            max: Some(2),
        }),
    };
    fn from_aper(decoder: &mut Decoder, constraints: Constraints) -> Result<Self, DecodeError> {
        let _extended = bool::from_aper(decoder, UNCONSTRAINED)?;
        let optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let aperiodic = Aperiodic::from_aper(decoder, UNCONSTRAINED)?;
        let srs_resource_trigger = if optionals.is_set(0) {
            Some(SrsResourceTrigger::from_aper(decoder, UNCONSTRAINED)?)
        } else {
            None
        };

        Ok(Self {
            aperiodic,
            srs_resource_trigger,
        })
    }
    fn to_aper(&self, constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(2);
        optionals.set(0, self.srs_resource_trigger.is_some());

        enc.append(&false.to_aper(UNCONSTRAINED)?)?;
        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&self.aperiodic.to_aper(UNCONSTRAINED)?);
        if let Some(x) = self.srs_resource_trigger {
            enc.append(&x.to_aper(UNCONSTRAINED)?);
        }

        Ok(enc)
    }
}

// Aperiodic
# [derive(Clone, Copy, FromPrimitive)]
pub enum Aperiodic {
    True,
    Extended,
}

impl APerElement for Aperiodic {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, constraints: Constraints) -> Result<Self, DecodeError> {
        if bool::from_aper(decoder, Self::CONSTRAINTS)? {
            Ok(Aperiodic::Extended)
        } else {
            let v = u8::from_aper(decoder, Self::CONSTRAINTS)?;
            FromPrimitive::from_u8(v).ok_or(DecodeError::MalformedInt)
        }
    }
    fn to_aper(&self, constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&false.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&(*self as u8).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

