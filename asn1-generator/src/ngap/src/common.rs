// Copyright (c) Nicholas Larkin
// Autogenerated from NGAP-CommonDataTypes.asn
use bitvec::prelude::*;
pub type BitString = BitVec<Msb0, u8>;
use asn1_codecs::aper::{self, AperCodec, AperCodecData, AperCodecError};
#[allow(unused_imports)]
use num_enum::TryFromPrimitive;

// Criticality
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum Criticality {
    Reject,
    Ignore,
    Notify,
}

impl AperCodec for Criticality {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self::Output, AperCodecError> {
        let (idx, extended) = aper::decode::decode_enumerated(data, Some(0), Some(2), false)?;
        if extended {
            return Err(aper::AperCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| AperCodecError::new("Unknown enum variant"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_enumerated(data, Some(0), Some(2), false, *self as i128, false)
    }
}

// Presence
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum Presence {
    Optional,
    Conditional,
    Mandatory,
}

impl AperCodec for Presence {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self::Output, AperCodecError> {
        let (idx, extended) = aper::decode::decode_enumerated(data, Some(0), Some(2), false)?;
        if extended {
            return Err(aper::AperCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| AperCodecError::new("Unknown enum variant"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_enumerated(data, Some(0), Some(2), false, *self as i128, false)
    }
}

// PrivateIeId
#[derive(Clone, Debug)]
pub enum PrivateIeId {
    Local(u16),
    Global(Vec<u8>),
}

impl AperCodec for PrivateIeId {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self::Output, AperCodecError> {
        let (idx, extended) = aper::decode::decode_choice_idx(data, 0, 1, false)?;
        if extended {
            return Err(aper::AperCodecError::new(
                "CHOICE additions not implemented",
            ));
        }
        match idx {
            0 => Ok(Self::Local(
                aper::decode::decode_integer(data, Some(0), Some(65535), false)?.0 as u16,
            )),
            1 => Ok(Self::Global(aper::decode::decode_octetstring(
                data, None, None, false,
            )?)),
            _ => Err(AperCodecError::new("Unknown choice idx")),
        }
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        match self {
            Self::Local(x) => {
                aper::encode::encode_choice_idx(data, 0, 1, false, 0, false)?;
                aper::encode::encode_integer(data, Some(0), Some(65535), false, *x as i128, false)
            }
            Self::Global(x) => {
                aper::encode::encode_choice_idx(data, 0, 1, false, 1, false)?;
                aper::encode::encode_octetstring(data, None, None, false, &x, false)
            }
        }
    }
}

// ProcedureCode
#[derive(Clone, Debug)]
pub struct ProcedureCode(pub u8);

impl AperCodec for ProcedureCode {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self::Output, AperCodecError> {
        Ok(Self(
            aper::decode::decode_integer(data, Some(0), Some(255), false)?.0 as u8,
        ))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_integer(data, Some(0), Some(255), false, self.0 as i128, false)
    }
}

// ProtocolExtensionId
#[derive(Clone, Debug)]
pub struct ProtocolExtensionId(pub u16);

impl AperCodec for ProtocolExtensionId {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self::Output, AperCodecError> {
        Ok(Self(
            aper::decode::decode_integer(data, Some(0), Some(65535), false)?.0 as u16,
        ))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_integer(data, Some(0), Some(65535), false, self.0 as i128, false)
    }
}

// ProtocolIeId
#[derive(Clone, Debug)]
pub struct ProtocolIeId(pub u16);

impl AperCodec for ProtocolIeId {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self::Output, AperCodecError> {
        Ok(Self(
            aper::decode::decode_integer(data, Some(0), Some(65535), false)?.0 as u16,
        ))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_integer(data, Some(0), Some(65535), false, self.0 as i128, false)
    }
}

// TriggeringMessage
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum TriggeringMessage {
    InitiatingMessage,
    SuccessfulOutcome,
    UnsuccessfullOutcome,
}

impl AperCodec for TriggeringMessage {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self::Output, AperCodecError> {
        let (idx, extended) = aper::decode::decode_enumerated(data, Some(0), Some(2), false)?;
        if extended {
            return Err(aper::AperCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| AperCodecError::new("Unknown enum variant"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_enumerated(data, Some(0), Some(2), false, *self as i128, false)
    }
}
