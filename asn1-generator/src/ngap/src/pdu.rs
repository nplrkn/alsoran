// Copyright (c) Nicholas Larkin
// Autogenerated from NGAP-PDU-Contents.asn

use bitvec::prelude::*;
pub type BitString = BitVec<Msb0, u8>;
use super::common::*;
use super::ies::*;
use asn1_codecs::aper::{self, AperCodec, AperCodecData, AperCodecError};

// PduSessionResourceSetupRequest
#[derive(Clone)]
pub struct PduSessionResourceSetupRequest {
    pub amf_ue_ngap_id: AmfUeNgapId,
    pub ran_ue_ngap_id: RanUeNgapId,
    pub ran_paging_priority: Option<RanPagingPriority>,
    pub nas_pdu: Option<NasPdu>,
    pub pdu_session_resource_setup_list_su_req: PduSessionResourceSetupListSuReq,
    pub ue_aggregate_maximum_bit_rate: Option<UeAggregateMaximumBitRate>,
}

impl AperCodec for PduSessionResourceSetupRequest {
    type Output = PduSessionResourceSetupRequest;
    fn decode(data: &mut AperCodecData) -> Result<Self::Output, AperCodecError> {
        let _length = aper::decode::decode_length_determinent(data, None, None, false)?;
        let _ = aper::decode::decode_sequence_header(data, true, 0)?;
        let len = aper::decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut amf_ue_ngap_id: Option<AmfUeNgapId> = None;
        let mut ran_ue_ngap_id: Option<RanUeNgapId> = None;
        let mut ran_paging_priority: Option<RanPagingPriority> = None;
        let mut nas_pdu: Option<NasPdu> = None;
        let mut pdu_session_resource_setup_list_su_req: Option<PduSessionResourceSetupListSuReq> =
            None;
        let mut ue_aggregate_maximum_bit_rate: Option<UeAggregateMaximumBitRate> = None;

        for _ in 0..len {
            let (id, _ext) = aper::decode::decode_integer(data, Some(0), Some(65535), false)?;
            let criticality = Criticality::decode(data)?;
            let _length = aper::decode::decode_length_determinent(data, None, None, false)?;
            match id {
                10 => {
                    amf_ue_ngap_id = Some(AmfUeNgapId::decode(data)?);
                }
                85 => {
                    ran_ue_ngap_id = Some(RanUeNgapId::decode(data)?);
                }
                83 => {
                    ran_paging_priority = Some(RanPagingPriority::decode(data)?);
                }
                38 => {
                    nas_pdu = Some(NasPdu::decode(data)?);
                }
                74 => {
                    pdu_session_resource_setup_list_su_req =
                        Some(PduSessionResourceSetupListSuReq::decode(data)?);
                }
                110 => {
                    ue_aggregate_maximum_bit_rate = Some(UeAggregateMaximumBitRate::decode(data)?);
                }
                x => {
                    if let Criticality::Reject = criticality {
                        return Err(aper::AperCodecError::new(format!(
                            "Unrecognised IE type {} with criticality reject",
                            x
                        )));
                    }
                }
            }
        }
        let amf_ue_ngap_id = amf_ue_ngap_id.ok_or(aper::AperCodecError::new(format!(
            "Missing mandatory IE amf_ue_ngap_id"
        )))?;
        let ran_ue_ngap_id = ran_ue_ngap_id.ok_or(aper::AperCodecError::new(format!(
            "Missing mandatory IE ran_ue_ngap_id"
        )))?;
        let pdu_session_resource_setup_list_su_req =
            pdu_session_resource_setup_list_su_req.ok_or(aper::AperCodecError::new(format!(
                "Missing mandatory IE pdu_session_resource_setup_list_su_req"
            )))?;
        Ok(Self {
            amf_ue_ngap_id,
            ran_ue_ngap_id,
            ran_paging_priority,
            nas_pdu,
            pdu_session_resource_setup_list_su_req,
            ue_aggregate_maximum_bit_rate,
        })
    }
}

// PduSessionResourceSetupResponse
#[derive(Clone)]
pub struct PduSessionResourceSetupResponse {
    pub amf_ue_ngap_id: AmfUeNgapId,
    pub ran_ue_ngap_id: RanUeNgapId,
    pub pdu_session_resource_setup_list_su_res: Option<PduSessionResourceSetupListSuRes>,
    pub pdu_session_resource_failed_to_setup_list_su_res:
        Option<PduSessionResourceFailedToSetupListSuRes>,
    pub criticality_diagnostics: Option<CriticalityDiagnostics>,
}

impl AperCodec for PduSessionResourceSetupResponse {
    type Output = PduSessionResourceSetupResponse;
    fn decode(data: &mut AperCodecData) -> Result<Self::Output, AperCodecError> {
        let _length = aper::decode::decode_length_determinent(data, None, None, false)?;
        let _ = aper::decode::decode_sequence_header(data, true, 0)?;
        let len = aper::decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut amf_ue_ngap_id: Option<AmfUeNgapId> = None;
        let mut ran_ue_ngap_id: Option<RanUeNgapId> = None;
        let mut pdu_session_resource_setup_list_su_res: Option<PduSessionResourceSetupListSuRes> =
            None;
        let mut pdu_session_resource_failed_to_setup_list_su_res: Option<
            PduSessionResourceFailedToSetupListSuRes,
        > = None;
        let mut criticality_diagnostics: Option<CriticalityDiagnostics> = None;

        for _ in 0..len {
            let (id, _ext) = aper::decode::decode_integer(data, Some(0), Some(65535), false)?;
            let criticality = Criticality::decode(data)?;
            let _length = aper::decode::decode_length_determinent(data, None, None, false)?;
            match id {
                10 => {
                    amf_ue_ngap_id = Some(AmfUeNgapId::decode(data)?);
                }
                85 => {
                    ran_ue_ngap_id = Some(RanUeNgapId::decode(data)?);
                }
                75 => {
                    pdu_session_resource_setup_list_su_res =
                        Some(PduSessionResourceSetupListSuRes::decode(data)?);
                }
                58 => {
                    pdu_session_resource_failed_to_setup_list_su_res =
                        Some(PduSessionResourceFailedToSetupListSuRes::decode(data)?);
                }
                19 => {
                    criticality_diagnostics = Some(CriticalityDiagnostics::decode(data)?);
                }
                x => {
                    if let Criticality::Reject = criticality {
                        return Err(aper::AperCodecError::new(format!(
                            "Unrecognised IE type {} with criticality reject",
                            x
                        )));
                    }
                }
            }
        }
        let amf_ue_ngap_id = amf_ue_ngap_id.ok_or(aper::AperCodecError::new(format!(
            "Missing mandatory IE amf_ue_ngap_id"
        )))?;
        let ran_ue_ngap_id = ran_ue_ngap_id.ok_or(aper::AperCodecError::new(format!(
            "Missing mandatory IE ran_ue_ngap_id"
        )))?;
        Ok(Self {
            amf_ue_ngap_id,
            ran_ue_ngap_id,
            pdu_session_resource_setup_list_su_res,
            pdu_session_resource_failed_to_setup_list_su_res,
            criticality_diagnostics,
        })
    }
}

// PduSessionResourceReleaseCommand
#[derive(Clone)]
pub struct PduSessionResourceReleaseCommand {
    pub amf_ue_ngap_id: AmfUeNgapId,
    pub ran_ue_ngap_id: RanUeNgapId,
    pub ran_paging_priority: Option<RanPagingPriority>,
    pub nas_pdu: Option<NasPdu>,
    pub pdu_session_resource_to_release_list_rel_cmd: PduSessionResourceToReleaseListRelCmd,
}

impl AperCodec for PduSessionResourceReleaseCommand {
    type Output = PduSessionResourceReleaseCommand;
    fn decode(data: &mut AperCodecData) -> Result<Self::Output, AperCodecError> {
        let _length = aper::decode::decode_length_determinent(data, None, None, false)?;
        let _ = aper::decode::decode_sequence_header(data, true, 0)?;
        let len = aper::decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut amf_ue_ngap_id: Option<AmfUeNgapId> = None;
        let mut ran_ue_ngap_id: Option<RanUeNgapId> = None;
        let mut ran_paging_priority: Option<RanPagingPriority> = None;
        let mut nas_pdu: Option<NasPdu> = None;
        let mut pdu_session_resource_to_release_list_rel_cmd: Option<
            PduSessionResourceToReleaseListRelCmd,
        > = None;

        for _ in 0..len {
            let (id, _ext) = aper::decode::decode_integer(data, Some(0), Some(65535), false)?;
            let criticality = Criticality::decode(data)?;
            let _length = aper::decode::decode_length_determinent(data, None, None, false)?;
            match id {
                10 => {
                    amf_ue_ngap_id = Some(AmfUeNgapId::decode(data)?);
                }
                85 => {
                    ran_ue_ngap_id = Some(RanUeNgapId::decode(data)?);
                }
                83 => {
                    ran_paging_priority = Some(RanPagingPriority::decode(data)?);
                }
                38 => {
                    nas_pdu = Some(NasPdu::decode(data)?);
                }
                79 => {
                    pdu_session_resource_to_release_list_rel_cmd =
                        Some(PduSessionResourceToReleaseListRelCmd::decode(data)?);
                }
                x => {
                    if let Criticality::Reject = criticality {
                        return Err(aper::AperCodecError::new(format!(
                            "Unrecognised IE type {} with criticality reject",
                            x
                        )));
                    }
                }
            }
        }
        let amf_ue_ngap_id = amf_ue_ngap_id.ok_or(aper::AperCodecError::new(format!(
            "Missing mandatory IE amf_ue_ngap_id"
        )))?;
        let ran_ue_ngap_id = ran_ue_ngap_id.ok_or(aper::AperCodecError::new(format!(
            "Missing mandatory IE ran_ue_ngap_id"
        )))?;
        let pdu_session_resource_to_release_list_rel_cmd =
            pdu_session_resource_to_release_list_rel_cmd.ok_or(aper::AperCodecError::new(
                format!("Missing mandatory IE pdu_session_resource_to_release_list_rel_cmd"),
            ))?;
        Ok(Self {
            amf_ue_ngap_id,
            ran_ue_ngap_id,
            ran_paging_priority,
            nas_pdu,
            pdu_session_resource_to_release_list_rel_cmd,
        })
    }
}

// PduSessionResourceReleaseResponse
#[derive(Clone)]
pub struct PduSessionResourceReleaseResponse {
    pub amf_ue_ngap_id: AmfUeNgapId,
    pub ran_ue_ngap_id: RanUeNgapId,
    pub pdu_session_resource_released_list_rel_res: PduSessionResourceReleasedListRelRes,
    pub user_location_information: Option<UserLocationInformation>,
    pub criticality_diagnostics: Option<CriticalityDiagnostics>,
}

impl AperCodec for PduSessionResourceReleaseResponse {
    type Output = PduSessionResourceReleaseResponse;
    fn decode(data: &mut AperCodecData) -> Result<Self::Output, AperCodecError> {
        let _length = aper::decode::decode_length_determinent(data, None, None, false)?;
        let _ = aper::decode::decode_sequence_header(data, true, 0)?;
        let len = aper::decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut amf_ue_ngap_id: Option<AmfUeNgapId> = None;
        let mut ran_ue_ngap_id: Option<RanUeNgapId> = None;
        let mut pdu_session_resource_released_list_rel_res: Option<
            PduSessionResourceReleasedListRelRes,
        > = None;
        let mut user_location_information: Option<UserLocationInformation> = None;
        let mut criticality_diagnostics: Option<CriticalityDiagnostics> = None;

        for _ in 0..len {
            let (id, _ext) = aper::decode::decode_integer(data, Some(0), Some(65535), false)?;
            let criticality = Criticality::decode(data)?;
            let _length = aper::decode::decode_length_determinent(data, None, None, false)?;
            match id {
                10 => {
                    amf_ue_ngap_id = Some(AmfUeNgapId::decode(data)?);
                }
                85 => {
                    ran_ue_ngap_id = Some(RanUeNgapId::decode(data)?);
                }
                70 => {
                    pdu_session_resource_released_list_rel_res =
                        Some(PduSessionResourceReleasedListRelRes::decode(data)?);
                }
                121 => {
                    user_location_information = Some(UserLocationInformation::decode(data)?);
                }
                19 => {
                    criticality_diagnostics = Some(CriticalityDiagnostics::decode(data)?);
                }
                x => {
                    if let Criticality::Reject = criticality {
                        return Err(aper::AperCodecError::new(format!(
                            "Unrecognised IE type {} with criticality reject",
                            x
                        )));
                    }
                }
            }
        }
        let amf_ue_ngap_id = amf_ue_ngap_id.ok_or(aper::AperCodecError::new(format!(
            "Missing mandatory IE amf_ue_ngap_id"
        )))?;
        let ran_ue_ngap_id = ran_ue_ngap_id.ok_or(aper::AperCodecError::new(format!(
            "Missing mandatory IE ran_ue_ngap_id"
        )))?;
        let pdu_session_resource_released_list_rel_res = pdu_session_resource_released_list_rel_res
            .ok_or(aper::AperCodecError::new(format!(
                "Missing mandatory IE pdu_session_resource_released_list_rel_res"
            )))?;
        Ok(Self {
            amf_ue_ngap_id,
            ran_ue_ngap_id,
            pdu_session_resource_released_list_rel_res,
            user_location_information,
            criticality_diagnostics,
        })
    }
}

// PduSessionResourceModifyRequest
#[derive(Clone)]
pub struct PduSessionResourceModifyRequest {
    pub amf_ue_ngap_id: AmfUeNgapId,
    pub ran_ue_ngap_id: RanUeNgapId,
    pub ran_paging_priority: Option<RanPagingPriority>,
    pub pdu_session_resource_modify_list_mod_req: PduSessionResourceModifyListModReq,
}

impl AperCodec for PduSessionResourceModifyRequest {
    type Output = PduSessionResourceModifyRequest;
    fn decode(data: &mut AperCodecData) -> Result<Self::Output, AperCodecError> {
        let _length = aper::decode::decode_length_determinent(data, None, None, false)?;
        let _ = aper::decode::decode_sequence_header(data, true, 0)?;
        let len = aper::decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut amf_ue_ngap_id: Option<AmfUeNgapId> = None;
        let mut ran_ue_ngap_id: Option<RanUeNgapId> = None;
        let mut ran_paging_priority: Option<RanPagingPriority> = None;
        let mut pdu_session_resource_modify_list_mod_req: Option<
            PduSessionResourceModifyListModReq,
        > = None;

        for _ in 0..len {
            let (id, _ext) = aper::decode::decode_integer(data, Some(0), Some(65535), false)?;
            let criticality = Criticality::decode(data)?;
            let _length = aper::decode::decode_length_determinent(data, None, None, false)?;
            match id {
                10 => {
                    amf_ue_ngap_id = Some(AmfUeNgapId::decode(data)?);
                }
                85 => {
                    ran_ue_ngap_id = Some(RanUeNgapId::decode(data)?);
                }
                83 => {
                    ran_paging_priority = Some(RanPagingPriority::decode(data)?);
                }
                64 => {
                    pdu_session_resource_modify_list_mod_req =
                        Some(PduSessionResourceModifyListModReq::decode(data)?);
                }
                x => {
                    if let Criticality::Reject = criticality {
                        return Err(aper::AperCodecError::new(format!(
                            "Unrecognised IE type {} with criticality reject",
                            x
                        )));
                    }
                }
            }
        }
        let amf_ue_ngap_id = amf_ue_ngap_id.ok_or(aper::AperCodecError::new(format!(
            "Missing mandatory IE amf_ue_ngap_id"
        )))?;
        let ran_ue_ngap_id = ran_ue_ngap_id.ok_or(aper::AperCodecError::new(format!(
            "Missing mandatory IE ran_ue_ngap_id"
        )))?;
        let pdu_session_resource_modify_list_mod_req = pdu_session_resource_modify_list_mod_req
            .ok_or(aper::AperCodecError::new(format!(
                "Missing mandatory IE pdu_session_resource_modify_list_mod_req"
            )))?;
        Ok(Self {
            amf_ue_ngap_id,
            ran_ue_ngap_id,
            ran_paging_priority,
            pdu_session_resource_modify_list_mod_req,
        })
    }
}

// PduSessionResourceModifyResponse
#[derive(Clone)]
pub struct PduSessionResourceModifyResponse {
    pub amf_ue_ngap_id: AmfUeNgapId,
    pub ran_ue_ngap_id: RanUeNgapId,
    pub pdu_session_resource_modify_list_mod_res: Option<PduSessionResourceModifyListModRes>,
    pub pdu_session_resource_failed_to_modify_list_mod_res:
        Option<PduSessionResourceFailedToModifyListModRes>,
    pub user_location_information: Option<UserLocationInformation>,
    pub criticality_diagnostics: Option<CriticalityDiagnostics>,
}

impl AperCodec for PduSessionResourceModifyResponse {
    type Output = PduSessionResourceModifyResponse;
    fn decode(data: &mut AperCodecData) -> Result<Self::Output, AperCodecError> {
        let _length = aper::decode::decode_length_determinent(data, None, None, false)?;
        let _ = aper::decode::decode_sequence_header(data, true, 0)?;
        let len = aper::decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut amf_ue_ngap_id: Option<AmfUeNgapId> = None;
        let mut ran_ue_ngap_id: Option<RanUeNgapId> = None;
        let mut pdu_session_resource_modify_list_mod_res: Option<
            PduSessionResourceModifyListModRes,
        > = None;
        let mut pdu_session_resource_failed_to_modify_list_mod_res: Option<
            PduSessionResourceFailedToModifyListModRes,
        > = None;
        let mut user_location_information: Option<UserLocationInformation> = None;
        let mut criticality_diagnostics: Option<CriticalityDiagnostics> = None;

        for _ in 0..len {
            let (id, _ext) = aper::decode::decode_integer(data, Some(0), Some(65535), false)?;
            let criticality = Criticality::decode(data)?;
            let _length = aper::decode::decode_length_determinent(data, None, None, false)?;
            match id {
                10 => {
                    amf_ue_ngap_id = Some(AmfUeNgapId::decode(data)?);
                }
                85 => {
                    ran_ue_ngap_id = Some(RanUeNgapId::decode(data)?);
                }
                65 => {
                    pdu_session_resource_modify_list_mod_res =
                        Some(PduSessionResourceModifyListModRes::decode(data)?);
                }
                54 => {
                    pdu_session_resource_failed_to_modify_list_mod_res =
                        Some(PduSessionResourceFailedToModifyListModRes::decode(data)?);
                }
                121 => {
                    user_location_information = Some(UserLocationInformation::decode(data)?);
                }
                19 => {
                    criticality_diagnostics = Some(CriticalityDiagnostics::decode(data)?);
                }
                x => {
                    if let Criticality::Reject = criticality {
                        return Err(aper::AperCodecError::new(format!(
                            "Unrecognised IE type {} with criticality reject",
                            x
                        )));
                    }
                }
            }
        }
        let amf_ue_ngap_id = amf_ue_ngap_id.ok_or(aper::AperCodecError::new(format!(
            "Missing mandatory IE amf_ue_ngap_id"
        )))?;
        let ran_ue_ngap_id = ran_ue_ngap_id.ok_or(aper::AperCodecError::new(format!(
            "Missing mandatory IE ran_ue_ngap_id"
        )))?;
        Ok(Self {
            amf_ue_ngap_id,
            ran_ue_ngap_id,
            pdu_session_resource_modify_list_mod_res,
            pdu_session_resource_failed_to_modify_list_mod_res,
            user_location_information,
            criticality_diagnostics,
        })
    }
}

// PduSessionResourceNotify
#[derive(Clone)]
pub struct PduSessionResourceNotify {
    pub amf_ue_ngap_id: AmfUeNgapId,
    pub ran_ue_ngap_id: RanUeNgapId,
    pub pdu_session_resource_notify_list: Option<PduSessionResourceNotifyList>,
    pub pdu_session_resource_released_list_not: Option<PduSessionResourceReleasedListNot>,
    pub user_location_information: Option<UserLocationInformation>,
}

impl AperCodec for PduSessionResourceNotify {
    type Output = PduSessionResourceNotify;
    fn decode(data: &mut AperCodecData) -> Result<Self::Output, AperCodecError> {
        let _length = aper::decode::decode_length_determinent(data, None, None, false)?;
        let _ = aper::decode::decode_sequence_header(data, true, 0)?;
        let len = aper::decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut amf_ue_ngap_id: Option<AmfUeNgapId> = None;
        let mut ran_ue_ngap_id: Option<RanUeNgapId> = None;
        let mut pdu_session_resource_notify_list: Option<PduSessionResourceNotifyList> = None;
        let mut pdu_session_resource_released_list_not: Option<PduSessionResourceReleasedListNot> =
            None;
        let mut user_location_information: Option<UserLocationInformation> = None;

        for _ in 0..len {
            let (id, _ext) = aper::decode::decode_integer(data, Some(0), Some(65535), false)?;
            let criticality = Criticality::decode(data)?;
            let _length = aper::decode::decode_length_determinent(data, None, None, false)?;
            match id {
                10 => {
                    amf_ue_ngap_id = Some(AmfUeNgapId::decode(data)?);
                }
                85 => {
                    ran_ue_ngap_id = Some(RanUeNgapId::decode(data)?);
                }
                66 => {
                    pdu_session_resource_notify_list =
                        Some(PduSessionResourceNotifyList::decode(data)?);
                }
                67 => {
                    pdu_session_resource_released_list_not =
                        Some(PduSessionResourceReleasedListNot::decode(data)?);
                }
                121 => {
                    user_location_information = Some(UserLocationInformation::decode(data)?);
                }
                x => {
                    if let Criticality::Reject = criticality {
                        return Err(aper::AperCodecError::new(format!(
                            "Unrecognised IE type {} with criticality reject",
                            x
                        )));
                    }
                }
            }
        }
        let amf_ue_ngap_id = amf_ue_ngap_id.ok_or(aper::AperCodecError::new(format!(
            "Missing mandatory IE amf_ue_ngap_id"
        )))?;
        let ran_ue_ngap_id = ran_ue_ngap_id.ok_or(aper::AperCodecError::new(format!(
            "Missing mandatory IE ran_ue_ngap_id"
        )))?;
        Ok(Self {
            amf_ue_ngap_id,
            ran_ue_ngap_id,
            pdu_session_resource_notify_list,
            pdu_session_resource_released_list_not,
            user_location_information,
        })
    }
}

// PduSessionResourceModifyIndication
#[derive(Clone)]
pub struct PduSessionResourceModifyIndication {
    pub amf_ue_ngap_id: AmfUeNgapId,
    pub ran_ue_ngap_id: RanUeNgapId,
    pub pdu_session_resource_modify_list_mod_ind: PduSessionResourceModifyListModInd,
    pub user_location_information: Option<UserLocationInformation>,
}

impl AperCodec for PduSessionResourceModifyIndication {
    type Output = PduSessionResourceModifyIndication;
    fn decode(data: &mut AperCodecData) -> Result<Self::Output, AperCodecError> {
        let _length = aper::decode::decode_length_determinent(data, None, None, false)?;
        let _ = aper::decode::decode_sequence_header(data, true, 0)?;
        let len = aper::decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut amf_ue_ngap_id: Option<AmfUeNgapId> = None;
        let mut ran_ue_ngap_id: Option<RanUeNgapId> = None;
        let mut pdu_session_resource_modify_list_mod_ind: Option<
            PduSessionResourceModifyListModInd,
        > = None;
        let mut user_location_information: Option<UserLocationInformation> = None;

        for _ in 0..len {
            let (id, _ext) = aper::decode::decode_integer(data, Some(0), Some(65535), false)?;
            let criticality = Criticality::decode(data)?;
            let _length = aper::decode::decode_length_determinent(data, None, None, false)?;
            match id {
                10 => {
                    amf_ue_ngap_id = Some(AmfUeNgapId::decode(data)?);
                }
                85 => {
                    ran_ue_ngap_id = Some(RanUeNgapId::decode(data)?);
                }
                63 => {
                    pdu_session_resource_modify_list_mod_ind =
                        Some(PduSessionResourceModifyListModInd::decode(data)?);
                }
                121 => {
                    user_location_information = Some(UserLocationInformation::decode(data)?);
                }
                x => {
                    if let Criticality::Reject = criticality {
                        return Err(aper::AperCodecError::new(format!(
                            "Unrecognised IE type {} with criticality reject",
                            x
                        )));
                    }
                }
            }
        }
        let amf_ue_ngap_id = amf_ue_ngap_id.ok_or(aper::AperCodecError::new(format!(
            "Missing mandatory IE amf_ue_ngap_id"
        )))?;
        let ran_ue_ngap_id = ran_ue_ngap_id.ok_or(aper::AperCodecError::new(format!(
            "Missing mandatory IE ran_ue_ngap_id"
        )))?;
        let pdu_session_resource_modify_list_mod_ind = pdu_session_resource_modify_list_mod_ind
            .ok_or(aper::AperCodecError::new(format!(
                "Missing mandatory IE pdu_session_resource_modify_list_mod_ind"
            )))?;
        Ok(Self {
            amf_ue_ngap_id,
            ran_ue_ngap_id,
            pdu_session_resource_modify_list_mod_ind,
            user_location_information,
        })
    }
}

// PduSessionResourceModifyConfirm
#[derive(Clone)]
pub struct PduSessionResourceModifyConfirm {
    pub amf_ue_ngap_id: AmfUeNgapId,
    pub ran_ue_ngap_id: RanUeNgapId,
    pub pdu_session_resource_modify_list_mod_cfm: Option<PduSessionResourceModifyListModCfm>,
    pub pdu_session_resource_failed_to_modify_list_mod_cfm:
        Option<PduSessionResourceFailedToModifyListModCfm>,
    pub criticality_diagnostics: Option<CriticalityDiagnostics>,
}

impl AperCodec for PduSessionResourceModifyConfirm {
    type Output = PduSessionResourceModifyConfirm;
    fn decode(data: &mut AperCodecData) -> Result<Self::Output, AperCodecError> {
        let _length = aper::decode::decode_length_determinent(data, None, None, false)?;
        let _ = aper::decode::decode_sequence_header(data, true, 0)?;
        let len = aper::decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut amf_ue_ngap_id: Option<AmfUeNgapId> = None;
        let mut ran_ue_ngap_id: Option<RanUeNgapId> = None;
        let mut pdu_session_resource_modify_list_mod_cfm: Option<
            PduSessionResourceModifyListModCfm,
        > = None;
        let mut pdu_session_resource_failed_to_modify_list_mod_cfm: Option<
            PduSessionResourceFailedToModifyListModCfm,
        > = None;
        let mut criticality_diagnostics: Option<CriticalityDiagnostics> = None;

        for _ in 0..len {
            let (id, _ext) = aper::decode::decode_integer(data, Some(0), Some(65535), false)?;
            let criticality = Criticality::decode(data)?;
            let _length = aper::decode::decode_length_determinent(data, None, None, false)?;
            match id {
                10 => {
                    amf_ue_ngap_id = Some(AmfUeNgapId::decode(data)?);
                }
                85 => {
                    ran_ue_ngap_id = Some(RanUeNgapId::decode(data)?);
                }
                62 => {
                    pdu_session_resource_modify_list_mod_cfm =
                        Some(PduSessionResourceModifyListModCfm::decode(data)?);
                }
                131 => {
                    pdu_session_resource_failed_to_modify_list_mod_cfm =
                        Some(PduSessionResourceFailedToModifyListModCfm::decode(data)?);
                }
                19 => {
                    criticality_diagnostics = Some(CriticalityDiagnostics::decode(data)?);
                }
                x => {
                    if let Criticality::Reject = criticality {
                        return Err(aper::AperCodecError::new(format!(
                            "Unrecognised IE type {} with criticality reject",
                            x
                        )));
                    }
                }
            }
        }
        let amf_ue_ngap_id = amf_ue_ngap_id.ok_or(aper::AperCodecError::new(format!(
            "Missing mandatory IE amf_ue_ngap_id"
        )))?;
        let ran_ue_ngap_id = ran_ue_ngap_id.ok_or(aper::AperCodecError::new(format!(
            "Missing mandatory IE ran_ue_ngap_id"
        )))?;
        Ok(Self {
            amf_ue_ngap_id,
            ran_ue_ngap_id,
            pdu_session_resource_modify_list_mod_cfm,
            pdu_session_resource_failed_to_modify_list_mod_cfm,
            criticality_diagnostics,
        })
    }
}

// InitialContextSetupRequest
#[derive(Clone)]
pub struct InitialContextSetupRequest {
    pub amf_ue_ngap_id: AmfUeNgapId,
    pub ran_ue_ngap_id: RanUeNgapId,
    pub old_amf: Option<AmfName>,
    pub ue_aggregate_maximum_bit_rate: Option<UeAggregateMaximumBitRate>,
    pub core_network_assistance_information_for_inactive:
        Option<CoreNetworkAssistanceInformationForInactive>,
    pub guami: Guami,
    pub pdu_session_resource_setup_list_cxt_req: Option<PduSessionResourceSetupListCxtReq>,
    pub allowed_nssai: AllowedNssai,
    pub ue_security_capabilities: UeSecurityCapabilities,
    pub security_key: SecurityKey,
    pub trace_activation: Option<TraceActivation>,
    pub mobility_restriction_list: Option<MobilityRestrictionList>,
    pub ue_radio_capability: Option<UeRadioCapability>,
    pub index_to_rfsp: Option<IndexToRfsp>,
    pub masked_imeisv: Option<MaskedImeisv>,
    pub nas_pdu: Option<NasPdu>,
    pub emergency_fallback_indicator: Option<EmergencyFallbackIndicator>,
    pub rrc_inactive_transition_report_request: Option<RrcInactiveTransitionReportRequest>,
    pub ue_radio_capability_for_paging: Option<UeRadioCapabilityForPaging>,
    pub redirection_voice_fallback: Option<RedirectionVoiceFallback>,
    pub location_reporting_request_type: Option<LocationReportingRequestType>,
    pub cn_assisted_ran_tuning: Option<CnAssistedRanTuning>,
    pub srvcc_operation_possible: Option<SrvccOperationPossible>,
    pub iab_authorized: Option<IabAuthorized>,
    pub enhanced_coverage_restriction: Option<EnhancedCoverageRestriction>,
    pub extended_connected_time: Option<ExtendedConnectedTime>,
    pub ue_differentiation_info: Option<UeDifferentiationInfo>,
    pub nrv2x_services_authorized: Option<Nrv2xServicesAuthorized>,
    pub ltev2x_services_authorized: Option<Ltev2xServicesAuthorized>,
    pub nrue_sidelink_aggregate_maximum_bitrate: Option<NrueSidelinkAggregateMaximumBitrate>,
    pub lteue_sidelink_aggregate_maximum_bitrate: Option<LteueSidelinkAggregateMaximumBitrate>,
    pub pc5_qos_parameters: Option<Pc5QosParameters>,
    pub c_emode_brestricted: Option<CEmodeBrestricted>,
    pub ue_up_c_iot_support: Option<UeUpCIotSupport>,
    pub rg_level_wireline_access_characteristics: Option<RgLevelWirelineAccessCharacteristics>,
    pub management_based_mdt_plmn_list: Option<MdtPlmnList>,
    pub ue_radio_capability_id: Option<UeRadioCapabilityId>,
}

impl AperCodec for InitialContextSetupRequest {
    type Output = InitialContextSetupRequest;
    fn decode(data: &mut AperCodecData) -> Result<Self::Output, AperCodecError> {
        let _length = aper::decode::decode_length_determinent(data, None, None, false)?;
        let _ = aper::decode::decode_sequence_header(data, true, 0)?;
        let len = aper::decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut amf_ue_ngap_id: Option<AmfUeNgapId> = None;
        let mut ran_ue_ngap_id: Option<RanUeNgapId> = None;
        let mut old_amf: Option<AmfName> = None;
        let mut ue_aggregate_maximum_bit_rate: Option<UeAggregateMaximumBitRate> = None;
        let mut core_network_assistance_information_for_inactive: Option<
            CoreNetworkAssistanceInformationForInactive,
        > = None;
        let mut guami: Option<Guami> = None;
        let mut pdu_session_resource_setup_list_cxt_req: Option<PduSessionResourceSetupListCxtReq> =
            None;
        let mut allowed_nssai: Option<AllowedNssai> = None;
        let mut ue_security_capabilities: Option<UeSecurityCapabilities> = None;
        let mut security_key: Option<SecurityKey> = None;
        let mut trace_activation: Option<TraceActivation> = None;
        let mut mobility_restriction_list: Option<MobilityRestrictionList> = None;
        let mut ue_radio_capability: Option<UeRadioCapability> = None;
        let mut index_to_rfsp: Option<IndexToRfsp> = None;
        let mut masked_imeisv: Option<MaskedImeisv> = None;
        let mut nas_pdu: Option<NasPdu> = None;
        let mut emergency_fallback_indicator: Option<EmergencyFallbackIndicator> = None;
        let mut rrc_inactive_transition_report_request: Option<RrcInactiveTransitionReportRequest> =
            None;
        let mut ue_radio_capability_for_paging: Option<UeRadioCapabilityForPaging> = None;
        let mut redirection_voice_fallback: Option<RedirectionVoiceFallback> = None;
        let mut location_reporting_request_type: Option<LocationReportingRequestType> = None;
        let mut cn_assisted_ran_tuning: Option<CnAssistedRanTuning> = None;
        let mut srvcc_operation_possible: Option<SrvccOperationPossible> = None;
        let mut iab_authorized: Option<IabAuthorized> = None;
        let mut enhanced_coverage_restriction: Option<EnhancedCoverageRestriction> = None;
        let mut extended_connected_time: Option<ExtendedConnectedTime> = None;
        let mut ue_differentiation_info: Option<UeDifferentiationInfo> = None;
        let mut nrv2x_services_authorized: Option<Nrv2xServicesAuthorized> = None;
        let mut ltev2x_services_authorized: Option<Ltev2xServicesAuthorized> = None;
        let mut nrue_sidelink_aggregate_maximum_bitrate: Option<
            NrueSidelinkAggregateMaximumBitrate,
        > = None;
        let mut lteue_sidelink_aggregate_maximum_bitrate: Option<
            LteueSidelinkAggregateMaximumBitrate,
        > = None;
        let mut pc5_qos_parameters: Option<Pc5QosParameters> = None;
        let mut c_emode_brestricted: Option<CEmodeBrestricted> = None;
        let mut ue_up_c_iot_support: Option<UeUpCIotSupport> = None;
        let mut rg_level_wireline_access_characteristics: Option<
            RgLevelWirelineAccessCharacteristics,
        > = None;
        let mut management_based_mdt_plmn_list: Option<MdtPlmnList> = None;
        let mut ue_radio_capability_id: Option<UeRadioCapabilityId> = None;

        for _ in 0..len {
            let (id, _ext) = aper::decode::decode_integer(data, Some(0), Some(65535), false)?;
            let criticality = Criticality::decode(data)?;
            let _length = aper::decode::decode_length_determinent(data, None, None, false)?;
            match id {
                10 => {
                    amf_ue_ngap_id = Some(AmfUeNgapId::decode(data)?);
                }
                85 => {
                    ran_ue_ngap_id = Some(RanUeNgapId::decode(data)?);
                }
                48 => {
                    old_amf = Some(AmfName::decode(data)?);
                }
                110 => {
                    ue_aggregate_maximum_bit_rate = Some(UeAggregateMaximumBitRate::decode(data)?);
                }
                18 => {
                    core_network_assistance_information_for_inactive =
                        Some(CoreNetworkAssistanceInformationForInactive::decode(data)?);
                }
                28 => {
                    guami = Some(Guami::decode(data)?);
                }
                71 => {
                    pdu_session_resource_setup_list_cxt_req =
                        Some(PduSessionResourceSetupListCxtReq::decode(data)?);
                }
                0 => {
                    allowed_nssai = Some(AllowedNssai::decode(data)?);
                }
                119 => {
                    ue_security_capabilities = Some(UeSecurityCapabilities::decode(data)?);
                }
                94 => {
                    security_key = Some(SecurityKey::decode(data)?);
                }
                108 => {
                    trace_activation = Some(TraceActivation::decode(data)?);
                }
                36 => {
                    mobility_restriction_list = Some(MobilityRestrictionList::decode(data)?);
                }
                117 => {
                    ue_radio_capability = Some(UeRadioCapability::decode(data)?);
                }
                31 => {
                    index_to_rfsp = Some(IndexToRfsp::decode(data)?);
                }
                34 => {
                    masked_imeisv = Some(MaskedImeisv::decode(data)?);
                }
                38 => {
                    nas_pdu = Some(NasPdu::decode(data)?);
                }
                24 => {
                    emergency_fallback_indicator = Some(EmergencyFallbackIndicator::decode(data)?);
                }
                91 => {
                    rrc_inactive_transition_report_request =
                        Some(RrcInactiveTransitionReportRequest::decode(data)?);
                }
                118 => {
                    ue_radio_capability_for_paging =
                        Some(UeRadioCapabilityForPaging::decode(data)?);
                }
                146 => {
                    redirection_voice_fallback = Some(RedirectionVoiceFallback::decode(data)?);
                }
                33 => {
                    location_reporting_request_type =
                        Some(LocationReportingRequestType::decode(data)?);
                }
                165 => {
                    cn_assisted_ran_tuning = Some(CnAssistedRanTuning::decode(data)?);
                }
                177 => {
                    srvcc_operation_possible = Some(SrvccOperationPossible::decode(data)?);
                }
                199 => {
                    iab_authorized = Some(IabAuthorized::decode(data)?);
                }
                205 => {
                    enhanced_coverage_restriction =
                        Some(EnhancedCoverageRestriction::decode(data)?);
                }
                206 => {
                    extended_connected_time = Some(ExtendedConnectedTime::decode(data)?);
                }
                209 => {
                    ue_differentiation_info = Some(UeDifferentiationInfo::decode(data)?);
                }
                216 => {
                    nrv2x_services_authorized = Some(Nrv2xServicesAuthorized::decode(data)?);
                }
                215 => {
                    ltev2x_services_authorized = Some(Ltev2xServicesAuthorized::decode(data)?);
                }
                218 => {
                    nrue_sidelink_aggregate_maximum_bitrate =
                        Some(NrueSidelinkAggregateMaximumBitrate::decode(data)?);
                }
                217 => {
                    lteue_sidelink_aggregate_maximum_bitrate =
                        Some(LteueSidelinkAggregateMaximumBitrate::decode(data)?);
                }
                219 => {
                    pc5_qos_parameters = Some(Pc5QosParameters::decode(data)?);
                }
                222 => {
                    c_emode_brestricted = Some(CEmodeBrestricted::decode(data)?);
                }
                234 => {
                    ue_up_c_iot_support = Some(UeUpCIotSupport::decode(data)?);
                }
                238 => {
                    rg_level_wireline_access_characteristics =
                        Some(RgLevelWirelineAccessCharacteristics::decode(data)?);
                }
                254 => {
                    management_based_mdt_plmn_list = Some(MdtPlmnList::decode(data)?);
                }
                264 => {
                    ue_radio_capability_id = Some(UeRadioCapabilityId::decode(data)?);
                }
                x => {
                    if let Criticality::Reject = criticality {
                        return Err(aper::AperCodecError::new(format!(
                            "Unrecognised IE type {} with criticality reject",
                            x
                        )));
                    }
                }
            }
        }
        let amf_ue_ngap_id = amf_ue_ngap_id.ok_or(aper::AperCodecError::new(format!(
            "Missing mandatory IE amf_ue_ngap_id"
        )))?;
        let ran_ue_ngap_id = ran_ue_ngap_id.ok_or(aper::AperCodecError::new(format!(
            "Missing mandatory IE ran_ue_ngap_id"
        )))?;
        let guami = guami.ok_or(aper::AperCodecError::new(format!(
            "Missing mandatory IE guami"
        )))?;
        let allowed_nssai = allowed_nssai.ok_or(aper::AperCodecError::new(format!(
            "Missing mandatory IE allowed_nssai"
        )))?;
        let ue_security_capabilities = ue_security_capabilities.ok_or(
            aper::AperCodecError::new(format!("Missing mandatory IE ue_security_capabilities")),
        )?;
        let security_key = security_key.ok_or(aper::AperCodecError::new(format!(
            "Missing mandatory IE security_key"
        )))?;
        Ok(Self {
            amf_ue_ngap_id,
            ran_ue_ngap_id,
            old_amf,
            ue_aggregate_maximum_bit_rate,
            core_network_assistance_information_for_inactive,
            guami,
            pdu_session_resource_setup_list_cxt_req,
            allowed_nssai,
            ue_security_capabilities,
            security_key,
            trace_activation,
            mobility_restriction_list,
            ue_radio_capability,
            index_to_rfsp,
            masked_imeisv,
            nas_pdu,
            emergency_fallback_indicator,
            rrc_inactive_transition_report_request,
            ue_radio_capability_for_paging,
            redirection_voice_fallback,
            location_reporting_request_type,
            cn_assisted_ran_tuning,
            srvcc_operation_possible,
            iab_authorized,
            enhanced_coverage_restriction,
            extended_connected_time,
            ue_differentiation_info,
            nrv2x_services_authorized,
            ltev2x_services_authorized,
            nrue_sidelink_aggregate_maximum_bitrate,
            lteue_sidelink_aggregate_maximum_bitrate,
            pc5_qos_parameters,
            c_emode_brestricted,
            ue_up_c_iot_support,
            rg_level_wireline_access_characteristics,
            management_based_mdt_plmn_list,
            ue_radio_capability_id,
        })
    }
}

// InitialContextSetupResponse
#[derive(Clone)]
pub struct InitialContextSetupResponse {
    pub amf_ue_ngap_id: AmfUeNgapId,
    pub ran_ue_ngap_id: RanUeNgapId,
    pub pdu_session_resource_setup_list_cxt_res: Option<PduSessionResourceSetupListCxtRes>,
    pub pdu_session_resource_failed_to_setup_list_cxt_res:
        Option<PduSessionResourceFailedToSetupListCxtRes>,
    pub criticality_diagnostics: Option<CriticalityDiagnostics>,
}

impl AperCodec for InitialContextSetupResponse {
    type Output = InitialContextSetupResponse;
    fn decode(data: &mut AperCodecData) -> Result<Self::Output, AperCodecError> {
        let _length = aper::decode::decode_length_determinent(data, None, None, false)?;
        let _ = aper::decode::decode_sequence_header(data, true, 0)?;
        let len = aper::decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut amf_ue_ngap_id: Option<AmfUeNgapId> = None;
        let mut ran_ue_ngap_id: Option<RanUeNgapId> = None;
        let mut pdu_session_resource_setup_list_cxt_res: Option<PduSessionResourceSetupListCxtRes> =
            None;
        let mut pdu_session_resource_failed_to_setup_list_cxt_res: Option<
            PduSessionResourceFailedToSetupListCxtRes,
        > = None;
        let mut criticality_diagnostics: Option<CriticalityDiagnostics> = None;

        for _ in 0..len {
            let (id, _ext) = aper::decode::decode_integer(data, Some(0), Some(65535), false)?;
            let criticality = Criticality::decode(data)?;
            let _length = aper::decode::decode_length_determinent(data, None, None, false)?;
            match id {
                10 => {
                    amf_ue_ngap_id = Some(AmfUeNgapId::decode(data)?);
                }
                85 => {
                    ran_ue_ngap_id = Some(RanUeNgapId::decode(data)?);
                }
                72 => {
                    pdu_session_resource_setup_list_cxt_res =
                        Some(PduSessionResourceSetupListCxtRes::decode(data)?);
                }
                55 => {
                    pdu_session_resource_failed_to_setup_list_cxt_res =
                        Some(PduSessionResourceFailedToSetupListCxtRes::decode(data)?);
                }
                19 => {
                    criticality_diagnostics = Some(CriticalityDiagnostics::decode(data)?);
                }
                x => {
                    if let Criticality::Reject = criticality {
                        return Err(aper::AperCodecError::new(format!(
                            "Unrecognised IE type {} with criticality reject",
                            x
                        )));
                    }
                }
            }
        }
        let amf_ue_ngap_id = amf_ue_ngap_id.ok_or(aper::AperCodecError::new(format!(
            "Missing mandatory IE amf_ue_ngap_id"
        )))?;
        let ran_ue_ngap_id = ran_ue_ngap_id.ok_or(aper::AperCodecError::new(format!(
            "Missing mandatory IE ran_ue_ngap_id"
        )))?;
        Ok(Self {
            amf_ue_ngap_id,
            ran_ue_ngap_id,
            pdu_session_resource_setup_list_cxt_res,
            pdu_session_resource_failed_to_setup_list_cxt_res,
            criticality_diagnostics,
        })
    }
}

// InitialContextSetupFailure
#[derive(Clone)]
pub struct InitialContextSetupFailure {
    pub amf_ue_ngap_id: AmfUeNgapId,
    pub ran_ue_ngap_id: RanUeNgapId,
    pub pdu_session_resource_failed_to_setup_list_cxt_fail:
        Option<PduSessionResourceFailedToSetupListCxtFail>,
    pub cause: Cause,
    pub criticality_diagnostics: Option<CriticalityDiagnostics>,
}

impl AperCodec for InitialContextSetupFailure {
    type Output = InitialContextSetupFailure;
    fn decode(data: &mut AperCodecData) -> Result<Self::Output, AperCodecError> {
        let _length = aper::decode::decode_length_determinent(data, None, None, false)?;
        let _ = aper::decode::decode_sequence_header(data, true, 0)?;
        let len = aper::decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut amf_ue_ngap_id: Option<AmfUeNgapId> = None;
        let mut ran_ue_ngap_id: Option<RanUeNgapId> = None;
        let mut pdu_session_resource_failed_to_setup_list_cxt_fail: Option<
            PduSessionResourceFailedToSetupListCxtFail,
        > = None;
        let mut cause: Option<Cause> = None;
        let mut criticality_diagnostics: Option<CriticalityDiagnostics> = None;

        for _ in 0..len {
            let (id, _ext) = aper::decode::decode_integer(data, Some(0), Some(65535), false)?;
            let criticality = Criticality::decode(data)?;
            let _length = aper::decode::decode_length_determinent(data, None, None, false)?;
            match id {
                10 => {
                    amf_ue_ngap_id = Some(AmfUeNgapId::decode(data)?);
                }
                85 => {
                    ran_ue_ngap_id = Some(RanUeNgapId::decode(data)?);
                }
                132 => {
                    pdu_session_resource_failed_to_setup_list_cxt_fail =
                        Some(PduSessionResourceFailedToSetupListCxtFail::decode(data)?);
                }
                15 => {
                    cause = Some(Cause::decode(data)?);
                }
                19 => {
                    criticality_diagnostics = Some(CriticalityDiagnostics::decode(data)?);
                }
                x => {
                    if let Criticality::Reject = criticality {
                        return Err(aper::AperCodecError::new(format!(
                            "Unrecognised IE type {} with criticality reject",
                            x
                        )));
                    }
                }
            }
        }
        let amf_ue_ngap_id = amf_ue_ngap_id.ok_or(aper::AperCodecError::new(format!(
            "Missing mandatory IE amf_ue_ngap_id"
        )))?;
        let ran_ue_ngap_id = ran_ue_ngap_id.ok_or(aper::AperCodecError::new(format!(
            "Missing mandatory IE ran_ue_ngap_id"
        )))?;
        let cause = cause.ok_or(aper::AperCodecError::new(format!(
            "Missing mandatory IE cause"
        )))?;
        Ok(Self {
            amf_ue_ngap_id,
            ran_ue_ngap_id,
            pdu_session_resource_failed_to_setup_list_cxt_fail,
            cause,
            criticality_diagnostics,
        })
    }
}

// UeContextReleaseRequest
#[derive(Clone)]
pub struct UeContextReleaseRequest {
    pub amf_ue_ngap_id: AmfUeNgapId,
    pub ran_ue_ngap_id: RanUeNgapId,
    pub pdu_session_resource_list_cxt_rel_req: Option<PduSessionResourceListCxtRelReq>,
    pub cause: Cause,
}

impl AperCodec for UeContextReleaseRequest {
    type Output = UeContextReleaseRequest;
    fn decode(data: &mut AperCodecData) -> Result<Self::Output, AperCodecError> {
        let _length = aper::decode::decode_length_determinent(data, None, None, false)?;
        let _ = aper::decode::decode_sequence_header(data, true, 0)?;
        let len = aper::decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut amf_ue_ngap_id: Option<AmfUeNgapId> = None;
        let mut ran_ue_ngap_id: Option<RanUeNgapId> = None;
        let mut pdu_session_resource_list_cxt_rel_req: Option<PduSessionResourceListCxtRelReq> =
            None;
        let mut cause: Option<Cause> = None;

        for _ in 0..len {
            let (id, _ext) = aper::decode::decode_integer(data, Some(0), Some(65535), false)?;
            let criticality = Criticality::decode(data)?;
            let _length = aper::decode::decode_length_determinent(data, None, None, false)?;
            match id {
                10 => {
                    amf_ue_ngap_id = Some(AmfUeNgapId::decode(data)?);
                }
                85 => {
                    ran_ue_ngap_id = Some(RanUeNgapId::decode(data)?);
                }
                133 => {
                    pdu_session_resource_list_cxt_rel_req =
                        Some(PduSessionResourceListCxtRelReq::decode(data)?);
                }
                15 => {
                    cause = Some(Cause::decode(data)?);
                }
                x => {
                    if let Criticality::Reject = criticality {
                        return Err(aper::AperCodecError::new(format!(
                            "Unrecognised IE type {} with criticality reject",
                            x
                        )));
                    }
                }
            }
        }
        let amf_ue_ngap_id = amf_ue_ngap_id.ok_or(aper::AperCodecError::new(format!(
            "Missing mandatory IE amf_ue_ngap_id"
        )))?;
        let ran_ue_ngap_id = ran_ue_ngap_id.ok_or(aper::AperCodecError::new(format!(
            "Missing mandatory IE ran_ue_ngap_id"
        )))?;
        let cause = cause.ok_or(aper::AperCodecError::new(format!(
            "Missing mandatory IE cause"
        )))?;
        Ok(Self {
            amf_ue_ngap_id,
            ran_ue_ngap_id,
            pdu_session_resource_list_cxt_rel_req,
            cause,
        })
    }
}

// UeContextReleaseCommand
#[derive(Clone)]
pub struct UeContextReleaseCommand {
    pub ue_ngap_i_ds: UeNgapIDs,
    pub cause: Cause,
}

impl AperCodec for UeContextReleaseCommand {
    type Output = UeContextReleaseCommand;
    fn decode(data: &mut AperCodecData) -> Result<Self::Output, AperCodecError> {
        let _length = aper::decode::decode_length_determinent(data, None, None, false)?;
        let _ = aper::decode::decode_sequence_header(data, true, 0)?;
        let len = aper::decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut ue_ngap_i_ds: Option<UeNgapIDs> = None;
        let mut cause: Option<Cause> = None;

        for _ in 0..len {
            let (id, _ext) = aper::decode::decode_integer(data, Some(0), Some(65535), false)?;
            let criticality = Criticality::decode(data)?;
            let _length = aper::decode::decode_length_determinent(data, None, None, false)?;
            match id {
                114 => {
                    ue_ngap_i_ds = Some(UeNgapIDs::decode(data)?);
                }
                15 => {
                    cause = Some(Cause::decode(data)?);
                }
                x => {
                    if let Criticality::Reject = criticality {
                        return Err(aper::AperCodecError::new(format!(
                            "Unrecognised IE type {} with criticality reject",
                            x
                        )));
                    }
                }
            }
        }
        let ue_ngap_i_ds = ue_ngap_i_ds.ok_or(aper::AperCodecError::new(format!(
            "Missing mandatory IE ue_ngap_i_ds"
        )))?;
        let cause = cause.ok_or(aper::AperCodecError::new(format!(
            "Missing mandatory IE cause"
        )))?;
        Ok(Self {
            ue_ngap_i_ds,
            cause,
        })
    }
}

// UeContextReleaseComplete
#[derive(Clone)]
pub struct UeContextReleaseComplete {
    pub amf_ue_ngap_id: AmfUeNgapId,
    pub ran_ue_ngap_id: RanUeNgapId,
    pub user_location_information: Option<UserLocationInformation>,
    pub info_on_recommended_cells_and_ran_nodes_for_paging:
        Option<InfoOnRecommendedCellsAndRanNodesForPaging>,
    pub pdu_session_resource_list_cxt_rel_cpl: Option<PduSessionResourceListCxtRelCpl>,
    pub criticality_diagnostics: Option<CriticalityDiagnostics>,
    pub paging_assis_datafor_c_ecapab_ue: Option<PagingAssisDataforCEcapabUe>,
}

impl AperCodec for UeContextReleaseComplete {
    type Output = UeContextReleaseComplete;
    fn decode(data: &mut AperCodecData) -> Result<Self::Output, AperCodecError> {
        let _length = aper::decode::decode_length_determinent(data, None, None, false)?;
        let _ = aper::decode::decode_sequence_header(data, true, 0)?;
        let len = aper::decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut amf_ue_ngap_id: Option<AmfUeNgapId> = None;
        let mut ran_ue_ngap_id: Option<RanUeNgapId> = None;
        let mut user_location_information: Option<UserLocationInformation> = None;
        let mut info_on_recommended_cells_and_ran_nodes_for_paging: Option<
            InfoOnRecommendedCellsAndRanNodesForPaging,
        > = None;
        let mut pdu_session_resource_list_cxt_rel_cpl: Option<PduSessionResourceListCxtRelCpl> =
            None;
        let mut criticality_diagnostics: Option<CriticalityDiagnostics> = None;
        let mut paging_assis_datafor_c_ecapab_ue: Option<PagingAssisDataforCEcapabUe> = None;

        for _ in 0..len {
            let (id, _ext) = aper::decode::decode_integer(data, Some(0), Some(65535), false)?;
            let criticality = Criticality::decode(data)?;
            let _length = aper::decode::decode_length_determinent(data, None, None, false)?;
            match id {
                10 => {
                    amf_ue_ngap_id = Some(AmfUeNgapId::decode(data)?);
                }
                85 => {
                    ran_ue_ngap_id = Some(RanUeNgapId::decode(data)?);
                }
                121 => {
                    user_location_information = Some(UserLocationInformation::decode(data)?);
                }
                32 => {
                    info_on_recommended_cells_and_ran_nodes_for_paging =
                        Some(InfoOnRecommendedCellsAndRanNodesForPaging::decode(data)?);
                }
                60 => {
                    pdu_session_resource_list_cxt_rel_cpl =
                        Some(PduSessionResourceListCxtRelCpl::decode(data)?);
                }
                19 => {
                    criticality_diagnostics = Some(CriticalityDiagnostics::decode(data)?);
                }
                207 => {
                    paging_assis_datafor_c_ecapab_ue =
                        Some(PagingAssisDataforCEcapabUe::decode(data)?);
                }
                x => {
                    if let Criticality::Reject = criticality {
                        return Err(aper::AperCodecError::new(format!(
                            "Unrecognised IE type {} with criticality reject",
                            x
                        )));
                    }
                }
            }
        }
        let amf_ue_ngap_id = amf_ue_ngap_id.ok_or(aper::AperCodecError::new(format!(
            "Missing mandatory IE amf_ue_ngap_id"
        )))?;
        let ran_ue_ngap_id = ran_ue_ngap_id.ok_or(aper::AperCodecError::new(format!(
            "Missing mandatory IE ran_ue_ngap_id"
        )))?;
        Ok(Self {
            amf_ue_ngap_id,
            ran_ue_ngap_id,
            user_location_information,
            info_on_recommended_cells_and_ran_nodes_for_paging,
            pdu_session_resource_list_cxt_rel_cpl,
            criticality_diagnostics,
            paging_assis_datafor_c_ecapab_ue,
        })
    }
}

// UeContextResumeRequest
#[derive(Clone)]
pub struct UeContextResumeRequest {
    pub amf_ue_ngap_id: AmfUeNgapId,
    pub ran_ue_ngap_id: RanUeNgapId,
    pub rrc_resume_cause: RrcEstablishmentCause,
    pub pdu_session_resource_resume_list_res_req: Option<PduSessionResourceResumeListResReq>,
    pub pdu_session_resource_failed_to_resume_list_res_req:
        Option<PduSessionResourceFailedToResumeListResReq>,
    pub suspend_request_indication: Option<SuspendRequestIndication>,
    pub info_on_recommended_cells_and_ran_nodes_for_paging:
        Option<InfoOnRecommendedCellsAndRanNodesForPaging>,
    pub paging_assis_datafor_c_ecapab_ue: Option<PagingAssisDataforCEcapabUe>,
}

impl AperCodec for UeContextResumeRequest {
    type Output = UeContextResumeRequest;
    fn decode(data: &mut AperCodecData) -> Result<Self::Output, AperCodecError> {
        let _length = aper::decode::decode_length_determinent(data, None, None, false)?;
        let _ = aper::decode::decode_sequence_header(data, true, 0)?;
        let len = aper::decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut amf_ue_ngap_id: Option<AmfUeNgapId> = None;
        let mut ran_ue_ngap_id: Option<RanUeNgapId> = None;
        let mut rrc_resume_cause: Option<RrcEstablishmentCause> = None;
        let mut pdu_session_resource_resume_list_res_req: Option<
            PduSessionResourceResumeListResReq,
        > = None;
        let mut pdu_session_resource_failed_to_resume_list_res_req: Option<
            PduSessionResourceFailedToResumeListResReq,
        > = None;
        let mut suspend_request_indication: Option<SuspendRequestIndication> = None;
        let mut info_on_recommended_cells_and_ran_nodes_for_paging: Option<
            InfoOnRecommendedCellsAndRanNodesForPaging,
        > = None;
        let mut paging_assis_datafor_c_ecapab_ue: Option<PagingAssisDataforCEcapabUe> = None;

        for _ in 0..len {
            let (id, _ext) = aper::decode::decode_integer(data, Some(0), Some(65535), false)?;
            let criticality = Criticality::decode(data)?;
            let _length = aper::decode::decode_length_determinent(data, None, None, false)?;
            match id {
                10 => {
                    amf_ue_ngap_id = Some(AmfUeNgapId::decode(data)?);
                }
                85 => {
                    ran_ue_ngap_id = Some(RanUeNgapId::decode(data)?);
                }
                237 => {
                    rrc_resume_cause = Some(RrcEstablishmentCause::decode(data)?);
                }
                232 => {
                    pdu_session_resource_resume_list_res_req =
                        Some(PduSessionResourceResumeListResReq::decode(data)?);
                }
                229 => {
                    pdu_session_resource_failed_to_resume_list_res_req =
                        Some(PduSessionResourceFailedToResumeListResReq::decode(data)?);
                }
                235 => {
                    suspend_request_indication = Some(SuspendRequestIndication::decode(data)?);
                }
                32 => {
                    info_on_recommended_cells_and_ran_nodes_for_paging =
                        Some(InfoOnRecommendedCellsAndRanNodesForPaging::decode(data)?);
                }
                207 => {
                    paging_assis_datafor_c_ecapab_ue =
                        Some(PagingAssisDataforCEcapabUe::decode(data)?);
                }
                x => {
                    if let Criticality::Reject = criticality {
                        return Err(aper::AperCodecError::new(format!(
                            "Unrecognised IE type {} with criticality reject",
                            x
                        )));
                    }
                }
            }
        }
        let amf_ue_ngap_id = amf_ue_ngap_id.ok_or(aper::AperCodecError::new(format!(
            "Missing mandatory IE amf_ue_ngap_id"
        )))?;
        let ran_ue_ngap_id = ran_ue_ngap_id.ok_or(aper::AperCodecError::new(format!(
            "Missing mandatory IE ran_ue_ngap_id"
        )))?;
        let rrc_resume_cause = rrc_resume_cause.ok_or(aper::AperCodecError::new(format!(
            "Missing mandatory IE rrc_resume_cause"
        )))?;
        Ok(Self {
            amf_ue_ngap_id,
            ran_ue_ngap_id,
            rrc_resume_cause,
            pdu_session_resource_resume_list_res_req,
            pdu_session_resource_failed_to_resume_list_res_req,
            suspend_request_indication,
            info_on_recommended_cells_and_ran_nodes_for_paging,
            paging_assis_datafor_c_ecapab_ue,
        })
    }
}

// UeContextResumeResponse
#[derive(Clone)]
pub struct UeContextResumeResponse {
    pub amf_ue_ngap_id: AmfUeNgapId,
    pub ran_ue_ngap_id: RanUeNgapId,
    pub pdu_session_resource_resume_list_res_res: Option<PduSessionResourceResumeListResRes>,
    pub pdu_session_resource_failed_to_resume_list_res_res:
        Option<PduSessionResourceFailedToResumeListResRes>,
    pub security_context: Option<SecurityContext>,
    pub suspend_response_indication: Option<SuspendResponseIndication>,
    pub extended_connected_time: Option<ExtendedConnectedTime>,
    pub criticality_diagnostics: Option<CriticalityDiagnostics>,
}

impl AperCodec for UeContextResumeResponse {
    type Output = UeContextResumeResponse;
    fn decode(data: &mut AperCodecData) -> Result<Self::Output, AperCodecError> {
        let _length = aper::decode::decode_length_determinent(data, None, None, false)?;
        let _ = aper::decode::decode_sequence_header(data, true, 0)?;
        let len = aper::decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut amf_ue_ngap_id: Option<AmfUeNgapId> = None;
        let mut ran_ue_ngap_id: Option<RanUeNgapId> = None;
        let mut pdu_session_resource_resume_list_res_res: Option<
            PduSessionResourceResumeListResRes,
        > = None;
        let mut pdu_session_resource_failed_to_resume_list_res_res: Option<
            PduSessionResourceFailedToResumeListResRes,
        > = None;
        let mut security_context: Option<SecurityContext> = None;
        let mut suspend_response_indication: Option<SuspendResponseIndication> = None;
        let mut extended_connected_time: Option<ExtendedConnectedTime> = None;
        let mut criticality_diagnostics: Option<CriticalityDiagnostics> = None;

        for _ in 0..len {
            let (id, _ext) = aper::decode::decode_integer(data, Some(0), Some(65535), false)?;
            let criticality = Criticality::decode(data)?;
            let _length = aper::decode::decode_length_determinent(data, None, None, false)?;
            match id {
                10 => {
                    amf_ue_ngap_id = Some(AmfUeNgapId::decode(data)?);
                }
                85 => {
                    ran_ue_ngap_id = Some(RanUeNgapId::decode(data)?);
                }
                233 => {
                    pdu_session_resource_resume_list_res_res =
                        Some(PduSessionResourceResumeListResRes::decode(data)?);
                }
                230 => {
                    pdu_session_resource_failed_to_resume_list_res_res =
                        Some(PduSessionResourceFailedToResumeListResRes::decode(data)?);
                }
                93 => {
                    security_context = Some(SecurityContext::decode(data)?);
                }
                236 => {
                    suspend_response_indication = Some(SuspendResponseIndication::decode(data)?);
                }
                206 => {
                    extended_connected_time = Some(ExtendedConnectedTime::decode(data)?);
                }
                19 => {
                    criticality_diagnostics = Some(CriticalityDiagnostics::decode(data)?);
                }
                x => {
                    if let Criticality::Reject = criticality {
                        return Err(aper::AperCodecError::new(format!(
                            "Unrecognised IE type {} with criticality reject",
                            x
                        )));
                    }
                }
            }
        }
        let amf_ue_ngap_id = amf_ue_ngap_id.ok_or(aper::AperCodecError::new(format!(
            "Missing mandatory IE amf_ue_ngap_id"
        )))?;
        let ran_ue_ngap_id = ran_ue_ngap_id.ok_or(aper::AperCodecError::new(format!(
            "Missing mandatory IE ran_ue_ngap_id"
        )))?;
        Ok(Self {
            amf_ue_ngap_id,
            ran_ue_ngap_id,
            pdu_session_resource_resume_list_res_res,
            pdu_session_resource_failed_to_resume_list_res_res,
            security_context,
            suspend_response_indication,
            extended_connected_time,
            criticality_diagnostics,
        })
    }
}

// UeContextResumeFailure
#[derive(Clone)]
pub struct UeContextResumeFailure {
    pub amf_ue_ngap_id: AmfUeNgapId,
    pub ran_ue_ngap_id: RanUeNgapId,
    pub cause: Cause,
    pub criticality_diagnostics: Option<CriticalityDiagnostics>,
}

impl AperCodec for UeContextResumeFailure {
    type Output = UeContextResumeFailure;
    fn decode(data: &mut AperCodecData) -> Result<Self::Output, AperCodecError> {
        let _length = aper::decode::decode_length_determinent(data, None, None, false)?;
        let _ = aper::decode::decode_sequence_header(data, true, 0)?;
        let len = aper::decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut amf_ue_ngap_id: Option<AmfUeNgapId> = None;
        let mut ran_ue_ngap_id: Option<RanUeNgapId> = None;
        let mut cause: Option<Cause> = None;
        let mut criticality_diagnostics: Option<CriticalityDiagnostics> = None;

        for _ in 0..len {
            let (id, _ext) = aper::decode::decode_integer(data, Some(0), Some(65535), false)?;
            let criticality = Criticality::decode(data)?;
            let _length = aper::decode::decode_length_determinent(data, None, None, false)?;
            match id {
                10 => {
                    amf_ue_ngap_id = Some(AmfUeNgapId::decode(data)?);
                }
                85 => {
                    ran_ue_ngap_id = Some(RanUeNgapId::decode(data)?);
                }
                15 => {
                    cause = Some(Cause::decode(data)?);
                }
                19 => {
                    criticality_diagnostics = Some(CriticalityDiagnostics::decode(data)?);
                }
                x => {
                    if let Criticality::Reject = criticality {
                        return Err(aper::AperCodecError::new(format!(
                            "Unrecognised IE type {} with criticality reject",
                            x
                        )));
                    }
                }
            }
        }
        let amf_ue_ngap_id = amf_ue_ngap_id.ok_or(aper::AperCodecError::new(format!(
            "Missing mandatory IE amf_ue_ngap_id"
        )))?;
        let ran_ue_ngap_id = ran_ue_ngap_id.ok_or(aper::AperCodecError::new(format!(
            "Missing mandatory IE ran_ue_ngap_id"
        )))?;
        let cause = cause.ok_or(aper::AperCodecError::new(format!(
            "Missing mandatory IE cause"
        )))?;
        Ok(Self {
            amf_ue_ngap_id,
            ran_ue_ngap_id,
            cause,
            criticality_diagnostics,
        })
    }
}

// UeContextSuspendRequest
#[derive(Clone)]
pub struct UeContextSuspendRequest {
    pub amf_ue_ngap_id: AmfUeNgapId,
    pub ran_ue_ngap_id: RanUeNgapId,
    pub info_on_recommended_cells_and_ran_nodes_for_paging:
        Option<InfoOnRecommendedCellsAndRanNodesForPaging>,
    pub paging_assis_datafor_c_ecapab_ue: Option<PagingAssisDataforCEcapabUe>,
    pub pdu_session_resource_suspend_list_sus_req: Option<PduSessionResourceSuspendListSusReq>,
}

impl AperCodec for UeContextSuspendRequest {
    type Output = UeContextSuspendRequest;
    fn decode(data: &mut AperCodecData) -> Result<Self::Output, AperCodecError> {
        let _length = aper::decode::decode_length_determinent(data, None, None, false)?;
        let _ = aper::decode::decode_sequence_header(data, true, 0)?;
        let len = aper::decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut amf_ue_ngap_id: Option<AmfUeNgapId> = None;
        let mut ran_ue_ngap_id: Option<RanUeNgapId> = None;
        let mut info_on_recommended_cells_and_ran_nodes_for_paging: Option<
            InfoOnRecommendedCellsAndRanNodesForPaging,
        > = None;
        let mut paging_assis_datafor_c_ecapab_ue: Option<PagingAssisDataforCEcapabUe> = None;
        let mut pdu_session_resource_suspend_list_sus_req: Option<
            PduSessionResourceSuspendListSusReq,
        > = None;

        for _ in 0..len {
            let (id, _ext) = aper::decode::decode_integer(data, Some(0), Some(65535), false)?;
            let criticality = Criticality::decode(data)?;
            let _length = aper::decode::decode_length_determinent(data, None, None, false)?;
            match id {
                10 => {
                    amf_ue_ngap_id = Some(AmfUeNgapId::decode(data)?);
                }
                85 => {
                    ran_ue_ngap_id = Some(RanUeNgapId::decode(data)?);
                }
                32 => {
                    info_on_recommended_cells_and_ran_nodes_for_paging =
                        Some(InfoOnRecommendedCellsAndRanNodesForPaging::decode(data)?);
                }
                207 => {
                    paging_assis_datafor_c_ecapab_ue =
                        Some(PagingAssisDataforCEcapabUe::decode(data)?);
                }
                231 => {
                    pdu_session_resource_suspend_list_sus_req =
                        Some(PduSessionResourceSuspendListSusReq::decode(data)?);
                }
                x => {
                    if let Criticality::Reject = criticality {
                        return Err(aper::AperCodecError::new(format!(
                            "Unrecognised IE type {} with criticality reject",
                            x
                        )));
                    }
                }
            }
        }
        let amf_ue_ngap_id = amf_ue_ngap_id.ok_or(aper::AperCodecError::new(format!(
            "Missing mandatory IE amf_ue_ngap_id"
        )))?;
        let ran_ue_ngap_id = ran_ue_ngap_id.ok_or(aper::AperCodecError::new(format!(
            "Missing mandatory IE ran_ue_ngap_id"
        )))?;
        Ok(Self {
            amf_ue_ngap_id,
            ran_ue_ngap_id,
            info_on_recommended_cells_and_ran_nodes_for_paging,
            paging_assis_datafor_c_ecapab_ue,
            pdu_session_resource_suspend_list_sus_req,
        })
    }
}

// UeContextSuspendResponse
#[derive(Clone)]
pub struct UeContextSuspendResponse {
    pub amf_ue_ngap_id: AmfUeNgapId,
    pub ran_ue_ngap_id: RanUeNgapId,
    pub security_context: Option<SecurityContext>,
    pub criticality_diagnostics: Option<CriticalityDiagnostics>,
}

impl AperCodec for UeContextSuspendResponse {
    type Output = UeContextSuspendResponse;
    fn decode(data: &mut AperCodecData) -> Result<Self::Output, AperCodecError> {
        let _length = aper::decode::decode_length_determinent(data, None, None, false)?;
        let _ = aper::decode::decode_sequence_header(data, true, 0)?;
        let len = aper::decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut amf_ue_ngap_id: Option<AmfUeNgapId> = None;
        let mut ran_ue_ngap_id: Option<RanUeNgapId> = None;
        let mut security_context: Option<SecurityContext> = None;
        let mut criticality_diagnostics: Option<CriticalityDiagnostics> = None;

        for _ in 0..len {
            let (id, _ext) = aper::decode::decode_integer(data, Some(0), Some(65535), false)?;
            let criticality = Criticality::decode(data)?;
            let _length = aper::decode::decode_length_determinent(data, None, None, false)?;
            match id {
                10 => {
                    amf_ue_ngap_id = Some(AmfUeNgapId::decode(data)?);
                }
                85 => {
                    ran_ue_ngap_id = Some(RanUeNgapId::decode(data)?);
                }
                93 => {
                    security_context = Some(SecurityContext::decode(data)?);
                }
                19 => {
                    criticality_diagnostics = Some(CriticalityDiagnostics::decode(data)?);
                }
                x => {
                    if let Criticality::Reject = criticality {
                        return Err(aper::AperCodecError::new(format!(
                            "Unrecognised IE type {} with criticality reject",
                            x
                        )));
                    }
                }
            }
        }
        let amf_ue_ngap_id = amf_ue_ngap_id.ok_or(aper::AperCodecError::new(format!(
            "Missing mandatory IE amf_ue_ngap_id"
        )))?;
        let ran_ue_ngap_id = ran_ue_ngap_id.ok_or(aper::AperCodecError::new(format!(
            "Missing mandatory IE ran_ue_ngap_id"
        )))?;
        Ok(Self {
            amf_ue_ngap_id,
            ran_ue_ngap_id,
            security_context,
            criticality_diagnostics,
        })
    }
}

// UeContextSuspendFailure
#[derive(Clone)]
pub struct UeContextSuspendFailure {
    pub amf_ue_ngap_id: AmfUeNgapId,
    pub ran_ue_ngap_id: RanUeNgapId,
    pub cause: Cause,
    pub criticality_diagnostics: Option<CriticalityDiagnostics>,
}

impl AperCodec for UeContextSuspendFailure {
    type Output = UeContextSuspendFailure;
    fn decode(data: &mut AperCodecData) -> Result<Self::Output, AperCodecError> {
        let _length = aper::decode::decode_length_determinent(data, None, None, false)?;
        let _ = aper::decode::decode_sequence_header(data, true, 0)?;
        let len = aper::decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut amf_ue_ngap_id: Option<AmfUeNgapId> = None;
        let mut ran_ue_ngap_id: Option<RanUeNgapId> = None;
        let mut cause: Option<Cause> = None;
        let mut criticality_diagnostics: Option<CriticalityDiagnostics> = None;

        for _ in 0..len {
            let (id, _ext) = aper::decode::decode_integer(data, Some(0), Some(65535), false)?;
            let criticality = Criticality::decode(data)?;
            let _length = aper::decode::decode_length_determinent(data, None, None, false)?;
            match id {
                10 => {
                    amf_ue_ngap_id = Some(AmfUeNgapId::decode(data)?);
                }
                85 => {
                    ran_ue_ngap_id = Some(RanUeNgapId::decode(data)?);
                }
                15 => {
                    cause = Some(Cause::decode(data)?);
                }
                19 => {
                    criticality_diagnostics = Some(CriticalityDiagnostics::decode(data)?);
                }
                x => {
                    if let Criticality::Reject = criticality {
                        return Err(aper::AperCodecError::new(format!(
                            "Unrecognised IE type {} with criticality reject",
                            x
                        )));
                    }
                }
            }
        }
        let amf_ue_ngap_id = amf_ue_ngap_id.ok_or(aper::AperCodecError::new(format!(
            "Missing mandatory IE amf_ue_ngap_id"
        )))?;
        let ran_ue_ngap_id = ran_ue_ngap_id.ok_or(aper::AperCodecError::new(format!(
            "Missing mandatory IE ran_ue_ngap_id"
        )))?;
        let cause = cause.ok_or(aper::AperCodecError::new(format!(
            "Missing mandatory IE cause"
        )))?;
        Ok(Self {
            amf_ue_ngap_id,
            ran_ue_ngap_id,
            cause,
            criticality_diagnostics,
        })
    }
}

// UeContextModificationRequest
#[derive(Clone)]
pub struct UeContextModificationRequest {
    pub amf_ue_ngap_id: AmfUeNgapId,
    pub ran_ue_ngap_id: RanUeNgapId,
    pub ran_paging_priority: Option<RanPagingPriority>,
    pub security_key: Option<SecurityKey>,
    pub index_to_rfsp: Option<IndexToRfsp>,
    pub ue_aggregate_maximum_bit_rate: Option<UeAggregateMaximumBitRate>,
    pub ue_security_capabilities: Option<UeSecurityCapabilities>,
    pub core_network_assistance_information_for_inactive:
        Option<CoreNetworkAssistanceInformationForInactive>,
    pub emergency_fallback_indicator: Option<EmergencyFallbackIndicator>,
    pub new_amf_ue_ngap_id: Option<AmfUeNgapId>,
    pub rrc_inactive_transition_report_request: Option<RrcInactiveTransitionReportRequest>,
    pub new_guami: Option<Guami>,
    pub cn_assisted_ran_tuning: Option<CnAssistedRanTuning>,
    pub srvcc_operation_possible: Option<SrvccOperationPossible>,
    pub iab_authorized: Option<IabAuthorized>,
    pub nrv2x_services_authorized: Option<Nrv2xServicesAuthorized>,
    pub ltev2x_services_authorized: Option<Ltev2xServicesAuthorized>,
    pub nrue_sidelink_aggregate_maximum_bitrate: Option<NrueSidelinkAggregateMaximumBitrate>,
    pub lteue_sidelink_aggregate_maximum_bitrate: Option<LteueSidelinkAggregateMaximumBitrate>,
    pub pc5_qos_parameters: Option<Pc5QosParameters>,
    pub ue_radio_capability_id: Option<UeRadioCapabilityId>,
    pub rg_level_wireline_access_characteristics: Option<RgLevelWirelineAccessCharacteristics>,
}

impl AperCodec for UeContextModificationRequest {
    type Output = UeContextModificationRequest;
    fn decode(data: &mut AperCodecData) -> Result<Self::Output, AperCodecError> {
        let _length = aper::decode::decode_length_determinent(data, None, None, false)?;
        let _ = aper::decode::decode_sequence_header(data, true, 0)?;
        let len = aper::decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut amf_ue_ngap_id: Option<AmfUeNgapId> = None;
        let mut ran_ue_ngap_id: Option<RanUeNgapId> = None;
        let mut ran_paging_priority: Option<RanPagingPriority> = None;
        let mut security_key: Option<SecurityKey> = None;
        let mut index_to_rfsp: Option<IndexToRfsp> = None;
        let mut ue_aggregate_maximum_bit_rate: Option<UeAggregateMaximumBitRate> = None;
        let mut ue_security_capabilities: Option<UeSecurityCapabilities> = None;
        let mut core_network_assistance_information_for_inactive: Option<
            CoreNetworkAssistanceInformationForInactive,
        > = None;
        let mut emergency_fallback_indicator: Option<EmergencyFallbackIndicator> = None;
        let mut new_amf_ue_ngap_id: Option<AmfUeNgapId> = None;
        let mut rrc_inactive_transition_report_request: Option<RrcInactiveTransitionReportRequest> =
            None;
        let mut new_guami: Option<Guami> = None;
        let mut cn_assisted_ran_tuning: Option<CnAssistedRanTuning> = None;
        let mut srvcc_operation_possible: Option<SrvccOperationPossible> = None;
        let mut iab_authorized: Option<IabAuthorized> = None;
        let mut nrv2x_services_authorized: Option<Nrv2xServicesAuthorized> = None;
        let mut ltev2x_services_authorized: Option<Ltev2xServicesAuthorized> = None;
        let mut nrue_sidelink_aggregate_maximum_bitrate: Option<
            NrueSidelinkAggregateMaximumBitrate,
        > = None;
        let mut lteue_sidelink_aggregate_maximum_bitrate: Option<
            LteueSidelinkAggregateMaximumBitrate,
        > = None;
        let mut pc5_qos_parameters: Option<Pc5QosParameters> = None;
        let mut ue_radio_capability_id: Option<UeRadioCapabilityId> = None;
        let mut rg_level_wireline_access_characteristics: Option<
            RgLevelWirelineAccessCharacteristics,
        > = None;

        for _ in 0..len {
            let (id, _ext) = aper::decode::decode_integer(data, Some(0), Some(65535), false)?;
            let criticality = Criticality::decode(data)?;
            let _length = aper::decode::decode_length_determinent(data, None, None, false)?;
            match id {
                10 => {
                    amf_ue_ngap_id = Some(AmfUeNgapId::decode(data)?);
                }
                85 => {
                    ran_ue_ngap_id = Some(RanUeNgapId::decode(data)?);
                }
                83 => {
                    ran_paging_priority = Some(RanPagingPriority::decode(data)?);
                }
                94 => {
                    security_key = Some(SecurityKey::decode(data)?);
                }
                31 => {
                    index_to_rfsp = Some(IndexToRfsp::decode(data)?);
                }
                110 => {
                    ue_aggregate_maximum_bit_rate = Some(UeAggregateMaximumBitRate::decode(data)?);
                }
                119 => {
                    ue_security_capabilities = Some(UeSecurityCapabilities::decode(data)?);
                }
                18 => {
                    core_network_assistance_information_for_inactive =
                        Some(CoreNetworkAssistanceInformationForInactive::decode(data)?);
                }
                24 => {
                    emergency_fallback_indicator = Some(EmergencyFallbackIndicator::decode(data)?);
                }
                40 => {
                    new_amf_ue_ngap_id = Some(AmfUeNgapId::decode(data)?);
                }
                91 => {
                    rrc_inactive_transition_report_request =
                        Some(RrcInactiveTransitionReportRequest::decode(data)?);
                }
                162 => {
                    new_guami = Some(Guami::decode(data)?);
                }
                165 => {
                    cn_assisted_ran_tuning = Some(CnAssistedRanTuning::decode(data)?);
                }
                177 => {
                    srvcc_operation_possible = Some(SrvccOperationPossible::decode(data)?);
                }
                199 => {
                    iab_authorized = Some(IabAuthorized::decode(data)?);
                }
                216 => {
                    nrv2x_services_authorized = Some(Nrv2xServicesAuthorized::decode(data)?);
                }
                215 => {
                    ltev2x_services_authorized = Some(Ltev2xServicesAuthorized::decode(data)?);
                }
                218 => {
                    nrue_sidelink_aggregate_maximum_bitrate =
                        Some(NrueSidelinkAggregateMaximumBitrate::decode(data)?);
                }
                217 => {
                    lteue_sidelink_aggregate_maximum_bitrate =
                        Some(LteueSidelinkAggregateMaximumBitrate::decode(data)?);
                }
                219 => {
                    pc5_qos_parameters = Some(Pc5QosParameters::decode(data)?);
                }
                264 => {
                    ue_radio_capability_id = Some(UeRadioCapabilityId::decode(data)?);
                }
                238 => {
                    rg_level_wireline_access_characteristics =
                        Some(RgLevelWirelineAccessCharacteristics::decode(data)?);
                }
                x => {
                    if let Criticality::Reject = criticality {
                        return Err(aper::AperCodecError::new(format!(
                            "Unrecognised IE type {} with criticality reject",
                            x
                        )));
                    }
                }
            }
        }
        let amf_ue_ngap_id = amf_ue_ngap_id.ok_or(aper::AperCodecError::new(format!(
            "Missing mandatory IE amf_ue_ngap_id"
        )))?;
        let ran_ue_ngap_id = ran_ue_ngap_id.ok_or(aper::AperCodecError::new(format!(
            "Missing mandatory IE ran_ue_ngap_id"
        )))?;
        Ok(Self {
            amf_ue_ngap_id,
            ran_ue_ngap_id,
            ran_paging_priority,
            security_key,
            index_to_rfsp,
            ue_aggregate_maximum_bit_rate,
            ue_security_capabilities,
            core_network_assistance_information_for_inactive,
            emergency_fallback_indicator,
            new_amf_ue_ngap_id,
            rrc_inactive_transition_report_request,
            new_guami,
            cn_assisted_ran_tuning,
            srvcc_operation_possible,
            iab_authorized,
            nrv2x_services_authorized,
            ltev2x_services_authorized,
            nrue_sidelink_aggregate_maximum_bitrate,
            lteue_sidelink_aggregate_maximum_bitrate,
            pc5_qos_parameters,
            ue_radio_capability_id,
            rg_level_wireline_access_characteristics,
        })
    }
}

// UeContextModificationResponse
#[derive(Clone)]
pub struct UeContextModificationResponse {
    pub amf_ue_ngap_id: AmfUeNgapId,
    pub ran_ue_ngap_id: RanUeNgapId,
    pub rrc_state: Option<RrcState>,
    pub user_location_information: Option<UserLocationInformation>,
    pub criticality_diagnostics: Option<CriticalityDiagnostics>,
}

impl AperCodec for UeContextModificationResponse {
    type Output = UeContextModificationResponse;
    fn decode(data: &mut AperCodecData) -> Result<Self::Output, AperCodecError> {
        let _length = aper::decode::decode_length_determinent(data, None, None, false)?;
        let _ = aper::decode::decode_sequence_header(data, true, 0)?;
        let len = aper::decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut amf_ue_ngap_id: Option<AmfUeNgapId> = None;
        let mut ran_ue_ngap_id: Option<RanUeNgapId> = None;
        let mut rrc_state: Option<RrcState> = None;
        let mut user_location_information: Option<UserLocationInformation> = None;
        let mut criticality_diagnostics: Option<CriticalityDiagnostics> = None;

        for _ in 0..len {
            let (id, _ext) = aper::decode::decode_integer(data, Some(0), Some(65535), false)?;
            let criticality = Criticality::decode(data)?;
            let _length = aper::decode::decode_length_determinent(data, None, None, false)?;
            match id {
                10 => {
                    amf_ue_ngap_id = Some(AmfUeNgapId::decode(data)?);
                }
                85 => {
                    ran_ue_ngap_id = Some(RanUeNgapId::decode(data)?);
                }
                92 => {
                    rrc_state = Some(RrcState::decode(data)?);
                }
                121 => {
                    user_location_information = Some(UserLocationInformation::decode(data)?);
                }
                19 => {
                    criticality_diagnostics = Some(CriticalityDiagnostics::decode(data)?);
                }
                x => {
                    if let Criticality::Reject = criticality {
                        return Err(aper::AperCodecError::new(format!(
                            "Unrecognised IE type {} with criticality reject",
                            x
                        )));
                    }
                }
            }
        }
        let amf_ue_ngap_id = amf_ue_ngap_id.ok_or(aper::AperCodecError::new(format!(
            "Missing mandatory IE amf_ue_ngap_id"
        )))?;
        let ran_ue_ngap_id = ran_ue_ngap_id.ok_or(aper::AperCodecError::new(format!(
            "Missing mandatory IE ran_ue_ngap_id"
        )))?;
        Ok(Self {
            amf_ue_ngap_id,
            ran_ue_ngap_id,
            rrc_state,
            user_location_information,
            criticality_diagnostics,
        })
    }
}

// UeContextModificationFailure
#[derive(Clone)]
pub struct UeContextModificationFailure {
    pub amf_ue_ngap_id: AmfUeNgapId,
    pub ran_ue_ngap_id: RanUeNgapId,
    pub cause: Cause,
    pub criticality_diagnostics: Option<CriticalityDiagnostics>,
}

impl AperCodec for UeContextModificationFailure {
    type Output = UeContextModificationFailure;
    fn decode(data: &mut AperCodecData) -> Result<Self::Output, AperCodecError> {
        let _length = aper::decode::decode_length_determinent(data, None, None, false)?;
        let _ = aper::decode::decode_sequence_header(data, true, 0)?;
        let len = aper::decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut amf_ue_ngap_id: Option<AmfUeNgapId> = None;
        let mut ran_ue_ngap_id: Option<RanUeNgapId> = None;
        let mut cause: Option<Cause> = None;
        let mut criticality_diagnostics: Option<CriticalityDiagnostics> = None;

        for _ in 0..len {
            let (id, _ext) = aper::decode::decode_integer(data, Some(0), Some(65535), false)?;
            let criticality = Criticality::decode(data)?;
            let _length = aper::decode::decode_length_determinent(data, None, None, false)?;
            match id {
                10 => {
                    amf_ue_ngap_id = Some(AmfUeNgapId::decode(data)?);
                }
                85 => {
                    ran_ue_ngap_id = Some(RanUeNgapId::decode(data)?);
                }
                15 => {
                    cause = Some(Cause::decode(data)?);
                }
                19 => {
                    criticality_diagnostics = Some(CriticalityDiagnostics::decode(data)?);
                }
                x => {
                    if let Criticality::Reject = criticality {
                        return Err(aper::AperCodecError::new(format!(
                            "Unrecognised IE type {} with criticality reject",
                            x
                        )));
                    }
                }
            }
        }
        let amf_ue_ngap_id = amf_ue_ngap_id.ok_or(aper::AperCodecError::new(format!(
            "Missing mandatory IE amf_ue_ngap_id"
        )))?;
        let ran_ue_ngap_id = ran_ue_ngap_id.ok_or(aper::AperCodecError::new(format!(
            "Missing mandatory IE ran_ue_ngap_id"
        )))?;
        let cause = cause.ok_or(aper::AperCodecError::new(format!(
            "Missing mandatory IE cause"
        )))?;
        Ok(Self {
            amf_ue_ngap_id,
            ran_ue_ngap_id,
            cause,
            criticality_diagnostics,
        })
    }
}

// RrcInactiveTransitionReport
#[derive(Clone)]
pub struct RrcInactiveTransitionReport {
    pub amf_ue_ngap_id: AmfUeNgapId,
    pub ran_ue_ngap_id: RanUeNgapId,
    pub rrc_state: RrcState,
    pub user_location_information: UserLocationInformation,
}

impl AperCodec for RrcInactiveTransitionReport {
    type Output = RrcInactiveTransitionReport;
    fn decode(data: &mut AperCodecData) -> Result<Self::Output, AperCodecError> {
        let _length = aper::decode::decode_length_determinent(data, None, None, false)?;
        let _ = aper::decode::decode_sequence_header(data, true, 0)?;
        let len = aper::decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut amf_ue_ngap_id: Option<AmfUeNgapId> = None;
        let mut ran_ue_ngap_id: Option<RanUeNgapId> = None;
        let mut rrc_state: Option<RrcState> = None;
        let mut user_location_information: Option<UserLocationInformation> = None;

        for _ in 0..len {
            let (id, _ext) = aper::decode::decode_integer(data, Some(0), Some(65535), false)?;
            let criticality = Criticality::decode(data)?;
            let _length = aper::decode::decode_length_determinent(data, None, None, false)?;
            match id {
                10 => {
                    amf_ue_ngap_id = Some(AmfUeNgapId::decode(data)?);
                }
                85 => {
                    ran_ue_ngap_id = Some(RanUeNgapId::decode(data)?);
                }
                92 => {
                    rrc_state = Some(RrcState::decode(data)?);
                }
                121 => {
                    user_location_information = Some(UserLocationInformation::decode(data)?);
                }
                x => {
                    if let Criticality::Reject = criticality {
                        return Err(aper::AperCodecError::new(format!(
                            "Unrecognised IE type {} with criticality reject",
                            x
                        )));
                    }
                }
            }
        }
        let amf_ue_ngap_id = amf_ue_ngap_id.ok_or(aper::AperCodecError::new(format!(
            "Missing mandatory IE amf_ue_ngap_id"
        )))?;
        let ran_ue_ngap_id = ran_ue_ngap_id.ok_or(aper::AperCodecError::new(format!(
            "Missing mandatory IE ran_ue_ngap_id"
        )))?;
        let rrc_state = rrc_state.ok_or(aper::AperCodecError::new(format!(
            "Missing mandatory IE rrc_state"
        )))?;
        let user_location_information = user_location_information.ok_or(
            aper::AperCodecError::new(format!("Missing mandatory IE user_location_information")),
        )?;
        Ok(Self {
            amf_ue_ngap_id,
            ran_ue_ngap_id,
            rrc_state,
            user_location_information,
        })
    }
}

// RetrieveUeInformation
#[derive(Clone)]
pub struct RetrieveUeInformation {
    pub five_g_s_tmsi: FiveGSTmsi,
}

impl AperCodec for RetrieveUeInformation {
    type Output = RetrieveUeInformation;
    fn decode(data: &mut AperCodecData) -> Result<Self::Output, AperCodecError> {
        let _length = aper::decode::decode_length_determinent(data, None, None, false)?;
        let _ = aper::decode::decode_sequence_header(data, true, 0)?;
        let len = aper::decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut five_g_s_tmsi: Option<FiveGSTmsi> = None;

        for _ in 0..len {
            let (id, _ext) = aper::decode::decode_integer(data, Some(0), Some(65535), false)?;
            let criticality = Criticality::decode(data)?;
            let _length = aper::decode::decode_length_determinent(data, None, None, false)?;
            match id {
                26 => {
                    five_g_s_tmsi = Some(FiveGSTmsi::decode(data)?);
                }
                x => {
                    if let Criticality::Reject = criticality {
                        return Err(aper::AperCodecError::new(format!(
                            "Unrecognised IE type {} with criticality reject",
                            x
                        )));
                    }
                }
            }
        }
        let five_g_s_tmsi = five_g_s_tmsi.ok_or(aper::AperCodecError::new(format!(
            "Missing mandatory IE five_g_s_tmsi"
        )))?;
        Ok(Self { five_g_s_tmsi })
    }
}

// UeInformationTransfer
#[derive(Clone)]
pub struct UeInformationTransfer {
    pub five_g_s_tmsi: FiveGSTmsi,
    pub nb_iot_ue_priority: Option<NbIotUePriority>,
    pub ue_radio_capability: Option<UeRadioCapability>,
    pub s_nssai: Option<SNssai>,
    pub allowed_nssai: Option<AllowedNssai>,
    pub ue_differentiation_info: Option<UeDifferentiationInfo>,
}

impl AperCodec for UeInformationTransfer {
    type Output = UeInformationTransfer;
    fn decode(data: &mut AperCodecData) -> Result<Self::Output, AperCodecError> {
        let _length = aper::decode::decode_length_determinent(data, None, None, false)?;
        let _ = aper::decode::decode_sequence_header(data, true, 0)?;
        let len = aper::decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut five_g_s_tmsi: Option<FiveGSTmsi> = None;
        let mut nb_iot_ue_priority: Option<NbIotUePriority> = None;
        let mut ue_radio_capability: Option<UeRadioCapability> = None;
        let mut s_nssai: Option<SNssai> = None;
        let mut allowed_nssai: Option<AllowedNssai> = None;
        let mut ue_differentiation_info: Option<UeDifferentiationInfo> = None;

        for _ in 0..len {
            let (id, _ext) = aper::decode::decode_integer(data, Some(0), Some(65535), false)?;
            let criticality = Criticality::decode(data)?;
            let _length = aper::decode::decode_length_determinent(data, None, None, false)?;
            match id {
                26 => {
                    five_g_s_tmsi = Some(FiveGSTmsi::decode(data)?);
                }
                210 => {
                    nb_iot_ue_priority = Some(NbIotUePriority::decode(data)?);
                }
                117 => {
                    ue_radio_capability = Some(UeRadioCapability::decode(data)?);
                }
                148 => {
                    s_nssai = Some(SNssai::decode(data)?);
                }
                0 => {
                    allowed_nssai = Some(AllowedNssai::decode(data)?);
                }
                209 => {
                    ue_differentiation_info = Some(UeDifferentiationInfo::decode(data)?);
                }
                x => {
                    if let Criticality::Reject = criticality {
                        return Err(aper::AperCodecError::new(format!(
                            "Unrecognised IE type {} with criticality reject",
                            x
                        )));
                    }
                }
            }
        }
        let five_g_s_tmsi = five_g_s_tmsi.ok_or(aper::AperCodecError::new(format!(
            "Missing mandatory IE five_g_s_tmsi"
        )))?;
        Ok(Self {
            five_g_s_tmsi,
            nb_iot_ue_priority,
            ue_radio_capability,
            s_nssai,
            allowed_nssai,
            ue_differentiation_info,
        })
    }
}

// RancpRelocationIndication
#[derive(Clone)]
pub struct RancpRelocationIndication {
    pub ran_ue_ngap_id: RanUeNgapId,
    pub five_g_s_tmsi: FiveGSTmsi,
    pub eutra_cgi: EutraCgi,
    pub tai: Tai,
    pub ul_cp_security_information: UlCpSecurityInformation,
}

impl AperCodec for RancpRelocationIndication {
    type Output = RancpRelocationIndication;
    fn decode(data: &mut AperCodecData) -> Result<Self::Output, AperCodecError> {
        let _length = aper::decode::decode_length_determinent(data, None, None, false)?;
        let _ = aper::decode::decode_sequence_header(data, true, 0)?;
        let len = aper::decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut ran_ue_ngap_id: Option<RanUeNgapId> = None;
        let mut five_g_s_tmsi: Option<FiveGSTmsi> = None;
        let mut eutra_cgi: Option<EutraCgi> = None;
        let mut tai: Option<Tai> = None;
        let mut ul_cp_security_information: Option<UlCpSecurityInformation> = None;

        for _ in 0..len {
            let (id, _ext) = aper::decode::decode_integer(data, Some(0), Some(65535), false)?;
            let criticality = Criticality::decode(data)?;
            let _length = aper::decode::decode_length_determinent(data, None, None, false)?;
            match id {
                85 => {
                    ran_ue_ngap_id = Some(RanUeNgapId::decode(data)?);
                }
                26 => {
                    five_g_s_tmsi = Some(FiveGSTmsi::decode(data)?);
                }
                25 => {
                    eutra_cgi = Some(EutraCgi::decode(data)?);
                }
                213 => {
                    tai = Some(Tai::decode(data)?);
                }
                211 => {
                    ul_cp_security_information = Some(UlCpSecurityInformation::decode(data)?);
                }
                x => {
                    if let Criticality::Reject = criticality {
                        return Err(aper::AperCodecError::new(format!(
                            "Unrecognised IE type {} with criticality reject",
                            x
                        )));
                    }
                }
            }
        }
        let ran_ue_ngap_id = ran_ue_ngap_id.ok_or(aper::AperCodecError::new(format!(
            "Missing mandatory IE ran_ue_ngap_id"
        )))?;
        let five_g_s_tmsi = five_g_s_tmsi.ok_or(aper::AperCodecError::new(format!(
            "Missing mandatory IE five_g_s_tmsi"
        )))?;
        let eutra_cgi = eutra_cgi.ok_or(aper::AperCodecError::new(format!(
            "Missing mandatory IE eutra_cgi"
        )))?;
        let tai = tai.ok_or(aper::AperCodecError::new(format!(
            "Missing mandatory IE tai"
        )))?;
        let ul_cp_security_information = ul_cp_security_information.ok_or(
            aper::AperCodecError::new(format!("Missing mandatory IE ul_cp_security_information")),
        )?;
        Ok(Self {
            ran_ue_ngap_id,
            five_g_s_tmsi,
            eutra_cgi,
            tai,
            ul_cp_security_information,
        })
    }
}

// HandoverRequired
#[derive(Clone)]
pub struct HandoverRequired {
    pub amf_ue_ngap_id: AmfUeNgapId,
    pub ran_ue_ngap_id: RanUeNgapId,
    pub handover_type: HandoverType,
    pub cause: Cause,
    pub target_id: TargetId,
    pub direct_forwarding_path_availability: Option<DirectForwardingPathAvailability>,
    pub pdu_session_resource_list_ho_rqd: PduSessionResourceListHoRqd,
    pub source_to_target_transparent_container: SourceToTargetTransparentContainer,
}

impl AperCodec for HandoverRequired {
    type Output = HandoverRequired;
    fn decode(data: &mut AperCodecData) -> Result<Self::Output, AperCodecError> {
        let _length = aper::decode::decode_length_determinent(data, None, None, false)?;
        let _ = aper::decode::decode_sequence_header(data, true, 0)?;
        let len = aper::decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut amf_ue_ngap_id: Option<AmfUeNgapId> = None;
        let mut ran_ue_ngap_id: Option<RanUeNgapId> = None;
        let mut handover_type: Option<HandoverType> = None;
        let mut cause: Option<Cause> = None;
        let mut target_id: Option<TargetId> = None;
        let mut direct_forwarding_path_availability: Option<DirectForwardingPathAvailability> =
            None;
        let mut pdu_session_resource_list_ho_rqd: Option<PduSessionResourceListHoRqd> = None;
        let mut source_to_target_transparent_container: Option<SourceToTargetTransparentContainer> =
            None;

        for _ in 0..len {
            let (id, _ext) = aper::decode::decode_integer(data, Some(0), Some(65535), false)?;
            let criticality = Criticality::decode(data)?;
            let _length = aper::decode::decode_length_determinent(data, None, None, false)?;
            match id {
                10 => {
                    amf_ue_ngap_id = Some(AmfUeNgapId::decode(data)?);
                }
                85 => {
                    ran_ue_ngap_id = Some(RanUeNgapId::decode(data)?);
                }
                29 => {
                    handover_type = Some(HandoverType::decode(data)?);
                }
                15 => {
                    cause = Some(Cause::decode(data)?);
                }
                105 => {
                    target_id = Some(TargetId::decode(data)?);
                }
                22 => {
                    direct_forwarding_path_availability =
                        Some(DirectForwardingPathAvailability::decode(data)?);
                }
                61 => {
                    pdu_session_resource_list_ho_rqd =
                        Some(PduSessionResourceListHoRqd::decode(data)?);
                }
                101 => {
                    source_to_target_transparent_container =
                        Some(SourceToTargetTransparentContainer::decode(data)?);
                }
                x => {
                    if let Criticality::Reject = criticality {
                        return Err(aper::AperCodecError::new(format!(
                            "Unrecognised IE type {} with criticality reject",
                            x
                        )));
                    }
                }
            }
        }
        let amf_ue_ngap_id = amf_ue_ngap_id.ok_or(aper::AperCodecError::new(format!(
            "Missing mandatory IE amf_ue_ngap_id"
        )))?;
        let ran_ue_ngap_id = ran_ue_ngap_id.ok_or(aper::AperCodecError::new(format!(
            "Missing mandatory IE ran_ue_ngap_id"
        )))?;
        let handover_type = handover_type.ok_or(aper::AperCodecError::new(format!(
            "Missing mandatory IE handover_type"
        )))?;
        let cause = cause.ok_or(aper::AperCodecError::new(format!(
            "Missing mandatory IE cause"
        )))?;
        let target_id = target_id.ok_or(aper::AperCodecError::new(format!(
            "Missing mandatory IE target_id"
        )))?;
        let pdu_session_resource_list_ho_rqd =
            pdu_session_resource_list_ho_rqd.ok_or(aper::AperCodecError::new(format!(
                "Missing mandatory IE pdu_session_resource_list_ho_rqd"
            )))?;
        let source_to_target_transparent_container =
            source_to_target_transparent_container.ok_or(aper::AperCodecError::new(format!(
                "Missing mandatory IE source_to_target_transparent_container"
            )))?;
        Ok(Self {
            amf_ue_ngap_id,
            ran_ue_ngap_id,
            handover_type,
            cause,
            target_id,
            direct_forwarding_path_availability,
            pdu_session_resource_list_ho_rqd,
            source_to_target_transparent_container,
        })
    }
}

// HandoverCommand
#[derive(Clone)]
pub struct HandoverCommand {
    pub amf_ue_ngap_id: AmfUeNgapId,
    pub ran_ue_ngap_id: RanUeNgapId,
    pub handover_type: HandoverType,
    pub nas_security_parameters_from_ngran: Option<NasSecurityParametersFromNgran>,
    pub pdu_session_resource_handover_list: Option<PduSessionResourceHandoverList>,
    pub pdu_session_resource_to_release_list_ho_cmd: Option<PduSessionResourceToReleaseListHoCmd>,
    pub target_to_source_transparent_container: TargetToSourceTransparentContainer,
    pub criticality_diagnostics: Option<CriticalityDiagnostics>,
}

impl AperCodec for HandoverCommand {
    type Output = HandoverCommand;
    fn decode(data: &mut AperCodecData) -> Result<Self::Output, AperCodecError> {
        let _length = aper::decode::decode_length_determinent(data, None, None, false)?;
        let _ = aper::decode::decode_sequence_header(data, true, 0)?;
        let len = aper::decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut amf_ue_ngap_id: Option<AmfUeNgapId> = None;
        let mut ran_ue_ngap_id: Option<RanUeNgapId> = None;
        let mut handover_type: Option<HandoverType> = None;
        let mut nas_security_parameters_from_ngran: Option<NasSecurityParametersFromNgran> = None;
        let mut pdu_session_resource_handover_list: Option<PduSessionResourceHandoverList> = None;
        let mut pdu_session_resource_to_release_list_ho_cmd: Option<
            PduSessionResourceToReleaseListHoCmd,
        > = None;
        let mut target_to_source_transparent_container: Option<TargetToSourceTransparentContainer> =
            None;
        let mut criticality_diagnostics: Option<CriticalityDiagnostics> = None;

        for _ in 0..len {
            let (id, _ext) = aper::decode::decode_integer(data, Some(0), Some(65535), false)?;
            let criticality = Criticality::decode(data)?;
            let _length = aper::decode::decode_length_determinent(data, None, None, false)?;
            match id {
                10 => {
                    amf_ue_ngap_id = Some(AmfUeNgapId::decode(data)?);
                }
                85 => {
                    ran_ue_ngap_id = Some(RanUeNgapId::decode(data)?);
                }
                29 => {
                    handover_type = Some(HandoverType::decode(data)?);
                }
                39 => {
                    nas_security_parameters_from_ngran =
                        Some(NasSecurityParametersFromNgran::decode(data)?);
                }
                59 => {
                    pdu_session_resource_handover_list =
                        Some(PduSessionResourceHandoverList::decode(data)?);
                }
                78 => {
                    pdu_session_resource_to_release_list_ho_cmd =
                        Some(PduSessionResourceToReleaseListHoCmd::decode(data)?);
                }
                106 => {
                    target_to_source_transparent_container =
                        Some(TargetToSourceTransparentContainer::decode(data)?);
                }
                19 => {
                    criticality_diagnostics = Some(CriticalityDiagnostics::decode(data)?);
                }
                x => {
                    if let Criticality::Reject = criticality {
                        return Err(aper::AperCodecError::new(format!(
                            "Unrecognised IE type {} with criticality reject",
                            x
                        )));
                    }
                }
            }
        }
        let amf_ue_ngap_id = amf_ue_ngap_id.ok_or(aper::AperCodecError::new(format!(
            "Missing mandatory IE amf_ue_ngap_id"
        )))?;
        let ran_ue_ngap_id = ran_ue_ngap_id.ok_or(aper::AperCodecError::new(format!(
            "Missing mandatory IE ran_ue_ngap_id"
        )))?;
        let handover_type = handover_type.ok_or(aper::AperCodecError::new(format!(
            "Missing mandatory IE handover_type"
        )))?;
        let target_to_source_transparent_container =
            target_to_source_transparent_container.ok_or(aper::AperCodecError::new(format!(
                "Missing mandatory IE target_to_source_transparent_container"
            )))?;
        Ok(Self {
            amf_ue_ngap_id,
            ran_ue_ngap_id,
            handover_type,
            nas_security_parameters_from_ngran,
            pdu_session_resource_handover_list,
            pdu_session_resource_to_release_list_ho_cmd,
            target_to_source_transparent_container,
            criticality_diagnostics,
        })
    }
}

// HandoverPreparationFailure
#[derive(Clone)]
pub struct HandoverPreparationFailure {
    pub amf_ue_ngap_id: AmfUeNgapId,
    pub ran_ue_ngap_id: RanUeNgapId,
    pub cause: Cause,
    pub criticality_diagnostics: Option<CriticalityDiagnostics>,
    pub targetto_source_failure_transparent_container:
        Option<TargettoSourceFailureTransparentContainer>,
}

impl AperCodec for HandoverPreparationFailure {
    type Output = HandoverPreparationFailure;
    fn decode(data: &mut AperCodecData) -> Result<Self::Output, AperCodecError> {
        let _length = aper::decode::decode_length_determinent(data, None, None, false)?;
        let _ = aper::decode::decode_sequence_header(data, true, 0)?;
        let len = aper::decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut amf_ue_ngap_id: Option<AmfUeNgapId> = None;
        let mut ran_ue_ngap_id: Option<RanUeNgapId> = None;
        let mut cause: Option<Cause> = None;
        let mut criticality_diagnostics: Option<CriticalityDiagnostics> = None;
        let mut targetto_source_failure_transparent_container: Option<
            TargettoSourceFailureTransparentContainer,
        > = None;

        for _ in 0..len {
            let (id, _ext) = aper::decode::decode_integer(data, Some(0), Some(65535), false)?;
            let criticality = Criticality::decode(data)?;
            let _length = aper::decode::decode_length_determinent(data, None, None, false)?;
            match id {
                10 => {
                    amf_ue_ngap_id = Some(AmfUeNgapId::decode(data)?);
                }
                85 => {
                    ran_ue_ngap_id = Some(RanUeNgapId::decode(data)?);
                }
                15 => {
                    cause = Some(Cause::decode(data)?);
                }
                19 => {
                    criticality_diagnostics = Some(CriticalityDiagnostics::decode(data)?);
                }
                262 => {
                    targetto_source_failure_transparent_container =
                        Some(TargettoSourceFailureTransparentContainer::decode(data)?);
                }
                x => {
                    if let Criticality::Reject = criticality {
                        return Err(aper::AperCodecError::new(format!(
                            "Unrecognised IE type {} with criticality reject",
                            x
                        )));
                    }
                }
            }
        }
        let amf_ue_ngap_id = amf_ue_ngap_id.ok_or(aper::AperCodecError::new(format!(
            "Missing mandatory IE amf_ue_ngap_id"
        )))?;
        let ran_ue_ngap_id = ran_ue_ngap_id.ok_or(aper::AperCodecError::new(format!(
            "Missing mandatory IE ran_ue_ngap_id"
        )))?;
        let cause = cause.ok_or(aper::AperCodecError::new(format!(
            "Missing mandatory IE cause"
        )))?;
        Ok(Self {
            amf_ue_ngap_id,
            ran_ue_ngap_id,
            cause,
            criticality_diagnostics,
            targetto_source_failure_transparent_container,
        })
    }
}

// HandoverRequest
#[derive(Clone)]
pub struct HandoverRequest {
    pub amf_ue_ngap_id: AmfUeNgapId,
    pub handover_type: HandoverType,
    pub cause: Cause,
    pub ue_aggregate_maximum_bit_rate: UeAggregateMaximumBitRate,
    pub core_network_assistance_information_for_inactive:
        Option<CoreNetworkAssistanceInformationForInactive>,
    pub ue_security_capabilities: UeSecurityCapabilities,
    pub security_context: SecurityContext,
    pub new_security_context_ind: Option<NewSecurityContextInd>,
    pub nasc: Option<NasPdu>,
    pub pdu_session_resource_setup_list_ho_req: PduSessionResourceSetupListHoReq,
    pub allowed_nssai: AllowedNssai,
    pub trace_activation: Option<TraceActivation>,
    pub masked_imeisv: Option<MaskedImeisv>,
    pub source_to_target_transparent_container: SourceToTargetTransparentContainer,
    pub mobility_restriction_list: Option<MobilityRestrictionList>,
    pub location_reporting_request_type: Option<LocationReportingRequestType>,
    pub rrc_inactive_transition_report_request: Option<RrcInactiveTransitionReportRequest>,
    pub guami: Guami,
    pub redirection_voice_fallback: Option<RedirectionVoiceFallback>,
    pub cn_assisted_ran_tuning: Option<CnAssistedRanTuning>,
    pub srvcc_operation_possible: Option<SrvccOperationPossible>,
    pub iab_authorized: Option<IabAuthorized>,
    pub enhanced_coverage_restriction: Option<EnhancedCoverageRestriction>,
    pub ue_differentiation_info: Option<UeDifferentiationInfo>,
    pub nrv2x_services_authorized: Option<Nrv2xServicesAuthorized>,
    pub ltev2x_services_authorized: Option<Ltev2xServicesAuthorized>,
    pub nrue_sidelink_aggregate_maximum_bitrate: Option<NrueSidelinkAggregateMaximumBitrate>,
    pub lteue_sidelink_aggregate_maximum_bitrate: Option<LteueSidelinkAggregateMaximumBitrate>,
    pub pc5_qos_parameters: Option<Pc5QosParameters>,
    pub c_emode_brestricted: Option<CEmodeBrestricted>,
    pub ue_up_c_iot_support: Option<UeUpCIotSupport>,
    pub management_based_mdt_plmn_list: Option<MdtPlmnList>,
    pub ue_radio_capability_id: Option<UeRadioCapabilityId>,
    pub extended_connected_time: Option<ExtendedConnectedTime>,
}

impl AperCodec for HandoverRequest {
    type Output = HandoverRequest;
    fn decode(data: &mut AperCodecData) -> Result<Self::Output, AperCodecError> {
        let _length = aper::decode::decode_length_determinent(data, None, None, false)?;
        let _ = aper::decode::decode_sequence_header(data, true, 0)?;
        let len = aper::decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut amf_ue_ngap_id: Option<AmfUeNgapId> = None;
        let mut handover_type: Option<HandoverType> = None;
        let mut cause: Option<Cause> = None;
        let mut ue_aggregate_maximum_bit_rate: Option<UeAggregateMaximumBitRate> = None;
        let mut core_network_assistance_information_for_inactive: Option<
            CoreNetworkAssistanceInformationForInactive,
        > = None;
        let mut ue_security_capabilities: Option<UeSecurityCapabilities> = None;
        let mut security_context: Option<SecurityContext> = None;
        let mut new_security_context_ind: Option<NewSecurityContextInd> = None;
        let mut nasc: Option<NasPdu> = None;
        let mut pdu_session_resource_setup_list_ho_req: Option<PduSessionResourceSetupListHoReq> =
            None;
        let mut allowed_nssai: Option<AllowedNssai> = None;
        let mut trace_activation: Option<TraceActivation> = None;
        let mut masked_imeisv: Option<MaskedImeisv> = None;
        let mut source_to_target_transparent_container: Option<SourceToTargetTransparentContainer> =
            None;
        let mut mobility_restriction_list: Option<MobilityRestrictionList> = None;
        let mut location_reporting_request_type: Option<LocationReportingRequestType> = None;
        let mut rrc_inactive_transition_report_request: Option<RrcInactiveTransitionReportRequest> =
            None;
        let mut guami: Option<Guami> = None;
        let mut redirection_voice_fallback: Option<RedirectionVoiceFallback> = None;
        let mut cn_assisted_ran_tuning: Option<CnAssistedRanTuning> = None;
        let mut srvcc_operation_possible: Option<SrvccOperationPossible> = None;
        let mut iab_authorized: Option<IabAuthorized> = None;
        let mut enhanced_coverage_restriction: Option<EnhancedCoverageRestriction> = None;
        let mut ue_differentiation_info: Option<UeDifferentiationInfo> = None;
        let mut nrv2x_services_authorized: Option<Nrv2xServicesAuthorized> = None;
        let mut ltev2x_services_authorized: Option<Ltev2xServicesAuthorized> = None;
        let mut nrue_sidelink_aggregate_maximum_bitrate: Option<
            NrueSidelinkAggregateMaximumBitrate,
        > = None;
        let mut lteue_sidelink_aggregate_maximum_bitrate: Option<
            LteueSidelinkAggregateMaximumBitrate,
        > = None;
        let mut pc5_qos_parameters: Option<Pc5QosParameters> = None;
        let mut c_emode_brestricted: Option<CEmodeBrestricted> = None;
        let mut ue_up_c_iot_support: Option<UeUpCIotSupport> = None;
        let mut management_based_mdt_plmn_list: Option<MdtPlmnList> = None;
        let mut ue_radio_capability_id: Option<UeRadioCapabilityId> = None;
        let mut extended_connected_time: Option<ExtendedConnectedTime> = None;

        for _ in 0..len {
            let (id, _ext) = aper::decode::decode_integer(data, Some(0), Some(65535), false)?;
            let criticality = Criticality::decode(data)?;
            let _length = aper::decode::decode_length_determinent(data, None, None, false)?;
            match id {
                10 => {
                    amf_ue_ngap_id = Some(AmfUeNgapId::decode(data)?);
                }
                29 => {
                    handover_type = Some(HandoverType::decode(data)?);
                }
                15 => {
                    cause = Some(Cause::decode(data)?);
                }
                110 => {
                    ue_aggregate_maximum_bit_rate = Some(UeAggregateMaximumBitRate::decode(data)?);
                }
                18 => {
                    core_network_assistance_information_for_inactive =
                        Some(CoreNetworkAssistanceInformationForInactive::decode(data)?);
                }
                119 => {
                    ue_security_capabilities = Some(UeSecurityCapabilities::decode(data)?);
                }
                93 => {
                    security_context = Some(SecurityContext::decode(data)?);
                }
                41 => {
                    new_security_context_ind = Some(NewSecurityContextInd::decode(data)?);
                }
                37 => {
                    nasc = Some(NasPdu::decode(data)?);
                }
                73 => {
                    pdu_session_resource_setup_list_ho_req =
                        Some(PduSessionResourceSetupListHoReq::decode(data)?);
                }
                0 => {
                    allowed_nssai = Some(AllowedNssai::decode(data)?);
                }
                108 => {
                    trace_activation = Some(TraceActivation::decode(data)?);
                }
                34 => {
                    masked_imeisv = Some(MaskedImeisv::decode(data)?);
                }
                101 => {
                    source_to_target_transparent_container =
                        Some(SourceToTargetTransparentContainer::decode(data)?);
                }
                36 => {
                    mobility_restriction_list = Some(MobilityRestrictionList::decode(data)?);
                }
                33 => {
                    location_reporting_request_type =
                        Some(LocationReportingRequestType::decode(data)?);
                }
                91 => {
                    rrc_inactive_transition_report_request =
                        Some(RrcInactiveTransitionReportRequest::decode(data)?);
                }
                28 => {
                    guami = Some(Guami::decode(data)?);
                }
                146 => {
                    redirection_voice_fallback = Some(RedirectionVoiceFallback::decode(data)?);
                }
                165 => {
                    cn_assisted_ran_tuning = Some(CnAssistedRanTuning::decode(data)?);
                }
                177 => {
                    srvcc_operation_possible = Some(SrvccOperationPossible::decode(data)?);
                }
                199 => {
                    iab_authorized = Some(IabAuthorized::decode(data)?);
                }
                205 => {
                    enhanced_coverage_restriction =
                        Some(EnhancedCoverageRestriction::decode(data)?);
                }
                209 => {
                    ue_differentiation_info = Some(UeDifferentiationInfo::decode(data)?);
                }
                216 => {
                    nrv2x_services_authorized = Some(Nrv2xServicesAuthorized::decode(data)?);
                }
                215 => {
                    ltev2x_services_authorized = Some(Ltev2xServicesAuthorized::decode(data)?);
                }
                218 => {
                    nrue_sidelink_aggregate_maximum_bitrate =
                        Some(NrueSidelinkAggregateMaximumBitrate::decode(data)?);
                }
                217 => {
                    lteue_sidelink_aggregate_maximum_bitrate =
                        Some(LteueSidelinkAggregateMaximumBitrate::decode(data)?);
                }
                219 => {
                    pc5_qos_parameters = Some(Pc5QosParameters::decode(data)?);
                }
                222 => {
                    c_emode_brestricted = Some(CEmodeBrestricted::decode(data)?);
                }
                234 => {
                    ue_up_c_iot_support = Some(UeUpCIotSupport::decode(data)?);
                }
                254 => {
                    management_based_mdt_plmn_list = Some(MdtPlmnList::decode(data)?);
                }
                264 => {
                    ue_radio_capability_id = Some(UeRadioCapabilityId::decode(data)?);
                }
                206 => {
                    extended_connected_time = Some(ExtendedConnectedTime::decode(data)?);
                }
                x => {
                    if let Criticality::Reject = criticality {
                        return Err(aper::AperCodecError::new(format!(
                            "Unrecognised IE type {} with criticality reject",
                            x
                        )));
                    }
                }
            }
        }
        let amf_ue_ngap_id = amf_ue_ngap_id.ok_or(aper::AperCodecError::new(format!(
            "Missing mandatory IE amf_ue_ngap_id"
        )))?;
        let handover_type = handover_type.ok_or(aper::AperCodecError::new(format!(
            "Missing mandatory IE handover_type"
        )))?;
        let cause = cause.ok_or(aper::AperCodecError::new(format!(
            "Missing mandatory IE cause"
        )))?;
        let ue_aggregate_maximum_bit_rate =
            ue_aggregate_maximum_bit_rate.ok_or(aper::AperCodecError::new(format!(
                "Missing mandatory IE ue_aggregate_maximum_bit_rate"
            )))?;
        let ue_security_capabilities = ue_security_capabilities.ok_or(
            aper::AperCodecError::new(format!("Missing mandatory IE ue_security_capabilities")),
        )?;
        let security_context = security_context.ok_or(aper::AperCodecError::new(format!(
            "Missing mandatory IE security_context"
        )))?;
        let pdu_session_resource_setup_list_ho_req =
            pdu_session_resource_setup_list_ho_req.ok_or(aper::AperCodecError::new(format!(
                "Missing mandatory IE pdu_session_resource_setup_list_ho_req"
            )))?;
        let allowed_nssai = allowed_nssai.ok_or(aper::AperCodecError::new(format!(
            "Missing mandatory IE allowed_nssai"
        )))?;
        let source_to_target_transparent_container =
            source_to_target_transparent_container.ok_or(aper::AperCodecError::new(format!(
                "Missing mandatory IE source_to_target_transparent_container"
            )))?;
        let guami = guami.ok_or(aper::AperCodecError::new(format!(
            "Missing mandatory IE guami"
        )))?;
        Ok(Self {
            amf_ue_ngap_id,
            handover_type,
            cause,
            ue_aggregate_maximum_bit_rate,
            core_network_assistance_information_for_inactive,
            ue_security_capabilities,
            security_context,
            new_security_context_ind,
            nasc,
            pdu_session_resource_setup_list_ho_req,
            allowed_nssai,
            trace_activation,
            masked_imeisv,
            source_to_target_transparent_container,
            mobility_restriction_list,
            location_reporting_request_type,
            rrc_inactive_transition_report_request,
            guami,
            redirection_voice_fallback,
            cn_assisted_ran_tuning,
            srvcc_operation_possible,
            iab_authorized,
            enhanced_coverage_restriction,
            ue_differentiation_info,
            nrv2x_services_authorized,
            ltev2x_services_authorized,
            nrue_sidelink_aggregate_maximum_bitrate,
            lteue_sidelink_aggregate_maximum_bitrate,
            pc5_qos_parameters,
            c_emode_brestricted,
            ue_up_c_iot_support,
            management_based_mdt_plmn_list,
            ue_radio_capability_id,
            extended_connected_time,
        })
    }
}

// HandoverRequestAcknowledge
#[derive(Clone)]
pub struct HandoverRequestAcknowledge {
    pub amf_ue_ngap_id: AmfUeNgapId,
    pub ran_ue_ngap_id: RanUeNgapId,
    pub pdu_session_resource_admitted_list: PduSessionResourceAdmittedList,
    pub pdu_session_resource_failed_to_setup_list_ho_ack:
        Option<PduSessionResourceFailedToSetupListHoAck>,
    pub target_to_source_transparent_container: TargetToSourceTransparentContainer,
    pub criticality_diagnostics: Option<CriticalityDiagnostics>,
}

impl AperCodec for HandoverRequestAcknowledge {
    type Output = HandoverRequestAcknowledge;
    fn decode(data: &mut AperCodecData) -> Result<Self::Output, AperCodecError> {
        let _length = aper::decode::decode_length_determinent(data, None, None, false)?;
        let _ = aper::decode::decode_sequence_header(data, true, 0)?;
        let len = aper::decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut amf_ue_ngap_id: Option<AmfUeNgapId> = None;
        let mut ran_ue_ngap_id: Option<RanUeNgapId> = None;
        let mut pdu_session_resource_admitted_list: Option<PduSessionResourceAdmittedList> = None;
        let mut pdu_session_resource_failed_to_setup_list_ho_ack: Option<
            PduSessionResourceFailedToSetupListHoAck,
        > = None;
        let mut target_to_source_transparent_container: Option<TargetToSourceTransparentContainer> =
            None;
        let mut criticality_diagnostics: Option<CriticalityDiagnostics> = None;

        for _ in 0..len {
            let (id, _ext) = aper::decode::decode_integer(data, Some(0), Some(65535), false)?;
            let criticality = Criticality::decode(data)?;
            let _length = aper::decode::decode_length_determinent(data, None, None, false)?;
            match id {
                10 => {
                    amf_ue_ngap_id = Some(AmfUeNgapId::decode(data)?);
                }
                85 => {
                    ran_ue_ngap_id = Some(RanUeNgapId::decode(data)?);
                }
                53 => {
                    pdu_session_resource_admitted_list =
                        Some(PduSessionResourceAdmittedList::decode(data)?);
                }
                56 => {
                    pdu_session_resource_failed_to_setup_list_ho_ack =
                        Some(PduSessionResourceFailedToSetupListHoAck::decode(data)?);
                }
                106 => {
                    target_to_source_transparent_container =
                        Some(TargetToSourceTransparentContainer::decode(data)?);
                }
                19 => {
                    criticality_diagnostics = Some(CriticalityDiagnostics::decode(data)?);
                }
                x => {
                    if let Criticality::Reject = criticality {
                        return Err(aper::AperCodecError::new(format!(
                            "Unrecognised IE type {} with criticality reject",
                            x
                        )));
                    }
                }
            }
        }
        let amf_ue_ngap_id = amf_ue_ngap_id.ok_or(aper::AperCodecError::new(format!(
            "Missing mandatory IE amf_ue_ngap_id"
        )))?;
        let ran_ue_ngap_id = ran_ue_ngap_id.ok_or(aper::AperCodecError::new(format!(
            "Missing mandatory IE ran_ue_ngap_id"
        )))?;
        let pdu_session_resource_admitted_list =
            pdu_session_resource_admitted_list.ok_or(aper::AperCodecError::new(format!(
                "Missing mandatory IE pdu_session_resource_admitted_list"
            )))?;
        let target_to_source_transparent_container =
            target_to_source_transparent_container.ok_or(aper::AperCodecError::new(format!(
                "Missing mandatory IE target_to_source_transparent_container"
            )))?;
        Ok(Self {
            amf_ue_ngap_id,
            ran_ue_ngap_id,
            pdu_session_resource_admitted_list,
            pdu_session_resource_failed_to_setup_list_ho_ack,
            target_to_source_transparent_container,
            criticality_diagnostics,
        })
    }
}

// HandoverFailure
#[derive(Clone)]
pub struct HandoverFailure {
    pub amf_ue_ngap_id: AmfUeNgapId,
    pub cause: Cause,
    pub criticality_diagnostics: Option<CriticalityDiagnostics>,
    pub targetto_source_failure_transparent_container:
        Option<TargettoSourceFailureTransparentContainer>,
}

impl AperCodec for HandoverFailure {
    type Output = HandoverFailure;
    fn decode(data: &mut AperCodecData) -> Result<Self::Output, AperCodecError> {
        let _length = aper::decode::decode_length_determinent(data, None, None, false)?;
        let _ = aper::decode::decode_sequence_header(data, true, 0)?;
        let len = aper::decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut amf_ue_ngap_id: Option<AmfUeNgapId> = None;
        let mut cause: Option<Cause> = None;
        let mut criticality_diagnostics: Option<CriticalityDiagnostics> = None;
        let mut targetto_source_failure_transparent_container: Option<
            TargettoSourceFailureTransparentContainer,
        > = None;

        for _ in 0..len {
            let (id, _ext) = aper::decode::decode_integer(data, Some(0), Some(65535), false)?;
            let criticality = Criticality::decode(data)?;
            let _length = aper::decode::decode_length_determinent(data, None, None, false)?;
            match id {
                10 => {
                    amf_ue_ngap_id = Some(AmfUeNgapId::decode(data)?);
                }
                15 => {
                    cause = Some(Cause::decode(data)?);
                }
                19 => {
                    criticality_diagnostics = Some(CriticalityDiagnostics::decode(data)?);
                }
                262 => {
                    targetto_source_failure_transparent_container =
                        Some(TargettoSourceFailureTransparentContainer::decode(data)?);
                }
                x => {
                    if let Criticality::Reject = criticality {
                        return Err(aper::AperCodecError::new(format!(
                            "Unrecognised IE type {} with criticality reject",
                            x
                        )));
                    }
                }
            }
        }
        let amf_ue_ngap_id = amf_ue_ngap_id.ok_or(aper::AperCodecError::new(format!(
            "Missing mandatory IE amf_ue_ngap_id"
        )))?;
        let cause = cause.ok_or(aper::AperCodecError::new(format!(
            "Missing mandatory IE cause"
        )))?;
        Ok(Self {
            amf_ue_ngap_id,
            cause,
            criticality_diagnostics,
            targetto_source_failure_transparent_container,
        })
    }
}

// HandoverNotify
#[derive(Clone)]
pub struct HandoverNotify {
    pub amf_ue_ngap_id: AmfUeNgapId,
    pub ran_ue_ngap_id: RanUeNgapId,
    pub user_location_information: UserLocationInformation,
    pub notify_source_ngran_node: Option<NotifySourceNgranNode>,
}

impl AperCodec for HandoverNotify {
    type Output = HandoverNotify;
    fn decode(data: &mut AperCodecData) -> Result<Self::Output, AperCodecError> {
        let _length = aper::decode::decode_length_determinent(data, None, None, false)?;
        let _ = aper::decode::decode_sequence_header(data, true, 0)?;
        let len = aper::decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut amf_ue_ngap_id: Option<AmfUeNgapId> = None;
        let mut ran_ue_ngap_id: Option<RanUeNgapId> = None;
        let mut user_location_information: Option<UserLocationInformation> = None;
        let mut notify_source_ngran_node: Option<NotifySourceNgranNode> = None;

        for _ in 0..len {
            let (id, _ext) = aper::decode::decode_integer(data, Some(0), Some(65535), false)?;
            let criticality = Criticality::decode(data)?;
            let _length = aper::decode::decode_length_determinent(data, None, None, false)?;
            match id {
                10 => {
                    amf_ue_ngap_id = Some(AmfUeNgapId::decode(data)?);
                }
                85 => {
                    ran_ue_ngap_id = Some(RanUeNgapId::decode(data)?);
                }
                121 => {
                    user_location_information = Some(UserLocationInformation::decode(data)?);
                }
                269 => {
                    notify_source_ngran_node = Some(NotifySourceNgranNode::decode(data)?);
                }
                x => {
                    if let Criticality::Reject = criticality {
                        return Err(aper::AperCodecError::new(format!(
                            "Unrecognised IE type {} with criticality reject",
                            x
                        )));
                    }
                }
            }
        }
        let amf_ue_ngap_id = amf_ue_ngap_id.ok_or(aper::AperCodecError::new(format!(
            "Missing mandatory IE amf_ue_ngap_id"
        )))?;
        let ran_ue_ngap_id = ran_ue_ngap_id.ok_or(aper::AperCodecError::new(format!(
            "Missing mandatory IE ran_ue_ngap_id"
        )))?;
        let user_location_information = user_location_information.ok_or(
            aper::AperCodecError::new(format!("Missing mandatory IE user_location_information")),
        )?;
        Ok(Self {
            amf_ue_ngap_id,
            ran_ue_ngap_id,
            user_location_information,
            notify_source_ngran_node,
        })
    }
}

// PathSwitchRequest
#[derive(Clone)]
pub struct PathSwitchRequest {
    pub ran_ue_ngap_id: RanUeNgapId,
    pub source_amf_ue_ngap_id: AmfUeNgapId,
    pub user_location_information: UserLocationInformation,
    pub ue_security_capabilities: UeSecurityCapabilities,
    pub pdu_session_resource_to_be_switched_dl_list: PduSessionResourceToBeSwitchedDlList,
    pub pdu_session_resource_failed_to_setup_list_ps_req:
        Option<PduSessionResourceFailedToSetupListPsReq>,
    pub rrc_resume_cause: Option<RrcEstablishmentCause>,
}

impl AperCodec for PathSwitchRequest {
    type Output = PathSwitchRequest;
    fn decode(data: &mut AperCodecData) -> Result<Self::Output, AperCodecError> {
        let _length = aper::decode::decode_length_determinent(data, None, None, false)?;
        let _ = aper::decode::decode_sequence_header(data, true, 0)?;
        let len = aper::decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut ran_ue_ngap_id: Option<RanUeNgapId> = None;
        let mut source_amf_ue_ngap_id: Option<AmfUeNgapId> = None;
        let mut user_location_information: Option<UserLocationInformation> = None;
        let mut ue_security_capabilities: Option<UeSecurityCapabilities> = None;
        let mut pdu_session_resource_to_be_switched_dl_list: Option<
            PduSessionResourceToBeSwitchedDlList,
        > = None;
        let mut pdu_session_resource_failed_to_setup_list_ps_req: Option<
            PduSessionResourceFailedToSetupListPsReq,
        > = None;
        let mut rrc_resume_cause: Option<RrcEstablishmentCause> = None;

        for _ in 0..len {
            let (id, _ext) = aper::decode::decode_integer(data, Some(0), Some(65535), false)?;
            let criticality = Criticality::decode(data)?;
            let _length = aper::decode::decode_length_determinent(data, None, None, false)?;
            match id {
                85 => {
                    ran_ue_ngap_id = Some(RanUeNgapId::decode(data)?);
                }
                100 => {
                    source_amf_ue_ngap_id = Some(AmfUeNgapId::decode(data)?);
                }
                121 => {
                    user_location_information = Some(UserLocationInformation::decode(data)?);
                }
                119 => {
                    ue_security_capabilities = Some(UeSecurityCapabilities::decode(data)?);
                }
                76 => {
                    pdu_session_resource_to_be_switched_dl_list =
                        Some(PduSessionResourceToBeSwitchedDlList::decode(data)?);
                }
                57 => {
                    pdu_session_resource_failed_to_setup_list_ps_req =
                        Some(PduSessionResourceFailedToSetupListPsReq::decode(data)?);
                }
                237 => {
                    rrc_resume_cause = Some(RrcEstablishmentCause::decode(data)?);
                }
                x => {
                    if let Criticality::Reject = criticality {
                        return Err(aper::AperCodecError::new(format!(
                            "Unrecognised IE type {} with criticality reject",
                            x
                        )));
                    }
                }
            }
        }
        let ran_ue_ngap_id = ran_ue_ngap_id.ok_or(aper::AperCodecError::new(format!(
            "Missing mandatory IE ran_ue_ngap_id"
        )))?;
        let source_amf_ue_ngap_id = source_amf_ue_ngap_id.ok_or(aper::AperCodecError::new(
            format!("Missing mandatory IE source_amf_ue_ngap_id"),
        ))?;
        let user_location_information = user_location_information.ok_or(
            aper::AperCodecError::new(format!("Missing mandatory IE user_location_information")),
        )?;
        let ue_security_capabilities = ue_security_capabilities.ok_or(
            aper::AperCodecError::new(format!("Missing mandatory IE ue_security_capabilities")),
        )?;
        let pdu_session_resource_to_be_switched_dl_list =
            pdu_session_resource_to_be_switched_dl_list.ok_or(aper::AperCodecError::new(
                format!("Missing mandatory IE pdu_session_resource_to_be_switched_dl_list"),
            ))?;
        Ok(Self {
            ran_ue_ngap_id,
            source_amf_ue_ngap_id,
            user_location_information,
            ue_security_capabilities,
            pdu_session_resource_to_be_switched_dl_list,
            pdu_session_resource_failed_to_setup_list_ps_req,
            rrc_resume_cause,
        })
    }
}

// PathSwitchRequestAcknowledge
#[derive(Clone)]
pub struct PathSwitchRequestAcknowledge {
    pub amf_ue_ngap_id: AmfUeNgapId,
    pub ran_ue_ngap_id: RanUeNgapId,
    pub ue_security_capabilities: Option<UeSecurityCapabilities>,
    pub security_context: SecurityContext,
    pub new_security_context_ind: Option<NewSecurityContextInd>,
    pub pdu_session_resource_switched_list: PduSessionResourceSwitchedList,
    pub pdu_session_resource_released_list_ps_ack: Option<PduSessionResourceReleasedListPsAck>,
    pub allowed_nssai: AllowedNssai,
    pub core_network_assistance_information_for_inactive:
        Option<CoreNetworkAssistanceInformationForInactive>,
    pub rrc_inactive_transition_report_request: Option<RrcInactiveTransitionReportRequest>,
    pub criticality_diagnostics: Option<CriticalityDiagnostics>,
    pub redirection_voice_fallback: Option<RedirectionVoiceFallback>,
    pub cn_assisted_ran_tuning: Option<CnAssistedRanTuning>,
    pub srvcc_operation_possible: Option<SrvccOperationPossible>,
    pub enhanced_coverage_restriction: Option<EnhancedCoverageRestriction>,
    pub extended_connected_time: Option<ExtendedConnectedTime>,
    pub ue_differentiation_info: Option<UeDifferentiationInfo>,
    pub nrv2x_services_authorized: Option<Nrv2xServicesAuthorized>,
    pub ltev2x_services_authorized: Option<Ltev2xServicesAuthorized>,
    pub nrue_sidelink_aggregate_maximum_bitrate: Option<NrueSidelinkAggregateMaximumBitrate>,
    pub lteue_sidelink_aggregate_maximum_bitrate: Option<LteueSidelinkAggregateMaximumBitrate>,
    pub pc5_qos_parameters: Option<Pc5QosParameters>,
    pub c_emode_brestricted: Option<CEmodeBrestricted>,
    pub ue_up_c_iot_support: Option<UeUpCIotSupport>,
    pub ue_radio_capability_id: Option<UeRadioCapabilityId>,
}

impl AperCodec for PathSwitchRequestAcknowledge {
    type Output = PathSwitchRequestAcknowledge;
    fn decode(data: &mut AperCodecData) -> Result<Self::Output, AperCodecError> {
        let _length = aper::decode::decode_length_determinent(data, None, None, false)?;
        let _ = aper::decode::decode_sequence_header(data, true, 0)?;
        let len = aper::decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut amf_ue_ngap_id: Option<AmfUeNgapId> = None;
        let mut ran_ue_ngap_id: Option<RanUeNgapId> = None;
        let mut ue_security_capabilities: Option<UeSecurityCapabilities> = None;
        let mut security_context: Option<SecurityContext> = None;
        let mut new_security_context_ind: Option<NewSecurityContextInd> = None;
        let mut pdu_session_resource_switched_list: Option<PduSessionResourceSwitchedList> = None;
        let mut pdu_session_resource_released_list_ps_ack: Option<
            PduSessionResourceReleasedListPsAck,
        > = None;
        let mut allowed_nssai: Option<AllowedNssai> = None;
        let mut core_network_assistance_information_for_inactive: Option<
            CoreNetworkAssistanceInformationForInactive,
        > = None;
        let mut rrc_inactive_transition_report_request: Option<RrcInactiveTransitionReportRequest> =
            None;
        let mut criticality_diagnostics: Option<CriticalityDiagnostics> = None;
        let mut redirection_voice_fallback: Option<RedirectionVoiceFallback> = None;
        let mut cn_assisted_ran_tuning: Option<CnAssistedRanTuning> = None;
        let mut srvcc_operation_possible: Option<SrvccOperationPossible> = None;
        let mut enhanced_coverage_restriction: Option<EnhancedCoverageRestriction> = None;
        let mut extended_connected_time: Option<ExtendedConnectedTime> = None;
        let mut ue_differentiation_info: Option<UeDifferentiationInfo> = None;
        let mut nrv2x_services_authorized: Option<Nrv2xServicesAuthorized> = None;
        let mut ltev2x_services_authorized: Option<Ltev2xServicesAuthorized> = None;
        let mut nrue_sidelink_aggregate_maximum_bitrate: Option<
            NrueSidelinkAggregateMaximumBitrate,
        > = None;
        let mut lteue_sidelink_aggregate_maximum_bitrate: Option<
            LteueSidelinkAggregateMaximumBitrate,
        > = None;
        let mut pc5_qos_parameters: Option<Pc5QosParameters> = None;
        let mut c_emode_brestricted: Option<CEmodeBrestricted> = None;
        let mut ue_up_c_iot_support: Option<UeUpCIotSupport> = None;
        let mut ue_radio_capability_id: Option<UeRadioCapabilityId> = None;

        for _ in 0..len {
            let (id, _ext) = aper::decode::decode_integer(data, Some(0), Some(65535), false)?;
            let criticality = Criticality::decode(data)?;
            let _length = aper::decode::decode_length_determinent(data, None, None, false)?;
            match id {
                10 => {
                    amf_ue_ngap_id = Some(AmfUeNgapId::decode(data)?);
                }
                85 => {
                    ran_ue_ngap_id = Some(RanUeNgapId::decode(data)?);
                }
                119 => {
                    ue_security_capabilities = Some(UeSecurityCapabilities::decode(data)?);
                }
                93 => {
                    security_context = Some(SecurityContext::decode(data)?);
                }
                41 => {
                    new_security_context_ind = Some(NewSecurityContextInd::decode(data)?);
                }
                77 => {
                    pdu_session_resource_switched_list =
                        Some(PduSessionResourceSwitchedList::decode(data)?);
                }
                68 => {
                    pdu_session_resource_released_list_ps_ack =
                        Some(PduSessionResourceReleasedListPsAck::decode(data)?);
                }
                0 => {
                    allowed_nssai = Some(AllowedNssai::decode(data)?);
                }
                18 => {
                    core_network_assistance_information_for_inactive =
                        Some(CoreNetworkAssistanceInformationForInactive::decode(data)?);
                }
                91 => {
                    rrc_inactive_transition_report_request =
                        Some(RrcInactiveTransitionReportRequest::decode(data)?);
                }
                19 => {
                    criticality_diagnostics = Some(CriticalityDiagnostics::decode(data)?);
                }
                146 => {
                    redirection_voice_fallback = Some(RedirectionVoiceFallback::decode(data)?);
                }
                165 => {
                    cn_assisted_ran_tuning = Some(CnAssistedRanTuning::decode(data)?);
                }
                177 => {
                    srvcc_operation_possible = Some(SrvccOperationPossible::decode(data)?);
                }
                205 => {
                    enhanced_coverage_restriction =
                        Some(EnhancedCoverageRestriction::decode(data)?);
                }
                206 => {
                    extended_connected_time = Some(ExtendedConnectedTime::decode(data)?);
                }
                209 => {
                    ue_differentiation_info = Some(UeDifferentiationInfo::decode(data)?);
                }
                216 => {
                    nrv2x_services_authorized = Some(Nrv2xServicesAuthorized::decode(data)?);
                }
                215 => {
                    ltev2x_services_authorized = Some(Ltev2xServicesAuthorized::decode(data)?);
                }
                218 => {
                    nrue_sidelink_aggregate_maximum_bitrate =
                        Some(NrueSidelinkAggregateMaximumBitrate::decode(data)?);
                }
                217 => {
                    lteue_sidelink_aggregate_maximum_bitrate =
                        Some(LteueSidelinkAggregateMaximumBitrate::decode(data)?);
                }
                219 => {
                    pc5_qos_parameters = Some(Pc5QosParameters::decode(data)?);
                }
                222 => {
                    c_emode_brestricted = Some(CEmodeBrestricted::decode(data)?);
                }
                234 => {
                    ue_up_c_iot_support = Some(UeUpCIotSupport::decode(data)?);
                }
                264 => {
                    ue_radio_capability_id = Some(UeRadioCapabilityId::decode(data)?);
                }
                x => {
                    if let Criticality::Reject = criticality {
                        return Err(aper::AperCodecError::new(format!(
                            "Unrecognised IE type {} with criticality reject",
                            x
                        )));
                    }
                }
            }
        }
        let amf_ue_ngap_id = amf_ue_ngap_id.ok_or(aper::AperCodecError::new(format!(
            "Missing mandatory IE amf_ue_ngap_id"
        )))?;
        let ran_ue_ngap_id = ran_ue_ngap_id.ok_or(aper::AperCodecError::new(format!(
            "Missing mandatory IE ran_ue_ngap_id"
        )))?;
        let security_context = security_context.ok_or(aper::AperCodecError::new(format!(
            "Missing mandatory IE security_context"
        )))?;
        let pdu_session_resource_switched_list =
            pdu_session_resource_switched_list.ok_or(aper::AperCodecError::new(format!(
                "Missing mandatory IE pdu_session_resource_switched_list"
            )))?;
        let allowed_nssai = allowed_nssai.ok_or(aper::AperCodecError::new(format!(
            "Missing mandatory IE allowed_nssai"
        )))?;
        Ok(Self {
            amf_ue_ngap_id,
            ran_ue_ngap_id,
            ue_security_capabilities,
            security_context,
            new_security_context_ind,
            pdu_session_resource_switched_list,
            pdu_session_resource_released_list_ps_ack,
            allowed_nssai,
            core_network_assistance_information_for_inactive,
            rrc_inactive_transition_report_request,
            criticality_diagnostics,
            redirection_voice_fallback,
            cn_assisted_ran_tuning,
            srvcc_operation_possible,
            enhanced_coverage_restriction,
            extended_connected_time,
            ue_differentiation_info,
            nrv2x_services_authorized,
            ltev2x_services_authorized,
            nrue_sidelink_aggregate_maximum_bitrate,
            lteue_sidelink_aggregate_maximum_bitrate,
            pc5_qos_parameters,
            c_emode_brestricted,
            ue_up_c_iot_support,
            ue_radio_capability_id,
        })
    }
}

// PathSwitchRequestFailure
#[derive(Clone)]
pub struct PathSwitchRequestFailure {
    pub amf_ue_ngap_id: AmfUeNgapId,
    pub ran_ue_ngap_id: RanUeNgapId,
    pub pdu_session_resource_released_list_ps_fail: PduSessionResourceReleasedListPsFail,
    pub criticality_diagnostics: Option<CriticalityDiagnostics>,
}

impl AperCodec for PathSwitchRequestFailure {
    type Output = PathSwitchRequestFailure;
    fn decode(data: &mut AperCodecData) -> Result<Self::Output, AperCodecError> {
        let _length = aper::decode::decode_length_determinent(data, None, None, false)?;
        let _ = aper::decode::decode_sequence_header(data, true, 0)?;
        let len = aper::decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut amf_ue_ngap_id: Option<AmfUeNgapId> = None;
        let mut ran_ue_ngap_id: Option<RanUeNgapId> = None;
        let mut pdu_session_resource_released_list_ps_fail: Option<
            PduSessionResourceReleasedListPsFail,
        > = None;
        let mut criticality_diagnostics: Option<CriticalityDiagnostics> = None;

        for _ in 0..len {
            let (id, _ext) = aper::decode::decode_integer(data, Some(0), Some(65535), false)?;
            let criticality = Criticality::decode(data)?;
            let _length = aper::decode::decode_length_determinent(data, None, None, false)?;
            match id {
                10 => {
                    amf_ue_ngap_id = Some(AmfUeNgapId::decode(data)?);
                }
                85 => {
                    ran_ue_ngap_id = Some(RanUeNgapId::decode(data)?);
                }
                69 => {
                    pdu_session_resource_released_list_ps_fail =
                        Some(PduSessionResourceReleasedListPsFail::decode(data)?);
                }
                19 => {
                    criticality_diagnostics = Some(CriticalityDiagnostics::decode(data)?);
                }
                x => {
                    if let Criticality::Reject = criticality {
                        return Err(aper::AperCodecError::new(format!(
                            "Unrecognised IE type {} with criticality reject",
                            x
                        )));
                    }
                }
            }
        }
        let amf_ue_ngap_id = amf_ue_ngap_id.ok_or(aper::AperCodecError::new(format!(
            "Missing mandatory IE amf_ue_ngap_id"
        )))?;
        let ran_ue_ngap_id = ran_ue_ngap_id.ok_or(aper::AperCodecError::new(format!(
            "Missing mandatory IE ran_ue_ngap_id"
        )))?;
        let pdu_session_resource_released_list_ps_fail = pdu_session_resource_released_list_ps_fail
            .ok_or(aper::AperCodecError::new(format!(
                "Missing mandatory IE pdu_session_resource_released_list_ps_fail"
            )))?;
        Ok(Self {
            amf_ue_ngap_id,
            ran_ue_ngap_id,
            pdu_session_resource_released_list_ps_fail,
            criticality_diagnostics,
        })
    }
}

// HandoverCancel
#[derive(Clone)]
pub struct HandoverCancel {
    pub amf_ue_ngap_id: AmfUeNgapId,
    pub ran_ue_ngap_id: RanUeNgapId,
    pub cause: Cause,
}

impl AperCodec for HandoverCancel {
    type Output = HandoverCancel;
    fn decode(data: &mut AperCodecData) -> Result<Self::Output, AperCodecError> {
        let _length = aper::decode::decode_length_determinent(data, None, None, false)?;
        let _ = aper::decode::decode_sequence_header(data, true, 0)?;
        let len = aper::decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut amf_ue_ngap_id: Option<AmfUeNgapId> = None;
        let mut ran_ue_ngap_id: Option<RanUeNgapId> = None;
        let mut cause: Option<Cause> = None;

        for _ in 0..len {
            let (id, _ext) = aper::decode::decode_integer(data, Some(0), Some(65535), false)?;
            let criticality = Criticality::decode(data)?;
            let _length = aper::decode::decode_length_determinent(data, None, None, false)?;
            match id {
                10 => {
                    amf_ue_ngap_id = Some(AmfUeNgapId::decode(data)?);
                }
                85 => {
                    ran_ue_ngap_id = Some(RanUeNgapId::decode(data)?);
                }
                15 => {
                    cause = Some(Cause::decode(data)?);
                }
                x => {
                    if let Criticality::Reject = criticality {
                        return Err(aper::AperCodecError::new(format!(
                            "Unrecognised IE type {} with criticality reject",
                            x
                        )));
                    }
                }
            }
        }
        let amf_ue_ngap_id = amf_ue_ngap_id.ok_or(aper::AperCodecError::new(format!(
            "Missing mandatory IE amf_ue_ngap_id"
        )))?;
        let ran_ue_ngap_id = ran_ue_ngap_id.ok_or(aper::AperCodecError::new(format!(
            "Missing mandatory IE ran_ue_ngap_id"
        )))?;
        let cause = cause.ok_or(aper::AperCodecError::new(format!(
            "Missing mandatory IE cause"
        )))?;
        Ok(Self {
            amf_ue_ngap_id,
            ran_ue_ngap_id,
            cause,
        })
    }
}

// HandoverCancelAcknowledge
#[derive(Clone)]
pub struct HandoverCancelAcknowledge {
    pub amf_ue_ngap_id: AmfUeNgapId,
    pub ran_ue_ngap_id: RanUeNgapId,
    pub criticality_diagnostics: Option<CriticalityDiagnostics>,
}

impl AperCodec for HandoverCancelAcknowledge {
    type Output = HandoverCancelAcknowledge;
    fn decode(data: &mut AperCodecData) -> Result<Self::Output, AperCodecError> {
        let _length = aper::decode::decode_length_determinent(data, None, None, false)?;
        let _ = aper::decode::decode_sequence_header(data, true, 0)?;
        let len = aper::decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut amf_ue_ngap_id: Option<AmfUeNgapId> = None;
        let mut ran_ue_ngap_id: Option<RanUeNgapId> = None;
        let mut criticality_diagnostics: Option<CriticalityDiagnostics> = None;

        for _ in 0..len {
            let (id, _ext) = aper::decode::decode_integer(data, Some(0), Some(65535), false)?;
            let criticality = Criticality::decode(data)?;
            let _length = aper::decode::decode_length_determinent(data, None, None, false)?;
            match id {
                10 => {
                    amf_ue_ngap_id = Some(AmfUeNgapId::decode(data)?);
                }
                85 => {
                    ran_ue_ngap_id = Some(RanUeNgapId::decode(data)?);
                }
                19 => {
                    criticality_diagnostics = Some(CriticalityDiagnostics::decode(data)?);
                }
                x => {
                    if let Criticality::Reject = criticality {
                        return Err(aper::AperCodecError::new(format!(
                            "Unrecognised IE type {} with criticality reject",
                            x
                        )));
                    }
                }
            }
        }
        let amf_ue_ngap_id = amf_ue_ngap_id.ok_or(aper::AperCodecError::new(format!(
            "Missing mandatory IE amf_ue_ngap_id"
        )))?;
        let ran_ue_ngap_id = ran_ue_ngap_id.ok_or(aper::AperCodecError::new(format!(
            "Missing mandatory IE ran_ue_ngap_id"
        )))?;
        Ok(Self {
            amf_ue_ngap_id,
            ran_ue_ngap_id,
            criticality_diagnostics,
        })
    }
}

// HandoverSuccess
#[derive(Clone)]
pub struct HandoverSuccess {
    pub amf_ue_ngap_id: AmfUeNgapId,
    pub ran_ue_ngap_id: RanUeNgapId,
}

impl AperCodec for HandoverSuccess {
    type Output = HandoverSuccess;
    fn decode(data: &mut AperCodecData) -> Result<Self::Output, AperCodecError> {
        let _length = aper::decode::decode_length_determinent(data, None, None, false)?;
        let _ = aper::decode::decode_sequence_header(data, true, 0)?;
        let len = aper::decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut amf_ue_ngap_id: Option<AmfUeNgapId> = None;
        let mut ran_ue_ngap_id: Option<RanUeNgapId> = None;

        for _ in 0..len {
            let (id, _ext) = aper::decode::decode_integer(data, Some(0), Some(65535), false)?;
            let criticality = Criticality::decode(data)?;
            let _length = aper::decode::decode_length_determinent(data, None, None, false)?;
            match id {
                10 => {
                    amf_ue_ngap_id = Some(AmfUeNgapId::decode(data)?);
                }
                85 => {
                    ran_ue_ngap_id = Some(RanUeNgapId::decode(data)?);
                }
                x => {
                    if let Criticality::Reject = criticality {
                        return Err(aper::AperCodecError::new(format!(
                            "Unrecognised IE type {} with criticality reject",
                            x
                        )));
                    }
                }
            }
        }
        let amf_ue_ngap_id = amf_ue_ngap_id.ok_or(aper::AperCodecError::new(format!(
            "Missing mandatory IE amf_ue_ngap_id"
        )))?;
        let ran_ue_ngap_id = ran_ue_ngap_id.ok_or(aper::AperCodecError::new(format!(
            "Missing mandatory IE ran_ue_ngap_id"
        )))?;
        Ok(Self {
            amf_ue_ngap_id,
            ran_ue_ngap_id,
        })
    }
}

// UplinkRanEarlyStatusTransfer
#[derive(Clone)]
pub struct UplinkRanEarlyStatusTransfer {
    pub amf_ue_ngap_id: AmfUeNgapId,
    pub ran_ue_ngap_id: RanUeNgapId,
    pub early_status_transfer_transparent_container: EarlyStatusTransferTransparentContainer,
}

impl AperCodec for UplinkRanEarlyStatusTransfer {
    type Output = UplinkRanEarlyStatusTransfer;
    fn decode(data: &mut AperCodecData) -> Result<Self::Output, AperCodecError> {
        let _length = aper::decode::decode_length_determinent(data, None, None, false)?;
        let _ = aper::decode::decode_sequence_header(data, true, 0)?;
        let len = aper::decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut amf_ue_ngap_id: Option<AmfUeNgapId> = None;
        let mut ran_ue_ngap_id: Option<RanUeNgapId> = None;
        let mut early_status_transfer_transparent_container: Option<
            EarlyStatusTransferTransparentContainer,
        > = None;

        for _ in 0..len {
            let (id, _ext) = aper::decode::decode_integer(data, Some(0), Some(65535), false)?;
            let criticality = Criticality::decode(data)?;
            let _length = aper::decode::decode_length_determinent(data, None, None, false)?;
            match id {
                10 => {
                    amf_ue_ngap_id = Some(AmfUeNgapId::decode(data)?);
                }
                85 => {
                    ran_ue_ngap_id = Some(RanUeNgapId::decode(data)?);
                }
                268 => {
                    early_status_transfer_transparent_container =
                        Some(EarlyStatusTransferTransparentContainer::decode(data)?);
                }
                x => {
                    if let Criticality::Reject = criticality {
                        return Err(aper::AperCodecError::new(format!(
                            "Unrecognised IE type {} with criticality reject",
                            x
                        )));
                    }
                }
            }
        }
        let amf_ue_ngap_id = amf_ue_ngap_id.ok_or(aper::AperCodecError::new(format!(
            "Missing mandatory IE amf_ue_ngap_id"
        )))?;
        let ran_ue_ngap_id = ran_ue_ngap_id.ok_or(aper::AperCodecError::new(format!(
            "Missing mandatory IE ran_ue_ngap_id"
        )))?;
        let early_status_transfer_transparent_container =
            early_status_transfer_transparent_container.ok_or(aper::AperCodecError::new(
                format!("Missing mandatory IE early_status_transfer_transparent_container"),
            ))?;
        Ok(Self {
            amf_ue_ngap_id,
            ran_ue_ngap_id,
            early_status_transfer_transparent_container,
        })
    }
}

// DownlinkRanEarlyStatusTransfer
#[derive(Clone)]
pub struct DownlinkRanEarlyStatusTransfer {
    pub amf_ue_ngap_id: AmfUeNgapId,
    pub ran_ue_ngap_id: RanUeNgapId,
    pub early_status_transfer_transparent_container: EarlyStatusTransferTransparentContainer,
}

impl AperCodec for DownlinkRanEarlyStatusTransfer {
    type Output = DownlinkRanEarlyStatusTransfer;
    fn decode(data: &mut AperCodecData) -> Result<Self::Output, AperCodecError> {
        let _length = aper::decode::decode_length_determinent(data, None, None, false)?;
        let _ = aper::decode::decode_sequence_header(data, true, 0)?;
        let len = aper::decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut amf_ue_ngap_id: Option<AmfUeNgapId> = None;
        let mut ran_ue_ngap_id: Option<RanUeNgapId> = None;
        let mut early_status_transfer_transparent_container: Option<
            EarlyStatusTransferTransparentContainer,
        > = None;

        for _ in 0..len {
            let (id, _ext) = aper::decode::decode_integer(data, Some(0), Some(65535), false)?;
            let criticality = Criticality::decode(data)?;
            let _length = aper::decode::decode_length_determinent(data, None, None, false)?;
            match id {
                10 => {
                    amf_ue_ngap_id = Some(AmfUeNgapId::decode(data)?);
                }
                85 => {
                    ran_ue_ngap_id = Some(RanUeNgapId::decode(data)?);
                }
                268 => {
                    early_status_transfer_transparent_container =
                        Some(EarlyStatusTransferTransparentContainer::decode(data)?);
                }
                x => {
                    if let Criticality::Reject = criticality {
                        return Err(aper::AperCodecError::new(format!(
                            "Unrecognised IE type {} with criticality reject",
                            x
                        )));
                    }
                }
            }
        }
        let amf_ue_ngap_id = amf_ue_ngap_id.ok_or(aper::AperCodecError::new(format!(
            "Missing mandatory IE amf_ue_ngap_id"
        )))?;
        let ran_ue_ngap_id = ran_ue_ngap_id.ok_or(aper::AperCodecError::new(format!(
            "Missing mandatory IE ran_ue_ngap_id"
        )))?;
        let early_status_transfer_transparent_container =
            early_status_transfer_transparent_container.ok_or(aper::AperCodecError::new(
                format!("Missing mandatory IE early_status_transfer_transparent_container"),
            ))?;
        Ok(Self {
            amf_ue_ngap_id,
            ran_ue_ngap_id,
            early_status_transfer_transparent_container,
        })
    }
}

// UplinkRanStatusTransfer
#[derive(Clone)]
pub struct UplinkRanStatusTransfer {
    pub amf_ue_ngap_id: AmfUeNgapId,
    pub ran_ue_ngap_id: RanUeNgapId,
    pub ran_status_transfer_transparent_container: RanStatusTransferTransparentContainer,
}

impl AperCodec for UplinkRanStatusTransfer {
    type Output = UplinkRanStatusTransfer;
    fn decode(data: &mut AperCodecData) -> Result<Self::Output, AperCodecError> {
        let _length = aper::decode::decode_length_determinent(data, None, None, false)?;
        let _ = aper::decode::decode_sequence_header(data, true, 0)?;
        let len = aper::decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut amf_ue_ngap_id: Option<AmfUeNgapId> = None;
        let mut ran_ue_ngap_id: Option<RanUeNgapId> = None;
        let mut ran_status_transfer_transparent_container: Option<
            RanStatusTransferTransparentContainer,
        > = None;

        for _ in 0..len {
            let (id, _ext) = aper::decode::decode_integer(data, Some(0), Some(65535), false)?;
            let criticality = Criticality::decode(data)?;
            let _length = aper::decode::decode_length_determinent(data, None, None, false)?;
            match id {
                10 => {
                    amf_ue_ngap_id = Some(AmfUeNgapId::decode(data)?);
                }
                85 => {
                    ran_ue_ngap_id = Some(RanUeNgapId::decode(data)?);
                }
                84 => {
                    ran_status_transfer_transparent_container =
                        Some(RanStatusTransferTransparentContainer::decode(data)?);
                }
                x => {
                    if let Criticality::Reject = criticality {
                        return Err(aper::AperCodecError::new(format!(
                            "Unrecognised IE type {} with criticality reject",
                            x
                        )));
                    }
                }
            }
        }
        let amf_ue_ngap_id = amf_ue_ngap_id.ok_or(aper::AperCodecError::new(format!(
            "Missing mandatory IE amf_ue_ngap_id"
        )))?;
        let ran_ue_ngap_id = ran_ue_ngap_id.ok_or(aper::AperCodecError::new(format!(
            "Missing mandatory IE ran_ue_ngap_id"
        )))?;
        let ran_status_transfer_transparent_container = ran_status_transfer_transparent_container
            .ok_or(aper::AperCodecError::new(
            format!("Missing mandatory IE ran_status_transfer_transparent_container"),
        ))?;
        Ok(Self {
            amf_ue_ngap_id,
            ran_ue_ngap_id,
            ran_status_transfer_transparent_container,
        })
    }
}

// DownlinkRanStatusTransfer
#[derive(Clone)]
pub struct DownlinkRanStatusTransfer {
    pub amf_ue_ngap_id: AmfUeNgapId,
    pub ran_ue_ngap_id: RanUeNgapId,
    pub ran_status_transfer_transparent_container: RanStatusTransferTransparentContainer,
}

impl AperCodec for DownlinkRanStatusTransfer {
    type Output = DownlinkRanStatusTransfer;
    fn decode(data: &mut AperCodecData) -> Result<Self::Output, AperCodecError> {
        let _length = aper::decode::decode_length_determinent(data, None, None, false)?;
        let _ = aper::decode::decode_sequence_header(data, true, 0)?;
        let len = aper::decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut amf_ue_ngap_id: Option<AmfUeNgapId> = None;
        let mut ran_ue_ngap_id: Option<RanUeNgapId> = None;
        let mut ran_status_transfer_transparent_container: Option<
            RanStatusTransferTransparentContainer,
        > = None;

        for _ in 0..len {
            let (id, _ext) = aper::decode::decode_integer(data, Some(0), Some(65535), false)?;
            let criticality = Criticality::decode(data)?;
            let _length = aper::decode::decode_length_determinent(data, None, None, false)?;
            match id {
                10 => {
                    amf_ue_ngap_id = Some(AmfUeNgapId::decode(data)?);
                }
                85 => {
                    ran_ue_ngap_id = Some(RanUeNgapId::decode(data)?);
                }
                84 => {
                    ran_status_transfer_transparent_container =
                        Some(RanStatusTransferTransparentContainer::decode(data)?);
                }
                x => {
                    if let Criticality::Reject = criticality {
                        return Err(aper::AperCodecError::new(format!(
                            "Unrecognised IE type {} with criticality reject",
                            x
                        )));
                    }
                }
            }
        }
        let amf_ue_ngap_id = amf_ue_ngap_id.ok_or(aper::AperCodecError::new(format!(
            "Missing mandatory IE amf_ue_ngap_id"
        )))?;
        let ran_ue_ngap_id = ran_ue_ngap_id.ok_or(aper::AperCodecError::new(format!(
            "Missing mandatory IE ran_ue_ngap_id"
        )))?;
        let ran_status_transfer_transparent_container = ran_status_transfer_transparent_container
            .ok_or(aper::AperCodecError::new(
            format!("Missing mandatory IE ran_status_transfer_transparent_container"),
        ))?;
        Ok(Self {
            amf_ue_ngap_id,
            ran_ue_ngap_id,
            ran_status_transfer_transparent_container,
        })
    }
}

// Paging
#[derive(Clone)]
pub struct Paging {
    pub ue_paging_identity: UePagingIdentity,
    pub paging_drx: Option<PagingDrx>,
    pub tai_list_for_paging: TaiListForPaging,
    pub paging_priority: Option<PagingPriority>,
    pub ue_radio_capability_for_paging: Option<UeRadioCapabilityForPaging>,
    pub paging_origin: Option<PagingOrigin>,
    pub assistance_data_for_paging: Option<AssistanceDataForPaging>,
    pub nb_iot_paging_e_drx_info: Option<NbIotPagingEDrxInfo>,
    pub nb_iot_paging_drx: Option<NbIotPagingDrx>,
    pub enhanced_coverage_restriction: Option<EnhancedCoverageRestriction>,
    pub wus_assistance_information: Option<WusAssistanceInformation>,
    pub paginge_drx_information: Option<PagingeDrxInformation>,
    pub c_emode_brestricted: Option<CEmodeBrestricted>,
}

impl AperCodec for Paging {
    type Output = Paging;
    fn decode(data: &mut AperCodecData) -> Result<Self::Output, AperCodecError> {
        let _length = aper::decode::decode_length_determinent(data, None, None, false)?;
        let _ = aper::decode::decode_sequence_header(data, true, 0)?;
        let len = aper::decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut ue_paging_identity: Option<UePagingIdentity> = None;
        let mut paging_drx: Option<PagingDrx> = None;
        let mut tai_list_for_paging: Option<TaiListForPaging> = None;
        let mut paging_priority: Option<PagingPriority> = None;
        let mut ue_radio_capability_for_paging: Option<UeRadioCapabilityForPaging> = None;
        let mut paging_origin: Option<PagingOrigin> = None;
        let mut assistance_data_for_paging: Option<AssistanceDataForPaging> = None;
        let mut nb_iot_paging_e_drx_info: Option<NbIotPagingEDrxInfo> = None;
        let mut nb_iot_paging_drx: Option<NbIotPagingDrx> = None;
        let mut enhanced_coverage_restriction: Option<EnhancedCoverageRestriction> = None;
        let mut wus_assistance_information: Option<WusAssistanceInformation> = None;
        let mut paginge_drx_information: Option<PagingeDrxInformation> = None;
        let mut c_emode_brestricted: Option<CEmodeBrestricted> = None;

        for _ in 0..len {
            let (id, _ext) = aper::decode::decode_integer(data, Some(0), Some(65535), false)?;
            let criticality = Criticality::decode(data)?;
            let _length = aper::decode::decode_length_determinent(data, None, None, false)?;
            match id {
                115 => {
                    ue_paging_identity = Some(UePagingIdentity::decode(data)?);
                }
                50 => {
                    paging_drx = Some(PagingDrx::decode(data)?);
                }
                103 => {
                    tai_list_for_paging = Some(TaiListForPaging::decode(data)?);
                }
                52 => {
                    paging_priority = Some(PagingPriority::decode(data)?);
                }
                118 => {
                    ue_radio_capability_for_paging =
                        Some(UeRadioCapabilityForPaging::decode(data)?);
                }
                51 => {
                    paging_origin = Some(PagingOrigin::decode(data)?);
                }
                11 => {
                    assistance_data_for_paging = Some(AssistanceDataForPaging::decode(data)?);
                }
                203 => {
                    nb_iot_paging_e_drx_info = Some(NbIotPagingEDrxInfo::decode(data)?);
                }
                202 => {
                    nb_iot_paging_drx = Some(NbIotPagingDrx::decode(data)?);
                }
                205 => {
                    enhanced_coverage_restriction =
                        Some(EnhancedCoverageRestriction::decode(data)?);
                }
                208 => {
                    wus_assistance_information = Some(WusAssistanceInformation::decode(data)?);
                }
                223 => {
                    paginge_drx_information = Some(PagingeDrxInformation::decode(data)?);
                }
                222 => {
                    c_emode_brestricted = Some(CEmodeBrestricted::decode(data)?);
                }
                x => {
                    if let Criticality::Reject = criticality {
                        return Err(aper::AperCodecError::new(format!(
                            "Unrecognised IE type {} with criticality reject",
                            x
                        )));
                    }
                }
            }
        }
        let ue_paging_identity = ue_paging_identity.ok_or(aper::AperCodecError::new(format!(
            "Missing mandatory IE ue_paging_identity"
        )))?;
        let tai_list_for_paging = tai_list_for_paging.ok_or(aper::AperCodecError::new(format!(
            "Missing mandatory IE tai_list_for_paging"
        )))?;
        Ok(Self {
            ue_paging_identity,
            paging_drx,
            tai_list_for_paging,
            paging_priority,
            ue_radio_capability_for_paging,
            paging_origin,
            assistance_data_for_paging,
            nb_iot_paging_e_drx_info,
            nb_iot_paging_drx,
            enhanced_coverage_restriction,
            wus_assistance_information,
            paginge_drx_information,
            c_emode_brestricted,
        })
    }
}

// InitialUeMessage
#[derive(Clone)]
pub struct InitialUeMessage {
    pub ran_ue_ngap_id: RanUeNgapId,
    pub nas_pdu: NasPdu,
    pub user_location_information: UserLocationInformation,
    pub rrc_establishment_cause: RrcEstablishmentCause,
    pub five_g_s_tmsi: Option<FiveGSTmsi>,
    pub amf_set_id: Option<AmfSetId>,
    pub ue_context_request: Option<UeContextRequest>,
    pub allowed_nssai: Option<AllowedNssai>,
    pub source_to_target_amf_information_reroute: Option<SourceToTargetAmfInformationReroute>,
    pub selected_plmn_identity: Option<PlmnIdentity>,
    pub iab_node_indication: Option<IabNodeIndication>,
    pub c_emode_b_support_indicator: Option<CEmodeBSupportIndicator>,
    pub ltem_indication: Option<LtemIndication>,
    pub edt_session: Option<EdtSession>,
    pub authenticated_indication: Option<AuthenticatedIndication>,
    pub npn_access_information: Option<NpnAccessInformation>,
}

impl AperCodec for InitialUeMessage {
    type Output = InitialUeMessage;
    fn decode(data: &mut AperCodecData) -> Result<Self::Output, AperCodecError> {
        let _length = aper::decode::decode_length_determinent(data, None, None, false)?;
        let _ = aper::decode::decode_sequence_header(data, true, 0)?;
        let len = aper::decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut ran_ue_ngap_id: Option<RanUeNgapId> = None;
        let mut nas_pdu: Option<NasPdu> = None;
        let mut user_location_information: Option<UserLocationInformation> = None;
        let mut rrc_establishment_cause: Option<RrcEstablishmentCause> = None;
        let mut five_g_s_tmsi: Option<FiveGSTmsi> = None;
        let mut amf_set_id: Option<AmfSetId> = None;
        let mut ue_context_request: Option<UeContextRequest> = None;
        let mut allowed_nssai: Option<AllowedNssai> = None;
        let mut source_to_target_amf_information_reroute: Option<
            SourceToTargetAmfInformationReroute,
        > = None;
        let mut selected_plmn_identity: Option<PlmnIdentity> = None;
        let mut iab_node_indication: Option<IabNodeIndication> = None;
        let mut c_emode_b_support_indicator: Option<CEmodeBSupportIndicator> = None;
        let mut ltem_indication: Option<LtemIndication> = None;
        let mut edt_session: Option<EdtSession> = None;
        let mut authenticated_indication: Option<AuthenticatedIndication> = None;
        let mut npn_access_information: Option<NpnAccessInformation> = None;

        for _ in 0..len {
            let (id, _ext) = aper::decode::decode_integer(data, Some(0), Some(65535), false)?;
            let criticality = Criticality::decode(data)?;
            let _length = aper::decode::decode_length_determinent(data, None, None, false)?;
            match id {
                85 => {
                    ran_ue_ngap_id = Some(RanUeNgapId::decode(data)?);
                }
                38 => {
                    nas_pdu = Some(NasPdu::decode(data)?);
                }
                121 => {
                    user_location_information = Some(UserLocationInformation::decode(data)?);
                }
                90 => {
                    rrc_establishment_cause = Some(RrcEstablishmentCause::decode(data)?);
                }
                26 => {
                    five_g_s_tmsi = Some(FiveGSTmsi::decode(data)?);
                }
                3 => {
                    amf_set_id = Some(AmfSetId::decode(data)?);
                }
                112 => {
                    ue_context_request = Some(UeContextRequest::decode(data)?);
                }
                0 => {
                    allowed_nssai = Some(AllowedNssai::decode(data)?);
                }
                171 => {
                    source_to_target_amf_information_reroute =
                        Some(SourceToTargetAmfInformationReroute::decode(data)?);
                }
                174 => {
                    selected_plmn_identity = Some(PlmnIdentity::decode(data)?);
                }
                201 => {
                    iab_node_indication = Some(IabNodeIndication::decode(data)?);
                }
                224 => {
                    c_emode_b_support_indicator = Some(CEmodeBSupportIndicator::decode(data)?);
                }
                225 => {
                    ltem_indication = Some(LtemIndication::decode(data)?);
                }
                227 => {
                    edt_session = Some(EdtSession::decode(data)?);
                }
                245 => {
                    authenticated_indication = Some(AuthenticatedIndication::decode(data)?);
                }
                259 => {
                    npn_access_information = Some(NpnAccessInformation::decode(data)?);
                }
                x => {
                    if let Criticality::Reject = criticality {
                        return Err(aper::AperCodecError::new(format!(
                            "Unrecognised IE type {} with criticality reject",
                            x
                        )));
                    }
                }
            }
        }
        let ran_ue_ngap_id = ran_ue_ngap_id.ok_or(aper::AperCodecError::new(format!(
            "Missing mandatory IE ran_ue_ngap_id"
        )))?;
        let nas_pdu = nas_pdu.ok_or(aper::AperCodecError::new(format!(
            "Missing mandatory IE nas_pdu"
        )))?;
        let user_location_information = user_location_information.ok_or(
            aper::AperCodecError::new(format!("Missing mandatory IE user_location_information")),
        )?;
        let rrc_establishment_cause = rrc_establishment_cause.ok_or(aper::AperCodecError::new(
            format!("Missing mandatory IE rrc_establishment_cause"),
        ))?;
        Ok(Self {
            ran_ue_ngap_id,
            nas_pdu,
            user_location_information,
            rrc_establishment_cause,
            five_g_s_tmsi,
            amf_set_id,
            ue_context_request,
            allowed_nssai,
            source_to_target_amf_information_reroute,
            selected_plmn_identity,
            iab_node_indication,
            c_emode_b_support_indicator,
            ltem_indication,
            edt_session,
            authenticated_indication,
            npn_access_information,
        })
    }
}

// DownlinkNasTransport
#[derive(Clone)]
pub struct DownlinkNasTransport {
    pub amf_ue_ngap_id: AmfUeNgapId,
    pub ran_ue_ngap_id: RanUeNgapId,
    pub old_amf: Option<AmfName>,
    pub ran_paging_priority: Option<RanPagingPriority>,
    pub nas_pdu: NasPdu,
    pub mobility_restriction_list: Option<MobilityRestrictionList>,
    pub index_to_rfsp: Option<IndexToRfsp>,
    pub ue_aggregate_maximum_bit_rate: Option<UeAggregateMaximumBitRate>,
    pub allowed_nssai: Option<AllowedNssai>,
    pub srvcc_operation_possible: Option<SrvccOperationPossible>,
    pub enhanced_coverage_restriction: Option<EnhancedCoverageRestriction>,
    pub extended_connected_time: Option<ExtendedConnectedTime>,
    pub ue_differentiation_info: Option<UeDifferentiationInfo>,
    pub c_emode_brestricted: Option<CEmodeBrestricted>,
    pub ue_radio_capability: Option<UeRadioCapability>,
    pub ue_capability_info_request: Option<UeCapabilityInfoRequest>,
    pub end_indication: Option<EndIndication>,
    pub ue_radio_capability_id: Option<UeRadioCapabilityId>,
}

impl AperCodec for DownlinkNasTransport {
    type Output = DownlinkNasTransport;
    fn decode(data: &mut AperCodecData) -> Result<Self::Output, AperCodecError> {
        let _length = aper::decode::decode_length_determinent(data, None, None, false)?;
        let _ = aper::decode::decode_sequence_header(data, true, 0)?;
        let len = aper::decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut amf_ue_ngap_id: Option<AmfUeNgapId> = None;
        let mut ran_ue_ngap_id: Option<RanUeNgapId> = None;
        let mut old_amf: Option<AmfName> = None;
        let mut ran_paging_priority: Option<RanPagingPriority> = None;
        let mut nas_pdu: Option<NasPdu> = None;
        let mut mobility_restriction_list: Option<MobilityRestrictionList> = None;
        let mut index_to_rfsp: Option<IndexToRfsp> = None;
        let mut ue_aggregate_maximum_bit_rate: Option<UeAggregateMaximumBitRate> = None;
        let mut allowed_nssai: Option<AllowedNssai> = None;
        let mut srvcc_operation_possible: Option<SrvccOperationPossible> = None;
        let mut enhanced_coverage_restriction: Option<EnhancedCoverageRestriction> = None;
        let mut extended_connected_time: Option<ExtendedConnectedTime> = None;
        let mut ue_differentiation_info: Option<UeDifferentiationInfo> = None;
        let mut c_emode_brestricted: Option<CEmodeBrestricted> = None;
        let mut ue_radio_capability: Option<UeRadioCapability> = None;
        let mut ue_capability_info_request: Option<UeCapabilityInfoRequest> = None;
        let mut end_indication: Option<EndIndication> = None;
        let mut ue_radio_capability_id: Option<UeRadioCapabilityId> = None;

        for _ in 0..len {
            let (id, _ext) = aper::decode::decode_integer(data, Some(0), Some(65535), false)?;
            let criticality = Criticality::decode(data)?;
            let _length = aper::decode::decode_length_determinent(data, None, None, false)?;
            match id {
                10 => {
                    amf_ue_ngap_id = Some(AmfUeNgapId::decode(data)?);
                }
                85 => {
                    ran_ue_ngap_id = Some(RanUeNgapId::decode(data)?);
                }
                48 => {
                    old_amf = Some(AmfName::decode(data)?);
                }
                83 => {
                    ran_paging_priority = Some(RanPagingPriority::decode(data)?);
                }
                38 => {
                    nas_pdu = Some(NasPdu::decode(data)?);
                }
                36 => {
                    mobility_restriction_list = Some(MobilityRestrictionList::decode(data)?);
                }
                31 => {
                    index_to_rfsp = Some(IndexToRfsp::decode(data)?);
                }
                110 => {
                    ue_aggregate_maximum_bit_rate = Some(UeAggregateMaximumBitRate::decode(data)?);
                }
                0 => {
                    allowed_nssai = Some(AllowedNssai::decode(data)?);
                }
                177 => {
                    srvcc_operation_possible = Some(SrvccOperationPossible::decode(data)?);
                }
                205 => {
                    enhanced_coverage_restriction =
                        Some(EnhancedCoverageRestriction::decode(data)?);
                }
                206 => {
                    extended_connected_time = Some(ExtendedConnectedTime::decode(data)?);
                }
                209 => {
                    ue_differentiation_info = Some(UeDifferentiationInfo::decode(data)?);
                }
                222 => {
                    c_emode_brestricted = Some(CEmodeBrestricted::decode(data)?);
                }
                117 => {
                    ue_radio_capability = Some(UeRadioCapability::decode(data)?);
                }
                228 => {
                    ue_capability_info_request = Some(UeCapabilityInfoRequest::decode(data)?);
                }
                226 => {
                    end_indication = Some(EndIndication::decode(data)?);
                }
                264 => {
                    ue_radio_capability_id = Some(UeRadioCapabilityId::decode(data)?);
                }
                x => {
                    if let Criticality::Reject = criticality {
                        return Err(aper::AperCodecError::new(format!(
                            "Unrecognised IE type {} with criticality reject",
                            x
                        )));
                    }
                }
            }
        }
        let amf_ue_ngap_id = amf_ue_ngap_id.ok_or(aper::AperCodecError::new(format!(
            "Missing mandatory IE amf_ue_ngap_id"
        )))?;
        let ran_ue_ngap_id = ran_ue_ngap_id.ok_or(aper::AperCodecError::new(format!(
            "Missing mandatory IE ran_ue_ngap_id"
        )))?;
        let nas_pdu = nas_pdu.ok_or(aper::AperCodecError::new(format!(
            "Missing mandatory IE nas_pdu"
        )))?;
        Ok(Self {
            amf_ue_ngap_id,
            ran_ue_ngap_id,
            old_amf,
            ran_paging_priority,
            nas_pdu,
            mobility_restriction_list,
            index_to_rfsp,
            ue_aggregate_maximum_bit_rate,
            allowed_nssai,
            srvcc_operation_possible,
            enhanced_coverage_restriction,
            extended_connected_time,
            ue_differentiation_info,
            c_emode_brestricted,
            ue_radio_capability,
            ue_capability_info_request,
            end_indication,
            ue_radio_capability_id,
        })
    }
}

// UplinkNasTransport
#[derive(Clone)]
pub struct UplinkNasTransport {
    pub amf_ue_ngap_id: AmfUeNgapId,
    pub ran_ue_ngap_id: RanUeNgapId,
    pub nas_pdu: NasPdu,
    pub user_location_information: UserLocationInformation,
    pub w_agf_identity_information: Option<Vec<u8>>,
    pub tngf_identity_information: Option<Vec<u8>>,
    pub twif_identity_information: Option<Vec<u8>>,
}

impl AperCodec for UplinkNasTransport {
    type Output = UplinkNasTransport;
    fn decode(data: &mut AperCodecData) -> Result<Self::Output, AperCodecError> {
        let _length = aper::decode::decode_length_determinent(data, None, None, false)?;
        let _ = aper::decode::decode_sequence_header(data, true, 0)?;
        let len = aper::decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut amf_ue_ngap_id: Option<AmfUeNgapId> = None;
        let mut ran_ue_ngap_id: Option<RanUeNgapId> = None;
        let mut nas_pdu: Option<NasPdu> = None;
        let mut user_location_information: Option<UserLocationInformation> = None;
        let mut w_agf_identity_information: Option<Vec<u8>> = None;
        let mut tngf_identity_information: Option<Vec<u8>> = None;
        let mut twif_identity_information: Option<Vec<u8>> = None;

        for _ in 0..len {
            let (id, _ext) = aper::decode::decode_integer(data, Some(0), Some(65535), false)?;
            let criticality = Criticality::decode(data)?;
            let _length = aper::decode::decode_length_determinent(data, None, None, false)?;
            match id {
                10 => {
                    amf_ue_ngap_id = Some(AmfUeNgapId::decode(data)?);
                }
                85 => {
                    ran_ue_ngap_id = Some(RanUeNgapId::decode(data)?);
                }
                38 => {
                    nas_pdu = Some(NasPdu::decode(data)?);
                }
                121 => {
                    user_location_information = Some(UserLocationInformation::decode(data)?);
                }
                239 => {
                    w_agf_identity_information =
                        Some(aper::decode::decode_octetstring(data, None, None, false)?);
                }
                246 => {
                    tngf_identity_information =
                        Some(aper::decode::decode_octetstring(data, None, None, false)?);
                }
                247 => {
                    twif_identity_information =
                        Some(aper::decode::decode_octetstring(data, None, None, false)?);
                }
                x => {
                    if let Criticality::Reject = criticality {
                        return Err(aper::AperCodecError::new(format!(
                            "Unrecognised IE type {} with criticality reject",
                            x
                        )));
                    }
                }
            }
        }
        let amf_ue_ngap_id = amf_ue_ngap_id.ok_or(aper::AperCodecError::new(format!(
            "Missing mandatory IE amf_ue_ngap_id"
        )))?;
        let ran_ue_ngap_id = ran_ue_ngap_id.ok_or(aper::AperCodecError::new(format!(
            "Missing mandatory IE ran_ue_ngap_id"
        )))?;
        let nas_pdu = nas_pdu.ok_or(aper::AperCodecError::new(format!(
            "Missing mandatory IE nas_pdu"
        )))?;
        let user_location_information = user_location_information.ok_or(
            aper::AperCodecError::new(format!("Missing mandatory IE user_location_information")),
        )?;
        Ok(Self {
            amf_ue_ngap_id,
            ran_ue_ngap_id,
            nas_pdu,
            user_location_information,
            w_agf_identity_information,
            tngf_identity_information,
            twif_identity_information,
        })
    }
}

// NasNonDeliveryIndication
#[derive(Clone)]
pub struct NasNonDeliveryIndication {
    pub amf_ue_ngap_id: AmfUeNgapId,
    pub ran_ue_ngap_id: RanUeNgapId,
    pub nas_pdu: NasPdu,
    pub cause: Cause,
}

impl AperCodec for NasNonDeliveryIndication {
    type Output = NasNonDeliveryIndication;
    fn decode(data: &mut AperCodecData) -> Result<Self::Output, AperCodecError> {
        let _length = aper::decode::decode_length_determinent(data, None, None, false)?;
        let _ = aper::decode::decode_sequence_header(data, true, 0)?;
        let len = aper::decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut amf_ue_ngap_id: Option<AmfUeNgapId> = None;
        let mut ran_ue_ngap_id: Option<RanUeNgapId> = None;
        let mut nas_pdu: Option<NasPdu> = None;
        let mut cause: Option<Cause> = None;

        for _ in 0..len {
            let (id, _ext) = aper::decode::decode_integer(data, Some(0), Some(65535), false)?;
            let criticality = Criticality::decode(data)?;
            let _length = aper::decode::decode_length_determinent(data, None, None, false)?;
            match id {
                10 => {
                    amf_ue_ngap_id = Some(AmfUeNgapId::decode(data)?);
                }
                85 => {
                    ran_ue_ngap_id = Some(RanUeNgapId::decode(data)?);
                }
                38 => {
                    nas_pdu = Some(NasPdu::decode(data)?);
                }
                15 => {
                    cause = Some(Cause::decode(data)?);
                }
                x => {
                    if let Criticality::Reject = criticality {
                        return Err(aper::AperCodecError::new(format!(
                            "Unrecognised IE type {} with criticality reject",
                            x
                        )));
                    }
                }
            }
        }
        let amf_ue_ngap_id = amf_ue_ngap_id.ok_or(aper::AperCodecError::new(format!(
            "Missing mandatory IE amf_ue_ngap_id"
        )))?;
        let ran_ue_ngap_id = ran_ue_ngap_id.ok_or(aper::AperCodecError::new(format!(
            "Missing mandatory IE ran_ue_ngap_id"
        )))?;
        let nas_pdu = nas_pdu.ok_or(aper::AperCodecError::new(format!(
            "Missing mandatory IE nas_pdu"
        )))?;
        let cause = cause.ok_or(aper::AperCodecError::new(format!(
            "Missing mandatory IE cause"
        )))?;
        Ok(Self {
            amf_ue_ngap_id,
            ran_ue_ngap_id,
            nas_pdu,
            cause,
        })
    }
}

// RerouteNasRequest
#[derive(Clone)]
pub struct RerouteNasRequest {
    pub ran_ue_ngap_id: RanUeNgapId,
    pub amf_ue_ngap_id: Option<AmfUeNgapId>,
    pub ngap_message: Vec<u8>,
    pub amf_set_id: AmfSetId,
    pub allowed_nssai: Option<AllowedNssai>,
    pub source_to_target_amf_information_reroute: Option<SourceToTargetAmfInformationReroute>,
}

impl AperCodec for RerouteNasRequest {
    type Output = RerouteNasRequest;
    fn decode(data: &mut AperCodecData) -> Result<Self::Output, AperCodecError> {
        let _length = aper::decode::decode_length_determinent(data, None, None, false)?;
        let _ = aper::decode::decode_sequence_header(data, true, 0)?;
        let len = aper::decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut ran_ue_ngap_id: Option<RanUeNgapId> = None;
        let mut amf_ue_ngap_id: Option<AmfUeNgapId> = None;
        let mut ngap_message: Option<Vec<u8>> = None;
        let mut amf_set_id: Option<AmfSetId> = None;
        let mut allowed_nssai: Option<AllowedNssai> = None;
        let mut source_to_target_amf_information_reroute: Option<
            SourceToTargetAmfInformationReroute,
        > = None;

        for _ in 0..len {
            let (id, _ext) = aper::decode::decode_integer(data, Some(0), Some(65535), false)?;
            let criticality = Criticality::decode(data)?;
            let _length = aper::decode::decode_length_determinent(data, None, None, false)?;
            match id {
                85 => {
                    ran_ue_ngap_id = Some(RanUeNgapId::decode(data)?);
                }
                10 => {
                    amf_ue_ngap_id = Some(AmfUeNgapId::decode(data)?);
                }
                42 => {
                    ngap_message = Some(aper::decode::decode_octetstring(data, None, None, false)?);
                }
                3 => {
                    amf_set_id = Some(AmfSetId::decode(data)?);
                }
                0 => {
                    allowed_nssai = Some(AllowedNssai::decode(data)?);
                }
                171 => {
                    source_to_target_amf_information_reroute =
                        Some(SourceToTargetAmfInformationReroute::decode(data)?);
                }
                x => {
                    if let Criticality::Reject = criticality {
                        return Err(aper::AperCodecError::new(format!(
                            "Unrecognised IE type {} with criticality reject",
                            x
                        )));
                    }
                }
            }
        }
        let ran_ue_ngap_id = ran_ue_ngap_id.ok_or(aper::AperCodecError::new(format!(
            "Missing mandatory IE ran_ue_ngap_id"
        )))?;
        let ngap_message = ngap_message.ok_or(aper::AperCodecError::new(format!(
            "Missing mandatory IE ngap_message"
        )))?;
        let amf_set_id = amf_set_id.ok_or(aper::AperCodecError::new(format!(
            "Missing mandatory IE amf_set_id"
        )))?;
        Ok(Self {
            ran_ue_ngap_id,
            amf_ue_ngap_id,
            ngap_message,
            amf_set_id,
            allowed_nssai,
            source_to_target_amf_information_reroute,
        })
    }
}

// NgSetupRequest
#[derive(Clone)]
pub struct NgSetupRequest {
    pub global_ran_node_id: GlobalRanNodeId,
    pub ran_node_name: Option<RanNodeName>,
    pub supported_ta_list: SupportedTaList,
    pub default_paging_drx: PagingDrx,
    pub ue_retention_information: Option<UeRetentionInformation>,
    pub nb_iot_default_paging_drx: Option<NbIotDefaultPagingDrx>,
    pub extended_ran_node_name: Option<ExtendedRanNodeName>,
}

impl AperCodec for NgSetupRequest {
    type Output = NgSetupRequest;
    fn decode(data: &mut AperCodecData) -> Result<Self::Output, AperCodecError> {
        let _length = aper::decode::decode_length_determinent(data, None, None, false)?;
        let _ = aper::decode::decode_sequence_header(data, true, 0)?;
        let len = aper::decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut global_ran_node_id: Option<GlobalRanNodeId> = None;
        let mut ran_node_name: Option<RanNodeName> = None;
        let mut supported_ta_list: Option<SupportedTaList> = None;
        let mut default_paging_drx: Option<PagingDrx> = None;
        let mut ue_retention_information: Option<UeRetentionInformation> = None;
        let mut nb_iot_default_paging_drx: Option<NbIotDefaultPagingDrx> = None;
        let mut extended_ran_node_name: Option<ExtendedRanNodeName> = None;

        for _ in 0..len {
            let (id, _ext) = aper::decode::decode_integer(data, Some(0), Some(65535), false)?;
            let criticality = Criticality::decode(data)?;
            let _length = aper::decode::decode_length_determinent(data, None, None, false)?;
            match id {
                27 => {
                    global_ran_node_id = Some(GlobalRanNodeId::decode(data)?);
                }
                82 => {
                    ran_node_name = Some(RanNodeName::decode(data)?);
                }
                102 => {
                    supported_ta_list = Some(SupportedTaList::decode(data)?);
                }
                21 => {
                    default_paging_drx = Some(PagingDrx::decode(data)?);
                }
                147 => {
                    ue_retention_information = Some(UeRetentionInformation::decode(data)?);
                }
                204 => {
                    nb_iot_default_paging_drx = Some(NbIotDefaultPagingDrx::decode(data)?);
                }
                273 => {
                    extended_ran_node_name = Some(ExtendedRanNodeName::decode(data)?);
                }
                x => {
                    if let Criticality::Reject = criticality {
                        return Err(aper::AperCodecError::new(format!(
                            "Unrecognised IE type {} with criticality reject",
                            x
                        )));
                    }
                }
            }
        }
        let global_ran_node_id = global_ran_node_id.ok_or(aper::AperCodecError::new(format!(
            "Missing mandatory IE global_ran_node_id"
        )))?;
        let supported_ta_list = supported_ta_list.ok_or(aper::AperCodecError::new(format!(
            "Missing mandatory IE supported_ta_list"
        )))?;
        let default_paging_drx = default_paging_drx.ok_or(aper::AperCodecError::new(format!(
            "Missing mandatory IE default_paging_drx"
        )))?;
        Ok(Self {
            global_ran_node_id,
            ran_node_name,
            supported_ta_list,
            default_paging_drx,
            ue_retention_information,
            nb_iot_default_paging_drx,
            extended_ran_node_name,
        })
    }
}

// NgSetupResponse
#[derive(Clone)]
pub struct NgSetupResponse {
    pub amf_name: AmfName,
    pub served_guami_list: ServedGuamiList,
    pub relative_amf_capacity: RelativeAmfCapacity,
    pub plmn_support_list: PlmnSupportList,
    pub criticality_diagnostics: Option<CriticalityDiagnostics>,
    pub ue_retention_information: Option<UeRetentionInformation>,
    pub iab_supported: Option<IabSupported>,
    pub extended_amf_name: Option<ExtendedAmfName>,
}

impl AperCodec for NgSetupResponse {
    type Output = NgSetupResponse;
    fn decode(data: &mut AperCodecData) -> Result<Self::Output, AperCodecError> {
        let _length = aper::decode::decode_length_determinent(data, None, None, false)?;
        let _ = aper::decode::decode_sequence_header(data, true, 0)?;
        let len = aper::decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut amf_name: Option<AmfName> = None;
        let mut served_guami_list: Option<ServedGuamiList> = None;
        let mut relative_amf_capacity: Option<RelativeAmfCapacity> = None;
        let mut plmn_support_list: Option<PlmnSupportList> = None;
        let mut criticality_diagnostics: Option<CriticalityDiagnostics> = None;
        let mut ue_retention_information: Option<UeRetentionInformation> = None;
        let mut iab_supported: Option<IabSupported> = None;
        let mut extended_amf_name: Option<ExtendedAmfName> = None;

        for _ in 0..len {
            let (id, _ext) = aper::decode::decode_integer(data, Some(0), Some(65535), false)?;
            let criticality = Criticality::decode(data)?;
            let _length = aper::decode::decode_length_determinent(data, None, None, false)?;
            match id {
                1 => {
                    amf_name = Some(AmfName::decode(data)?);
                }
                96 => {
                    served_guami_list = Some(ServedGuamiList::decode(data)?);
                }
                86 => {
                    relative_amf_capacity = Some(RelativeAmfCapacity::decode(data)?);
                }
                80 => {
                    plmn_support_list = Some(PlmnSupportList::decode(data)?);
                }
                19 => {
                    criticality_diagnostics = Some(CriticalityDiagnostics::decode(data)?);
                }
                147 => {
                    ue_retention_information = Some(UeRetentionInformation::decode(data)?);
                }
                200 => {
                    iab_supported = Some(IabSupported::decode(data)?);
                }
                274 => {
                    extended_amf_name = Some(ExtendedAmfName::decode(data)?);
                }
                x => {
                    if let Criticality::Reject = criticality {
                        return Err(aper::AperCodecError::new(format!(
                            "Unrecognised IE type {} with criticality reject",
                            x
                        )));
                    }
                }
            }
        }
        let amf_name = amf_name.ok_or(aper::AperCodecError::new(format!(
            "Missing mandatory IE amf_name"
        )))?;
        let served_guami_list = served_guami_list.ok_or(aper::AperCodecError::new(format!(
            "Missing mandatory IE served_guami_list"
        )))?;
        let relative_amf_capacity = relative_amf_capacity.ok_or(aper::AperCodecError::new(
            format!("Missing mandatory IE relative_amf_capacity"),
        ))?;
        let plmn_support_list = plmn_support_list.ok_or(aper::AperCodecError::new(format!(
            "Missing mandatory IE plmn_support_list"
        )))?;
        Ok(Self {
            amf_name,
            served_guami_list,
            relative_amf_capacity,
            plmn_support_list,
            criticality_diagnostics,
            ue_retention_information,
            iab_supported,
            extended_amf_name,
        })
    }
}

// NgSetupFailure
#[derive(Clone)]
pub struct NgSetupFailure {
    pub cause: Cause,
    pub time_to_wait: Option<TimeToWait>,
    pub criticality_diagnostics: Option<CriticalityDiagnostics>,
}

impl AperCodec for NgSetupFailure {
    type Output = NgSetupFailure;
    fn decode(data: &mut AperCodecData) -> Result<Self::Output, AperCodecError> {
        let _length = aper::decode::decode_length_determinent(data, None, None, false)?;
        let _ = aper::decode::decode_sequence_header(data, true, 0)?;
        let len = aper::decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut cause: Option<Cause> = None;
        let mut time_to_wait: Option<TimeToWait> = None;
        let mut criticality_diagnostics: Option<CriticalityDiagnostics> = None;

        for _ in 0..len {
            let (id, _ext) = aper::decode::decode_integer(data, Some(0), Some(65535), false)?;
            let criticality = Criticality::decode(data)?;
            let _length = aper::decode::decode_length_determinent(data, None, None, false)?;
            match id {
                15 => {
                    cause = Some(Cause::decode(data)?);
                }
                107 => {
                    time_to_wait = Some(TimeToWait::decode(data)?);
                }
                19 => {
                    criticality_diagnostics = Some(CriticalityDiagnostics::decode(data)?);
                }
                x => {
                    if let Criticality::Reject = criticality {
                        return Err(aper::AperCodecError::new(format!(
                            "Unrecognised IE type {} with criticality reject",
                            x
                        )));
                    }
                }
            }
        }
        let cause = cause.ok_or(aper::AperCodecError::new(format!(
            "Missing mandatory IE cause"
        )))?;
        Ok(Self {
            cause,
            time_to_wait,
            criticality_diagnostics,
        })
    }
}

// RanConfigurationUpdate
#[derive(Clone)]
pub struct RanConfigurationUpdate {
    pub ran_node_name: Option<RanNodeName>,
    pub supported_ta_list: Option<SupportedTaList>,
    pub default_paging_drx: Option<PagingDrx>,
    pub global_ran_node_id: Option<GlobalRanNodeId>,
    pub ngran_tnl_association_to_remove_list: Option<NgranTnlAssociationToRemoveList>,
    pub nb_iot_default_paging_drx: Option<NbIotDefaultPagingDrx>,
    pub extended_ran_node_name: Option<ExtendedRanNodeName>,
}

impl AperCodec for RanConfigurationUpdate {
    type Output = RanConfigurationUpdate;
    fn decode(data: &mut AperCodecData) -> Result<Self::Output, AperCodecError> {
        let _length = aper::decode::decode_length_determinent(data, None, None, false)?;
        let _ = aper::decode::decode_sequence_header(data, true, 0)?;
        let len = aper::decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut ran_node_name: Option<RanNodeName> = None;
        let mut supported_ta_list: Option<SupportedTaList> = None;
        let mut default_paging_drx: Option<PagingDrx> = None;
        let mut global_ran_node_id: Option<GlobalRanNodeId> = None;
        let mut ngran_tnl_association_to_remove_list: Option<NgranTnlAssociationToRemoveList> =
            None;
        let mut nb_iot_default_paging_drx: Option<NbIotDefaultPagingDrx> = None;
        let mut extended_ran_node_name: Option<ExtendedRanNodeName> = None;

        for _ in 0..len {
            let (id, _ext) = aper::decode::decode_integer(data, Some(0), Some(65535), false)?;
            let criticality = Criticality::decode(data)?;
            let _length = aper::decode::decode_length_determinent(data, None, None, false)?;
            match id {
                82 => {
                    ran_node_name = Some(RanNodeName::decode(data)?);
                }
                102 => {
                    supported_ta_list = Some(SupportedTaList::decode(data)?);
                }
                21 => {
                    default_paging_drx = Some(PagingDrx::decode(data)?);
                }
                27 => {
                    global_ran_node_id = Some(GlobalRanNodeId::decode(data)?);
                }
                167 => {
                    ngran_tnl_association_to_remove_list =
                        Some(NgranTnlAssociationToRemoveList::decode(data)?);
                }
                204 => {
                    nb_iot_default_paging_drx = Some(NbIotDefaultPagingDrx::decode(data)?);
                }
                273 => {
                    extended_ran_node_name = Some(ExtendedRanNodeName::decode(data)?);
                }
                x => {
                    if let Criticality::Reject = criticality {
                        return Err(aper::AperCodecError::new(format!(
                            "Unrecognised IE type {} with criticality reject",
                            x
                        )));
                    }
                }
            }
        }
        Ok(Self {
            ran_node_name,
            supported_ta_list,
            default_paging_drx,
            global_ran_node_id,
            ngran_tnl_association_to_remove_list,
            nb_iot_default_paging_drx,
            extended_ran_node_name,
        })
    }
}

// RanConfigurationUpdateAcknowledge
#[derive(Clone)]
pub struct RanConfigurationUpdateAcknowledge {
    pub criticality_diagnostics: Option<CriticalityDiagnostics>,
}

impl AperCodec for RanConfigurationUpdateAcknowledge {
    type Output = RanConfigurationUpdateAcknowledge;
    fn decode(data: &mut AperCodecData) -> Result<Self::Output, AperCodecError> {
        let _length = aper::decode::decode_length_determinent(data, None, None, false)?;
        let _ = aper::decode::decode_sequence_header(data, true, 0)?;
        let len = aper::decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut criticality_diagnostics: Option<CriticalityDiagnostics> = None;

        for _ in 0..len {
            let (id, _ext) = aper::decode::decode_integer(data, Some(0), Some(65535), false)?;
            let criticality = Criticality::decode(data)?;
            let _length = aper::decode::decode_length_determinent(data, None, None, false)?;
            match id {
                19 => {
                    criticality_diagnostics = Some(CriticalityDiagnostics::decode(data)?);
                }
                x => {
                    if let Criticality::Reject = criticality {
                        return Err(aper::AperCodecError::new(format!(
                            "Unrecognised IE type {} with criticality reject",
                            x
                        )));
                    }
                }
            }
        }
        Ok(Self {
            criticality_diagnostics,
        })
    }
}

// RanConfigurationUpdateFailure
#[derive(Clone)]
pub struct RanConfigurationUpdateFailure {
    pub cause: Cause,
    pub time_to_wait: Option<TimeToWait>,
    pub criticality_diagnostics: Option<CriticalityDiagnostics>,
}

impl AperCodec for RanConfigurationUpdateFailure {
    type Output = RanConfigurationUpdateFailure;
    fn decode(data: &mut AperCodecData) -> Result<Self::Output, AperCodecError> {
        let _length = aper::decode::decode_length_determinent(data, None, None, false)?;
        let _ = aper::decode::decode_sequence_header(data, true, 0)?;
        let len = aper::decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut cause: Option<Cause> = None;
        let mut time_to_wait: Option<TimeToWait> = None;
        let mut criticality_diagnostics: Option<CriticalityDiagnostics> = None;

        for _ in 0..len {
            let (id, _ext) = aper::decode::decode_integer(data, Some(0), Some(65535), false)?;
            let criticality = Criticality::decode(data)?;
            let _length = aper::decode::decode_length_determinent(data, None, None, false)?;
            match id {
                15 => {
                    cause = Some(Cause::decode(data)?);
                }
                107 => {
                    time_to_wait = Some(TimeToWait::decode(data)?);
                }
                19 => {
                    criticality_diagnostics = Some(CriticalityDiagnostics::decode(data)?);
                }
                x => {
                    if let Criticality::Reject = criticality {
                        return Err(aper::AperCodecError::new(format!(
                            "Unrecognised IE type {} with criticality reject",
                            x
                        )));
                    }
                }
            }
        }
        let cause = cause.ok_or(aper::AperCodecError::new(format!(
            "Missing mandatory IE cause"
        )))?;
        Ok(Self {
            cause,
            time_to_wait,
            criticality_diagnostics,
        })
    }
}

// AmfConfigurationUpdate
#[derive(Clone)]
pub struct AmfConfigurationUpdate {
    pub amf_name: Option<AmfName>,
    pub served_guami_list: Option<ServedGuamiList>,
    pub relative_amf_capacity: Option<RelativeAmfCapacity>,
    pub plmn_support_list: Option<PlmnSupportList>,
    pub amf_tnl_association_to_add_list: Option<AmfTnlAssociationToAddList>,
    pub amf_tnl_association_to_remove_list: Option<AmfTnlAssociationToRemoveList>,
    pub amf_tnl_association_to_update_list: Option<AmfTnlAssociationToUpdateList>,
    pub extended_amf_name: Option<ExtendedAmfName>,
}

impl AperCodec for AmfConfigurationUpdate {
    type Output = AmfConfigurationUpdate;
    fn decode(data: &mut AperCodecData) -> Result<Self::Output, AperCodecError> {
        let _length = aper::decode::decode_length_determinent(data, None, None, false)?;
        let _ = aper::decode::decode_sequence_header(data, true, 0)?;
        let len = aper::decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut amf_name: Option<AmfName> = None;
        let mut served_guami_list: Option<ServedGuamiList> = None;
        let mut relative_amf_capacity: Option<RelativeAmfCapacity> = None;
        let mut plmn_support_list: Option<PlmnSupportList> = None;
        let mut amf_tnl_association_to_add_list: Option<AmfTnlAssociationToAddList> = None;
        let mut amf_tnl_association_to_remove_list: Option<AmfTnlAssociationToRemoveList> = None;
        let mut amf_tnl_association_to_update_list: Option<AmfTnlAssociationToUpdateList> = None;
        let mut extended_amf_name: Option<ExtendedAmfName> = None;

        for _ in 0..len {
            let (id, _ext) = aper::decode::decode_integer(data, Some(0), Some(65535), false)?;
            let criticality = Criticality::decode(data)?;
            let _length = aper::decode::decode_length_determinent(data, None, None, false)?;
            match id {
                1 => {
                    amf_name = Some(AmfName::decode(data)?);
                }
                96 => {
                    served_guami_list = Some(ServedGuamiList::decode(data)?);
                }
                86 => {
                    relative_amf_capacity = Some(RelativeAmfCapacity::decode(data)?);
                }
                80 => {
                    plmn_support_list = Some(PlmnSupportList::decode(data)?);
                }
                6 => {
                    amf_tnl_association_to_add_list =
                        Some(AmfTnlAssociationToAddList::decode(data)?);
                }
                7 => {
                    amf_tnl_association_to_remove_list =
                        Some(AmfTnlAssociationToRemoveList::decode(data)?);
                }
                8 => {
                    amf_tnl_association_to_update_list =
                        Some(AmfTnlAssociationToUpdateList::decode(data)?);
                }
                274 => {
                    extended_amf_name = Some(ExtendedAmfName::decode(data)?);
                }
                x => {
                    if let Criticality::Reject = criticality {
                        return Err(aper::AperCodecError::new(format!(
                            "Unrecognised IE type {} with criticality reject",
                            x
                        )));
                    }
                }
            }
        }
        Ok(Self {
            amf_name,
            served_guami_list,
            relative_amf_capacity,
            plmn_support_list,
            amf_tnl_association_to_add_list,
            amf_tnl_association_to_remove_list,
            amf_tnl_association_to_update_list,
            extended_amf_name,
        })
    }
}

// AmfConfigurationUpdateAcknowledge
#[derive(Clone)]
pub struct AmfConfigurationUpdateAcknowledge {
    pub amf_tnl_association_setup_list: Option<AmfTnlAssociationSetupList>,
    pub amf_tnl_association_failed_to_setup_list: Option<TnlAssociationList>,
    pub criticality_diagnostics: Option<CriticalityDiagnostics>,
}

impl AperCodec for AmfConfigurationUpdateAcknowledge {
    type Output = AmfConfigurationUpdateAcknowledge;
    fn decode(data: &mut AperCodecData) -> Result<Self::Output, AperCodecError> {
        let _length = aper::decode::decode_length_determinent(data, None, None, false)?;
        let _ = aper::decode::decode_sequence_header(data, true, 0)?;
        let len = aper::decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut amf_tnl_association_setup_list: Option<AmfTnlAssociationSetupList> = None;
        let mut amf_tnl_association_failed_to_setup_list: Option<TnlAssociationList> = None;
        let mut criticality_diagnostics: Option<CriticalityDiagnostics> = None;

        for _ in 0..len {
            let (id, _ext) = aper::decode::decode_integer(data, Some(0), Some(65535), false)?;
            let criticality = Criticality::decode(data)?;
            let _length = aper::decode::decode_length_determinent(data, None, None, false)?;
            match id {
                5 => {
                    amf_tnl_association_setup_list =
                        Some(AmfTnlAssociationSetupList::decode(data)?);
                }
                4 => {
                    amf_tnl_association_failed_to_setup_list =
                        Some(TnlAssociationList::decode(data)?);
                }
                19 => {
                    criticality_diagnostics = Some(CriticalityDiagnostics::decode(data)?);
                }
                x => {
                    if let Criticality::Reject = criticality {
                        return Err(aper::AperCodecError::new(format!(
                            "Unrecognised IE type {} with criticality reject",
                            x
                        )));
                    }
                }
            }
        }
        Ok(Self {
            amf_tnl_association_setup_list,
            amf_tnl_association_failed_to_setup_list,
            criticality_diagnostics,
        })
    }
}

// AmfConfigurationUpdateFailure
#[derive(Clone)]
pub struct AmfConfigurationUpdateFailure {
    pub cause: Cause,
    pub time_to_wait: Option<TimeToWait>,
    pub criticality_diagnostics: Option<CriticalityDiagnostics>,
}

impl AperCodec for AmfConfigurationUpdateFailure {
    type Output = AmfConfigurationUpdateFailure;
    fn decode(data: &mut AperCodecData) -> Result<Self::Output, AperCodecError> {
        let _length = aper::decode::decode_length_determinent(data, None, None, false)?;
        let _ = aper::decode::decode_sequence_header(data, true, 0)?;
        let len = aper::decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut cause: Option<Cause> = None;
        let mut time_to_wait: Option<TimeToWait> = None;
        let mut criticality_diagnostics: Option<CriticalityDiagnostics> = None;

        for _ in 0..len {
            let (id, _ext) = aper::decode::decode_integer(data, Some(0), Some(65535), false)?;
            let criticality = Criticality::decode(data)?;
            let _length = aper::decode::decode_length_determinent(data, None, None, false)?;
            match id {
                15 => {
                    cause = Some(Cause::decode(data)?);
                }
                107 => {
                    time_to_wait = Some(TimeToWait::decode(data)?);
                }
                19 => {
                    criticality_diagnostics = Some(CriticalityDiagnostics::decode(data)?);
                }
                x => {
                    if let Criticality::Reject = criticality {
                        return Err(aper::AperCodecError::new(format!(
                            "Unrecognised IE type {} with criticality reject",
                            x
                        )));
                    }
                }
            }
        }
        let cause = cause.ok_or(aper::AperCodecError::new(format!(
            "Missing mandatory IE cause"
        )))?;
        Ok(Self {
            cause,
            time_to_wait,
            criticality_diagnostics,
        })
    }
}

// AmfStatusIndication
#[derive(Clone)]
pub struct AmfStatusIndication {
    pub unavailable_guami_list: UnavailableGuamiList,
}

impl AperCodec for AmfStatusIndication {
    type Output = AmfStatusIndication;
    fn decode(data: &mut AperCodecData) -> Result<Self::Output, AperCodecError> {
        let _length = aper::decode::decode_length_determinent(data, None, None, false)?;
        let _ = aper::decode::decode_sequence_header(data, true, 0)?;
        let len = aper::decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut unavailable_guami_list: Option<UnavailableGuamiList> = None;

        for _ in 0..len {
            let (id, _ext) = aper::decode::decode_integer(data, Some(0), Some(65535), false)?;
            let criticality = Criticality::decode(data)?;
            let _length = aper::decode::decode_length_determinent(data, None, None, false)?;
            match id {
                120 => {
                    unavailable_guami_list = Some(UnavailableGuamiList::decode(data)?);
                }
                x => {
                    if let Criticality::Reject = criticality {
                        return Err(aper::AperCodecError::new(format!(
                            "Unrecognised IE type {} with criticality reject",
                            x
                        )));
                    }
                }
            }
        }
        let unavailable_guami_list = unavailable_guami_list.ok_or(aper::AperCodecError::new(
            format!("Missing mandatory IE unavailable_guami_list"),
        ))?;
        Ok(Self {
            unavailable_guami_list,
        })
    }
}

// NgReset
#[derive(Clone)]
pub struct NgReset {
    pub cause: Cause,
    pub reset_type: ResetType,
}

impl AperCodec for NgReset {
    type Output = NgReset;
    fn decode(data: &mut AperCodecData) -> Result<Self::Output, AperCodecError> {
        let _length = aper::decode::decode_length_determinent(data, None, None, false)?;
        let _ = aper::decode::decode_sequence_header(data, true, 0)?;
        let len = aper::decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut cause: Option<Cause> = None;
        let mut reset_type: Option<ResetType> = None;

        for _ in 0..len {
            let (id, _ext) = aper::decode::decode_integer(data, Some(0), Some(65535), false)?;
            let criticality = Criticality::decode(data)?;
            let _length = aper::decode::decode_length_determinent(data, None, None, false)?;
            match id {
                15 => {
                    cause = Some(Cause::decode(data)?);
                }
                88 => {
                    reset_type = Some(ResetType::decode(data)?);
                }
                x => {
                    if let Criticality::Reject = criticality {
                        return Err(aper::AperCodecError::new(format!(
                            "Unrecognised IE type {} with criticality reject",
                            x
                        )));
                    }
                }
            }
        }
        let cause = cause.ok_or(aper::AperCodecError::new(format!(
            "Missing mandatory IE cause"
        )))?;
        let reset_type = reset_type.ok_or(aper::AperCodecError::new(format!(
            "Missing mandatory IE reset_type"
        )))?;
        Ok(Self { cause, reset_type })
    }
}

// NgResetAcknowledge
#[derive(Clone)]
pub struct NgResetAcknowledge {
    pub ue_associated_logical_ng_connection_list: Option<UeAssociatedLogicalNgConnectionList>,
    pub criticality_diagnostics: Option<CriticalityDiagnostics>,
}

impl AperCodec for NgResetAcknowledge {
    type Output = NgResetAcknowledge;
    fn decode(data: &mut AperCodecData) -> Result<Self::Output, AperCodecError> {
        let _length = aper::decode::decode_length_determinent(data, None, None, false)?;
        let _ = aper::decode::decode_sequence_header(data, true, 0)?;
        let len = aper::decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut ue_associated_logical_ng_connection_list: Option<
            UeAssociatedLogicalNgConnectionList,
        > = None;
        let mut criticality_diagnostics: Option<CriticalityDiagnostics> = None;

        for _ in 0..len {
            let (id, _ext) = aper::decode::decode_integer(data, Some(0), Some(65535), false)?;
            let criticality = Criticality::decode(data)?;
            let _length = aper::decode::decode_length_determinent(data, None, None, false)?;
            match id {
                111 => {
                    ue_associated_logical_ng_connection_list =
                        Some(UeAssociatedLogicalNgConnectionList::decode(data)?);
                }
                19 => {
                    criticality_diagnostics = Some(CriticalityDiagnostics::decode(data)?);
                }
                x => {
                    if let Criticality::Reject = criticality {
                        return Err(aper::AperCodecError::new(format!(
                            "Unrecognised IE type {} with criticality reject",
                            x
                        )));
                    }
                }
            }
        }
        Ok(Self {
            ue_associated_logical_ng_connection_list,
            criticality_diagnostics,
        })
    }
}

// ErrorIndication
#[derive(Clone)]
pub struct ErrorIndication {
    pub amf_ue_ngap_id: Option<AmfUeNgapId>,
    pub ran_ue_ngap_id: Option<RanUeNgapId>,
    pub cause: Option<Cause>,
    pub criticality_diagnostics: Option<CriticalityDiagnostics>,
    pub five_g_s_tmsi: Option<FiveGSTmsi>,
}

impl AperCodec for ErrorIndication {
    type Output = ErrorIndication;
    fn decode(data: &mut AperCodecData) -> Result<Self::Output, AperCodecError> {
        let _length = aper::decode::decode_length_determinent(data, None, None, false)?;
        let _ = aper::decode::decode_sequence_header(data, true, 0)?;
        let len = aper::decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut amf_ue_ngap_id: Option<AmfUeNgapId> = None;
        let mut ran_ue_ngap_id: Option<RanUeNgapId> = None;
        let mut cause: Option<Cause> = None;
        let mut criticality_diagnostics: Option<CriticalityDiagnostics> = None;
        let mut five_g_s_tmsi: Option<FiveGSTmsi> = None;

        for _ in 0..len {
            let (id, _ext) = aper::decode::decode_integer(data, Some(0), Some(65535), false)?;
            let criticality = Criticality::decode(data)?;
            let _length = aper::decode::decode_length_determinent(data, None, None, false)?;
            match id {
                10 => {
                    amf_ue_ngap_id = Some(AmfUeNgapId::decode(data)?);
                }
                85 => {
                    ran_ue_ngap_id = Some(RanUeNgapId::decode(data)?);
                }
                15 => {
                    cause = Some(Cause::decode(data)?);
                }
                19 => {
                    criticality_diagnostics = Some(CriticalityDiagnostics::decode(data)?);
                }
                26 => {
                    five_g_s_tmsi = Some(FiveGSTmsi::decode(data)?);
                }
                x => {
                    if let Criticality::Reject = criticality {
                        return Err(aper::AperCodecError::new(format!(
                            "Unrecognised IE type {} with criticality reject",
                            x
                        )));
                    }
                }
            }
        }
        Ok(Self {
            amf_ue_ngap_id,
            ran_ue_ngap_id,
            cause,
            criticality_diagnostics,
            five_g_s_tmsi,
        })
    }
}

// OverloadStart
#[derive(Clone)]
pub struct OverloadStart {
    pub amf_overload_response: Option<OverloadResponse>,
    pub amf_traffic_load_reduction_indication: Option<TrafficLoadReductionIndication>,
    pub overload_start_nssai_list: Option<OverloadStartNssaiList>,
}

impl AperCodec for OverloadStart {
    type Output = OverloadStart;
    fn decode(data: &mut AperCodecData) -> Result<Self::Output, AperCodecError> {
        let _length = aper::decode::decode_length_determinent(data, None, None, false)?;
        let _ = aper::decode::decode_sequence_header(data, true, 0)?;
        let len = aper::decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut amf_overload_response: Option<OverloadResponse> = None;
        let mut amf_traffic_load_reduction_indication: Option<TrafficLoadReductionIndication> =
            None;
        let mut overload_start_nssai_list: Option<OverloadStartNssaiList> = None;

        for _ in 0..len {
            let (id, _ext) = aper::decode::decode_integer(data, Some(0), Some(65535), false)?;
            let criticality = Criticality::decode(data)?;
            let _length = aper::decode::decode_length_determinent(data, None, None, false)?;
            match id {
                2 => {
                    amf_overload_response = Some(OverloadResponse::decode(data)?);
                }
                9 => {
                    amf_traffic_load_reduction_indication =
                        Some(TrafficLoadReductionIndication::decode(data)?);
                }
                49 => {
                    overload_start_nssai_list = Some(OverloadStartNssaiList::decode(data)?);
                }
                x => {
                    if let Criticality::Reject = criticality {
                        return Err(aper::AperCodecError::new(format!(
                            "Unrecognised IE type {} with criticality reject",
                            x
                        )));
                    }
                }
            }
        }
        Ok(Self {
            amf_overload_response,
            amf_traffic_load_reduction_indication,
            overload_start_nssai_list,
        })
    }
}

// OverloadStop
#[derive(Clone)]
pub struct OverloadStop {}

impl AperCodec for OverloadStop {
    type Output = OverloadStop;
    fn decode(data: &mut AperCodecData) -> Result<Self::Output, AperCodecError> {
        let _length = aper::decode::decode_length_determinent(data, None, None, false)?;
        let _ = aper::decode::decode_sequence_header(data, true, 0)?;
        let len = aper::decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        for _ in 0..len {
            let (id, _ext) = aper::decode::decode_integer(data, Some(0), Some(65535), false)?;
            let criticality = Criticality::decode(data)?;
            let _length = aper::decode::decode_length_determinent(data, None, None, false)?;
            match id {
                x => {
                    if let Criticality::Reject = criticality {
                        return Err(aper::AperCodecError::new(format!(
                            "Unrecognised IE type {} with criticality reject",
                            x
                        )));
                    }
                }
            }
        }
        Ok(Self {})
    }
}

// UplinkRanConfigurationTransfer
#[derive(Clone)]
pub struct UplinkRanConfigurationTransfer {
    pub son_configuration_transfer_ul: Option<SonConfigurationTransfer>,
    pub endc_son_configuration_transfer_ul: Option<EnDcsonConfigurationTransfer>,
    pub intersystem_son_configuration_transfer_ul: Option<IntersystemSonConfigurationTransfer>,
}

impl AperCodec for UplinkRanConfigurationTransfer {
    type Output = UplinkRanConfigurationTransfer;
    fn decode(data: &mut AperCodecData) -> Result<Self::Output, AperCodecError> {
        let _length = aper::decode::decode_length_determinent(data, None, None, false)?;
        let _ = aper::decode::decode_sequence_header(data, true, 0)?;
        let len = aper::decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut son_configuration_transfer_ul: Option<SonConfigurationTransfer> = None;
        let mut endc_son_configuration_transfer_ul: Option<EnDcsonConfigurationTransfer> = None;
        let mut intersystem_son_configuration_transfer_ul: Option<
            IntersystemSonConfigurationTransfer,
        > = None;

        for _ in 0..len {
            let (id, _ext) = aper::decode::decode_integer(data, Some(0), Some(65535), false)?;
            let criticality = Criticality::decode(data)?;
            let _length = aper::decode::decode_length_determinent(data, None, None, false)?;
            match id {
                99 => {
                    son_configuration_transfer_ul = Some(SonConfigurationTransfer::decode(data)?);
                }
                158 => {
                    endc_son_configuration_transfer_ul =
                        Some(EnDcsonConfigurationTransfer::decode(data)?);
                }
                251 => {
                    intersystem_son_configuration_transfer_ul =
                        Some(IntersystemSonConfigurationTransfer::decode(data)?);
                }
                x => {
                    if let Criticality::Reject = criticality {
                        return Err(aper::AperCodecError::new(format!(
                            "Unrecognised IE type {} with criticality reject",
                            x
                        )));
                    }
                }
            }
        }
        Ok(Self {
            son_configuration_transfer_ul,
            endc_son_configuration_transfer_ul,
            intersystem_son_configuration_transfer_ul,
        })
    }
}

// DownlinkRanConfigurationTransfer
#[derive(Clone)]
pub struct DownlinkRanConfigurationTransfer {
    pub son_configuration_transfer_dl: Option<SonConfigurationTransfer>,
    pub endc_son_configuration_transfer_dl: Option<EnDcsonConfigurationTransfer>,
    pub intersystem_son_configuration_transfer_dl: Option<IntersystemSonConfigurationTransfer>,
}

impl AperCodec for DownlinkRanConfigurationTransfer {
    type Output = DownlinkRanConfigurationTransfer;
    fn decode(data: &mut AperCodecData) -> Result<Self::Output, AperCodecError> {
        let _length = aper::decode::decode_length_determinent(data, None, None, false)?;
        let _ = aper::decode::decode_sequence_header(data, true, 0)?;
        let len = aper::decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut son_configuration_transfer_dl: Option<SonConfigurationTransfer> = None;
        let mut endc_son_configuration_transfer_dl: Option<EnDcsonConfigurationTransfer> = None;
        let mut intersystem_son_configuration_transfer_dl: Option<
            IntersystemSonConfigurationTransfer,
        > = None;

        for _ in 0..len {
            let (id, _ext) = aper::decode::decode_integer(data, Some(0), Some(65535), false)?;
            let criticality = Criticality::decode(data)?;
            let _length = aper::decode::decode_length_determinent(data, None, None, false)?;
            match id {
                98 => {
                    son_configuration_transfer_dl = Some(SonConfigurationTransfer::decode(data)?);
                }
                157 => {
                    endc_son_configuration_transfer_dl =
                        Some(EnDcsonConfigurationTransfer::decode(data)?);
                }
                250 => {
                    intersystem_son_configuration_transfer_dl =
                        Some(IntersystemSonConfigurationTransfer::decode(data)?);
                }
                x => {
                    if let Criticality::Reject = criticality {
                        return Err(aper::AperCodecError::new(format!(
                            "Unrecognised IE type {} with criticality reject",
                            x
                        )));
                    }
                }
            }
        }
        Ok(Self {
            son_configuration_transfer_dl,
            endc_son_configuration_transfer_dl,
            intersystem_son_configuration_transfer_dl,
        })
    }
}

// WriteReplaceWarningRequest
#[derive(Clone)]
pub struct WriteReplaceWarningRequest {
    pub message_identifier: MessageIdentifier,
    pub serial_number: SerialNumber,
    pub warning_area_list: Option<WarningAreaList>,
    pub repetition_period: RepetitionPeriod,
    pub number_of_broadcasts_requested: NumberOfBroadcastsRequested,
    pub warning_type: Option<WarningType>,
    pub warning_security_info: Option<WarningSecurityInfo>,
    pub data_coding_scheme: Option<DataCodingScheme>,
    pub warning_message_contents: Option<WarningMessageContents>,
    pub concurrent_warning_message_ind: Option<ConcurrentWarningMessageInd>,
    pub warning_area_coordinates: Option<WarningAreaCoordinates>,
}

impl AperCodec for WriteReplaceWarningRequest {
    type Output = WriteReplaceWarningRequest;
    fn decode(data: &mut AperCodecData) -> Result<Self::Output, AperCodecError> {
        let _length = aper::decode::decode_length_determinent(data, None, None, false)?;
        let _ = aper::decode::decode_sequence_header(data, true, 0)?;
        let len = aper::decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut message_identifier: Option<MessageIdentifier> = None;
        let mut serial_number: Option<SerialNumber> = None;
        let mut warning_area_list: Option<WarningAreaList> = None;
        let mut repetition_period: Option<RepetitionPeriod> = None;
        let mut number_of_broadcasts_requested: Option<NumberOfBroadcastsRequested> = None;
        let mut warning_type: Option<WarningType> = None;
        let mut warning_security_info: Option<WarningSecurityInfo> = None;
        let mut data_coding_scheme: Option<DataCodingScheme> = None;
        let mut warning_message_contents: Option<WarningMessageContents> = None;
        let mut concurrent_warning_message_ind: Option<ConcurrentWarningMessageInd> = None;
        let mut warning_area_coordinates: Option<WarningAreaCoordinates> = None;

        for _ in 0..len {
            let (id, _ext) = aper::decode::decode_integer(data, Some(0), Some(65535), false)?;
            let criticality = Criticality::decode(data)?;
            let _length = aper::decode::decode_length_determinent(data, None, None, false)?;
            match id {
                35 => {
                    message_identifier = Some(MessageIdentifier::decode(data)?);
                }
                95 => {
                    serial_number = Some(SerialNumber::decode(data)?);
                }
                122 => {
                    warning_area_list = Some(WarningAreaList::decode(data)?);
                }
                87 => {
                    repetition_period = Some(RepetitionPeriod::decode(data)?);
                }
                47 => {
                    number_of_broadcasts_requested =
                        Some(NumberOfBroadcastsRequested::decode(data)?);
                }
                125 => {
                    warning_type = Some(WarningType::decode(data)?);
                }
                124 => {
                    warning_security_info = Some(WarningSecurityInfo::decode(data)?);
                }
                20 => {
                    data_coding_scheme = Some(DataCodingScheme::decode(data)?);
                }
                123 => {
                    warning_message_contents = Some(WarningMessageContents::decode(data)?);
                }
                17 => {
                    concurrent_warning_message_ind =
                        Some(ConcurrentWarningMessageInd::decode(data)?);
                }
                141 => {
                    warning_area_coordinates = Some(WarningAreaCoordinates::decode(data)?);
                }
                x => {
                    if let Criticality::Reject = criticality {
                        return Err(aper::AperCodecError::new(format!(
                            "Unrecognised IE type {} with criticality reject",
                            x
                        )));
                    }
                }
            }
        }
        let message_identifier = message_identifier.ok_or(aper::AperCodecError::new(format!(
            "Missing mandatory IE message_identifier"
        )))?;
        let serial_number = serial_number.ok_or(aper::AperCodecError::new(format!(
            "Missing mandatory IE serial_number"
        )))?;
        let repetition_period = repetition_period.ok_or(aper::AperCodecError::new(format!(
            "Missing mandatory IE repetition_period"
        )))?;
        let number_of_broadcasts_requested =
            number_of_broadcasts_requested.ok_or(aper::AperCodecError::new(format!(
                "Missing mandatory IE number_of_broadcasts_requested"
            )))?;
        Ok(Self {
            message_identifier,
            serial_number,
            warning_area_list,
            repetition_period,
            number_of_broadcasts_requested,
            warning_type,
            warning_security_info,
            data_coding_scheme,
            warning_message_contents,
            concurrent_warning_message_ind,
            warning_area_coordinates,
        })
    }
}

// WriteReplaceWarningResponse
#[derive(Clone)]
pub struct WriteReplaceWarningResponse {
    pub message_identifier: MessageIdentifier,
    pub serial_number: SerialNumber,
    pub broadcast_completed_area_list: Option<BroadcastCompletedAreaList>,
    pub criticality_diagnostics: Option<CriticalityDiagnostics>,
}

impl AperCodec for WriteReplaceWarningResponse {
    type Output = WriteReplaceWarningResponse;
    fn decode(data: &mut AperCodecData) -> Result<Self::Output, AperCodecError> {
        let _length = aper::decode::decode_length_determinent(data, None, None, false)?;
        let _ = aper::decode::decode_sequence_header(data, true, 0)?;
        let len = aper::decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut message_identifier: Option<MessageIdentifier> = None;
        let mut serial_number: Option<SerialNumber> = None;
        let mut broadcast_completed_area_list: Option<BroadcastCompletedAreaList> = None;
        let mut criticality_diagnostics: Option<CriticalityDiagnostics> = None;

        for _ in 0..len {
            let (id, _ext) = aper::decode::decode_integer(data, Some(0), Some(65535), false)?;
            let criticality = Criticality::decode(data)?;
            let _length = aper::decode::decode_length_determinent(data, None, None, false)?;
            match id {
                35 => {
                    message_identifier = Some(MessageIdentifier::decode(data)?);
                }
                95 => {
                    serial_number = Some(SerialNumber::decode(data)?);
                }
                13 => {
                    broadcast_completed_area_list = Some(BroadcastCompletedAreaList::decode(data)?);
                }
                19 => {
                    criticality_diagnostics = Some(CriticalityDiagnostics::decode(data)?);
                }
                x => {
                    if let Criticality::Reject = criticality {
                        return Err(aper::AperCodecError::new(format!(
                            "Unrecognised IE type {} with criticality reject",
                            x
                        )));
                    }
                }
            }
        }
        let message_identifier = message_identifier.ok_or(aper::AperCodecError::new(format!(
            "Missing mandatory IE message_identifier"
        )))?;
        let serial_number = serial_number.ok_or(aper::AperCodecError::new(format!(
            "Missing mandatory IE serial_number"
        )))?;
        Ok(Self {
            message_identifier,
            serial_number,
            broadcast_completed_area_list,
            criticality_diagnostics,
        })
    }
}

// PwsCancelRequest
#[derive(Clone)]
pub struct PwsCancelRequest {
    pub message_identifier: MessageIdentifier,
    pub serial_number: SerialNumber,
    pub warning_area_list: Option<WarningAreaList>,
    pub cancel_all_warning_messages: Option<CancelAllWarningMessages>,
}

impl AperCodec for PwsCancelRequest {
    type Output = PwsCancelRequest;
    fn decode(data: &mut AperCodecData) -> Result<Self::Output, AperCodecError> {
        let _length = aper::decode::decode_length_determinent(data, None, None, false)?;
        let _ = aper::decode::decode_sequence_header(data, true, 0)?;
        let len = aper::decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut message_identifier: Option<MessageIdentifier> = None;
        let mut serial_number: Option<SerialNumber> = None;
        let mut warning_area_list: Option<WarningAreaList> = None;
        let mut cancel_all_warning_messages: Option<CancelAllWarningMessages> = None;

        for _ in 0..len {
            let (id, _ext) = aper::decode::decode_integer(data, Some(0), Some(65535), false)?;
            let criticality = Criticality::decode(data)?;
            let _length = aper::decode::decode_length_determinent(data, None, None, false)?;
            match id {
                35 => {
                    message_identifier = Some(MessageIdentifier::decode(data)?);
                }
                95 => {
                    serial_number = Some(SerialNumber::decode(data)?);
                }
                122 => {
                    warning_area_list = Some(WarningAreaList::decode(data)?);
                }
                14 => {
                    cancel_all_warning_messages = Some(CancelAllWarningMessages::decode(data)?);
                }
                x => {
                    if let Criticality::Reject = criticality {
                        return Err(aper::AperCodecError::new(format!(
                            "Unrecognised IE type {} with criticality reject",
                            x
                        )));
                    }
                }
            }
        }
        let message_identifier = message_identifier.ok_or(aper::AperCodecError::new(format!(
            "Missing mandatory IE message_identifier"
        )))?;
        let serial_number = serial_number.ok_or(aper::AperCodecError::new(format!(
            "Missing mandatory IE serial_number"
        )))?;
        Ok(Self {
            message_identifier,
            serial_number,
            warning_area_list,
            cancel_all_warning_messages,
        })
    }
}

// PwsCancelResponse
#[derive(Clone)]
pub struct PwsCancelResponse {
    pub message_identifier: MessageIdentifier,
    pub serial_number: SerialNumber,
    pub broadcast_cancelled_area_list: Option<BroadcastCancelledAreaList>,
    pub criticality_diagnostics: Option<CriticalityDiagnostics>,
}

impl AperCodec for PwsCancelResponse {
    type Output = PwsCancelResponse;
    fn decode(data: &mut AperCodecData) -> Result<Self::Output, AperCodecError> {
        let _length = aper::decode::decode_length_determinent(data, None, None, false)?;
        let _ = aper::decode::decode_sequence_header(data, true, 0)?;
        let len = aper::decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut message_identifier: Option<MessageIdentifier> = None;
        let mut serial_number: Option<SerialNumber> = None;
        let mut broadcast_cancelled_area_list: Option<BroadcastCancelledAreaList> = None;
        let mut criticality_diagnostics: Option<CriticalityDiagnostics> = None;

        for _ in 0..len {
            let (id, _ext) = aper::decode::decode_integer(data, Some(0), Some(65535), false)?;
            let criticality = Criticality::decode(data)?;
            let _length = aper::decode::decode_length_determinent(data, None, None, false)?;
            match id {
                35 => {
                    message_identifier = Some(MessageIdentifier::decode(data)?);
                }
                95 => {
                    serial_number = Some(SerialNumber::decode(data)?);
                }
                12 => {
                    broadcast_cancelled_area_list = Some(BroadcastCancelledAreaList::decode(data)?);
                }
                19 => {
                    criticality_diagnostics = Some(CriticalityDiagnostics::decode(data)?);
                }
                x => {
                    if let Criticality::Reject = criticality {
                        return Err(aper::AperCodecError::new(format!(
                            "Unrecognised IE type {} with criticality reject",
                            x
                        )));
                    }
                }
            }
        }
        let message_identifier = message_identifier.ok_or(aper::AperCodecError::new(format!(
            "Missing mandatory IE message_identifier"
        )))?;
        let serial_number = serial_number.ok_or(aper::AperCodecError::new(format!(
            "Missing mandatory IE serial_number"
        )))?;
        Ok(Self {
            message_identifier,
            serial_number,
            broadcast_cancelled_area_list,
            criticality_diagnostics,
        })
    }
}

// PwsRestartIndication
#[derive(Clone)]
pub struct PwsRestartIndication {
    pub cell_id_list_for_restart: CellIdListForRestart,
    pub global_ran_node_id: GlobalRanNodeId,
    pub tai_list_for_restart: TaiListForRestart,
    pub emergency_area_id_list_for_restart: Option<EmergencyAreaIdListForRestart>,
}

impl AperCodec for PwsRestartIndication {
    type Output = PwsRestartIndication;
    fn decode(data: &mut AperCodecData) -> Result<Self::Output, AperCodecError> {
        let _length = aper::decode::decode_length_determinent(data, None, None, false)?;
        let _ = aper::decode::decode_sequence_header(data, true, 0)?;
        let len = aper::decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut cell_id_list_for_restart: Option<CellIdListForRestart> = None;
        let mut global_ran_node_id: Option<GlobalRanNodeId> = None;
        let mut tai_list_for_restart: Option<TaiListForRestart> = None;
        let mut emergency_area_id_list_for_restart: Option<EmergencyAreaIdListForRestart> = None;

        for _ in 0..len {
            let (id, _ext) = aper::decode::decode_integer(data, Some(0), Some(65535), false)?;
            let criticality = Criticality::decode(data)?;
            let _length = aper::decode::decode_length_determinent(data, None, None, false)?;
            match id {
                16 => {
                    cell_id_list_for_restart = Some(CellIdListForRestart::decode(data)?);
                }
                27 => {
                    global_ran_node_id = Some(GlobalRanNodeId::decode(data)?);
                }
                104 => {
                    tai_list_for_restart = Some(TaiListForRestart::decode(data)?);
                }
                23 => {
                    emergency_area_id_list_for_restart =
                        Some(EmergencyAreaIdListForRestart::decode(data)?);
                }
                x => {
                    if let Criticality::Reject = criticality {
                        return Err(aper::AperCodecError::new(format!(
                            "Unrecognised IE type {} with criticality reject",
                            x
                        )));
                    }
                }
            }
        }
        let cell_id_list_for_restart = cell_id_list_for_restart.ok_or(
            aper::AperCodecError::new(format!("Missing mandatory IE cell_id_list_for_restart")),
        )?;
        let global_ran_node_id = global_ran_node_id.ok_or(aper::AperCodecError::new(format!(
            "Missing mandatory IE global_ran_node_id"
        )))?;
        let tai_list_for_restart = tai_list_for_restart.ok_or(aper::AperCodecError::new(
            format!("Missing mandatory IE tai_list_for_restart"),
        ))?;
        Ok(Self {
            cell_id_list_for_restart,
            global_ran_node_id,
            tai_list_for_restart,
            emergency_area_id_list_for_restart,
        })
    }
}

// PwsFailureIndication
#[derive(Clone)]
pub struct PwsFailureIndication {
    pub pws_failed_cell_id_list: PwsFailedCellIdList,
    pub global_ran_node_id: GlobalRanNodeId,
}

impl AperCodec for PwsFailureIndication {
    type Output = PwsFailureIndication;
    fn decode(data: &mut AperCodecData) -> Result<Self::Output, AperCodecError> {
        let _length = aper::decode::decode_length_determinent(data, None, None, false)?;
        let _ = aper::decode::decode_sequence_header(data, true, 0)?;
        let len = aper::decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut pws_failed_cell_id_list: Option<PwsFailedCellIdList> = None;
        let mut global_ran_node_id: Option<GlobalRanNodeId> = None;

        for _ in 0..len {
            let (id, _ext) = aper::decode::decode_integer(data, Some(0), Some(65535), false)?;
            let criticality = Criticality::decode(data)?;
            let _length = aper::decode::decode_length_determinent(data, None, None, false)?;
            match id {
                81 => {
                    pws_failed_cell_id_list = Some(PwsFailedCellIdList::decode(data)?);
                }
                27 => {
                    global_ran_node_id = Some(GlobalRanNodeId::decode(data)?);
                }
                x => {
                    if let Criticality::Reject = criticality {
                        return Err(aper::AperCodecError::new(format!(
                            "Unrecognised IE type {} with criticality reject",
                            x
                        )));
                    }
                }
            }
        }
        let pws_failed_cell_id_list = pws_failed_cell_id_list.ok_or(aper::AperCodecError::new(
            format!("Missing mandatory IE pws_failed_cell_id_list"),
        ))?;
        let global_ran_node_id = global_ran_node_id.ok_or(aper::AperCodecError::new(format!(
            "Missing mandatory IE global_ran_node_id"
        )))?;
        Ok(Self {
            pws_failed_cell_id_list,
            global_ran_node_id,
        })
    }
}

// DownlinkUeAssociatedNrpPaTransport
#[derive(Clone)]
pub struct DownlinkUeAssociatedNrpPaTransport {
    pub amf_ue_ngap_id: AmfUeNgapId,
    pub ran_ue_ngap_id: RanUeNgapId,
    pub routing_id: RoutingId,
    pub nrp_pa_pdu: NrpPaPdu,
}

impl AperCodec for DownlinkUeAssociatedNrpPaTransport {
    type Output = DownlinkUeAssociatedNrpPaTransport;
    fn decode(data: &mut AperCodecData) -> Result<Self::Output, AperCodecError> {
        let _length = aper::decode::decode_length_determinent(data, None, None, false)?;
        let _ = aper::decode::decode_sequence_header(data, true, 0)?;
        let len = aper::decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut amf_ue_ngap_id: Option<AmfUeNgapId> = None;
        let mut ran_ue_ngap_id: Option<RanUeNgapId> = None;
        let mut routing_id: Option<RoutingId> = None;
        let mut nrp_pa_pdu: Option<NrpPaPdu> = None;

        for _ in 0..len {
            let (id, _ext) = aper::decode::decode_integer(data, Some(0), Some(65535), false)?;
            let criticality = Criticality::decode(data)?;
            let _length = aper::decode::decode_length_determinent(data, None, None, false)?;
            match id {
                10 => {
                    amf_ue_ngap_id = Some(AmfUeNgapId::decode(data)?);
                }
                85 => {
                    ran_ue_ngap_id = Some(RanUeNgapId::decode(data)?);
                }
                89 => {
                    routing_id = Some(RoutingId::decode(data)?);
                }
                46 => {
                    nrp_pa_pdu = Some(NrpPaPdu::decode(data)?);
                }
                x => {
                    if let Criticality::Reject = criticality {
                        return Err(aper::AperCodecError::new(format!(
                            "Unrecognised IE type {} with criticality reject",
                            x
                        )));
                    }
                }
            }
        }
        let amf_ue_ngap_id = amf_ue_ngap_id.ok_or(aper::AperCodecError::new(format!(
            "Missing mandatory IE amf_ue_ngap_id"
        )))?;
        let ran_ue_ngap_id = ran_ue_ngap_id.ok_or(aper::AperCodecError::new(format!(
            "Missing mandatory IE ran_ue_ngap_id"
        )))?;
        let routing_id = routing_id.ok_or(aper::AperCodecError::new(format!(
            "Missing mandatory IE routing_id"
        )))?;
        let nrp_pa_pdu = nrp_pa_pdu.ok_or(aper::AperCodecError::new(format!(
            "Missing mandatory IE nrp_pa_pdu"
        )))?;
        Ok(Self {
            amf_ue_ngap_id,
            ran_ue_ngap_id,
            routing_id,
            nrp_pa_pdu,
        })
    }
}

// UplinkUeAssociatedNrpPaTransport
#[derive(Clone)]
pub struct UplinkUeAssociatedNrpPaTransport {
    pub amf_ue_ngap_id: AmfUeNgapId,
    pub ran_ue_ngap_id: RanUeNgapId,
    pub routing_id: RoutingId,
    pub nrp_pa_pdu: NrpPaPdu,
}

impl AperCodec for UplinkUeAssociatedNrpPaTransport {
    type Output = UplinkUeAssociatedNrpPaTransport;
    fn decode(data: &mut AperCodecData) -> Result<Self::Output, AperCodecError> {
        let _length = aper::decode::decode_length_determinent(data, None, None, false)?;
        let _ = aper::decode::decode_sequence_header(data, true, 0)?;
        let len = aper::decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut amf_ue_ngap_id: Option<AmfUeNgapId> = None;
        let mut ran_ue_ngap_id: Option<RanUeNgapId> = None;
        let mut routing_id: Option<RoutingId> = None;
        let mut nrp_pa_pdu: Option<NrpPaPdu> = None;

        for _ in 0..len {
            let (id, _ext) = aper::decode::decode_integer(data, Some(0), Some(65535), false)?;
            let criticality = Criticality::decode(data)?;
            let _length = aper::decode::decode_length_determinent(data, None, None, false)?;
            match id {
                10 => {
                    amf_ue_ngap_id = Some(AmfUeNgapId::decode(data)?);
                }
                85 => {
                    ran_ue_ngap_id = Some(RanUeNgapId::decode(data)?);
                }
                89 => {
                    routing_id = Some(RoutingId::decode(data)?);
                }
                46 => {
                    nrp_pa_pdu = Some(NrpPaPdu::decode(data)?);
                }
                x => {
                    if let Criticality::Reject = criticality {
                        return Err(aper::AperCodecError::new(format!(
                            "Unrecognised IE type {} with criticality reject",
                            x
                        )));
                    }
                }
            }
        }
        let amf_ue_ngap_id = amf_ue_ngap_id.ok_or(aper::AperCodecError::new(format!(
            "Missing mandatory IE amf_ue_ngap_id"
        )))?;
        let ran_ue_ngap_id = ran_ue_ngap_id.ok_or(aper::AperCodecError::new(format!(
            "Missing mandatory IE ran_ue_ngap_id"
        )))?;
        let routing_id = routing_id.ok_or(aper::AperCodecError::new(format!(
            "Missing mandatory IE routing_id"
        )))?;
        let nrp_pa_pdu = nrp_pa_pdu.ok_or(aper::AperCodecError::new(format!(
            "Missing mandatory IE nrp_pa_pdu"
        )))?;
        Ok(Self {
            amf_ue_ngap_id,
            ran_ue_ngap_id,
            routing_id,
            nrp_pa_pdu,
        })
    }
}

// DownlinkNonUeAssociatedNrpPaTransport
#[derive(Clone)]
pub struct DownlinkNonUeAssociatedNrpPaTransport {
    pub routing_id: RoutingId,
    pub nrp_pa_pdu: NrpPaPdu,
}

impl AperCodec for DownlinkNonUeAssociatedNrpPaTransport {
    type Output = DownlinkNonUeAssociatedNrpPaTransport;
    fn decode(data: &mut AperCodecData) -> Result<Self::Output, AperCodecError> {
        let _length = aper::decode::decode_length_determinent(data, None, None, false)?;
        let _ = aper::decode::decode_sequence_header(data, true, 0)?;
        let len = aper::decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut routing_id: Option<RoutingId> = None;
        let mut nrp_pa_pdu: Option<NrpPaPdu> = None;

        for _ in 0..len {
            let (id, _ext) = aper::decode::decode_integer(data, Some(0), Some(65535), false)?;
            let criticality = Criticality::decode(data)?;
            let _length = aper::decode::decode_length_determinent(data, None, None, false)?;
            match id {
                89 => {
                    routing_id = Some(RoutingId::decode(data)?);
                }
                46 => {
                    nrp_pa_pdu = Some(NrpPaPdu::decode(data)?);
                }
                x => {
                    if let Criticality::Reject = criticality {
                        return Err(aper::AperCodecError::new(format!(
                            "Unrecognised IE type {} with criticality reject",
                            x
                        )));
                    }
                }
            }
        }
        let routing_id = routing_id.ok_or(aper::AperCodecError::new(format!(
            "Missing mandatory IE routing_id"
        )))?;
        let nrp_pa_pdu = nrp_pa_pdu.ok_or(aper::AperCodecError::new(format!(
            "Missing mandatory IE nrp_pa_pdu"
        )))?;
        Ok(Self {
            routing_id,
            nrp_pa_pdu,
        })
    }
}

// UplinkNonUeAssociatedNrpPaTransport
#[derive(Clone)]
pub struct UplinkNonUeAssociatedNrpPaTransport {
    pub routing_id: RoutingId,
    pub nrp_pa_pdu: NrpPaPdu,
}

impl AperCodec for UplinkNonUeAssociatedNrpPaTransport {
    type Output = UplinkNonUeAssociatedNrpPaTransport;
    fn decode(data: &mut AperCodecData) -> Result<Self::Output, AperCodecError> {
        let _length = aper::decode::decode_length_determinent(data, None, None, false)?;
        let _ = aper::decode::decode_sequence_header(data, true, 0)?;
        let len = aper::decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut routing_id: Option<RoutingId> = None;
        let mut nrp_pa_pdu: Option<NrpPaPdu> = None;

        for _ in 0..len {
            let (id, _ext) = aper::decode::decode_integer(data, Some(0), Some(65535), false)?;
            let criticality = Criticality::decode(data)?;
            let _length = aper::decode::decode_length_determinent(data, None, None, false)?;
            match id {
                89 => {
                    routing_id = Some(RoutingId::decode(data)?);
                }
                46 => {
                    nrp_pa_pdu = Some(NrpPaPdu::decode(data)?);
                }
                x => {
                    if let Criticality::Reject = criticality {
                        return Err(aper::AperCodecError::new(format!(
                            "Unrecognised IE type {} with criticality reject",
                            x
                        )));
                    }
                }
            }
        }
        let routing_id = routing_id.ok_or(aper::AperCodecError::new(format!(
            "Missing mandatory IE routing_id"
        )))?;
        let nrp_pa_pdu = nrp_pa_pdu.ok_or(aper::AperCodecError::new(format!(
            "Missing mandatory IE nrp_pa_pdu"
        )))?;
        Ok(Self {
            routing_id,
            nrp_pa_pdu,
        })
    }
}

// TraceStart
#[derive(Clone)]
pub struct TraceStart {
    pub amf_ue_ngap_id: AmfUeNgapId,
    pub ran_ue_ngap_id: RanUeNgapId,
    pub trace_activation: TraceActivation,
}

impl AperCodec for TraceStart {
    type Output = TraceStart;
    fn decode(data: &mut AperCodecData) -> Result<Self::Output, AperCodecError> {
        let _length = aper::decode::decode_length_determinent(data, None, None, false)?;
        let _ = aper::decode::decode_sequence_header(data, true, 0)?;
        let len = aper::decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut amf_ue_ngap_id: Option<AmfUeNgapId> = None;
        let mut ran_ue_ngap_id: Option<RanUeNgapId> = None;
        let mut trace_activation: Option<TraceActivation> = None;

        for _ in 0..len {
            let (id, _ext) = aper::decode::decode_integer(data, Some(0), Some(65535), false)?;
            let criticality = Criticality::decode(data)?;
            let _length = aper::decode::decode_length_determinent(data, None, None, false)?;
            match id {
                10 => {
                    amf_ue_ngap_id = Some(AmfUeNgapId::decode(data)?);
                }
                85 => {
                    ran_ue_ngap_id = Some(RanUeNgapId::decode(data)?);
                }
                108 => {
                    trace_activation = Some(TraceActivation::decode(data)?);
                }
                x => {
                    if let Criticality::Reject = criticality {
                        return Err(aper::AperCodecError::new(format!(
                            "Unrecognised IE type {} with criticality reject",
                            x
                        )));
                    }
                }
            }
        }
        let amf_ue_ngap_id = amf_ue_ngap_id.ok_or(aper::AperCodecError::new(format!(
            "Missing mandatory IE amf_ue_ngap_id"
        )))?;
        let ran_ue_ngap_id = ran_ue_ngap_id.ok_or(aper::AperCodecError::new(format!(
            "Missing mandatory IE ran_ue_ngap_id"
        )))?;
        let trace_activation = trace_activation.ok_or(aper::AperCodecError::new(format!(
            "Missing mandatory IE trace_activation"
        )))?;
        Ok(Self {
            amf_ue_ngap_id,
            ran_ue_ngap_id,
            trace_activation,
        })
    }
}

// TraceFailureIndication
#[derive(Clone)]
pub struct TraceFailureIndication {
    pub amf_ue_ngap_id: AmfUeNgapId,
    pub ran_ue_ngap_id: RanUeNgapId,
    pub ngran_trace_id: NgranTraceId,
    pub cause: Cause,
}

impl AperCodec for TraceFailureIndication {
    type Output = TraceFailureIndication;
    fn decode(data: &mut AperCodecData) -> Result<Self::Output, AperCodecError> {
        let _length = aper::decode::decode_length_determinent(data, None, None, false)?;
        let _ = aper::decode::decode_sequence_header(data, true, 0)?;
        let len = aper::decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut amf_ue_ngap_id: Option<AmfUeNgapId> = None;
        let mut ran_ue_ngap_id: Option<RanUeNgapId> = None;
        let mut ngran_trace_id: Option<NgranTraceId> = None;
        let mut cause: Option<Cause> = None;

        for _ in 0..len {
            let (id, _ext) = aper::decode::decode_integer(data, Some(0), Some(65535), false)?;
            let criticality = Criticality::decode(data)?;
            let _length = aper::decode::decode_length_determinent(data, None, None, false)?;
            match id {
                10 => {
                    amf_ue_ngap_id = Some(AmfUeNgapId::decode(data)?);
                }
                85 => {
                    ran_ue_ngap_id = Some(RanUeNgapId::decode(data)?);
                }
                44 => {
                    ngran_trace_id = Some(NgranTraceId::decode(data)?);
                }
                15 => {
                    cause = Some(Cause::decode(data)?);
                }
                x => {
                    if let Criticality::Reject = criticality {
                        return Err(aper::AperCodecError::new(format!(
                            "Unrecognised IE type {} with criticality reject",
                            x
                        )));
                    }
                }
            }
        }
        let amf_ue_ngap_id = amf_ue_ngap_id.ok_or(aper::AperCodecError::new(format!(
            "Missing mandatory IE amf_ue_ngap_id"
        )))?;
        let ran_ue_ngap_id = ran_ue_ngap_id.ok_or(aper::AperCodecError::new(format!(
            "Missing mandatory IE ran_ue_ngap_id"
        )))?;
        let ngran_trace_id = ngran_trace_id.ok_or(aper::AperCodecError::new(format!(
            "Missing mandatory IE ngran_trace_id"
        )))?;
        let cause = cause.ok_or(aper::AperCodecError::new(format!(
            "Missing mandatory IE cause"
        )))?;
        Ok(Self {
            amf_ue_ngap_id,
            ran_ue_ngap_id,
            ngran_trace_id,
            cause,
        })
    }
}

// DeactivateTrace
#[derive(Clone)]
pub struct DeactivateTrace {
    pub amf_ue_ngap_id: AmfUeNgapId,
    pub ran_ue_ngap_id: RanUeNgapId,
    pub ngran_trace_id: NgranTraceId,
}

impl AperCodec for DeactivateTrace {
    type Output = DeactivateTrace;
    fn decode(data: &mut AperCodecData) -> Result<Self::Output, AperCodecError> {
        let _length = aper::decode::decode_length_determinent(data, None, None, false)?;
        let _ = aper::decode::decode_sequence_header(data, true, 0)?;
        let len = aper::decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut amf_ue_ngap_id: Option<AmfUeNgapId> = None;
        let mut ran_ue_ngap_id: Option<RanUeNgapId> = None;
        let mut ngran_trace_id: Option<NgranTraceId> = None;

        for _ in 0..len {
            let (id, _ext) = aper::decode::decode_integer(data, Some(0), Some(65535), false)?;
            let criticality = Criticality::decode(data)?;
            let _length = aper::decode::decode_length_determinent(data, None, None, false)?;
            match id {
                10 => {
                    amf_ue_ngap_id = Some(AmfUeNgapId::decode(data)?);
                }
                85 => {
                    ran_ue_ngap_id = Some(RanUeNgapId::decode(data)?);
                }
                44 => {
                    ngran_trace_id = Some(NgranTraceId::decode(data)?);
                }
                x => {
                    if let Criticality::Reject = criticality {
                        return Err(aper::AperCodecError::new(format!(
                            "Unrecognised IE type {} with criticality reject",
                            x
                        )));
                    }
                }
            }
        }
        let amf_ue_ngap_id = amf_ue_ngap_id.ok_or(aper::AperCodecError::new(format!(
            "Missing mandatory IE amf_ue_ngap_id"
        )))?;
        let ran_ue_ngap_id = ran_ue_ngap_id.ok_or(aper::AperCodecError::new(format!(
            "Missing mandatory IE ran_ue_ngap_id"
        )))?;
        let ngran_trace_id = ngran_trace_id.ok_or(aper::AperCodecError::new(format!(
            "Missing mandatory IE ngran_trace_id"
        )))?;
        Ok(Self {
            amf_ue_ngap_id,
            ran_ue_ngap_id,
            ngran_trace_id,
        })
    }
}

// CellTrafficTrace
#[derive(Clone)]
pub struct CellTrafficTrace {
    pub amf_ue_ngap_id: AmfUeNgapId,
    pub ran_ue_ngap_id: RanUeNgapId,
    pub ngran_trace_id: NgranTraceId,
    pub ngran_cgi: NgranCgi,
    pub trace_collection_entity_ip_address: TransportLayerAddress,
    pub privacy_indicator: Option<PrivacyIndicator>,
    pub trace_collection_entity_uri: Option<UriAddress>,
}

impl AperCodec for CellTrafficTrace {
    type Output = CellTrafficTrace;
    fn decode(data: &mut AperCodecData) -> Result<Self::Output, AperCodecError> {
        let _length = aper::decode::decode_length_determinent(data, None, None, false)?;
        let _ = aper::decode::decode_sequence_header(data, true, 0)?;
        let len = aper::decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut amf_ue_ngap_id: Option<AmfUeNgapId> = None;
        let mut ran_ue_ngap_id: Option<RanUeNgapId> = None;
        let mut ngran_trace_id: Option<NgranTraceId> = None;
        let mut ngran_cgi: Option<NgranCgi> = None;
        let mut trace_collection_entity_ip_address: Option<TransportLayerAddress> = None;
        let mut privacy_indicator: Option<PrivacyIndicator> = None;
        let mut trace_collection_entity_uri: Option<UriAddress> = None;

        for _ in 0..len {
            let (id, _ext) = aper::decode::decode_integer(data, Some(0), Some(65535), false)?;
            let criticality = Criticality::decode(data)?;
            let _length = aper::decode::decode_length_determinent(data, None, None, false)?;
            match id {
                10 => {
                    amf_ue_ngap_id = Some(AmfUeNgapId::decode(data)?);
                }
                85 => {
                    ran_ue_ngap_id = Some(RanUeNgapId::decode(data)?);
                }
                44 => {
                    ngran_trace_id = Some(NgranTraceId::decode(data)?);
                }
                43 => {
                    ngran_cgi = Some(NgranCgi::decode(data)?);
                }
                109 => {
                    trace_collection_entity_ip_address = Some(TransportLayerAddress::decode(data)?);
                }
                256 => {
                    privacy_indicator = Some(PrivacyIndicator::decode(data)?);
                }
                257 => {
                    trace_collection_entity_uri = Some(UriAddress::decode(data)?);
                }
                x => {
                    if let Criticality::Reject = criticality {
                        return Err(aper::AperCodecError::new(format!(
                            "Unrecognised IE type {} with criticality reject",
                            x
                        )));
                    }
                }
            }
        }
        let amf_ue_ngap_id = amf_ue_ngap_id.ok_or(aper::AperCodecError::new(format!(
            "Missing mandatory IE amf_ue_ngap_id"
        )))?;
        let ran_ue_ngap_id = ran_ue_ngap_id.ok_or(aper::AperCodecError::new(format!(
            "Missing mandatory IE ran_ue_ngap_id"
        )))?;
        let ngran_trace_id = ngran_trace_id.ok_or(aper::AperCodecError::new(format!(
            "Missing mandatory IE ngran_trace_id"
        )))?;
        let ngran_cgi = ngran_cgi.ok_or(aper::AperCodecError::new(format!(
            "Missing mandatory IE ngran_cgi"
        )))?;
        let trace_collection_entity_ip_address =
            trace_collection_entity_ip_address.ok_or(aper::AperCodecError::new(format!(
                "Missing mandatory IE trace_collection_entity_ip_address"
            )))?;
        Ok(Self {
            amf_ue_ngap_id,
            ran_ue_ngap_id,
            ngran_trace_id,
            ngran_cgi,
            trace_collection_entity_ip_address,
            privacy_indicator,
            trace_collection_entity_uri,
        })
    }
}

// LocationReportingControl
#[derive(Clone)]
pub struct LocationReportingControl {
    pub amf_ue_ngap_id: AmfUeNgapId,
    pub ran_ue_ngap_id: RanUeNgapId,
    pub location_reporting_request_type: LocationReportingRequestType,
}

impl AperCodec for LocationReportingControl {
    type Output = LocationReportingControl;
    fn decode(data: &mut AperCodecData) -> Result<Self::Output, AperCodecError> {
        let _length = aper::decode::decode_length_determinent(data, None, None, false)?;
        let _ = aper::decode::decode_sequence_header(data, true, 0)?;
        let len = aper::decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut amf_ue_ngap_id: Option<AmfUeNgapId> = None;
        let mut ran_ue_ngap_id: Option<RanUeNgapId> = None;
        let mut location_reporting_request_type: Option<LocationReportingRequestType> = None;

        for _ in 0..len {
            let (id, _ext) = aper::decode::decode_integer(data, Some(0), Some(65535), false)?;
            let criticality = Criticality::decode(data)?;
            let _length = aper::decode::decode_length_determinent(data, None, None, false)?;
            match id {
                10 => {
                    amf_ue_ngap_id = Some(AmfUeNgapId::decode(data)?);
                }
                85 => {
                    ran_ue_ngap_id = Some(RanUeNgapId::decode(data)?);
                }
                33 => {
                    location_reporting_request_type =
                        Some(LocationReportingRequestType::decode(data)?);
                }
                x => {
                    if let Criticality::Reject = criticality {
                        return Err(aper::AperCodecError::new(format!(
                            "Unrecognised IE type {} with criticality reject",
                            x
                        )));
                    }
                }
            }
        }
        let amf_ue_ngap_id = amf_ue_ngap_id.ok_or(aper::AperCodecError::new(format!(
            "Missing mandatory IE amf_ue_ngap_id"
        )))?;
        let ran_ue_ngap_id = ran_ue_ngap_id.ok_or(aper::AperCodecError::new(format!(
            "Missing mandatory IE ran_ue_ngap_id"
        )))?;
        let location_reporting_request_type =
            location_reporting_request_type.ok_or(aper::AperCodecError::new(format!(
                "Missing mandatory IE location_reporting_request_type"
            )))?;
        Ok(Self {
            amf_ue_ngap_id,
            ran_ue_ngap_id,
            location_reporting_request_type,
        })
    }
}

// LocationReportingFailureIndication
#[derive(Clone)]
pub struct LocationReportingFailureIndication {
    pub amf_ue_ngap_id: AmfUeNgapId,
    pub ran_ue_ngap_id: RanUeNgapId,
    pub cause: Cause,
}

impl AperCodec for LocationReportingFailureIndication {
    type Output = LocationReportingFailureIndication;
    fn decode(data: &mut AperCodecData) -> Result<Self::Output, AperCodecError> {
        let _length = aper::decode::decode_length_determinent(data, None, None, false)?;
        let _ = aper::decode::decode_sequence_header(data, true, 0)?;
        let len = aper::decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut amf_ue_ngap_id: Option<AmfUeNgapId> = None;
        let mut ran_ue_ngap_id: Option<RanUeNgapId> = None;
        let mut cause: Option<Cause> = None;

        for _ in 0..len {
            let (id, _ext) = aper::decode::decode_integer(data, Some(0), Some(65535), false)?;
            let criticality = Criticality::decode(data)?;
            let _length = aper::decode::decode_length_determinent(data, None, None, false)?;
            match id {
                10 => {
                    amf_ue_ngap_id = Some(AmfUeNgapId::decode(data)?);
                }
                85 => {
                    ran_ue_ngap_id = Some(RanUeNgapId::decode(data)?);
                }
                15 => {
                    cause = Some(Cause::decode(data)?);
                }
                x => {
                    if let Criticality::Reject = criticality {
                        return Err(aper::AperCodecError::new(format!(
                            "Unrecognised IE type {} with criticality reject",
                            x
                        )));
                    }
                }
            }
        }
        let amf_ue_ngap_id = amf_ue_ngap_id.ok_or(aper::AperCodecError::new(format!(
            "Missing mandatory IE amf_ue_ngap_id"
        )))?;
        let ran_ue_ngap_id = ran_ue_ngap_id.ok_or(aper::AperCodecError::new(format!(
            "Missing mandatory IE ran_ue_ngap_id"
        )))?;
        let cause = cause.ok_or(aper::AperCodecError::new(format!(
            "Missing mandatory IE cause"
        )))?;
        Ok(Self {
            amf_ue_ngap_id,
            ran_ue_ngap_id,
            cause,
        })
    }
}

// LocationReport
#[derive(Clone)]
pub struct LocationReport {
    pub amf_ue_ngap_id: AmfUeNgapId,
    pub ran_ue_ngap_id: RanUeNgapId,
    pub user_location_information: UserLocationInformation,
    pub ue_presence_in_area_of_interest_list: Option<UePresenceInAreaOfInterestList>,
    pub location_reporting_request_type: LocationReportingRequestType,
}

impl AperCodec for LocationReport {
    type Output = LocationReport;
    fn decode(data: &mut AperCodecData) -> Result<Self::Output, AperCodecError> {
        let _length = aper::decode::decode_length_determinent(data, None, None, false)?;
        let _ = aper::decode::decode_sequence_header(data, true, 0)?;
        let len = aper::decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut amf_ue_ngap_id: Option<AmfUeNgapId> = None;
        let mut ran_ue_ngap_id: Option<RanUeNgapId> = None;
        let mut user_location_information: Option<UserLocationInformation> = None;
        let mut ue_presence_in_area_of_interest_list: Option<UePresenceInAreaOfInterestList> = None;
        let mut location_reporting_request_type: Option<LocationReportingRequestType> = None;

        for _ in 0..len {
            let (id, _ext) = aper::decode::decode_integer(data, Some(0), Some(65535), false)?;
            let criticality = Criticality::decode(data)?;
            let _length = aper::decode::decode_length_determinent(data, None, None, false)?;
            match id {
                10 => {
                    amf_ue_ngap_id = Some(AmfUeNgapId::decode(data)?);
                }
                85 => {
                    ran_ue_ngap_id = Some(RanUeNgapId::decode(data)?);
                }
                121 => {
                    user_location_information = Some(UserLocationInformation::decode(data)?);
                }
                116 => {
                    ue_presence_in_area_of_interest_list =
                        Some(UePresenceInAreaOfInterestList::decode(data)?);
                }
                33 => {
                    location_reporting_request_type =
                        Some(LocationReportingRequestType::decode(data)?);
                }
                x => {
                    if let Criticality::Reject = criticality {
                        return Err(aper::AperCodecError::new(format!(
                            "Unrecognised IE type {} with criticality reject",
                            x
                        )));
                    }
                }
            }
        }
        let amf_ue_ngap_id = amf_ue_ngap_id.ok_or(aper::AperCodecError::new(format!(
            "Missing mandatory IE amf_ue_ngap_id"
        )))?;
        let ran_ue_ngap_id = ran_ue_ngap_id.ok_or(aper::AperCodecError::new(format!(
            "Missing mandatory IE ran_ue_ngap_id"
        )))?;
        let user_location_information = user_location_information.ok_or(
            aper::AperCodecError::new(format!("Missing mandatory IE user_location_information")),
        )?;
        let location_reporting_request_type =
            location_reporting_request_type.ok_or(aper::AperCodecError::new(format!(
                "Missing mandatory IE location_reporting_request_type"
            )))?;
        Ok(Self {
            amf_ue_ngap_id,
            ran_ue_ngap_id,
            user_location_information,
            ue_presence_in_area_of_interest_list,
            location_reporting_request_type,
        })
    }
}

// UetnlaBindingReleaseRequest
#[derive(Clone)]
pub struct UetnlaBindingReleaseRequest {
    pub amf_ue_ngap_id: AmfUeNgapId,
    pub ran_ue_ngap_id: RanUeNgapId,
}

impl AperCodec for UetnlaBindingReleaseRequest {
    type Output = UetnlaBindingReleaseRequest;
    fn decode(data: &mut AperCodecData) -> Result<Self::Output, AperCodecError> {
        let _length = aper::decode::decode_length_determinent(data, None, None, false)?;
        let _ = aper::decode::decode_sequence_header(data, true, 0)?;
        let len = aper::decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut amf_ue_ngap_id: Option<AmfUeNgapId> = None;
        let mut ran_ue_ngap_id: Option<RanUeNgapId> = None;

        for _ in 0..len {
            let (id, _ext) = aper::decode::decode_integer(data, Some(0), Some(65535), false)?;
            let criticality = Criticality::decode(data)?;
            let _length = aper::decode::decode_length_determinent(data, None, None, false)?;
            match id {
                10 => {
                    amf_ue_ngap_id = Some(AmfUeNgapId::decode(data)?);
                }
                85 => {
                    ran_ue_ngap_id = Some(RanUeNgapId::decode(data)?);
                }
                x => {
                    if let Criticality::Reject = criticality {
                        return Err(aper::AperCodecError::new(format!(
                            "Unrecognised IE type {} with criticality reject",
                            x
                        )));
                    }
                }
            }
        }
        let amf_ue_ngap_id = amf_ue_ngap_id.ok_or(aper::AperCodecError::new(format!(
            "Missing mandatory IE amf_ue_ngap_id"
        )))?;
        let ran_ue_ngap_id = ran_ue_ngap_id.ok_or(aper::AperCodecError::new(format!(
            "Missing mandatory IE ran_ue_ngap_id"
        )))?;
        Ok(Self {
            amf_ue_ngap_id,
            ran_ue_ngap_id,
        })
    }
}

// UeRadioCapabilityInfoIndication
#[derive(Clone)]
pub struct UeRadioCapabilityInfoIndication {
    pub amf_ue_ngap_id: AmfUeNgapId,
    pub ran_ue_ngap_id: RanUeNgapId,
    pub ue_radio_capability: UeRadioCapability,
    pub ue_radio_capability_for_paging: Option<UeRadioCapabilityForPaging>,
    pub ue_radio_capability_eutra_format: Option<UeRadioCapability>,
}

impl AperCodec for UeRadioCapabilityInfoIndication {
    type Output = UeRadioCapabilityInfoIndication;
    fn decode(data: &mut AperCodecData) -> Result<Self::Output, AperCodecError> {
        let _length = aper::decode::decode_length_determinent(data, None, None, false)?;
        let _ = aper::decode::decode_sequence_header(data, true, 0)?;
        let len = aper::decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut amf_ue_ngap_id: Option<AmfUeNgapId> = None;
        let mut ran_ue_ngap_id: Option<RanUeNgapId> = None;
        let mut ue_radio_capability: Option<UeRadioCapability> = None;
        let mut ue_radio_capability_for_paging: Option<UeRadioCapabilityForPaging> = None;
        let mut ue_radio_capability_eutra_format: Option<UeRadioCapability> = None;

        for _ in 0..len {
            let (id, _ext) = aper::decode::decode_integer(data, Some(0), Some(65535), false)?;
            let criticality = Criticality::decode(data)?;
            let _length = aper::decode::decode_length_determinent(data, None, None, false)?;
            match id {
                10 => {
                    amf_ue_ngap_id = Some(AmfUeNgapId::decode(data)?);
                }
                85 => {
                    ran_ue_ngap_id = Some(RanUeNgapId::decode(data)?);
                }
                117 => {
                    ue_radio_capability = Some(UeRadioCapability::decode(data)?);
                }
                118 => {
                    ue_radio_capability_for_paging =
                        Some(UeRadioCapabilityForPaging::decode(data)?);
                }
                265 => {
                    ue_radio_capability_eutra_format = Some(UeRadioCapability::decode(data)?);
                }
                x => {
                    if let Criticality::Reject = criticality {
                        return Err(aper::AperCodecError::new(format!(
                            "Unrecognised IE type {} with criticality reject",
                            x
                        )));
                    }
                }
            }
        }
        let amf_ue_ngap_id = amf_ue_ngap_id.ok_or(aper::AperCodecError::new(format!(
            "Missing mandatory IE amf_ue_ngap_id"
        )))?;
        let ran_ue_ngap_id = ran_ue_ngap_id.ok_or(aper::AperCodecError::new(format!(
            "Missing mandatory IE ran_ue_ngap_id"
        )))?;
        let ue_radio_capability = ue_radio_capability.ok_or(aper::AperCodecError::new(format!(
            "Missing mandatory IE ue_radio_capability"
        )))?;
        Ok(Self {
            amf_ue_ngap_id,
            ran_ue_ngap_id,
            ue_radio_capability,
            ue_radio_capability_for_paging,
            ue_radio_capability_eutra_format,
        })
    }
}

// UeRadioCapabilityCheckRequest
#[derive(Clone)]
pub struct UeRadioCapabilityCheckRequest {
    pub amf_ue_ngap_id: AmfUeNgapId,
    pub ran_ue_ngap_id: RanUeNgapId,
    pub ue_radio_capability: Option<UeRadioCapability>,
    pub ue_radio_capability_id: Option<UeRadioCapabilityId>,
}

impl AperCodec for UeRadioCapabilityCheckRequest {
    type Output = UeRadioCapabilityCheckRequest;
    fn decode(data: &mut AperCodecData) -> Result<Self::Output, AperCodecError> {
        let _length = aper::decode::decode_length_determinent(data, None, None, false)?;
        let _ = aper::decode::decode_sequence_header(data, true, 0)?;
        let len = aper::decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut amf_ue_ngap_id: Option<AmfUeNgapId> = None;
        let mut ran_ue_ngap_id: Option<RanUeNgapId> = None;
        let mut ue_radio_capability: Option<UeRadioCapability> = None;
        let mut ue_radio_capability_id: Option<UeRadioCapabilityId> = None;

        for _ in 0..len {
            let (id, _ext) = aper::decode::decode_integer(data, Some(0), Some(65535), false)?;
            let criticality = Criticality::decode(data)?;
            let _length = aper::decode::decode_length_determinent(data, None, None, false)?;
            match id {
                10 => {
                    amf_ue_ngap_id = Some(AmfUeNgapId::decode(data)?);
                }
                85 => {
                    ran_ue_ngap_id = Some(RanUeNgapId::decode(data)?);
                }
                117 => {
                    ue_radio_capability = Some(UeRadioCapability::decode(data)?);
                }
                264 => {
                    ue_radio_capability_id = Some(UeRadioCapabilityId::decode(data)?);
                }
                x => {
                    if let Criticality::Reject = criticality {
                        return Err(aper::AperCodecError::new(format!(
                            "Unrecognised IE type {} with criticality reject",
                            x
                        )));
                    }
                }
            }
        }
        let amf_ue_ngap_id = amf_ue_ngap_id.ok_or(aper::AperCodecError::new(format!(
            "Missing mandatory IE amf_ue_ngap_id"
        )))?;
        let ran_ue_ngap_id = ran_ue_ngap_id.ok_or(aper::AperCodecError::new(format!(
            "Missing mandatory IE ran_ue_ngap_id"
        )))?;
        Ok(Self {
            amf_ue_ngap_id,
            ran_ue_ngap_id,
            ue_radio_capability,
            ue_radio_capability_id,
        })
    }
}

// UeRadioCapabilityCheckResponse
#[derive(Clone)]
pub struct UeRadioCapabilityCheckResponse {
    pub amf_ue_ngap_id: AmfUeNgapId,
    pub ran_ue_ngap_id: RanUeNgapId,
    pub ims_voice_support_indicator: ImsVoiceSupportIndicator,
    pub criticality_diagnostics: Option<CriticalityDiagnostics>,
}

impl AperCodec for UeRadioCapabilityCheckResponse {
    type Output = UeRadioCapabilityCheckResponse;
    fn decode(data: &mut AperCodecData) -> Result<Self::Output, AperCodecError> {
        let _length = aper::decode::decode_length_determinent(data, None, None, false)?;
        let _ = aper::decode::decode_sequence_header(data, true, 0)?;
        let len = aper::decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut amf_ue_ngap_id: Option<AmfUeNgapId> = None;
        let mut ran_ue_ngap_id: Option<RanUeNgapId> = None;
        let mut ims_voice_support_indicator: Option<ImsVoiceSupportIndicator> = None;
        let mut criticality_diagnostics: Option<CriticalityDiagnostics> = None;

        for _ in 0..len {
            let (id, _ext) = aper::decode::decode_integer(data, Some(0), Some(65535), false)?;
            let criticality = Criticality::decode(data)?;
            let _length = aper::decode::decode_length_determinent(data, None, None, false)?;
            match id {
                10 => {
                    amf_ue_ngap_id = Some(AmfUeNgapId::decode(data)?);
                }
                85 => {
                    ran_ue_ngap_id = Some(RanUeNgapId::decode(data)?);
                }
                30 => {
                    ims_voice_support_indicator = Some(ImsVoiceSupportIndicator::decode(data)?);
                }
                19 => {
                    criticality_diagnostics = Some(CriticalityDiagnostics::decode(data)?);
                }
                x => {
                    if let Criticality::Reject = criticality {
                        return Err(aper::AperCodecError::new(format!(
                            "Unrecognised IE type {} with criticality reject",
                            x
                        )));
                    }
                }
            }
        }
        let amf_ue_ngap_id = amf_ue_ngap_id.ok_or(aper::AperCodecError::new(format!(
            "Missing mandatory IE amf_ue_ngap_id"
        )))?;
        let ran_ue_ngap_id = ran_ue_ngap_id.ok_or(aper::AperCodecError::new(format!(
            "Missing mandatory IE ran_ue_ngap_id"
        )))?;
        let ims_voice_support_indicator = ims_voice_support_indicator.ok_or(
            aper::AperCodecError::new(format!("Missing mandatory IE ims_voice_support_indicator")),
        )?;
        Ok(Self {
            amf_ue_ngap_id,
            ran_ue_ngap_id,
            ims_voice_support_indicator,
            criticality_diagnostics,
        })
    }
}

// PrivateMessage - omitted

// SecondaryRatDataUsageReport
#[derive(Clone)]
pub struct SecondaryRatDataUsageReport {
    pub amf_ue_ngap_id: AmfUeNgapId,
    pub ran_ue_ngap_id: RanUeNgapId,
    pub pdu_session_resource_secondary_rat_usage_list: PduSessionResourceSecondaryRatUsageList,
    pub handover_flag: Option<HandoverFlag>,
    pub user_location_information: Option<UserLocationInformation>,
}

impl AperCodec for SecondaryRatDataUsageReport {
    type Output = SecondaryRatDataUsageReport;
    fn decode(data: &mut AperCodecData) -> Result<Self::Output, AperCodecError> {
        let _length = aper::decode::decode_length_determinent(data, None, None, false)?;
        let _ = aper::decode::decode_sequence_header(data, true, 0)?;
        let len = aper::decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut amf_ue_ngap_id: Option<AmfUeNgapId> = None;
        let mut ran_ue_ngap_id: Option<RanUeNgapId> = None;
        let mut pdu_session_resource_secondary_rat_usage_list: Option<
            PduSessionResourceSecondaryRatUsageList,
        > = None;
        let mut handover_flag: Option<HandoverFlag> = None;
        let mut user_location_information: Option<UserLocationInformation> = None;

        for _ in 0..len {
            let (id, _ext) = aper::decode::decode_integer(data, Some(0), Some(65535), false)?;
            let criticality = Criticality::decode(data)?;
            let _length = aper::decode::decode_length_determinent(data, None, None, false)?;
            match id {
                10 => {
                    amf_ue_ngap_id = Some(AmfUeNgapId::decode(data)?);
                }
                85 => {
                    ran_ue_ngap_id = Some(RanUeNgapId::decode(data)?);
                }
                142 => {
                    pdu_session_resource_secondary_rat_usage_list =
                        Some(PduSessionResourceSecondaryRatUsageList::decode(data)?);
                }
                143 => {
                    handover_flag = Some(HandoverFlag::decode(data)?);
                }
                121 => {
                    user_location_information = Some(UserLocationInformation::decode(data)?);
                }
                x => {
                    if let Criticality::Reject = criticality {
                        return Err(aper::AperCodecError::new(format!(
                            "Unrecognised IE type {} with criticality reject",
                            x
                        )));
                    }
                }
            }
        }
        let amf_ue_ngap_id = amf_ue_ngap_id.ok_or(aper::AperCodecError::new(format!(
            "Missing mandatory IE amf_ue_ngap_id"
        )))?;
        let ran_ue_ngap_id = ran_ue_ngap_id.ok_or(aper::AperCodecError::new(format!(
            "Missing mandatory IE ran_ue_ngap_id"
        )))?;
        let pdu_session_resource_secondary_rat_usage_list =
            pdu_session_resource_secondary_rat_usage_list.ok_or(aper::AperCodecError::new(
                format!("Missing mandatory IE pdu_session_resource_secondary_rat_usage_list"),
            ))?;
        Ok(Self {
            amf_ue_ngap_id,
            ran_ue_ngap_id,
            pdu_session_resource_secondary_rat_usage_list,
            handover_flag,
            user_location_information,
        })
    }
}

// UplinkRimInformationTransfer
#[derive(Clone)]
pub struct UplinkRimInformationTransfer {
    pub rim_information_transfer: Option<RimInformationTransfer>,
}

impl AperCodec for UplinkRimInformationTransfer {
    type Output = UplinkRimInformationTransfer;
    fn decode(data: &mut AperCodecData) -> Result<Self::Output, AperCodecError> {
        let _length = aper::decode::decode_length_determinent(data, None, None, false)?;
        let _ = aper::decode::decode_sequence_header(data, true, 0)?;
        let len = aper::decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut rim_information_transfer: Option<RimInformationTransfer> = None;

        for _ in 0..len {
            let (id, _ext) = aper::decode::decode_integer(data, Some(0), Some(65535), false)?;
            let criticality = Criticality::decode(data)?;
            let _length = aper::decode::decode_length_determinent(data, None, None, false)?;
            match id {
                175 => {
                    rim_information_transfer = Some(RimInformationTransfer::decode(data)?);
                }
                x => {
                    if let Criticality::Reject = criticality {
                        return Err(aper::AperCodecError::new(format!(
                            "Unrecognised IE type {} with criticality reject",
                            x
                        )));
                    }
                }
            }
        }
        Ok(Self {
            rim_information_transfer,
        })
    }
}

// DownlinkRimInformationTransfer
#[derive(Clone)]
pub struct DownlinkRimInformationTransfer {
    pub rim_information_transfer: Option<RimInformationTransfer>,
}

impl AperCodec for DownlinkRimInformationTransfer {
    type Output = DownlinkRimInformationTransfer;
    fn decode(data: &mut AperCodecData) -> Result<Self::Output, AperCodecError> {
        let _length = aper::decode::decode_length_determinent(data, None, None, false)?;
        let _ = aper::decode::decode_sequence_header(data, true, 0)?;
        let len = aper::decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut rim_information_transfer: Option<RimInformationTransfer> = None;

        for _ in 0..len {
            let (id, _ext) = aper::decode::decode_integer(data, Some(0), Some(65535), false)?;
            let criticality = Criticality::decode(data)?;
            let _length = aper::decode::decode_length_determinent(data, None, None, false)?;
            match id {
                175 => {
                    rim_information_transfer = Some(RimInformationTransfer::decode(data)?);
                }
                x => {
                    if let Criticality::Reject = criticality {
                        return Err(aper::AperCodecError::new(format!(
                            "Unrecognised IE type {} with criticality reject",
                            x
                        )));
                    }
                }
            }
        }
        Ok(Self {
            rim_information_transfer,
        })
    }
}

// ConnectionEstablishmentIndication
#[derive(Clone)]
pub struct ConnectionEstablishmentIndication {
    pub amf_ue_ngap_id: AmfUeNgapId,
    pub ran_ue_ngap_id: RanUeNgapId,
    pub ue_radio_capability: Option<UeRadioCapability>,
    pub end_indication: Option<EndIndication>,
    pub s_nssai: Option<SNssai>,
    pub allowed_nssai: Option<AllowedNssai>,
    pub ue_differentiation_info: Option<UeDifferentiationInfo>,
    pub dl_cp_security_information: Option<DlCpSecurityInformation>,
    pub nb_iot_ue_priority: Option<NbIotUePriority>,
    pub enhanced_coverage_restriction: Option<EnhancedCoverageRestriction>,
    pub c_emode_brestricted: Option<CEmodeBrestricted>,
    pub ue_radio_capability_id: Option<UeRadioCapabilityId>,
}

impl AperCodec for ConnectionEstablishmentIndication {
    type Output = ConnectionEstablishmentIndication;
    fn decode(data: &mut AperCodecData) -> Result<Self::Output, AperCodecError> {
        let _length = aper::decode::decode_length_determinent(data, None, None, false)?;
        let _ = aper::decode::decode_sequence_header(data, true, 0)?;
        let len = aper::decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut amf_ue_ngap_id: Option<AmfUeNgapId> = None;
        let mut ran_ue_ngap_id: Option<RanUeNgapId> = None;
        let mut ue_radio_capability: Option<UeRadioCapability> = None;
        let mut end_indication: Option<EndIndication> = None;
        let mut s_nssai: Option<SNssai> = None;
        let mut allowed_nssai: Option<AllowedNssai> = None;
        let mut ue_differentiation_info: Option<UeDifferentiationInfo> = None;
        let mut dl_cp_security_information: Option<DlCpSecurityInformation> = None;
        let mut nb_iot_ue_priority: Option<NbIotUePriority> = None;
        let mut enhanced_coverage_restriction: Option<EnhancedCoverageRestriction> = None;
        let mut c_emode_brestricted: Option<CEmodeBrestricted> = None;
        let mut ue_radio_capability_id: Option<UeRadioCapabilityId> = None;

        for _ in 0..len {
            let (id, _ext) = aper::decode::decode_integer(data, Some(0), Some(65535), false)?;
            let criticality = Criticality::decode(data)?;
            let _length = aper::decode::decode_length_determinent(data, None, None, false)?;
            match id {
                10 => {
                    amf_ue_ngap_id = Some(AmfUeNgapId::decode(data)?);
                }
                85 => {
                    ran_ue_ngap_id = Some(RanUeNgapId::decode(data)?);
                }
                117 => {
                    ue_radio_capability = Some(UeRadioCapability::decode(data)?);
                }
                226 => {
                    end_indication = Some(EndIndication::decode(data)?);
                }
                148 => {
                    s_nssai = Some(SNssai::decode(data)?);
                }
                0 => {
                    allowed_nssai = Some(AllowedNssai::decode(data)?);
                }
                209 => {
                    ue_differentiation_info = Some(UeDifferentiationInfo::decode(data)?);
                }
                212 => {
                    dl_cp_security_information = Some(DlCpSecurityInformation::decode(data)?);
                }
                210 => {
                    nb_iot_ue_priority = Some(NbIotUePriority::decode(data)?);
                }
                205 => {
                    enhanced_coverage_restriction =
                        Some(EnhancedCoverageRestriction::decode(data)?);
                }
                222 => {
                    c_emode_brestricted = Some(CEmodeBrestricted::decode(data)?);
                }
                264 => {
                    ue_radio_capability_id = Some(UeRadioCapabilityId::decode(data)?);
                }
                x => {
                    if let Criticality::Reject = criticality {
                        return Err(aper::AperCodecError::new(format!(
                            "Unrecognised IE type {} with criticality reject",
                            x
                        )));
                    }
                }
            }
        }
        let amf_ue_ngap_id = amf_ue_ngap_id.ok_or(aper::AperCodecError::new(format!(
            "Missing mandatory IE amf_ue_ngap_id"
        )))?;
        let ran_ue_ngap_id = ran_ue_ngap_id.ok_or(aper::AperCodecError::new(format!(
            "Missing mandatory IE ran_ue_ngap_id"
        )))?;
        Ok(Self {
            amf_ue_ngap_id,
            ran_ue_ngap_id,
            ue_radio_capability,
            end_indication,
            s_nssai,
            allowed_nssai,
            ue_differentiation_info,
            dl_cp_security_information,
            nb_iot_ue_priority,
            enhanced_coverage_restriction,
            c_emode_brestricted,
            ue_radio_capability_id,
        })
    }
}

// UeRadioCapabilityIdMappingRequest
#[derive(Clone)]
pub struct UeRadioCapabilityIdMappingRequest {
    pub ue_radio_capability_id: UeRadioCapabilityId,
}

impl AperCodec for UeRadioCapabilityIdMappingRequest {
    type Output = UeRadioCapabilityIdMappingRequest;
    fn decode(data: &mut AperCodecData) -> Result<Self::Output, AperCodecError> {
        let _length = aper::decode::decode_length_determinent(data, None, None, false)?;
        let _ = aper::decode::decode_sequence_header(data, true, 0)?;
        let len = aper::decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut ue_radio_capability_id: Option<UeRadioCapabilityId> = None;

        for _ in 0..len {
            let (id, _ext) = aper::decode::decode_integer(data, Some(0), Some(65535), false)?;
            let criticality = Criticality::decode(data)?;
            let _length = aper::decode::decode_length_determinent(data, None, None, false)?;
            match id {
                264 => {
                    ue_radio_capability_id = Some(UeRadioCapabilityId::decode(data)?);
                }
                x => {
                    if let Criticality::Reject = criticality {
                        return Err(aper::AperCodecError::new(format!(
                            "Unrecognised IE type {} with criticality reject",
                            x
                        )));
                    }
                }
            }
        }
        let ue_radio_capability_id = ue_radio_capability_id.ok_or(aper::AperCodecError::new(
            format!("Missing mandatory IE ue_radio_capability_id"),
        ))?;
        Ok(Self {
            ue_radio_capability_id,
        })
    }
}

// UeRadioCapabilityIdMappingResponse
#[derive(Clone)]
pub struct UeRadioCapabilityIdMappingResponse {
    pub ue_radio_capability_id: UeRadioCapabilityId,
    pub ue_radio_capability: UeRadioCapability,
    pub criticality_diagnostics: Option<CriticalityDiagnostics>,
}

impl AperCodec for UeRadioCapabilityIdMappingResponse {
    type Output = UeRadioCapabilityIdMappingResponse;
    fn decode(data: &mut AperCodecData) -> Result<Self::Output, AperCodecError> {
        let _length = aper::decode::decode_length_determinent(data, None, None, false)?;
        let _ = aper::decode::decode_sequence_header(data, true, 0)?;
        let len = aper::decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut ue_radio_capability_id: Option<UeRadioCapabilityId> = None;
        let mut ue_radio_capability: Option<UeRadioCapability> = None;
        let mut criticality_diagnostics: Option<CriticalityDiagnostics> = None;

        for _ in 0..len {
            let (id, _ext) = aper::decode::decode_integer(data, Some(0), Some(65535), false)?;
            let criticality = Criticality::decode(data)?;
            let _length = aper::decode::decode_length_determinent(data, None, None, false)?;
            match id {
                264 => {
                    ue_radio_capability_id = Some(UeRadioCapabilityId::decode(data)?);
                }
                117 => {
                    ue_radio_capability = Some(UeRadioCapability::decode(data)?);
                }
                19 => {
                    criticality_diagnostics = Some(CriticalityDiagnostics::decode(data)?);
                }
                x => {
                    if let Criticality::Reject = criticality {
                        return Err(aper::AperCodecError::new(format!(
                            "Unrecognised IE type {} with criticality reject",
                            x
                        )));
                    }
                }
            }
        }
        let ue_radio_capability_id = ue_radio_capability_id.ok_or(aper::AperCodecError::new(
            format!("Missing mandatory IE ue_radio_capability_id"),
        ))?;
        let ue_radio_capability = ue_radio_capability.ok_or(aper::AperCodecError::new(format!(
            "Missing mandatory IE ue_radio_capability"
        )))?;
        Ok(Self {
            ue_radio_capability_id,
            ue_radio_capability,
            criticality_diagnostics,
        })
    }
}

// AmfcpRelocationIndication
#[derive(Clone)]
pub struct AmfcpRelocationIndication {
    pub amf_ue_ngap_id: AmfUeNgapId,
    pub ran_ue_ngap_id: RanUeNgapId,
    pub s_nssai: Option<SNssai>,
    pub allowed_nssai: Option<AllowedNssai>,
}

impl AperCodec for AmfcpRelocationIndication {
    type Output = AmfcpRelocationIndication;
    fn decode(data: &mut AperCodecData) -> Result<Self::Output, AperCodecError> {
        let _length = aper::decode::decode_length_determinent(data, None, None, false)?;
        let _ = aper::decode::decode_sequence_header(data, true, 0)?;
        let len = aper::decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut amf_ue_ngap_id: Option<AmfUeNgapId> = None;
        let mut ran_ue_ngap_id: Option<RanUeNgapId> = None;
        let mut s_nssai: Option<SNssai> = None;
        let mut allowed_nssai: Option<AllowedNssai> = None;

        for _ in 0..len {
            let (id, _ext) = aper::decode::decode_integer(data, Some(0), Some(65535), false)?;
            let criticality = Criticality::decode(data)?;
            let _length = aper::decode::decode_length_determinent(data, None, None, false)?;
            match id {
                10 => {
                    amf_ue_ngap_id = Some(AmfUeNgapId::decode(data)?);
                }
                85 => {
                    ran_ue_ngap_id = Some(RanUeNgapId::decode(data)?);
                }
                148 => {
                    s_nssai = Some(SNssai::decode(data)?);
                }
                0 => {
                    allowed_nssai = Some(AllowedNssai::decode(data)?);
                }
                x => {
                    if let Criticality::Reject = criticality {
                        return Err(aper::AperCodecError::new(format!(
                            "Unrecognised IE type {} with criticality reject",
                            x
                        )));
                    }
                }
            }
        }
        let amf_ue_ngap_id = amf_ue_ngap_id.ok_or(aper::AperCodecError::new(format!(
            "Missing mandatory IE amf_ue_ngap_id"
        )))?;
        let ran_ue_ngap_id = ran_ue_ngap_id.ok_or(aper::AperCodecError::new(format!(
            "Missing mandatory IE ran_ue_ngap_id"
        )))?;
        Ok(Self {
            amf_ue_ngap_id,
            ran_ue_ngap_id,
            s_nssai,
            allowed_nssai,
        })
    }
}
