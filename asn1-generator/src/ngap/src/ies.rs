// Copyright (c) Nicholas Larkin
// Autogenerated from NGAP-IEs.asn
use super::common::*;

use asn1::BitString;
use asn1::aper::{
    APerElement, Constraint, Constraints, DecodeError, Decoder, EncodeError, Encoding,
    UNCONSTRAINED,
};
use num_derive::FromPrimitive;
use num_traits::FromPrimitive;
// XnTlAs
pub struct XnTlAs(pub Vec<TransportLayerAddress>);

impl APerElement for XnTlAs {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(1),
            max: Some(1),
        }),
    };
    fn from_aper(decoder: &mut Decoder, constraints: Constraints) -> Result<Self, DecodeError> {
        Ok(Self(Vec<TransportLayerAddress>::from_aper(decoder, Self::CONSTRAINTS)?))
    }
    fn to_aper(&self, constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&(self.0).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// XnTnlConfigurationInfo
pub struct XnTnlConfigurationInfo {
    pub xn_transport_layer_addresses: XnTlAs,
    pub xn_extended_transport_layer_addresses: Option<XnExtTlAs>,
}

impl APerElement for XnTnlConfigurationInfo {
    const CONSTRAINTS: Constraints = Constraints {
        value: None,
        size: Some(Constraint {
            min: Some(2),
            max: Some(2),
        }),
    };
    fn from_aper(decoder: &mut Decoder, constraints: Constraints) -> Result<Self, DecodeError> {
        let _extended = bool::from_aper(decoder, UNCONSTRAINED)?;
        let optionals = BitString::from_aper(decoder, Self::CONSTRAINTS)?;
        let xn_transport_layer_addresses = XnTlAs::from_aper(decoder, UNCONSTRAINED)?;
        let xn_extended_transport_layer_addresses = if optionals.is_set(0) {
            Some(XnExtTlAs::from_aper(decoder, UNCONSTRAINED)?)
        } else {
            None
        };

        Ok(Self {
            xn_transport_layer_addresses,
            xn_extended_transport_layer_addresses,
        })
    }
    fn to_aper(&self, constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        let mut optionals = BitString::with_len(2);
        optionals.set(0, self.xn_extended_transport_layer_addresses.is_some());

        enc.append(&false.to_aper(UNCONSTRAINED)?)?;
        enc.append(&optionals.to_aper(Self::CONSTRAINTS)?)?;
        enc.append(&self.xn_transport_layer_addresses.to_aper(UNCONSTRAINED)?);
        if let Some(x) = self.xn_extended_transport_layer_addresses {
            enc.append(&x.to_aper(UNCONSTRAINED)?);
        }

        Ok(enc)
    }
}

// PniNpnRestricted
#[derive(Clone, Copy, FromPrimitive)]
pub enum PniNpnRestricted {
    Restricted,
    NotRestricted,
    _Extended,
}

impl APerElement for PniNpnRestricted {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, constraints: Constraints) -> Result<Self, DecodeError> {
        if bool::from_aper(decoder, Self::CONSTRAINTS)? {
            return Ok(PniNpnRestricted::_Extended)
        }
        let v = u8::from_aper(decoder, Self::CONSTRAINTS)?;
        FromPrimitive::from_u8(v).ok_or(DecodeError::MalformedInt)
    }
    fn to_aper(&self, constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&false.to_aper(UNCONSTRAINED)?)?;
        enc.append(&(*self as u8).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// QosFlowMappingIndication
#[derive(Clone, Copy, FromPrimitive)]
pub enum QosFlowMappingIndication {
    Ul,
    Dl,
    _Extended,
}

impl APerElement for QosFlowMappingIndication {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, constraints: Constraints) -> Result<Self, DecodeError> {
        if bool::from_aper(decoder, Self::CONSTRAINTS)? {
            return Ok(QosFlowMappingIndication::_Extended)
        }
        let v = u8::from_aper(decoder, Self::CONSTRAINTS)?;
        FromPrimitive::from_u8(v).ok_or(DecodeError::MalformedInt)
    }
    fn to_aper(&self, constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&false.to_aper(UNCONSTRAINED)?)?;
        enc.append(&(*self as u8).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// BtRssi
#[derive(Clone, Copy, FromPrimitive)]
pub enum BtRssi {
    True,
    _Extended,
}

impl APerElement for BtRssi {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, constraints: Constraints) -> Result<Self, DecodeError> {
        if bool::from_aper(decoder, Self::CONSTRAINTS)? {
            return Ok(BtRssi::_Extended)
        }
        let v = u8::from_aper(decoder, Self::CONSTRAINTS)?;
        FromPrimitive::from_u8(v).ok_or(DecodeError::MalformedInt)
    }
    fn to_aper(&self, constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&false.to_aper(UNCONSTRAINED)?)?;
        enc.append(&(*self as u8).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// CnType
#[derive(Clone, Copy, FromPrimitive)]
pub enum CnType {
    EpcForbidden,
    FiveGcForbidden,
    _Extended,
}

impl APerElement for CnType {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, constraints: Constraints) -> Result<Self, DecodeError> {
        if bool::from_aper(decoder, Self::CONSTRAINTS)? {
            return Ok(CnType::_Extended)
        }
        let v = u8::from_aper(decoder, Self::CONSTRAINTS)?;
        FromPrimitive::from_u8(v).ok_or(DecodeError::MalformedInt)
    }
    fn to_aper(&self, constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&false.to_aper(UNCONSTRAINED)?)?;
        enc.append(&(*self as u8).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// DapsIndicator
#[derive(Clone, Copy, FromPrimitive)]
pub enum DapsIndicator {
    DapsHoRequired,
    _Extended,
}

impl APerElement for DapsIndicator {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, constraints: Constraints) -> Result<Self, DecodeError> {
        if bool::from_aper(decoder, Self::CONSTRAINTS)? {
            return Ok(DapsIndicator::_Extended)
        }
        let v = u8::from_aper(decoder, Self::CONSTRAINTS)?;
        FromPrimitive::from_u8(v).ok_or(DecodeError::MalformedInt)
    }
    fn to_aper(&self, constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&false.to_aper(UNCONSTRAINED)?)?;
        enc.append(&(*self as u8).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// Dapsresponseindicator
#[derive(Clone, Copy, FromPrimitive)]
pub enum Dapsresponseindicator {
    DapsHoAccepted,
    DapsHoNotAccepted,
    _Extended,
}

impl APerElement for Dapsresponseindicator {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, constraints: Constraints) -> Result<Self, DecodeError> {
        if bool::from_aper(decoder, Self::CONSTRAINTS)? {
            return Ok(Dapsresponseindicator::_Extended)
        }
        let v = u8::from_aper(decoder, Self::CONSTRAINTS)?;
        FromPrimitive::from_u8(v).ok_or(DecodeError::MalformedInt)
    }
    fn to_aper(&self, constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&false.to_aper(UNCONSTRAINED)?)?;
        enc.append(&(*self as u8).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// OutOfCoverage
#[derive(Clone, Copy, FromPrimitive)]
pub enum OutOfCoverage {
    True,
    _Extended,
}

impl APerElement for OutOfCoverage {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, constraints: Constraints) -> Result<Self, DecodeError> {
        if bool::from_aper(decoder, Self::CONSTRAINTS)? {
            return Ok(OutOfCoverage::_Extended)
        }
        let v = u8::from_aper(decoder, Self::CONSTRAINTS)?;
        FromPrimitive::from_u8(v).ok_or(DecodeError::MalformedInt)
    }
    fn to_aper(&self, constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&false.to_aper(UNCONSTRAINED)?)?;
        enc.append(&(*self as u8).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// HandoverReportType
#[derive(Clone, Copy, FromPrimitive)]
pub enum HandoverReportType {
    HoTooEarly,
    HoToWrongCell,
    IntersystemPingPong,
    _Extended,
}

impl APerElement for HandoverReportType {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, constraints: Constraints) -> Result<Self, DecodeError> {
        if bool::from_aper(decoder, Self::CONSTRAINTS)? {
            return Ok(HandoverReportType::_Extended)
        }
        let v = u8::from_aper(decoder, Self::CONSTRAINTS)?;
        FromPrimitive::from_u8(v).ok_or(DecodeError::MalformedInt)
    }
    fn to_aper(&self, constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&false.to_aper(UNCONSTRAINED)?)?;
        enc.append(&(*self as u8).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// EarlyIratho
#[derive(Clone, Copy, FromPrimitive)]
pub enum EarlyIratho {
    True,
    False,
    _Extended,
}

impl APerElement for EarlyIratho {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, constraints: Constraints) -> Result<Self, DecodeError> {
        if bool::from_aper(decoder, Self::CONSTRAINTS)? {
            return Ok(EarlyIratho::_Extended)
        }
        let v = u8::from_aper(decoder, Self::CONSTRAINTS)?;
        FromPrimitive::from_u8(v).ok_or(DecodeError::MalformedInt)
    }
    fn to_aper(&self, constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&false.to_aper(UNCONSTRAINED)?)?;
        enc.append(&(*self as u8).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// RatType
#[derive(Clone, Copy, FromPrimitive)]
pub enum RatType {
    Nr,
    Eutra,
    _Extended,
}

impl APerElement for RatType {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, constraints: Constraints) -> Result<Self, DecodeError> {
        if bool::from_aper(decoder, Self::CONSTRAINTS)? {
            return Ok(RatType::_Extended)
        }
        let v = u8::from_aper(decoder, Self::CONSTRAINTS)?;
        FromPrimitive::from_u8(v).ok_or(DecodeError::MalformedInt)
    }
    fn to_aper(&self, constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&false.to_aper(UNCONSTRAINED)?)?;
        enc.append(&(*self as u8).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// RatType1
#[derive(Clone, Copy, FromPrimitive)]
pub enum RatType1 {
    Nr,
    Eutra,
    _Extended,
}

impl APerElement for RatType1 {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, constraints: Constraints) -> Result<Self, DecodeError> {
        if bool::from_aper(decoder, Self::CONSTRAINTS)? {
            return Ok(RatType1::_Extended)
        }
        let v = u8::from_aper(decoder, Self::CONSTRAINTS)?;
        FromPrimitive::from_u8(v).ok_or(DecodeError::MalformedInt)
    }
    fn to_aper(&self, constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&false.to_aper(UNCONSTRAINED)?)?;
        enc.append(&(*self as u8).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// RimRsDetection
#[derive(Clone, Copy, FromPrimitive)]
pub enum RimRsDetection {
    RsDetected,
    RsDisappeared,
    _Extended,
}

impl APerElement for RimRsDetection {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, constraints: Constraints) -> Result<Self, DecodeError> {
        if bool::from_aper(decoder, Self::CONSTRAINTS)? {
            return Ok(RimRsDetection::_Extended)
        }
        let v = u8::from_aper(decoder, Self::CONSTRAINTS)?;
        FromPrimitive::from_u8(v).ok_or(DecodeError::MalformedInt)
    }
    fn to_aper(&self, constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&false.to_aper(UNCONSTRAINED)?)?;
        enc.append(&(*self as u8).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// UncompensatedBarometricConfig
#[derive(Clone, Copy, FromPrimitive)]
pub enum UncompensatedBarometricConfig {
    True,
    _Extended,
}

impl APerElement for UncompensatedBarometricConfig {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, constraints: Constraints) -> Result<Self, DecodeError> {
        if bool::from_aper(decoder, Self::CONSTRAINTS)? {
            return Ok(UncompensatedBarometricConfig::_Extended)
        }
        let v = u8::from_aper(decoder, Self::CONSTRAINTS)?;
        FromPrimitive::from_u8(v).ok_or(DecodeError::MalformedInt)
    }
    fn to_aper(&self, constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&false.to_aper(UNCONSTRAINED)?)?;
        enc.append(&(*self as u8).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// UeSpeedConfig
#[derive(Clone, Copy, FromPrimitive)]
pub enum UeSpeedConfig {
    True,
    _Extended,
}

impl APerElement for UeSpeedConfig {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, constraints: Constraints) -> Result<Self, DecodeError> {
        if bool::from_aper(decoder, Self::CONSTRAINTS)? {
            return Ok(UeSpeedConfig::_Extended)
        }
        let v = u8::from_aper(decoder, Self::CONSTRAINTS)?;
        FromPrimitive::from_u8(v).ok_or(DecodeError::MalformedInt)
    }
    fn to_aper(&self, constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&false.to_aper(UNCONSTRAINED)?)?;
        enc.append(&(*self as u8).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// UeOrientationConfig
#[derive(Clone, Copy, FromPrimitive)]
pub enum UeOrientationConfig {
    True,
    _Extended,
}

impl APerElement for UeOrientationConfig {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, constraints: Constraints) -> Result<Self, DecodeError> {
        if bool::from_aper(decoder, Self::CONSTRAINTS)? {
            return Ok(UeOrientationConfig::_Extended)
        }
        let v = u8::from_aper(decoder, Self::CONSTRAINTS)?;
        FromPrimitive::from_u8(v).ok_or(DecodeError::MalformedInt)
    }
    fn to_aper(&self, constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&false.to_aper(UNCONSTRAINED)?)?;
        enc.append(&(*self as u8).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// PeriodicCommunicationIndicator
#[derive(Clone, Copy, FromPrimitive)]
pub enum PeriodicCommunicationIndicator {
    Periodically,
    Ondemand,
    _Extended,
}

impl APerElement for PeriodicCommunicationIndicator {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, constraints: Constraints) -> Result<Self, DecodeError> {
        if bool::from_aper(decoder, Self::CONSTRAINTS)? {
            return Ok(PeriodicCommunicationIndicator::_Extended)
        }
        let v = u8::from_aper(decoder, Self::CONSTRAINTS)?;
        FromPrimitive::from_u8(v).ok_or(DecodeError::MalformedInt)
    }
    fn to_aper(&self, constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&false.to_aper(UNCONSTRAINED)?)?;
        enc.append(&(*self as u8).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// StationaryIndication
#[derive(Clone, Copy, FromPrimitive)]
pub enum StationaryIndication {
    Stationary,
    Mobile,
    _Extended,
}

impl APerElement for StationaryIndication {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, constraints: Constraints) -> Result<Self, DecodeError> {
        if bool::from_aper(decoder, Self::CONSTRAINTS)? {
            return Ok(StationaryIndication::_Extended)
        }
        let v = u8::from_aper(decoder, Self::CONSTRAINTS)?;
        FromPrimitive::from_u8(v).ok_or(DecodeError::MalformedInt)
    }
    fn to_aper(&self, constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&false.to_aper(UNCONSTRAINED)?)?;
        enc.append(&(*self as u8).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// TrafficProfile
#[derive(Clone, Copy, FromPrimitive)]
pub enum TrafficProfile {
    SinglePacket,
    DualPackets,
    MultiplePackets,
    _Extended,
}

impl APerElement for TrafficProfile {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, constraints: Constraints) -> Result<Self, DecodeError> {
        if bool::from_aper(decoder, Self::CONSTRAINTS)? {
            return Ok(TrafficProfile::_Extended)
        }
        let v = u8::from_aper(decoder, Self::CONSTRAINTS)?;
        FromPrimitive::from_u8(v).ok_or(DecodeError::MalformedInt)
    }
    fn to_aper(&self, constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&false.to_aper(UNCONSTRAINED)?)?;
        enc.append(&(*self as u8).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// BatteryIndication
#[derive(Clone, Copy, FromPrimitive)]
pub enum BatteryIndication {
    BatteryPowered,
    BatteryPoweredNotRechargeableOrReplaceable,
    NotBatteryPowered,
    _Extended,
}

impl APerElement for BatteryIndication {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, constraints: Constraints) -> Result<Self, DecodeError> {
        if bool::from_aper(decoder, Self::CONSTRAINTS)? {
            return Ok(BatteryIndication::_Extended)
        }
        let v = u8::from_aper(decoder, Self::CONSTRAINTS)?;
        FromPrimitive::from_u8(v).ok_or(DecodeError::MalformedInt)
    }
    fn to_aper(&self, constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&false.to_aper(UNCONSTRAINED)?)?;
        enc.append(&(*self as u8).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// WlanRssi
#[derive(Clone, Copy, FromPrimitive)]
pub enum WlanRssi {
    True,
    _Extended,
}

impl APerElement for WlanRssi {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, constraints: Constraints) -> Result<Self, DecodeError> {
        if bool::from_aper(decoder, Self::CONSTRAINTS)? {
            return Ok(WlanRssi::_Extended)
        }
        let v = u8::from_aper(decoder, Self::CONSTRAINTS)?;
        FromPrimitive::from_u8(v).ok_or(DecodeError::MalformedInt)
    }
    fn to_aper(&self, constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&false.to_aper(UNCONSTRAINED)?)?;
        enc.append(&(*self as u8).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

// WlanRtt
#[derive(Clone, Copy, FromPrimitive)]
pub enum WlanRtt {
    True,
    _Extended,
}

impl APerElement for WlanRtt {
    const CONSTRAINTS: Constraints = UNCONSTRAINED;
    fn from_aper(decoder: &mut Decoder, constraints: Constraints) -> Result<Self, DecodeError> {
        if bool::from_aper(decoder, Self::CONSTRAINTS)? {
            return Ok(WlanRtt::_Extended)
        }
        let v = u8::from_aper(decoder, Self::CONSTRAINTS)?;
        FromPrimitive::from_u8(v).ok_or(DecodeError::MalformedInt)
    }
    fn to_aper(&self, constraints: Constraints) -> Result<Encoding, EncodeError> {
        let mut enc = Encoding::new();
        enc.append(&false.to_aper(UNCONSTRAINED)?)?;
        enc.append(&(*self as u8).to_aper(Self::CONSTRAINTS)?)?;
        Ok(enc)
    }
}

