#!/usr/bin/env python3

from itertools import permutations, takewhile
import unittest
from lark.visitors import Transformer, Visitor, Discard
from case import pascal_case, snake_case
from lark.lexer import Token
from lark import Tree, v_args
from parse import parse_string, parse_file
import sys


# Add a new type name and ensure it is unique
def add_type_name(orig_typename, name_dict):
    name = pascal_case(orig_typename)
    if name_dict.get(name):
        underscore = '_' if orig_typename[-1].isdigit() else ''
        suffix = 1
        while name_dict.get(name + underscore + str(suffix)):
            suffix += 1
        name = name + underscore + str(suffix)
    name_dict[name] = True
    return name


class TypeNameFinder(Visitor):
    def __init__(self):
        self.name_dict = dict()
        self.convert = dict()
        self.ie_dict = dict()

    def add(self, orig_typename):
        name = add_type_name(orig_typename, self.name_dict)
        print(f"{orig_typename} -> {name}")
        self.convert[orig_typename] = name

    def choice_def(self, tree):
        self.add(tree.children[0])

    def primitive_def(self, tree):
        self.add(tree.children[0])

    def enum_def(self, tree):
        self.add(tree.children[0])

    def sequence_def(self, tree):
        self.add(tree.children[0])

    def object_def(self, tree):
        self.ie_dict[tree.children[0]] = tree.children[1]


# This IeContainerMerger transformer is specific to the xxAP protocol pattern of using a ProtocolIeContainer
# or ProtocolExtensionContainer with ASN.1 open types for the IEs inside it.
#
# The goal of this transformer is to make the container construct look like a normal structure / sequence
# so that it is more ergonomic to use the autogenerated struct.
#
# The strategy is to graft in the IEs into the point at which the container is referenced.  This enables
# the later render stage to output these as fields in a single pass.
@v_args(tree=True)
class IeContainerMerger(Transformer):
    def __init__(self, ies=dict()):
        self.ie_dict = ies

    def choice(self, tree):
        # For a CHOICE of ProtocolIeContainer, we go fronm
        #   choice
        #     choice_field_ie_container                 <- tree.children[0]
        #       EutranBearerContextSetupRequest
        #       EutranBearerContextSetupRequest   <- tree.children[0].children[1]
        #     choice_field_ie_container
        #       ...etc
        #  object_def
        #    EutranBearerContextSetupRequest
        #    ies
        #      ie
        #
        #  ...to
        #   choice
        #     choice_field
        #       EutranBearerContextSetupRequest
        #       ies
        #         ie
        #     choice_field
        #       ...etc
        #
        # The ies section will then get broken out into a separate protocol_ie_container in a later
        # stage - see transform_type().
        #
        # For a CHOICE with an extension container with one or more ies in it, we graft those in as choice_field_extension_ies.
        #  choice
        #    choice_field
        #      SomeSelector
        #      SomeType
        #    choice_field_ie_extension
        #      choice-extension                        <- tree.children[0].children[0]
        #      single_ie_container  Something-ExtIEs   <- tree.children[0].children[1] and tree.children[0].children[1].children[0]
        #  object_def
        #    Something-ExtIEs
        #    ies
        #      ie
        #        ...thing 1...
        #      ie
        #        ...thing 2...
        #
        # to
        #  choice
        #    choice_field
        #      SomeSelector
        #      SomeType
        #    choice_field_extension_ies
        #      ie
        #        ...thing 1...
        #      ie
        #        ...thing 2...
        #
        for child in tree.children:
            if child.data == "choice_field_ie_container":
                child.data = "choice_field"
                child.children[1] = self.ie_dict[child.children[1]]
            elif child.data == "choice_field_ie_extension":
                # Look up the object def defining the extension IEs.
                child.data = "choice_field_extension_ies"
                name = child.children[1].children[0]
                ies = self.ie_dict[name]
                child.children = ies.children

                #         # Create a new child.
                #         found_ies = 0
                #         for ie in ies.children:
                #             if ie.data == "ie":
                #                 # the name comes the third field of the ie
                #                 name = ie.children[2]
                #                 new_child = Tree("choice_field", [name, ie])
                #                 new_children.append(new_child)
                #                 found_ies += 1
                #         if found_ies == 0:
                #             new_children.append(Tree("empty_sequence_field", []))
                #     else:
                #         new_children.append(child)
        return tree

    def sequence(self, tree):
        # For Sequence-like IE containers, convert a structure like
        #    sequence
        #      ie_container_field      PDUSessionResourceSetupRequestIEs
        #      extension_marker
        #  object_def
        #    PDUSessionResourceSetupRequestIEs
        #    ies
        #      ie
        #
        # into
        #
        #    ie_container_sequence
        #      ies
        #        ie
        #      extension_marker
        if len(tree.children) > 0 and tree.children[0].data == "protocol_ies_field":
            tree.children[0] = self.ie_dict[tree.children[0].children[0]]
            tree.data = "ie_container_sequence"
        return tree

    def extension_container_field(self, tree):
        # We convert from this
        #
        #  sequence
        #    ...
        #   extension_container_field CUtoDURRCInformation-ExtIEs
        #
        #  object_def
        #    CUtoDURRCInformation-ExtIEs
        #    ies
        #      optional_ie
        #
        # into
        #
        #  sequence
        #    extension_ies
        #      optional_ie
        tree.children[0] = self.ie_dict[tree.children[0]]
        tree.data = "extension_ies"

        # And we convert all mandatory ies to optionals.  Given we are flattening an optional structure, this is
        # the easiest way of making everything optional.
        for child in tree.children[0].children:
            if child.data == "ie":
                child.data = "optional_ie"
        return tree

    def sequence_of(self, tree):
        # For Sequence-Of-like IE containers, we convert
        #
        #   sequence_of
        #     1
        #     maxnoofIndividualF1ConnectionsToReset
        #     single_ie_container UE-associatedLogicalF1-ConnectionItemRes    <- tree.children[2] and tree.children[2].children[0]
        # object_def
        #   UE-associatedLogicalF1-ConnectionItemRes                          <- self.ie_dict key
        #   ies                                                               <- self.ie_dict value
        #     ie
        #
        # Into
        #    ie_container_sequence_of
        #      ie
        #
        if len(tree.children) == 3 and isinstance(tree.children[2], Tree) and tree.children[2].data == "single_ie_container":
            tree.children[2] = self.ie_dict[tree.children[2].children[0]].children[0]
            tree.data = "ie_container_sequence_of"
        return tree


@v_args(tree=True)
class Remover(Transformer):
    def object_def(self, tree):
        print("Removing object_def ", tree.children[0])
        return Discard

    def extended_items(self, tree):
        print("Removing extended items")
        return Discard


@v_args(tree=True)
class EnumDeDuplicator(Transformer):
    # If we find two enum variants with the same name after converting to pascal case
    # this is because of an RRC construct like Q-OffsetRange which contains both
    # "dB-24" AND "db24".  (Thanks, RRC).  We convert the dash to the word 'Dash' to
    # dismabiguate.
    def enumerated(self, tree):
        def is_regular_variant(item):
            return not (isinstance(item, Token) or (len(item.children) == 0) or item.data == "extended_items")

        for i1 in range(len(tree.children) - 1):
            item1 = tree.children[i1]
            if not is_regular_variant(item1):
                continue
            for i2 in range(i1 + 1, len(tree.children)):
                item2 = tree.children[i2]
                if not is_regular_variant(item2):
                    continue
                if pascal_case(item1.children[0]) == pascal_case(item2.children[0]):
                    item1.children[0] = item1.children[0].replace('-', 'Dash')
                    item2.children[0] = item2.children[0].replace('-', 'Dash')
        return tree


@ v_args(tree=True)
class TypeTransformer(Transformer):
    def __init__(self, constants=dict(), name_dict=dict(), convert=dict()):
        self.extra_defs = []
        self.name_dict = name_dict
        self.convert_dict = convert
        self.constants = constants

    def unique_type_name(self, name):
        return add_type_name(name, self.name_dict)

    def convert(self, orig):
        if orig not in self.convert_dict:
            print(
                f"Warning: unknown type {orig} - guessing name as {pascal_case(orig)}")
            name = pascal_case(orig)
        else:
            name = self.convert_dict[orig]
        return name

    def document(self, tree):
        tree.children += self.extra_defs
        return tree

    def enum_field(self, tree):
        tree.children[0] = pascal_case(tree.children[0])
        return tree

    def type_parameterized_identifier(self, tree):
        typ = pascal_case(tree.children[0]) + \
            f"<{self.convert(tree.children[1].children[0])}>"
        return Token('', typ)

    def field(self, tree):
        tree.children[1] = self.transform_type(
            tree.children[1], tree.children[0])
        tree.children[0] = snake_case(tree.children[0])
        return tree

    def choice_field(self, tree):
        tree.children[1] = self.transform_type(
            tree.children[1], tree.children[0])
        tree.children[0] = pascal_case(tree.children[0])
        return tree

    def choice_field_ie_container(self, tree):
        tree.children[1] = self.transform_type(
            tree.children[1], tree.children[0])
        tree.children[0] = pascal_case(tree.children[0])
        return tree

    def optional_field(self, tree):
        tree.children[1] = self.transform_type(
            tree.children[1], tree.children[0])
        tree.children[0] = snake_case(tree.children[0])
        return tree

    def primitive_def(self, tree):
        tree.children[0] = self.convert(tree.children[0])
        tree.children[1] = self.transform_type(
            tree.children[1], tree.children[0])
        return tree

    def choice_def(self, tree):
        tree.children[0] = self.convert(tree.children[0])
        return tree

    def enum_def(self, tree):
        tree.children[0] = self.convert(tree.children[0])
        return tree

    def sequence_def(self, tree):
        tree.children[0] = self.convert(tree.children[0])
        return tree

    def procedure_name(self, tree):
        tree.children[0] = self.convert(tree.children[0])
        return tree

    def initiating(self, tree):
        tree.children[0] = self.convert(tree.children[0])
        return tree

    def successful(self, tree):
        tree.children[0] = self.convert(tree.children[0])
        return tree

    def unsuccessful(self, tree):
        tree.children[0] = self.convert(tree.children[0])
        return tree

    def procedure_code(self, tree):
        tree.children[0] = self.get_constant(tree.children[0])
        return tree

    def transform_type(self, tree, orig_name):
        if isinstance(tree, Token):
            typename = tree.value
            tree = self.convert(typename)
        elif tree.data == 'sequence_of':
            tree.children[2] = self.transform_type(tree.children[2], orig_name)
        elif tree.data == 'enumerated':
            name = self.unique_type_name(orig_name)
            new_def = Tree('enum_def', [name, tree])
            self.extra_defs.append(new_def)
            tree = name
        elif tree.data == 'sequence':
            name = self.unique_type_name(orig_name)
            new_def = Tree('sequence_def', [name, tree])
            self.extra_defs.append(new_def)
            tree = name
        elif tree.data == 'null':
            tree = 'null'
        elif tree.data == 'choice':
            name = self.unique_type_name(orig_name)
            new_def = Tree('choice_def', [name, tree])
            self.extra_defs.append(new_def)
            tree = name
        elif tree.data == 'ies':
            name = self.unique_type_name(orig_name)
            new_def = Tree('protocol_ie_container', [name, tree])
            self.extra_defs.append(new_def)
            tree = name
        else:
            pass

        return tree

    def ie_container_sequence_of(self, tree):
        self.transform_bounds(tree)
        return Tree("ie_container_sequence_of", tree.children)

    def sequence_of(self, tree):
        self.transform_bounds(tree)
        return Tree("sequence_of", tree.children)

    def get_constant(self, name):
        c = self.constants.get(name)
        if c is None:
            print("Error: unknown constant ", name)
            return name
        return c

    def transform_bounds(self, tree):
        ub = 18446744073709551615
        lb = 0
        extensible = False
        if len(tree.children) <= 1:
            return (None, None, False)
        else:
            lb = tree.children[0]
            try:
                lb = int(lb)
            except:
                lb = self.get_constant(lb)

            ub = tree.children[1]
            if ub is None:
                ub = lb
            else:
                try:
                    ub = int(ub)
                except:
                    ub = self.get_constant(ub)

            for idx in range(2, len(tree.children)-1):
                item = tree.children[idx]
                if isinstance(item, Tree) and item.data == "extension_marker":
                    extensible = True

        tree.children[0] = lb
        tree.children[1] = ub

        return (lb, ub, extensible)

    def named_values(self, tree):
        return Discard

    def integer(self, tree):
        (lb, ub, extensible) = self.transform_bounds(tree)

        if extensible or ((lb, ub) == (None, None)):
            t = "i128"
        elif lb < 0:
            if lb >= -128 and ub <= 127:
                t = "i8"
            elif lb >= -32768 and ub <= 32767:
                t = "i16"
            elif lb >= -2147483648 and ub <= 2147483647:
                t = "i32"
            elif lb >= -9223372036854775808 and ub <= 9223372036854775807:
                t = "i64"
            else:
                t = "i128"
        elif ub < 256:
            t = "u8"
        elif ub < 65536:
            t = "u16"
        elif ub < 4294967296:
            t = "u32"
        elif ub < 18446744073709551616:
            t = "u64"
        else:
            t = "i128"

        return Tree(t, tree.children)

    def bit_string(self, tree):
        self.transform_bounds(tree)
        return Tree("BitString", tree.children)

    def printable_string(self, tree):
        self.transform_bounds(tree)
        return Tree("PrintableString", tree.children)

    def utf8_string(self, tree):
        self.transform_bounds(tree)
        return Tree("UTF8String", tree.children)

    def visible_string(self, tree):
        self.transform_bounds(tree)
        return Tree("VisibleString", tree.children)

    def octet_string(self, tree):
        if tree.children != None:
            self.transform_bounds(tree)
        return Tree("OctetString", tree.children)

    def boolean(self, tree):
        return Tree("bool", tree.children)

    def ie(self, tree):
        id = tree.children[0].value
        tree.children[0] = snake_case(id.replace("id-", ""))
        tree.children.insert(1, self.constants[id])
        tree.children[3] = self.transform_type(
            tree.children[3], tree.children[0])
        return tree

    def optional_ie(self, tree):
        return self.ie(tree)


def strip_xxap_common(tree):
    new_tree = Tree(tree.data, [])
    for definition in tree.children:
        if definition.children[0] not in ["GtpTunnel", "GtpTeid", "TransportLayerAddress", "PduSessionId"]:
            new_tree.children.append(definition)
    return new_tree


def transform(mut_tree, constants, strip_xxap):
    try:
        print("---- Deduplicate enum variants ----")
        mut_tree = EnumDeDuplicator().transform(mut_tree)

        print("---- Finding typenames ----")
        tnf = TypeNameFinder()
        tnf.visit(mut_tree)

        print("---- Removing object_defs and extended_items ----")
        mut_tree = Remover().transform(mut_tree)

        print("---- Merging IE containers ----")
        mut_tree = IeContainerMerger(tnf.ie_dict).transform(mut_tree)

        print("---- Transforming ----")
        mut_tree = TypeTransformer(
            constants, tnf.name_dict, tnf.convert).transform(mut_tree)

        if strip_xxap:
            print("---- Remove XXAP common elements ----")
            mut_tree = strip_xxap_common(mut_tree)

        return mut_tree

    except Exception as e:
        print(mut_tree.pretty())
        raise e


def transform_from_file(input_file, strip_xxap):
    tree = parse_file(input_file)
    return transform(tree, dict(), strip_xxap)


class TestTransformer(unittest.TestCase):
    maxDiff = None

    def should_generate(self, input, expected, constants=dict(), strip_xxap=False):
        output = ""
        tree = parse_string(input)
        # print(tree.pretty())
        try:
            output = transform(tree, constants, strip_xxap).pretty()
            # print(output)
            self.assertEqual(output, expected)
        finally:
            if output != expected:
                print(tree.pretty())

    def test_discard_integer_named_values(self):
        self.should_generate("""\
        PriorityLevel ::= INTEGER { spare (0), highest (1), lowest (14), no-priority (15) } (0..15)
""", """\
document
  primitive_def
    PriorityLevel
    u8
      0
      15
""")

    def test3(self):
        self.should_generate("""\
EventTrigger ::= CHOICE {
	blah-bla		NULL,
	short-macroENB-ID 		    BIT STRING (SIZE (18)),
}
""", """\
document
  choice_def
    EventTrigger
    choice
      choice_field
        BlahBla
        null
      choice_field
        ShortMacroEnbId
        BitString
          18
          18
""")

    def test2(self):
        input = """\
MaximumDataBurstVolume::= INTEGER(-234..maxFoo, ..., 4096.. 2000000)
"""
        output = """\
document
  primitive_def
    MaximumDataBurstVolume
    i128
      -234
      255
      extension_marker
      4096
      2000000
"""
        self.should_generate(input, output, constants={"maxFoo": 255})

    def test1(self):
        input = """\
WLANMeasurementConfiguration ::= SEQUENCE {
	wlanMeasConfig             	WLANMeasConfig,
    um-are-you-sure             PrintableString (SIZE (1..150, ...)),
    someNum                     INTEGER (0..1099511627775),
	foo                         SEQUENCE (SIZE (1..maxnoofSliceItems)) OF OverloadStartNSSAIItem,
	wlan-rtt                   	ENUMERATED {thing1, ..., thing2} OPTIONAL,
	n2    SEQUENCE {
            combOffset-n2              INTEGER (0..1),
            cyclicShift-n2             INTEGER (0..7)
        },
	...
}
"""
        output = """\
document
  sequence_def
    WlanMeasurementConfiguration
    sequence
      field
        wlan_meas_config
        WlanMeasConfig
      field
        um_are_you_sure
        PrintableString
          1
          150
          extension_marker
      field
        some_num
        u64
          0
          1099511627775
      field
        foo
        sequence_of
          1
          3
          OverloadStartNssaiItem
      optional_field
        wlan_rtt
        WlanRtt
      field
        n2
        N2
      extension_marker
  enum_def
    WlanRtt
    enumerated
      enum_field\tThing1
      extension_marker
  sequence_def
    N2
    sequence
      field
        comb_offset_n_2
        u8
          0
          1
      field
        cyclic_shift_n_2
        u8
          0
          7
"""
        self.should_generate(input, output, constants={
                             "maxnoofSliceItems": 3})

    def test_optional_octet_string(self):
        self.should_generate("""\
Child-Node-Cells-List-Item ::= SEQUENCE {
	cSI-RS-Configuration				OCTET STRING	OPTIONAL,
-- Here is a random comment    --
  	sR-Configuration					OCTET STRING	OPTIONAL,
	pDCCH-ConfigSIB1					OCTET STRING	OPTIONAL,
	sCS-Common							OCTET STRING	OPTIONAL,
}
""", """\
document
  sequence_def
    ChildNodeCellsListItem
    sequence
      optional_field
        csi_rs_configuration
        OctetString\tNone
      optional_field
        sr_configuration
        OctetString\tNone
      optional_field
        pdcch_config_sib1
        OctetString\tNone
      optional_field
        scs_common
        OctetString\tNone
""")

    def test_inline_name_clash(self):
        self.should_generate("""\
ActiveULBWP ::= SEQUENCE {
	subcarrierSpacing           ENUMERATED { kHz15, kHz30, kHz60, kHz120,... } ,
}
SubcarrierSpacing ::= ENUMERATED { kHz15, kHz30, kHz60, kHz120, kHz240, spare3, spare2, spare1, ... }
""", """\
document
  sequence_def
    ActiveUlBwp
    sequence
      field
        subcarrier_spacing
        SubcarrierSpacing1
  enum_def
    SubcarrierSpacing
    enumerated
      enum_field\tKHz15
      enum_field\tKHz30
      enum_field\tKHz60
      enum_field\tKHz120
      enum_field\tKHz240
      enum_field\tSpare3
      enum_field\tSpare2
      enum_field\tSpare1
      extension_marker
  enum_def
    SubcarrierSpacing1
    enumerated
      enum_field\tKHz15
      enum_field\tKHz30
      enum_field\tKHz60
      enum_field\tKHz120
      extension_marker
""")

    def test_clashing_type_names(self):
        self.should_generate("""\
Foo ::= INTEGER(1..16)
SRSConfig ::= SEQUENCE {
	a SRSResourceSet-List,
	b SRSResourceSetList,
}
SRSResourceSet-List ::= SEQUENCE (SIZE (1..2)) OF Foo
SRSResourceSetList ::= SEQUENCE (SIZE (1.. 3)) OF Foo
""", """\
document
  primitive_def
    Foo
    u8
      1
      16
  sequence_def
    SrsConfig
    sequence
      field
        a
        SrsResourceSetList
      field
        b
        SrsResourceSetList1
  primitive_def
    SrsResourceSetList
    sequence_of
      1
      2
      Foo
  primitive_def
    SrsResourceSetList1
    sequence_of
      1
      3
      Foo
""")

    def test_pdu_contents(self):
        self.should_generate("""\
PDUSessionResourceSetupRequest ::= SEQUENCE {
	protocolIEs		ProtocolIE-Container		{ {PDUSessionResourceSetupRequestIEs} },
	...
}

PDUSessionResourceSetupRequestIEs NGAP-PROTOCOL-IES ::= {
	{ ID id-AMF-UE-NGAP-ID							CRITICALITY reject	TYPE AMF-UE-NGAP-ID								PRESENCE mandatory	}|
	{ ID id-RANPagingPriority						CRITICALITY ignore	TYPE RANPagingPriority							PRESENCE optional		}|
	...
}
""", """\
document
  sequence_def
    PduSessionResourceSetupRequest
    ie_container_sequence
      ies
        ie
          amf_ue_ngap_id
          10
          reject
          AmfUeNgapId
        optional_ie
          ran_paging_priority
          83
          ignore
          RanPagingPriority
        extension_marker
      extension_marker
""", constants={"id-AMF-UE-NGAP-ID": 10, "id-RANPagingPriority": 83})

    def test_unconstrained_visible_string(self):
        self.should_generate(
            "URI-address ::= VisibleString", """\
document
  primitive_def
    UriAddress
    VisibleString
""")

    def test_octet_string(self):
        self.should_generate("""\
SNSSAI ::= SEQUENCE {
	sD			OCTET STRING (SIZE (3)) 	OPTIONAL	,
}
""", """\
document
  sequence_def
    Snssai
    sequence
      optional_field
        sd
        OctetString
          3
          3
""")

    def test_size_constrained_vec(self):
        self.should_generate("""\
Activated-Cells-to-be-Updated-List ::= SEQUENCE (SIZE (1..maxnoofServedCellsIAB)) OF Activated-Cells-to-be-Updated-List-Item
""", """\
document
  primitive_def
    ActivatedCellsToBeUpdatedList
    sequence_of
      1
      512
      ActivatedCellsToBeUpdatedListItem
""", constants={"maxnoofServedCellsIAB": 512})

    def test_seq_of_ie(self):
        self.should_generate("""\
UE-associatedLogicalF1-ConnectionListRes ::= SEQUENCE (SIZE (1.. maxnoofIndividualF1ConnectionsToReset)) OF ProtocolIE-SingleContainer { { UE-associatedLogicalF1-ConnectionItemRes } }

UE-associatedLogicalF1-ConnectionItemRes F1AP-PROTOCOL-IES ::= {
	{ ID id-UE-associatedLogicalF1-ConnectionItem	CRITICALITY reject	TYPE UE-associatedLogicalF1-ConnectionItem	PRESENCE mandatory } ,
	...
}
""", """\
document
  primitive_def
    UeAssociatedLogicalF1ConnectionListRes
    ie_container_sequence_of
      1
      63356
      ie
        ue_associated_logical_f1_connection_item
        80
        reject
        UeAssociatedLogicalF1ConnectionItem
""", constants={"maxnoofIndividualF1ConnectionsToReset": 63356, "id-UE-associatedLogicalF1-ConnectionItem": 80})

    def test_negative_integer(self):
        self.should_generate("""\
foo ::= INTEGER(-1..0)
""", """\
document
  primitive_def
    Foo
    i8
      -1
      0
""")

    def test_procedure(self):
        self.should_generate("""\
aMFConfigurationUpdate NGAP-ELEMENTARY-PROCEDURE ::= {
	INITIATING MESSAGE		AMFConfigurationUpdate
	SUCCESSFUL OUTCOME		AMFConfigurationUpdateAcknowledge
	UNSUCCESSFUL OUTCOME	AMFConfigurationUpdateFailure
	PROCEDURE CODE			id-AMFConfigurationUpdate
	CRITICALITY				reject
}""", """\
document
  procedure_def
    procedure_name\tAmfConfigurationUpdate
    family\tNGAP-ELEMENTARY-PROCEDURE
    initiating\tAmfConfigurationUpdate
    successful\tAmfConfigurationUpdateAcknowledge
    unsuccessful\tAmfConfigurationUpdateFailure
    procedure_code\t0
    criticality\treject
""", constants={"id-AMFConfigurationUpdate": 0})

    def test_single_option_enum(self):
        self.should_generate("""\
    TimeInformationType ::= ENUMERATED { localClock }
    """, """\
document
  enum_def
    TimeInformationType
    enumerated
      enum_field\tLocalClock
""")

    def test_inline_choice(self):
        self.should_generate("""\
SBCCH-SL-BCH-MessageType::=     CHOICE {
    c1                              CHOICE {
        masterInformationBlockSidelink              MasterInformationBlockSidelink,
        spare1 NULL
    },
    messageClassExtension   SEQUENCE {}
}""", """\
document
  choice_def
    SbcchSlBchMessageType
    choice
      choice_field
        C1
        C1
      empty_sequence_field\tmessageClassExtension
  choice_def
    C1
    choice
      choice_field
        MasterInformationBlockSidelink
        MasterInformationBlockSidelink
      choice_field
        Spare1
        null
""")

    def test_sequence_with_empty_sequence(self):
        self.should_generate("""\
UECapabilityInformationSidelink-IEs-r16 ::= SEQUENCE {
    accessStratumReleaseSidelink-r16            AccessStratumReleaseSidelink-r16,
    nonCriticalExtension                        SEQUENCE{}                                                              OPTIONAL
}
""", """\
document
  sequence_def
    UeCapabilityInformationSidelinkIEsR16
    sequence
      field
        access_stratum_release_sidelink_r_16
        AccessStratumReleaseSidelinkR16
      empty_sequence_field\tnonCriticalExtension
""")

    def test_rrc_setup_release(self):
        self.should_generate("""\
LocationMeasurementIndication-IEs ::=       SEQUENCE {
    measurementIndication                       SetupRelease {LocationMeasurementInfo},
}
""", """\
document
  sequence_def
    LocationMeasurementIndicationIEs
    sequence
      field
        measurement_indication
        SetupRelease<LocationMeasurementInfo>
""")

    def test_parameterized_choice_def(self):
        self.should_generate("""\
SetupRelease { ElementTypeParam } ::= CHOICE {
    release         NULL,
    setup           ElementTypeParam
}
""", """\
document
  generic_choice_def
    SetupRelease
    type_parameter\tElementTypeParam
    choice
      choice_field
        Release
        null
      choice_field
        Setup
        ElementTypeParam
""")

    def test_seq_of_constrained_int(self):
        self.should_generate("""\
AvailabilityCombination-r16 ::=         SEQUENCE {
    availabilityCombinationId-r16           AvailabilityCombinationId-r16,
    resourceAvailability-r16                SEQUENCE (SIZE (1..maxNrofResourceAvailabilityPerCombination-r16)) OF INTEGER (0..7)
}
""", """\
document
  sequence_def
    AvailabilityCombinationR16
    sequence
      field
        availability_combination_id_r_16
        AvailabilityCombinationIdR16
      field
        resource_availability_r_16
        sequence_of
          1
          maxNrofResourceAvailabilityPerCombination-r16
          u8
            0
            7
""")

    def test_unbounded_integer(self):
        self.should_generate("""\
VarMeasReportSL-r16 ::=                   SEQUENCE {
    sl-NumberOfReportsSent-r16                INTEGER
}""", """\
document
  sequence_def
    VarMeasReportSlR16
    sequence
      field
        sl_number_of_reports_sent_r_16
        i128
""")

    def test_dup_extra_defs(self):
        self.should_generate("""\
FeatureSetUplink-v1540 ::=           SEQUENCE {
    zeroSlotOffsetAperiodicSRS           ENUMERATED {supported}                     OPTIONAL,
    pa-PhaseDiscontinuityImpacts         ENUMERATED {supported}                     OPTIONAL,
}
""", """\
document
  sequence_def
    FeatureSetUplinkV1540
    sequence
      optional_field
        zero_slot_offset_aperiodic_srs
        ZeroSlotOffsetAperiodicSrs
      optional_field
        pa_phase_discontinuity_impacts
        PaPhaseDiscontinuityImpacts
  enum_def
    ZeroSlotOffsetAperiodicSrs
    enumerated
      enum_field\tSupported
  enum_def
    PaPhaseDiscontinuityImpacts
    enumerated
      enum_field\tSupported
""")

    def test_enum_with_duplicate_pascal_case_mappings(self):
        self.should_generate("""\
Q-OffsetRange ::=                   ENUMERATED {dB-24, something-else, dB24}
""", """\
document
  enum_def
    QOffsetRange
    enumerated
      enum_field\tDbDash24
      enum_field\tSomethingElse
      enum_field\tDb24
""")

    def test_choice_of_protocol_ie_container(self):
        self.should_generate("""\
System-BearerContextSetupRequest ::= CHOICE {
	e-UTRAN-BearerContextSetupRequest		ProtocolIE-Container { {EUTRAN-BearerContextSetupRequest } },
	nG-RAN-BearerContextSetupRequest		ProtocolIE-Container { {NG-RAN-BearerContextSetupRequest } },
	choice-extension						ProtocolIE-SingleContainer { {System-BearerContextSetupRequest-ExtIEs }  }
}

EUTRAN-BearerContextSetupRequest E1AP-PROTOCOL-IES ::= {
	{ ID id-DRB-To-Setup-List-EUTRAN		CRITICALITY reject	 TYPE DRB-To-Setup-List-EUTRAN		PRESENCE mandatory } |
	{ ID id-SubscriberProfileIDforRFP		CRITICALITY ignore	 TYPE SubscriberProfileIDforRFP		PRESENCE optional } |
	{ ID id-AdditionalRRMPriorityIndex		CRITICALITY ignore	 TYPE AdditionalRRMPriorityIndex	PRESENCE optional } ,
	...
}

NG-RAN-BearerContextSetupRequest E1AP-PROTOCOL-IES ::= {
	{ ID id-PDU-Session-Resource-To-Setup-List		CRITICALITY reject	 TYPE PDU-Session-Resource-To-Setup-List		PRESENCE mandatory } ,
	...
}""", """\
document
  choice_def
    SystemBearerContextSetupRequest
    choice
      choice_field
        EutranBearerContextSetupRequest
        EutranBearerContextSetupRequest
      choice_field
        NgRanBearerContextSetupRequest
        NgRanBearerContextSetupRequest
      extension_container
        choice-extension
        single_ie_container\tSystem-BearerContextSetupRequest-ExtIEs
  protocol_ie_container
    EutranBearerContextSetupRequest
    ies
      ie
        drb_to_setup_list_eutran
        42
        reject
        DrbToSetupListEutran
      optional_ie
        subscriber_profile_i_dfor_rfp
        43
        ignore
        SubscriberProfileIDforRfp
      optional_ie
        additional_rrm_priority_index
        123
        ignore
        AdditionalRrmPriorityIndex
      extension_marker
  protocol_ie_container
    NgRanBearerContextSetupRequest
    ies
      ie
        pdu_session_resource_to_setup_list
        321
        reject
        PduSessionResourceToSetupList
      extension_marker
""", constants={"id-DRB-To-Setup-List-EUTRAN": 42, "id-SubscriberProfileIDforRFP": 43, "id-AdditionalRRMPriorityIndex": 123, "id-PDU-Session-Resource-To-Setup-List": 321})

    def test_choice_of_protocol_ie_container(self):
        self.should_generate("""\
CUtoDURRCInformation ::= SEQUENCE {
	thing1							INTEGER(0..6),
	iE-Extensions				ProtocolExtensionContainer { { CUtoDURRCInformation-ExtIEs } } OPTIONAL,  --Need R
	...
}

CUtoDURRCInformation-ExtIEs F1AP-PROTOCOL-EXTENSION ::= {
	{ ID id-HandoverPreparationInformation	CRITICALITY reject	EXTENSION HandoverPreparationInformation		PRESENCE optional } |
	{ ID id-UEAssistanceInformationEUTRA	CRITICALITY ignore	EXTENSION UEAssistanceInformationEUTRA			PRESENCE mandatory } ,
	...
}""", """\
document
  sequence_def
    CuToDuRrcInformation
    sequence
      field
        thing_1
        u8
          0
          6
      extension_ies
        ies
          optional_ie
            handover_preparation_information
            232
            reject
            HandoverPreparationInformation
          optional_ie
            ue_assistance_information_eutra
            233
            ignore
            UeAssistanceInformationEutra
          extension_marker
      extension_marker
""", constants={"id-HandoverPreparationInformation": 232, "id-UEAssistanceInformationEUTRA": 233})

    def test_choice_extension(self):
        self.should_generate("""\
QoSInformation ::= CHOICE {
	eUTRANQoS					EUTRANQoS,
	choice-extension			ProtocolIE-SingleContainer { { QoSInformation-ExtIEs } }
}

QoSInformation-ExtIEs F1AP-PROTOCOL-IES ::= {
	{	ID id-DRB-Information		CRITICALITY ignore TYPE DRB-Information		PRESENCE mandatory } ,
	...
}""", """\
document
  choice_def
    QosInformation
    choice
      choice_field
        EutranQos
        EutranQos
      choice_field_extension_ies
        ie
          drb_information
          111
          ignore
          DrbInformation
        extension_marker
""", constants={"id-DRB-Information": 111})

    def test_choice_extension_empty(self):
        self.should_generate("""\
GNB-ID ::= CHOICE {
	gNB-ID		BIT STRING (SIZE (22..32)),
	choice-Extensions		ProtocolIE-SingleContainer { {GNB-ID-ExtIEs } }
}
GNB-ID-ExtIEs NGAP-PROTOCOL-IES ::= {
	...
}""", """\
document
  choice_def
    GnbId
    choice
      choice_field
        GnbId
        BitString
          22
          32
      choice_field_extension_ies
        extension_marker
""")


if __name__ == '__main__':
    if len(sys.argv) == 2:
        print(transform_from_file(sys.argv[1]))
    else:
        unittest.main(failfast=True)
