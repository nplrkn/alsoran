// Autogenerated from F1AP-PDU-Contents.asn
#![allow(clippy::all)]
use super::common::*;
use super::ies::*;
use asn1_per::{aper::*, *};
use xxap::*;
#[allow(unused_imports)]
use xxap::{GtpTunnel, PduSessionId, TransportLayerAddress};

// Reset
#[derive(Clone, Debug)]
pub struct Reset {
    pub transaction_id: TransactionId,
    pub cause: Cause,
    pub reset_type: ResetType,
}

impl Reset {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let _ = decode::decode_sequence_header(data, true, 0)?;
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut transaction_id: Option<TransactionId> = None;
        let mut cause: Option<Cause> = None;
        let mut reset_type: Option<ResetType> = None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                78 => transaction_id = Some(TransactionId::decode(data)?),
                0 => cause = Some(Cause::decode(data)?),
                48 => reset_type = Some(ResetType::decode(data)?),
                x => return Err(per_codec_error_new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        let transaction_id = transaction_id.ok_or(per_codec_error_new(format!(
            "Missing mandatory IE transaction_id"
        )))?;
        let cause = cause.ok_or(per_codec_error_new(format!("Missing mandatory IE cause")))?;
        let reset_type = reset_type.ok_or(per_codec_error_new(format!(
            "Missing mandatory IE reset_type"
        )))?;
        Ok(Self {
            transaction_id,
            cause,
            reset_type,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        let ie = &mut Allocator::new_codec_data();
        self.transaction_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 78, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.cause.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 0, false)?;
        Criticality::Ignore.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.reset_type.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 48, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        encode::encode_sequence_header(data, true, &BitString::new(), false)?;
        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for Reset {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Reset::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("Reset");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("Reset");
            e
        })
    }
}
// ResetType
#[derive(Clone, Debug)]
pub enum ResetType {
    F1Interface(ResetAll),
    PartOfF1Interface(UeAssociatedLogicalF1ConnectionListRes),
}

impl ResetType {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_choice_idx(data, 0, 2, false)?;
        if extended {
            return Err(per_codec_error_new("CHOICE additions not implemented"));
        }
        match idx {
            0 => Ok(Self::F1Interface(ResetAll::decode(data)?)),
            1 => Ok(Self::PartOfF1Interface(
                UeAssociatedLogicalF1ConnectionListRes::decode(data)?,
            )),
            2 => {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _ = Criticality::decode(data)?;
                let _ = decode::decode_length_determinent(data, None, None, false)?;
                let result = match id {
                    x => Err(per_codec_error_new(format!("Unrecognised IE type {}", x))),
                };
                data.decode_align()?;
                result
            }
            _ => Err(per_codec_error_new("Unknown choice idx")),
        }
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        match self {
            Self::F1Interface(x) => {
                encode::encode_choice_idx(data, 0, 2, false, 0, false)?;
                x.encode(data)
            }
            Self::PartOfF1Interface(x) => {
                encode::encode_choice_idx(data, 0, 2, false, 1, false)?;
                x.encode(data)
            }
        }
    }
}

impl PerCodec for ResetType {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        ResetType::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ResetType");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ResetType");
            e
        })
    }
}
// ResetAll
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum ResetAll {
    ResetAll,
}

impl ResetAll {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(0), true)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(0),
            true,
            *self as i128,
            (*self as u32) >= 1,
        )
    }
}

impl PerCodec for ResetAll {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        ResetAll::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ResetAll");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ResetAll");
            e
        })
    }
}
// UeAssociatedLogicalF1ConnectionListRes
#[derive(Clone, Debug)]
pub struct UeAssociatedLogicalF1ConnectionListRes(
    pub NonEmpty<UeAssociatedLogicalF1ConnectionItem>,
);

impl UeAssociatedLogicalF1ConnectionListRes {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(65536), false)?;
            let mut items = vec![];
            for _ in 0..length {
                let _ = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _ = Criticality::decode(data)?;
                let _ = decode::decode_length_determinent(data, None, None, false)?;
                items.push(UeAssociatedLogicalF1ConnectionItem::decode(data)?);
                data.decode_align()?;
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(65536), false, self.0.len())?;
        for x in &self.0 {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(data, Some(0), Some(65535), false, 80, false)?;
            Criticality::Reject.encode(data)?;
            encode::encode_length_determinent(data, None, None, false, ie.length_in_bytes())?;
            data.append_aligned(ie);
        }
        Ok(())
    }
}

impl PerCodec for UeAssociatedLogicalF1ConnectionListRes {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        UeAssociatedLogicalF1ConnectionListRes::decode_inner(data).map_err(
            |mut e: PerCodecError| {
                e.push_context("UeAssociatedLogicalF1ConnectionListRes");
                e
            },
        )
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UeAssociatedLogicalF1ConnectionListRes");
            e
        })
    }
}
// ResetAcknowledge
#[derive(Clone, Debug)]
pub struct ResetAcknowledge {
    pub transaction_id: TransactionId,
    pub ue_associated_logical_f1_connection_list_res_ack:
        Option<UeAssociatedLogicalF1ConnectionListResAck>,
    pub criticality_diagnostics: Option<CriticalityDiagnostics>,
}

impl ResetAcknowledge {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let _ = decode::decode_sequence_header(data, true, 0)?;
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut transaction_id: Option<TransactionId> = None;
        let mut ue_associated_logical_f1_connection_list_res_ack: Option<
            UeAssociatedLogicalF1ConnectionListResAck,
        > = None;
        let mut criticality_diagnostics: Option<CriticalityDiagnostics> = None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                78 => transaction_id = Some(TransactionId::decode(data)?),
                81 => {
                    ue_associated_logical_f1_connection_list_res_ack =
                        Some(UeAssociatedLogicalF1ConnectionListResAck::decode(data)?)
                }
                7 => criticality_diagnostics = Some(CriticalityDiagnostics::decode(data)?),
                x => return Err(per_codec_error_new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        let transaction_id = transaction_id.ok_or(per_codec_error_new(format!(
            "Missing mandatory IE transaction_id"
        )))?;
        Ok(Self {
            transaction_id,
            ue_associated_logical_f1_connection_list_res_ack,
            criticality_diagnostics,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        let ie = &mut Allocator::new_codec_data();
        self.transaction_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 78, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        if let Some(x) = &self.ue_associated_logical_f1_connection_list_res_ack {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 81, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.criticality_diagnostics {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 7, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        encode::encode_sequence_header(data, true, &BitString::new(), false)?;
        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for ResetAcknowledge {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        ResetAcknowledge::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ResetAcknowledge");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ResetAcknowledge");
            e
        })
    }
}
// UeAssociatedLogicalF1ConnectionListResAck
#[derive(Clone, Debug)]
pub struct UeAssociatedLogicalF1ConnectionListResAck(
    pub NonEmpty<UeAssociatedLogicalF1ConnectionItem>,
);

impl UeAssociatedLogicalF1ConnectionListResAck {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(65536), false)?;
            let mut items = vec![];
            for _ in 0..length {
                let _ = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _ = Criticality::decode(data)?;
                let _ = decode::decode_length_determinent(data, None, None, false)?;
                items.push(UeAssociatedLogicalF1ConnectionItem::decode(data)?);
                data.decode_align()?;
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(65536), false, self.0.len())?;
        for x in &self.0 {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(data, Some(0), Some(65535), false, 80, false)?;
            Criticality::Ignore.encode(data)?;
            encode::encode_length_determinent(data, None, None, false, ie.length_in_bytes())?;
            data.append_aligned(ie);
        }
        Ok(())
    }
}

impl PerCodec for UeAssociatedLogicalF1ConnectionListResAck {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        UeAssociatedLogicalF1ConnectionListResAck::decode_inner(data).map_err(
            |mut e: PerCodecError| {
                e.push_context("UeAssociatedLogicalF1ConnectionListResAck");
                e
            },
        )
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UeAssociatedLogicalF1ConnectionListResAck");
            e
        })
    }
}
// ErrorIndication
#[derive(Clone, Debug)]
pub struct ErrorIndication {
    pub transaction_id: TransactionId,
    pub gnb_cu_ue_f1ap_id: Option<GnbCuUeF1apId>,
    pub gnb_du_ue_f1ap_id: Option<GnbDuUeF1apId>,
    pub cause: Option<Cause>,
    pub criticality_diagnostics: Option<CriticalityDiagnostics>,
}

impl ErrorIndication {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let _ = decode::decode_sequence_header(data, true, 0)?;
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut transaction_id: Option<TransactionId> = None;
        let mut gnb_cu_ue_f1ap_id: Option<GnbCuUeF1apId> = None;
        let mut gnb_du_ue_f1ap_id: Option<GnbDuUeF1apId> = None;
        let mut cause: Option<Cause> = None;
        let mut criticality_diagnostics: Option<CriticalityDiagnostics> = None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                78 => transaction_id = Some(TransactionId::decode(data)?),
                40 => gnb_cu_ue_f1ap_id = Some(GnbCuUeF1apId::decode(data)?),
                41 => gnb_du_ue_f1ap_id = Some(GnbDuUeF1apId::decode(data)?),
                0 => cause = Some(Cause::decode(data)?),
                7 => criticality_diagnostics = Some(CriticalityDiagnostics::decode(data)?),
                x => return Err(per_codec_error_new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        let transaction_id = transaction_id.ok_or(per_codec_error_new(format!(
            "Missing mandatory IE transaction_id"
        )))?;
        Ok(Self {
            transaction_id,
            gnb_cu_ue_f1ap_id,
            gnb_du_ue_f1ap_id,
            cause,
            criticality_diagnostics,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        let ie = &mut Allocator::new_codec_data();
        self.transaction_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 78, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        if let Some(x) = &self.gnb_cu_ue_f1ap_id {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 40, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.gnb_du_ue_f1ap_id {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 41, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.cause {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 0, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.criticality_diagnostics {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 7, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        encode::encode_sequence_header(data, true, &BitString::new(), false)?;
        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for ErrorIndication {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        ErrorIndication::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ErrorIndication");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ErrorIndication");
            e
        })
    }
}
// F1SetupRequest
#[derive(Clone, Debug)]
pub struct F1SetupRequest {
    pub transaction_id: TransactionId,
    pub gnb_du_id: GnbDuId,
    pub gnb_du_name: Option<GnbDuName>,
    pub gnb_du_served_cells_list: Option<GnbDuServedCellsList>,
    pub gnb_du_rrc_version: RrcVersion,
    pub transport_layer_address_info: Option<TransportLayerAddressInfo>,
    pub bap_address: Option<BapAddress>,
    pub extended_gnb_du_name: Option<ExtendedGnbDuName>,
    pub rrc_terminating_iab_donor_gnb_id: Option<GlobalGnbId>,
    pub mobile_iab_mt_user_location_information: Option<MobileIabMtUserLocationInformation>,
}

impl F1SetupRequest {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let _ = decode::decode_sequence_header(data, true, 0)?;
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut transaction_id: Option<TransactionId> = None;
        let mut gnb_du_id: Option<GnbDuId> = None;
        let mut gnb_du_name: Option<GnbDuName> = None;
        let mut gnb_du_served_cells_list: Option<GnbDuServedCellsList> = None;
        let mut gnb_du_rrc_version: Option<RrcVersion> = None;
        let mut transport_layer_address_info: Option<TransportLayerAddressInfo> = None;
        let mut bap_address: Option<BapAddress> = None;
        let mut extended_gnb_du_name: Option<ExtendedGnbDuName> = None;
        let mut rrc_terminating_iab_donor_gnb_id: Option<GlobalGnbId> = None;
        let mut mobile_iab_mt_user_location_information: Option<
            MobileIabMtUserLocationInformation,
        > = None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                78 => transaction_id = Some(TransactionId::decode(data)?),
                42 => gnb_du_id = Some(GnbDuId::decode(data)?),
                45 => gnb_du_name = Some(GnbDuName::decode(data)?),
                44 => gnb_du_served_cells_list = Some(GnbDuServedCellsList::decode(data)?),
                171 => gnb_du_rrc_version = Some(RrcVersion::decode(data)?),
                254 => {
                    transport_layer_address_info = Some(TransportLayerAddressInfo::decode(data)?)
                }
                281 => bap_address = Some(BapAddress::decode(data)?),
                427 => extended_gnb_du_name = Some(ExtendedGnbDuName::decode(data)?),
                762 => rrc_terminating_iab_donor_gnb_id = Some(GlobalGnbId::decode(data)?),
                765 => {
                    mobile_iab_mt_user_location_information =
                        Some(MobileIabMtUserLocationInformation::decode(data)?)
                }
                x => return Err(per_codec_error_new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        let transaction_id = transaction_id.ok_or(per_codec_error_new(format!(
            "Missing mandatory IE transaction_id"
        )))?;
        let gnb_du_id = gnb_du_id.ok_or(per_codec_error_new(format!(
            "Missing mandatory IE gnb_du_id"
        )))?;
        let gnb_du_rrc_version = gnb_du_rrc_version.ok_or(per_codec_error_new(format!(
            "Missing mandatory IE gnb_du_rrc_version"
        )))?;
        Ok(Self {
            transaction_id,
            gnb_du_id,
            gnb_du_name,
            gnb_du_served_cells_list,
            gnb_du_rrc_version,
            transport_layer_address_info,
            bap_address,
            extended_gnb_du_name,
            rrc_terminating_iab_donor_gnb_id,
            mobile_iab_mt_user_location_information,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        let ie = &mut Allocator::new_codec_data();
        self.transaction_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 78, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.gnb_du_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 42, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        if let Some(x) = &self.gnb_du_name {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 45, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.gnb_du_served_cells_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 44, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        let ie = &mut Allocator::new_codec_data();
        self.gnb_du_rrc_version.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 171, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        if let Some(x) = &self.transport_layer_address_info {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 254, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.bap_address {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 281, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.extended_gnb_du_name {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 427, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.rrc_terminating_iab_donor_gnb_id {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 762, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.mobile_iab_mt_user_location_information {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 765, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        encode::encode_sequence_header(data, true, &BitString::new(), false)?;
        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for F1SetupRequest {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        F1SetupRequest::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("F1SetupRequest");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("F1SetupRequest");
            e
        })
    }
}
// GnbDuServedCellsList
#[derive(Clone, Debug)]
pub struct GnbDuServedCellsList(pub NonEmpty<GnbDuServedCellsItem>);

impl GnbDuServedCellsList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(512), false)?;
            let mut items = vec![];
            for _ in 0..length {
                let _ = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _ = Criticality::decode(data)?;
                let _ = decode::decode_length_determinent(data, None, None, false)?;
                items.push(GnbDuServedCellsItem::decode(data)?);
                data.decode_align()?;
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(512), false, self.0.len())?;
        for x in &self.0 {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(data, Some(0), Some(65535), false, 43, false)?;
            Criticality::Reject.encode(data)?;
            encode::encode_length_determinent(data, None, None, false, ie.length_in_bytes())?;
            data.append_aligned(ie);
        }
        Ok(())
    }
}

impl PerCodec for GnbDuServedCellsList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        GnbDuServedCellsList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("GnbDuServedCellsList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("GnbDuServedCellsList");
            e
        })
    }
}
// F1SetupResponse
#[derive(Clone, Debug)]
pub struct F1SetupResponse {
    pub transaction_id: TransactionId,
    pub gnb_cu_name: Option<GnbCuName>,
    pub cells_to_be_activated_list: Option<CellsToBeActivatedList>,
    pub gnb_cu_rrc_version: RrcVersion,
    pub transport_layer_address_info: Option<TransportLayerAddressInfo>,
    pub ul_bh_non_up_traffic_mapping: Option<UlBhNonUpTrafficMapping>,
    pub bap_address: Option<BapAddress>,
    pub extended_gnb_cu_name: Option<ExtendedGnbCuName>,
    pub ncgi_to_be_updated_list: Option<NcgiToBeUpdatedList>,
}

impl F1SetupResponse {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let _ = decode::decode_sequence_header(data, true, 0)?;
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut transaction_id: Option<TransactionId> = None;
        let mut gnb_cu_name: Option<GnbCuName> = None;
        let mut cells_to_be_activated_list: Option<CellsToBeActivatedList> = None;
        let mut gnb_cu_rrc_version: Option<RrcVersion> = None;
        let mut transport_layer_address_info: Option<TransportLayerAddressInfo> = None;
        let mut ul_bh_non_up_traffic_mapping: Option<UlBhNonUpTrafficMapping> = None;
        let mut bap_address: Option<BapAddress> = None;
        let mut extended_gnb_cu_name: Option<ExtendedGnbCuName> = None;
        let mut ncgi_to_be_updated_list: Option<NcgiToBeUpdatedList> = None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                78 => transaction_id = Some(TransactionId::decode(data)?),
                82 => gnb_cu_name = Some(GnbCuName::decode(data)?),
                3 => cells_to_be_activated_list = Some(CellsToBeActivatedList::decode(data)?),
                170 => gnb_cu_rrc_version = Some(RrcVersion::decode(data)?),
                254 => {
                    transport_layer_address_info = Some(TransportLayerAddressInfo::decode(data)?)
                }
                287 => ul_bh_non_up_traffic_mapping = Some(UlBhNonUpTrafficMapping::decode(data)?),
                281 => bap_address = Some(BapAddress::decode(data)?),
                426 => extended_gnb_cu_name = Some(ExtendedGnbCuName::decode(data)?),
                763 => ncgi_to_be_updated_list = Some(NcgiToBeUpdatedList::decode(data)?),
                x => return Err(per_codec_error_new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        let transaction_id = transaction_id.ok_or(per_codec_error_new(format!(
            "Missing mandatory IE transaction_id"
        )))?;
        let gnb_cu_rrc_version = gnb_cu_rrc_version.ok_or(per_codec_error_new(format!(
            "Missing mandatory IE gnb_cu_rrc_version"
        )))?;
        Ok(Self {
            transaction_id,
            gnb_cu_name,
            cells_to_be_activated_list,
            gnb_cu_rrc_version,
            transport_layer_address_info,
            ul_bh_non_up_traffic_mapping,
            bap_address,
            extended_gnb_cu_name,
            ncgi_to_be_updated_list,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        let ie = &mut Allocator::new_codec_data();
        self.transaction_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 78, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        if let Some(x) = &self.gnb_cu_name {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 82, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.cells_to_be_activated_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 3, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        let ie = &mut Allocator::new_codec_data();
        self.gnb_cu_rrc_version.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 170, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        if let Some(x) = &self.transport_layer_address_info {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 254, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.ul_bh_non_up_traffic_mapping {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 287, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.bap_address {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 281, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.extended_gnb_cu_name {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 426, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.ncgi_to_be_updated_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 763, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        encode::encode_sequence_header(data, true, &BitString::new(), false)?;
        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for F1SetupResponse {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        F1SetupResponse::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("F1SetupResponse");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("F1SetupResponse");
            e
        })
    }
}
// CellsToBeActivatedList
#[derive(Clone, Debug)]
pub struct CellsToBeActivatedList(pub NonEmpty<CellsToBeActivatedListItem>);

impl CellsToBeActivatedList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(512), false)?;
            let mut items = vec![];
            for _ in 0..length {
                let _ = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _ = Criticality::decode(data)?;
                let _ = decode::decode_length_determinent(data, None, None, false)?;
                items.push(CellsToBeActivatedListItem::decode(data)?);
                data.decode_align()?;
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(512), false, self.0.len())?;
        for x in &self.0 {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(data, Some(0), Some(65535), false, 4, false)?;
            Criticality::Reject.encode(data)?;
            encode::encode_length_determinent(data, None, None, false, ie.length_in_bytes())?;
            data.append_aligned(ie);
        }
        Ok(())
    }
}

impl PerCodec for CellsToBeActivatedList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        CellsToBeActivatedList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CellsToBeActivatedList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CellsToBeActivatedList");
            e
        })
    }
}
// NcgiToBeUpdatedList
#[derive(Clone, Debug)]
pub struct NcgiToBeUpdatedList(pub NonEmpty<NcgiToBeUpdatedListItem>);

impl NcgiToBeUpdatedList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(512), false)?;
            let mut items = vec![];
            for _ in 0..length {
                let _ = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _ = Criticality::decode(data)?;
                let _ = decode::decode_length_determinent(data, None, None, false)?;
                items.push(NcgiToBeUpdatedListItem::decode(data)?);
                data.decode_align()?;
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(512), false, self.0.len())?;
        for x in &self.0 {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(data, Some(0), Some(65535), false, 764, false)?;
            Criticality::Reject.encode(data)?;
            encode::encode_length_determinent(data, None, None, false, ie.length_in_bytes())?;
            data.append_aligned(ie);
        }
        Ok(())
    }
}

impl PerCodec for NcgiToBeUpdatedList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        NcgiToBeUpdatedList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NcgiToBeUpdatedList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NcgiToBeUpdatedList");
            e
        })
    }
}
// F1SetupFailure
#[derive(Clone, Debug)]
pub struct F1SetupFailure {
    pub transaction_id: TransactionId,
    pub cause: Cause,
    pub time_to_wait: Option<TimeToWait>,
    pub criticality_diagnostics: Option<CriticalityDiagnostics>,
}

impl F1SetupFailure {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let _ = decode::decode_sequence_header(data, true, 0)?;
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut transaction_id: Option<TransactionId> = None;
        let mut cause: Option<Cause> = None;
        let mut time_to_wait: Option<TimeToWait> = None;
        let mut criticality_diagnostics: Option<CriticalityDiagnostics> = None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                78 => transaction_id = Some(TransactionId::decode(data)?),
                0 => cause = Some(Cause::decode(data)?),
                77 => time_to_wait = Some(TimeToWait::decode(data)?),
                7 => criticality_diagnostics = Some(CriticalityDiagnostics::decode(data)?),
                x => return Err(per_codec_error_new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        let transaction_id = transaction_id.ok_or(per_codec_error_new(format!(
            "Missing mandatory IE transaction_id"
        )))?;
        let cause = cause.ok_or(per_codec_error_new(format!("Missing mandatory IE cause")))?;
        Ok(Self {
            transaction_id,
            cause,
            time_to_wait,
            criticality_diagnostics,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        let ie = &mut Allocator::new_codec_data();
        self.transaction_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 78, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.cause.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 0, false)?;
        Criticality::Ignore.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        if let Some(x) = &self.time_to_wait {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 77, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.criticality_diagnostics {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 7, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        encode::encode_sequence_header(data, true, &BitString::new(), false)?;
        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for F1SetupFailure {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        F1SetupFailure::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("F1SetupFailure");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("F1SetupFailure");
            e
        })
    }
}
// GnbDuConfigurationUpdate
#[derive(Clone, Debug)]
pub struct GnbDuConfigurationUpdate {
    pub transaction_id: TransactionId,
    pub served_cells_to_add_list: Option<ServedCellsToAddList>,
    pub served_cells_to_modify_list: Option<ServedCellsToModifyList>,
    pub served_cells_to_delete_list: Option<ServedCellsToDeleteList>,
    pub cells_status_list: Option<CellsStatusList>,
    pub dedicated_si_delivery_needed_ue_list: Option<DedicatedSiDeliveryNeededUeList>,
    pub gnb_du_id: Option<GnbDuId>,
    pub gnb_du_tnl_association_to_remove_list: Option<GnbDuTnlAssociationToRemoveList>,
    pub transport_layer_address_info: Option<TransportLayerAddressInfo>,
    pub coverage_modification_notification: Option<CoverageModificationNotification>,
    pub gnb_du_name: Option<GnbDuName>,
    pub extended_gnb_du_name: Option<ExtendedGnbDuName>,
    pub rrc_terminating_iab_donor_related_info: Option<RrcTerminatingIabDonorRelatedInfo>,
    pub mobile_iab_mt_user_location_information: Option<MobileIabMtUserLocationInformation>,
}

impl GnbDuConfigurationUpdate {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let _ = decode::decode_sequence_header(data, true, 0)?;
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut transaction_id: Option<TransactionId> = None;
        let mut served_cells_to_add_list: Option<ServedCellsToAddList> = None;
        let mut served_cells_to_modify_list: Option<ServedCellsToModifyList> = None;
        let mut served_cells_to_delete_list: Option<ServedCellsToDeleteList> = None;
        let mut cells_status_list: Option<CellsStatusList> = None;
        let mut dedicated_si_delivery_needed_ue_list: Option<DedicatedSiDeliveryNeededUeList> =
            None;
        let mut gnb_du_id: Option<GnbDuId> = None;
        let mut gnb_du_tnl_association_to_remove_list: Option<GnbDuTnlAssociationToRemoveList> =
            None;
        let mut transport_layer_address_info: Option<TransportLayerAddressInfo> = None;
        let mut coverage_modification_notification: Option<CoverageModificationNotification> = None;
        let mut gnb_du_name: Option<GnbDuName> = None;
        let mut extended_gnb_du_name: Option<ExtendedGnbDuName> = None;
        let mut rrc_terminating_iab_donor_related_info: Option<RrcTerminatingIabDonorRelatedInfo> =
            None;
        let mut mobile_iab_mt_user_location_information: Option<
            MobileIabMtUserLocationInformation,
        > = None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                78 => transaction_id = Some(TransactionId::decode(data)?),
                58 => served_cells_to_add_list = Some(ServedCellsToAddList::decode(data)?),
                62 => served_cells_to_modify_list = Some(ServedCellsToModifyList::decode(data)?),
                60 => served_cells_to_delete_list = Some(ServedCellsToDeleteList::decode(data)?),
                89 => cells_status_list = Some(CellsStatusList::decode(data)?),
                189 => {
                    dedicated_si_delivery_needed_ue_list =
                        Some(DedicatedSiDeliveryNeededUeList::decode(data)?)
                }
                42 => gnb_du_id = Some(GnbDuId::decode(data)?),
                228 => {
                    gnb_du_tnl_association_to_remove_list =
                        Some(GnbDuTnlAssociationToRemoveList::decode(data)?)
                }
                254 => {
                    transport_layer_address_info = Some(TransportLayerAddressInfo::decode(data)?)
                }
                446 => {
                    coverage_modification_notification =
                        Some(CoverageModificationNotification::decode(data)?)
                }
                45 => gnb_du_name = Some(GnbDuName::decode(data)?),
                427 => extended_gnb_du_name = Some(ExtendedGnbDuName::decode(data)?),
                761 => {
                    rrc_terminating_iab_donor_related_info =
                        Some(RrcTerminatingIabDonorRelatedInfo::decode(data)?)
                }
                765 => {
                    mobile_iab_mt_user_location_information =
                        Some(MobileIabMtUserLocationInformation::decode(data)?)
                }
                x => return Err(per_codec_error_new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        let transaction_id = transaction_id.ok_or(per_codec_error_new(format!(
            "Missing mandatory IE transaction_id"
        )))?;
        Ok(Self {
            transaction_id,
            served_cells_to_add_list,
            served_cells_to_modify_list,
            served_cells_to_delete_list,
            cells_status_list,
            dedicated_si_delivery_needed_ue_list,
            gnb_du_id,
            gnb_du_tnl_association_to_remove_list,
            transport_layer_address_info,
            coverage_modification_notification,
            gnb_du_name,
            extended_gnb_du_name,
            rrc_terminating_iab_donor_related_info,
            mobile_iab_mt_user_location_information,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        let ie = &mut Allocator::new_codec_data();
        self.transaction_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 78, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        if let Some(x) = &self.served_cells_to_add_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 58, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.served_cells_to_modify_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 62, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.served_cells_to_delete_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 60, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.cells_status_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 89, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.dedicated_si_delivery_needed_ue_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 189, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.gnb_du_id {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 42, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.gnb_du_tnl_association_to_remove_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 228, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.transport_layer_address_info {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 254, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.coverage_modification_notification {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 446, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.gnb_du_name {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 45, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.extended_gnb_du_name {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 427, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.rrc_terminating_iab_donor_related_info {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 761, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.mobile_iab_mt_user_location_information {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 765, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        encode::encode_sequence_header(data, true, &BitString::new(), false)?;
        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for GnbDuConfigurationUpdate {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        GnbDuConfigurationUpdate::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("GnbDuConfigurationUpdate");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("GnbDuConfigurationUpdate");
            e
        })
    }
}
// ServedCellsToAddList
#[derive(Clone, Debug)]
pub struct ServedCellsToAddList(pub NonEmpty<ServedCellsToAddItem>);

impl ServedCellsToAddList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(512), false)?;
            let mut items = vec![];
            for _ in 0..length {
                let _ = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _ = Criticality::decode(data)?;
                let _ = decode::decode_length_determinent(data, None, None, false)?;
                items.push(ServedCellsToAddItem::decode(data)?);
                data.decode_align()?;
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(512), false, self.0.len())?;
        for x in &self.0 {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(data, Some(0), Some(65535), false, 57, false)?;
            Criticality::Reject.encode(data)?;
            encode::encode_length_determinent(data, None, None, false, ie.length_in_bytes())?;
            data.append_aligned(ie);
        }
        Ok(())
    }
}

impl PerCodec for ServedCellsToAddList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        ServedCellsToAddList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ServedCellsToAddList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ServedCellsToAddList");
            e
        })
    }
}
// ServedCellsToModifyList
#[derive(Clone, Debug)]
pub struct ServedCellsToModifyList(pub NonEmpty<ServedCellsToModifyItem>);

impl ServedCellsToModifyList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(512), false)?;
            let mut items = vec![];
            for _ in 0..length {
                let _ = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _ = Criticality::decode(data)?;
                let _ = decode::decode_length_determinent(data, None, None, false)?;
                items.push(ServedCellsToModifyItem::decode(data)?);
                data.decode_align()?;
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(512), false, self.0.len())?;
        for x in &self.0 {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(data, Some(0), Some(65535), false, 61, false)?;
            Criticality::Reject.encode(data)?;
            encode::encode_length_determinent(data, None, None, false, ie.length_in_bytes())?;
            data.append_aligned(ie);
        }
        Ok(())
    }
}

impl PerCodec for ServedCellsToModifyList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        ServedCellsToModifyList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ServedCellsToModifyList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ServedCellsToModifyList");
            e
        })
    }
}
// ServedCellsToDeleteList
#[derive(Clone, Debug)]
pub struct ServedCellsToDeleteList(pub NonEmpty<ServedCellsToDeleteItem>);

impl ServedCellsToDeleteList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(512), false)?;
            let mut items = vec![];
            for _ in 0..length {
                let _ = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _ = Criticality::decode(data)?;
                let _ = decode::decode_length_determinent(data, None, None, false)?;
                items.push(ServedCellsToDeleteItem::decode(data)?);
                data.decode_align()?;
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(512), false, self.0.len())?;
        for x in &self.0 {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(data, Some(0), Some(65535), false, 59, false)?;
            Criticality::Reject.encode(data)?;
            encode::encode_length_determinent(data, None, None, false, ie.length_in_bytes())?;
            data.append_aligned(ie);
        }
        Ok(())
    }
}

impl PerCodec for ServedCellsToDeleteList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        ServedCellsToDeleteList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ServedCellsToDeleteList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ServedCellsToDeleteList");
            e
        })
    }
}
// CellsStatusList
#[derive(Clone, Debug)]
pub struct CellsStatusList(pub Vec<CellsStatusItem>);

impl CellsStatusList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(0), Some(512), false)?;
            let mut items = vec![];
            for _ in 0..length {
                let _ = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _ = Criticality::decode(data)?;
                let _ = decode::decode_length_determinent(data, None, None, false)?;
                items.push(CellsStatusItem::decode(data)?);
                data.decode_align()?;
            }
            items
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(0), Some(512), false, self.0.len())?;
        for x in &self.0 {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(data, Some(0), Some(65535), false, 88, false)?;
            Criticality::Reject.encode(data)?;
            encode::encode_length_determinent(data, None, None, false, ie.length_in_bytes())?;
            data.append_aligned(ie);
        }
        Ok(())
    }
}

impl PerCodec for CellsStatusList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        CellsStatusList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CellsStatusList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CellsStatusList");
            e
        })
    }
}
// DedicatedSiDeliveryNeededUeList
#[derive(Clone, Debug)]
pub struct DedicatedSiDeliveryNeededUeList(pub NonEmpty<DedicatedSiDeliveryNeededUeItem>);

impl DedicatedSiDeliveryNeededUeList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(65536), false)?;
            let mut items = vec![];
            for _ in 0..length {
                let _ = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _ = Criticality::decode(data)?;
                let _ = decode::decode_length_determinent(data, None, None, false)?;
                items.push(DedicatedSiDeliveryNeededUeItem::decode(data)?);
                data.decode_align()?;
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(65536), false, self.0.len())?;
        for x in &self.0 {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(data, Some(0), Some(65535), false, 190, false)?;
            Criticality::Ignore.encode(data)?;
            encode::encode_length_determinent(data, None, None, false, ie.length_in_bytes())?;
            data.append_aligned(ie);
        }
        Ok(())
    }
}

impl PerCodec for DedicatedSiDeliveryNeededUeList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        DedicatedSiDeliveryNeededUeList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DedicatedSiDeliveryNeededUeList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DedicatedSiDeliveryNeededUeList");
            e
        })
    }
}
// GnbDuTnlAssociationToRemoveList
#[derive(Clone, Debug)]
pub struct GnbDuTnlAssociationToRemoveList(pub NonEmpty<GnbDuTnlAssociationToRemoveItem>);

impl GnbDuTnlAssociationToRemoveList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(32), false)?;
            let mut items = vec![];
            for _ in 0..length {
                let _ = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _ = Criticality::decode(data)?;
                let _ = decode::decode_length_determinent(data, None, None, false)?;
                items.push(GnbDuTnlAssociationToRemoveItem::decode(data)?);
                data.decode_align()?;
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(32), false, self.0.len())?;
        for x in &self.0 {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(data, Some(0), Some(65535), false, 227, false)?;
            Criticality::Reject.encode(data)?;
            encode::encode_length_determinent(data, None, None, false, ie.length_in_bytes())?;
            data.append_aligned(ie);
        }
        Ok(())
    }
}

impl PerCodec for GnbDuTnlAssociationToRemoveList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        GnbDuTnlAssociationToRemoveList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("GnbDuTnlAssociationToRemoveList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("GnbDuTnlAssociationToRemoveList");
            e
        })
    }
}
// GnbDuConfigurationUpdateAcknowledge
#[derive(Clone, Debug)]
pub struct GnbDuConfigurationUpdateAcknowledge {
    pub transaction_id: TransactionId,
    pub cells_to_be_activated_list: Option<CellsToBeActivatedList>,
    pub criticality_diagnostics: Option<CriticalityDiagnostics>,
    pub cells_to_be_deactivated_list: Option<CellsToBeDeactivatedList>,
    pub transport_layer_address_info: Option<TransportLayerAddressInfo>,
    pub ul_bh_non_up_traffic_mapping: Option<UlBhNonUpTrafficMapping>,
    pub bap_address: Option<BapAddress>,
    pub cells_for_son_list: Option<CellsForSonList>,
}

impl GnbDuConfigurationUpdateAcknowledge {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let _ = decode::decode_sequence_header(data, true, 0)?;
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut transaction_id: Option<TransactionId> = None;
        let mut cells_to_be_activated_list: Option<CellsToBeActivatedList> = None;
        let mut criticality_diagnostics: Option<CriticalityDiagnostics> = None;
        let mut cells_to_be_deactivated_list: Option<CellsToBeDeactivatedList> = None;
        let mut transport_layer_address_info: Option<TransportLayerAddressInfo> = None;
        let mut ul_bh_non_up_traffic_mapping: Option<UlBhNonUpTrafficMapping> = None;
        let mut bap_address: Option<BapAddress> = None;
        let mut cells_for_son_list: Option<CellsForSonList> = None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                78 => transaction_id = Some(TransactionId::decode(data)?),
                3 => cells_to_be_activated_list = Some(CellsToBeActivatedList::decode(data)?),
                7 => criticality_diagnostics = Some(CriticalityDiagnostics::decode(data)?),
                5 => cells_to_be_deactivated_list = Some(CellsToBeDeactivatedList::decode(data)?),
                254 => {
                    transport_layer_address_info = Some(TransportLayerAddressInfo::decode(data)?)
                }
                287 => ul_bh_non_up_traffic_mapping = Some(UlBhNonUpTrafficMapping::decode(data)?),
                281 => bap_address = Some(BapAddress::decode(data)?),
                449 => cells_for_son_list = Some(CellsForSonList::decode(data)?),
                x => return Err(per_codec_error_new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        let transaction_id = transaction_id.ok_or(per_codec_error_new(format!(
            "Missing mandatory IE transaction_id"
        )))?;
        Ok(Self {
            transaction_id,
            cells_to_be_activated_list,
            criticality_diagnostics,
            cells_to_be_deactivated_list,
            transport_layer_address_info,
            ul_bh_non_up_traffic_mapping,
            bap_address,
            cells_for_son_list,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        let ie = &mut Allocator::new_codec_data();
        self.transaction_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 78, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        if let Some(x) = &self.cells_to_be_activated_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 3, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.criticality_diagnostics {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 7, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.cells_to_be_deactivated_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 5, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.transport_layer_address_info {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 254, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.ul_bh_non_up_traffic_mapping {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 287, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.bap_address {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 281, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.cells_for_son_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 449, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        encode::encode_sequence_header(data, true, &BitString::new(), false)?;
        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for GnbDuConfigurationUpdateAcknowledge {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        GnbDuConfigurationUpdateAcknowledge::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("GnbDuConfigurationUpdateAcknowledge");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("GnbDuConfigurationUpdateAcknowledge");
            e
        })
    }
}
// GnbDuConfigurationUpdateFailure
#[derive(Clone, Debug)]
pub struct GnbDuConfigurationUpdateFailure {
    pub transaction_id: TransactionId,
    pub cause: Cause,
    pub time_to_wait: Option<TimeToWait>,
    pub criticality_diagnostics: Option<CriticalityDiagnostics>,
}

impl GnbDuConfigurationUpdateFailure {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let _ = decode::decode_sequence_header(data, true, 0)?;
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut transaction_id: Option<TransactionId> = None;
        let mut cause: Option<Cause> = None;
        let mut time_to_wait: Option<TimeToWait> = None;
        let mut criticality_diagnostics: Option<CriticalityDiagnostics> = None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                78 => transaction_id = Some(TransactionId::decode(data)?),
                0 => cause = Some(Cause::decode(data)?),
                77 => time_to_wait = Some(TimeToWait::decode(data)?),
                7 => criticality_diagnostics = Some(CriticalityDiagnostics::decode(data)?),
                x => return Err(per_codec_error_new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        let transaction_id = transaction_id.ok_or(per_codec_error_new(format!(
            "Missing mandatory IE transaction_id"
        )))?;
        let cause = cause.ok_or(per_codec_error_new(format!("Missing mandatory IE cause")))?;
        Ok(Self {
            transaction_id,
            cause,
            time_to_wait,
            criticality_diagnostics,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        let ie = &mut Allocator::new_codec_data();
        self.transaction_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 78, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.cause.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 0, false)?;
        Criticality::Ignore.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        if let Some(x) = &self.time_to_wait {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 77, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.criticality_diagnostics {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 7, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        encode::encode_sequence_header(data, true, &BitString::new(), false)?;
        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for GnbDuConfigurationUpdateFailure {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        GnbDuConfigurationUpdateFailure::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("GnbDuConfigurationUpdateFailure");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("GnbDuConfigurationUpdateFailure");
            e
        })
    }
}
// GnbCuConfigurationUpdate
#[derive(Clone, Debug)]
pub struct GnbCuConfigurationUpdate {
    pub transaction_id: TransactionId,
    pub cells_to_be_activated_list: Option<CellsToBeActivatedList>,
    pub cells_to_be_deactivated_list: Option<CellsToBeDeactivatedList>,
    pub gnb_cu_tnl_association_to_add_list: Option<GnbCuTnlAssociationToAddList>,
    pub gnb_cu_tnl_association_to_remove_list: Option<GnbCuTnlAssociationToRemoveList>,
    pub gnb_cu_tnl_association_to_update_list: Option<GnbCuTnlAssociationToUpdateList>,
    pub cells_to_be_barred_list: Option<CellsToBeBarredList>,
    pub protected_eutra_resources_list: Option<ProtectedEutraResourcesList>,
    pub neighbour_cell_information_list: Option<NeighbourCellInformationList>,
    pub transport_layer_address_info: Option<TransportLayerAddressInfo>,
    pub ul_bh_non_up_traffic_mapping: Option<UlBhNonUpTrafficMapping>,
    pub bap_address: Option<BapAddress>,
    pub cco_assistance_information: Option<CcoAssistanceInformation>,
    pub cells_for_son_list: Option<CellsForSonList>,
    pub gnb_cu_name: Option<GnbCuName>,
    pub extended_gnb_cu_name: Option<ExtendedGnbCuName>,
    pub cells_allowed_to_be_deactivated_list: Option<CellsAllowedToBeDeactivatedList>,
}

impl GnbCuConfigurationUpdate {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let _ = decode::decode_sequence_header(data, true, 0)?;
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut transaction_id: Option<TransactionId> = None;
        let mut cells_to_be_activated_list: Option<CellsToBeActivatedList> = None;
        let mut cells_to_be_deactivated_list: Option<CellsToBeDeactivatedList> = None;
        let mut gnb_cu_tnl_association_to_add_list: Option<GnbCuTnlAssociationToAddList> = None;
        let mut gnb_cu_tnl_association_to_remove_list: Option<GnbCuTnlAssociationToRemoveList> =
            None;
        let mut gnb_cu_tnl_association_to_update_list: Option<GnbCuTnlAssociationToUpdateList> =
            None;
        let mut cells_to_be_barred_list: Option<CellsToBeBarredList> = None;
        let mut protected_eutra_resources_list: Option<ProtectedEutraResourcesList> = None;
        let mut neighbour_cell_information_list: Option<NeighbourCellInformationList> = None;
        let mut transport_layer_address_info: Option<TransportLayerAddressInfo> = None;
        let mut ul_bh_non_up_traffic_mapping: Option<UlBhNonUpTrafficMapping> = None;
        let mut bap_address: Option<BapAddress> = None;
        let mut cco_assistance_information: Option<CcoAssistanceInformation> = None;
        let mut cells_for_son_list: Option<CellsForSonList> = None;
        let mut gnb_cu_name: Option<GnbCuName> = None;
        let mut extended_gnb_cu_name: Option<ExtendedGnbCuName> = None;
        let mut cells_allowed_to_be_deactivated_list: Option<CellsAllowedToBeDeactivatedList> =
            None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                78 => transaction_id = Some(TransactionId::decode(data)?),
                3 => cells_to_be_activated_list = Some(CellsToBeActivatedList::decode(data)?),
                5 => cells_to_be_deactivated_list = Some(CellsToBeDeactivatedList::decode(data)?),
                121 => {
                    gnb_cu_tnl_association_to_add_list =
                        Some(GnbCuTnlAssociationToAddList::decode(data)?)
                }
                123 => {
                    gnb_cu_tnl_association_to_remove_list =
                        Some(GnbCuTnlAssociationToRemoveList::decode(data)?)
                }
                125 => {
                    gnb_cu_tnl_association_to_update_list =
                        Some(GnbCuTnlAssociationToUpdateList::decode(data)?)
                }
                129 => cells_to_be_barred_list = Some(CellsToBeBarredList::decode(data)?),
                105 => {
                    protected_eutra_resources_list =
                        Some(ProtectedEutraResourcesList::decode(data)?)
                }
                244 => {
                    neighbour_cell_information_list =
                        Some(NeighbourCellInformationList::decode(data)?)
                }
                254 => {
                    transport_layer_address_info = Some(TransportLayerAddressInfo::decode(data)?)
                }
                287 => ul_bh_non_up_traffic_mapping = Some(UlBhNonUpTrafficMapping::decode(data)?),
                281 => bap_address = Some(BapAddress::decode(data)?),
                447 => cco_assistance_information = Some(CcoAssistanceInformation::decode(data)?),
                449 => cells_for_son_list = Some(CellsForSonList::decode(data)?),
                82 => gnb_cu_name = Some(GnbCuName::decode(data)?),
                426 => extended_gnb_cu_name = Some(ExtendedGnbCuName::decode(data)?),
                746 => {
                    cells_allowed_to_be_deactivated_list =
                        Some(CellsAllowedToBeDeactivatedList::decode(data)?)
                }
                x => return Err(per_codec_error_new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        let transaction_id = transaction_id.ok_or(per_codec_error_new(format!(
            "Missing mandatory IE transaction_id"
        )))?;
        Ok(Self {
            transaction_id,
            cells_to_be_activated_list,
            cells_to_be_deactivated_list,
            gnb_cu_tnl_association_to_add_list,
            gnb_cu_tnl_association_to_remove_list,
            gnb_cu_tnl_association_to_update_list,
            cells_to_be_barred_list,
            protected_eutra_resources_list,
            neighbour_cell_information_list,
            transport_layer_address_info,
            ul_bh_non_up_traffic_mapping,
            bap_address,
            cco_assistance_information,
            cells_for_son_list,
            gnb_cu_name,
            extended_gnb_cu_name,
            cells_allowed_to_be_deactivated_list,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        let ie = &mut Allocator::new_codec_data();
        self.transaction_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 78, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        if let Some(x) = &self.cells_to_be_activated_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 3, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.cells_to_be_deactivated_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 5, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.gnb_cu_tnl_association_to_add_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 121, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.gnb_cu_tnl_association_to_remove_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 123, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.gnb_cu_tnl_association_to_update_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 125, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.cells_to_be_barred_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 129, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.protected_eutra_resources_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 105, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.neighbour_cell_information_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 244, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.transport_layer_address_info {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 254, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.ul_bh_non_up_traffic_mapping {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 287, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.bap_address {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 281, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.cco_assistance_information {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 447, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.cells_for_son_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 449, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.gnb_cu_name {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 82, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.extended_gnb_cu_name {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 426, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.cells_allowed_to_be_deactivated_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 746, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        encode::encode_sequence_header(data, true, &BitString::new(), false)?;
        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for GnbCuConfigurationUpdate {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        GnbCuConfigurationUpdate::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("GnbCuConfigurationUpdate");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("GnbCuConfigurationUpdate");
            e
        })
    }
}
// CellsToBeDeactivatedList
#[derive(Clone, Debug)]
pub struct CellsToBeDeactivatedList(pub NonEmpty<CellsToBeDeactivatedListItem>);

impl CellsToBeDeactivatedList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(512), false)?;
            let mut items = vec![];
            for _ in 0..length {
                let _ = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _ = Criticality::decode(data)?;
                let _ = decode::decode_length_determinent(data, None, None, false)?;
                items.push(CellsToBeDeactivatedListItem::decode(data)?);
                data.decode_align()?;
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(512), false, self.0.len())?;
        for x in &self.0 {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(data, Some(0), Some(65535), false, 6, false)?;
            Criticality::Reject.encode(data)?;
            encode::encode_length_determinent(data, None, None, false, ie.length_in_bytes())?;
            data.append_aligned(ie);
        }
        Ok(())
    }
}

impl PerCodec for CellsToBeDeactivatedList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        CellsToBeDeactivatedList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CellsToBeDeactivatedList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CellsToBeDeactivatedList");
            e
        })
    }
}
// GnbCuTnlAssociationToAddList
#[derive(Clone, Debug)]
pub struct GnbCuTnlAssociationToAddList(pub NonEmpty<GnbCuTnlAssociationToAddItem>);

impl GnbCuTnlAssociationToAddList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(32), false)?;
            let mut items = vec![];
            for _ in 0..length {
                let _ = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _ = Criticality::decode(data)?;
                let _ = decode::decode_length_determinent(data, None, None, false)?;
                items.push(GnbCuTnlAssociationToAddItem::decode(data)?);
                data.decode_align()?;
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(32), false, self.0.len())?;
        for x in &self.0 {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(data, Some(0), Some(65535), false, 120, false)?;
            Criticality::Ignore.encode(data)?;
            encode::encode_length_determinent(data, None, None, false, ie.length_in_bytes())?;
            data.append_aligned(ie);
        }
        Ok(())
    }
}

impl PerCodec for GnbCuTnlAssociationToAddList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        GnbCuTnlAssociationToAddList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("GnbCuTnlAssociationToAddList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("GnbCuTnlAssociationToAddList");
            e
        })
    }
}
// GnbCuTnlAssociationToRemoveList
#[derive(Clone, Debug)]
pub struct GnbCuTnlAssociationToRemoveList(pub NonEmpty<GnbCuTnlAssociationToRemoveItem>);

impl GnbCuTnlAssociationToRemoveList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(32), false)?;
            let mut items = vec![];
            for _ in 0..length {
                let _ = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _ = Criticality::decode(data)?;
                let _ = decode::decode_length_determinent(data, None, None, false)?;
                items.push(GnbCuTnlAssociationToRemoveItem::decode(data)?);
                data.decode_align()?;
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(32), false, self.0.len())?;
        for x in &self.0 {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(data, Some(0), Some(65535), false, 122, false)?;
            Criticality::Ignore.encode(data)?;
            encode::encode_length_determinent(data, None, None, false, ie.length_in_bytes())?;
            data.append_aligned(ie);
        }
        Ok(())
    }
}

impl PerCodec for GnbCuTnlAssociationToRemoveList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        GnbCuTnlAssociationToRemoveList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("GnbCuTnlAssociationToRemoveList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("GnbCuTnlAssociationToRemoveList");
            e
        })
    }
}
// GnbCuTnlAssociationToUpdateList
#[derive(Clone, Debug)]
pub struct GnbCuTnlAssociationToUpdateList(pub NonEmpty<GnbCuTnlAssociationToUpdateItem>);

impl GnbCuTnlAssociationToUpdateList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(32), false)?;
            let mut items = vec![];
            for _ in 0..length {
                let _ = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _ = Criticality::decode(data)?;
                let _ = decode::decode_length_determinent(data, None, None, false)?;
                items.push(GnbCuTnlAssociationToUpdateItem::decode(data)?);
                data.decode_align()?;
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(32), false, self.0.len())?;
        for x in &self.0 {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(data, Some(0), Some(65535), false, 124, false)?;
            Criticality::Ignore.encode(data)?;
            encode::encode_length_determinent(data, None, None, false, ie.length_in_bytes())?;
            data.append_aligned(ie);
        }
        Ok(())
    }
}

impl PerCodec for GnbCuTnlAssociationToUpdateList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        GnbCuTnlAssociationToUpdateList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("GnbCuTnlAssociationToUpdateList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("GnbCuTnlAssociationToUpdateList");
            e
        })
    }
}
// CellsToBeBarredList
#[derive(Clone, Debug)]
pub struct CellsToBeBarredList(pub NonEmpty<CellsToBeBarredItem>);

impl CellsToBeBarredList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(512), false)?;
            let mut items = vec![];
            for _ in 0..length {
                let _ = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _ = Criticality::decode(data)?;
                let _ = decode::decode_length_determinent(data, None, None, false)?;
                items.push(CellsToBeBarredItem::decode(data)?);
                data.decode_align()?;
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(512), false, self.0.len())?;
        for x in &self.0 {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(data, Some(0), Some(65535), false, 130, false)?;
            Criticality::Ignore.encode(data)?;
            encode::encode_length_determinent(data, None, None, false, ie.length_in_bytes())?;
            data.append_aligned(ie);
        }
        Ok(())
    }
}

impl PerCodec for CellsToBeBarredList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        CellsToBeBarredList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CellsToBeBarredList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CellsToBeBarredList");
            e
        })
    }
}
// CellsAllowedToBeDeactivatedList
#[derive(Clone, Debug)]
pub struct CellsAllowedToBeDeactivatedList(pub NonEmpty<CellsAllowedToBeDeactivatedListItem>);

impl CellsAllowedToBeDeactivatedList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(512), false)?;
            let mut items = vec![];
            for _ in 0..length {
                let _ = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _ = Criticality::decode(data)?;
                let _ = decode::decode_length_determinent(data, None, None, false)?;
                items.push(CellsAllowedToBeDeactivatedListItem::decode(data)?);
                data.decode_align()?;
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(512), false, self.0.len())?;
        for x in &self.0 {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(data, Some(0), Some(65535), false, 747, false)?;
            Criticality::Ignore.encode(data)?;
            encode::encode_length_determinent(data, None, None, false, ie.length_in_bytes())?;
            data.append_aligned(ie);
        }
        Ok(())
    }
}

impl PerCodec for CellsAllowedToBeDeactivatedList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        CellsAllowedToBeDeactivatedList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CellsAllowedToBeDeactivatedList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CellsAllowedToBeDeactivatedList");
            e
        })
    }
}
// ProtectedEutraResourcesList
#[derive(Clone, Debug)]
pub struct ProtectedEutraResourcesList(pub NonEmpty<ProtectedEutraResourcesItem>);

impl ProtectedEutraResourcesList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(256), false)?;
            let mut items = vec![];
            for _ in 0..length {
                let _ = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _ = Criticality::decode(data)?;
                let _ = decode::decode_length_determinent(data, None, None, false)?;
                items.push(ProtectedEutraResourcesItem::decode(data)?);
                data.decode_align()?;
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(256), false, self.0.len())?;
        for x in &self.0 {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(data, Some(0), Some(65535), false, 168, false)?;
            Criticality::Reject.encode(data)?;
            encode::encode_length_determinent(data, None, None, false, ie.length_in_bytes())?;
            data.append_aligned(ie);
        }
        Ok(())
    }
}

impl PerCodec for ProtectedEutraResourcesList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        ProtectedEutraResourcesList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ProtectedEutraResourcesList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ProtectedEutraResourcesList");
            e
        })
    }
}
// NeighbourCellInformationList
#[derive(Clone, Debug)]
pub struct NeighbourCellInformationList(pub NonEmpty<NeighbourCellInformationItem>);

impl NeighbourCellInformationList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(512), false)?;
            let mut items = vec![];
            for _ in 0..length {
                let _ = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _ = Criticality::decode(data)?;
                let _ = decode::decode_length_determinent(data, None, None, false)?;
                items.push(NeighbourCellInformationItem::decode(data)?);
                data.decode_align()?;
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(512), false, self.0.len())?;
        for x in &self.0 {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(data, Some(0), Some(65535), false, 255, false)?;
            Criticality::Ignore.encode(data)?;
            encode::encode_length_determinent(data, None, None, false, ie.length_in_bytes())?;
            data.append_aligned(ie);
        }
        Ok(())
    }
}

impl PerCodec for NeighbourCellInformationList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        NeighbourCellInformationList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NeighbourCellInformationList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NeighbourCellInformationList");
            e
        })
    }
}
// GnbCuConfigurationUpdateAcknowledge
#[derive(Clone, Debug)]
pub struct GnbCuConfigurationUpdateAcknowledge {
    pub transaction_id: TransactionId,
    pub cells_failed_to_be_activated_list: Option<CellsFailedToBeActivatedList>,
    pub criticality_diagnostics: Option<CriticalityDiagnostics>,
    pub gnb_cu_tnl_association_setup_list: Option<GnbCuTnlAssociationSetupList>,
    pub gnb_cu_tnl_association_failed_to_setup_list: Option<GnbCuTnlAssociationFailedToSetupList>,
    pub dedicated_si_delivery_needed_ue_list: Option<DedicatedSiDeliveryNeededUeList>,
    pub transport_layer_address_info: Option<TransportLayerAddressInfo>,
    pub cells_with_ss_bs_activated_list: Option<CellsWithSsBsActivatedList>,
}

impl GnbCuConfigurationUpdateAcknowledge {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let _ = decode::decode_sequence_header(data, true, 0)?;
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut transaction_id: Option<TransactionId> = None;
        let mut cells_failed_to_be_activated_list: Option<CellsFailedToBeActivatedList> = None;
        let mut criticality_diagnostics: Option<CriticalityDiagnostics> = None;
        let mut gnb_cu_tnl_association_setup_list: Option<GnbCuTnlAssociationSetupList> = None;
        let mut gnb_cu_tnl_association_failed_to_setup_list: Option<
            GnbCuTnlAssociationFailedToSetupList,
        > = None;
        let mut dedicated_si_delivery_needed_ue_list: Option<DedicatedSiDeliveryNeededUeList> =
            None;
        let mut transport_layer_address_info: Option<TransportLayerAddressInfo> = None;
        let mut cells_with_ss_bs_activated_list: Option<CellsWithSsBsActivatedList> = None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                78 => transaction_id = Some(TransactionId::decode(data)?),
                1 => {
                    cells_failed_to_be_activated_list =
                        Some(CellsFailedToBeActivatedList::decode(data)?)
                }
                7 => criticality_diagnostics = Some(CriticalityDiagnostics::decode(data)?),
                132 => {
                    gnb_cu_tnl_association_setup_list =
                        Some(GnbCuTnlAssociationSetupList::decode(data)?)
                }
                134 => {
                    gnb_cu_tnl_association_failed_to_setup_list =
                        Some(GnbCuTnlAssociationFailedToSetupList::decode(data)?)
                }
                189 => {
                    dedicated_si_delivery_needed_ue_list =
                        Some(DedicatedSiDeliveryNeededUeList::decode(data)?)
                }
                254 => {
                    transport_layer_address_info = Some(TransportLayerAddressInfo::decode(data)?)
                }
                745 => {
                    cells_with_ss_bs_activated_list =
                        Some(CellsWithSsBsActivatedList::decode(data)?)
                }
                x => return Err(per_codec_error_new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        let transaction_id = transaction_id.ok_or(per_codec_error_new(format!(
            "Missing mandatory IE transaction_id"
        )))?;
        Ok(Self {
            transaction_id,
            cells_failed_to_be_activated_list,
            criticality_diagnostics,
            gnb_cu_tnl_association_setup_list,
            gnb_cu_tnl_association_failed_to_setup_list,
            dedicated_si_delivery_needed_ue_list,
            transport_layer_address_info,
            cells_with_ss_bs_activated_list,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        let ie = &mut Allocator::new_codec_data();
        self.transaction_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 78, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        if let Some(x) = &self.cells_failed_to_be_activated_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 1, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.criticality_diagnostics {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 7, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.gnb_cu_tnl_association_setup_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 132, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.gnb_cu_tnl_association_failed_to_setup_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 134, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.dedicated_si_delivery_needed_ue_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 189, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.transport_layer_address_info {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 254, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.cells_with_ss_bs_activated_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 745, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        encode::encode_sequence_header(data, true, &BitString::new(), false)?;
        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for GnbCuConfigurationUpdateAcknowledge {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        GnbCuConfigurationUpdateAcknowledge::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("GnbCuConfigurationUpdateAcknowledge");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("GnbCuConfigurationUpdateAcknowledge");
            e
        })
    }
}
// CellsFailedToBeActivatedList
#[derive(Clone, Debug)]
pub struct CellsFailedToBeActivatedList(pub NonEmpty<CellsFailedToBeActivatedListItem>);

impl CellsFailedToBeActivatedList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(512), false)?;
            let mut items = vec![];
            for _ in 0..length {
                let _ = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _ = Criticality::decode(data)?;
                let _ = decode::decode_length_determinent(data, None, None, false)?;
                items.push(CellsFailedToBeActivatedListItem::decode(data)?);
                data.decode_align()?;
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(512), false, self.0.len())?;
        for x in &self.0 {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(data, Some(0), Some(65535), false, 2, false)?;
            Criticality::Reject.encode(data)?;
            encode::encode_length_determinent(data, None, None, false, ie.length_in_bytes())?;
            data.append_aligned(ie);
        }
        Ok(())
    }
}

impl PerCodec for CellsFailedToBeActivatedList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        CellsFailedToBeActivatedList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CellsFailedToBeActivatedList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CellsFailedToBeActivatedList");
            e
        })
    }
}
// GnbCuTnlAssociationSetupList
#[derive(Clone, Debug)]
pub struct GnbCuTnlAssociationSetupList(pub NonEmpty<GnbCuTnlAssociationSetupItem>);

impl GnbCuTnlAssociationSetupList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(32), false)?;
            let mut items = vec![];
            for _ in 0..length {
                let _ = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _ = Criticality::decode(data)?;
                let _ = decode::decode_length_determinent(data, None, None, false)?;
                items.push(GnbCuTnlAssociationSetupItem::decode(data)?);
                data.decode_align()?;
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(32), false, self.0.len())?;
        for x in &self.0 {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(data, Some(0), Some(65535), false, 133, false)?;
            Criticality::Ignore.encode(data)?;
            encode::encode_length_determinent(data, None, None, false, ie.length_in_bytes())?;
            data.append_aligned(ie);
        }
        Ok(())
    }
}

impl PerCodec for GnbCuTnlAssociationSetupList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        GnbCuTnlAssociationSetupList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("GnbCuTnlAssociationSetupList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("GnbCuTnlAssociationSetupList");
            e
        })
    }
}
// GnbCuTnlAssociationFailedToSetupList
#[derive(Clone, Debug)]
pub struct GnbCuTnlAssociationFailedToSetupList(pub NonEmpty<GnbCuTnlAssociationFailedToSetupItem>);

impl GnbCuTnlAssociationFailedToSetupList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(32), false)?;
            let mut items = vec![];
            for _ in 0..length {
                let _ = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _ = Criticality::decode(data)?;
                let _ = decode::decode_length_determinent(data, None, None, false)?;
                items.push(GnbCuTnlAssociationFailedToSetupItem::decode(data)?);
                data.decode_align()?;
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(32), false, self.0.len())?;
        for x in &self.0 {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(data, Some(0), Some(65535), false, 135, false)?;
            Criticality::Ignore.encode(data)?;
            encode::encode_length_determinent(data, None, None, false, ie.length_in_bytes())?;
            data.append_aligned(ie);
        }
        Ok(())
    }
}

impl PerCodec for GnbCuTnlAssociationFailedToSetupList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        GnbCuTnlAssociationFailedToSetupList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("GnbCuTnlAssociationFailedToSetupList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("GnbCuTnlAssociationFailedToSetupList");
            e
        })
    }
}
// GnbCuConfigurationUpdateFailure
#[derive(Clone, Debug)]
pub struct GnbCuConfigurationUpdateFailure {
    pub transaction_id: TransactionId,
    pub cause: Cause,
    pub time_to_wait: Option<TimeToWait>,
    pub criticality_diagnostics: Option<CriticalityDiagnostics>,
}

impl GnbCuConfigurationUpdateFailure {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let _ = decode::decode_sequence_header(data, true, 0)?;
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut transaction_id: Option<TransactionId> = None;
        let mut cause: Option<Cause> = None;
        let mut time_to_wait: Option<TimeToWait> = None;
        let mut criticality_diagnostics: Option<CriticalityDiagnostics> = None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                78 => transaction_id = Some(TransactionId::decode(data)?),
                0 => cause = Some(Cause::decode(data)?),
                77 => time_to_wait = Some(TimeToWait::decode(data)?),
                7 => criticality_diagnostics = Some(CriticalityDiagnostics::decode(data)?),
                x => return Err(per_codec_error_new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        let transaction_id = transaction_id.ok_or(per_codec_error_new(format!(
            "Missing mandatory IE transaction_id"
        )))?;
        let cause = cause.ok_or(per_codec_error_new(format!("Missing mandatory IE cause")))?;
        Ok(Self {
            transaction_id,
            cause,
            time_to_wait,
            criticality_diagnostics,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        let ie = &mut Allocator::new_codec_data();
        self.transaction_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 78, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.cause.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 0, false)?;
        Criticality::Ignore.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        if let Some(x) = &self.time_to_wait {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 77, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.criticality_diagnostics {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 7, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        encode::encode_sequence_header(data, true, &BitString::new(), false)?;
        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for GnbCuConfigurationUpdateFailure {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        GnbCuConfigurationUpdateFailure::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("GnbCuConfigurationUpdateFailure");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("GnbCuConfigurationUpdateFailure");
            e
        })
    }
}
// GnbDuResourceCoordinationRequest
#[derive(Clone, Debug)]
pub struct GnbDuResourceCoordinationRequest {
    pub transaction_id: TransactionId,
    pub request_type: RequestType,
    pub eutra_nr_cell_resource_coordination_req_container:
        EutraNrCellResourceCoordinationReqContainer,
    pub ignore_resource_coordination_container: Option<IgnoreResourceCoordinationContainer>,
}

impl GnbDuResourceCoordinationRequest {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let _ = decode::decode_sequence_header(data, true, 0)?;
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut transaction_id: Option<TransactionId> = None;
        let mut request_type: Option<RequestType> = None;
        let mut eutra_nr_cell_resource_coordination_req_container: Option<
            EutraNrCellResourceCoordinationReqContainer,
        > = None;
        let mut ignore_resource_coordination_container: Option<
            IgnoreResourceCoordinationContainer,
        > = None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                78 => transaction_id = Some(TransactionId::decode(data)?),
                106 => request_type = Some(RequestType::decode(data)?),
                101 => {
                    eutra_nr_cell_resource_coordination_req_container =
                        Some(EutraNrCellResourceCoordinationReqContainer::decode(data)?)
                }
                213 => {
                    ignore_resource_coordination_container =
                        Some(IgnoreResourceCoordinationContainer::decode(data)?)
                }
                x => return Err(per_codec_error_new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        let transaction_id = transaction_id.ok_or(per_codec_error_new(format!(
            "Missing mandatory IE transaction_id"
        )))?;
        let request_type = request_type.ok_or(per_codec_error_new(format!(
            "Missing mandatory IE request_type"
        )))?;
        let eutra_nr_cell_resource_coordination_req_container =
            eutra_nr_cell_resource_coordination_req_container.ok_or(per_codec_error_new(
                format!("Missing mandatory IE eutra_nr_cell_resource_coordination_req_container"),
            ))?;
        Ok(Self {
            transaction_id,
            request_type,
            eutra_nr_cell_resource_coordination_req_container,
            ignore_resource_coordination_container,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        let ie = &mut Allocator::new_codec_data();
        self.transaction_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 78, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.request_type.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 106, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.eutra_nr_cell_resource_coordination_req_container
            .encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 101, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        if let Some(x) = &self.ignore_resource_coordination_container {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 213, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        encode::encode_sequence_header(data, true, &BitString::new(), false)?;
        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for GnbDuResourceCoordinationRequest {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        GnbDuResourceCoordinationRequest::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("GnbDuResourceCoordinationRequest");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("GnbDuResourceCoordinationRequest");
            e
        })
    }
}
// GnbDuResourceCoordinationResponse
#[derive(Clone, Debug)]
pub struct GnbDuResourceCoordinationResponse {
    pub transaction_id: TransactionId,
    pub eutra_nr_cell_resource_coordination_req_ack_container:
        EutraNrCellResourceCoordinationReqAckContainer,
}

impl GnbDuResourceCoordinationResponse {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let _ = decode::decode_sequence_header(data, true, 0)?;
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut transaction_id: Option<TransactionId> = None;
        let mut eutra_nr_cell_resource_coordination_req_ack_container: Option<
            EutraNrCellResourceCoordinationReqAckContainer,
        > = None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                78 => transaction_id = Some(TransactionId::decode(data)?),
                102 => {
                    eutra_nr_cell_resource_coordination_req_ack_container = Some(
                        EutraNrCellResourceCoordinationReqAckContainer::decode(data)?,
                    )
                }
                x => return Err(per_codec_error_new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        let transaction_id = transaction_id.ok_or(per_codec_error_new(format!(
            "Missing mandatory IE transaction_id"
        )))?;
        let eutra_nr_cell_resource_coordination_req_ack_container =
            eutra_nr_cell_resource_coordination_req_ack_container.ok_or(per_codec_error_new(
                format!(
                    "Missing mandatory IE eutra_nr_cell_resource_coordination_req_ack_container"
                ),
            ))?;
        Ok(Self {
            transaction_id,
            eutra_nr_cell_resource_coordination_req_ack_container,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        let ie = &mut Allocator::new_codec_data();
        self.transaction_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 78, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.eutra_nr_cell_resource_coordination_req_ack_container
            .encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 102, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        encode::encode_sequence_header(data, true, &BitString::new(), false)?;
        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for GnbDuResourceCoordinationResponse {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        GnbDuResourceCoordinationResponse::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("GnbDuResourceCoordinationResponse");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("GnbDuResourceCoordinationResponse");
            e
        })
    }
}
// UeContextSetupRequest
#[derive(Clone, Debug)]
pub struct UeContextSetupRequest {
    pub gnb_cu_ue_f1ap_id: GnbCuUeF1apId,
    pub gnb_du_ue_f1ap_id: Option<GnbDuUeF1apId>,
    pub sp_cell_id: NrCgi,
    pub serv_cell_index: ServCellIndex,
    pub sp_cell_ul_configured: Option<CellUlConfigured>,
    pub cu_to_du_rrc_information: CuToDuRrcInformation,
    pub candidate_sp_cell_list: Option<CandidateSpCellList>,
    pub drx_cycle: Option<DrxCycle>,
    pub resource_coordination_transfer_container: Option<ResourceCoordinationTransferContainer>,
    pub s_cell_to_be_setup_list: Option<SCellToBeSetupList>,
    pub srbs_to_be_setup_list: Option<SrbsToBeSetupList>,
    pub drbs_to_be_setup_list: Option<DrbsToBeSetupList>,
    pub inactivity_monitoring_request: Option<InactivityMonitoringRequest>,
    pub rat_frequency_priority_information: Option<RatFrequencyPriorityInformation>,
    pub rrc_container: Option<RrcContainer>,
    pub masked_imeisv: Option<MaskedImeisv>,
    pub serving_plmn: Option<PlmnIdentity>,
    pub gnb_du_ue_ambr_ul: Option<BitRate>,
    pub rrc_delivery_status_request: Option<RrcDeliveryStatusRequest>,
    pub resource_coordination_transfer_information: Option<ResourceCoordinationTransferInformation>,
    pub serving_cell_mo: Option<ServingCellMo>,
    pub new_gnb_cu_ue_f1ap_id: Option<GnbDuUeF1apId>,
    pub ran_ue_id: Option<RanUeId>,
    pub trace_activation: Option<TraceActivation>,
    pub additional_rrm_priority_index: Option<AdditionalRrmPriorityIndex>,
    pub bh_channels_to_be_setup_list: Option<BhChannelsToBeSetupList>,
    pub configured_bap_address: Option<BapAddress>,
    pub nr_v2x_services_authorized: Option<NrV2xServicesAuthorized>,
    pub ltev2x_services_authorized: Option<Ltev2xServicesAuthorized>,
    pub nr_ue_sidelink_aggregate_maximum_bitrate: Option<NrUeSidelinkAggregateMaximumBitrate>,
    pub lte_ue_sidelink_aggregate_maximum_bitrate: Option<LteUeSidelinkAggregateMaximumBitrate>,
    pub pc5_link_ambr: Option<BitRate>,
    pub sl_drbs_to_be_setup_list: Option<SlDrbsToBeSetupList>,
    pub conditional_inter_du_mobility_information: Option<ConditionalInterDuMobilityInformation>,
    pub management_based_mdt_plmn_list: Option<MdtPlmnList>,
    pub serving_nid: Option<Nid>,
    pub f1c_transfer_path: Option<F1cTransferPath>,
    pub f1c_transfer_path_nr_dc: Option<F1cTransferPathNrDc>,
    pub mdt_polluted_measurement_indicator: Option<MdtPollutedMeasurementIndicator>,
    pub scg_activation_request: Option<ScgActivationRequest>,
    pub cg_sdt_session_info_old: Option<CgSdtSessionInfo>,
    pub five_g_pro_se_authorized: Option<FiveGProSeAuthorized>,
    pub five_g_pro_se_ue_pc5_aggregate_maximum_bitrate: Option<NrUeSidelinkAggregateMaximumBitrate>,
    pub five_g_pro_se_pc5_link_ambr: Option<BitRate>,
    pub uu_rlc_channel_to_be_setup_list: Option<UuRlcChannelToBeSetupList>,
    pub pc5rlc_channel_to_be_setup_list: Option<Pc5rlcChannelToBeSetupList>,
    pub path_switch_configuration: Option<PathSwitchConfiguration>,
    pub gnb_du_ue_slice_maximum_bit_rate_list: Option<GnbDuUeSliceMaximumBitRateList>,
    pub multicast_mbs_session_setup_list: Option<MulticastMbsSessionList>,
    pub ue_multicast_mr_bs_to_be_setup_list: Option<UeMulticastMrBsToBeSetupList>,
    pub serving_cell_mo_list: Option<ServingCellMoList>,
    pub network_controlled_repeater_authorized: Option<NetworkControlledRepeaterAuthorized>,
    pub sdt_volume_threshold: Option<SdtVolumeThreshold>,
    pub ltm_information_setup: Option<LtmInformationSetup>,
    pub ltm_configuration_id_mapping_list: Option<LtmConfigurationIdMappingList>,
    pub early_sync_information_request: Option<EarlySyncInformationRequest>,
    pub path_addition_information: Option<PathAdditionInformation>,
    pub nr_a2x_services_authorized: Option<NrA2xServicesAuthorized>,
    pub ltea2x_services_authorized: Option<Ltea2xServicesAuthorized>,
    pub nr_ue_sidelink_aggregate_maximum_bitrate_for_a2x:
        Option<NrUeSidelinkAggregateMaximumBitrate>,
    pub lte_ue_sidelink_aggregate_maximum_bitrate_for_a2x:
        Option<LteUeSidelinkAggregateMaximumBitrate>,
    pub dllbt_failure_information_request: Option<DllbtFailureInformationRequest>,
    pub sl_positioning_ranging_service_info: Option<SlPositioningRangingServiceInfo>,
    pub non_integer_drx_cycle: Option<NonIntegerDrxCycle>,
}

impl UeContextSetupRequest {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let _ = decode::decode_sequence_header(data, true, 0)?;
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut gnb_cu_ue_f1ap_id: Option<GnbCuUeF1apId> = None;
        let mut gnb_du_ue_f1ap_id: Option<GnbDuUeF1apId> = None;
        let mut sp_cell_id: Option<NrCgi> = None;
        let mut serv_cell_index: Option<ServCellIndex> = None;
        let mut sp_cell_ul_configured: Option<CellUlConfigured> = None;
        let mut cu_to_du_rrc_information: Option<CuToDuRrcInformation> = None;
        let mut candidate_sp_cell_list: Option<CandidateSpCellList> = None;
        let mut drx_cycle: Option<DrxCycle> = None;
        let mut resource_coordination_transfer_container: Option<
            ResourceCoordinationTransferContainer,
        > = None;
        let mut s_cell_to_be_setup_list: Option<SCellToBeSetupList> = None;
        let mut srbs_to_be_setup_list: Option<SrbsToBeSetupList> = None;
        let mut drbs_to_be_setup_list: Option<DrbsToBeSetupList> = None;
        let mut inactivity_monitoring_request: Option<InactivityMonitoringRequest> = None;
        let mut rat_frequency_priority_information: Option<RatFrequencyPriorityInformation> = None;
        let mut rrc_container: Option<RrcContainer> = None;
        let mut masked_imeisv: Option<MaskedImeisv> = None;
        let mut serving_plmn: Option<PlmnIdentity> = None;
        let mut gnb_du_ue_ambr_ul: Option<BitRate> = None;
        let mut rrc_delivery_status_request: Option<RrcDeliveryStatusRequest> = None;
        let mut resource_coordination_transfer_information: Option<
            ResourceCoordinationTransferInformation,
        > = None;
        let mut serving_cell_mo: Option<ServingCellMo> = None;
        let mut new_gnb_cu_ue_f1ap_id: Option<GnbDuUeF1apId> = None;
        let mut ran_ue_id: Option<RanUeId> = None;
        let mut trace_activation: Option<TraceActivation> = None;
        let mut additional_rrm_priority_index: Option<AdditionalRrmPriorityIndex> = None;
        let mut bh_channels_to_be_setup_list: Option<BhChannelsToBeSetupList> = None;
        let mut configured_bap_address: Option<BapAddress> = None;
        let mut nr_v2x_services_authorized: Option<NrV2xServicesAuthorized> = None;
        let mut ltev2x_services_authorized: Option<Ltev2xServicesAuthorized> = None;
        let mut nr_ue_sidelink_aggregate_maximum_bitrate: Option<
            NrUeSidelinkAggregateMaximumBitrate,
        > = None;
        let mut lte_ue_sidelink_aggregate_maximum_bitrate: Option<
            LteUeSidelinkAggregateMaximumBitrate,
        > = None;
        let mut pc5_link_ambr: Option<BitRate> = None;
        let mut sl_drbs_to_be_setup_list: Option<SlDrbsToBeSetupList> = None;
        let mut conditional_inter_du_mobility_information: Option<
            ConditionalInterDuMobilityInformation,
        > = None;
        let mut management_based_mdt_plmn_list: Option<MdtPlmnList> = None;
        let mut serving_nid: Option<Nid> = None;
        let mut f1c_transfer_path: Option<F1cTransferPath> = None;
        let mut f1c_transfer_path_nr_dc: Option<F1cTransferPathNrDc> = None;
        let mut mdt_polluted_measurement_indicator: Option<MdtPollutedMeasurementIndicator> = None;
        let mut scg_activation_request: Option<ScgActivationRequest> = None;
        let mut cg_sdt_session_info_old: Option<CgSdtSessionInfo> = None;
        let mut five_g_pro_se_authorized: Option<FiveGProSeAuthorized> = None;
        let mut five_g_pro_se_ue_pc5_aggregate_maximum_bitrate: Option<
            NrUeSidelinkAggregateMaximumBitrate,
        > = None;
        let mut five_g_pro_se_pc5_link_ambr: Option<BitRate> = None;
        let mut uu_rlc_channel_to_be_setup_list: Option<UuRlcChannelToBeSetupList> = None;
        let mut pc5rlc_channel_to_be_setup_list: Option<Pc5rlcChannelToBeSetupList> = None;
        let mut path_switch_configuration: Option<PathSwitchConfiguration> = None;
        let mut gnb_du_ue_slice_maximum_bit_rate_list: Option<GnbDuUeSliceMaximumBitRateList> =
            None;
        let mut multicast_mbs_session_setup_list: Option<MulticastMbsSessionList> = None;
        let mut ue_multicast_mr_bs_to_be_setup_list: Option<UeMulticastMrBsToBeSetupList> = None;
        let mut serving_cell_mo_list: Option<ServingCellMoList> = None;
        let mut network_controlled_repeater_authorized: Option<
            NetworkControlledRepeaterAuthorized,
        > = None;
        let mut sdt_volume_threshold: Option<SdtVolumeThreshold> = None;
        let mut ltm_information_setup: Option<LtmInformationSetup> = None;
        let mut ltm_configuration_id_mapping_list: Option<LtmConfigurationIdMappingList> = None;
        let mut early_sync_information_request: Option<EarlySyncInformationRequest> = None;
        let mut path_addition_information: Option<PathAdditionInformation> = None;
        let mut nr_a2x_services_authorized: Option<NrA2xServicesAuthorized> = None;
        let mut ltea2x_services_authorized: Option<Ltea2xServicesAuthorized> = None;
        let mut nr_ue_sidelink_aggregate_maximum_bitrate_for_a2x: Option<
            NrUeSidelinkAggregateMaximumBitrate,
        > = None;
        let mut lte_ue_sidelink_aggregate_maximum_bitrate_for_a2x: Option<
            LteUeSidelinkAggregateMaximumBitrate,
        > = None;
        let mut dllbt_failure_information_request: Option<DllbtFailureInformationRequest> = None;
        let mut sl_positioning_ranging_service_info: Option<SlPositioningRangingServiceInfo> = None;
        let mut non_integer_drx_cycle: Option<NonIntegerDrxCycle> = None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                40 => gnb_cu_ue_f1ap_id = Some(GnbCuUeF1apId::decode(data)?),
                41 => gnb_du_ue_f1ap_id = Some(GnbDuUeF1apId::decode(data)?),
                63 => sp_cell_id = Some(NrCgi::decode(data)?),
                107 => serv_cell_index = Some(ServCellIndex::decode(data)?),
                96 => sp_cell_ul_configured = Some(CellUlConfigured::decode(data)?),
                9 => cu_to_du_rrc_information = Some(CuToDuRrcInformation::decode(data)?),
                90 => candidate_sp_cell_list = Some(CandidateSpCellList::decode(data)?),
                38 => drx_cycle = Some(DrxCycle::decode(data)?),
                49 => {
                    resource_coordination_transfer_container =
                        Some(ResourceCoordinationTransferContainer::decode(data)?)
                }
                54 => s_cell_to_be_setup_list = Some(SCellToBeSetupList::decode(data)?),
                74 => srbs_to_be_setup_list = Some(SrbsToBeSetupList::decode(data)?),
                35 => drbs_to_be_setup_list = Some(DrbsToBeSetupList::decode(data)?),
                97 => {
                    inactivity_monitoring_request = Some(InactivityMonitoringRequest::decode(data)?)
                }
                108 => {
                    rat_frequency_priority_information =
                        Some(RatFrequencyPriorityInformation::decode(data)?)
                }
                50 => rrc_container = Some(RrcContainer::decode(data)?),
                126 => masked_imeisv = Some(MaskedImeisv::decode(data)?),
                165 => serving_plmn = Some(PlmnIdentity::decode(data)?),
                158 => gnb_du_ue_ambr_ul = Some(BitRate::decode(data)?),
                184 => rrc_delivery_status_request = Some(RrcDeliveryStatusRequest::decode(data)?),
                195 => {
                    resource_coordination_transfer_information =
                        Some(ResourceCoordinationTransferInformation::decode(data)?)
                }
                182 => serving_cell_mo = Some(ServingCellMo::decode(data)?),
                217 => new_gnb_cu_ue_f1ap_id = Some(GnbDuUeF1apId::decode(data)?),
                226 => ran_ue_id = Some(RanUeId::decode(data)?),
                242 => trace_activation = Some(TraceActivation::decode(data)?),
                248 => {
                    additional_rrm_priority_index = Some(AdditionalRrmPriorityIndex::decode(data)?)
                }
                258 => bh_channels_to_be_setup_list = Some(BhChannelsToBeSetupList::decode(data)?),
                282 => configured_bap_address = Some(BapAddress::decode(data)?),
                306 => nr_v2x_services_authorized = Some(NrV2xServicesAuthorized::decode(data)?),
                307 => ltev2x_services_authorized = Some(Ltev2xServicesAuthorized::decode(data)?),
                308 => {
                    nr_ue_sidelink_aggregate_maximum_bitrate =
                        Some(NrUeSidelinkAggregateMaximumBitrate::decode(data)?)
                }
                309 => {
                    lte_ue_sidelink_aggregate_maximum_bitrate =
                        Some(LteUeSidelinkAggregateMaximumBitrate::decode(data)?)
                }
                340 => pc5_link_ambr = Some(BitRate::decode(data)?),
                330 => sl_drbs_to_be_setup_list = Some(SlDrbsToBeSetupList::decode(data)?),
                373 => {
                    conditional_inter_du_mobility_information =
                        Some(ConditionalInterDuMobilityInformation::decode(data)?)
                }
                377 => management_based_mdt_plmn_list = Some(MdtPlmnList::decode(data)?),
                382 => serving_nid = Some(Nid::decode(data)?),
                428 => f1c_transfer_path = Some(F1cTransferPath::decode(data)?),
                511 => f1c_transfer_path_nr_dc = Some(F1cTransferPathNrDc::decode(data)?),
                536 => {
                    mdt_polluted_measurement_indicator =
                        Some(MdtPollutedMeasurementIndicator::decode(data)?)
                }
                547 => scg_activation_request = Some(ScgActivationRequest::decode(data)?),
                591 => cg_sdt_session_info_old = Some(CgSdtSessionInfo::decode(data)?),
                594 => five_g_pro_se_authorized = Some(FiveGProSeAuthorized::decode(data)?),
                595 => {
                    five_g_pro_se_ue_pc5_aggregate_maximum_bitrate =
                        Some(NrUeSidelinkAggregateMaximumBitrate::decode(data)?)
                }
                596 => five_g_pro_se_pc5_link_ambr = Some(BitRate::decode(data)?),
                599 => {
                    uu_rlc_channel_to_be_setup_list = Some(UuRlcChannelToBeSetupList::decode(data)?)
                }
                608 => {
                    pc5rlc_channel_to_be_setup_list =
                        Some(Pc5rlcChannelToBeSetupList::decode(data)?)
                }
                619 => path_switch_configuration = Some(PathSwitchConfiguration::decode(data)?),
                626 => {
                    gnb_du_ue_slice_maximum_bit_rate_list =
                        Some(GnbDuUeSliceMaximumBitRateList::decode(data)?)
                }
                632 => {
                    multicast_mbs_session_setup_list = Some(MulticastMbsSessionList::decode(data)?)
                }
                630 => {
                    ue_multicast_mr_bs_to_be_setup_list =
                        Some(UeMulticastMrBsToBeSetupList::decode(data)?)
                }
                695 => serving_cell_mo_list = Some(ServingCellMoList::decode(data)?),
                712 => {
                    network_controlled_repeater_authorized =
                        Some(NetworkControlledRepeaterAuthorized::decode(data)?)
                }
                716 => sdt_volume_threshold = Some(SdtVolumeThreshold::decode(data)?),
                720 => ltm_information_setup = Some(LtmInformationSetup::decode(data)?),
                721 => {
                    ltm_configuration_id_mapping_list =
                        Some(LtmConfigurationIdMappingList::decode(data)?)
                }
                726 => {
                    early_sync_information_request =
                        Some(EarlySyncInformationRequest::decode(data)?)
                }
                741 => path_addition_information = Some(PathAdditionInformation::decode(data)?),
                779 => nr_a2x_services_authorized = Some(NrA2xServicesAuthorized::decode(data)?),
                780 => ltea2x_services_authorized = Some(Ltea2xServicesAuthorized::decode(data)?),
                781 => {
                    nr_ue_sidelink_aggregate_maximum_bitrate_for_a2x =
                        Some(NrUeSidelinkAggregateMaximumBitrate::decode(data)?)
                }
                782 => {
                    lte_ue_sidelink_aggregate_maximum_bitrate_for_a2x =
                        Some(LteUeSidelinkAggregateMaximumBitrate::decode(data)?)
                }
                794 => {
                    dllbt_failure_information_request =
                        Some(DllbtFailureInformationRequest::decode(data)?)
                }
                801 => {
                    sl_positioning_ranging_service_info =
                        Some(SlPositioningRangingServiceInfo::decode(data)?)
                }
                838 => non_integer_drx_cycle = Some(NonIntegerDrxCycle::decode(data)?),
                x => return Err(per_codec_error_new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        let gnb_cu_ue_f1ap_id = gnb_cu_ue_f1ap_id.ok_or(per_codec_error_new(format!(
            "Missing mandatory IE gnb_cu_ue_f1ap_id"
        )))?;
        let sp_cell_id = sp_cell_id.ok_or(per_codec_error_new(format!(
            "Missing mandatory IE sp_cell_id"
        )))?;
        let serv_cell_index = serv_cell_index.ok_or(per_codec_error_new(format!(
            "Missing mandatory IE serv_cell_index"
        )))?;
        let cu_to_du_rrc_information = cu_to_du_rrc_information.ok_or(per_codec_error_new(
            format!("Missing mandatory IE cu_to_du_rrc_information"),
        ))?;
        Ok(Self {
            gnb_cu_ue_f1ap_id,
            gnb_du_ue_f1ap_id,
            sp_cell_id,
            serv_cell_index,
            sp_cell_ul_configured,
            cu_to_du_rrc_information,
            candidate_sp_cell_list,
            drx_cycle,
            resource_coordination_transfer_container,
            s_cell_to_be_setup_list,
            srbs_to_be_setup_list,
            drbs_to_be_setup_list,
            inactivity_monitoring_request,
            rat_frequency_priority_information,
            rrc_container,
            masked_imeisv,
            serving_plmn,
            gnb_du_ue_ambr_ul,
            rrc_delivery_status_request,
            resource_coordination_transfer_information,
            serving_cell_mo,
            new_gnb_cu_ue_f1ap_id,
            ran_ue_id,
            trace_activation,
            additional_rrm_priority_index,
            bh_channels_to_be_setup_list,
            configured_bap_address,
            nr_v2x_services_authorized,
            ltev2x_services_authorized,
            nr_ue_sidelink_aggregate_maximum_bitrate,
            lte_ue_sidelink_aggregate_maximum_bitrate,
            pc5_link_ambr,
            sl_drbs_to_be_setup_list,
            conditional_inter_du_mobility_information,
            management_based_mdt_plmn_list,
            serving_nid,
            f1c_transfer_path,
            f1c_transfer_path_nr_dc,
            mdt_polluted_measurement_indicator,
            scg_activation_request,
            cg_sdt_session_info_old,
            five_g_pro_se_authorized,
            five_g_pro_se_ue_pc5_aggregate_maximum_bitrate,
            five_g_pro_se_pc5_link_ambr,
            uu_rlc_channel_to_be_setup_list,
            pc5rlc_channel_to_be_setup_list,
            path_switch_configuration,
            gnb_du_ue_slice_maximum_bit_rate_list,
            multicast_mbs_session_setup_list,
            ue_multicast_mr_bs_to_be_setup_list,
            serving_cell_mo_list,
            network_controlled_repeater_authorized,
            sdt_volume_threshold,
            ltm_information_setup,
            ltm_configuration_id_mapping_list,
            early_sync_information_request,
            path_addition_information,
            nr_a2x_services_authorized,
            ltea2x_services_authorized,
            nr_ue_sidelink_aggregate_maximum_bitrate_for_a2x,
            lte_ue_sidelink_aggregate_maximum_bitrate_for_a2x,
            dllbt_failure_information_request,
            sl_positioning_ranging_service_info,
            non_integer_drx_cycle,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        let ie = &mut Allocator::new_codec_data();
        self.gnb_cu_ue_f1ap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 40, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        if let Some(x) = &self.gnb_du_ue_f1ap_id {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 41, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        let ie = &mut Allocator::new_codec_data();
        self.sp_cell_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 63, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.serv_cell_index.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 107, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        if let Some(x) = &self.sp_cell_ul_configured {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 96, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        let ie = &mut Allocator::new_codec_data();
        self.cu_to_du_rrc_information.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 9, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        if let Some(x) = &self.candidate_sp_cell_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 90, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.drx_cycle {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 38, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.resource_coordination_transfer_container {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 49, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.s_cell_to_be_setup_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 54, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.srbs_to_be_setup_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 74, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.drbs_to_be_setup_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 35, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.inactivity_monitoring_request {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 97, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.rat_frequency_priority_information {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 108, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.rrc_container {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 50, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.masked_imeisv {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 126, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.serving_plmn {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 165, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.gnb_du_ue_ambr_ul {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 158, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.rrc_delivery_status_request {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 184, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.resource_coordination_transfer_information {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 195, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.serving_cell_mo {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 182, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.new_gnb_cu_ue_f1ap_id {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 217, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.ran_ue_id {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 226, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.trace_activation {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 242, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.additional_rrm_priority_index {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 248, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.bh_channels_to_be_setup_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 258, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.configured_bap_address {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 282, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.nr_v2x_services_authorized {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 306, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.ltev2x_services_authorized {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 307, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.nr_ue_sidelink_aggregate_maximum_bitrate {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 308, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.lte_ue_sidelink_aggregate_maximum_bitrate {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 309, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.pc5_link_ambr {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 340, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.sl_drbs_to_be_setup_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 330, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.conditional_inter_du_mobility_information {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 373, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.management_based_mdt_plmn_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 377, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.serving_nid {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 382, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.f1c_transfer_path {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 428, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.f1c_transfer_path_nr_dc {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 511, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.mdt_polluted_measurement_indicator {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 536, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.scg_activation_request {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 547, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.cg_sdt_session_info_old {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 591, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.five_g_pro_se_authorized {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 594, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.five_g_pro_se_ue_pc5_aggregate_maximum_bitrate {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 595, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.five_g_pro_se_pc5_link_ambr {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 596, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.uu_rlc_channel_to_be_setup_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 599, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.pc5rlc_channel_to_be_setup_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 608, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.path_switch_configuration {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 619, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.gnb_du_ue_slice_maximum_bit_rate_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 626, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.multicast_mbs_session_setup_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 632, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.ue_multicast_mr_bs_to_be_setup_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 630, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.serving_cell_mo_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 695, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.network_controlled_repeater_authorized {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 712, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.sdt_volume_threshold {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 716, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.ltm_information_setup {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 720, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.ltm_configuration_id_mapping_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 721, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.early_sync_information_request {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 726, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.path_addition_information {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 741, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.nr_a2x_services_authorized {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 779, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.ltea2x_services_authorized {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 780, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.nr_ue_sidelink_aggregate_maximum_bitrate_for_a2x {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 781, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.lte_ue_sidelink_aggregate_maximum_bitrate_for_a2x {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 782, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.dllbt_failure_information_request {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 794, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.sl_positioning_ranging_service_info {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 801, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.non_integer_drx_cycle {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 838, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        encode::encode_sequence_header(data, true, &BitString::new(), false)?;
        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for UeContextSetupRequest {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        UeContextSetupRequest::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UeContextSetupRequest");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UeContextSetupRequest");
            e
        })
    }
}
// CandidateSpCellList
#[derive(Clone, Debug)]
pub struct CandidateSpCellList(pub NonEmpty<CandidateSpCellItem>);

impl CandidateSpCellList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(64), false)?;
            let mut items = vec![];
            for _ in 0..length {
                let _ = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _ = Criticality::decode(data)?;
                let _ = decode::decode_length_determinent(data, None, None, false)?;
                items.push(CandidateSpCellItem::decode(data)?);
                data.decode_align()?;
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(64), false, self.0.len())?;
        for x in &self.0 {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(data, Some(0), Some(65535), false, 91, false)?;
            Criticality::Ignore.encode(data)?;
            encode::encode_length_determinent(data, None, None, false, ie.length_in_bytes())?;
            data.append_aligned(ie);
        }
        Ok(())
    }
}

impl PerCodec for CandidateSpCellList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        CandidateSpCellList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CandidateSpCellList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CandidateSpCellList");
            e
        })
    }
}
// SCellToBeSetupList
#[derive(Clone, Debug)]
pub struct SCellToBeSetupList(pub NonEmpty<SCellToBeSetupItem>);

impl SCellToBeSetupList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(32), false)?;
            let mut items = vec![];
            for _ in 0..length {
                let _ = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _ = Criticality::decode(data)?;
                let _ = decode::decode_length_determinent(data, None, None, false)?;
                items.push(SCellToBeSetupItem::decode(data)?);
                data.decode_align()?;
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(32), false, self.0.len())?;
        for x in &self.0 {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(data, Some(0), Some(65535), false, 53, false)?;
            Criticality::Ignore.encode(data)?;
            encode::encode_length_determinent(data, None, None, false, ie.length_in_bytes())?;
            data.append_aligned(ie);
        }
        Ok(())
    }
}

impl PerCodec for SCellToBeSetupList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        SCellToBeSetupList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SCellToBeSetupList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SCellToBeSetupList");
            e
        })
    }
}
// SrbsToBeSetupList
#[derive(Clone, Debug)]
pub struct SrbsToBeSetupList(pub NonEmpty<SrbsToBeSetupItem>);

impl SrbsToBeSetupList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(8), false)?;
            let mut items = vec![];
            for _ in 0..length {
                let _ = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _ = Criticality::decode(data)?;
                let _ = decode::decode_length_determinent(data, None, None, false)?;
                items.push(SrbsToBeSetupItem::decode(data)?);
                data.decode_align()?;
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(8), false, self.0.len())?;
        for x in &self.0 {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(data, Some(0), Some(65535), false, 73, false)?;
            Criticality::Reject.encode(data)?;
            encode::encode_length_determinent(data, None, None, false, ie.length_in_bytes())?;
            data.append_aligned(ie);
        }
        Ok(())
    }
}

impl PerCodec for SrbsToBeSetupList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        SrbsToBeSetupList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SrbsToBeSetupList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SrbsToBeSetupList");
            e
        })
    }
}
// DrbsToBeSetupList
#[derive(Clone, Debug)]
pub struct DrbsToBeSetupList(pub NonEmpty<DrbsToBeSetupItem>);

impl DrbsToBeSetupList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(64), false)?;
            let mut items = vec![];
            for _ in 0..length {
                let _ = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _ = Criticality::decode(data)?;
                let _ = decode::decode_length_determinent(data, None, None, false)?;
                items.push(DrbsToBeSetupItem::decode(data)?);
                data.decode_align()?;
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(64), false, self.0.len())?;
        for x in &self.0 {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(data, Some(0), Some(65535), false, 34, false)?;
            Criticality::Reject.encode(data)?;
            encode::encode_length_determinent(data, None, None, false, ie.length_in_bytes())?;
            data.append_aligned(ie);
        }
        Ok(())
    }
}

impl PerCodec for DrbsToBeSetupList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        DrbsToBeSetupList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DrbsToBeSetupList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DrbsToBeSetupList");
            e
        })
    }
}
// BhChannelsToBeSetupList
#[derive(Clone, Debug)]
pub struct BhChannelsToBeSetupList(pub NonEmpty<BhChannelsToBeSetupItem>);

impl BhChannelsToBeSetupList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(65536), false)?;
            let mut items = vec![];
            for _ in 0..length {
                let _ = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _ = Criticality::decode(data)?;
                let _ = decode::decode_length_determinent(data, None, None, false)?;
                items.push(BhChannelsToBeSetupItem::decode(data)?);
                data.decode_align()?;
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(65536), false, self.0.len())?;
        for x in &self.0 {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(data, Some(0), Some(65535), false, 259, false)?;
            Criticality::Reject.encode(data)?;
            encode::encode_length_determinent(data, None, None, false, ie.length_in_bytes())?;
            data.append_aligned(ie);
        }
        Ok(())
    }
}

impl PerCodec for BhChannelsToBeSetupList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        BhChannelsToBeSetupList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("BhChannelsToBeSetupList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("BhChannelsToBeSetupList");
            e
        })
    }
}
// SlDrbsToBeSetupList
#[derive(Clone, Debug)]
pub struct SlDrbsToBeSetupList(pub NonEmpty<SlDrbsToBeSetupItem>);

impl SlDrbsToBeSetupList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(512), false)?;
            let mut items = vec![];
            for _ in 0..length {
                let _ = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _ = Criticality::decode(data)?;
                let _ = decode::decode_length_determinent(data, None, None, false)?;
                items.push(SlDrbsToBeSetupItem::decode(data)?);
                data.decode_align()?;
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(512), false, self.0.len())?;
        for x in &self.0 {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(data, Some(0), Some(65535), false, 329, false)?;
            Criticality::Reject.encode(data)?;
            encode::encode_length_determinent(data, None, None, false, ie.length_in_bytes())?;
            data.append_aligned(ie);
        }
        Ok(())
    }
}

impl PerCodec for SlDrbsToBeSetupList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        SlDrbsToBeSetupList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SlDrbsToBeSetupList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SlDrbsToBeSetupList");
            e
        })
    }
}
// UeMulticastMrBsToBeSetupList
#[derive(Clone, Debug)]
pub struct UeMulticastMrBsToBeSetupList(pub NonEmpty<UeMulticastMrBsToBeSetupItem>);

impl UeMulticastMrBsToBeSetupList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(64), false)?;
            let mut items = vec![];
            for _ in 0..length {
                let _ = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _ = Criticality::decode(data)?;
                let _ = decode::decode_length_determinent(data, None, None, false)?;
                items.push(UeMulticastMrBsToBeSetupItem::decode(data)?);
                data.decode_align()?;
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(64), false, self.0.len())?;
        for x in &self.0 {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(data, Some(0), Some(65535), false, 631, false)?;
            Criticality::Reject.encode(data)?;
            encode::encode_length_determinent(data, None, None, false, ie.length_in_bytes())?;
            data.append_aligned(ie);
        }
        Ok(())
    }
}

impl PerCodec for UeMulticastMrBsToBeSetupList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        UeMulticastMrBsToBeSetupList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UeMulticastMrBsToBeSetupList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UeMulticastMrBsToBeSetupList");
            e
        })
    }
}
// ServingCellMoList
#[derive(Clone, Debug)]
pub struct ServingCellMoList(pub NonEmpty<ServingCellMoListItem>);

impl ServingCellMoList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(16), false)?;
            let mut items = vec![];
            for _ in 0..length {
                let _ = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _ = Criticality::decode(data)?;
                let _ = decode::decode_length_determinent(data, None, None, false)?;
                items.push(ServingCellMoListItem::decode(data)?);
                data.decode_align()?;
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(16), false, self.0.len())?;
        for x in &self.0 {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(data, Some(0), Some(65535), false, 696, false)?;
            Criticality::Reject.encode(data)?;
            encode::encode_length_determinent(data, None, None, false, ie.length_in_bytes())?;
            data.append_aligned(ie);
        }
        Ok(())
    }
}

impl PerCodec for ServingCellMoList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        ServingCellMoList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ServingCellMoList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ServingCellMoList");
            e
        })
    }
}
// UeContextSetupResponse
#[derive(Clone, Debug)]
pub struct UeContextSetupResponse {
    pub gnb_cu_ue_f1ap_id: GnbCuUeF1apId,
    pub gnb_du_ue_f1ap_id: GnbDuUeF1apId,
    pub du_to_cu_rrc_information: DuToCuRrcInformation,
    pub c_rnti: Option<CRnti>,
    pub resource_coordination_transfer_container: Option<ResourceCoordinationTransferContainer>,
    pub full_configuration: Option<FullConfiguration>,
    pub drbs_setup_list: Option<DrbsSetupList>,
    pub srbs_failed_to_be_setup_list: Option<SrbsFailedToBeSetupList>,
    pub drbs_failed_to_be_setup_list: Option<DrbsFailedToBeSetupList>,
    pub s_cell_failedto_setup_list: Option<SCellFailedtoSetupList>,
    pub inactivity_monitoring_response: Option<InactivityMonitoringResponse>,
    pub criticality_diagnostics: Option<CriticalityDiagnostics>,
    pub srbs_setup_list: Option<SrbsSetupList>,
    pub bh_channels_setup_list: Option<BhChannelsSetupList>,
    pub bh_channels_failed_to_be_setup_list: Option<BhChannelsFailedToBeSetupList>,
    pub sl_drbs_setup_list: Option<SlDrbsSetupList>,
    pub sl_drbs_failed_to_be_setup_list: Option<SlDrbsFailedToBeSetupList>,
    pub requested_target_cell_global_id: Option<NrCgi>,
    pub scg_activation_status: Option<ScgActivationStatus>,
    pub uu_rlc_channel_setup_list: Option<UuRlcChannelSetupList>,
    pub uu_rlc_channel_failed_to_be_setup_list: Option<UuRlcChannelFailedToBeSetupList>,
    pub pc5rlc_channel_setup_list: Option<Pc5rlcChannelSetupList>,
    pub pc5rlc_channel_failed_to_be_setup_list: Option<Pc5rlcChannelFailedToBeSetupList>,
    pub serving_cell_mo_encoded_in_cgc_list: Option<ServingCellMoEncodedInCgcList>,
    pub ue_multicast_mr_bs_setupnew_list: Option<UeMulticastMrBsSetupnewList>,
    pub dedicated_si_delivery_indication: Option<DedicatedSiDeliveryIndication>,
    pub configured_bwp_list: Option<ConfiguredBwpList>,
    pub early_sync_information: Option<EarlySyncInformation>,
    pub ltm_configuration: Option<LtmConfiguration>,
    pub s_cpac_configuration: Option<SCpacConfiguration>,
}

impl UeContextSetupResponse {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let _ = decode::decode_sequence_header(data, true, 0)?;
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut gnb_cu_ue_f1ap_id: Option<GnbCuUeF1apId> = None;
        let mut gnb_du_ue_f1ap_id: Option<GnbDuUeF1apId> = None;
        let mut du_to_cu_rrc_information: Option<DuToCuRrcInformation> = None;
        let mut c_rnti: Option<CRnti> = None;
        let mut resource_coordination_transfer_container: Option<
            ResourceCoordinationTransferContainer,
        > = None;
        let mut full_configuration: Option<FullConfiguration> = None;
        let mut drbs_setup_list: Option<DrbsSetupList> = None;
        let mut srbs_failed_to_be_setup_list: Option<SrbsFailedToBeSetupList> = None;
        let mut drbs_failed_to_be_setup_list: Option<DrbsFailedToBeSetupList> = None;
        let mut s_cell_failedto_setup_list: Option<SCellFailedtoSetupList> = None;
        let mut inactivity_monitoring_response: Option<InactivityMonitoringResponse> = None;
        let mut criticality_diagnostics: Option<CriticalityDiagnostics> = None;
        let mut srbs_setup_list: Option<SrbsSetupList> = None;
        let mut bh_channels_setup_list: Option<BhChannelsSetupList> = None;
        let mut bh_channels_failed_to_be_setup_list: Option<BhChannelsFailedToBeSetupList> = None;
        let mut sl_drbs_setup_list: Option<SlDrbsSetupList> = None;
        let mut sl_drbs_failed_to_be_setup_list: Option<SlDrbsFailedToBeSetupList> = None;
        let mut requested_target_cell_global_id: Option<NrCgi> = None;
        let mut scg_activation_status: Option<ScgActivationStatus> = None;
        let mut uu_rlc_channel_setup_list: Option<UuRlcChannelSetupList> = None;
        let mut uu_rlc_channel_failed_to_be_setup_list: Option<UuRlcChannelFailedToBeSetupList> =
            None;
        let mut pc5rlc_channel_setup_list: Option<Pc5rlcChannelSetupList> = None;
        let mut pc5rlc_channel_failed_to_be_setup_list: Option<Pc5rlcChannelFailedToBeSetupList> =
            None;
        let mut serving_cell_mo_encoded_in_cgc_list: Option<ServingCellMoEncodedInCgcList> = None;
        let mut ue_multicast_mr_bs_setupnew_list: Option<UeMulticastMrBsSetupnewList> = None;
        let mut dedicated_si_delivery_indication: Option<DedicatedSiDeliveryIndication> = None;
        let mut configured_bwp_list: Option<ConfiguredBwpList> = None;
        let mut early_sync_information: Option<EarlySyncInformation> = None;
        let mut ltm_configuration: Option<LtmConfiguration> = None;
        let mut s_cpac_configuration: Option<SCpacConfiguration> = None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                40 => gnb_cu_ue_f1ap_id = Some(GnbCuUeF1apId::decode(data)?),
                41 => gnb_du_ue_f1ap_id = Some(GnbDuUeF1apId::decode(data)?),
                39 => du_to_cu_rrc_information = Some(DuToCuRrcInformation::decode(data)?),
                95 => c_rnti = Some(CRnti::decode(data)?),
                49 => {
                    resource_coordination_transfer_container =
                        Some(ResourceCoordinationTransferContainer::decode(data)?)
                }
                94 => full_configuration = Some(FullConfiguration::decode(data)?),
                27 => drbs_setup_list = Some(DrbsSetupList::decode(data)?),
                66 => srbs_failed_to_be_setup_list = Some(SrbsFailedToBeSetupList::decode(data)?),
                15 => drbs_failed_to_be_setup_list = Some(DrbsFailedToBeSetupList::decode(data)?),
                83 => s_cell_failedto_setup_list = Some(SCellFailedtoSetupList::decode(data)?),
                98 => {
                    inactivity_monitoring_response =
                        Some(InactivityMonitoringResponse::decode(data)?)
                }
                7 => criticality_diagnostics = Some(CriticalityDiagnostics::decode(data)?),
                202 => srbs_setup_list = Some(SrbsSetupList::decode(data)?),
                260 => bh_channels_setup_list = Some(BhChannelsSetupList::decode(data)?),
                279 => {
                    bh_channels_failed_to_be_setup_list =
                        Some(BhChannelsFailedToBeSetupList::decode(data)?)
                }
                324 => sl_drbs_setup_list = Some(SlDrbsSetupList::decode(data)?),
                316 => {
                    sl_drbs_failed_to_be_setup_list = Some(SlDrbsFailedToBeSetupList::decode(data)?)
                }
                376 => requested_target_cell_global_id = Some(NrCgi::decode(data)?),
                548 => scg_activation_status = Some(ScgActivationStatus::decode(data)?),
                602 => uu_rlc_channel_setup_list = Some(UuRlcChannelSetupList::decode(data)?),
                603 => {
                    uu_rlc_channel_failed_to_be_setup_list =
                        Some(UuRlcChannelFailedToBeSetupList::decode(data)?)
                }
                611 => pc5rlc_channel_setup_list = Some(Pc5rlcChannelSetupList::decode(data)?),
                612 => {
                    pc5rlc_channel_failed_to_be_setup_list =
                        Some(Pc5rlcChannelFailedToBeSetupList::decode(data)?)
                }
                697 => {
                    serving_cell_mo_encoded_in_cgc_list =
                        Some(ServingCellMoEncodedInCgcList::decode(data)?)
                }
                699 => {
                    ue_multicast_mr_bs_setupnew_list =
                        Some(UeMulticastMrBsSetupnewList::decode(data)?)
                }
                708 => {
                    dedicated_si_delivery_indication =
                        Some(DedicatedSiDeliveryIndication::decode(data)?)
                }
                709 => configured_bwp_list = Some(ConfiguredBwpList::decode(data)?),
                727 => early_sync_information = Some(EarlySyncInformation::decode(data)?),
                725 => ltm_configuration = Some(LtmConfiguration::decode(data)?),
                792 => s_cpac_configuration = Some(SCpacConfiguration::decode(data)?),
                x => return Err(per_codec_error_new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        let gnb_cu_ue_f1ap_id = gnb_cu_ue_f1ap_id.ok_or(per_codec_error_new(format!(
            "Missing mandatory IE gnb_cu_ue_f1ap_id"
        )))?;
        let gnb_du_ue_f1ap_id = gnb_du_ue_f1ap_id.ok_or(per_codec_error_new(format!(
            "Missing mandatory IE gnb_du_ue_f1ap_id"
        )))?;
        let du_to_cu_rrc_information = du_to_cu_rrc_information.ok_or(per_codec_error_new(
            format!("Missing mandatory IE du_to_cu_rrc_information"),
        ))?;
        Ok(Self {
            gnb_cu_ue_f1ap_id,
            gnb_du_ue_f1ap_id,
            du_to_cu_rrc_information,
            c_rnti,
            resource_coordination_transfer_container,
            full_configuration,
            drbs_setup_list,
            srbs_failed_to_be_setup_list,
            drbs_failed_to_be_setup_list,
            s_cell_failedto_setup_list,
            inactivity_monitoring_response,
            criticality_diagnostics,
            srbs_setup_list,
            bh_channels_setup_list,
            bh_channels_failed_to_be_setup_list,
            sl_drbs_setup_list,
            sl_drbs_failed_to_be_setup_list,
            requested_target_cell_global_id,
            scg_activation_status,
            uu_rlc_channel_setup_list,
            uu_rlc_channel_failed_to_be_setup_list,
            pc5rlc_channel_setup_list,
            pc5rlc_channel_failed_to_be_setup_list,
            serving_cell_mo_encoded_in_cgc_list,
            ue_multicast_mr_bs_setupnew_list,
            dedicated_si_delivery_indication,
            configured_bwp_list,
            early_sync_information,
            ltm_configuration,
            s_cpac_configuration,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        let ie = &mut Allocator::new_codec_data();
        self.gnb_cu_ue_f1ap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 40, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.gnb_du_ue_f1ap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 41, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.du_to_cu_rrc_information.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 39, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        if let Some(x) = &self.c_rnti {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 95, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.resource_coordination_transfer_container {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 49, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.full_configuration {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 94, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.drbs_setup_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 27, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.srbs_failed_to_be_setup_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 66, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.drbs_failed_to_be_setup_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 15, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.s_cell_failedto_setup_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 83, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.inactivity_monitoring_response {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 98, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.criticality_diagnostics {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 7, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.srbs_setup_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 202, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.bh_channels_setup_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 260, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.bh_channels_failed_to_be_setup_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 279, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.sl_drbs_setup_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 324, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.sl_drbs_failed_to_be_setup_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 316, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.requested_target_cell_global_id {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 376, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.scg_activation_status {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 548, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.uu_rlc_channel_setup_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 602, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.uu_rlc_channel_failed_to_be_setup_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 603, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.pc5rlc_channel_setup_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 611, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.pc5rlc_channel_failed_to_be_setup_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 612, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.serving_cell_mo_encoded_in_cgc_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 697, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.ue_multicast_mr_bs_setupnew_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 699, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.dedicated_si_delivery_indication {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 708, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.configured_bwp_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 709, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.early_sync_information {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 727, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.ltm_configuration {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 725, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.s_cpac_configuration {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 792, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        encode::encode_sequence_header(data, true, &BitString::new(), false)?;
        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for UeContextSetupResponse {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        UeContextSetupResponse::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UeContextSetupResponse");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UeContextSetupResponse");
            e
        })
    }
}
// DrbsSetupList
#[derive(Clone, Debug)]
pub struct DrbsSetupList(pub NonEmpty<DrbsSetupItem>);

impl DrbsSetupList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(64), false)?;
            let mut items = vec![];
            for _ in 0..length {
                let _ = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _ = Criticality::decode(data)?;
                let _ = decode::decode_length_determinent(data, None, None, false)?;
                items.push(DrbsSetupItem::decode(data)?);
                data.decode_align()?;
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(64), false, self.0.len())?;
        for x in &self.0 {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(data, Some(0), Some(65535), false, 26, false)?;
            Criticality::Ignore.encode(data)?;
            encode::encode_length_determinent(data, None, None, false, ie.length_in_bytes())?;
            data.append_aligned(ie);
        }
        Ok(())
    }
}

impl PerCodec for DrbsSetupList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        DrbsSetupList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DrbsSetupList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DrbsSetupList");
            e
        })
    }
}
// SrbsFailedToBeSetupList
#[derive(Clone, Debug)]
pub struct SrbsFailedToBeSetupList(pub NonEmpty<SrbsFailedToBeSetupItem>);

impl SrbsFailedToBeSetupList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(8), false)?;
            let mut items = vec![];
            for _ in 0..length {
                let _ = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _ = Criticality::decode(data)?;
                let _ = decode::decode_length_determinent(data, None, None, false)?;
                items.push(SrbsFailedToBeSetupItem::decode(data)?);
                data.decode_align()?;
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(8), false, self.0.len())?;
        for x in &self.0 {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(data, Some(0), Some(65535), false, 65, false)?;
            Criticality::Ignore.encode(data)?;
            encode::encode_length_determinent(data, None, None, false, ie.length_in_bytes())?;
            data.append_aligned(ie);
        }
        Ok(())
    }
}

impl PerCodec for SrbsFailedToBeSetupList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        SrbsFailedToBeSetupList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SrbsFailedToBeSetupList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SrbsFailedToBeSetupList");
            e
        })
    }
}
// DrbsFailedToBeSetupList
#[derive(Clone, Debug)]
pub struct DrbsFailedToBeSetupList(pub NonEmpty<DrbsFailedToBeSetupItem>);

impl DrbsFailedToBeSetupList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(64), false)?;
            let mut items = vec![];
            for _ in 0..length {
                let _ = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _ = Criticality::decode(data)?;
                let _ = decode::decode_length_determinent(data, None, None, false)?;
                items.push(DrbsFailedToBeSetupItem::decode(data)?);
                data.decode_align()?;
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(64), false, self.0.len())?;
        for x in &self.0 {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(data, Some(0), Some(65535), false, 14, false)?;
            Criticality::Ignore.encode(data)?;
            encode::encode_length_determinent(data, None, None, false, ie.length_in_bytes())?;
            data.append_aligned(ie);
        }
        Ok(())
    }
}

impl PerCodec for DrbsFailedToBeSetupList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        DrbsFailedToBeSetupList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DrbsFailedToBeSetupList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DrbsFailedToBeSetupList");
            e
        })
    }
}
// SCellFailedtoSetupList
#[derive(Clone, Debug)]
pub struct SCellFailedtoSetupList(pub NonEmpty<SCellFailedtoSetupItem>);

impl SCellFailedtoSetupList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(32), false)?;
            let mut items = vec![];
            for _ in 0..length {
                let _ = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _ = Criticality::decode(data)?;
                let _ = decode::decode_length_determinent(data, None, None, false)?;
                items.push(SCellFailedtoSetupItem::decode(data)?);
                data.decode_align()?;
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(32), false, self.0.len())?;
        for x in &self.0 {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(data, Some(0), Some(65535), false, 84, false)?;
            Criticality::Ignore.encode(data)?;
            encode::encode_length_determinent(data, None, None, false, ie.length_in_bytes())?;
            data.append_aligned(ie);
        }
        Ok(())
    }
}

impl PerCodec for SCellFailedtoSetupList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        SCellFailedtoSetupList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SCellFailedtoSetupList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SCellFailedtoSetupList");
            e
        })
    }
}
// SrbsSetupList
#[derive(Clone, Debug)]
pub struct SrbsSetupList(pub NonEmpty<SrbsSetupItem>);

impl SrbsSetupList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(8), false)?;
            let mut items = vec![];
            for _ in 0..length {
                let _ = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _ = Criticality::decode(data)?;
                let _ = decode::decode_length_determinent(data, None, None, false)?;
                items.push(SrbsSetupItem::decode(data)?);
                data.decode_align()?;
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(8), false, self.0.len())?;
        for x in &self.0 {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(data, Some(0), Some(65535), false, 203, false)?;
            Criticality::Ignore.encode(data)?;
            encode::encode_length_determinent(data, None, None, false, ie.length_in_bytes())?;
            data.append_aligned(ie);
        }
        Ok(())
    }
}

impl PerCodec for SrbsSetupList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        SrbsSetupList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SrbsSetupList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SrbsSetupList");
            e
        })
    }
}
// BhChannelsSetupList
#[derive(Clone, Debug)]
pub struct BhChannelsSetupList(pub NonEmpty<BhChannelsSetupItem>);

impl BhChannelsSetupList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(65536), false)?;
            let mut items = vec![];
            for _ in 0..length {
                let _ = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _ = Criticality::decode(data)?;
                let _ = decode::decode_length_determinent(data, None, None, false)?;
                items.push(BhChannelsSetupItem::decode(data)?);
                data.decode_align()?;
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(65536), false, self.0.len())?;
        for x in &self.0 {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(data, Some(0), Some(65535), false, 261, false)?;
            Criticality::Ignore.encode(data)?;
            encode::encode_length_determinent(data, None, None, false, ie.length_in_bytes())?;
            data.append_aligned(ie);
        }
        Ok(())
    }
}

impl PerCodec for BhChannelsSetupList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        BhChannelsSetupList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("BhChannelsSetupList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("BhChannelsSetupList");
            e
        })
    }
}
// BhChannelsFailedToBeSetupList
#[derive(Clone, Debug)]
pub struct BhChannelsFailedToBeSetupList(pub NonEmpty<BhChannelsFailedToBeSetupItem>);

impl BhChannelsFailedToBeSetupList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(65536), false)?;
            let mut items = vec![];
            for _ in 0..length {
                let _ = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _ = Criticality::decode(data)?;
                let _ = decode::decode_length_determinent(data, None, None, false)?;
                items.push(BhChannelsFailedToBeSetupItem::decode(data)?);
                data.decode_align()?;
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(65536), false, self.0.len())?;
        for x in &self.0 {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(data, Some(0), Some(65535), false, 278, false)?;
            Criticality::Ignore.encode(data)?;
            encode::encode_length_determinent(data, None, None, false, ie.length_in_bytes())?;
            data.append_aligned(ie);
        }
        Ok(())
    }
}

impl PerCodec for BhChannelsFailedToBeSetupList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        BhChannelsFailedToBeSetupList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("BhChannelsFailedToBeSetupList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("BhChannelsFailedToBeSetupList");
            e
        })
    }
}
// SlDrbsSetupList
#[derive(Clone, Debug)]
pub struct SlDrbsSetupList(pub NonEmpty<SlDrbsSetupItem>);

impl SlDrbsSetupList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(512), false)?;
            let mut items = vec![];
            for _ in 0..length {
                let _ = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _ = Criticality::decode(data)?;
                let _ = decode::decode_length_determinent(data, None, None, false)?;
                items.push(SlDrbsSetupItem::decode(data)?);
                data.decode_align()?;
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(512), false, self.0.len())?;
        for x in &self.0 {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(data, Some(0), Some(65535), false, 323, false)?;
            Criticality::Ignore.encode(data)?;
            encode::encode_length_determinent(data, None, None, false, ie.length_in_bytes())?;
            data.append_aligned(ie);
        }
        Ok(())
    }
}

impl PerCodec for SlDrbsSetupList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        SlDrbsSetupList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SlDrbsSetupList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SlDrbsSetupList");
            e
        })
    }
}
// SlDrbsFailedToBeSetupList
#[derive(Clone, Debug)]
pub struct SlDrbsFailedToBeSetupList(pub NonEmpty<SlDrbsFailedToBeSetupItem>);

impl SlDrbsFailedToBeSetupList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(512), false)?;
            let mut items = vec![];
            for _ in 0..length {
                let _ = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _ = Criticality::decode(data)?;
                let _ = decode::decode_length_determinent(data, None, None, false)?;
                items.push(SlDrbsFailedToBeSetupItem::decode(data)?);
                data.decode_align()?;
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(512), false, self.0.len())?;
        for x in &self.0 {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(data, Some(0), Some(65535), false, 315, false)?;
            Criticality::Ignore.encode(data)?;
            encode::encode_length_determinent(data, None, None, false, ie.length_in_bytes())?;
            data.append_aligned(ie);
        }
        Ok(())
    }
}

impl PerCodec for SlDrbsFailedToBeSetupList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        SlDrbsFailedToBeSetupList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SlDrbsFailedToBeSetupList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SlDrbsFailedToBeSetupList");
            e
        })
    }
}
// UeMulticastMrBsSetupnewList
#[derive(Clone, Debug)]
pub struct UeMulticastMrBsSetupnewList(pub NonEmpty<UeMulticastMrBsSetupnewItem>);

impl UeMulticastMrBsSetupnewList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(64), false)?;
            let mut items = vec![];
            for _ in 0..length {
                let _ = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _ = Criticality::decode(data)?;
                let _ = decode::decode_length_determinent(data, None, None, false)?;
                items.push(UeMulticastMrBsSetupnewItem::decode(data)?);
                data.decode_align()?;
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(64), false, self.0.len())?;
        for x in &self.0 {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(data, Some(0), Some(65535), false, 700, false)?;
            Criticality::Reject.encode(data)?;
            encode::encode_length_determinent(data, None, None, false, ie.length_in_bytes())?;
            data.append_aligned(ie);
        }
        Ok(())
    }
}

impl PerCodec for UeMulticastMrBsSetupnewList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        UeMulticastMrBsSetupnewList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UeMulticastMrBsSetupnewList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UeMulticastMrBsSetupnewList");
            e
        })
    }
}
// UeContextSetupFailure
#[derive(Clone, Debug)]
pub struct UeContextSetupFailure {
    pub gnb_cu_ue_f1ap_id: GnbCuUeF1apId,
    pub gnb_du_ue_f1ap_id: Option<GnbDuUeF1apId>,
    pub cause: Cause,
    pub criticality_diagnostics: Option<CriticalityDiagnostics>,
    pub potential_sp_cell_list: Option<PotentialSpCellList>,
    pub requested_target_cell_global_id: Option<NrCgi>,
}

impl UeContextSetupFailure {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let _ = decode::decode_sequence_header(data, true, 0)?;
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut gnb_cu_ue_f1ap_id: Option<GnbCuUeF1apId> = None;
        let mut gnb_du_ue_f1ap_id: Option<GnbDuUeF1apId> = None;
        let mut cause: Option<Cause> = None;
        let mut criticality_diagnostics: Option<CriticalityDiagnostics> = None;
        let mut potential_sp_cell_list: Option<PotentialSpCellList> = None;
        let mut requested_target_cell_global_id: Option<NrCgi> = None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                40 => gnb_cu_ue_f1ap_id = Some(GnbCuUeF1apId::decode(data)?),
                41 => gnb_du_ue_f1ap_id = Some(GnbDuUeF1apId::decode(data)?),
                0 => cause = Some(Cause::decode(data)?),
                7 => criticality_diagnostics = Some(CriticalityDiagnostics::decode(data)?),
                92 => potential_sp_cell_list = Some(PotentialSpCellList::decode(data)?),
                376 => requested_target_cell_global_id = Some(NrCgi::decode(data)?),
                x => return Err(per_codec_error_new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        let gnb_cu_ue_f1ap_id = gnb_cu_ue_f1ap_id.ok_or(per_codec_error_new(format!(
            "Missing mandatory IE gnb_cu_ue_f1ap_id"
        )))?;
        let cause = cause.ok_or(per_codec_error_new(format!("Missing mandatory IE cause")))?;
        Ok(Self {
            gnb_cu_ue_f1ap_id,
            gnb_du_ue_f1ap_id,
            cause,
            criticality_diagnostics,
            potential_sp_cell_list,
            requested_target_cell_global_id,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        let ie = &mut Allocator::new_codec_data();
        self.gnb_cu_ue_f1ap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 40, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        if let Some(x) = &self.gnb_du_ue_f1ap_id {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 41, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        let ie = &mut Allocator::new_codec_data();
        self.cause.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 0, false)?;
        Criticality::Ignore.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        if let Some(x) = &self.criticality_diagnostics {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 7, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.potential_sp_cell_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 92, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.requested_target_cell_global_id {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 376, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        encode::encode_sequence_header(data, true, &BitString::new(), false)?;
        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for UeContextSetupFailure {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        UeContextSetupFailure::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UeContextSetupFailure");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UeContextSetupFailure");
            e
        })
    }
}
// PotentialSpCellList
#[derive(Clone, Debug)]
pub struct PotentialSpCellList(pub Vec<PotentialSpCellItem>);

impl PotentialSpCellList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(0), Some(64), false)?;
            let mut items = vec![];
            for _ in 0..length {
                let _ = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _ = Criticality::decode(data)?;
                let _ = decode::decode_length_determinent(data, None, None, false)?;
                items.push(PotentialSpCellItem::decode(data)?);
                data.decode_align()?;
            }
            items
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(0), Some(64), false, self.0.len())?;
        for x in &self.0 {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(data, Some(0), Some(65535), false, 93, false)?;
            Criticality::Ignore.encode(data)?;
            encode::encode_length_determinent(data, None, None, false, ie.length_in_bytes())?;
            data.append_aligned(ie);
        }
        Ok(())
    }
}

impl PerCodec for PotentialSpCellList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PotentialSpCellList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PotentialSpCellList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PotentialSpCellList");
            e
        })
    }
}
// UeContextReleaseRequest
#[derive(Clone, Debug)]
pub struct UeContextReleaseRequest {
    pub gnb_cu_ue_f1ap_id: GnbCuUeF1apId,
    pub gnb_du_ue_f1ap_id: GnbDuUeF1apId,
    pub cause: Cause,
    pub target_cells_to_cancel: Option<TargetCellList>,
    pub ltm_cells_to_be_released_list: Option<LtmCellsToBeReleasedList>,
}

impl UeContextReleaseRequest {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let _ = decode::decode_sequence_header(data, true, 0)?;
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut gnb_cu_ue_f1ap_id: Option<GnbCuUeF1apId> = None;
        let mut gnb_du_ue_f1ap_id: Option<GnbDuUeF1apId> = None;
        let mut cause: Option<Cause> = None;
        let mut target_cells_to_cancel: Option<TargetCellList> = None;
        let mut ltm_cells_to_be_released_list: Option<LtmCellsToBeReleasedList> = None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                40 => gnb_cu_ue_f1ap_id = Some(GnbCuUeF1apId::decode(data)?),
                41 => gnb_du_ue_f1ap_id = Some(GnbDuUeF1apId::decode(data)?),
                0 => cause = Some(Cause::decode(data)?),
                375 => target_cells_to_cancel = Some(TargetCellList::decode(data)?),
                723 => {
                    ltm_cells_to_be_released_list = Some(LtmCellsToBeReleasedList::decode(data)?)
                }
                x => return Err(per_codec_error_new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        let gnb_cu_ue_f1ap_id = gnb_cu_ue_f1ap_id.ok_or(per_codec_error_new(format!(
            "Missing mandatory IE gnb_cu_ue_f1ap_id"
        )))?;
        let gnb_du_ue_f1ap_id = gnb_du_ue_f1ap_id.ok_or(per_codec_error_new(format!(
            "Missing mandatory IE gnb_du_ue_f1ap_id"
        )))?;
        let cause = cause.ok_or(per_codec_error_new(format!("Missing mandatory IE cause")))?;
        Ok(Self {
            gnb_cu_ue_f1ap_id,
            gnb_du_ue_f1ap_id,
            cause,
            target_cells_to_cancel,
            ltm_cells_to_be_released_list,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        let ie = &mut Allocator::new_codec_data();
        self.gnb_cu_ue_f1ap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 40, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.gnb_du_ue_f1ap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 41, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.cause.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 0, false)?;
        Criticality::Ignore.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        if let Some(x) = &self.target_cells_to_cancel {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 375, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.ltm_cells_to_be_released_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 723, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        encode::encode_sequence_header(data, true, &BitString::new(), false)?;
        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for UeContextReleaseRequest {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        UeContextReleaseRequest::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UeContextReleaseRequest");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UeContextReleaseRequest");
            e
        })
    }
}
// UeContextReleaseCommand
#[derive(Clone, Debug)]
pub struct UeContextReleaseCommand {
    pub gnb_cu_ue_f1ap_id: GnbCuUeF1apId,
    pub gnb_du_ue_f1ap_id: GnbDuUeF1apId,
    pub cause: Cause,
    pub rrc_container: Option<RrcContainer>,
    pub srb_id: Option<SrbId>,
    pub old_gnb_du_ue_f1ap_id: Option<GnbDuUeF1apId>,
    pub execute_duplication: Option<ExecuteDuplication>,
    pub rrc_delivery_status_request: Option<RrcDeliveryStatusRequest>,
    pub target_cells_to_cancel: Option<TargetCellList>,
    pub pos_context_rev_indication: Option<PosContextRevIndication>,
    pub cg_sdt_kept_indicator: Option<CgSdtKeptIndicator>,
    pub ltm_cells_to_be_released_list: Option<LtmCellsToBeReleasedList>,
    pub dllbt_failure_information_request: Option<DllbtFailureInformationRequest>,
}

impl UeContextReleaseCommand {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let _ = decode::decode_sequence_header(data, true, 0)?;
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut gnb_cu_ue_f1ap_id: Option<GnbCuUeF1apId> = None;
        let mut gnb_du_ue_f1ap_id: Option<GnbDuUeF1apId> = None;
        let mut cause: Option<Cause> = None;
        let mut rrc_container: Option<RrcContainer> = None;
        let mut srb_id: Option<SrbId> = None;
        let mut old_gnb_du_ue_f1ap_id: Option<GnbDuUeF1apId> = None;
        let mut execute_duplication: Option<ExecuteDuplication> = None;
        let mut rrc_delivery_status_request: Option<RrcDeliveryStatusRequest> = None;
        let mut target_cells_to_cancel: Option<TargetCellList> = None;
        let mut pos_context_rev_indication: Option<PosContextRevIndication> = None;
        let mut cg_sdt_kept_indicator: Option<CgSdtKeptIndicator> = None;
        let mut ltm_cells_to_be_released_list: Option<LtmCellsToBeReleasedList> = None;
        let mut dllbt_failure_information_request: Option<DllbtFailureInformationRequest> = None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                40 => gnb_cu_ue_f1ap_id = Some(GnbCuUeF1apId::decode(data)?),
                41 => gnb_du_ue_f1ap_id = Some(GnbDuUeF1apId::decode(data)?),
                0 => cause = Some(Cause::decode(data)?),
                50 => rrc_container = Some(RrcContainer::decode(data)?),
                64 => srb_id = Some(SrbId::decode(data)?),
                47 => old_gnb_du_ue_f1ap_id = Some(GnbDuUeF1apId::decode(data)?),
                109 => execute_duplication = Some(ExecuteDuplication::decode(data)?),
                184 => rrc_delivery_status_request = Some(RrcDeliveryStatusRequest::decode(data)?),
                375 => target_cells_to_cancel = Some(TargetCellList::decode(data)?),
                576 => pos_context_rev_indication = Some(PosContextRevIndication::decode(data)?),
                588 => cg_sdt_kept_indicator = Some(CgSdtKeptIndicator::decode(data)?),
                723 => {
                    ltm_cells_to_be_released_list = Some(LtmCellsToBeReleasedList::decode(data)?)
                }
                794 => {
                    dllbt_failure_information_request =
                        Some(DllbtFailureInformationRequest::decode(data)?)
                }
                x => return Err(per_codec_error_new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        let gnb_cu_ue_f1ap_id = gnb_cu_ue_f1ap_id.ok_or(per_codec_error_new(format!(
            "Missing mandatory IE gnb_cu_ue_f1ap_id"
        )))?;
        let gnb_du_ue_f1ap_id = gnb_du_ue_f1ap_id.ok_or(per_codec_error_new(format!(
            "Missing mandatory IE gnb_du_ue_f1ap_id"
        )))?;
        let cause = cause.ok_or(per_codec_error_new(format!("Missing mandatory IE cause")))?;
        Ok(Self {
            gnb_cu_ue_f1ap_id,
            gnb_du_ue_f1ap_id,
            cause,
            rrc_container,
            srb_id,
            old_gnb_du_ue_f1ap_id,
            execute_duplication,
            rrc_delivery_status_request,
            target_cells_to_cancel,
            pos_context_rev_indication,
            cg_sdt_kept_indicator,
            ltm_cells_to_be_released_list,
            dllbt_failure_information_request,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        let ie = &mut Allocator::new_codec_data();
        self.gnb_cu_ue_f1ap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 40, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.gnb_du_ue_f1ap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 41, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.cause.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 0, false)?;
        Criticality::Ignore.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        if let Some(x) = &self.rrc_container {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 50, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.srb_id {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 64, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.old_gnb_du_ue_f1ap_id {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 47, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.execute_duplication {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 109, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.rrc_delivery_status_request {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 184, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.target_cells_to_cancel {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 375, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.pos_context_rev_indication {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 576, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.cg_sdt_kept_indicator {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 588, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.ltm_cells_to_be_released_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 723, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.dllbt_failure_information_request {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 794, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        encode::encode_sequence_header(data, true, &BitString::new(), false)?;
        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for UeContextReleaseCommand {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        UeContextReleaseCommand::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UeContextReleaseCommand");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UeContextReleaseCommand");
            e
        })
    }
}
// UeContextReleaseComplete
#[derive(Clone, Debug)]
pub struct UeContextReleaseComplete {
    pub gnb_cu_ue_f1ap_id: GnbCuUeF1apId,
    pub gnb_du_ue_f1ap_id: GnbDuUeF1apId,
    pub criticality_diagnostics: Option<CriticalityDiagnostics>,
    pub recommended_ss_bs_for_paging_list: Option<RecommendedSsBsForPagingList>,
}

impl UeContextReleaseComplete {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let _ = decode::decode_sequence_header(data, true, 0)?;
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut gnb_cu_ue_f1ap_id: Option<GnbCuUeF1apId> = None;
        let mut gnb_du_ue_f1ap_id: Option<GnbDuUeF1apId> = None;
        let mut criticality_diagnostics: Option<CriticalityDiagnostics> = None;
        let mut recommended_ss_bs_for_paging_list: Option<RecommendedSsBsForPagingList> = None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                40 => gnb_cu_ue_f1ap_id = Some(GnbCuUeF1apId::decode(data)?),
                41 => gnb_du_ue_f1ap_id = Some(GnbDuUeF1apId::decode(data)?),
                7 => criticality_diagnostics = Some(CriticalityDiagnostics::decode(data)?),
                743 => {
                    recommended_ss_bs_for_paging_list =
                        Some(RecommendedSsBsForPagingList::decode(data)?)
                }
                x => return Err(per_codec_error_new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        let gnb_cu_ue_f1ap_id = gnb_cu_ue_f1ap_id.ok_or(per_codec_error_new(format!(
            "Missing mandatory IE gnb_cu_ue_f1ap_id"
        )))?;
        let gnb_du_ue_f1ap_id = gnb_du_ue_f1ap_id.ok_or(per_codec_error_new(format!(
            "Missing mandatory IE gnb_du_ue_f1ap_id"
        )))?;
        Ok(Self {
            gnb_cu_ue_f1ap_id,
            gnb_du_ue_f1ap_id,
            criticality_diagnostics,
            recommended_ss_bs_for_paging_list,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        let ie = &mut Allocator::new_codec_data();
        self.gnb_cu_ue_f1ap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 40, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.gnb_du_ue_f1ap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 41, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        if let Some(x) = &self.criticality_diagnostics {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 7, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.recommended_ss_bs_for_paging_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 743, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        encode::encode_sequence_header(data, true, &BitString::new(), false)?;
        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for UeContextReleaseComplete {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        UeContextReleaseComplete::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UeContextReleaseComplete");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UeContextReleaseComplete");
            e
        })
    }
}
// UeContextModificationRequest
#[derive(Clone, Debug)]
pub struct UeContextModificationRequest {
    pub gnb_cu_ue_f1ap_id: GnbCuUeF1apId,
    pub gnb_du_ue_f1ap_id: GnbDuUeF1apId,
    pub sp_cell_id: Option<NrCgi>,
    pub serv_cell_index: Option<ServCellIndex>,
    pub sp_cell_ul_configured: Option<CellUlConfigured>,
    pub drx_cycle: Option<DrxCycle>,
    pub cu_to_du_rrc_information: Option<CuToDuRrcInformation>,
    pub transmission_action_indicator: Option<TransmissionActionIndicator>,
    pub resource_coordination_transfer_container: Option<ResourceCoordinationTransferContainer>,
    pub rrc_reconfiguration_complete_indicator: Option<RrcReconfigurationCompleteIndicator>,
    pub rrc_container: Option<RrcContainer>,
    pub s_cell_to_be_setup_mod_list: Option<SCellToBeSetupModList>,
    pub s_cell_to_be_removed_list: Option<SCellToBeRemovedList>,
    pub srbs_to_be_setup_mod_list: Option<SrbsToBeSetupModList>,
    pub drbs_to_be_setup_mod_list: Option<DrbsToBeSetupModList>,
    pub drbs_to_be_modified_list: Option<DrbsToBeModifiedList>,
    pub srbs_to_be_released_list: Option<SrbsToBeReleasedList>,
    pub drbs_to_be_released_list: Option<DrbsToBeReleasedList>,
    pub inactivity_monitoring_request: Option<InactivityMonitoringRequest>,
    pub rat_frequency_priority_information: Option<RatFrequencyPriorityInformation>,
    pub drx_configuration_indicator: Option<DrxConfigurationIndicator>,
    pub rlc_failure_indication: Option<RlcFailureIndication>,
    pub uplink_tx_direct_current_list_information: Option<UplinkTxDirectCurrentListInformation>,
    pub gnb_du_configuration_query: Option<GnbDuConfigurationQuery>,
    pub gnb_du_ue_ambr_ul: Option<BitRate>,
    pub execute_duplication: Option<ExecuteDuplication>,
    pub rrc_delivery_status_request: Option<RrcDeliveryStatusRequest>,
    pub resource_coordination_transfer_information: Option<ResourceCoordinationTransferInformation>,
    pub serving_cell_mo: Option<ServingCellMo>,
    pub needfor_gap: Option<NeedforGap>,
    pub full_configuration: Option<FullConfiguration>,
    pub additional_rrm_priority_index: Option<AdditionalRrmPriorityIndex>,
    pub lower_layer_presence_status_change: Option<LowerLayerPresenceStatusChange>,
    pub bh_channels_to_be_setup_mod_list: Option<BhChannelsToBeSetupModList>,
    pub bh_channels_to_be_modified_list: Option<BhChannelsToBeModifiedList>,
    pub bh_channels_to_be_released_list: Option<BhChannelsToBeReleasedList>,
    pub nr_v2x_services_authorized: Option<NrV2xServicesAuthorized>,
    pub ltev2x_services_authorized: Option<Ltev2xServicesAuthorized>,
    pub nr_ue_sidelink_aggregate_maximum_bitrate: Option<NrUeSidelinkAggregateMaximumBitrate>,
    pub lte_ue_sidelink_aggregate_maximum_bitrate: Option<LteUeSidelinkAggregateMaximumBitrate>,
    pub pc5_link_ambr: Option<BitRate>,
    pub sl_drbs_to_be_setup_mod_list: Option<SlDrbsToBeSetupModList>,
    pub sl_drbs_to_be_modified_list: Option<SlDrbsToBeModifiedList>,
    pub sl_drbs_to_be_released_list: Option<SlDrbsToBeReleasedList>,
    pub conditional_intra_du_mobility_information: Option<ConditionalIntraDuMobilityInformation>,
    pub f1c_transfer_path: Option<F1cTransferPath>,
    pub scg_indicator: Option<ScgIndicator>,
    pub uplink_tx_direct_current_two_carrier_list_info:
        Option<UplinkTxDirectCurrentTwoCarrierListInfo>,
    pub iab_conditional_rrc_message_delivery_indication:
        Option<IabConditionalRrcMessageDeliveryIndication>,
    pub f1c_transfer_path_nr_dc: Option<F1cTransferPathNrDc>,
    pub mdt_polluted_measurement_indicator: Option<MdtPollutedMeasurementIndicator>,
    pub scg_activation_request: Option<ScgActivationRequest>,
    pub cg_sdt_query_indication: Option<CgSdtQueryIndication>,
    pub five_g_pro_se_authorized: Option<FiveGProSeAuthorized>,
    pub five_g_pro_se_ue_pc5_aggregate_maximum_bitrate: Option<NrUeSidelinkAggregateMaximumBitrate>,
    pub five_g_pro_se_pc5_link_ambr: Option<BitRate>,
    pub updated_remote_ue_local_id: Option<RemoteUeLocalId>,
    pub uu_rlc_channel_to_be_setup_list: Option<UuRlcChannelToBeSetupList>,
    pub uu_rlc_channel_to_be_modified_list: Option<UuRlcChannelToBeModifiedList>,
    pub uu_rlc_channel_to_be_released_list: Option<UuRlcChannelToBeReleasedList>,
    pub pc5rlc_channel_to_be_setup_list: Option<Pc5rlcChannelToBeSetupList>,
    pub pc5rlc_channel_to_be_modified_list: Option<Pc5rlcChannelToBeModifiedList>,
    pub pc5rlc_channel_to_be_released_list: Option<Pc5rlcChannelToBeReleasedList>,
    pub path_switch_configuration: Option<PathSwitchConfiguration>,
    pub gnb_du_ue_slice_maximum_bit_rate_list: Option<GnbDuUeSliceMaximumBitRateList>,
    pub multicast_mbs_session_setup_list: Option<MulticastMbsSessionList>,
    pub multicast_mbs_session_remove_list: Option<MulticastMbsSessionList>,
    pub ue_multicast_mr_bs_to_be_setup_at_modify_list: Option<UeMulticastMrBsToBeSetupAtModifyList>,
    pub ue_multicast_mr_bs_to_be_released_list: Option<UeMulticastMrBsToBeReleasedList>,
    pub sldrx_cycle_list: Option<SldrxCycleList>,
    pub management_based_mdt_plmn_modification_list: Option<MdtPlmnModificationList>,
    pub sdt_bearer_configuration_query_indication: Option<SdtBearerConfigurationQueryIndication>,
    pub daps_ho_status: Option<DapsHoStatus>,
    pub serving_cell_mo_list: Option<ServingCellMoList>,
    pub ul_tx_direct_current_more_carrier_information:
        Option<UlTxDirectCurrentMoreCarrierInformation>,
    pub cpacmcg_information: Option<CpacmcgInformation>,
    pub network_controlled_repeater_authorized: Option<NetworkControlledRepeaterAuthorized>,
    pub sdt_volume_threshold: Option<SdtVolumeThreshold>,
    pub ltm_information_modify: Option<LtmInformationModify>,
    pub ltmcfra_resource_config_list: Option<LtmcfraResourceConfigList>,
    pub ltm_configuration_id_mapping_list: Option<LtmConfigurationIdMappingList>,
    pub early_sync_information_request: Option<EarlySyncInformationRequest>,
    pub early_sync_candidate_cell_information_list: Option<EarlySyncCandidateCellInformationList>,
    pub early_sync_serving_cell_information: Option<EarlySyncServingCellInformation>,
    pub ltm_cells_to_be_released_list: Option<LtmCellsToBeReleasedList>,
    pub path_addition_information: Option<PathAdditionInformation>,
    pub nr_a2x_services_authorized: Option<NrA2xServicesAuthorized>,
    pub ltea2x_services_authorized: Option<Ltea2xServicesAuthorized>,
    pub nr_ue_sidelink_aggregate_maximum_bitrate_for_a2x:
        Option<NrUeSidelinkAggregateMaximumBitrate>,
    pub lte_ue_sidelink_aggregate_maximum_bitrate_for_a2x:
        Option<LteUeSidelinkAggregateMaximumBitrate>,
    pub dllbt_failure_information_request: Option<DllbtFailureInformationRequest>,
    pub sl_positioning_ranging_service_info: Option<SlPositioningRangingServiceInfo>,
    pub non_integer_drx_cycle: Option<NonIntegerDrxCycle>,
    pub ltm_reset_information: Option<LtmResetInformation>,
}

impl UeContextModificationRequest {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let _ = decode::decode_sequence_header(data, true, 0)?;
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut gnb_cu_ue_f1ap_id: Option<GnbCuUeF1apId> = None;
        let mut gnb_du_ue_f1ap_id: Option<GnbDuUeF1apId> = None;
        let mut sp_cell_id: Option<NrCgi> = None;
        let mut serv_cell_index: Option<ServCellIndex> = None;
        let mut sp_cell_ul_configured: Option<CellUlConfigured> = None;
        let mut drx_cycle: Option<DrxCycle> = None;
        let mut cu_to_du_rrc_information: Option<CuToDuRrcInformation> = None;
        let mut transmission_action_indicator: Option<TransmissionActionIndicator> = None;
        let mut resource_coordination_transfer_container: Option<
            ResourceCoordinationTransferContainer,
        > = None;
        let mut rrc_reconfiguration_complete_indicator: Option<
            RrcReconfigurationCompleteIndicator,
        > = None;
        let mut rrc_container: Option<RrcContainer> = None;
        let mut s_cell_to_be_setup_mod_list: Option<SCellToBeSetupModList> = None;
        let mut s_cell_to_be_removed_list: Option<SCellToBeRemovedList> = None;
        let mut srbs_to_be_setup_mod_list: Option<SrbsToBeSetupModList> = None;
        let mut drbs_to_be_setup_mod_list: Option<DrbsToBeSetupModList> = None;
        let mut drbs_to_be_modified_list: Option<DrbsToBeModifiedList> = None;
        let mut srbs_to_be_released_list: Option<SrbsToBeReleasedList> = None;
        let mut drbs_to_be_released_list: Option<DrbsToBeReleasedList> = None;
        let mut inactivity_monitoring_request: Option<InactivityMonitoringRequest> = None;
        let mut rat_frequency_priority_information: Option<RatFrequencyPriorityInformation> = None;
        let mut drx_configuration_indicator: Option<DrxConfigurationIndicator> = None;
        let mut rlc_failure_indication: Option<RlcFailureIndication> = None;
        let mut uplink_tx_direct_current_list_information: Option<
            UplinkTxDirectCurrentListInformation,
        > = None;
        let mut gnb_du_configuration_query: Option<GnbDuConfigurationQuery> = None;
        let mut gnb_du_ue_ambr_ul: Option<BitRate> = None;
        let mut execute_duplication: Option<ExecuteDuplication> = None;
        let mut rrc_delivery_status_request: Option<RrcDeliveryStatusRequest> = None;
        let mut resource_coordination_transfer_information: Option<
            ResourceCoordinationTransferInformation,
        > = None;
        let mut serving_cell_mo: Option<ServingCellMo> = None;
        let mut needfor_gap: Option<NeedforGap> = None;
        let mut full_configuration: Option<FullConfiguration> = None;
        let mut additional_rrm_priority_index: Option<AdditionalRrmPriorityIndex> = None;
        let mut lower_layer_presence_status_change: Option<LowerLayerPresenceStatusChange> = None;
        let mut bh_channels_to_be_setup_mod_list: Option<BhChannelsToBeSetupModList> = None;
        let mut bh_channels_to_be_modified_list: Option<BhChannelsToBeModifiedList> = None;
        let mut bh_channels_to_be_released_list: Option<BhChannelsToBeReleasedList> = None;
        let mut nr_v2x_services_authorized: Option<NrV2xServicesAuthorized> = None;
        let mut ltev2x_services_authorized: Option<Ltev2xServicesAuthorized> = None;
        let mut nr_ue_sidelink_aggregate_maximum_bitrate: Option<
            NrUeSidelinkAggregateMaximumBitrate,
        > = None;
        let mut lte_ue_sidelink_aggregate_maximum_bitrate: Option<
            LteUeSidelinkAggregateMaximumBitrate,
        > = None;
        let mut pc5_link_ambr: Option<BitRate> = None;
        let mut sl_drbs_to_be_setup_mod_list: Option<SlDrbsToBeSetupModList> = None;
        let mut sl_drbs_to_be_modified_list: Option<SlDrbsToBeModifiedList> = None;
        let mut sl_drbs_to_be_released_list: Option<SlDrbsToBeReleasedList> = None;
        let mut conditional_intra_du_mobility_information: Option<
            ConditionalIntraDuMobilityInformation,
        > = None;
        let mut f1c_transfer_path: Option<F1cTransferPath> = None;
        let mut scg_indicator: Option<ScgIndicator> = None;
        let mut uplink_tx_direct_current_two_carrier_list_info: Option<
            UplinkTxDirectCurrentTwoCarrierListInfo,
        > = None;
        let mut iab_conditional_rrc_message_delivery_indication: Option<
            IabConditionalRrcMessageDeliveryIndication,
        > = None;
        let mut f1c_transfer_path_nr_dc: Option<F1cTransferPathNrDc> = None;
        let mut mdt_polluted_measurement_indicator: Option<MdtPollutedMeasurementIndicator> = None;
        let mut scg_activation_request: Option<ScgActivationRequest> = None;
        let mut cg_sdt_query_indication: Option<CgSdtQueryIndication> = None;
        let mut five_g_pro_se_authorized: Option<FiveGProSeAuthorized> = None;
        let mut five_g_pro_se_ue_pc5_aggregate_maximum_bitrate: Option<
            NrUeSidelinkAggregateMaximumBitrate,
        > = None;
        let mut five_g_pro_se_pc5_link_ambr: Option<BitRate> = None;
        let mut updated_remote_ue_local_id: Option<RemoteUeLocalId> = None;
        let mut uu_rlc_channel_to_be_setup_list: Option<UuRlcChannelToBeSetupList> = None;
        let mut uu_rlc_channel_to_be_modified_list: Option<UuRlcChannelToBeModifiedList> = None;
        let mut uu_rlc_channel_to_be_released_list: Option<UuRlcChannelToBeReleasedList> = None;
        let mut pc5rlc_channel_to_be_setup_list: Option<Pc5rlcChannelToBeSetupList> = None;
        let mut pc5rlc_channel_to_be_modified_list: Option<Pc5rlcChannelToBeModifiedList> = None;
        let mut pc5rlc_channel_to_be_released_list: Option<Pc5rlcChannelToBeReleasedList> = None;
        let mut path_switch_configuration: Option<PathSwitchConfiguration> = None;
        let mut gnb_du_ue_slice_maximum_bit_rate_list: Option<GnbDuUeSliceMaximumBitRateList> =
            None;
        let mut multicast_mbs_session_setup_list: Option<MulticastMbsSessionList> = None;
        let mut multicast_mbs_session_remove_list: Option<MulticastMbsSessionList> = None;
        let mut ue_multicast_mr_bs_to_be_setup_at_modify_list: Option<
            UeMulticastMrBsToBeSetupAtModifyList,
        > = None;
        let mut ue_multicast_mr_bs_to_be_released_list: Option<UeMulticastMrBsToBeReleasedList> =
            None;
        let mut sldrx_cycle_list: Option<SldrxCycleList> = None;
        let mut management_based_mdt_plmn_modification_list: Option<MdtPlmnModificationList> = None;
        let mut sdt_bearer_configuration_query_indication: Option<
            SdtBearerConfigurationQueryIndication,
        > = None;
        let mut daps_ho_status: Option<DapsHoStatus> = None;
        let mut serving_cell_mo_list: Option<ServingCellMoList> = None;
        let mut ul_tx_direct_current_more_carrier_information: Option<
            UlTxDirectCurrentMoreCarrierInformation,
        > = None;
        let mut cpacmcg_information: Option<CpacmcgInformation> = None;
        let mut network_controlled_repeater_authorized: Option<
            NetworkControlledRepeaterAuthorized,
        > = None;
        let mut sdt_volume_threshold: Option<SdtVolumeThreshold> = None;
        let mut ltm_information_modify: Option<LtmInformationModify> = None;
        let mut ltmcfra_resource_config_list: Option<LtmcfraResourceConfigList> = None;
        let mut ltm_configuration_id_mapping_list: Option<LtmConfigurationIdMappingList> = None;
        let mut early_sync_information_request: Option<EarlySyncInformationRequest> = None;
        let mut early_sync_candidate_cell_information_list: Option<
            EarlySyncCandidateCellInformationList,
        > = None;
        let mut early_sync_serving_cell_information: Option<EarlySyncServingCellInformation> = None;
        let mut ltm_cells_to_be_released_list: Option<LtmCellsToBeReleasedList> = None;
        let mut path_addition_information: Option<PathAdditionInformation> = None;
        let mut nr_a2x_services_authorized: Option<NrA2xServicesAuthorized> = None;
        let mut ltea2x_services_authorized: Option<Ltea2xServicesAuthorized> = None;
        let mut nr_ue_sidelink_aggregate_maximum_bitrate_for_a2x: Option<
            NrUeSidelinkAggregateMaximumBitrate,
        > = None;
        let mut lte_ue_sidelink_aggregate_maximum_bitrate_for_a2x: Option<
            LteUeSidelinkAggregateMaximumBitrate,
        > = None;
        let mut dllbt_failure_information_request: Option<DllbtFailureInformationRequest> = None;
        let mut sl_positioning_ranging_service_info: Option<SlPositioningRangingServiceInfo> = None;
        let mut non_integer_drx_cycle: Option<NonIntegerDrxCycle> = None;
        let mut ltm_reset_information: Option<LtmResetInformation> = None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                40 => gnb_cu_ue_f1ap_id = Some(GnbCuUeF1apId::decode(data)?),
                41 => gnb_du_ue_f1ap_id = Some(GnbDuUeF1apId::decode(data)?),
                63 => sp_cell_id = Some(NrCgi::decode(data)?),
                107 => serv_cell_index = Some(ServCellIndex::decode(data)?),
                96 => sp_cell_ul_configured = Some(CellUlConfigured::decode(data)?),
                38 => drx_cycle = Some(DrxCycle::decode(data)?),
                9 => cu_to_du_rrc_information = Some(CuToDuRrcInformation::decode(data)?),
                79 => {
                    transmission_action_indicator = Some(TransmissionActionIndicator::decode(data)?)
                }
                49 => {
                    resource_coordination_transfer_container =
                        Some(ResourceCoordinationTransferContainer::decode(data)?)
                }
                87 => {
                    rrc_reconfiguration_complete_indicator =
                        Some(RrcReconfigurationCompleteIndicator::decode(data)?)
                }
                50 => rrc_container = Some(RrcContainer::decode(data)?),
                56 => s_cell_to_be_setup_mod_list = Some(SCellToBeSetupModList::decode(data)?),
                52 => s_cell_to_be_removed_list = Some(SCellToBeRemovedList::decode(data)?),
                76 => srbs_to_be_setup_mod_list = Some(SrbsToBeSetupModList::decode(data)?),
                37 => drbs_to_be_setup_mod_list = Some(DrbsToBeSetupModList::decode(data)?),
                31 => drbs_to_be_modified_list = Some(DrbsToBeModifiedList::decode(data)?),
                72 => srbs_to_be_released_list = Some(SrbsToBeReleasedList::decode(data)?),
                33 => drbs_to_be_released_list = Some(DrbsToBeReleasedList::decode(data)?),
                97 => {
                    inactivity_monitoring_request = Some(InactivityMonitoringRequest::decode(data)?)
                }
                108 => {
                    rat_frequency_priority_information =
                        Some(RatFrequencyPriorityInformation::decode(data)?)
                }
                159 => drx_configuration_indicator = Some(DrxConfigurationIndicator::decode(data)?),
                174 => rlc_failure_indication = Some(RlcFailureIndication::decode(data)?),
                175 => {
                    uplink_tx_direct_current_list_information =
                        Some(UplinkTxDirectCurrentListInformation::decode(data)?)
                }
                162 => gnb_du_configuration_query = Some(GnbDuConfigurationQuery::decode(data)?),
                158 => gnb_du_ue_ambr_ul = Some(BitRate::decode(data)?),
                109 => execute_duplication = Some(ExecuteDuplication::decode(data)?),
                184 => rrc_delivery_status_request = Some(RrcDeliveryStatusRequest::decode(data)?),
                195 => {
                    resource_coordination_transfer_information =
                        Some(ResourceCoordinationTransferInformation::decode(data)?)
                }
                182 => serving_cell_mo = Some(ServingCellMo::decode(data)?),
                215 => needfor_gap = Some(NeedforGap::decode(data)?),
                94 => full_configuration = Some(FullConfiguration::decode(data)?),
                248 => {
                    additional_rrm_priority_index = Some(AdditionalRrmPriorityIndex::decode(data)?)
                }
                253 => {
                    lower_layer_presence_status_change =
                        Some(LowerLayerPresenceStatusChange::decode(data)?)
                }
                267 => {
                    bh_channels_to_be_setup_mod_list =
                        Some(BhChannelsToBeSetupModList::decode(data)?)
                }
                263 => {
                    bh_channels_to_be_modified_list =
                        Some(BhChannelsToBeModifiedList::decode(data)?)
                }
                265 => {
                    bh_channels_to_be_released_list =
                        Some(BhChannelsToBeReleasedList::decode(data)?)
                }
                306 => nr_v2x_services_authorized = Some(NrV2xServicesAuthorized::decode(data)?),
                307 => ltev2x_services_authorized = Some(Ltev2xServicesAuthorized::decode(data)?),
                308 => {
                    nr_ue_sidelink_aggregate_maximum_bitrate =
                        Some(NrUeSidelinkAggregateMaximumBitrate::decode(data)?)
                }
                309 => {
                    lte_ue_sidelink_aggregate_maximum_bitrate =
                        Some(LteUeSidelinkAggregateMaximumBitrate::decode(data)?)
                }
                340 => pc5_link_ambr = Some(BitRate::decode(data)?),
                332 => sl_drbs_to_be_setup_mod_list = Some(SlDrbsToBeSetupModList::decode(data)?),
                326 => sl_drbs_to_be_modified_list = Some(SlDrbsToBeModifiedList::decode(data)?),
                328 => sl_drbs_to_be_released_list = Some(SlDrbsToBeReleasedList::decode(data)?),
                374 => {
                    conditional_intra_du_mobility_information =
                        Some(ConditionalIntraDuMobilityInformation::decode(data)?)
                }
                428 => f1c_transfer_path = Some(F1cTransferPath::decode(data)?),
                432 => scg_indicator = Some(ScgIndicator::decode(data)?),
                684 => {
                    uplink_tx_direct_current_two_carrier_list_info =
                        Some(UplinkTxDirectCurrentTwoCarrierListInfo::decode(data)?)
                }
                510 => {
                    iab_conditional_rrc_message_delivery_indication =
                        Some(IabConditionalRrcMessageDeliveryIndication::decode(data)?)
                }
                511 => f1c_transfer_path_nr_dc = Some(F1cTransferPathNrDc::decode(data)?),
                536 => {
                    mdt_polluted_measurement_indicator =
                        Some(MdtPollutedMeasurementIndicator::decode(data)?)
                }
                547 => scg_activation_request = Some(ScgActivationRequest::decode(data)?),
                586 => cg_sdt_query_indication = Some(CgSdtQueryIndication::decode(data)?),
                594 => five_g_pro_se_authorized = Some(FiveGProSeAuthorized::decode(data)?),
                595 => {
                    five_g_pro_se_ue_pc5_aggregate_maximum_bitrate =
                        Some(NrUeSidelinkAggregateMaximumBitrate::decode(data)?)
                }
                596 => five_g_pro_se_pc5_link_ambr = Some(BitRate::decode(data)?),
                618 => updated_remote_ue_local_id = Some(RemoteUeLocalId::decode(data)?),
                599 => {
                    uu_rlc_channel_to_be_setup_list = Some(UuRlcChannelToBeSetupList::decode(data)?)
                }
                600 => {
                    uu_rlc_channel_to_be_modified_list =
                        Some(UuRlcChannelToBeModifiedList::decode(data)?)
                }
                601 => {
                    uu_rlc_channel_to_be_released_list =
                        Some(UuRlcChannelToBeReleasedList::decode(data)?)
                }
                608 => {
                    pc5rlc_channel_to_be_setup_list =
                        Some(Pc5rlcChannelToBeSetupList::decode(data)?)
                }
                609 => {
                    pc5rlc_channel_to_be_modified_list =
                        Some(Pc5rlcChannelToBeModifiedList::decode(data)?)
                }
                610 => {
                    pc5rlc_channel_to_be_released_list =
                        Some(Pc5rlcChannelToBeReleasedList::decode(data)?)
                }
                619 => path_switch_configuration = Some(PathSwitchConfiguration::decode(data)?),
                626 => {
                    gnb_du_ue_slice_maximum_bit_rate_list =
                        Some(GnbDuUeSliceMaximumBitRateList::decode(data)?)
                }
                632 => {
                    multicast_mbs_session_setup_list = Some(MulticastMbsSessionList::decode(data)?)
                }
                633 => {
                    multicast_mbs_session_remove_list = Some(MulticastMbsSessionList::decode(data)?)
                }
                685 => {
                    ue_multicast_mr_bs_to_be_setup_at_modify_list =
                        Some(UeMulticastMrBsToBeSetupAtModifyList::decode(data)?)
                }
                628 => {
                    ue_multicast_mr_bs_to_be_released_list =
                        Some(UeMulticastMrBsToBeReleasedList::decode(data)?)
                }
                643 => sldrx_cycle_list = Some(SldrxCycleList::decode(data)?),
                647 => {
                    management_based_mdt_plmn_modification_list =
                        Some(MdtPlmnModificationList::decode(data)?)
                }
                675 => {
                    sdt_bearer_configuration_query_indication =
                        Some(SdtBearerConfigurationQueryIndication::decode(data)?)
                }
                683 => daps_ho_status = Some(DapsHoStatus::decode(data)?),
                695 => serving_cell_mo_list = Some(ServingCellMoList::decode(data)?),
                690 => {
                    ul_tx_direct_current_more_carrier_information =
                        Some(UlTxDirectCurrentMoreCarrierInformation::decode(data)?)
                }
                691 => cpacmcg_information = Some(CpacmcgInformation::decode(data)?),
                712 => {
                    network_controlled_repeater_authorized =
                        Some(NetworkControlledRepeaterAuthorized::decode(data)?)
                }
                716 => sdt_volume_threshold = Some(SdtVolumeThreshold::decode(data)?),
                722 => ltm_information_modify = Some(LtmInformationModify::decode(data)?),
                845 => {
                    ltmcfra_resource_config_list = Some(LtmcfraResourceConfigList::decode(data)?)
                }
                721 => {
                    ltm_configuration_id_mapping_list =
                        Some(LtmConfigurationIdMappingList::decode(data)?)
                }
                726 => {
                    early_sync_information_request =
                        Some(EarlySyncInformationRequest::decode(data)?)
                }
                728 => {
                    early_sync_candidate_cell_information_list =
                        Some(EarlySyncCandidateCellInformationList::decode(data)?)
                }
                843 => {
                    early_sync_serving_cell_information =
                        Some(EarlySyncServingCellInformation::decode(data)?)
                }
                723 => {
                    ltm_cells_to_be_released_list = Some(LtmCellsToBeReleasedList::decode(data)?)
                }
                741 => path_addition_information = Some(PathAdditionInformation::decode(data)?),
                779 => nr_a2x_services_authorized = Some(NrA2xServicesAuthorized::decode(data)?),
                780 => ltea2x_services_authorized = Some(Ltea2xServicesAuthorized::decode(data)?),
                781 => {
                    nr_ue_sidelink_aggregate_maximum_bitrate_for_a2x =
                        Some(NrUeSidelinkAggregateMaximumBitrate::decode(data)?)
                }
                782 => {
                    lte_ue_sidelink_aggregate_maximum_bitrate_for_a2x =
                        Some(LteUeSidelinkAggregateMaximumBitrate::decode(data)?)
                }
                794 => {
                    dllbt_failure_information_request =
                        Some(DllbtFailureInformationRequest::decode(data)?)
                }
                801 => {
                    sl_positioning_ranging_service_info =
                        Some(SlPositioningRangingServiceInfo::decode(data)?)
                }
                838 => non_integer_drx_cycle = Some(NonIntegerDrxCycle::decode(data)?),
                855 => ltm_reset_information = Some(LtmResetInformation::decode(data)?),
                x => return Err(per_codec_error_new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        let gnb_cu_ue_f1ap_id = gnb_cu_ue_f1ap_id.ok_or(per_codec_error_new(format!(
            "Missing mandatory IE gnb_cu_ue_f1ap_id"
        )))?;
        let gnb_du_ue_f1ap_id = gnb_du_ue_f1ap_id.ok_or(per_codec_error_new(format!(
            "Missing mandatory IE gnb_du_ue_f1ap_id"
        )))?;
        Ok(Self {
            gnb_cu_ue_f1ap_id,
            gnb_du_ue_f1ap_id,
            sp_cell_id,
            serv_cell_index,
            sp_cell_ul_configured,
            drx_cycle,
            cu_to_du_rrc_information,
            transmission_action_indicator,
            resource_coordination_transfer_container,
            rrc_reconfiguration_complete_indicator,
            rrc_container,
            s_cell_to_be_setup_mod_list,
            s_cell_to_be_removed_list,
            srbs_to_be_setup_mod_list,
            drbs_to_be_setup_mod_list,
            drbs_to_be_modified_list,
            srbs_to_be_released_list,
            drbs_to_be_released_list,
            inactivity_monitoring_request,
            rat_frequency_priority_information,
            drx_configuration_indicator,
            rlc_failure_indication,
            uplink_tx_direct_current_list_information,
            gnb_du_configuration_query,
            gnb_du_ue_ambr_ul,
            execute_duplication,
            rrc_delivery_status_request,
            resource_coordination_transfer_information,
            serving_cell_mo,
            needfor_gap,
            full_configuration,
            additional_rrm_priority_index,
            lower_layer_presence_status_change,
            bh_channels_to_be_setup_mod_list,
            bh_channels_to_be_modified_list,
            bh_channels_to_be_released_list,
            nr_v2x_services_authorized,
            ltev2x_services_authorized,
            nr_ue_sidelink_aggregate_maximum_bitrate,
            lte_ue_sidelink_aggregate_maximum_bitrate,
            pc5_link_ambr,
            sl_drbs_to_be_setup_mod_list,
            sl_drbs_to_be_modified_list,
            sl_drbs_to_be_released_list,
            conditional_intra_du_mobility_information,
            f1c_transfer_path,
            scg_indicator,
            uplink_tx_direct_current_two_carrier_list_info,
            iab_conditional_rrc_message_delivery_indication,
            f1c_transfer_path_nr_dc,
            mdt_polluted_measurement_indicator,
            scg_activation_request,
            cg_sdt_query_indication,
            five_g_pro_se_authorized,
            five_g_pro_se_ue_pc5_aggregate_maximum_bitrate,
            five_g_pro_se_pc5_link_ambr,
            updated_remote_ue_local_id,
            uu_rlc_channel_to_be_setup_list,
            uu_rlc_channel_to_be_modified_list,
            uu_rlc_channel_to_be_released_list,
            pc5rlc_channel_to_be_setup_list,
            pc5rlc_channel_to_be_modified_list,
            pc5rlc_channel_to_be_released_list,
            path_switch_configuration,
            gnb_du_ue_slice_maximum_bit_rate_list,
            multicast_mbs_session_setup_list,
            multicast_mbs_session_remove_list,
            ue_multicast_mr_bs_to_be_setup_at_modify_list,
            ue_multicast_mr_bs_to_be_released_list,
            sldrx_cycle_list,
            management_based_mdt_plmn_modification_list,
            sdt_bearer_configuration_query_indication,
            daps_ho_status,
            serving_cell_mo_list,
            ul_tx_direct_current_more_carrier_information,
            cpacmcg_information,
            network_controlled_repeater_authorized,
            sdt_volume_threshold,
            ltm_information_modify,
            ltmcfra_resource_config_list,
            ltm_configuration_id_mapping_list,
            early_sync_information_request,
            early_sync_candidate_cell_information_list,
            early_sync_serving_cell_information,
            ltm_cells_to_be_released_list,
            path_addition_information,
            nr_a2x_services_authorized,
            ltea2x_services_authorized,
            nr_ue_sidelink_aggregate_maximum_bitrate_for_a2x,
            lte_ue_sidelink_aggregate_maximum_bitrate_for_a2x,
            dllbt_failure_information_request,
            sl_positioning_ranging_service_info,
            non_integer_drx_cycle,
            ltm_reset_information,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        let ie = &mut Allocator::new_codec_data();
        self.gnb_cu_ue_f1ap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 40, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.gnb_du_ue_f1ap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 41, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        if let Some(x) = &self.sp_cell_id {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 63, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.serv_cell_index {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 107, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.sp_cell_ul_configured {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 96, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.drx_cycle {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 38, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.cu_to_du_rrc_information {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 9, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.transmission_action_indicator {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 79, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.resource_coordination_transfer_container {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 49, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.rrc_reconfiguration_complete_indicator {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 87, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.rrc_container {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 50, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.s_cell_to_be_setup_mod_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 56, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.s_cell_to_be_removed_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 52, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.srbs_to_be_setup_mod_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 76, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.drbs_to_be_setup_mod_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 37, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.drbs_to_be_modified_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 31, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.srbs_to_be_released_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 72, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.drbs_to_be_released_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 33, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.inactivity_monitoring_request {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 97, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.rat_frequency_priority_information {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 108, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.drx_configuration_indicator {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 159, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.rlc_failure_indication {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 174, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.uplink_tx_direct_current_list_information {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 175, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.gnb_du_configuration_query {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 162, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.gnb_du_ue_ambr_ul {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 158, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.execute_duplication {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 109, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.rrc_delivery_status_request {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 184, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.resource_coordination_transfer_information {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 195, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.serving_cell_mo {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 182, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.needfor_gap {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 215, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.full_configuration {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 94, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.additional_rrm_priority_index {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 248, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.lower_layer_presence_status_change {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 253, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.bh_channels_to_be_setup_mod_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 267, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.bh_channels_to_be_modified_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 263, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.bh_channels_to_be_released_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 265, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.nr_v2x_services_authorized {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 306, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.ltev2x_services_authorized {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 307, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.nr_ue_sidelink_aggregate_maximum_bitrate {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 308, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.lte_ue_sidelink_aggregate_maximum_bitrate {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 309, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.pc5_link_ambr {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 340, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.sl_drbs_to_be_setup_mod_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 332, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.sl_drbs_to_be_modified_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 326, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.sl_drbs_to_be_released_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 328, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.conditional_intra_du_mobility_information {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 374, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.f1c_transfer_path {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 428, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.scg_indicator {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 432, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.uplink_tx_direct_current_two_carrier_list_info {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 684, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.iab_conditional_rrc_message_delivery_indication {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 510, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.f1c_transfer_path_nr_dc {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 511, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.mdt_polluted_measurement_indicator {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 536, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.scg_activation_request {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 547, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.cg_sdt_query_indication {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 586, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.five_g_pro_se_authorized {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 594, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.five_g_pro_se_ue_pc5_aggregate_maximum_bitrate {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 595, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.five_g_pro_se_pc5_link_ambr {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 596, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.updated_remote_ue_local_id {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 618, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.uu_rlc_channel_to_be_setup_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 599, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.uu_rlc_channel_to_be_modified_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 600, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.uu_rlc_channel_to_be_released_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 601, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.pc5rlc_channel_to_be_setup_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 608, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.pc5rlc_channel_to_be_modified_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 609, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.pc5rlc_channel_to_be_released_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 610, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.path_switch_configuration {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 619, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.gnb_du_ue_slice_maximum_bit_rate_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 626, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.multicast_mbs_session_setup_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 632, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.multicast_mbs_session_remove_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 633, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.ue_multicast_mr_bs_to_be_setup_at_modify_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 685, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.ue_multicast_mr_bs_to_be_released_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 628, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.sldrx_cycle_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 643, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.management_based_mdt_plmn_modification_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 647, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.sdt_bearer_configuration_query_indication {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 675, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.daps_ho_status {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 683, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.serving_cell_mo_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 695, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.ul_tx_direct_current_more_carrier_information {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 690, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.cpacmcg_information {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 691, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.network_controlled_repeater_authorized {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 712, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.sdt_volume_threshold {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 716, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.ltm_information_modify {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 722, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.ltmcfra_resource_config_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 845, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.ltm_configuration_id_mapping_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 721, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.early_sync_information_request {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 726, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.early_sync_candidate_cell_information_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 728, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.early_sync_serving_cell_information {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 843, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.ltm_cells_to_be_released_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 723, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.path_addition_information {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 741, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.nr_a2x_services_authorized {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 779, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.ltea2x_services_authorized {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 780, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.nr_ue_sidelink_aggregate_maximum_bitrate_for_a2x {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 781, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.lte_ue_sidelink_aggregate_maximum_bitrate_for_a2x {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 782, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.dllbt_failure_information_request {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 794, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.sl_positioning_ranging_service_info {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 801, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.non_integer_drx_cycle {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 838, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.ltm_reset_information {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 855, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        encode::encode_sequence_header(data, true, &BitString::new(), false)?;
        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for UeContextModificationRequest {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        UeContextModificationRequest::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UeContextModificationRequest");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UeContextModificationRequest");
            e
        })
    }
}
// SCellToBeSetupModList
#[derive(Clone, Debug)]
pub struct SCellToBeSetupModList(pub NonEmpty<SCellToBeSetupModItem>);

impl SCellToBeSetupModList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(32), false)?;
            let mut items = vec![];
            for _ in 0..length {
                let _ = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _ = Criticality::decode(data)?;
                let _ = decode::decode_length_determinent(data, None, None, false)?;
                items.push(SCellToBeSetupModItem::decode(data)?);
                data.decode_align()?;
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(32), false, self.0.len())?;
        for x in &self.0 {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(data, Some(0), Some(65535), false, 55, false)?;
            Criticality::Ignore.encode(data)?;
            encode::encode_length_determinent(data, None, None, false, ie.length_in_bytes())?;
            data.append_aligned(ie);
        }
        Ok(())
    }
}

impl PerCodec for SCellToBeSetupModList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        SCellToBeSetupModList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SCellToBeSetupModList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SCellToBeSetupModList");
            e
        })
    }
}
// SCellToBeRemovedList
#[derive(Clone, Debug)]
pub struct SCellToBeRemovedList(pub NonEmpty<SCellToBeRemovedItem>);

impl SCellToBeRemovedList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(32), false)?;
            let mut items = vec![];
            for _ in 0..length {
                let _ = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _ = Criticality::decode(data)?;
                let _ = decode::decode_length_determinent(data, None, None, false)?;
                items.push(SCellToBeRemovedItem::decode(data)?);
                data.decode_align()?;
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(32), false, self.0.len())?;
        for x in &self.0 {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(data, Some(0), Some(65535), false, 51, false)?;
            Criticality::Ignore.encode(data)?;
            encode::encode_length_determinent(data, None, None, false, ie.length_in_bytes())?;
            data.append_aligned(ie);
        }
        Ok(())
    }
}

impl PerCodec for SCellToBeRemovedList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        SCellToBeRemovedList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SCellToBeRemovedList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SCellToBeRemovedList");
            e
        })
    }
}
// SrbsToBeSetupModList
#[derive(Clone, Debug)]
pub struct SrbsToBeSetupModList(pub NonEmpty<SrbsToBeSetupModItem>);

impl SrbsToBeSetupModList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(8), false)?;
            let mut items = vec![];
            for _ in 0..length {
                let _ = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _ = Criticality::decode(data)?;
                let _ = decode::decode_length_determinent(data, None, None, false)?;
                items.push(SrbsToBeSetupModItem::decode(data)?);
                data.decode_align()?;
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(8), false, self.0.len())?;
        for x in &self.0 {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(data, Some(0), Some(65535), false, 75, false)?;
            Criticality::Reject.encode(data)?;
            encode::encode_length_determinent(data, None, None, false, ie.length_in_bytes())?;
            data.append_aligned(ie);
        }
        Ok(())
    }
}

impl PerCodec for SrbsToBeSetupModList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        SrbsToBeSetupModList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SrbsToBeSetupModList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SrbsToBeSetupModList");
            e
        })
    }
}
// DrbsToBeSetupModList
#[derive(Clone, Debug)]
pub struct DrbsToBeSetupModList(pub NonEmpty<DrbsToBeSetupModItem>);

impl DrbsToBeSetupModList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(64), false)?;
            let mut items = vec![];
            for _ in 0..length {
                let _ = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _ = Criticality::decode(data)?;
                let _ = decode::decode_length_determinent(data, None, None, false)?;
                items.push(DrbsToBeSetupModItem::decode(data)?);
                data.decode_align()?;
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(64), false, self.0.len())?;
        for x in &self.0 {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(data, Some(0), Some(65535), false, 36, false)?;
            Criticality::Reject.encode(data)?;
            encode::encode_length_determinent(data, None, None, false, ie.length_in_bytes())?;
            data.append_aligned(ie);
        }
        Ok(())
    }
}

impl PerCodec for DrbsToBeSetupModList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        DrbsToBeSetupModList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DrbsToBeSetupModList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DrbsToBeSetupModList");
            e
        })
    }
}
// BhChannelsToBeSetupModList
#[derive(Clone, Debug)]
pub struct BhChannelsToBeSetupModList(pub NonEmpty<BhChannelsToBeSetupModItem>);

impl BhChannelsToBeSetupModList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(65536), false)?;
            let mut items = vec![];
            for _ in 0..length {
                let _ = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _ = Criticality::decode(data)?;
                let _ = decode::decode_length_determinent(data, None, None, false)?;
                items.push(BhChannelsToBeSetupModItem::decode(data)?);
                data.decode_align()?;
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(65536), false, self.0.len())?;
        for x in &self.0 {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(data, Some(0), Some(65535), false, 266, false)?;
            Criticality::Reject.encode(data)?;
            encode::encode_length_determinent(data, None, None, false, ie.length_in_bytes())?;
            data.append_aligned(ie);
        }
        Ok(())
    }
}

impl PerCodec for BhChannelsToBeSetupModList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        BhChannelsToBeSetupModList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("BhChannelsToBeSetupModList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("BhChannelsToBeSetupModList");
            e
        })
    }
}
// DrbsToBeModifiedList
#[derive(Clone, Debug)]
pub struct DrbsToBeModifiedList(pub NonEmpty<DrbsToBeModifiedItem>);

impl DrbsToBeModifiedList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(64), false)?;
            let mut items = vec![];
            for _ in 0..length {
                let _ = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _ = Criticality::decode(data)?;
                let _ = decode::decode_length_determinent(data, None, None, false)?;
                items.push(DrbsToBeModifiedItem::decode(data)?);
                data.decode_align()?;
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(64), false, self.0.len())?;
        for x in &self.0 {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(data, Some(0), Some(65535), false, 30, false)?;
            Criticality::Reject.encode(data)?;
            encode::encode_length_determinent(data, None, None, false, ie.length_in_bytes())?;
            data.append_aligned(ie);
        }
        Ok(())
    }
}

impl PerCodec for DrbsToBeModifiedList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        DrbsToBeModifiedList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DrbsToBeModifiedList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DrbsToBeModifiedList");
            e
        })
    }
}
// BhChannelsToBeModifiedList
#[derive(Clone, Debug)]
pub struct BhChannelsToBeModifiedList(pub NonEmpty<BhChannelsToBeModifiedItem>);

impl BhChannelsToBeModifiedList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(65536), false)?;
            let mut items = vec![];
            for _ in 0..length {
                let _ = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _ = Criticality::decode(data)?;
                let _ = decode::decode_length_determinent(data, None, None, false)?;
                items.push(BhChannelsToBeModifiedItem::decode(data)?);
                data.decode_align()?;
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(65536), false, self.0.len())?;
        for x in &self.0 {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(data, Some(0), Some(65535), false, 262, false)?;
            Criticality::Reject.encode(data)?;
            encode::encode_length_determinent(data, None, None, false, ie.length_in_bytes())?;
            data.append_aligned(ie);
        }
        Ok(())
    }
}

impl PerCodec for BhChannelsToBeModifiedList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        BhChannelsToBeModifiedList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("BhChannelsToBeModifiedList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("BhChannelsToBeModifiedList");
            e
        })
    }
}
// SrbsToBeReleasedList
#[derive(Clone, Debug)]
pub struct SrbsToBeReleasedList(pub NonEmpty<SrbsToBeReleasedItem>);

impl SrbsToBeReleasedList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(8), false)?;
            let mut items = vec![];
            for _ in 0..length {
                let _ = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _ = Criticality::decode(data)?;
                let _ = decode::decode_length_determinent(data, None, None, false)?;
                items.push(SrbsToBeReleasedItem::decode(data)?);
                data.decode_align()?;
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(8), false, self.0.len())?;
        for x in &self.0 {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(data, Some(0), Some(65535), false, 71, false)?;
            Criticality::Reject.encode(data)?;
            encode::encode_length_determinent(data, None, None, false, ie.length_in_bytes())?;
            data.append_aligned(ie);
        }
        Ok(())
    }
}

impl PerCodec for SrbsToBeReleasedList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        SrbsToBeReleasedList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SrbsToBeReleasedList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SrbsToBeReleasedList");
            e
        })
    }
}
// DrbsToBeReleasedList
#[derive(Clone, Debug)]
pub struct DrbsToBeReleasedList(pub NonEmpty<DrbsToBeReleasedItem>);

impl DrbsToBeReleasedList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(64), false)?;
            let mut items = vec![];
            for _ in 0..length {
                let _ = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _ = Criticality::decode(data)?;
                let _ = decode::decode_length_determinent(data, None, None, false)?;
                items.push(DrbsToBeReleasedItem::decode(data)?);
                data.decode_align()?;
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(64), false, self.0.len())?;
        for x in &self.0 {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(data, Some(0), Some(65535), false, 32, false)?;
            Criticality::Reject.encode(data)?;
            encode::encode_length_determinent(data, None, None, false, ie.length_in_bytes())?;
            data.append_aligned(ie);
        }
        Ok(())
    }
}

impl PerCodec for DrbsToBeReleasedList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        DrbsToBeReleasedList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DrbsToBeReleasedList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DrbsToBeReleasedList");
            e
        })
    }
}
// BhChannelsToBeReleasedList
#[derive(Clone, Debug)]
pub struct BhChannelsToBeReleasedList(pub NonEmpty<BhChannelsToBeReleasedItem>);

impl BhChannelsToBeReleasedList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(65536), false)?;
            let mut items = vec![];
            for _ in 0..length {
                let _ = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _ = Criticality::decode(data)?;
                let _ = decode::decode_length_determinent(data, None, None, false)?;
                items.push(BhChannelsToBeReleasedItem::decode(data)?);
                data.decode_align()?;
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(65536), false, self.0.len())?;
        for x in &self.0 {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(data, Some(0), Some(65535), false, 264, false)?;
            Criticality::Reject.encode(data)?;
            encode::encode_length_determinent(data, None, None, false, ie.length_in_bytes())?;
            data.append_aligned(ie);
        }
        Ok(())
    }
}

impl PerCodec for BhChannelsToBeReleasedList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        BhChannelsToBeReleasedList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("BhChannelsToBeReleasedList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("BhChannelsToBeReleasedList");
            e
        })
    }
}
// UeMulticastMrBsToBeSetupAtModifyList
#[derive(Clone, Debug)]
pub struct UeMulticastMrBsToBeSetupAtModifyList(pub NonEmpty<UeMulticastMrBsToBeSetupAtModifyItem>);

impl UeMulticastMrBsToBeSetupAtModifyList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(64), false)?;
            let mut items = vec![];
            for _ in 0..length {
                let _ = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _ = Criticality::decode(data)?;
                let _ = decode::decode_length_determinent(data, None, None, false)?;
                items.push(UeMulticastMrBsToBeSetupAtModifyItem::decode(data)?);
                data.decode_align()?;
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(64), false, self.0.len())?;
        for x in &self.0 {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(data, Some(0), Some(65535), false, 686, false)?;
            Criticality::Reject.encode(data)?;
            encode::encode_length_determinent(data, None, None, false, ie.length_in_bytes())?;
            data.append_aligned(ie);
        }
        Ok(())
    }
}

impl PerCodec for UeMulticastMrBsToBeSetupAtModifyList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        UeMulticastMrBsToBeSetupAtModifyList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UeMulticastMrBsToBeSetupAtModifyList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UeMulticastMrBsToBeSetupAtModifyList");
            e
        })
    }
}
// UeMulticastMrBsToBeReleasedList
#[derive(Clone, Debug)]
pub struct UeMulticastMrBsToBeReleasedList(pub NonEmpty<UeMulticastMrBsToBeReleasedItem>);

impl UeMulticastMrBsToBeReleasedList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(64), false)?;
            let mut items = vec![];
            for _ in 0..length {
                let _ = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _ = Criticality::decode(data)?;
                let _ = decode::decode_length_determinent(data, None, None, false)?;
                items.push(UeMulticastMrBsToBeReleasedItem::decode(data)?);
                data.decode_align()?;
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(64), false, self.0.len())?;
        for x in &self.0 {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(data, Some(0), Some(65535), false, 629, false)?;
            Criticality::Reject.encode(data)?;
            encode::encode_length_determinent(data, None, None, false, ie.length_in_bytes())?;
            data.append_aligned(ie);
        }
        Ok(())
    }
}

impl PerCodec for UeMulticastMrBsToBeReleasedList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        UeMulticastMrBsToBeReleasedList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UeMulticastMrBsToBeReleasedList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UeMulticastMrBsToBeReleasedList");
            e
        })
    }
}
// SlDrbsToBeSetupModList
#[derive(Clone, Debug)]
pub struct SlDrbsToBeSetupModList(pub NonEmpty<SlDrbsToBeSetupModItem>);

impl SlDrbsToBeSetupModList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(512), false)?;
            let mut items = vec![];
            for _ in 0..length {
                let _ = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _ = Criticality::decode(data)?;
                let _ = decode::decode_length_determinent(data, None, None, false)?;
                items.push(SlDrbsToBeSetupModItem::decode(data)?);
                data.decode_align()?;
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(512), false, self.0.len())?;
        for x in &self.0 {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(data, Some(0), Some(65535), false, 331, false)?;
            Criticality::Reject.encode(data)?;
            encode::encode_length_determinent(data, None, None, false, ie.length_in_bytes())?;
            data.append_aligned(ie);
        }
        Ok(())
    }
}

impl PerCodec for SlDrbsToBeSetupModList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        SlDrbsToBeSetupModList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SlDrbsToBeSetupModList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SlDrbsToBeSetupModList");
            e
        })
    }
}
// SlDrbsToBeModifiedList
#[derive(Clone, Debug)]
pub struct SlDrbsToBeModifiedList(pub NonEmpty<SlDrbsToBeModifiedItem>);

impl SlDrbsToBeModifiedList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(512), false)?;
            let mut items = vec![];
            for _ in 0..length {
                let _ = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _ = Criticality::decode(data)?;
                let _ = decode::decode_length_determinent(data, None, None, false)?;
                items.push(SlDrbsToBeModifiedItem::decode(data)?);
                data.decode_align()?;
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(512), false, self.0.len())?;
        for x in &self.0 {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(data, Some(0), Some(65535), false, 325, false)?;
            Criticality::Reject.encode(data)?;
            encode::encode_length_determinent(data, None, None, false, ie.length_in_bytes())?;
            data.append_aligned(ie);
        }
        Ok(())
    }
}

impl PerCodec for SlDrbsToBeModifiedList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        SlDrbsToBeModifiedList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SlDrbsToBeModifiedList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SlDrbsToBeModifiedList");
            e
        })
    }
}
// SlDrbsToBeReleasedList
#[derive(Clone, Debug)]
pub struct SlDrbsToBeReleasedList(pub NonEmpty<SlDrbsToBeReleasedItem>);

impl SlDrbsToBeReleasedList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(512), false)?;
            let mut items = vec![];
            for _ in 0..length {
                let _ = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _ = Criticality::decode(data)?;
                let _ = decode::decode_length_determinent(data, None, None, false)?;
                items.push(SlDrbsToBeReleasedItem::decode(data)?);
                data.decode_align()?;
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(512), false, self.0.len())?;
        for x in &self.0 {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(data, Some(0), Some(65535), false, 327, false)?;
            Criticality::Reject.encode(data)?;
            encode::encode_length_determinent(data, None, None, false, ie.length_in_bytes())?;
            data.append_aligned(ie);
        }
        Ok(())
    }
}

impl PerCodec for SlDrbsToBeReleasedList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        SlDrbsToBeReleasedList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SlDrbsToBeReleasedList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SlDrbsToBeReleasedList");
            e
        })
    }
}
// UeContextModificationResponse
#[derive(Clone, Debug)]
pub struct UeContextModificationResponse {
    pub gnb_cu_ue_f1ap_id: GnbCuUeF1apId,
    pub gnb_du_ue_f1ap_id: GnbDuUeF1apId,
    pub resource_coordination_transfer_container: Option<ResourceCoordinationTransferContainer>,
    pub du_to_cu_rrc_information: Option<DuToCuRrcInformation>,
    pub drbs_setup_mod_list: Option<DrbsSetupModList>,
    pub drbs_modified_list: Option<DrbsModifiedList>,
    pub srbs_failed_to_be_setup_mod_list: Option<SrbsFailedToBeSetupModList>,
    pub drbs_failed_to_be_setup_mod_list: Option<DrbsFailedToBeSetupModList>,
    pub s_cell_failedto_setup_mod_list: Option<SCellFailedtoSetupModList>,
    pub drbs_failed_to_be_modified_list: Option<DrbsFailedToBeModifiedList>,
    pub inactivity_monitoring_response: Option<InactivityMonitoringResponse>,
    pub criticality_diagnostics: Option<CriticalityDiagnostics>,
    pub c_rnti: Option<CRnti>,
    pub associated_s_cell_list: Option<AssociatedSCellList>,
    pub srbs_setup_mod_list: Option<SrbsSetupModList>,
    pub srbs_modified_list: Option<SrbsModifiedList>,
    pub full_configuration: Option<FullConfiguration>,
    pub bh_channels_setup_mod_list: Option<BhChannelsSetupModList>,
    pub bh_channels_modified_list: Option<BhChannelsModifiedList>,
    pub bh_channels_failed_to_be_setup_mod_list: Option<BhChannelsFailedToBeSetupModList>,
    pub bh_channels_failed_to_be_modified_list: Option<BhChannelsFailedToBeModifiedList>,
    pub sl_drbs_setup_mod_list: Option<SlDrbsSetupModList>,
    pub sl_drbs_modified_list: Option<SlDrbsModifiedList>,
    pub sl_drbs_failed_to_be_setup_mod_list: Option<SlDrbsFailedToBeSetupModList>,
    pub sl_drbs_failed_to_be_modified_list: Option<SlDrbsFailedToBeModifiedList>,
    pub requested_target_cell_global_id: Option<NrCgi>,
    pub scg_activation_status: Option<ScgActivationStatus>,
    pub uu_rlc_channel_setup_list: Option<UuRlcChannelSetupList>,
    pub uu_rlc_channel_failed_to_be_setup_list: Option<UuRlcChannelFailedToBeSetupList>,
    pub uu_rlc_channel_modified_list: Option<UuRlcChannelModifiedList>,
    pub uu_rlc_channel_failed_to_be_modified_list: Option<UuRlcChannelFailedToBeModifiedList>,
    pub pc5rlc_channel_setup_list: Option<Pc5rlcChannelSetupList>,
    pub pc5rlc_channel_failed_to_be_setup_list: Option<Pc5rlcChannelFailedToBeSetupList>,
    pub pc5rlc_channel_modified_list: Option<Pc5rlcChannelModifiedList>,
    pub pc5rlc_channel_failed_to_be_modified_list: Option<Pc5rlcChannelFailedToBeModifiedList>,
    pub sdt_bearer_configuration_info: Option<SdtBearerConfigurationInfo>,
    pub ue_multicast_mr_bs_setup_list: Option<UeMulticastMrBsSetupList>,
    pub serving_cell_mo_encoded_in_cgc_list: Option<ServingCellMoEncodedInCgcList>,
    pub dedicated_si_delivery_indication: Option<DedicatedSiDeliveryIndication>,
    pub configured_bwp_list: Option<ConfiguredBwpList>,
    pub early_sync_information: Option<EarlySyncInformation>,
    pub ltm_configuration: Option<LtmConfiguration>,
    pub s_cpac_configuration: Option<SCpacConfiguration>,
}

impl UeContextModificationResponse {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let _ = decode::decode_sequence_header(data, true, 0)?;
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut gnb_cu_ue_f1ap_id: Option<GnbCuUeF1apId> = None;
        let mut gnb_du_ue_f1ap_id: Option<GnbDuUeF1apId> = None;
        let mut resource_coordination_transfer_container: Option<
            ResourceCoordinationTransferContainer,
        > = None;
        let mut du_to_cu_rrc_information: Option<DuToCuRrcInformation> = None;
        let mut drbs_setup_mod_list: Option<DrbsSetupModList> = None;
        let mut drbs_modified_list: Option<DrbsModifiedList> = None;
        let mut srbs_failed_to_be_setup_mod_list: Option<SrbsFailedToBeSetupModList> = None;
        let mut drbs_failed_to_be_setup_mod_list: Option<DrbsFailedToBeSetupModList> = None;
        let mut s_cell_failedto_setup_mod_list: Option<SCellFailedtoSetupModList> = None;
        let mut drbs_failed_to_be_modified_list: Option<DrbsFailedToBeModifiedList> = None;
        let mut inactivity_monitoring_response: Option<InactivityMonitoringResponse> = None;
        let mut criticality_diagnostics: Option<CriticalityDiagnostics> = None;
        let mut c_rnti: Option<CRnti> = None;
        let mut associated_s_cell_list: Option<AssociatedSCellList> = None;
        let mut srbs_setup_mod_list: Option<SrbsSetupModList> = None;
        let mut srbs_modified_list: Option<SrbsModifiedList> = None;
        let mut full_configuration: Option<FullConfiguration> = None;
        let mut bh_channels_setup_mod_list: Option<BhChannelsSetupModList> = None;
        let mut bh_channels_modified_list: Option<BhChannelsModifiedList> = None;
        let mut bh_channels_failed_to_be_setup_mod_list: Option<BhChannelsFailedToBeSetupModList> =
            None;
        let mut bh_channels_failed_to_be_modified_list: Option<BhChannelsFailedToBeModifiedList> =
            None;
        let mut sl_drbs_setup_mod_list: Option<SlDrbsSetupModList> = None;
        let mut sl_drbs_modified_list: Option<SlDrbsModifiedList> = None;
        let mut sl_drbs_failed_to_be_setup_mod_list: Option<SlDrbsFailedToBeSetupModList> = None;
        let mut sl_drbs_failed_to_be_modified_list: Option<SlDrbsFailedToBeModifiedList> = None;
        let mut requested_target_cell_global_id: Option<NrCgi> = None;
        let mut scg_activation_status: Option<ScgActivationStatus> = None;
        let mut uu_rlc_channel_setup_list: Option<UuRlcChannelSetupList> = None;
        let mut uu_rlc_channel_failed_to_be_setup_list: Option<UuRlcChannelFailedToBeSetupList> =
            None;
        let mut uu_rlc_channel_modified_list: Option<UuRlcChannelModifiedList> = None;
        let mut uu_rlc_channel_failed_to_be_modified_list: Option<
            UuRlcChannelFailedToBeModifiedList,
        > = None;
        let mut pc5rlc_channel_setup_list: Option<Pc5rlcChannelSetupList> = None;
        let mut pc5rlc_channel_failed_to_be_setup_list: Option<Pc5rlcChannelFailedToBeSetupList> =
            None;
        let mut pc5rlc_channel_modified_list: Option<Pc5rlcChannelModifiedList> = None;
        let mut pc5rlc_channel_failed_to_be_modified_list: Option<
            Pc5rlcChannelFailedToBeModifiedList,
        > = None;
        let mut sdt_bearer_configuration_info: Option<SdtBearerConfigurationInfo> = None;
        let mut ue_multicast_mr_bs_setup_list: Option<UeMulticastMrBsSetupList> = None;
        let mut serving_cell_mo_encoded_in_cgc_list: Option<ServingCellMoEncodedInCgcList> = None;
        let mut dedicated_si_delivery_indication: Option<DedicatedSiDeliveryIndication> = None;
        let mut configured_bwp_list: Option<ConfiguredBwpList> = None;
        let mut early_sync_information: Option<EarlySyncInformation> = None;
        let mut ltm_configuration: Option<LtmConfiguration> = None;
        let mut s_cpac_configuration: Option<SCpacConfiguration> = None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                40 => gnb_cu_ue_f1ap_id = Some(GnbCuUeF1apId::decode(data)?),
                41 => gnb_du_ue_f1ap_id = Some(GnbDuUeF1apId::decode(data)?),
                49 => {
                    resource_coordination_transfer_container =
                        Some(ResourceCoordinationTransferContainer::decode(data)?)
                }
                39 => du_to_cu_rrc_information = Some(DuToCuRrcInformation::decode(data)?),
                29 => drbs_setup_mod_list = Some(DrbsSetupModList::decode(data)?),
                21 => drbs_modified_list = Some(DrbsModifiedList::decode(data)?),
                68 => {
                    srbs_failed_to_be_setup_mod_list =
                        Some(SrbsFailedToBeSetupModList::decode(data)?)
                }
                17 => {
                    drbs_failed_to_be_setup_mod_list =
                        Some(DrbsFailedToBeSetupModList::decode(data)?)
                }
                85 => {
                    s_cell_failedto_setup_mod_list = Some(SCellFailedtoSetupModList::decode(data)?)
                }
                13 => {
                    drbs_failed_to_be_modified_list =
                        Some(DrbsFailedToBeModifiedList::decode(data)?)
                }
                98 => {
                    inactivity_monitoring_response =
                        Some(InactivityMonitoringResponse::decode(data)?)
                }
                7 => criticality_diagnostics = Some(CriticalityDiagnostics::decode(data)?),
                95 => c_rnti = Some(CRnti::decode(data)?),
                198 => associated_s_cell_list = Some(AssociatedSCellList::decode(data)?),
                204 => srbs_setup_mod_list = Some(SrbsSetupModList::decode(data)?),
                206 => srbs_modified_list = Some(SrbsModifiedList::decode(data)?),
                94 => full_configuration = Some(FullConfiguration::decode(data)?),
                275 => bh_channels_setup_mod_list = Some(BhChannelsSetupModList::decode(data)?),
                273 => bh_channels_modified_list = Some(BhChannelsModifiedList::decode(data)?),
                271 => {
                    bh_channels_failed_to_be_setup_mod_list =
                        Some(BhChannelsFailedToBeSetupModList::decode(data)?)
                }
                269 => {
                    bh_channels_failed_to_be_modified_list =
                        Some(BhChannelsFailedToBeModifiedList::decode(data)?)
                }
                333 => sl_drbs_setup_mod_list = Some(SlDrbsSetupModList::decode(data)?),
                318 => sl_drbs_modified_list = Some(SlDrbsModifiedList::decode(data)?),
                334 => {
                    sl_drbs_failed_to_be_setup_mod_list =
                        Some(SlDrbsFailedToBeSetupModList::decode(data)?)
                }
                314 => {
                    sl_drbs_failed_to_be_modified_list =
                        Some(SlDrbsFailedToBeModifiedList::decode(data)?)
                }
                376 => requested_target_cell_global_id = Some(NrCgi::decode(data)?),
                548 => scg_activation_status = Some(ScgActivationStatus::decode(data)?),
                602 => uu_rlc_channel_setup_list = Some(UuRlcChannelSetupList::decode(data)?),
                603 => {
                    uu_rlc_channel_failed_to_be_setup_list =
                        Some(UuRlcChannelFailedToBeSetupList::decode(data)?)
                }
                604 => uu_rlc_channel_modified_list = Some(UuRlcChannelModifiedList::decode(data)?),
                605 => {
                    uu_rlc_channel_failed_to_be_modified_list =
                        Some(UuRlcChannelFailedToBeModifiedList::decode(data)?)
                }
                611 => pc5rlc_channel_setup_list = Some(Pc5rlcChannelSetupList::decode(data)?),
                612 => {
                    pc5rlc_channel_failed_to_be_setup_list =
                        Some(Pc5rlcChannelFailedToBeSetupList::decode(data)?)
                }
                616 => {
                    pc5rlc_channel_modified_list = Some(Pc5rlcChannelModifiedList::decode(data)?)
                }
                613 => {
                    pc5rlc_channel_failed_to_be_modified_list =
                        Some(Pc5rlcChannelFailedToBeModifiedList::decode(data)?)
                }
                676 => {
                    sdt_bearer_configuration_info = Some(SdtBearerConfigurationInfo::decode(data)?)
                }
                679 => {
                    ue_multicast_mr_bs_setup_list = Some(UeMulticastMrBsSetupList::decode(data)?)
                }
                697 => {
                    serving_cell_mo_encoded_in_cgc_list =
                        Some(ServingCellMoEncodedInCgcList::decode(data)?)
                }
                708 => {
                    dedicated_si_delivery_indication =
                        Some(DedicatedSiDeliveryIndication::decode(data)?)
                }
                709 => configured_bwp_list = Some(ConfiguredBwpList::decode(data)?),
                727 => early_sync_information = Some(EarlySyncInformation::decode(data)?),
                725 => ltm_configuration = Some(LtmConfiguration::decode(data)?),
                792 => s_cpac_configuration = Some(SCpacConfiguration::decode(data)?),
                x => return Err(per_codec_error_new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        let gnb_cu_ue_f1ap_id = gnb_cu_ue_f1ap_id.ok_or(per_codec_error_new(format!(
            "Missing mandatory IE gnb_cu_ue_f1ap_id"
        )))?;
        let gnb_du_ue_f1ap_id = gnb_du_ue_f1ap_id.ok_or(per_codec_error_new(format!(
            "Missing mandatory IE gnb_du_ue_f1ap_id"
        )))?;
        Ok(Self {
            gnb_cu_ue_f1ap_id,
            gnb_du_ue_f1ap_id,
            resource_coordination_transfer_container,
            du_to_cu_rrc_information,
            drbs_setup_mod_list,
            drbs_modified_list,
            srbs_failed_to_be_setup_mod_list,
            drbs_failed_to_be_setup_mod_list,
            s_cell_failedto_setup_mod_list,
            drbs_failed_to_be_modified_list,
            inactivity_monitoring_response,
            criticality_diagnostics,
            c_rnti,
            associated_s_cell_list,
            srbs_setup_mod_list,
            srbs_modified_list,
            full_configuration,
            bh_channels_setup_mod_list,
            bh_channels_modified_list,
            bh_channels_failed_to_be_setup_mod_list,
            bh_channels_failed_to_be_modified_list,
            sl_drbs_setup_mod_list,
            sl_drbs_modified_list,
            sl_drbs_failed_to_be_setup_mod_list,
            sl_drbs_failed_to_be_modified_list,
            requested_target_cell_global_id,
            scg_activation_status,
            uu_rlc_channel_setup_list,
            uu_rlc_channel_failed_to_be_setup_list,
            uu_rlc_channel_modified_list,
            uu_rlc_channel_failed_to_be_modified_list,
            pc5rlc_channel_setup_list,
            pc5rlc_channel_failed_to_be_setup_list,
            pc5rlc_channel_modified_list,
            pc5rlc_channel_failed_to_be_modified_list,
            sdt_bearer_configuration_info,
            ue_multicast_mr_bs_setup_list,
            serving_cell_mo_encoded_in_cgc_list,
            dedicated_si_delivery_indication,
            configured_bwp_list,
            early_sync_information,
            ltm_configuration,
            s_cpac_configuration,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        let ie = &mut Allocator::new_codec_data();
        self.gnb_cu_ue_f1ap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 40, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.gnb_du_ue_f1ap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 41, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        if let Some(x) = &self.resource_coordination_transfer_container {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 49, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.du_to_cu_rrc_information {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 39, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.drbs_setup_mod_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 29, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.drbs_modified_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 21, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.srbs_failed_to_be_setup_mod_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 68, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.drbs_failed_to_be_setup_mod_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 17, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.s_cell_failedto_setup_mod_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 85, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.drbs_failed_to_be_modified_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 13, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.inactivity_monitoring_response {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 98, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.criticality_diagnostics {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 7, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.c_rnti {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 95, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.associated_s_cell_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 198, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.srbs_setup_mod_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 204, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.srbs_modified_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 206, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.full_configuration {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 94, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.bh_channels_setup_mod_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 275, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.bh_channels_modified_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 273, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.bh_channels_failed_to_be_setup_mod_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 271, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.bh_channels_failed_to_be_modified_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 269, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.sl_drbs_setup_mod_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 333, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.sl_drbs_modified_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 318, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.sl_drbs_failed_to_be_setup_mod_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 334, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.sl_drbs_failed_to_be_modified_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 314, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.requested_target_cell_global_id {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 376, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.scg_activation_status {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 548, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.uu_rlc_channel_setup_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 602, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.uu_rlc_channel_failed_to_be_setup_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 603, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.uu_rlc_channel_modified_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 604, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.uu_rlc_channel_failed_to_be_modified_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 605, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.pc5rlc_channel_setup_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 611, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.pc5rlc_channel_failed_to_be_setup_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 612, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.pc5rlc_channel_modified_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 616, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.pc5rlc_channel_failed_to_be_modified_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 613, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.sdt_bearer_configuration_info {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 676, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.ue_multicast_mr_bs_setup_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 679, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.serving_cell_mo_encoded_in_cgc_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 697, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.dedicated_si_delivery_indication {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 708, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.configured_bwp_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 709, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.early_sync_information {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 727, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.ltm_configuration {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 725, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.s_cpac_configuration {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 792, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        encode::encode_sequence_header(data, true, &BitString::new(), false)?;
        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for UeContextModificationResponse {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        UeContextModificationResponse::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UeContextModificationResponse");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UeContextModificationResponse");
            e
        })
    }
}
// DrbsSetupModList
#[derive(Clone, Debug)]
pub struct DrbsSetupModList(pub NonEmpty<DrbsSetupModItem>);

impl DrbsSetupModList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(64), false)?;
            let mut items = vec![];
            for _ in 0..length {
                let _ = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _ = Criticality::decode(data)?;
                let _ = decode::decode_length_determinent(data, None, None, false)?;
                items.push(DrbsSetupModItem::decode(data)?);
                data.decode_align()?;
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(64), false, self.0.len())?;
        for x in &self.0 {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(data, Some(0), Some(65535), false, 28, false)?;
            Criticality::Ignore.encode(data)?;
            encode::encode_length_determinent(data, None, None, false, ie.length_in_bytes())?;
            data.append_aligned(ie);
        }
        Ok(())
    }
}

impl PerCodec for DrbsSetupModList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        DrbsSetupModList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DrbsSetupModList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DrbsSetupModList");
            e
        })
    }
}
// DrbsModifiedList
#[derive(Clone, Debug)]
pub struct DrbsModifiedList(pub NonEmpty<DrbsModifiedItem>);

impl DrbsModifiedList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(64), false)?;
            let mut items = vec![];
            for _ in 0..length {
                let _ = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _ = Criticality::decode(data)?;
                let _ = decode::decode_length_determinent(data, None, None, false)?;
                items.push(DrbsModifiedItem::decode(data)?);
                data.decode_align()?;
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(64), false, self.0.len())?;
        for x in &self.0 {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(data, Some(0), Some(65535), false, 20, false)?;
            Criticality::Ignore.encode(data)?;
            encode::encode_length_determinent(data, None, None, false, ie.length_in_bytes())?;
            data.append_aligned(ie);
        }
        Ok(())
    }
}

impl PerCodec for DrbsModifiedList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        DrbsModifiedList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DrbsModifiedList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DrbsModifiedList");
            e
        })
    }
}
// SrbsSetupModList
#[derive(Clone, Debug)]
pub struct SrbsSetupModList(pub NonEmpty<SrbsSetupModItem>);

impl SrbsSetupModList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(8), false)?;
            let mut items = vec![];
            for _ in 0..length {
                let _ = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _ = Criticality::decode(data)?;
                let _ = decode::decode_length_determinent(data, None, None, false)?;
                items.push(SrbsSetupModItem::decode(data)?);
                data.decode_align()?;
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(8), false, self.0.len())?;
        for x in &self.0 {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(data, Some(0), Some(65535), false, 205, false)?;
            Criticality::Ignore.encode(data)?;
            encode::encode_length_determinent(data, None, None, false, ie.length_in_bytes())?;
            data.append_aligned(ie);
        }
        Ok(())
    }
}

impl PerCodec for SrbsSetupModList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        SrbsSetupModList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SrbsSetupModList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SrbsSetupModList");
            e
        })
    }
}
// SrbsModifiedList
#[derive(Clone, Debug)]
pub struct SrbsModifiedList(pub NonEmpty<SrbsModifiedItem>);

impl SrbsModifiedList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(8), false)?;
            let mut items = vec![];
            for _ in 0..length {
                let _ = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _ = Criticality::decode(data)?;
                let _ = decode::decode_length_determinent(data, None, None, false)?;
                items.push(SrbsModifiedItem::decode(data)?);
                data.decode_align()?;
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(8), false, self.0.len())?;
        for x in &self.0 {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(data, Some(0), Some(65535), false, 207, false)?;
            Criticality::Ignore.encode(data)?;
            encode::encode_length_determinent(data, None, None, false, ie.length_in_bytes())?;
            data.append_aligned(ie);
        }
        Ok(())
    }
}

impl PerCodec for SrbsModifiedList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        SrbsModifiedList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SrbsModifiedList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SrbsModifiedList");
            e
        })
    }
}
// DrbsFailedToBeModifiedList
#[derive(Clone, Debug)]
pub struct DrbsFailedToBeModifiedList(pub NonEmpty<DrbsFailedToBeModifiedItem>);

impl DrbsFailedToBeModifiedList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(64), false)?;
            let mut items = vec![];
            for _ in 0..length {
                let _ = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _ = Criticality::decode(data)?;
                let _ = decode::decode_length_determinent(data, None, None, false)?;
                items.push(DrbsFailedToBeModifiedItem::decode(data)?);
                data.decode_align()?;
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(64), false, self.0.len())?;
        for x in &self.0 {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(data, Some(0), Some(65535), false, 12, false)?;
            Criticality::Ignore.encode(data)?;
            encode::encode_length_determinent(data, None, None, false, ie.length_in_bytes())?;
            data.append_aligned(ie);
        }
        Ok(())
    }
}

impl PerCodec for DrbsFailedToBeModifiedList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        DrbsFailedToBeModifiedList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DrbsFailedToBeModifiedList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DrbsFailedToBeModifiedList");
            e
        })
    }
}
// SrbsFailedToBeSetupModList
#[derive(Clone, Debug)]
pub struct SrbsFailedToBeSetupModList(pub NonEmpty<SrbsFailedToBeSetupModItem>);

impl SrbsFailedToBeSetupModList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(8), false)?;
            let mut items = vec![];
            for _ in 0..length {
                let _ = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _ = Criticality::decode(data)?;
                let _ = decode::decode_length_determinent(data, None, None, false)?;
                items.push(SrbsFailedToBeSetupModItem::decode(data)?);
                data.decode_align()?;
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(8), false, self.0.len())?;
        for x in &self.0 {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(data, Some(0), Some(65535), false, 67, false)?;
            Criticality::Ignore.encode(data)?;
            encode::encode_length_determinent(data, None, None, false, ie.length_in_bytes())?;
            data.append_aligned(ie);
        }
        Ok(())
    }
}

impl PerCodec for SrbsFailedToBeSetupModList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        SrbsFailedToBeSetupModList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SrbsFailedToBeSetupModList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SrbsFailedToBeSetupModList");
            e
        })
    }
}
// DrbsFailedToBeSetupModList
#[derive(Clone, Debug)]
pub struct DrbsFailedToBeSetupModList(pub NonEmpty<DrbsFailedToBeSetupModItem>);

impl DrbsFailedToBeSetupModList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(64), false)?;
            let mut items = vec![];
            for _ in 0..length {
                let _ = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _ = Criticality::decode(data)?;
                let _ = decode::decode_length_determinent(data, None, None, false)?;
                items.push(DrbsFailedToBeSetupModItem::decode(data)?);
                data.decode_align()?;
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(64), false, self.0.len())?;
        for x in &self.0 {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(data, Some(0), Some(65535), false, 16, false)?;
            Criticality::Ignore.encode(data)?;
            encode::encode_length_determinent(data, None, None, false, ie.length_in_bytes())?;
            data.append_aligned(ie);
        }
        Ok(())
    }
}

impl PerCodec for DrbsFailedToBeSetupModList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        DrbsFailedToBeSetupModList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DrbsFailedToBeSetupModList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DrbsFailedToBeSetupModList");
            e
        })
    }
}
// SCellFailedtoSetupModList
#[derive(Clone, Debug)]
pub struct SCellFailedtoSetupModList(pub NonEmpty<SCellFailedtoSetupModItem>);

impl SCellFailedtoSetupModList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(32), false)?;
            let mut items = vec![];
            for _ in 0..length {
                let _ = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _ = Criticality::decode(data)?;
                let _ = decode::decode_length_determinent(data, None, None, false)?;
                items.push(SCellFailedtoSetupModItem::decode(data)?);
                data.decode_align()?;
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(32), false, self.0.len())?;
        for x in &self.0 {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(data, Some(0), Some(65535), false, 86, false)?;
            Criticality::Ignore.encode(data)?;
            encode::encode_length_determinent(data, None, None, false, ie.length_in_bytes())?;
            data.append_aligned(ie);
        }
        Ok(())
    }
}

impl PerCodec for SCellFailedtoSetupModList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        SCellFailedtoSetupModList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SCellFailedtoSetupModList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SCellFailedtoSetupModList");
            e
        })
    }
}
// BhChannelsSetupModList
#[derive(Clone, Debug)]
pub struct BhChannelsSetupModList(pub NonEmpty<BhChannelsSetupModItem>);

impl BhChannelsSetupModList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(65536), false)?;
            let mut items = vec![];
            for _ in 0..length {
                let _ = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _ = Criticality::decode(data)?;
                let _ = decode::decode_length_determinent(data, None, None, false)?;
                items.push(BhChannelsSetupModItem::decode(data)?);
                data.decode_align()?;
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(65536), false, self.0.len())?;
        for x in &self.0 {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(data, Some(0), Some(65535), false, 274, false)?;
            Criticality::Ignore.encode(data)?;
            encode::encode_length_determinent(data, None, None, false, ie.length_in_bytes())?;
            data.append_aligned(ie);
        }
        Ok(())
    }
}

impl PerCodec for BhChannelsSetupModList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        BhChannelsSetupModList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("BhChannelsSetupModList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("BhChannelsSetupModList");
            e
        })
    }
}
// BhChannelsModifiedList
#[derive(Clone, Debug)]
pub struct BhChannelsModifiedList(pub NonEmpty<BhChannelsModifiedItem>);

impl BhChannelsModifiedList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(65536), false)?;
            let mut items = vec![];
            for _ in 0..length {
                let _ = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _ = Criticality::decode(data)?;
                let _ = decode::decode_length_determinent(data, None, None, false)?;
                items.push(BhChannelsModifiedItem::decode(data)?);
                data.decode_align()?;
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(65536), false, self.0.len())?;
        for x in &self.0 {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(data, Some(0), Some(65535), false, 272, false)?;
            Criticality::Ignore.encode(data)?;
            encode::encode_length_determinent(data, None, None, false, ie.length_in_bytes())?;
            data.append_aligned(ie);
        }
        Ok(())
    }
}

impl PerCodec for BhChannelsModifiedList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        BhChannelsModifiedList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("BhChannelsModifiedList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("BhChannelsModifiedList");
            e
        })
    }
}
// BhChannelsFailedToBeModifiedList
#[derive(Clone, Debug)]
pub struct BhChannelsFailedToBeModifiedList(pub NonEmpty<BhChannelsFailedToBeModifiedItem>);

impl BhChannelsFailedToBeModifiedList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(65536), false)?;
            let mut items = vec![];
            for _ in 0..length {
                let _ = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _ = Criticality::decode(data)?;
                let _ = decode::decode_length_determinent(data, None, None, false)?;
                items.push(BhChannelsFailedToBeModifiedItem::decode(data)?);
                data.decode_align()?;
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(65536), false, self.0.len())?;
        for x in &self.0 {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(data, Some(0), Some(65535), false, 268, false)?;
            Criticality::Ignore.encode(data)?;
            encode::encode_length_determinent(data, None, None, false, ie.length_in_bytes())?;
            data.append_aligned(ie);
        }
        Ok(())
    }
}

impl PerCodec for BhChannelsFailedToBeModifiedList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        BhChannelsFailedToBeModifiedList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("BhChannelsFailedToBeModifiedList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("BhChannelsFailedToBeModifiedList");
            e
        })
    }
}
// BhChannelsFailedToBeSetupModList
#[derive(Clone, Debug)]
pub struct BhChannelsFailedToBeSetupModList(pub NonEmpty<BhChannelsFailedToBeSetupModItem>);

impl BhChannelsFailedToBeSetupModList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(65536), false)?;
            let mut items = vec![];
            for _ in 0..length {
                let _ = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _ = Criticality::decode(data)?;
                let _ = decode::decode_length_determinent(data, None, None, false)?;
                items.push(BhChannelsFailedToBeSetupModItem::decode(data)?);
                data.decode_align()?;
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(65536), false, self.0.len())?;
        for x in &self.0 {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(data, Some(0), Some(65535), false, 270, false)?;
            Criticality::Ignore.encode(data)?;
            encode::encode_length_determinent(data, None, None, false, ie.length_in_bytes())?;
            data.append_aligned(ie);
        }
        Ok(())
    }
}

impl PerCodec for BhChannelsFailedToBeSetupModList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        BhChannelsFailedToBeSetupModList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("BhChannelsFailedToBeSetupModList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("BhChannelsFailedToBeSetupModList");
            e
        })
    }
}
// AssociatedSCellList
#[derive(Clone, Debug)]
pub struct AssociatedSCellList(pub NonEmpty<AssociatedSCellItem>);

impl AssociatedSCellList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(32), false)?;
            let mut items = vec![];
            for _ in 0..length {
                let _ = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _ = Criticality::decode(data)?;
                let _ = decode::decode_length_determinent(data, None, None, false)?;
                items.push(AssociatedSCellItem::decode(data)?);
                data.decode_align()?;
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(32), false, self.0.len())?;
        for x in &self.0 {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(data, Some(0), Some(65535), false, 200, false)?;
            Criticality::Ignore.encode(data)?;
            encode::encode_length_determinent(data, None, None, false, ie.length_in_bytes())?;
            data.append_aligned(ie);
        }
        Ok(())
    }
}

impl PerCodec for AssociatedSCellList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        AssociatedSCellList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("AssociatedSCellList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("AssociatedSCellList");
            e
        })
    }
}
// SlDrbsSetupModList
#[derive(Clone, Debug)]
pub struct SlDrbsSetupModList(pub NonEmpty<SlDrbsSetupModItem>);

impl SlDrbsSetupModList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(512), false)?;
            let mut items = vec![];
            for _ in 0..length {
                let _ = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _ = Criticality::decode(data)?;
                let _ = decode::decode_length_determinent(data, None, None, false)?;
                items.push(SlDrbsSetupModItem::decode(data)?);
                data.decode_align()?;
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(512), false, self.0.len())?;
        for x in &self.0 {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(data, Some(0), Some(65535), false, 335, false)?;
            Criticality::Ignore.encode(data)?;
            encode::encode_length_determinent(data, None, None, false, ie.length_in_bytes())?;
            data.append_aligned(ie);
        }
        Ok(())
    }
}

impl PerCodec for SlDrbsSetupModList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        SlDrbsSetupModList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SlDrbsSetupModList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SlDrbsSetupModList");
            e
        })
    }
}
// SlDrbsModifiedList
#[derive(Clone, Debug)]
pub struct SlDrbsModifiedList(pub NonEmpty<SlDrbsModifiedItem>);

impl SlDrbsModifiedList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(512), false)?;
            let mut items = vec![];
            for _ in 0..length {
                let _ = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _ = Criticality::decode(data)?;
                let _ = decode::decode_length_determinent(data, None, None, false)?;
                items.push(SlDrbsModifiedItem::decode(data)?);
                data.decode_align()?;
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(512), false, self.0.len())?;
        for x in &self.0 {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(data, Some(0), Some(65535), false, 317, false)?;
            Criticality::Ignore.encode(data)?;
            encode::encode_length_determinent(data, None, None, false, ie.length_in_bytes())?;
            data.append_aligned(ie);
        }
        Ok(())
    }
}

impl PerCodec for SlDrbsModifiedList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        SlDrbsModifiedList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SlDrbsModifiedList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SlDrbsModifiedList");
            e
        })
    }
}
// SlDrbsFailedToBeModifiedList
#[derive(Clone, Debug)]
pub struct SlDrbsFailedToBeModifiedList(pub NonEmpty<SlDrbsFailedToBeModifiedItem>);

impl SlDrbsFailedToBeModifiedList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(512), false)?;
            let mut items = vec![];
            for _ in 0..length {
                let _ = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _ = Criticality::decode(data)?;
                let _ = decode::decode_length_determinent(data, None, None, false)?;
                items.push(SlDrbsFailedToBeModifiedItem::decode(data)?);
                data.decode_align()?;
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(512), false, self.0.len())?;
        for x in &self.0 {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(data, Some(0), Some(65535), false, 313, false)?;
            Criticality::Ignore.encode(data)?;
            encode::encode_length_determinent(data, None, None, false, ie.length_in_bytes())?;
            data.append_aligned(ie);
        }
        Ok(())
    }
}

impl PerCodec for SlDrbsFailedToBeModifiedList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        SlDrbsFailedToBeModifiedList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SlDrbsFailedToBeModifiedList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SlDrbsFailedToBeModifiedList");
            e
        })
    }
}
// SlDrbsFailedToBeSetupModList
#[derive(Clone, Debug)]
pub struct SlDrbsFailedToBeSetupModList(pub NonEmpty<SlDrbsFailedToBeSetupModItem>);

impl SlDrbsFailedToBeSetupModList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(512), false)?;
            let mut items = vec![];
            for _ in 0..length {
                let _ = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _ = Criticality::decode(data)?;
                let _ = decode::decode_length_determinent(data, None, None, false)?;
                items.push(SlDrbsFailedToBeSetupModItem::decode(data)?);
                data.decode_align()?;
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(512), false, self.0.len())?;
        for x in &self.0 {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(data, Some(0), Some(65535), false, 336, false)?;
            Criticality::Ignore.encode(data)?;
            encode::encode_length_determinent(data, None, None, false, ie.length_in_bytes())?;
            data.append_aligned(ie);
        }
        Ok(())
    }
}

impl PerCodec for SlDrbsFailedToBeSetupModList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        SlDrbsFailedToBeSetupModList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SlDrbsFailedToBeSetupModList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SlDrbsFailedToBeSetupModList");
            e
        })
    }
}
// UeMulticastMrBsSetupList
#[derive(Clone, Debug)]
pub struct UeMulticastMrBsSetupList(pub NonEmpty<UeMulticastMrBsSetupItem>);

impl UeMulticastMrBsSetupList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(64), false)?;
            let mut items = vec![];
            for _ in 0..length {
                let _ = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _ = Criticality::decode(data)?;
                let _ = decode::decode_length_determinent(data, None, None, false)?;
                items.push(UeMulticastMrBsSetupItem::decode(data)?);
                data.decode_align()?;
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(64), false, self.0.len())?;
        for x in &self.0 {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(data, Some(0), Some(65535), false, 680, false)?;
            Criticality::Reject.encode(data)?;
            encode::encode_length_determinent(data, None, None, false, ie.length_in_bytes())?;
            data.append_aligned(ie);
        }
        Ok(())
    }
}

impl PerCodec for UeMulticastMrBsSetupList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        UeMulticastMrBsSetupList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UeMulticastMrBsSetupList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UeMulticastMrBsSetupList");
            e
        })
    }
}
// UeContextModificationFailure
#[derive(Clone, Debug)]
pub struct UeContextModificationFailure {
    pub gnb_cu_ue_f1ap_id: GnbCuUeF1apId,
    pub gnb_du_ue_f1ap_id: GnbDuUeF1apId,
    pub cause: Cause,
    pub criticality_diagnostics: Option<CriticalityDiagnostics>,
    pub requested_target_cell_global_id: Option<NrCgi>,
}

impl UeContextModificationFailure {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let _ = decode::decode_sequence_header(data, true, 0)?;
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut gnb_cu_ue_f1ap_id: Option<GnbCuUeF1apId> = None;
        let mut gnb_du_ue_f1ap_id: Option<GnbDuUeF1apId> = None;
        let mut cause: Option<Cause> = None;
        let mut criticality_diagnostics: Option<CriticalityDiagnostics> = None;
        let mut requested_target_cell_global_id: Option<NrCgi> = None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                40 => gnb_cu_ue_f1ap_id = Some(GnbCuUeF1apId::decode(data)?),
                41 => gnb_du_ue_f1ap_id = Some(GnbDuUeF1apId::decode(data)?),
                0 => cause = Some(Cause::decode(data)?),
                7 => criticality_diagnostics = Some(CriticalityDiagnostics::decode(data)?),
                376 => requested_target_cell_global_id = Some(NrCgi::decode(data)?),
                x => return Err(per_codec_error_new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        let gnb_cu_ue_f1ap_id = gnb_cu_ue_f1ap_id.ok_or(per_codec_error_new(format!(
            "Missing mandatory IE gnb_cu_ue_f1ap_id"
        )))?;
        let gnb_du_ue_f1ap_id = gnb_du_ue_f1ap_id.ok_or(per_codec_error_new(format!(
            "Missing mandatory IE gnb_du_ue_f1ap_id"
        )))?;
        let cause = cause.ok_or(per_codec_error_new(format!("Missing mandatory IE cause")))?;
        Ok(Self {
            gnb_cu_ue_f1ap_id,
            gnb_du_ue_f1ap_id,
            cause,
            criticality_diagnostics,
            requested_target_cell_global_id,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        let ie = &mut Allocator::new_codec_data();
        self.gnb_cu_ue_f1ap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 40, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.gnb_du_ue_f1ap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 41, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.cause.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 0, false)?;
        Criticality::Ignore.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        if let Some(x) = &self.criticality_diagnostics {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 7, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.requested_target_cell_global_id {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 376, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        encode::encode_sequence_header(data, true, &BitString::new(), false)?;
        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for UeContextModificationFailure {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        UeContextModificationFailure::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UeContextModificationFailure");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UeContextModificationFailure");
            e
        })
    }
}
// UeContextModificationRequired
#[derive(Clone, Debug)]
pub struct UeContextModificationRequired {
    pub gnb_cu_ue_f1ap_id: GnbCuUeF1apId,
    pub gnb_du_ue_f1ap_id: GnbDuUeF1apId,
    pub resource_coordination_transfer_container: Option<ResourceCoordinationTransferContainer>,
    pub du_to_cu_rrc_information: Option<DuToCuRrcInformation>,
    pub drbs_required_to_be_modified_list: Option<DrbsRequiredToBeModifiedList>,
    pub srbs_required_to_be_released_list: Option<SrbsRequiredToBeReleasedList>,
    pub drbs_required_to_be_released_list: Option<DrbsRequiredToBeReleasedList>,
    pub cause: Cause,
    pub bh_channels_required_to_be_released_list: Option<BhChannelsRequiredToBeReleasedList>,
    pub sl_drbs_required_to_be_modified_list: Option<SlDrbsRequiredToBeModifiedList>,
    pub sl_drbs_required_to_be_released_list: Option<SlDrbsRequiredToBeReleasedList>,
    pub target_cells_to_cancel: Option<TargetCellList>,
    pub uu_rlc_channel_required_to_be_modified_list: Option<UuRlcChannelRequiredToBeModifiedList>,
    pub uu_rlc_channel_required_to_be_released_list: Option<UuRlcChannelRequiredToBeReleasedList>,
    pub pc5rlc_channel_required_to_be_modified_list: Option<Pc5rlcChannelRequiredToBeModifiedList>,
    pub pc5rlc_channel_required_to_be_released_list: Option<Pc5rlcChannelRequiredToBeReleasedList>,
    pub ue_multicast_mr_bs_required_to_be_modified_list:
        Option<UeMulticastMrBsRequiredToBeModifiedList>,
    pub ue_multicast_mr_bs_required_to_be_released_list:
        Option<UeMulticastMrBsRequiredToBeReleasedList>,
    pub ltm_cells_to_be_released_list: Option<LtmCellsToBeReleasedList>,
}

impl UeContextModificationRequired {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let _ = decode::decode_sequence_header(data, true, 0)?;
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut gnb_cu_ue_f1ap_id: Option<GnbCuUeF1apId> = None;
        let mut gnb_du_ue_f1ap_id: Option<GnbDuUeF1apId> = None;
        let mut resource_coordination_transfer_container: Option<
            ResourceCoordinationTransferContainer,
        > = None;
        let mut du_to_cu_rrc_information: Option<DuToCuRrcInformation> = None;
        let mut drbs_required_to_be_modified_list: Option<DrbsRequiredToBeModifiedList> = None;
        let mut srbs_required_to_be_released_list: Option<SrbsRequiredToBeReleasedList> = None;
        let mut drbs_required_to_be_released_list: Option<DrbsRequiredToBeReleasedList> = None;
        let mut cause: Option<Cause> = None;
        let mut bh_channels_required_to_be_released_list: Option<
            BhChannelsRequiredToBeReleasedList,
        > = None;
        let mut sl_drbs_required_to_be_modified_list: Option<SlDrbsRequiredToBeModifiedList> = None;
        let mut sl_drbs_required_to_be_released_list: Option<SlDrbsRequiredToBeReleasedList> = None;
        let mut target_cells_to_cancel: Option<TargetCellList> = None;
        let mut uu_rlc_channel_required_to_be_modified_list: Option<
            UuRlcChannelRequiredToBeModifiedList,
        > = None;
        let mut uu_rlc_channel_required_to_be_released_list: Option<
            UuRlcChannelRequiredToBeReleasedList,
        > = None;
        let mut pc5rlc_channel_required_to_be_modified_list: Option<
            Pc5rlcChannelRequiredToBeModifiedList,
        > = None;
        let mut pc5rlc_channel_required_to_be_released_list: Option<
            Pc5rlcChannelRequiredToBeReleasedList,
        > = None;
        let mut ue_multicast_mr_bs_required_to_be_modified_list: Option<
            UeMulticastMrBsRequiredToBeModifiedList,
        > = None;
        let mut ue_multicast_mr_bs_required_to_be_released_list: Option<
            UeMulticastMrBsRequiredToBeReleasedList,
        > = None;
        let mut ltm_cells_to_be_released_list: Option<LtmCellsToBeReleasedList> = None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                40 => gnb_cu_ue_f1ap_id = Some(GnbCuUeF1apId::decode(data)?),
                41 => gnb_du_ue_f1ap_id = Some(GnbDuUeF1apId::decode(data)?),
                49 => {
                    resource_coordination_transfer_container =
                        Some(ResourceCoordinationTransferContainer::decode(data)?)
                }
                39 => du_to_cu_rrc_information = Some(DuToCuRrcInformation::decode(data)?),
                23 => {
                    drbs_required_to_be_modified_list =
                        Some(DrbsRequiredToBeModifiedList::decode(data)?)
                }
                70 => {
                    srbs_required_to_be_released_list =
                        Some(SrbsRequiredToBeReleasedList::decode(data)?)
                }
                25 => {
                    drbs_required_to_be_released_list =
                        Some(DrbsRequiredToBeReleasedList::decode(data)?)
                }
                0 => cause = Some(Cause::decode(data)?),
                277 => {
                    bh_channels_required_to_be_released_list =
                        Some(BhChannelsRequiredToBeReleasedList::decode(data)?)
                }
                320 => {
                    sl_drbs_required_to_be_modified_list =
                        Some(SlDrbsRequiredToBeModifiedList::decode(data)?)
                }
                322 => {
                    sl_drbs_required_to_be_released_list =
                        Some(SlDrbsRequiredToBeReleasedList::decode(data)?)
                }
                375 => target_cells_to_cancel = Some(TargetCellList::decode(data)?),
                606 => {
                    uu_rlc_channel_required_to_be_modified_list =
                        Some(UuRlcChannelRequiredToBeModifiedList::decode(data)?)
                }
                607 => {
                    uu_rlc_channel_required_to_be_released_list =
                        Some(UuRlcChannelRequiredToBeReleasedList::decode(data)?)
                }
                614 => {
                    pc5rlc_channel_required_to_be_modified_list =
                        Some(Pc5rlcChannelRequiredToBeModifiedList::decode(data)?)
                }
                615 => {
                    pc5rlc_channel_required_to_be_released_list =
                        Some(Pc5rlcChannelRequiredToBeReleasedList::decode(data)?)
                }
                655 => {
                    ue_multicast_mr_bs_required_to_be_modified_list =
                        Some(UeMulticastMrBsRequiredToBeModifiedList::decode(data)?)
                }
                657 => {
                    ue_multicast_mr_bs_required_to_be_released_list =
                        Some(UeMulticastMrBsRequiredToBeReleasedList::decode(data)?)
                }
                723 => {
                    ltm_cells_to_be_released_list = Some(LtmCellsToBeReleasedList::decode(data)?)
                }
                x => return Err(per_codec_error_new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        let gnb_cu_ue_f1ap_id = gnb_cu_ue_f1ap_id.ok_or(per_codec_error_new(format!(
            "Missing mandatory IE gnb_cu_ue_f1ap_id"
        )))?;
        let gnb_du_ue_f1ap_id = gnb_du_ue_f1ap_id.ok_or(per_codec_error_new(format!(
            "Missing mandatory IE gnb_du_ue_f1ap_id"
        )))?;
        let cause = cause.ok_or(per_codec_error_new(format!("Missing mandatory IE cause")))?;
        Ok(Self {
            gnb_cu_ue_f1ap_id,
            gnb_du_ue_f1ap_id,
            resource_coordination_transfer_container,
            du_to_cu_rrc_information,
            drbs_required_to_be_modified_list,
            srbs_required_to_be_released_list,
            drbs_required_to_be_released_list,
            cause,
            bh_channels_required_to_be_released_list,
            sl_drbs_required_to_be_modified_list,
            sl_drbs_required_to_be_released_list,
            target_cells_to_cancel,
            uu_rlc_channel_required_to_be_modified_list,
            uu_rlc_channel_required_to_be_released_list,
            pc5rlc_channel_required_to_be_modified_list,
            pc5rlc_channel_required_to_be_released_list,
            ue_multicast_mr_bs_required_to_be_modified_list,
            ue_multicast_mr_bs_required_to_be_released_list,
            ltm_cells_to_be_released_list,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        let ie = &mut Allocator::new_codec_data();
        self.gnb_cu_ue_f1ap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 40, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.gnb_du_ue_f1ap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 41, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        if let Some(x) = &self.resource_coordination_transfer_container {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 49, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.du_to_cu_rrc_information {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 39, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.drbs_required_to_be_modified_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 23, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.srbs_required_to_be_released_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 70, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.drbs_required_to_be_released_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 25, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        let ie = &mut Allocator::new_codec_data();
        self.cause.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 0, false)?;
        Criticality::Ignore.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        if let Some(x) = &self.bh_channels_required_to_be_released_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 277, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.sl_drbs_required_to_be_modified_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 320, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.sl_drbs_required_to_be_released_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 322, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.target_cells_to_cancel {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 375, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.uu_rlc_channel_required_to_be_modified_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 606, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.uu_rlc_channel_required_to_be_released_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 607, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.pc5rlc_channel_required_to_be_modified_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 614, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.pc5rlc_channel_required_to_be_released_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 615, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.ue_multicast_mr_bs_required_to_be_modified_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 655, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.ue_multicast_mr_bs_required_to_be_released_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 657, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.ltm_cells_to_be_released_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 723, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        encode::encode_sequence_header(data, true, &BitString::new(), false)?;
        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for UeContextModificationRequired {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        UeContextModificationRequired::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UeContextModificationRequired");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UeContextModificationRequired");
            e
        })
    }
}
// DrbsRequiredToBeModifiedList
#[derive(Clone, Debug)]
pub struct DrbsRequiredToBeModifiedList(pub NonEmpty<DrbsRequiredToBeModifiedItem>);

impl DrbsRequiredToBeModifiedList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(64), false)?;
            let mut items = vec![];
            for _ in 0..length {
                let _ = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _ = Criticality::decode(data)?;
                let _ = decode::decode_length_determinent(data, None, None, false)?;
                items.push(DrbsRequiredToBeModifiedItem::decode(data)?);
                data.decode_align()?;
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(64), false, self.0.len())?;
        for x in &self.0 {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(data, Some(0), Some(65535), false, 22, false)?;
            Criticality::Reject.encode(data)?;
            encode::encode_length_determinent(data, None, None, false, ie.length_in_bytes())?;
            data.append_aligned(ie);
        }
        Ok(())
    }
}

impl PerCodec for DrbsRequiredToBeModifiedList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        DrbsRequiredToBeModifiedList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DrbsRequiredToBeModifiedList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DrbsRequiredToBeModifiedList");
            e
        })
    }
}
// DrbsRequiredToBeReleasedList
#[derive(Clone, Debug)]
pub struct DrbsRequiredToBeReleasedList(pub NonEmpty<DrbsRequiredToBeReleasedItem>);

impl DrbsRequiredToBeReleasedList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(64), false)?;
            let mut items = vec![];
            for _ in 0..length {
                let _ = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _ = Criticality::decode(data)?;
                let _ = decode::decode_length_determinent(data, None, None, false)?;
                items.push(DrbsRequiredToBeReleasedItem::decode(data)?);
                data.decode_align()?;
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(64), false, self.0.len())?;
        for x in &self.0 {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(data, Some(0), Some(65535), false, 24, false)?;
            Criticality::Reject.encode(data)?;
            encode::encode_length_determinent(data, None, None, false, ie.length_in_bytes())?;
            data.append_aligned(ie);
        }
        Ok(())
    }
}

impl PerCodec for DrbsRequiredToBeReleasedList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        DrbsRequiredToBeReleasedList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DrbsRequiredToBeReleasedList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DrbsRequiredToBeReleasedList");
            e
        })
    }
}
// SrbsRequiredToBeReleasedList
#[derive(Clone, Debug)]
pub struct SrbsRequiredToBeReleasedList(pub NonEmpty<SrbsRequiredToBeReleasedItem>);

impl SrbsRequiredToBeReleasedList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(8), false)?;
            let mut items = vec![];
            for _ in 0..length {
                let _ = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _ = Criticality::decode(data)?;
                let _ = decode::decode_length_determinent(data, None, None, false)?;
                items.push(SrbsRequiredToBeReleasedItem::decode(data)?);
                data.decode_align()?;
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(8), false, self.0.len())?;
        for x in &self.0 {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(data, Some(0), Some(65535), false, 69, false)?;
            Criticality::Reject.encode(data)?;
            encode::encode_length_determinent(data, None, None, false, ie.length_in_bytes())?;
            data.append_aligned(ie);
        }
        Ok(())
    }
}

impl PerCodec for SrbsRequiredToBeReleasedList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        SrbsRequiredToBeReleasedList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SrbsRequiredToBeReleasedList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SrbsRequiredToBeReleasedList");
            e
        })
    }
}
// BhChannelsRequiredToBeReleasedList
#[derive(Clone, Debug)]
pub struct BhChannelsRequiredToBeReleasedList(pub NonEmpty<BhChannelsRequiredToBeReleasedItem>);

impl BhChannelsRequiredToBeReleasedList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(65536), false)?;
            let mut items = vec![];
            for _ in 0..length {
                let _ = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _ = Criticality::decode(data)?;
                let _ = decode::decode_length_determinent(data, None, None, false)?;
                items.push(BhChannelsRequiredToBeReleasedItem::decode(data)?);
                data.decode_align()?;
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(65536), false, self.0.len())?;
        for x in &self.0 {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(data, Some(0), Some(65535), false, 276, false)?;
            Criticality::Reject.encode(data)?;
            encode::encode_length_determinent(data, None, None, false, ie.length_in_bytes())?;
            data.append_aligned(ie);
        }
        Ok(())
    }
}

impl PerCodec for BhChannelsRequiredToBeReleasedList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        BhChannelsRequiredToBeReleasedList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("BhChannelsRequiredToBeReleasedList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("BhChannelsRequiredToBeReleasedList");
            e
        })
    }
}
// SlDrbsRequiredToBeModifiedList
#[derive(Clone, Debug)]
pub struct SlDrbsRequiredToBeModifiedList(pub NonEmpty<SlDrbsRequiredToBeModifiedItem>);

impl SlDrbsRequiredToBeModifiedList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(512), false)?;
            let mut items = vec![];
            for _ in 0..length {
                let _ = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _ = Criticality::decode(data)?;
                let _ = decode::decode_length_determinent(data, None, None, false)?;
                items.push(SlDrbsRequiredToBeModifiedItem::decode(data)?);
                data.decode_align()?;
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(512), false, self.0.len())?;
        for x in &self.0 {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(data, Some(0), Some(65535), false, 319, false)?;
            Criticality::Reject.encode(data)?;
            encode::encode_length_determinent(data, None, None, false, ie.length_in_bytes())?;
            data.append_aligned(ie);
        }
        Ok(())
    }
}

impl PerCodec for SlDrbsRequiredToBeModifiedList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        SlDrbsRequiredToBeModifiedList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SlDrbsRequiredToBeModifiedList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SlDrbsRequiredToBeModifiedList");
            e
        })
    }
}
// SlDrbsRequiredToBeReleasedList
#[derive(Clone, Debug)]
pub struct SlDrbsRequiredToBeReleasedList(pub NonEmpty<SlDrbsRequiredToBeReleasedItem>);

impl SlDrbsRequiredToBeReleasedList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(512), false)?;
            let mut items = vec![];
            for _ in 0..length {
                let _ = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _ = Criticality::decode(data)?;
                let _ = decode::decode_length_determinent(data, None, None, false)?;
                items.push(SlDrbsRequiredToBeReleasedItem::decode(data)?);
                data.decode_align()?;
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(512), false, self.0.len())?;
        for x in &self.0 {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(data, Some(0), Some(65535), false, 321, false)?;
            Criticality::Reject.encode(data)?;
            encode::encode_length_determinent(data, None, None, false, ie.length_in_bytes())?;
            data.append_aligned(ie);
        }
        Ok(())
    }
}

impl PerCodec for SlDrbsRequiredToBeReleasedList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        SlDrbsRequiredToBeReleasedList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SlDrbsRequiredToBeReleasedList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SlDrbsRequiredToBeReleasedList");
            e
        })
    }
}
// UeMulticastMrBsRequiredToBeModifiedList
#[derive(Clone, Debug)]
pub struct UeMulticastMrBsRequiredToBeModifiedList(
    pub NonEmpty<UeMulticastMrBsRequiredToBeModifiedItem>,
);

impl UeMulticastMrBsRequiredToBeModifiedList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(64), false)?;
            let mut items = vec![];
            for _ in 0..length {
                let _ = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _ = Criticality::decode(data)?;
                let _ = decode::decode_length_determinent(data, None, None, false)?;
                items.push(UeMulticastMrBsRequiredToBeModifiedItem::decode(data)?);
                data.decode_align()?;
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(64), false, self.0.len())?;
        for x in &self.0 {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(data, Some(0), Some(65535), false, 656, false)?;
            Criticality::Reject.encode(data)?;
            encode::encode_length_determinent(data, None, None, false, ie.length_in_bytes())?;
            data.append_aligned(ie);
        }
        Ok(())
    }
}

impl PerCodec for UeMulticastMrBsRequiredToBeModifiedList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        UeMulticastMrBsRequiredToBeModifiedList::decode_inner(data).map_err(
            |mut e: PerCodecError| {
                e.push_context("UeMulticastMrBsRequiredToBeModifiedList");
                e
            },
        )
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UeMulticastMrBsRequiredToBeModifiedList");
            e
        })
    }
}
// UeMulticastMrBsRequiredToBeReleasedList
#[derive(Clone, Debug)]
pub struct UeMulticastMrBsRequiredToBeReleasedList(
    pub NonEmpty<UeMulticastMrBsRequiredToBeReleasedItem>,
);

impl UeMulticastMrBsRequiredToBeReleasedList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(64), false)?;
            let mut items = vec![];
            for _ in 0..length {
                let _ = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _ = Criticality::decode(data)?;
                let _ = decode::decode_length_determinent(data, None, None, false)?;
                items.push(UeMulticastMrBsRequiredToBeReleasedItem::decode(data)?);
                data.decode_align()?;
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(64), false, self.0.len())?;
        for x in &self.0 {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(data, Some(0), Some(65535), false, 658, false)?;
            Criticality::Reject.encode(data)?;
            encode::encode_length_determinent(data, None, None, false, ie.length_in_bytes())?;
            data.append_aligned(ie);
        }
        Ok(())
    }
}

impl PerCodec for UeMulticastMrBsRequiredToBeReleasedList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        UeMulticastMrBsRequiredToBeReleasedList::decode_inner(data).map_err(
            |mut e: PerCodecError| {
                e.push_context("UeMulticastMrBsRequiredToBeReleasedList");
                e
            },
        )
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UeMulticastMrBsRequiredToBeReleasedList");
            e
        })
    }
}
// UeContextModificationConfirm
#[derive(Clone, Debug)]
pub struct UeContextModificationConfirm {
    pub gnb_cu_ue_f1ap_id: GnbCuUeF1apId,
    pub gnb_du_ue_f1ap_id: GnbDuUeF1apId,
    pub resource_coordination_transfer_container: Option<ResourceCoordinationTransferContainer>,
    pub drbs_modified_conf_list: Option<DrbsModifiedConfList>,
    pub rrc_container: Option<RrcContainer>,
    pub criticality_diagnostics: Option<CriticalityDiagnostics>,
    pub execute_duplication: Option<ExecuteDuplication>,
    pub resource_coordination_transfer_information: Option<ResourceCoordinationTransferInformation>,
    pub sl_drbs_modified_conf_list: Option<SlDrbsModifiedConfList>,
    pub uu_rlc_channel_modified_list: Option<UuRlcChannelModifiedList>,
    pub pc5rlc_channel_modified_list: Option<Pc5rlcChannelModifiedList>,
    pub ue_multicast_mr_bs_confirmed_to_be_modified_list:
        Option<UeMulticastMrBsConfirmedToBeModifiedList>,
}

impl UeContextModificationConfirm {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let _ = decode::decode_sequence_header(data, true, 0)?;
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut gnb_cu_ue_f1ap_id: Option<GnbCuUeF1apId> = None;
        let mut gnb_du_ue_f1ap_id: Option<GnbDuUeF1apId> = None;
        let mut resource_coordination_transfer_container: Option<
            ResourceCoordinationTransferContainer,
        > = None;
        let mut drbs_modified_conf_list: Option<DrbsModifiedConfList> = None;
        let mut rrc_container: Option<RrcContainer> = None;
        let mut criticality_diagnostics: Option<CriticalityDiagnostics> = None;
        let mut execute_duplication: Option<ExecuteDuplication> = None;
        let mut resource_coordination_transfer_information: Option<
            ResourceCoordinationTransferInformation,
        > = None;
        let mut sl_drbs_modified_conf_list: Option<SlDrbsModifiedConfList> = None;
        let mut uu_rlc_channel_modified_list: Option<UuRlcChannelModifiedList> = None;
        let mut pc5rlc_channel_modified_list: Option<Pc5rlcChannelModifiedList> = None;
        let mut ue_multicast_mr_bs_confirmed_to_be_modified_list: Option<
            UeMulticastMrBsConfirmedToBeModifiedList,
        > = None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                40 => gnb_cu_ue_f1ap_id = Some(GnbCuUeF1apId::decode(data)?),
                41 => gnb_du_ue_f1ap_id = Some(GnbDuUeF1apId::decode(data)?),
                49 => {
                    resource_coordination_transfer_container =
                        Some(ResourceCoordinationTransferContainer::decode(data)?)
                }
                19 => drbs_modified_conf_list = Some(DrbsModifiedConfList::decode(data)?),
                50 => rrc_container = Some(RrcContainer::decode(data)?),
                7 => criticality_diagnostics = Some(CriticalityDiagnostics::decode(data)?),
                109 => execute_duplication = Some(ExecuteDuplication::decode(data)?),
                195 => {
                    resource_coordination_transfer_information =
                        Some(ResourceCoordinationTransferInformation::decode(data)?)
                }
                337 => sl_drbs_modified_conf_list = Some(SlDrbsModifiedConfList::decode(data)?),
                604 => uu_rlc_channel_modified_list = Some(UuRlcChannelModifiedList::decode(data)?),
                616 => {
                    pc5rlc_channel_modified_list = Some(Pc5rlcChannelModifiedList::decode(data)?)
                }
                653 => {
                    ue_multicast_mr_bs_confirmed_to_be_modified_list =
                        Some(UeMulticastMrBsConfirmedToBeModifiedList::decode(data)?)
                }
                x => return Err(per_codec_error_new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        let gnb_cu_ue_f1ap_id = gnb_cu_ue_f1ap_id.ok_or(per_codec_error_new(format!(
            "Missing mandatory IE gnb_cu_ue_f1ap_id"
        )))?;
        let gnb_du_ue_f1ap_id = gnb_du_ue_f1ap_id.ok_or(per_codec_error_new(format!(
            "Missing mandatory IE gnb_du_ue_f1ap_id"
        )))?;
        Ok(Self {
            gnb_cu_ue_f1ap_id,
            gnb_du_ue_f1ap_id,
            resource_coordination_transfer_container,
            drbs_modified_conf_list,
            rrc_container,
            criticality_diagnostics,
            execute_duplication,
            resource_coordination_transfer_information,
            sl_drbs_modified_conf_list,
            uu_rlc_channel_modified_list,
            pc5rlc_channel_modified_list,
            ue_multicast_mr_bs_confirmed_to_be_modified_list,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        let ie = &mut Allocator::new_codec_data();
        self.gnb_cu_ue_f1ap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 40, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.gnb_du_ue_f1ap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 41, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        if let Some(x) = &self.resource_coordination_transfer_container {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 49, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.drbs_modified_conf_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 19, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.rrc_container {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 50, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.criticality_diagnostics {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 7, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.execute_duplication {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 109, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.resource_coordination_transfer_information {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 195, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.sl_drbs_modified_conf_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 337, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.uu_rlc_channel_modified_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 604, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.pc5rlc_channel_modified_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 616, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.ue_multicast_mr_bs_confirmed_to_be_modified_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 653, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        encode::encode_sequence_header(data, true, &BitString::new(), false)?;
        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for UeContextModificationConfirm {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        UeContextModificationConfirm::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UeContextModificationConfirm");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UeContextModificationConfirm");
            e
        })
    }
}
// DrbsModifiedConfList
#[derive(Clone, Debug)]
pub struct DrbsModifiedConfList(pub NonEmpty<DrbsModifiedConfItem>);

impl DrbsModifiedConfList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(64), false)?;
            let mut items = vec![];
            for _ in 0..length {
                let _ = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _ = Criticality::decode(data)?;
                let _ = decode::decode_length_determinent(data, None, None, false)?;
                items.push(DrbsModifiedConfItem::decode(data)?);
                data.decode_align()?;
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(64), false, self.0.len())?;
        for x in &self.0 {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(data, Some(0), Some(65535), false, 18, false)?;
            Criticality::Ignore.encode(data)?;
            encode::encode_length_determinent(data, None, None, false, ie.length_in_bytes())?;
            data.append_aligned(ie);
        }
        Ok(())
    }
}

impl PerCodec for DrbsModifiedConfList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        DrbsModifiedConfList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DrbsModifiedConfList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DrbsModifiedConfList");
            e
        })
    }
}
// SlDrbsModifiedConfList
#[derive(Clone, Debug)]
pub struct SlDrbsModifiedConfList(pub NonEmpty<SlDrbsModifiedConfItem>);

impl SlDrbsModifiedConfList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(512), false)?;
            let mut items = vec![];
            for _ in 0..length {
                let _ = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _ = Criticality::decode(data)?;
                let _ = decode::decode_length_determinent(data, None, None, false)?;
                items.push(SlDrbsModifiedConfItem::decode(data)?);
                data.decode_align()?;
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(512), false, self.0.len())?;
        for x in &self.0 {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(data, Some(0), Some(65535), false, 338, false)?;
            Criticality::Ignore.encode(data)?;
            encode::encode_length_determinent(data, None, None, false, ie.length_in_bytes())?;
            data.append_aligned(ie);
        }
        Ok(())
    }
}

impl PerCodec for SlDrbsModifiedConfList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        SlDrbsModifiedConfList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SlDrbsModifiedConfList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SlDrbsModifiedConfList");
            e
        })
    }
}
// UeMulticastMrBsConfirmedToBeModifiedList
#[derive(Clone, Debug)]
pub struct UeMulticastMrBsConfirmedToBeModifiedList(
    pub NonEmpty<UeMulticastMrBsConfirmedToBeModifiedItem>,
);

impl UeMulticastMrBsConfirmedToBeModifiedList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(64), false)?;
            let mut items = vec![];
            for _ in 0..length {
                let _ = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _ = Criticality::decode(data)?;
                let _ = decode::decode_length_determinent(data, None, None, false)?;
                items.push(UeMulticastMrBsConfirmedToBeModifiedItem::decode(data)?);
                data.decode_align()?;
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(64), false, self.0.len())?;
        for x in &self.0 {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(data, Some(0), Some(65535), false, 654, false)?;
            Criticality::Reject.encode(data)?;
            encode::encode_length_determinent(data, None, None, false, ie.length_in_bytes())?;
            data.append_aligned(ie);
        }
        Ok(())
    }
}

impl PerCodec for UeMulticastMrBsConfirmedToBeModifiedList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        UeMulticastMrBsConfirmedToBeModifiedList::decode_inner(data).map_err(
            |mut e: PerCodecError| {
                e.push_context("UeMulticastMrBsConfirmedToBeModifiedList");
                e
            },
        )
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UeMulticastMrBsConfirmedToBeModifiedList");
            e
        })
    }
}
// UeContextModificationRefuse
#[derive(Clone, Debug)]
pub struct UeContextModificationRefuse {
    pub gnb_cu_ue_f1ap_id: GnbCuUeF1apId,
    pub gnb_du_ue_f1ap_id: GnbDuUeF1apId,
    pub cause: Cause,
    pub criticality_diagnostics: Option<CriticalityDiagnostics>,
}

impl UeContextModificationRefuse {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let _ = decode::decode_sequence_header(data, true, 0)?;
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut gnb_cu_ue_f1ap_id: Option<GnbCuUeF1apId> = None;
        let mut gnb_du_ue_f1ap_id: Option<GnbDuUeF1apId> = None;
        let mut cause: Option<Cause> = None;
        let mut criticality_diagnostics: Option<CriticalityDiagnostics> = None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                40 => gnb_cu_ue_f1ap_id = Some(GnbCuUeF1apId::decode(data)?),
                41 => gnb_du_ue_f1ap_id = Some(GnbDuUeF1apId::decode(data)?),
                0 => cause = Some(Cause::decode(data)?),
                7 => criticality_diagnostics = Some(CriticalityDiagnostics::decode(data)?),
                x => return Err(per_codec_error_new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        let gnb_cu_ue_f1ap_id = gnb_cu_ue_f1ap_id.ok_or(per_codec_error_new(format!(
            "Missing mandatory IE gnb_cu_ue_f1ap_id"
        )))?;
        let gnb_du_ue_f1ap_id = gnb_du_ue_f1ap_id.ok_or(per_codec_error_new(format!(
            "Missing mandatory IE gnb_du_ue_f1ap_id"
        )))?;
        let cause = cause.ok_or(per_codec_error_new(format!("Missing mandatory IE cause")))?;
        Ok(Self {
            gnb_cu_ue_f1ap_id,
            gnb_du_ue_f1ap_id,
            cause,
            criticality_diagnostics,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        let ie = &mut Allocator::new_codec_data();
        self.gnb_cu_ue_f1ap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 40, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.gnb_du_ue_f1ap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 41, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.cause.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 0, false)?;
        Criticality::Ignore.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        if let Some(x) = &self.criticality_diagnostics {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 7, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        encode::encode_sequence_header(data, true, &BitString::new(), false)?;
        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for UeContextModificationRefuse {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        UeContextModificationRefuse::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UeContextModificationRefuse");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UeContextModificationRefuse");
            e
        })
    }
}
// WriteReplaceWarningRequest
#[derive(Clone, Debug)]
pub struct WriteReplaceWarningRequest {
    pub transaction_id: TransactionId,
    pub pws_system_information: PwsSystemInformation,
    pub repetition_period: RepetitionPeriod,
    pub numberof_broadcast_request: NumberofBroadcastRequest,
    pub cells_to_be_broadcast_list: Option<CellsToBeBroadcastList>,
}

impl WriteReplaceWarningRequest {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let _ = decode::decode_sequence_header(data, true, 0)?;
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut transaction_id: Option<TransactionId> = None;
        let mut pws_system_information: Option<PwsSystemInformation> = None;
        let mut repetition_period: Option<RepetitionPeriod> = None;
        let mut numberof_broadcast_request: Option<NumberofBroadcastRequest> = None;
        let mut cells_to_be_broadcast_list: Option<CellsToBeBroadcastList> = None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                78 => transaction_id = Some(TransactionId::decode(data)?),
                140 => pws_system_information = Some(PwsSystemInformation::decode(data)?),
                141 => repetition_period = Some(RepetitionPeriod::decode(data)?),
                142 => numberof_broadcast_request = Some(NumberofBroadcastRequest::decode(data)?),
                144 => cells_to_be_broadcast_list = Some(CellsToBeBroadcastList::decode(data)?),
                x => return Err(per_codec_error_new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        let transaction_id = transaction_id.ok_or(per_codec_error_new(format!(
            "Missing mandatory IE transaction_id"
        )))?;
        let pws_system_information = pws_system_information.ok_or(per_codec_error_new(format!(
            "Missing mandatory IE pws_system_information"
        )))?;
        let repetition_period = repetition_period.ok_or(per_codec_error_new(format!(
            "Missing mandatory IE repetition_period"
        )))?;
        let numberof_broadcast_request = numberof_broadcast_request.ok_or(per_codec_error_new(
            format!("Missing mandatory IE numberof_broadcast_request"),
        ))?;
        Ok(Self {
            transaction_id,
            pws_system_information,
            repetition_period,
            numberof_broadcast_request,
            cells_to_be_broadcast_list,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        let ie = &mut Allocator::new_codec_data();
        self.transaction_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 78, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.pws_system_information.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 140, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.repetition_period.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 141, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.numberof_broadcast_request.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 142, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        if let Some(x) = &self.cells_to_be_broadcast_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 144, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        encode::encode_sequence_header(data, true, &BitString::new(), false)?;
        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for WriteReplaceWarningRequest {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        WriteReplaceWarningRequest::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("WriteReplaceWarningRequest");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("WriteReplaceWarningRequest");
            e
        })
    }
}
// CellsToBeBroadcastList
#[derive(Clone, Debug)]
pub struct CellsToBeBroadcastList(pub NonEmpty<CellsToBeBroadcastItem>);

impl CellsToBeBroadcastList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(512), false)?;
            let mut items = vec![];
            for _ in 0..length {
                let _ = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _ = Criticality::decode(data)?;
                let _ = decode::decode_length_determinent(data, None, None, false)?;
                items.push(CellsToBeBroadcastItem::decode(data)?);
                data.decode_align()?;
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(512), false, self.0.len())?;
        for x in &self.0 {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(data, Some(0), Some(65535), false, 145, false)?;
            Criticality::Reject.encode(data)?;
            encode::encode_length_determinent(data, None, None, false, ie.length_in_bytes())?;
            data.append_aligned(ie);
        }
        Ok(())
    }
}

impl PerCodec for CellsToBeBroadcastList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        CellsToBeBroadcastList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CellsToBeBroadcastList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CellsToBeBroadcastList");
            e
        })
    }
}
// WriteReplaceWarningResponse
#[derive(Clone, Debug)]
pub struct WriteReplaceWarningResponse {
    pub transaction_id: TransactionId,
    pub cells_broadcast_completed_list: Option<CellsBroadcastCompletedList>,
    pub criticality_diagnostics: Option<CriticalityDiagnostics>,
    pub dedicated_si_delivery_needed_ue_list: Option<DedicatedSiDeliveryNeededUeList>,
}

impl WriteReplaceWarningResponse {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let _ = decode::decode_sequence_header(data, true, 0)?;
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut transaction_id: Option<TransactionId> = None;
        let mut cells_broadcast_completed_list: Option<CellsBroadcastCompletedList> = None;
        let mut criticality_diagnostics: Option<CriticalityDiagnostics> = None;
        let mut dedicated_si_delivery_needed_ue_list: Option<DedicatedSiDeliveryNeededUeList> =
            None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                78 => transaction_id = Some(TransactionId::decode(data)?),
                146 => {
                    cells_broadcast_completed_list =
                        Some(CellsBroadcastCompletedList::decode(data)?)
                }
                7 => criticality_diagnostics = Some(CriticalityDiagnostics::decode(data)?),
                189 => {
                    dedicated_si_delivery_needed_ue_list =
                        Some(DedicatedSiDeliveryNeededUeList::decode(data)?)
                }
                x => return Err(per_codec_error_new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        let transaction_id = transaction_id.ok_or(per_codec_error_new(format!(
            "Missing mandatory IE transaction_id"
        )))?;
        Ok(Self {
            transaction_id,
            cells_broadcast_completed_list,
            criticality_diagnostics,
            dedicated_si_delivery_needed_ue_list,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        let ie = &mut Allocator::new_codec_data();
        self.transaction_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 78, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        if let Some(x) = &self.cells_broadcast_completed_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 146, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.criticality_diagnostics {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 7, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.dedicated_si_delivery_needed_ue_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 189, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        encode::encode_sequence_header(data, true, &BitString::new(), false)?;
        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for WriteReplaceWarningResponse {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        WriteReplaceWarningResponse::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("WriteReplaceWarningResponse");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("WriteReplaceWarningResponse");
            e
        })
    }
}
// CellsBroadcastCompletedList
#[derive(Clone, Debug)]
pub struct CellsBroadcastCompletedList(pub NonEmpty<CellsBroadcastCompletedItem>);

impl CellsBroadcastCompletedList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(512), false)?;
            let mut items = vec![];
            for _ in 0..length {
                let _ = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _ = Criticality::decode(data)?;
                let _ = decode::decode_length_determinent(data, None, None, false)?;
                items.push(CellsBroadcastCompletedItem::decode(data)?);
                data.decode_align()?;
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(512), false, self.0.len())?;
        for x in &self.0 {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(data, Some(0), Some(65535), false, 147, false)?;
            Criticality::Reject.encode(data)?;
            encode::encode_length_determinent(data, None, None, false, ie.length_in_bytes())?;
            data.append_aligned(ie);
        }
        Ok(())
    }
}

impl PerCodec for CellsBroadcastCompletedList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        CellsBroadcastCompletedList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CellsBroadcastCompletedList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CellsBroadcastCompletedList");
            e
        })
    }
}
// PwsCancelRequest
#[derive(Clone, Debug)]
pub struct PwsCancelRequest {
    pub transaction_id: TransactionId,
    pub numberof_broadcast_request: NumberofBroadcastRequest,
    pub broadcast_to_be_cancelled_list: Option<BroadcastToBeCancelledList>,
    pub cancel_all_warning_messages_indicator: Option<CancelAllWarningMessagesIndicator>,
    pub notification_information: Option<NotificationInformation>,
}

impl PwsCancelRequest {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let _ = decode::decode_sequence_header(data, true, 0)?;
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut transaction_id: Option<TransactionId> = None;
        let mut numberof_broadcast_request: Option<NumberofBroadcastRequest> = None;
        let mut broadcast_to_be_cancelled_list: Option<BroadcastToBeCancelledList> = None;
        let mut cancel_all_warning_messages_indicator: Option<CancelAllWarningMessagesIndicator> =
            None;
        let mut notification_information: Option<NotificationInformation> = None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                78 => transaction_id = Some(TransactionId::decode(data)?),
                142 => numberof_broadcast_request = Some(NumberofBroadcastRequest::decode(data)?),
                148 => {
                    broadcast_to_be_cancelled_list = Some(BroadcastToBeCancelledList::decode(data)?)
                }
                157 => {
                    cancel_all_warning_messages_indicator =
                        Some(CancelAllWarningMessagesIndicator::decode(data)?)
                }
                220 => notification_information = Some(NotificationInformation::decode(data)?),
                x => return Err(per_codec_error_new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        let transaction_id = transaction_id.ok_or(per_codec_error_new(format!(
            "Missing mandatory IE transaction_id"
        )))?;
        let numberof_broadcast_request = numberof_broadcast_request.ok_or(per_codec_error_new(
            format!("Missing mandatory IE numberof_broadcast_request"),
        ))?;
        Ok(Self {
            transaction_id,
            numberof_broadcast_request,
            broadcast_to_be_cancelled_list,
            cancel_all_warning_messages_indicator,
            notification_information,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        let ie = &mut Allocator::new_codec_data();
        self.transaction_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 78, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.numberof_broadcast_request.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 142, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        if let Some(x) = &self.broadcast_to_be_cancelled_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 148, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.cancel_all_warning_messages_indicator {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 157, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.notification_information {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 220, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        encode::encode_sequence_header(data, true, &BitString::new(), false)?;
        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for PwsCancelRequest {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PwsCancelRequest::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PwsCancelRequest");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PwsCancelRequest");
            e
        })
    }
}
// BroadcastToBeCancelledList
#[derive(Clone, Debug)]
pub struct BroadcastToBeCancelledList(pub NonEmpty<BroadcastToBeCancelledItem>);

impl BroadcastToBeCancelledList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(512), false)?;
            let mut items = vec![];
            for _ in 0..length {
                let _ = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _ = Criticality::decode(data)?;
                let _ = decode::decode_length_determinent(data, None, None, false)?;
                items.push(BroadcastToBeCancelledItem::decode(data)?);
                data.decode_align()?;
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(512), false, self.0.len())?;
        for x in &self.0 {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(data, Some(0), Some(65535), false, 149, false)?;
            Criticality::Reject.encode(data)?;
            encode::encode_length_determinent(data, None, None, false, ie.length_in_bytes())?;
            data.append_aligned(ie);
        }
        Ok(())
    }
}

impl PerCodec for BroadcastToBeCancelledList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        BroadcastToBeCancelledList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("BroadcastToBeCancelledList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("BroadcastToBeCancelledList");
            e
        })
    }
}
// PwsCancelResponse
#[derive(Clone, Debug)]
pub struct PwsCancelResponse {
    pub transaction_id: TransactionId,
    pub cells_broadcast_cancelled_list: Option<CellsBroadcastCancelledList>,
    pub criticality_diagnostics: Option<CriticalityDiagnostics>,
}

impl PwsCancelResponse {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let _ = decode::decode_sequence_header(data, true, 0)?;
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut transaction_id: Option<TransactionId> = None;
        let mut cells_broadcast_cancelled_list: Option<CellsBroadcastCancelledList> = None;
        let mut criticality_diagnostics: Option<CriticalityDiagnostics> = None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                78 => transaction_id = Some(TransactionId::decode(data)?),
                150 => {
                    cells_broadcast_cancelled_list =
                        Some(CellsBroadcastCancelledList::decode(data)?)
                }
                7 => criticality_diagnostics = Some(CriticalityDiagnostics::decode(data)?),
                x => return Err(per_codec_error_new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        let transaction_id = transaction_id.ok_or(per_codec_error_new(format!(
            "Missing mandatory IE transaction_id"
        )))?;
        Ok(Self {
            transaction_id,
            cells_broadcast_cancelled_list,
            criticality_diagnostics,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        let ie = &mut Allocator::new_codec_data();
        self.transaction_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 78, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        if let Some(x) = &self.cells_broadcast_cancelled_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 150, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.criticality_diagnostics {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 7, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        encode::encode_sequence_header(data, true, &BitString::new(), false)?;
        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for PwsCancelResponse {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PwsCancelResponse::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PwsCancelResponse");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PwsCancelResponse");
            e
        })
    }
}
// CellsBroadcastCancelledList
#[derive(Clone, Debug)]
pub struct CellsBroadcastCancelledList(pub NonEmpty<CellsBroadcastCancelledItem>);

impl CellsBroadcastCancelledList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(512), false)?;
            let mut items = vec![];
            for _ in 0..length {
                let _ = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _ = Criticality::decode(data)?;
                let _ = decode::decode_length_determinent(data, None, None, false)?;
                items.push(CellsBroadcastCancelledItem::decode(data)?);
                data.decode_align()?;
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(512), false, self.0.len())?;
        for x in &self.0 {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(data, Some(0), Some(65535), false, 151, false)?;
            Criticality::Reject.encode(data)?;
            encode::encode_length_determinent(data, None, None, false, ie.length_in_bytes())?;
            data.append_aligned(ie);
        }
        Ok(())
    }
}

impl PerCodec for CellsBroadcastCancelledList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        CellsBroadcastCancelledList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CellsBroadcastCancelledList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CellsBroadcastCancelledList");
            e
        })
    }
}
// UeInactivityNotification
#[derive(Clone, Debug)]
pub struct UeInactivityNotification {
    pub gnb_cu_ue_f1ap_id: GnbCuUeF1apId,
    pub gnb_du_ue_f1ap_id: GnbDuUeF1apId,
    pub drb_activity_list: DrbActivityList,
    pub sdt_termination_request: Option<SdtTerminationRequest>,
}

impl UeInactivityNotification {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let _ = decode::decode_sequence_header(data, true, 0)?;
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut gnb_cu_ue_f1ap_id: Option<GnbCuUeF1apId> = None;
        let mut gnb_du_ue_f1ap_id: Option<GnbDuUeF1apId> = None;
        let mut drb_activity_list: Option<DrbActivityList> = None;
        let mut sdt_termination_request: Option<SdtTerminationRequest> = None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                40 => gnb_cu_ue_f1ap_id = Some(GnbCuUeF1apId::decode(data)?),
                41 => gnb_du_ue_f1ap_id = Some(GnbDuUeF1apId::decode(data)?),
                100 => drb_activity_list = Some(DrbActivityList::decode(data)?),
                635 => sdt_termination_request = Some(SdtTerminationRequest::decode(data)?),
                x => return Err(per_codec_error_new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        let gnb_cu_ue_f1ap_id = gnb_cu_ue_f1ap_id.ok_or(per_codec_error_new(format!(
            "Missing mandatory IE gnb_cu_ue_f1ap_id"
        )))?;
        let gnb_du_ue_f1ap_id = gnb_du_ue_f1ap_id.ok_or(per_codec_error_new(format!(
            "Missing mandatory IE gnb_du_ue_f1ap_id"
        )))?;
        let drb_activity_list = drb_activity_list.ok_or(per_codec_error_new(format!(
            "Missing mandatory IE drb_activity_list"
        )))?;
        Ok(Self {
            gnb_cu_ue_f1ap_id,
            gnb_du_ue_f1ap_id,
            drb_activity_list,
            sdt_termination_request,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        let ie = &mut Allocator::new_codec_data();
        self.gnb_cu_ue_f1ap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 40, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.gnb_du_ue_f1ap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 41, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.drb_activity_list.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 100, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        if let Some(x) = &self.sdt_termination_request {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 635, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        encode::encode_sequence_header(data, true, &BitString::new(), false)?;
        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for UeInactivityNotification {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        UeInactivityNotification::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UeInactivityNotification");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UeInactivityNotification");
            e
        })
    }
}
// DrbActivityList
#[derive(Clone, Debug)]
pub struct DrbActivityList(pub NonEmpty<DrbActivityItem>);

impl DrbActivityList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(64), false)?;
            let mut items = vec![];
            for _ in 0..length {
                let _ = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _ = Criticality::decode(data)?;
                let _ = decode::decode_length_determinent(data, None, None, false)?;
                items.push(DrbActivityItem::decode(data)?);
                data.decode_align()?;
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(64), false, self.0.len())?;
        for x in &self.0 {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(data, Some(0), Some(65535), false, 99, false)?;
            Criticality::Reject.encode(data)?;
            encode::encode_length_determinent(data, None, None, false, ie.length_in_bytes())?;
            data.append_aligned(ie);
        }
        Ok(())
    }
}

impl PerCodec for DrbActivityList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        DrbActivityList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DrbActivityList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DrbActivityList");
            e
        })
    }
}
// InitialUlRrcMessageTransfer
#[derive(Clone, Debug)]
pub struct InitialUlRrcMessageTransfer {
    pub gnb_du_ue_f1ap_id: GnbDuUeF1apId,
    pub nr_cgi: NrCgi,
    pub c_rnti: CRnti,
    pub rrc_container: RrcContainer,
    pub du_to_cu_rrc_container: Option<DuToCuRrcContainer>,
    pub sul_access_indication: Option<SulAccessIndication>,
    pub transaction_id: TransactionId,
    pub ran_ue_id: Option<RanUeId>,
    pub rrc_container_rrc_setup_complete: Option<RrcContainerRrcSetupComplete>,
    pub nr_red_cap_ue_indication: Option<NrRedCapUeIndication>,
    pub sdt_information: Option<SdtInformation>,
    pub sidelink_relay_configuration: Option<SidelinkRelayConfiguration>,
    pub nr_e_red_cap_ue_indication: Option<NrERedCapUeIndication>,
}

impl InitialUlRrcMessageTransfer {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let _ = decode::decode_sequence_header(data, true, 0)?;
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut gnb_du_ue_f1ap_id: Option<GnbDuUeF1apId> = None;
        let mut nr_cgi: Option<NrCgi> = None;
        let mut c_rnti: Option<CRnti> = None;
        let mut rrc_container: Option<RrcContainer> = None;
        let mut du_to_cu_rrc_container: Option<DuToCuRrcContainer> = None;
        let mut sul_access_indication: Option<SulAccessIndication> = None;
        let mut transaction_id: Option<TransactionId> = None;
        let mut ran_ue_id: Option<RanUeId> = None;
        let mut rrc_container_rrc_setup_complete: Option<RrcContainerRrcSetupComplete> = None;
        let mut nr_red_cap_ue_indication: Option<NrRedCapUeIndication> = None;
        let mut sdt_information: Option<SdtInformation> = None;
        let mut sidelink_relay_configuration: Option<SidelinkRelayConfiguration> = None;
        let mut nr_e_red_cap_ue_indication: Option<NrERedCapUeIndication> = None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                41 => gnb_du_ue_f1ap_id = Some(GnbDuUeF1apId::decode(data)?),
                111 => nr_cgi = Some(NrCgi::decode(data)?),
                95 => c_rnti = Some(CRnti::decode(data)?),
                50 => rrc_container = Some(RrcContainer::decode(data)?),
                128 => du_to_cu_rrc_container = Some(DuToCuRrcContainer::decode(data)?),
                178 => sul_access_indication = Some(SulAccessIndication::decode(data)?),
                78 => transaction_id = Some(TransactionId::decode(data)?),
                226 => ran_ue_id = Some(RanUeId::decode(data)?),
                241 => {
                    rrc_container_rrc_setup_complete =
                        Some(RrcContainerRrcSetupComplete::decode(data)?)
                }
                578 => nr_red_cap_ue_indication = Some(NrRedCapUeIndication::decode(data)?),
                592 => sdt_information = Some(SdtInformation::decode(data)?),
                617 => {
                    sidelink_relay_configuration = Some(SidelinkRelayConfiguration::decode(data)?)
                }
                783 => nr_e_red_cap_ue_indication = Some(NrERedCapUeIndication::decode(data)?),
                x => return Err(per_codec_error_new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        let gnb_du_ue_f1ap_id = gnb_du_ue_f1ap_id.ok_or(per_codec_error_new(format!(
            "Missing mandatory IE gnb_du_ue_f1ap_id"
        )))?;
        let nr_cgi = nr_cgi.ok_or(per_codec_error_new(format!("Missing mandatory IE nr_cgi")))?;
        let c_rnti = c_rnti.ok_or(per_codec_error_new(format!("Missing mandatory IE c_rnti")))?;
        let rrc_container = rrc_container.ok_or(per_codec_error_new(format!(
            "Missing mandatory IE rrc_container"
        )))?;
        let transaction_id = transaction_id.ok_or(per_codec_error_new(format!(
            "Missing mandatory IE transaction_id"
        )))?;
        Ok(Self {
            gnb_du_ue_f1ap_id,
            nr_cgi,
            c_rnti,
            rrc_container,
            du_to_cu_rrc_container,
            sul_access_indication,
            transaction_id,
            ran_ue_id,
            rrc_container_rrc_setup_complete,
            nr_red_cap_ue_indication,
            sdt_information,
            sidelink_relay_configuration,
            nr_e_red_cap_ue_indication,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        let ie = &mut Allocator::new_codec_data();
        self.gnb_du_ue_f1ap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 41, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.nr_cgi.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 111, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.c_rnti.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 95, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.rrc_container.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 50, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        if let Some(x) = &self.du_to_cu_rrc_container {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 128, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.sul_access_indication {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 178, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        let ie = &mut Allocator::new_codec_data();
        self.transaction_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 78, false)?;
        Criticality::Ignore.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        if let Some(x) = &self.ran_ue_id {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 226, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.rrc_container_rrc_setup_complete {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 241, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.nr_red_cap_ue_indication {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 578, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.sdt_information {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 592, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.sidelink_relay_configuration {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 617, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.nr_e_red_cap_ue_indication {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 783, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        encode::encode_sequence_header(data, true, &BitString::new(), false)?;
        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for InitialUlRrcMessageTransfer {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        InitialUlRrcMessageTransfer::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("InitialUlRrcMessageTransfer");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("InitialUlRrcMessageTransfer");
            e
        })
    }
}
// DlRrcMessageTransfer
#[derive(Clone, Debug)]
pub struct DlRrcMessageTransfer {
    pub gnb_cu_ue_f1ap_id: GnbCuUeF1apId,
    pub gnb_du_ue_f1ap_id: GnbDuUeF1apId,
    pub old_gnb_du_ue_f1ap_id: Option<GnbDuUeF1apId>,
    pub srb_id: SrbId,
    pub execute_duplication: Option<ExecuteDuplication>,
    pub rrc_container: RrcContainer,
    pub rat_frequency_priority_information: Option<RatFrequencyPriorityInformation>,
    pub rrc_delivery_status_request: Option<RrcDeliveryStatusRequest>,
    pub ue_context_not_retrievable: Option<UeContextNotRetrievable>,
    pub redirected_rrc_message: Option<Vec<u8>>,
    pub plmn_assistance_info_for_net_shar: Option<PlmnIdentity>,
    pub new_gnb_cu_ue_f1ap_id: Option<GnbCuUeF1apId>,
    pub additional_rrm_priority_index: Option<AdditionalRrmPriorityIndex>,
    pub srb_mapping_info: Option<UuRlcChannelId>,
}

impl DlRrcMessageTransfer {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let _ = decode::decode_sequence_header(data, true, 0)?;
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut gnb_cu_ue_f1ap_id: Option<GnbCuUeF1apId> = None;
        let mut gnb_du_ue_f1ap_id: Option<GnbDuUeF1apId> = None;
        let mut old_gnb_du_ue_f1ap_id: Option<GnbDuUeF1apId> = None;
        let mut srb_id: Option<SrbId> = None;
        let mut execute_duplication: Option<ExecuteDuplication> = None;
        let mut rrc_container: Option<RrcContainer> = None;
        let mut rat_frequency_priority_information: Option<RatFrequencyPriorityInformation> = None;
        let mut rrc_delivery_status_request: Option<RrcDeliveryStatusRequest> = None;
        let mut ue_context_not_retrievable: Option<UeContextNotRetrievable> = None;
        let mut redirected_rrc_message: Option<Vec<u8>> = None;
        let mut plmn_assistance_info_for_net_shar: Option<PlmnIdentity> = None;
        let mut new_gnb_cu_ue_f1ap_id: Option<GnbCuUeF1apId> = None;
        let mut additional_rrm_priority_index: Option<AdditionalRrmPriorityIndex> = None;
        let mut srb_mapping_info: Option<UuRlcChannelId> = None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                40 => gnb_cu_ue_f1ap_id = Some(GnbCuUeF1apId::decode(data)?),
                41 => gnb_du_ue_f1ap_id = Some(GnbDuUeF1apId::decode(data)?),
                47 => old_gnb_du_ue_f1ap_id = Some(GnbDuUeF1apId::decode(data)?),
                64 => srb_id = Some(SrbId::decode(data)?),
                109 => execute_duplication = Some(ExecuteDuplication::decode(data)?),
                50 => rrc_container = Some(RrcContainer::decode(data)?),
                108 => {
                    rat_frequency_priority_information =
                        Some(RatFrequencyPriorityInformation::decode(data)?)
                }
                184 => rrc_delivery_status_request = Some(RrcDeliveryStatusRequest::decode(data)?),
                222 => ue_context_not_retrievable = Some(UeContextNotRetrievable::decode(data)?),
                218 => {
                    redirected_rrc_message =
                        Some(decode::decode_octetstring(data, None, None, false)?)
                }
                221 => plmn_assistance_info_for_net_shar = Some(PlmnIdentity::decode(data)?),
                217 => new_gnb_cu_ue_f1ap_id = Some(GnbCuUeF1apId::decode(data)?),
                248 => {
                    additional_rrm_priority_index = Some(AdditionalRrmPriorityIndex::decode(data)?)
                }
                597 => srb_mapping_info = Some(UuRlcChannelId::decode(data)?),
                x => return Err(per_codec_error_new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        let gnb_cu_ue_f1ap_id = gnb_cu_ue_f1ap_id.ok_or(per_codec_error_new(format!(
            "Missing mandatory IE gnb_cu_ue_f1ap_id"
        )))?;
        let gnb_du_ue_f1ap_id = gnb_du_ue_f1ap_id.ok_or(per_codec_error_new(format!(
            "Missing mandatory IE gnb_du_ue_f1ap_id"
        )))?;
        let srb_id = srb_id.ok_or(per_codec_error_new(format!("Missing mandatory IE srb_id")))?;
        let rrc_container = rrc_container.ok_or(per_codec_error_new(format!(
            "Missing mandatory IE rrc_container"
        )))?;
        Ok(Self {
            gnb_cu_ue_f1ap_id,
            gnb_du_ue_f1ap_id,
            old_gnb_du_ue_f1ap_id,
            srb_id,
            execute_duplication,
            rrc_container,
            rat_frequency_priority_information,
            rrc_delivery_status_request,
            ue_context_not_retrievable,
            redirected_rrc_message,
            plmn_assistance_info_for_net_shar,
            new_gnb_cu_ue_f1ap_id,
            additional_rrm_priority_index,
            srb_mapping_info,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        let ie = &mut Allocator::new_codec_data();
        self.gnb_cu_ue_f1ap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 40, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.gnb_du_ue_f1ap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 41, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        if let Some(x) = &self.old_gnb_du_ue_f1ap_id {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 47, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        let ie = &mut Allocator::new_codec_data();
        self.srb_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 64, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        if let Some(x) = &self.execute_duplication {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 109, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        let ie = &mut Allocator::new_codec_data();
        self.rrc_container.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 50, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        if let Some(x) = &self.rat_frequency_priority_information {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 108, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.rrc_delivery_status_request {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 184, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.ue_context_not_retrievable {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 222, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.redirected_rrc_message {
            let ie = &mut Allocator::new_codec_data();
            encode::encode_octetstring(ie, None, None, false, &x, false)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 218, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.plmn_assistance_info_for_net_shar {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 221, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.new_gnb_cu_ue_f1ap_id {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 217, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.additional_rrm_priority_index {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 248, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.srb_mapping_info {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 597, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        encode::encode_sequence_header(data, true, &BitString::new(), false)?;
        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for DlRrcMessageTransfer {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        DlRrcMessageTransfer::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DlRrcMessageTransfer");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DlRrcMessageTransfer");
            e
        })
    }
}
// UlRrcMessageTransfer
#[derive(Clone, Debug)]
pub struct UlRrcMessageTransfer {
    pub gnb_cu_ue_f1ap_id: GnbCuUeF1apId,
    pub gnb_du_ue_f1ap_id: GnbDuUeF1apId,
    pub srb_id: SrbId,
    pub rrc_container: RrcContainer,
    pub selected_plmn_id: Option<PlmnIdentity>,
    pub new_gnb_du_ue_f1ap_id: Option<GnbDuUeF1apId>,
}

impl UlRrcMessageTransfer {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let _ = decode::decode_sequence_header(data, true, 0)?;
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut gnb_cu_ue_f1ap_id: Option<GnbCuUeF1apId> = None;
        let mut gnb_du_ue_f1ap_id: Option<GnbDuUeF1apId> = None;
        let mut srb_id: Option<SrbId> = None;
        let mut rrc_container: Option<RrcContainer> = None;
        let mut selected_plmn_id: Option<PlmnIdentity> = None;
        let mut new_gnb_du_ue_f1ap_id: Option<GnbDuUeF1apId> = None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                40 => gnb_cu_ue_f1ap_id = Some(GnbCuUeF1apId::decode(data)?),
                41 => gnb_du_ue_f1ap_id = Some(GnbDuUeF1apId::decode(data)?),
                64 => srb_id = Some(SrbId::decode(data)?),
                50 => rrc_container = Some(RrcContainer::decode(data)?),
                224 => selected_plmn_id = Some(PlmnIdentity::decode(data)?),
                219 => new_gnb_du_ue_f1ap_id = Some(GnbDuUeF1apId::decode(data)?),
                x => return Err(per_codec_error_new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        let gnb_cu_ue_f1ap_id = gnb_cu_ue_f1ap_id.ok_or(per_codec_error_new(format!(
            "Missing mandatory IE gnb_cu_ue_f1ap_id"
        )))?;
        let gnb_du_ue_f1ap_id = gnb_du_ue_f1ap_id.ok_or(per_codec_error_new(format!(
            "Missing mandatory IE gnb_du_ue_f1ap_id"
        )))?;
        let srb_id = srb_id.ok_or(per_codec_error_new(format!("Missing mandatory IE srb_id")))?;
        let rrc_container = rrc_container.ok_or(per_codec_error_new(format!(
            "Missing mandatory IE rrc_container"
        )))?;
        Ok(Self {
            gnb_cu_ue_f1ap_id,
            gnb_du_ue_f1ap_id,
            srb_id,
            rrc_container,
            selected_plmn_id,
            new_gnb_du_ue_f1ap_id,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        let ie = &mut Allocator::new_codec_data();
        self.gnb_cu_ue_f1ap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 40, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.gnb_du_ue_f1ap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 41, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.srb_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 64, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.rrc_container.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 50, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        if let Some(x) = &self.selected_plmn_id {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 224, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.new_gnb_du_ue_f1ap_id {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 219, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        encode::encode_sequence_header(data, true, &BitString::new(), false)?;
        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for UlRrcMessageTransfer {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        UlRrcMessageTransfer::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UlRrcMessageTransfer");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UlRrcMessageTransfer");
            e
        })
    }
}
// PrivateMessage
#[derive(Clone, Debug)]
pub struct PrivateMessage {}

impl PrivateMessage {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (_optionals, _extensions_present) = decode::decode_sequence_header(data, true, 0)?;

        Ok(Self {})
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let optionals = BitString::new();

        encode::encode_sequence_header(data, true, &optionals, false)?;

        Ok(())
    }
}

impl PerCodec for PrivateMessage {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PrivateMessage::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PrivateMessage");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PrivateMessage");
            e
        })
    }
}
// SystemInformationDeliveryCommand
#[derive(Clone, Debug)]
pub struct SystemInformationDeliveryCommand {
    pub transaction_id: TransactionId,
    pub nr_cgi: NrCgi,
    pub si_type_list: SiTypeList,
    pub confirmed_ue_id: GnbDuUeF1apId,
}

impl SystemInformationDeliveryCommand {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let _ = decode::decode_sequence_header(data, true, 0)?;
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut transaction_id: Option<TransactionId> = None;
        let mut nr_cgi: Option<NrCgi> = None;
        let mut si_type_list: Option<SiTypeList> = None;
        let mut confirmed_ue_id: Option<GnbDuUeF1apId> = None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                78 => transaction_id = Some(TransactionId::decode(data)?),
                111 => nr_cgi = Some(NrCgi::decode(data)?),
                116 => si_type_list = Some(SiTypeList::decode(data)?),
                156 => confirmed_ue_id = Some(GnbDuUeF1apId::decode(data)?),
                x => return Err(per_codec_error_new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        let transaction_id = transaction_id.ok_or(per_codec_error_new(format!(
            "Missing mandatory IE transaction_id"
        )))?;
        let nr_cgi = nr_cgi.ok_or(per_codec_error_new(format!("Missing mandatory IE nr_cgi")))?;
        let si_type_list = si_type_list.ok_or(per_codec_error_new(format!(
            "Missing mandatory IE si_type_list"
        )))?;
        let confirmed_ue_id = confirmed_ue_id.ok_or(per_codec_error_new(format!(
            "Missing mandatory IE confirmed_ue_id"
        )))?;
        Ok(Self {
            transaction_id,
            nr_cgi,
            si_type_list,
            confirmed_ue_id,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        let ie = &mut Allocator::new_codec_data();
        self.transaction_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 78, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.nr_cgi.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 111, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.si_type_list.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 116, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.confirmed_ue_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 156, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        encode::encode_sequence_header(data, true, &BitString::new(), false)?;
        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for SystemInformationDeliveryCommand {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        SystemInformationDeliveryCommand::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SystemInformationDeliveryCommand");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SystemInformationDeliveryCommand");
            e
        })
    }
}
// Paging
#[derive(Clone, Debug)]
pub struct Paging {
    pub ue_identity_index_value: UeIdentityIndexValue,
    pub paging_identity: PagingIdentity,
    pub paging_drx: Option<PagingDrx>,
    pub paging_priority: Option<PagingPriority>,
    pub paging_cell_list: PagingCellList,
    pub paging_origin: Option<PagingOrigin>,
    pub ran_ue_paging_drx: Option<PagingDrx>,
    pub cn_ue_paging_drx: Option<PagingDrx>,
    pub nr_paginge_drx_information: Option<NrPagingeDrxInformation>,
    pub nr_paginge_drx_informationfor_rrc_inactive: Option<NrPagingeDrxInformationforRrcInactive>,
    pub paging_cause: Option<PagingCause>,
    pub peips_assistance_info: Option<PeipsAssistanceInfo>,
    pub ue_paging_capability: Option<UePagingCapability>,
    pub extended_ue_identity_index_value: Option<ExtendedUeIdentityIndexValue>,
    pub hashed_ue_identity_index_value: Option<HashedUeIdentityIndexValue>,
    pub mt_sdt_information: Option<MtSdtInformation>,
    pub nr_paginglonge_drx_informationfor_rrc_inactive:
        Option<NrPaginglongeDrxInformationforRrcInactive>,
}

impl Paging {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let _ = decode::decode_sequence_header(data, true, 0)?;
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut ue_identity_index_value: Option<UeIdentityIndexValue> = None;
        let mut paging_identity: Option<PagingIdentity> = None;
        let mut paging_drx: Option<PagingDrx> = None;
        let mut paging_priority: Option<PagingPriority> = None;
        let mut paging_cell_list: Option<PagingCellList> = None;
        let mut paging_origin: Option<PagingOrigin> = None;
        let mut ran_ue_paging_drx: Option<PagingDrx> = None;
        let mut cn_ue_paging_drx: Option<PagingDrx> = None;
        let mut nr_paginge_drx_information: Option<NrPagingeDrxInformation> = None;
        let mut nr_paginge_drx_informationfor_rrc_inactive: Option<
            NrPagingeDrxInformationforRrcInactive,
        > = None;
        let mut paging_cause: Option<PagingCause> = None;
        let mut peips_assistance_info: Option<PeipsAssistanceInfo> = None;
        let mut ue_paging_capability: Option<UePagingCapability> = None;
        let mut extended_ue_identity_index_value: Option<ExtendedUeIdentityIndexValue> = None;
        let mut hashed_ue_identity_index_value: Option<HashedUeIdentityIndexValue> = None;
        let mut mt_sdt_information: Option<MtSdtInformation> = None;
        let mut nr_paginglonge_drx_informationfor_rrc_inactive: Option<
            NrPaginglongeDrxInformationforRrcInactive,
        > = None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                117 => ue_identity_index_value = Some(UeIdentityIndexValue::decode(data)?),
                127 => paging_identity = Some(PagingIdentity::decode(data)?),
                114 => paging_drx = Some(PagingDrx::decode(data)?),
                115 => paging_priority = Some(PagingPriority::decode(data)?),
                113 => paging_cell_list = Some(PagingCellList::decode(data)?),
                216 => paging_origin = Some(PagingOrigin::decode(data)?),
                580 => ran_ue_paging_drx = Some(PagingDrx::decode(data)?),
                581 => cn_ue_paging_drx = Some(PagingDrx::decode(data)?),
                582 => nr_paginge_drx_information = Some(NrPagingeDrxInformation::decode(data)?),
                583 => {
                    nr_paginge_drx_informationfor_rrc_inactive =
                        Some(NrPagingeDrxInformationforRrcInactive::decode(data)?)
                }
                620 => paging_cause = Some(PagingCause::decode(data)?),
                622 => peips_assistance_info = Some(PeipsAssistanceInfo::decode(data)?),
                623 => ue_paging_capability = Some(UePagingCapability::decode(data)?),
                694 => {
                    extended_ue_identity_index_value =
                        Some(ExtendedUeIdentityIndexValue::decode(data)?)
                }
                698 => {
                    hashed_ue_identity_index_value = Some(HashedUeIdentityIndexValue::decode(data)?)
                }
                713 => mt_sdt_information = Some(MtSdtInformation::decode(data)?),
                785 => {
                    nr_paginglonge_drx_informationfor_rrc_inactive =
                        Some(NrPaginglongeDrxInformationforRrcInactive::decode(data)?)
                }
                x => return Err(per_codec_error_new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        let ue_identity_index_value = ue_identity_index_value.ok_or(per_codec_error_new(
            format!("Missing mandatory IE ue_identity_index_value"),
        ))?;
        let paging_identity = paging_identity.ok_or(per_codec_error_new(format!(
            "Missing mandatory IE paging_identity"
        )))?;
        let paging_cell_list = paging_cell_list.ok_or(per_codec_error_new(format!(
            "Missing mandatory IE paging_cell_list"
        )))?;
        Ok(Self {
            ue_identity_index_value,
            paging_identity,
            paging_drx,
            paging_priority,
            paging_cell_list,
            paging_origin,
            ran_ue_paging_drx,
            cn_ue_paging_drx,
            nr_paginge_drx_information,
            nr_paginge_drx_informationfor_rrc_inactive,
            paging_cause,
            peips_assistance_info,
            ue_paging_capability,
            extended_ue_identity_index_value,
            hashed_ue_identity_index_value,
            mt_sdt_information,
            nr_paginglonge_drx_informationfor_rrc_inactive,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        let ie = &mut Allocator::new_codec_data();
        self.ue_identity_index_value.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 117, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.paging_identity.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 127, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        if let Some(x) = &self.paging_drx {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 114, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.paging_priority {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 115, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        let ie = &mut Allocator::new_codec_data();
        self.paging_cell_list.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 113, false)?;
        Criticality::Ignore.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        if let Some(x) = &self.paging_origin {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 216, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.ran_ue_paging_drx {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 580, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.cn_ue_paging_drx {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 581, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.nr_paginge_drx_information {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 582, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.nr_paginge_drx_informationfor_rrc_inactive {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 583, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.paging_cause {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 620, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.peips_assistance_info {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 622, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.ue_paging_capability {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 623, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.extended_ue_identity_index_value {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 694, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.hashed_ue_identity_index_value {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 698, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.mt_sdt_information {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 713, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.nr_paginglonge_drx_informationfor_rrc_inactive {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 785, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        encode::encode_sequence_header(data, true, &BitString::new(), false)?;
        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for Paging {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Paging::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("Paging");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("Paging");
            e
        })
    }
}
// PagingCellList
#[derive(Clone, Debug)]
pub struct PagingCellList(pub NonEmpty<PagingCellItem>);

impl PagingCellList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(512), false)?;
            let mut items = vec![];
            for _ in 0..length {
                let _ = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _ = Criticality::decode(data)?;
                let _ = decode::decode_length_determinent(data, None, None, false)?;
                items.push(PagingCellItem::decode(data)?);
                data.decode_align()?;
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(512), false, self.0.len())?;
        for x in &self.0 {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(data, Some(0), Some(65535), false, 112, false)?;
            Criticality::Ignore.encode(data)?;
            encode::encode_length_determinent(data, None, None, false, ie.length_in_bytes())?;
            data.append_aligned(ie);
        }
        Ok(())
    }
}

impl PerCodec for PagingCellList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PagingCellList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PagingCellList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PagingCellList");
            e
        })
    }
}
// Notify
#[derive(Clone, Debug)]
pub struct Notify {
    pub gnb_cu_ue_f1ap_id: GnbCuUeF1apId,
    pub gnb_du_ue_f1ap_id: GnbDuUeF1apId,
    pub drb_notify_list: DrbNotifyList,
}

impl Notify {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let _ = decode::decode_sequence_header(data, true, 0)?;
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut gnb_cu_ue_f1ap_id: Option<GnbCuUeF1apId> = None;
        let mut gnb_du_ue_f1ap_id: Option<GnbDuUeF1apId> = None;
        let mut drb_notify_list: Option<DrbNotifyList> = None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                40 => gnb_cu_ue_f1ap_id = Some(GnbCuUeF1apId::decode(data)?),
                41 => gnb_du_ue_f1ap_id = Some(GnbDuUeF1apId::decode(data)?),
                137 => drb_notify_list = Some(DrbNotifyList::decode(data)?),
                x => return Err(per_codec_error_new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        let gnb_cu_ue_f1ap_id = gnb_cu_ue_f1ap_id.ok_or(per_codec_error_new(format!(
            "Missing mandatory IE gnb_cu_ue_f1ap_id"
        )))?;
        let gnb_du_ue_f1ap_id = gnb_du_ue_f1ap_id.ok_or(per_codec_error_new(format!(
            "Missing mandatory IE gnb_du_ue_f1ap_id"
        )))?;
        let drb_notify_list = drb_notify_list.ok_or(per_codec_error_new(format!(
            "Missing mandatory IE drb_notify_list"
        )))?;
        Ok(Self {
            gnb_cu_ue_f1ap_id,
            gnb_du_ue_f1ap_id,
            drb_notify_list,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        let ie = &mut Allocator::new_codec_data();
        self.gnb_cu_ue_f1ap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 40, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.gnb_du_ue_f1ap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 41, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.drb_notify_list.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 137, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        encode::encode_sequence_header(data, true, &BitString::new(), false)?;
        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for Notify {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Notify::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("Notify");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("Notify");
            e
        })
    }
}
// DrbNotifyList
#[derive(Clone, Debug)]
pub struct DrbNotifyList(pub NonEmpty<DrbNotifyItem>);

impl DrbNotifyList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(64), false)?;
            let mut items = vec![];
            for _ in 0..length {
                let _ = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _ = Criticality::decode(data)?;
                let _ = decode::decode_length_determinent(data, None, None, false)?;
                items.push(DrbNotifyItem::decode(data)?);
                data.decode_align()?;
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(64), false, self.0.len())?;
        for x in &self.0 {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(data, Some(0), Some(65535), false, 136, false)?;
            Criticality::Reject.encode(data)?;
            encode::encode_length_determinent(data, None, None, false, ie.length_in_bytes())?;
            data.append_aligned(ie);
        }
        Ok(())
    }
}

impl PerCodec for DrbNotifyList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        DrbNotifyList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DrbNotifyList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DrbNotifyList");
            e
        })
    }
}
// NetworkAccessRateReduction
#[derive(Clone, Debug)]
pub struct NetworkAccessRateReduction {
    pub transaction_id: TransactionId,
    pub uac_assistance_info: UacAssistanceInfo,
}

impl NetworkAccessRateReduction {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let _ = decode::decode_sequence_header(data, true, 0)?;
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut transaction_id: Option<TransactionId> = None;
        let mut uac_assistance_info: Option<UacAssistanceInfo> = None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                78 => transaction_id = Some(TransactionId::decode(data)?),
                225 => uac_assistance_info = Some(UacAssistanceInfo::decode(data)?),
                x => return Err(per_codec_error_new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        let transaction_id = transaction_id.ok_or(per_codec_error_new(format!(
            "Missing mandatory IE transaction_id"
        )))?;
        let uac_assistance_info = uac_assistance_info.ok_or(per_codec_error_new(format!(
            "Missing mandatory IE uac_assistance_info"
        )))?;
        Ok(Self {
            transaction_id,
            uac_assistance_info,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        let ie = &mut Allocator::new_codec_data();
        self.transaction_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 78, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.uac_assistance_info.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 225, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        encode::encode_sequence_header(data, true, &BitString::new(), false)?;
        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for NetworkAccessRateReduction {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        NetworkAccessRateReduction::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NetworkAccessRateReduction");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NetworkAccessRateReduction");
            e
        })
    }
}
// PwsRestartIndication
#[derive(Clone, Debug)]
pub struct PwsRestartIndication {
    pub transaction_id: TransactionId,
    pub nr_cgi_list_for_restart_list: NrCgiListForRestartList,
}

impl PwsRestartIndication {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let _ = decode::decode_sequence_header(data, true, 0)?;
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut transaction_id: Option<TransactionId> = None;
        let mut nr_cgi_list_for_restart_list: Option<NrCgiListForRestartList> = None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                78 => transaction_id = Some(TransactionId::decode(data)?),
                152 => nr_cgi_list_for_restart_list = Some(NrCgiListForRestartList::decode(data)?),
                x => return Err(per_codec_error_new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        let transaction_id = transaction_id.ok_or(per_codec_error_new(format!(
            "Missing mandatory IE transaction_id"
        )))?;
        let nr_cgi_list_for_restart_list = nr_cgi_list_for_restart_list.ok_or(
            per_codec_error_new(format!("Missing mandatory IE nr_cgi_list_for_restart_list")),
        )?;
        Ok(Self {
            transaction_id,
            nr_cgi_list_for_restart_list,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        let ie = &mut Allocator::new_codec_data();
        self.transaction_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 78, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.nr_cgi_list_for_restart_list.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 152, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        encode::encode_sequence_header(data, true, &BitString::new(), false)?;
        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for PwsRestartIndication {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PwsRestartIndication::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PwsRestartIndication");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PwsRestartIndication");
            e
        })
    }
}
// NrCgiListForRestartList
#[derive(Clone, Debug)]
pub struct NrCgiListForRestartList(pub NonEmpty<NrCgiListForRestartItem>);

impl NrCgiListForRestartList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(512), false)?;
            let mut items = vec![];
            for _ in 0..length {
                let _ = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _ = Criticality::decode(data)?;
                let _ = decode::decode_length_determinent(data, None, None, false)?;
                items.push(NrCgiListForRestartItem::decode(data)?);
                data.decode_align()?;
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(512), false, self.0.len())?;
        for x in &self.0 {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(data, Some(0), Some(65535), false, 153, false)?;
            Criticality::Reject.encode(data)?;
            encode::encode_length_determinent(data, None, None, false, ie.length_in_bytes())?;
            data.append_aligned(ie);
        }
        Ok(())
    }
}

impl PerCodec for NrCgiListForRestartList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        NrCgiListForRestartList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NrCgiListForRestartList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NrCgiListForRestartList");
            e
        })
    }
}
// PwsFailureIndication
#[derive(Clone, Debug)]
pub struct PwsFailureIndication {
    pub transaction_id: TransactionId,
    pub pws_failed_nr_cgi_list: Option<PwsFailedNrCgiList>,
}

impl PwsFailureIndication {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let _ = decode::decode_sequence_header(data, true, 0)?;
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut transaction_id: Option<TransactionId> = None;
        let mut pws_failed_nr_cgi_list: Option<PwsFailedNrCgiList> = None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                78 => transaction_id = Some(TransactionId::decode(data)?),
                154 => pws_failed_nr_cgi_list = Some(PwsFailedNrCgiList::decode(data)?),
                x => return Err(per_codec_error_new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        let transaction_id = transaction_id.ok_or(per_codec_error_new(format!(
            "Missing mandatory IE transaction_id"
        )))?;
        Ok(Self {
            transaction_id,
            pws_failed_nr_cgi_list,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        let ie = &mut Allocator::new_codec_data();
        self.transaction_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 78, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        if let Some(x) = &self.pws_failed_nr_cgi_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 154, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        encode::encode_sequence_header(data, true, &BitString::new(), false)?;
        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for PwsFailureIndication {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PwsFailureIndication::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PwsFailureIndication");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PwsFailureIndication");
            e
        })
    }
}
// PwsFailedNrCgiList
#[derive(Clone, Debug)]
pub struct PwsFailedNrCgiList(pub NonEmpty<PwsFailedNrCgiItem>);

impl PwsFailedNrCgiList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(512), false)?;
            let mut items = vec![];
            for _ in 0..length {
                let _ = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _ = Criticality::decode(data)?;
                let _ = decode::decode_length_determinent(data, None, None, false)?;
                items.push(PwsFailedNrCgiItem::decode(data)?);
                data.decode_align()?;
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(512), false, self.0.len())?;
        for x in &self.0 {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(data, Some(0), Some(65535), false, 155, false)?;
            Criticality::Reject.encode(data)?;
            encode::encode_length_determinent(data, None, None, false, ie.length_in_bytes())?;
            data.append_aligned(ie);
        }
        Ok(())
    }
}

impl PerCodec for PwsFailedNrCgiList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PwsFailedNrCgiList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PwsFailedNrCgiList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PwsFailedNrCgiList");
            e
        })
    }
}
// GnbDuStatusIndication
#[derive(Clone, Debug)]
pub struct GnbDuStatusIndication {
    pub transaction_id: TransactionId,
    pub gnb_du_overload_information: GnbDuOverloadInformation,
    pub iab_congestion_indication: Option<IabCongestionIndication>,
}

impl GnbDuStatusIndication {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let _ = decode::decode_sequence_header(data, true, 0)?;
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut transaction_id: Option<TransactionId> = None;
        let mut gnb_du_overload_information: Option<GnbDuOverloadInformation> = None;
        let mut iab_congestion_indication: Option<IabCongestionIndication> = None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                78 => transaction_id = Some(TransactionId::decode(data)?),
                172 => gnb_du_overload_information = Some(GnbDuOverloadInformation::decode(data)?),
                509 => iab_congestion_indication = Some(IabCongestionIndication::decode(data)?),
                x => return Err(per_codec_error_new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        let transaction_id = transaction_id.ok_or(per_codec_error_new(format!(
            "Missing mandatory IE transaction_id"
        )))?;
        let gnb_du_overload_information = gnb_du_overload_information.ok_or(
            per_codec_error_new(format!("Missing mandatory IE gnb_du_overload_information")),
        )?;
        Ok(Self {
            transaction_id,
            gnb_du_overload_information,
            iab_congestion_indication,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        let ie = &mut Allocator::new_codec_data();
        self.transaction_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 78, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.gnb_du_overload_information.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 172, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        if let Some(x) = &self.iab_congestion_indication {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 509, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        encode::encode_sequence_header(data, true, &BitString::new(), false)?;
        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for GnbDuStatusIndication {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        GnbDuStatusIndication::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("GnbDuStatusIndication");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("GnbDuStatusIndication");
            e
        })
    }
}
// RrcDeliveryReport
#[derive(Clone, Debug)]
pub struct RrcDeliveryReport {
    pub gnb_cu_ue_f1ap_id: GnbCuUeF1apId,
    pub gnb_du_ue_f1ap_id: GnbDuUeF1apId,
    pub rrc_delivery_status: RrcDeliveryStatus,
    pub srb_id: SrbId,
}

impl RrcDeliveryReport {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let _ = decode::decode_sequence_header(data, true, 0)?;
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut gnb_cu_ue_f1ap_id: Option<GnbCuUeF1apId> = None;
        let mut gnb_du_ue_f1ap_id: Option<GnbDuUeF1apId> = None;
        let mut rrc_delivery_status: Option<RrcDeliveryStatus> = None;
        let mut srb_id: Option<SrbId> = None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                40 => gnb_cu_ue_f1ap_id = Some(GnbCuUeF1apId::decode(data)?),
                41 => gnb_du_ue_f1ap_id = Some(GnbDuUeF1apId::decode(data)?),
                185 => rrc_delivery_status = Some(RrcDeliveryStatus::decode(data)?),
                64 => srb_id = Some(SrbId::decode(data)?),
                x => return Err(per_codec_error_new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        let gnb_cu_ue_f1ap_id = gnb_cu_ue_f1ap_id.ok_or(per_codec_error_new(format!(
            "Missing mandatory IE gnb_cu_ue_f1ap_id"
        )))?;
        let gnb_du_ue_f1ap_id = gnb_du_ue_f1ap_id.ok_or(per_codec_error_new(format!(
            "Missing mandatory IE gnb_du_ue_f1ap_id"
        )))?;
        let rrc_delivery_status = rrc_delivery_status.ok_or(per_codec_error_new(format!(
            "Missing mandatory IE rrc_delivery_status"
        )))?;
        let srb_id = srb_id.ok_or(per_codec_error_new(format!("Missing mandatory IE srb_id")))?;
        Ok(Self {
            gnb_cu_ue_f1ap_id,
            gnb_du_ue_f1ap_id,
            rrc_delivery_status,
            srb_id,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        let ie = &mut Allocator::new_codec_data();
        self.gnb_cu_ue_f1ap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 40, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.gnb_du_ue_f1ap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 41, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.rrc_delivery_status.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 185, false)?;
        Criticality::Ignore.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.srb_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 64, false)?;
        Criticality::Ignore.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        encode::encode_sequence_header(data, true, &BitString::new(), false)?;
        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for RrcDeliveryReport {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        RrcDeliveryReport::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("RrcDeliveryReport");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("RrcDeliveryReport");
            e
        })
    }
}
// F1RemovalRequest
#[derive(Clone, Debug)]
pub struct F1RemovalRequest {
    pub transaction_id: TransactionId,
}

impl F1RemovalRequest {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let _ = decode::decode_sequence_header(data, true, 0)?;
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut transaction_id: Option<TransactionId> = None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                78 => transaction_id = Some(TransactionId::decode(data)?),
                x => return Err(per_codec_error_new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        let transaction_id = transaction_id.ok_or(per_codec_error_new(format!(
            "Missing mandatory IE transaction_id"
        )))?;
        Ok(Self { transaction_id })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        let ie = &mut Allocator::new_codec_data();
        self.transaction_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 78, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        encode::encode_sequence_header(data, true, &BitString::new(), false)?;
        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for F1RemovalRequest {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        F1RemovalRequest::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("F1RemovalRequest");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("F1RemovalRequest");
            e
        })
    }
}
// F1RemovalResponse
#[derive(Clone, Debug)]
pub struct F1RemovalResponse {
    pub transaction_id: TransactionId,
    pub criticality_diagnostics: Option<CriticalityDiagnostics>,
}

impl F1RemovalResponse {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let _ = decode::decode_sequence_header(data, true, 0)?;
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut transaction_id: Option<TransactionId> = None;
        let mut criticality_diagnostics: Option<CriticalityDiagnostics> = None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                78 => transaction_id = Some(TransactionId::decode(data)?),
                7 => criticality_diagnostics = Some(CriticalityDiagnostics::decode(data)?),
                x => return Err(per_codec_error_new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        let transaction_id = transaction_id.ok_or(per_codec_error_new(format!(
            "Missing mandatory IE transaction_id"
        )))?;
        Ok(Self {
            transaction_id,
            criticality_diagnostics,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        let ie = &mut Allocator::new_codec_data();
        self.transaction_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 78, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        if let Some(x) = &self.criticality_diagnostics {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 7, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        encode::encode_sequence_header(data, true, &BitString::new(), false)?;
        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for F1RemovalResponse {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        F1RemovalResponse::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("F1RemovalResponse");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("F1RemovalResponse");
            e
        })
    }
}
// F1RemovalFailure
#[derive(Clone, Debug)]
pub struct F1RemovalFailure {
    pub transaction_id: TransactionId,
    pub cause: Cause,
    pub criticality_diagnostics: Option<CriticalityDiagnostics>,
}

impl F1RemovalFailure {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let _ = decode::decode_sequence_header(data, true, 0)?;
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut transaction_id: Option<TransactionId> = None;
        let mut cause: Option<Cause> = None;
        let mut criticality_diagnostics: Option<CriticalityDiagnostics> = None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                78 => transaction_id = Some(TransactionId::decode(data)?),
                0 => cause = Some(Cause::decode(data)?),
                7 => criticality_diagnostics = Some(CriticalityDiagnostics::decode(data)?),
                x => return Err(per_codec_error_new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        let transaction_id = transaction_id.ok_or(per_codec_error_new(format!(
            "Missing mandatory IE transaction_id"
        )))?;
        let cause = cause.ok_or(per_codec_error_new(format!("Missing mandatory IE cause")))?;
        Ok(Self {
            transaction_id,
            cause,
            criticality_diagnostics,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        let ie = &mut Allocator::new_codec_data();
        self.transaction_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 78, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.cause.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 0, false)?;
        Criticality::Ignore.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        if let Some(x) = &self.criticality_diagnostics {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 7, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        encode::encode_sequence_header(data, true, &BitString::new(), false)?;
        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for F1RemovalFailure {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        F1RemovalFailure::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("F1RemovalFailure");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("F1RemovalFailure");
            e
        })
    }
}
// TraceStart
#[derive(Clone, Debug)]
pub struct TraceStart {
    pub gnb_cu_ue_f1ap_id: GnbCuUeF1apId,
    pub gnb_du_ue_f1ap_id: GnbDuUeF1apId,
    pub trace_activation: TraceActivation,
}

impl TraceStart {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let _ = decode::decode_sequence_header(data, true, 0)?;
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut gnb_cu_ue_f1ap_id: Option<GnbCuUeF1apId> = None;
        let mut gnb_du_ue_f1ap_id: Option<GnbDuUeF1apId> = None;
        let mut trace_activation: Option<TraceActivation> = None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                40 => gnb_cu_ue_f1ap_id = Some(GnbCuUeF1apId::decode(data)?),
                41 => gnb_du_ue_f1ap_id = Some(GnbDuUeF1apId::decode(data)?),
                242 => trace_activation = Some(TraceActivation::decode(data)?),
                x => return Err(per_codec_error_new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        let gnb_cu_ue_f1ap_id = gnb_cu_ue_f1ap_id.ok_or(per_codec_error_new(format!(
            "Missing mandatory IE gnb_cu_ue_f1ap_id"
        )))?;
        let gnb_du_ue_f1ap_id = gnb_du_ue_f1ap_id.ok_or(per_codec_error_new(format!(
            "Missing mandatory IE gnb_du_ue_f1ap_id"
        )))?;
        let trace_activation = trace_activation.ok_or(per_codec_error_new(format!(
            "Missing mandatory IE trace_activation"
        )))?;
        Ok(Self {
            gnb_cu_ue_f1ap_id,
            gnb_du_ue_f1ap_id,
            trace_activation,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        let ie = &mut Allocator::new_codec_data();
        self.gnb_cu_ue_f1ap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 40, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.gnb_du_ue_f1ap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 41, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.trace_activation.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 242, false)?;
        Criticality::Ignore.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        encode::encode_sequence_header(data, true, &BitString::new(), false)?;
        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for TraceStart {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        TraceStart::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TraceStart");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TraceStart");
            e
        })
    }
}
// DeactivateTrace
#[derive(Clone, Debug)]
pub struct DeactivateTrace {
    pub gnb_cu_ue_f1ap_id: GnbCuUeF1apId,
    pub gnb_du_ue_f1ap_id: GnbDuUeF1apId,
    pub trace_id: TraceId,
}

impl DeactivateTrace {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let _ = decode::decode_sequence_header(data, true, 0)?;
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut gnb_cu_ue_f1ap_id: Option<GnbCuUeF1apId> = None;
        let mut gnb_du_ue_f1ap_id: Option<GnbDuUeF1apId> = None;
        let mut trace_id: Option<TraceId> = None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                40 => gnb_cu_ue_f1ap_id = Some(GnbCuUeF1apId::decode(data)?),
                41 => gnb_du_ue_f1ap_id = Some(GnbDuUeF1apId::decode(data)?),
                243 => trace_id = Some(TraceId::decode(data)?),
                x => return Err(per_codec_error_new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        let gnb_cu_ue_f1ap_id = gnb_cu_ue_f1ap_id.ok_or(per_codec_error_new(format!(
            "Missing mandatory IE gnb_cu_ue_f1ap_id"
        )))?;
        let gnb_du_ue_f1ap_id = gnb_du_ue_f1ap_id.ok_or(per_codec_error_new(format!(
            "Missing mandatory IE gnb_du_ue_f1ap_id"
        )))?;
        let trace_id = trace_id.ok_or(per_codec_error_new(format!(
            "Missing mandatory IE trace_id"
        )))?;
        Ok(Self {
            gnb_cu_ue_f1ap_id,
            gnb_du_ue_f1ap_id,
            trace_id,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        let ie = &mut Allocator::new_codec_data();
        self.gnb_cu_ue_f1ap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 40, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.gnb_du_ue_f1ap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 41, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.trace_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 243, false)?;
        Criticality::Ignore.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        encode::encode_sequence_header(data, true, &BitString::new(), false)?;
        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for DeactivateTrace {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        DeactivateTrace::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DeactivateTrace");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DeactivateTrace");
            e
        })
    }
}
// CellTrafficTrace
#[derive(Clone, Debug)]
pub struct CellTrafficTrace {
    pub gnb_cu_ue_f1ap_id: GnbCuUeF1apId,
    pub gnb_du_ue_f1ap_id: GnbDuUeF1apId,
    pub trace_id: TraceId,
    pub trace_collection_entity_ip_address: TransportLayerAddress,
    pub privacy_indicator: Option<PrivacyIndicator>,
    pub trace_collection_entity_uri: Option<UriAddress>,
}

impl CellTrafficTrace {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let _ = decode::decode_sequence_header(data, true, 0)?;
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut gnb_cu_ue_f1ap_id: Option<GnbCuUeF1apId> = None;
        let mut gnb_du_ue_f1ap_id: Option<GnbDuUeF1apId> = None;
        let mut trace_id: Option<TraceId> = None;
        let mut trace_collection_entity_ip_address: Option<TransportLayerAddress> = None;
        let mut privacy_indicator: Option<PrivacyIndicator> = None;
        let mut trace_collection_entity_uri: Option<UriAddress> = None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                40 => gnb_cu_ue_f1ap_id = Some(GnbCuUeF1apId::decode(data)?),
                41 => gnb_du_ue_f1ap_id = Some(GnbDuUeF1apId::decode(data)?),
                243 => trace_id = Some(TraceId::decode(data)?),
                378 => {
                    trace_collection_entity_ip_address = Some(TransportLayerAddress::decode(data)?)
                }
                379 => privacy_indicator = Some(PrivacyIndicator::decode(data)?),
                380 => trace_collection_entity_uri = Some(UriAddress::decode(data)?),
                x => return Err(per_codec_error_new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        let gnb_cu_ue_f1ap_id = gnb_cu_ue_f1ap_id.ok_or(per_codec_error_new(format!(
            "Missing mandatory IE gnb_cu_ue_f1ap_id"
        )))?;
        let gnb_du_ue_f1ap_id = gnb_du_ue_f1ap_id.ok_or(per_codec_error_new(format!(
            "Missing mandatory IE gnb_du_ue_f1ap_id"
        )))?;
        let trace_id = trace_id.ok_or(per_codec_error_new(format!(
            "Missing mandatory IE trace_id"
        )))?;
        let trace_collection_entity_ip_address =
            trace_collection_entity_ip_address.ok_or(per_codec_error_new(format!(
                "Missing mandatory IE trace_collection_entity_ip_address"
            )))?;
        Ok(Self {
            gnb_cu_ue_f1ap_id,
            gnb_du_ue_f1ap_id,
            trace_id,
            trace_collection_entity_ip_address,
            privacy_indicator,
            trace_collection_entity_uri,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        let ie = &mut Allocator::new_codec_data();
        self.gnb_cu_ue_f1ap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 40, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.gnb_du_ue_f1ap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 41, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.trace_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 243, false)?;
        Criticality::Ignore.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.trace_collection_entity_ip_address.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 378, false)?;
        Criticality::Ignore.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        if let Some(x) = &self.privacy_indicator {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 379, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.trace_collection_entity_uri {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 380, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        encode::encode_sequence_header(data, true, &BitString::new(), false)?;
        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for CellTrafficTrace {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        CellTrafficTrace::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CellTrafficTrace");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CellTrafficTrace");
            e
        })
    }
}
// DuCuRadioInformationTransfer
#[derive(Clone, Debug)]
pub struct DuCuRadioInformationTransfer {
    pub transaction_id: TransactionId,
    pub du_cu_radio_information_type: DuCuRadioInformationType,
}

impl DuCuRadioInformationTransfer {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let _ = decode::decode_sequence_header(data, true, 0)?;
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut transaction_id: Option<TransactionId> = None;
        let mut du_cu_radio_information_type: Option<DuCuRadioInformationType> = None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                78 => transaction_id = Some(TransactionId::decode(data)?),
                249 => du_cu_radio_information_type = Some(DuCuRadioInformationType::decode(data)?),
                x => return Err(per_codec_error_new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        let transaction_id = transaction_id.ok_or(per_codec_error_new(format!(
            "Missing mandatory IE transaction_id"
        )))?;
        let du_cu_radio_information_type = du_cu_radio_information_type.ok_or(
            per_codec_error_new(format!("Missing mandatory IE du_cu_radio_information_type")),
        )?;
        Ok(Self {
            transaction_id,
            du_cu_radio_information_type,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        let ie = &mut Allocator::new_codec_data();
        self.transaction_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 78, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.du_cu_radio_information_type.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 249, false)?;
        Criticality::Ignore.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        encode::encode_sequence_header(data, true, &BitString::new(), false)?;
        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for DuCuRadioInformationTransfer {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        DuCuRadioInformationTransfer::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DuCuRadioInformationTransfer");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DuCuRadioInformationTransfer");
            e
        })
    }
}
// CuDuRadioInformationTransfer
#[derive(Clone, Debug)]
pub struct CuDuRadioInformationTransfer {
    pub transaction_id: TransactionId,
    pub cu_du_radio_information_type: CuDuRadioInformationType,
}

impl CuDuRadioInformationTransfer {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let _ = decode::decode_sequence_header(data, true, 0)?;
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut transaction_id: Option<TransactionId> = None;
        let mut cu_du_radio_information_type: Option<CuDuRadioInformationType> = None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                78 => transaction_id = Some(TransactionId::decode(data)?),
                250 => cu_du_radio_information_type = Some(CuDuRadioInformationType::decode(data)?),
                x => return Err(per_codec_error_new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        let transaction_id = transaction_id.ok_or(per_codec_error_new(format!(
            "Missing mandatory IE transaction_id"
        )))?;
        let cu_du_radio_information_type = cu_du_radio_information_type.ok_or(
            per_codec_error_new(format!("Missing mandatory IE cu_du_radio_information_type")),
        )?;
        Ok(Self {
            transaction_id,
            cu_du_radio_information_type,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        let ie = &mut Allocator::new_codec_data();
        self.transaction_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 78, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.cu_du_radio_information_type.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 250, false)?;
        Criticality::Ignore.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        encode::encode_sequence_header(data, true, &BitString::new(), false)?;
        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for CuDuRadioInformationTransfer {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        CuDuRadioInformationTransfer::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CuDuRadioInformationTransfer");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CuDuRadioInformationTransfer");
            e
        })
    }
}
// BapMappingConfiguration
#[derive(Clone, Debug)]
pub struct BapMappingConfiguration {
    pub transaction_id: TransactionId,
    pub bh_routing_information_added_list: Option<BhRoutingInformationAddedList>,
    pub bh_routing_information_removed_list: Option<BhRoutingInformationRemovedList>,
    pub traffic_mapping_information: Option<TrafficMappingInfo>,
    pub buffer_size_thresh: Option<BufferSizeThresh>,
    pub bap_header_rewriting_added_list: Option<BapHeaderRewritingAddedList>,
    pub re_routing_enable_indicator: Option<ReRoutingEnableIndicator>,
    pub bap_header_rewriting_removed_list: Option<BapHeaderRewritingRemovedList>,
}

impl BapMappingConfiguration {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let _ = decode::decode_sequence_header(data, true, 0)?;
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut transaction_id: Option<TransactionId> = None;
        let mut bh_routing_information_added_list: Option<BhRoutingInformationAddedList> = None;
        let mut bh_routing_information_removed_list: Option<BhRoutingInformationRemovedList> = None;
        let mut traffic_mapping_information: Option<TrafficMappingInfo> = None;
        let mut buffer_size_thresh: Option<BufferSizeThresh> = None;
        let mut bap_header_rewriting_added_list: Option<BapHeaderRewritingAddedList> = None;
        let mut re_routing_enable_indicator: Option<ReRoutingEnableIndicator> = None;
        let mut bap_header_rewriting_removed_list: Option<BapHeaderRewritingRemovedList> = None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                78 => transaction_id = Some(TransactionId::decode(data)?),
                283 => {
                    bh_routing_information_added_list =
                        Some(BhRoutingInformationAddedList::decode(data)?)
                }
                285 => {
                    bh_routing_information_removed_list =
                        Some(BhRoutingInformationRemovedList::decode(data)?)
                }
                299 => traffic_mapping_information = Some(TrafficMappingInfo::decode(data)?),
                512 => buffer_size_thresh = Some(BufferSizeThresh::decode(data)?),
                514 => {
                    bap_header_rewriting_added_list =
                        Some(BapHeaderRewritingAddedList::decode(data)?)
                }
                516 => re_routing_enable_indicator = Some(ReRoutingEnableIndicator::decode(data)?),
                641 => {
                    bap_header_rewriting_removed_list =
                        Some(BapHeaderRewritingRemovedList::decode(data)?)
                }
                x => return Err(per_codec_error_new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        let transaction_id = transaction_id.ok_or(per_codec_error_new(format!(
            "Missing mandatory IE transaction_id"
        )))?;
        Ok(Self {
            transaction_id,
            bh_routing_information_added_list,
            bh_routing_information_removed_list,
            traffic_mapping_information,
            buffer_size_thresh,
            bap_header_rewriting_added_list,
            re_routing_enable_indicator,
            bap_header_rewriting_removed_list,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        let ie = &mut Allocator::new_codec_data();
        self.transaction_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 78, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        if let Some(x) = &self.bh_routing_information_added_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 283, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.bh_routing_information_removed_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 285, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.traffic_mapping_information {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 299, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.buffer_size_thresh {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 512, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.bap_header_rewriting_added_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 514, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.re_routing_enable_indicator {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 516, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.bap_header_rewriting_removed_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 641, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        encode::encode_sequence_header(data, true, &BitString::new(), false)?;
        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for BapMappingConfiguration {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        BapMappingConfiguration::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("BapMappingConfiguration");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("BapMappingConfiguration");
            e
        })
    }
}
// BhRoutingInformationAddedList
#[derive(Clone, Debug)]
pub struct BhRoutingInformationAddedList(pub NonEmpty<BhRoutingInformationAddedListItem>);

impl BhRoutingInformationAddedList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(1024), false)?;
            let mut items = vec![];
            for _ in 0..length {
                let _ = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _ = Criticality::decode(data)?;
                let _ = decode::decode_length_determinent(data, None, None, false)?;
                items.push(BhRoutingInformationAddedListItem::decode(data)?);
                data.decode_align()?;
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(1024), false, self.0.len())?;
        for x in &self.0 {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(data, Some(0), Some(65535), false, 284, false)?;
            Criticality::Ignore.encode(data)?;
            encode::encode_length_determinent(data, None, None, false, ie.length_in_bytes())?;
            data.append_aligned(ie);
        }
        Ok(())
    }
}

impl PerCodec for BhRoutingInformationAddedList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        BhRoutingInformationAddedList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("BhRoutingInformationAddedList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("BhRoutingInformationAddedList");
            e
        })
    }
}
// BhRoutingInformationRemovedList
#[derive(Clone, Debug)]
pub struct BhRoutingInformationRemovedList(pub NonEmpty<BhRoutingInformationRemovedListItem>);

impl BhRoutingInformationRemovedList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(1024), false)?;
            let mut items = vec![];
            for _ in 0..length {
                let _ = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _ = Criticality::decode(data)?;
                let _ = decode::decode_length_determinent(data, None, None, false)?;
                items.push(BhRoutingInformationRemovedListItem::decode(data)?);
                data.decode_align()?;
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(1024), false, self.0.len())?;
        for x in &self.0 {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(data, Some(0), Some(65535), false, 286, false)?;
            Criticality::Ignore.encode(data)?;
            encode::encode_length_determinent(data, None, None, false, ie.length_in_bytes())?;
            data.append_aligned(ie);
        }
        Ok(())
    }
}

impl PerCodec for BhRoutingInformationRemovedList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        BhRoutingInformationRemovedList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("BhRoutingInformationRemovedList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("BhRoutingInformationRemovedList");
            e
        })
    }
}
// BapHeaderRewritingAddedList
#[derive(Clone, Debug)]
pub struct BapHeaderRewritingAddedList(pub NonEmpty<BapHeaderRewritingAddedListItem>);

impl BapHeaderRewritingAddedList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(1024), false)?;
            let mut items = vec![];
            for _ in 0..length {
                let _ = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _ = Criticality::decode(data)?;
                let _ = decode::decode_length_determinent(data, None, None, false)?;
                items.push(BapHeaderRewritingAddedListItem::decode(data)?);
                data.decode_align()?;
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(1024), false, self.0.len())?;
        for x in &self.0 {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(data, Some(0), Some(65535), false, 515, false)?;
            Criticality::Ignore.encode(data)?;
            encode::encode_length_determinent(data, None, None, false, ie.length_in_bytes())?;
            data.append_aligned(ie);
        }
        Ok(())
    }
}

impl PerCodec for BapHeaderRewritingAddedList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        BapHeaderRewritingAddedList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("BapHeaderRewritingAddedList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("BapHeaderRewritingAddedList");
            e
        })
    }
}
// BapHeaderRewritingRemovedList
#[derive(Clone, Debug)]
pub struct BapHeaderRewritingRemovedList(pub NonEmpty<BapHeaderRewritingRemovedListItem>);

impl BapHeaderRewritingRemovedList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(1024), false)?;
            let mut items = vec![];
            for _ in 0..length {
                let _ = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _ = Criticality::decode(data)?;
                let _ = decode::decode_length_determinent(data, None, None, false)?;
                items.push(BapHeaderRewritingRemovedListItem::decode(data)?);
                data.decode_align()?;
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(1024), false, self.0.len())?;
        for x in &self.0 {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(data, Some(0), Some(65535), false, 642, false)?;
            Criticality::Ignore.encode(data)?;
            encode::encode_length_determinent(data, None, None, false, ie.length_in_bytes())?;
            data.append_aligned(ie);
        }
        Ok(())
    }
}

impl PerCodec for BapHeaderRewritingRemovedList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        BapHeaderRewritingRemovedList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("BapHeaderRewritingRemovedList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("BapHeaderRewritingRemovedList");
            e
        })
    }
}
// BapMappingConfigurationAcknowledge
#[derive(Clone, Debug)]
pub struct BapMappingConfigurationAcknowledge {
    pub transaction_id: TransactionId,
    pub criticality_diagnostics: Option<CriticalityDiagnostics>,
}

impl BapMappingConfigurationAcknowledge {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let _ = decode::decode_sequence_header(data, true, 0)?;
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut transaction_id: Option<TransactionId> = None;
        let mut criticality_diagnostics: Option<CriticalityDiagnostics> = None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                78 => transaction_id = Some(TransactionId::decode(data)?),
                7 => criticality_diagnostics = Some(CriticalityDiagnostics::decode(data)?),
                x => return Err(per_codec_error_new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        let transaction_id = transaction_id.ok_or(per_codec_error_new(format!(
            "Missing mandatory IE transaction_id"
        )))?;
        Ok(Self {
            transaction_id,
            criticality_diagnostics,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        let ie = &mut Allocator::new_codec_data();
        self.transaction_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 78, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        if let Some(x) = &self.criticality_diagnostics {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 7, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        encode::encode_sequence_header(data, true, &BitString::new(), false)?;
        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for BapMappingConfigurationAcknowledge {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        BapMappingConfigurationAcknowledge::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("BapMappingConfigurationAcknowledge");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("BapMappingConfigurationAcknowledge");
            e
        })
    }
}
// BapMappingConfigurationFailure
#[derive(Clone, Debug)]
pub struct BapMappingConfigurationFailure {
    pub transaction_id: TransactionId,
    pub cause: Cause,
    pub time_to_wait: Option<TimeToWait>,
    pub criticality_diagnostics: Option<CriticalityDiagnostics>,
}

impl BapMappingConfigurationFailure {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let _ = decode::decode_sequence_header(data, true, 0)?;
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut transaction_id: Option<TransactionId> = None;
        let mut cause: Option<Cause> = None;
        let mut time_to_wait: Option<TimeToWait> = None;
        let mut criticality_diagnostics: Option<CriticalityDiagnostics> = None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                78 => transaction_id = Some(TransactionId::decode(data)?),
                0 => cause = Some(Cause::decode(data)?),
                77 => time_to_wait = Some(TimeToWait::decode(data)?),
                7 => criticality_diagnostics = Some(CriticalityDiagnostics::decode(data)?),
                x => return Err(per_codec_error_new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        let transaction_id = transaction_id.ok_or(per_codec_error_new(format!(
            "Missing mandatory IE transaction_id"
        )))?;
        let cause = cause.ok_or(per_codec_error_new(format!("Missing mandatory IE cause")))?;
        Ok(Self {
            transaction_id,
            cause,
            time_to_wait,
            criticality_diagnostics,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        let ie = &mut Allocator::new_codec_data();
        self.transaction_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 78, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.cause.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 0, false)?;
        Criticality::Ignore.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        if let Some(x) = &self.time_to_wait {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 77, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.criticality_diagnostics {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 7, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        encode::encode_sequence_header(data, true, &BitString::new(), false)?;
        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for BapMappingConfigurationFailure {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        BapMappingConfigurationFailure::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("BapMappingConfigurationFailure");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("BapMappingConfigurationFailure");
            e
        })
    }
}
// GnbDuResourceConfiguration
#[derive(Clone, Debug)]
pub struct GnbDuResourceConfiguration {
    pub transaction_id: TransactionId,
    pub activated_cells_to_be_updated_list: Option<ActivatedCellsToBeUpdatedList>,
    pub child_nodes_list: Option<ChildNodesList>,
    pub neighbour_node_cells_list: Option<NeighbourNodeCellsList>,
    pub serving_cells_list: Option<ServingCellsList>,
}

impl GnbDuResourceConfiguration {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let _ = decode::decode_sequence_header(data, true, 0)?;
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut transaction_id: Option<TransactionId> = None;
        let mut activated_cells_to_be_updated_list: Option<ActivatedCellsToBeUpdatedList> = None;
        let mut child_nodes_list: Option<ChildNodesList> = None;
        let mut neighbour_node_cells_list: Option<NeighbourNodeCellsList> = None;
        let mut serving_cells_list: Option<ServingCellsList> = None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                78 => transaction_id = Some(TransactionId::decode(data)?),
                288 => {
                    activated_cells_to_be_updated_list =
                        Some(ActivatedCellsToBeUpdatedList::decode(data)?)
                }
                289 => child_nodes_list = Some(ChildNodesList::decode(data)?),
                533 => neighbour_node_cells_list = Some(NeighbourNodeCellsList::decode(data)?),
                534 => serving_cells_list = Some(ServingCellsList::decode(data)?),
                x => return Err(per_codec_error_new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        let transaction_id = transaction_id.ok_or(per_codec_error_new(format!(
            "Missing mandatory IE transaction_id"
        )))?;
        Ok(Self {
            transaction_id,
            activated_cells_to_be_updated_list,
            child_nodes_list,
            neighbour_node_cells_list,
            serving_cells_list,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        let ie = &mut Allocator::new_codec_data();
        self.transaction_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 78, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        if let Some(x) = &self.activated_cells_to_be_updated_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 288, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.child_nodes_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 289, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.neighbour_node_cells_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 533, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.serving_cells_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 534, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        encode::encode_sequence_header(data, true, &BitString::new(), false)?;
        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for GnbDuResourceConfiguration {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        GnbDuResourceConfiguration::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("GnbDuResourceConfiguration");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("GnbDuResourceConfiguration");
            e
        })
    }
}
// GnbDuResourceConfigurationAcknowledge
#[derive(Clone, Debug)]
pub struct GnbDuResourceConfigurationAcknowledge {
    pub transaction_id: TransactionId,
    pub criticality_diagnostics: Option<CriticalityDiagnostics>,
}

impl GnbDuResourceConfigurationAcknowledge {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let _ = decode::decode_sequence_header(data, true, 0)?;
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut transaction_id: Option<TransactionId> = None;
        let mut criticality_diagnostics: Option<CriticalityDiagnostics> = None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                78 => transaction_id = Some(TransactionId::decode(data)?),
                7 => criticality_diagnostics = Some(CriticalityDiagnostics::decode(data)?),
                x => return Err(per_codec_error_new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        let transaction_id = transaction_id.ok_or(per_codec_error_new(format!(
            "Missing mandatory IE transaction_id"
        )))?;
        Ok(Self {
            transaction_id,
            criticality_diagnostics,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        let ie = &mut Allocator::new_codec_data();
        self.transaction_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 78, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        if let Some(x) = &self.criticality_diagnostics {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 7, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        encode::encode_sequence_header(data, true, &BitString::new(), false)?;
        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for GnbDuResourceConfigurationAcknowledge {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        GnbDuResourceConfigurationAcknowledge::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("GnbDuResourceConfigurationAcknowledge");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("GnbDuResourceConfigurationAcknowledge");
            e
        })
    }
}
// GnbDuResourceConfigurationFailure
#[derive(Clone, Debug)]
pub struct GnbDuResourceConfigurationFailure {
    pub transaction_id: TransactionId,
    pub cause: Cause,
    pub time_to_wait: Option<TimeToWait>,
    pub criticality_diagnostics: Option<CriticalityDiagnostics>,
}

impl GnbDuResourceConfigurationFailure {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let _ = decode::decode_sequence_header(data, true, 0)?;
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut transaction_id: Option<TransactionId> = None;
        let mut cause: Option<Cause> = None;
        let mut time_to_wait: Option<TimeToWait> = None;
        let mut criticality_diagnostics: Option<CriticalityDiagnostics> = None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                78 => transaction_id = Some(TransactionId::decode(data)?),
                0 => cause = Some(Cause::decode(data)?),
                77 => time_to_wait = Some(TimeToWait::decode(data)?),
                7 => criticality_diagnostics = Some(CriticalityDiagnostics::decode(data)?),
                x => return Err(per_codec_error_new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        let transaction_id = transaction_id.ok_or(per_codec_error_new(format!(
            "Missing mandatory IE transaction_id"
        )))?;
        let cause = cause.ok_or(per_codec_error_new(format!("Missing mandatory IE cause")))?;
        Ok(Self {
            transaction_id,
            cause,
            time_to_wait,
            criticality_diagnostics,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        let ie = &mut Allocator::new_codec_data();
        self.transaction_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 78, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.cause.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 0, false)?;
        Criticality::Ignore.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        if let Some(x) = &self.time_to_wait {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 77, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.criticality_diagnostics {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 7, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        encode::encode_sequence_header(data, true, &BitString::new(), false)?;
        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for GnbDuResourceConfigurationFailure {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        GnbDuResourceConfigurationFailure::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("GnbDuResourceConfigurationFailure");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("GnbDuResourceConfigurationFailure");
            e
        })
    }
}
// IabtnlAddressRequest
#[derive(Clone, Debug)]
pub struct IabtnlAddressRequest {
    pub transaction_id: TransactionId,
    pub ia_bv_4_addresses_requested: Option<IaBv4AddressesRequested>,
    pub iabi_pv_6_request_type: Option<IabiPv6RequestType>,
    pub iab_tnl_addresses_to_remove_list: Option<IabTnlAddressesToRemoveList>,
    pub iab_tnl_addresses_exception: Option<IabTnlAddressesException>,
}

impl IabtnlAddressRequest {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let _ = decode::decode_sequence_header(data, true, 0)?;
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut transaction_id: Option<TransactionId> = None;
        let mut ia_bv_4_addresses_requested: Option<IaBv4AddressesRequested> = None;
        let mut iabi_pv_6_request_type: Option<IabiPv6RequestType> = None;
        let mut iab_tnl_addresses_to_remove_list: Option<IabTnlAddressesToRemoveList> = None;
        let mut iab_tnl_addresses_exception: Option<IabTnlAddressesException> = None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                78 => transaction_id = Some(TransactionId::decode(data)?),
                297 => ia_bv_4_addresses_requested = Some(IaBv4AddressesRequested::decode(data)?),
                296 => iabi_pv_6_request_type = Some(IabiPv6RequestType::decode(data)?),
                292 => {
                    iab_tnl_addresses_to_remove_list =
                        Some(IabTnlAddressesToRemoveList::decode(data)?)
                }
                513 => iab_tnl_addresses_exception = Some(IabTnlAddressesException::decode(data)?),
                x => return Err(per_codec_error_new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        let transaction_id = transaction_id.ok_or(per_codec_error_new(format!(
            "Missing mandatory IE transaction_id"
        )))?;
        Ok(Self {
            transaction_id,
            ia_bv_4_addresses_requested,
            iabi_pv_6_request_type,
            iab_tnl_addresses_to_remove_list,
            iab_tnl_addresses_exception,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        let ie = &mut Allocator::new_codec_data();
        self.transaction_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 78, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        if let Some(x) = &self.ia_bv_4_addresses_requested {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 297, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.iabi_pv_6_request_type {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 296, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.iab_tnl_addresses_to_remove_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 292, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.iab_tnl_addresses_exception {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 513, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        encode::encode_sequence_header(data, true, &BitString::new(), false)?;
        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for IabtnlAddressRequest {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        IabtnlAddressRequest::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("IabtnlAddressRequest");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("IabtnlAddressRequest");
            e
        })
    }
}
// IabTnlAddressesToRemoveList
#[derive(Clone, Debug)]
pub struct IabTnlAddressesToRemoveList(pub NonEmpty<IabTnlAddressesToRemoveItem>);

impl IabTnlAddressesToRemoveList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(1024), false)?;
            let mut items = vec![];
            for _ in 0..length {
                let _ = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _ = Criticality::decode(data)?;
                let _ = decode::decode_length_determinent(data, None, None, false)?;
                items.push(IabTnlAddressesToRemoveItem::decode(data)?);
                data.decode_align()?;
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(1024), false, self.0.len())?;
        for x in &self.0 {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(data, Some(0), Some(65535), false, 293, false)?;
            Criticality::Reject.encode(data)?;
            encode::encode_length_determinent(data, None, None, false, ie.length_in_bytes())?;
            data.append_aligned(ie);
        }
        Ok(())
    }
}

impl PerCodec for IabTnlAddressesToRemoveList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        IabTnlAddressesToRemoveList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("IabTnlAddressesToRemoveList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("IabTnlAddressesToRemoveList");
            e
        })
    }
}
// IabtnlAddressResponse
#[derive(Clone, Debug)]
pub struct IabtnlAddressResponse {
    pub transaction_id: TransactionId,
    pub iab_allocated_tnl_address_list: IabAllocatedTnlAddressList,
}

impl IabtnlAddressResponse {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let _ = decode::decode_sequence_header(data, true, 0)?;
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut transaction_id: Option<TransactionId> = None;
        let mut iab_allocated_tnl_address_list: Option<IabAllocatedTnlAddressList> = None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                78 => transaction_id = Some(TransactionId::decode(data)?),
                294 => {
                    iab_allocated_tnl_address_list = Some(IabAllocatedTnlAddressList::decode(data)?)
                }
                x => return Err(per_codec_error_new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        let transaction_id = transaction_id.ok_or(per_codec_error_new(format!(
            "Missing mandatory IE transaction_id"
        )))?;
        let iab_allocated_tnl_address_list =
            iab_allocated_tnl_address_list.ok_or(per_codec_error_new(format!(
                "Missing mandatory IE iab_allocated_tnl_address_list"
            )))?;
        Ok(Self {
            transaction_id,
            iab_allocated_tnl_address_list,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        let ie = &mut Allocator::new_codec_data();
        self.transaction_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 78, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.iab_allocated_tnl_address_list.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 294, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        encode::encode_sequence_header(data, true, &BitString::new(), false)?;
        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for IabtnlAddressResponse {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        IabtnlAddressResponse::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("IabtnlAddressResponse");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("IabtnlAddressResponse");
            e
        })
    }
}
// IabAllocatedTnlAddressList
#[derive(Clone, Debug)]
pub struct IabAllocatedTnlAddressList(pub NonEmpty<IabAllocatedTnlAddressItem>);

impl IabAllocatedTnlAddressList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(1024), false)?;
            let mut items = vec![];
            for _ in 0..length {
                let _ = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _ = Criticality::decode(data)?;
                let _ = decode::decode_length_determinent(data, None, None, false)?;
                items.push(IabAllocatedTnlAddressItem::decode(data)?);
                data.decode_align()?;
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(1024), false, self.0.len())?;
        for x in &self.0 {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(data, Some(0), Some(65535), false, 295, false)?;
            Criticality::Reject.encode(data)?;
            encode::encode_length_determinent(data, None, None, false, ie.length_in_bytes())?;
            data.append_aligned(ie);
        }
        Ok(())
    }
}

impl PerCodec for IabAllocatedTnlAddressList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        IabAllocatedTnlAddressList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("IabAllocatedTnlAddressList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("IabAllocatedTnlAddressList");
            e
        })
    }
}
// IabtnlAddressFailure
#[derive(Clone, Debug)]
pub struct IabtnlAddressFailure {
    pub transaction_id: TransactionId,
    pub cause: Cause,
    pub time_to_wait: Option<TimeToWait>,
    pub criticality_diagnostics: Option<CriticalityDiagnostics>,
}

impl IabtnlAddressFailure {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let _ = decode::decode_sequence_header(data, true, 0)?;
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut transaction_id: Option<TransactionId> = None;
        let mut cause: Option<Cause> = None;
        let mut time_to_wait: Option<TimeToWait> = None;
        let mut criticality_diagnostics: Option<CriticalityDiagnostics> = None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                78 => transaction_id = Some(TransactionId::decode(data)?),
                0 => cause = Some(Cause::decode(data)?),
                77 => time_to_wait = Some(TimeToWait::decode(data)?),
                7 => criticality_diagnostics = Some(CriticalityDiagnostics::decode(data)?),
                x => return Err(per_codec_error_new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        let transaction_id = transaction_id.ok_or(per_codec_error_new(format!(
            "Missing mandatory IE transaction_id"
        )))?;
        let cause = cause.ok_or(per_codec_error_new(format!("Missing mandatory IE cause")))?;
        Ok(Self {
            transaction_id,
            cause,
            time_to_wait,
            criticality_diagnostics,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        let ie = &mut Allocator::new_codec_data();
        self.transaction_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 78, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.cause.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 0, false)?;
        Criticality::Ignore.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        if let Some(x) = &self.time_to_wait {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 77, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.criticality_diagnostics {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 7, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        encode::encode_sequence_header(data, true, &BitString::new(), false)?;
        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for IabtnlAddressFailure {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        IabtnlAddressFailure::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("IabtnlAddressFailure");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("IabtnlAddressFailure");
            e
        })
    }
}
// IabupConfigurationUpdateRequest
#[derive(Clone, Debug)]
pub struct IabupConfigurationUpdateRequest {
    pub transaction_id: TransactionId,
    pub ul_up_tnl_information_to_update_list: Option<UlUpTnlInformationToUpdateList>,
    pub ul_up_tnl_address_to_update_list: Option<UlUpTnlAddressToUpdateList>,
}

impl IabupConfigurationUpdateRequest {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let _ = decode::decode_sequence_header(data, true, 0)?;
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut transaction_id: Option<TransactionId> = None;
        let mut ul_up_tnl_information_to_update_list: Option<UlUpTnlInformationToUpdateList> = None;
        let mut ul_up_tnl_address_to_update_list: Option<UlUpTnlAddressToUpdateList> = None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                78 => transaction_id = Some(TransactionId::decode(data)?),
                300 => {
                    ul_up_tnl_information_to_update_list =
                        Some(UlUpTnlInformationToUpdateList::decode(data)?)
                }
                302 => {
                    ul_up_tnl_address_to_update_list =
                        Some(UlUpTnlAddressToUpdateList::decode(data)?)
                }
                x => return Err(per_codec_error_new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        let transaction_id = transaction_id.ok_or(per_codec_error_new(format!(
            "Missing mandatory IE transaction_id"
        )))?;
        Ok(Self {
            transaction_id,
            ul_up_tnl_information_to_update_list,
            ul_up_tnl_address_to_update_list,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        let ie = &mut Allocator::new_codec_data();
        self.transaction_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 78, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        if let Some(x) = &self.ul_up_tnl_information_to_update_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 300, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.ul_up_tnl_address_to_update_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 302, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        encode::encode_sequence_header(data, true, &BitString::new(), false)?;
        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for IabupConfigurationUpdateRequest {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        IabupConfigurationUpdateRequest::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("IabupConfigurationUpdateRequest");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("IabupConfigurationUpdateRequest");
            e
        })
    }
}
// UlUpTnlInformationToUpdateList
#[derive(Clone, Debug)]
pub struct UlUpTnlInformationToUpdateList(pub NonEmpty<UlUpTnlInformationToUpdateListItem>);

impl UlUpTnlInformationToUpdateList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(32678), false)?;
            let mut items = vec![];
            for _ in 0..length {
                let _ = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _ = Criticality::decode(data)?;
                let _ = decode::decode_length_determinent(data, None, None, false)?;
                items.push(UlUpTnlInformationToUpdateListItem::decode(data)?);
                data.decode_align()?;
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(32678), false, self.0.len())?;
        for x in &self.0 {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(data, Some(0), Some(65535), false, 301, false)?;
            Criticality::Ignore.encode(data)?;
            encode::encode_length_determinent(data, None, None, false, ie.length_in_bytes())?;
            data.append_aligned(ie);
        }
        Ok(())
    }
}

impl PerCodec for UlUpTnlInformationToUpdateList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        UlUpTnlInformationToUpdateList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UlUpTnlInformationToUpdateList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UlUpTnlInformationToUpdateList");
            e
        })
    }
}
// UlUpTnlAddressToUpdateList
#[derive(Clone, Debug)]
pub struct UlUpTnlAddressToUpdateList(pub NonEmpty<UlUpTnlAddressToUpdateListItem>);

impl UlUpTnlAddressToUpdateList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(8), false)?;
            let mut items = vec![];
            for _ in 0..length {
                let _ = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _ = Criticality::decode(data)?;
                let _ = decode::decode_length_determinent(data, None, None, false)?;
                items.push(UlUpTnlAddressToUpdateListItem::decode(data)?);
                data.decode_align()?;
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(8), false, self.0.len())?;
        for x in &self.0 {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(data, Some(0), Some(65535), false, 303, false)?;
            Criticality::Ignore.encode(data)?;
            encode::encode_length_determinent(data, None, None, false, ie.length_in_bytes())?;
            data.append_aligned(ie);
        }
        Ok(())
    }
}

impl PerCodec for UlUpTnlAddressToUpdateList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        UlUpTnlAddressToUpdateList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UlUpTnlAddressToUpdateList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UlUpTnlAddressToUpdateList");
            e
        })
    }
}
// IabupConfigurationUpdateResponse
#[derive(Clone, Debug)]
pub struct IabupConfigurationUpdateResponse {
    pub transaction_id: TransactionId,
    pub criticality_diagnostics: Option<CriticalityDiagnostics>,
    pub dl_up_tnl_address_to_update_list: Option<DlUpTnlAddressToUpdateList>,
}

impl IabupConfigurationUpdateResponse {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let _ = decode::decode_sequence_header(data, true, 0)?;
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut transaction_id: Option<TransactionId> = None;
        let mut criticality_diagnostics: Option<CriticalityDiagnostics> = None;
        let mut dl_up_tnl_address_to_update_list: Option<DlUpTnlAddressToUpdateList> = None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                78 => transaction_id = Some(TransactionId::decode(data)?),
                7 => criticality_diagnostics = Some(CriticalityDiagnostics::decode(data)?),
                304 => {
                    dl_up_tnl_address_to_update_list =
                        Some(DlUpTnlAddressToUpdateList::decode(data)?)
                }
                x => return Err(per_codec_error_new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        let transaction_id = transaction_id.ok_or(per_codec_error_new(format!(
            "Missing mandatory IE transaction_id"
        )))?;
        Ok(Self {
            transaction_id,
            criticality_diagnostics,
            dl_up_tnl_address_to_update_list,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        let ie = &mut Allocator::new_codec_data();
        self.transaction_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 78, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        if let Some(x) = &self.criticality_diagnostics {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 7, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.dl_up_tnl_address_to_update_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 304, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        encode::encode_sequence_header(data, true, &BitString::new(), false)?;
        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for IabupConfigurationUpdateResponse {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        IabupConfigurationUpdateResponse::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("IabupConfigurationUpdateResponse");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("IabupConfigurationUpdateResponse");
            e
        })
    }
}
// DlUpTnlAddressToUpdateList
#[derive(Clone, Debug)]
pub struct DlUpTnlAddressToUpdateList(pub NonEmpty<DlUpTnlAddressToUpdateListItem>);

impl DlUpTnlAddressToUpdateList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(8), false)?;
            let mut items = vec![];
            for _ in 0..length {
                let _ = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _ = Criticality::decode(data)?;
                let _ = decode::decode_length_determinent(data, None, None, false)?;
                items.push(DlUpTnlAddressToUpdateListItem::decode(data)?);
                data.decode_align()?;
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(8), false, self.0.len())?;
        for x in &self.0 {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(data, Some(0), Some(65535), false, 305, false)?;
            Criticality::Ignore.encode(data)?;
            encode::encode_length_determinent(data, None, None, false, ie.length_in_bytes())?;
            data.append_aligned(ie);
        }
        Ok(())
    }
}

impl PerCodec for DlUpTnlAddressToUpdateList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        DlUpTnlAddressToUpdateList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DlUpTnlAddressToUpdateList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DlUpTnlAddressToUpdateList");
            e
        })
    }
}
// IabupConfigurationUpdateFailure
#[derive(Clone, Debug)]
pub struct IabupConfigurationUpdateFailure {
    pub transaction_id: TransactionId,
    pub cause: Cause,
    pub time_to_wait: Option<TimeToWait>,
    pub criticality_diagnostics: Option<CriticalityDiagnostics>,
}

impl IabupConfigurationUpdateFailure {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let _ = decode::decode_sequence_header(data, true, 0)?;
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut transaction_id: Option<TransactionId> = None;
        let mut cause: Option<Cause> = None;
        let mut time_to_wait: Option<TimeToWait> = None;
        let mut criticality_diagnostics: Option<CriticalityDiagnostics> = None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                78 => transaction_id = Some(TransactionId::decode(data)?),
                0 => cause = Some(Cause::decode(data)?),
                77 => time_to_wait = Some(TimeToWait::decode(data)?),
                7 => criticality_diagnostics = Some(CriticalityDiagnostics::decode(data)?),
                x => return Err(per_codec_error_new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        let transaction_id = transaction_id.ok_or(per_codec_error_new(format!(
            "Missing mandatory IE transaction_id"
        )))?;
        let cause = cause.ok_or(per_codec_error_new(format!("Missing mandatory IE cause")))?;
        Ok(Self {
            transaction_id,
            cause,
            time_to_wait,
            criticality_diagnostics,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        let ie = &mut Allocator::new_codec_data();
        self.transaction_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 78, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.cause.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 0, false)?;
        Criticality::Ignore.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        if let Some(x) = &self.time_to_wait {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 77, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.criticality_diagnostics {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 7, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        encode::encode_sequence_header(data, true, &BitString::new(), false)?;
        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for IabupConfigurationUpdateFailure {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        IabupConfigurationUpdateFailure::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("IabupConfigurationUpdateFailure");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("IabupConfigurationUpdateFailure");
            e
        })
    }
}
// Miabf1SetupTriggering
#[derive(Clone, Debug)]
pub struct Miabf1SetupTriggering {
    pub transaction_id: TransactionId,
    pub target_gnb_id: GlobalGnbId,
    pub target_gnb_ip_address: Option<TransportLayerAddress>,
    pub target_se_gw_ip_address: Option<TransportLayerAddress>,
}

impl Miabf1SetupTriggering {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let _ = decode::decode_sequence_header(data, true, 0)?;
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut transaction_id: Option<TransactionId> = None;
        let mut target_gnb_id: Option<GlobalGnbId> = None;
        let mut target_gnb_ip_address: Option<TransportLayerAddress> = None;
        let mut target_se_gw_ip_address: Option<TransportLayerAddress> = None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                78 => transaction_id = Some(TransactionId::decode(data)?),
                755 => target_gnb_id = Some(GlobalGnbId::decode(data)?),
                756 => target_gnb_ip_address = Some(TransportLayerAddress::decode(data)?),
                757 => target_se_gw_ip_address = Some(TransportLayerAddress::decode(data)?),
                x => return Err(per_codec_error_new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        let transaction_id = transaction_id.ok_or(per_codec_error_new(format!(
            "Missing mandatory IE transaction_id"
        )))?;
        let target_gnb_id = target_gnb_id.ok_or(per_codec_error_new(format!(
            "Missing mandatory IE target_gnb_id"
        )))?;
        Ok(Self {
            transaction_id,
            target_gnb_id,
            target_gnb_ip_address,
            target_se_gw_ip_address,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        let ie = &mut Allocator::new_codec_data();
        self.transaction_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 78, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.target_gnb_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 755, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        if let Some(x) = &self.target_gnb_ip_address {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 756, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.target_se_gw_ip_address {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 757, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        encode::encode_sequence_header(data, true, &BitString::new(), false)?;
        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for Miabf1SetupTriggering {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Miabf1SetupTriggering::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("Miabf1SetupTriggering");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("Miabf1SetupTriggering");
            e
        })
    }
}
// Miabf1SetupOutcomeNotification
#[derive(Clone, Debug)]
pub struct Miabf1SetupOutcomeNotification {
    pub transaction_id: TransactionId,
    pub f1_setup_outcome: F1SetupOutcome,
    pub activated_cells_mapping_list: Option<ActivatedCellsMappingList>,
    pub target_f1_terminating_donor_gnb_id: Option<GlobalGnbId>,
}

impl Miabf1SetupOutcomeNotification {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let _ = decode::decode_sequence_header(data, true, 0)?;
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut transaction_id: Option<TransactionId> = None;
        let mut f1_setup_outcome: Option<F1SetupOutcome> = None;
        let mut activated_cells_mapping_list: Option<ActivatedCellsMappingList> = None;
        let mut target_f1_terminating_donor_gnb_id: Option<GlobalGnbId> = None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                78 => transaction_id = Some(TransactionId::decode(data)?),
                760 => f1_setup_outcome = Some(F1SetupOutcome::decode(data)?),
                758 => {
                    activated_cells_mapping_list = Some(ActivatedCellsMappingList::decode(data)?)
                }
                787 => target_f1_terminating_donor_gnb_id = Some(GlobalGnbId::decode(data)?),
                x => return Err(per_codec_error_new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        let transaction_id = transaction_id.ok_or(per_codec_error_new(format!(
            "Missing mandatory IE transaction_id"
        )))?;
        let f1_setup_outcome = f1_setup_outcome.ok_or(per_codec_error_new(format!(
            "Missing mandatory IE f1_setup_outcome"
        )))?;
        Ok(Self {
            transaction_id,
            f1_setup_outcome,
            activated_cells_mapping_list,
            target_f1_terminating_donor_gnb_id,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        let ie = &mut Allocator::new_codec_data();
        self.transaction_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 78, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.f1_setup_outcome.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 760, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        if let Some(x) = &self.activated_cells_mapping_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 758, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.target_f1_terminating_donor_gnb_id {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 787, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        encode::encode_sequence_header(data, true, &BitString::new(), false)?;
        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for Miabf1SetupOutcomeNotification {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Miabf1SetupOutcomeNotification::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("Miabf1SetupOutcomeNotification");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("Miabf1SetupOutcomeNotification");
            e
        })
    }
}
// F1SetupOutcome
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum F1SetupOutcome {
    Success,
    Failure,
}

impl F1SetupOutcome {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(1), true)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(1),
            true,
            *self as i128,
            (*self as u32) >= 2,
        )
    }
}

impl PerCodec for F1SetupOutcome {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        F1SetupOutcome::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("F1SetupOutcome");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("F1SetupOutcome");
            e
        })
    }
}
// ActivatedCellsMappingList
#[derive(Clone, Debug)]
pub struct ActivatedCellsMappingList(pub NonEmpty<ActivatedCellsMappingListItem>);

impl ActivatedCellsMappingList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(512), false)?;
            let mut items = vec![];
            for _ in 0..length {
                let _ = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _ = Criticality::decode(data)?;
                let _ = decode::decode_length_determinent(data, None, None, false)?;
                items.push(ActivatedCellsMappingListItem::decode(data)?);
                data.decode_align()?;
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(512), false, self.0.len())?;
        for x in &self.0 {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(data, Some(0), Some(65535), false, 759, false)?;
            Criticality::Ignore.encode(data)?;
            encode::encode_length_determinent(data, None, None, false, ie.length_in_bytes())?;
            data.append_aligned(ie);
        }
        Ok(())
    }
}

impl PerCodec for ActivatedCellsMappingList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        ActivatedCellsMappingList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ActivatedCellsMappingList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ActivatedCellsMappingList");
            e
        })
    }
}
// ResourceStatusRequest
#[derive(Clone, Debug)]
pub struct ResourceStatusRequest {
    pub transaction_id: TransactionId,
    pub gnb_cu_measurement_id: GnbCuMeasurementId,
    pub gnb_du_measurement_id: Option<GnbDuMeasurementId>,
    pub registration_request: RegistrationRequest,
    pub report_characteristics: Option<ReportCharacteristics>,
    pub cell_to_report_list: Option<CellToReportList>,
    pub reporting_periodicity: Option<ReportingPeriodicity>,
}

impl ResourceStatusRequest {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let _ = decode::decode_sequence_header(data, true, 0)?;
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut transaction_id: Option<TransactionId> = None;
        let mut gnb_cu_measurement_id: Option<GnbCuMeasurementId> = None;
        let mut gnb_du_measurement_id: Option<GnbDuMeasurementId> = None;
        let mut registration_request: Option<RegistrationRequest> = None;
        let mut report_characteristics: Option<ReportCharacteristics> = None;
        let mut cell_to_report_list: Option<CellToReportList> = None;
        let mut reporting_periodicity: Option<ReportingPeriodicity> = None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                78 => transaction_id = Some(TransactionId::decode(data)?),
                345 => gnb_cu_measurement_id = Some(GnbCuMeasurementId::decode(data)?),
                346 => gnb_du_measurement_id = Some(GnbDuMeasurementId::decode(data)?),
                347 => registration_request = Some(RegistrationRequest::decode(data)?),
                348 => report_characteristics = Some(ReportCharacteristics::decode(data)?),
                349 => cell_to_report_list = Some(CellToReportList::decode(data)?),
                352 => reporting_periodicity = Some(ReportingPeriodicity::decode(data)?),
                x => return Err(per_codec_error_new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        let transaction_id = transaction_id.ok_or(per_codec_error_new(format!(
            "Missing mandatory IE transaction_id"
        )))?;
        let gnb_cu_measurement_id = gnb_cu_measurement_id.ok_or(per_codec_error_new(format!(
            "Missing mandatory IE gnb_cu_measurement_id"
        )))?;
        let registration_request = registration_request.ok_or(per_codec_error_new(format!(
            "Missing mandatory IE registration_request"
        )))?;
        Ok(Self {
            transaction_id,
            gnb_cu_measurement_id,
            gnb_du_measurement_id,
            registration_request,
            report_characteristics,
            cell_to_report_list,
            reporting_periodicity,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        let ie = &mut Allocator::new_codec_data();
        self.transaction_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 78, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.gnb_cu_measurement_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 345, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        if let Some(x) = &self.gnb_du_measurement_id {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 346, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        let ie = &mut Allocator::new_codec_data();
        self.registration_request.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 347, false)?;
        Criticality::Ignore.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        if let Some(x) = &self.report_characteristics {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 348, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.cell_to_report_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 349, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.reporting_periodicity {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 352, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        encode::encode_sequence_header(data, true, &BitString::new(), false)?;
        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for ResourceStatusRequest {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        ResourceStatusRequest::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ResourceStatusRequest");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ResourceStatusRequest");
            e
        })
    }
}
// ResourceStatusResponse
#[derive(Clone, Debug)]
pub struct ResourceStatusResponse {
    pub transaction_id: TransactionId,
    pub gnb_cu_measurement_id: GnbCuMeasurementId,
    pub gnb_du_measurement_id: GnbDuMeasurementId,
    pub criticality_diagnostics: Option<CriticalityDiagnostics>,
}

impl ResourceStatusResponse {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let _ = decode::decode_sequence_header(data, true, 0)?;
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut transaction_id: Option<TransactionId> = None;
        let mut gnb_cu_measurement_id: Option<GnbCuMeasurementId> = None;
        let mut gnb_du_measurement_id: Option<GnbDuMeasurementId> = None;
        let mut criticality_diagnostics: Option<CriticalityDiagnostics> = None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                78 => transaction_id = Some(TransactionId::decode(data)?),
                345 => gnb_cu_measurement_id = Some(GnbCuMeasurementId::decode(data)?),
                346 => gnb_du_measurement_id = Some(GnbDuMeasurementId::decode(data)?),
                7 => criticality_diagnostics = Some(CriticalityDiagnostics::decode(data)?),
                x => return Err(per_codec_error_new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        let transaction_id = transaction_id.ok_or(per_codec_error_new(format!(
            "Missing mandatory IE transaction_id"
        )))?;
        let gnb_cu_measurement_id = gnb_cu_measurement_id.ok_or(per_codec_error_new(format!(
            "Missing mandatory IE gnb_cu_measurement_id"
        )))?;
        let gnb_du_measurement_id = gnb_du_measurement_id.ok_or(per_codec_error_new(format!(
            "Missing mandatory IE gnb_du_measurement_id"
        )))?;
        Ok(Self {
            transaction_id,
            gnb_cu_measurement_id,
            gnb_du_measurement_id,
            criticality_diagnostics,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        let ie = &mut Allocator::new_codec_data();
        self.transaction_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 78, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.gnb_cu_measurement_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 345, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.gnb_du_measurement_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 346, false)?;
        Criticality::Ignore.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        if let Some(x) = &self.criticality_diagnostics {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 7, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        encode::encode_sequence_header(data, true, &BitString::new(), false)?;
        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for ResourceStatusResponse {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        ResourceStatusResponse::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ResourceStatusResponse");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ResourceStatusResponse");
            e
        })
    }
}
// ResourceStatusFailure
#[derive(Clone, Debug)]
pub struct ResourceStatusFailure {
    pub transaction_id: TransactionId,
    pub gnb_cu_measurement_id: GnbCuMeasurementId,
    pub gnb_du_measurement_id: GnbDuMeasurementId,
    pub cause: Cause,
    pub criticality_diagnostics: Option<CriticalityDiagnostics>,
}

impl ResourceStatusFailure {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let _ = decode::decode_sequence_header(data, true, 0)?;
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut transaction_id: Option<TransactionId> = None;
        let mut gnb_cu_measurement_id: Option<GnbCuMeasurementId> = None;
        let mut gnb_du_measurement_id: Option<GnbDuMeasurementId> = None;
        let mut cause: Option<Cause> = None;
        let mut criticality_diagnostics: Option<CriticalityDiagnostics> = None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                78 => transaction_id = Some(TransactionId::decode(data)?),
                345 => gnb_cu_measurement_id = Some(GnbCuMeasurementId::decode(data)?),
                346 => gnb_du_measurement_id = Some(GnbDuMeasurementId::decode(data)?),
                0 => cause = Some(Cause::decode(data)?),
                7 => criticality_diagnostics = Some(CriticalityDiagnostics::decode(data)?),
                x => return Err(per_codec_error_new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        let transaction_id = transaction_id.ok_or(per_codec_error_new(format!(
            "Missing mandatory IE transaction_id"
        )))?;
        let gnb_cu_measurement_id = gnb_cu_measurement_id.ok_or(per_codec_error_new(format!(
            "Missing mandatory IE gnb_cu_measurement_id"
        )))?;
        let gnb_du_measurement_id = gnb_du_measurement_id.ok_or(per_codec_error_new(format!(
            "Missing mandatory IE gnb_du_measurement_id"
        )))?;
        let cause = cause.ok_or(per_codec_error_new(format!("Missing mandatory IE cause")))?;
        Ok(Self {
            transaction_id,
            gnb_cu_measurement_id,
            gnb_du_measurement_id,
            cause,
            criticality_diagnostics,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        let ie = &mut Allocator::new_codec_data();
        self.transaction_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 78, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.gnb_cu_measurement_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 345, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.gnb_du_measurement_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 346, false)?;
        Criticality::Ignore.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.cause.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 0, false)?;
        Criticality::Ignore.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        if let Some(x) = &self.criticality_diagnostics {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 7, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        encode::encode_sequence_header(data, true, &BitString::new(), false)?;
        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for ResourceStatusFailure {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        ResourceStatusFailure::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ResourceStatusFailure");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ResourceStatusFailure");
            e
        })
    }
}
// ResourceStatusUpdate
#[derive(Clone, Debug)]
pub struct ResourceStatusUpdate {
    pub transaction_id: TransactionId,
    pub gnb_cu_measurement_id: GnbCuMeasurementId,
    pub gnb_du_measurement_id: GnbDuMeasurementId,
    pub hardware_load_indicator: Option<HardwareLoadIndicator>,
    pub tnl_capacity_indicator: Option<TnlCapacityIndicator>,
    pub cell_measurement_result_list: Option<CellMeasurementResultList>,
}

impl ResourceStatusUpdate {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let _ = decode::decode_sequence_header(data, true, 0)?;
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut transaction_id: Option<TransactionId> = None;
        let mut gnb_cu_measurement_id: Option<GnbCuMeasurementId> = None;
        let mut gnb_du_measurement_id: Option<GnbDuMeasurementId> = None;
        let mut hardware_load_indicator: Option<HardwareLoadIndicator> = None;
        let mut tnl_capacity_indicator: Option<TnlCapacityIndicator> = None;
        let mut cell_measurement_result_list: Option<CellMeasurementResultList> = None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                78 => transaction_id = Some(TransactionId::decode(data)?),
                345 => gnb_cu_measurement_id = Some(GnbCuMeasurementId::decode(data)?),
                346 => gnb_du_measurement_id = Some(GnbDuMeasurementId::decode(data)?),
                351 => hardware_load_indicator = Some(HardwareLoadIndicator::decode(data)?),
                353 => tnl_capacity_indicator = Some(TnlCapacityIndicator::decode(data)?),
                350 => {
                    cell_measurement_result_list = Some(CellMeasurementResultList::decode(data)?)
                }
                x => return Err(per_codec_error_new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        let transaction_id = transaction_id.ok_or(per_codec_error_new(format!(
            "Missing mandatory IE transaction_id"
        )))?;
        let gnb_cu_measurement_id = gnb_cu_measurement_id.ok_or(per_codec_error_new(format!(
            "Missing mandatory IE gnb_cu_measurement_id"
        )))?;
        let gnb_du_measurement_id = gnb_du_measurement_id.ok_or(per_codec_error_new(format!(
            "Missing mandatory IE gnb_du_measurement_id"
        )))?;
        Ok(Self {
            transaction_id,
            gnb_cu_measurement_id,
            gnb_du_measurement_id,
            hardware_load_indicator,
            tnl_capacity_indicator,
            cell_measurement_result_list,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        let ie = &mut Allocator::new_codec_data();
        self.transaction_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 78, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.gnb_cu_measurement_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 345, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.gnb_du_measurement_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 346, false)?;
        Criticality::Ignore.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        if let Some(x) = &self.hardware_load_indicator {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 351, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.tnl_capacity_indicator {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 353, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.cell_measurement_result_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 350, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        encode::encode_sequence_header(data, true, &BitString::new(), false)?;
        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for ResourceStatusUpdate {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        ResourceStatusUpdate::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ResourceStatusUpdate");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ResourceStatusUpdate");
            e
        })
    }
}
// AccessAndMobilityIndication
#[derive(Clone, Debug)]
pub struct AccessAndMobilityIndication {
    pub transaction_id: TransactionId,
    pub ra_report_list: Option<RaReportList>,
    pub rlf_report_information_list: Option<RlfReportInformationList>,
    pub successful_ho_report_information_list: Option<SuccessfulHoReportInformationList>,
    pub successful_ps_cell_change_report_information_list:
        Option<SuccessfulPsCellChangeReportInformationList>,
}

impl AccessAndMobilityIndication {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let _ = decode::decode_sequence_header(data, true, 0)?;
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut transaction_id: Option<TransactionId> = None;
        let mut ra_report_list: Option<RaReportList> = None;
        let mut rlf_report_information_list: Option<RlfReportInformationList> = None;
        let mut successful_ho_report_information_list: Option<SuccessfulHoReportInformationList> =
            None;
        let mut successful_ps_cell_change_report_information_list: Option<
            SuccessfulPsCellChangeReportInformationList,
        > = None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                78 => transaction_id = Some(TransactionId::decode(data)?),
                359 => ra_report_list = Some(RaReportList::decode(data)?),
                360 => rlf_report_information_list = Some(RlfReportInformationList::decode(data)?),
                443 => {
                    successful_ho_report_information_list =
                        Some(SuccessfulHoReportInformationList::decode(data)?)
                }
                736 => {
                    successful_ps_cell_change_report_information_list =
                        Some(SuccessfulPsCellChangeReportInformationList::decode(data)?)
                }
                x => return Err(per_codec_error_new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        let transaction_id = transaction_id.ok_or(per_codec_error_new(format!(
            "Missing mandatory IE transaction_id"
        )))?;
        Ok(Self {
            transaction_id,
            ra_report_list,
            rlf_report_information_list,
            successful_ho_report_information_list,
            successful_ps_cell_change_report_information_list,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        let ie = &mut Allocator::new_codec_data();
        self.transaction_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 78, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        if let Some(x) = &self.ra_report_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 359, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.rlf_report_information_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 360, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.successful_ho_report_information_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 443, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.successful_ps_cell_change_report_information_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 736, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        encode::encode_sequence_header(data, true, &BitString::new(), false)?;
        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for AccessAndMobilityIndication {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        AccessAndMobilityIndication::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("AccessAndMobilityIndication");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("AccessAndMobilityIndication");
            e
        })
    }
}
// ReferenceTimeInformationReportingControl
#[derive(Clone, Debug)]
pub struct ReferenceTimeInformationReportingControl {
    pub transaction_id: TransactionId,
    pub reporting_request_type: ReportingRequestType,
}

impl ReferenceTimeInformationReportingControl {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let _ = decode::decode_sequence_header(data, true, 0)?;
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut transaction_id: Option<TransactionId> = None;
        let mut reporting_request_type: Option<ReportingRequestType> = None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                78 => transaction_id = Some(TransactionId::decode(data)?),
                365 => reporting_request_type = Some(ReportingRequestType::decode(data)?),
                x => return Err(per_codec_error_new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        let transaction_id = transaction_id.ok_or(per_codec_error_new(format!(
            "Missing mandatory IE transaction_id"
        )))?;
        let reporting_request_type = reporting_request_type.ok_or(per_codec_error_new(format!(
            "Missing mandatory IE reporting_request_type"
        )))?;
        Ok(Self {
            transaction_id,
            reporting_request_type,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        let ie = &mut Allocator::new_codec_data();
        self.transaction_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 78, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.reporting_request_type.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 365, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        encode::encode_sequence_header(data, true, &BitString::new(), false)?;
        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for ReferenceTimeInformationReportingControl {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        ReferenceTimeInformationReportingControl::decode_inner(data).map_err(
            |mut e: PerCodecError| {
                e.push_context("ReferenceTimeInformationReportingControl");
                e
            },
        )
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ReferenceTimeInformationReportingControl");
            e
        })
    }
}
// ReferenceTimeInformationReport
#[derive(Clone, Debug)]
pub struct ReferenceTimeInformationReport {
    pub transaction_id: TransactionId,
    pub time_reference_information: TimeReferenceInformation,
}

impl ReferenceTimeInformationReport {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let _ = decode::decode_sequence_header(data, true, 0)?;
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut transaction_id: Option<TransactionId> = None;
        let mut time_reference_information: Option<TimeReferenceInformation> = None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                78 => transaction_id = Some(TransactionId::decode(data)?),
                366 => time_reference_information = Some(TimeReferenceInformation::decode(data)?),
                x => return Err(per_codec_error_new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        let transaction_id = transaction_id.ok_or(per_codec_error_new(format!(
            "Missing mandatory IE transaction_id"
        )))?;
        let time_reference_information = time_reference_information.ok_or(per_codec_error_new(
            format!("Missing mandatory IE time_reference_information"),
        ))?;
        Ok(Self {
            transaction_id,
            time_reference_information,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        let ie = &mut Allocator::new_codec_data();
        self.transaction_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 78, false)?;
        Criticality::Ignore.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.time_reference_information.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 366, false)?;
        Criticality::Ignore.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        encode::encode_sequence_header(data, true, &BitString::new(), false)?;
        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for ReferenceTimeInformationReport {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        ReferenceTimeInformationReport::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ReferenceTimeInformationReport");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ReferenceTimeInformationReport");
            e
        })
    }
}
// AccessSuccess
#[derive(Clone, Debug)]
pub struct AccessSuccess {
    pub gnb_cu_ue_f1ap_id: GnbCuUeF1apId,
    pub gnb_du_ue_f1ap_id: GnbDuUeF1apId,
    pub nr_cgi: NrCgi,
}

impl AccessSuccess {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let _ = decode::decode_sequence_header(data, true, 0)?;
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut gnb_cu_ue_f1ap_id: Option<GnbCuUeF1apId> = None;
        let mut gnb_du_ue_f1ap_id: Option<GnbDuUeF1apId> = None;
        let mut nr_cgi: Option<NrCgi> = None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                40 => gnb_cu_ue_f1ap_id = Some(GnbCuUeF1apId::decode(data)?),
                41 => gnb_du_ue_f1ap_id = Some(GnbDuUeF1apId::decode(data)?),
                111 => nr_cgi = Some(NrCgi::decode(data)?),
                x => return Err(per_codec_error_new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        let gnb_cu_ue_f1ap_id = gnb_cu_ue_f1ap_id.ok_or(per_codec_error_new(format!(
            "Missing mandatory IE gnb_cu_ue_f1ap_id"
        )))?;
        let gnb_du_ue_f1ap_id = gnb_du_ue_f1ap_id.ok_or(per_codec_error_new(format!(
            "Missing mandatory IE gnb_du_ue_f1ap_id"
        )))?;
        let nr_cgi = nr_cgi.ok_or(per_codec_error_new(format!("Missing mandatory IE nr_cgi")))?;
        Ok(Self {
            gnb_cu_ue_f1ap_id,
            gnb_du_ue_f1ap_id,
            nr_cgi,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        let ie = &mut Allocator::new_codec_data();
        self.gnb_cu_ue_f1ap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 40, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.gnb_du_ue_f1ap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 41, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.nr_cgi.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 111, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        encode::encode_sequence_header(data, true, &BitString::new(), false)?;
        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for AccessSuccess {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        AccessSuccess::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("AccessSuccess");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("AccessSuccess");
            e
        })
    }
}
// PositioningAssistanceInformationControl
#[derive(Clone, Debug)]
pub struct PositioningAssistanceInformationControl {
    pub transaction_id: TransactionId,
    pub pos_assistance_information: Option<PosAssistanceInformation>,
    pub pos_broadcast: Option<PosBroadcast>,
    pub positioning_broadcast_cells: Option<PositioningBroadcastCells>,
    pub routing_id: Option<RoutingId>,
}

impl PositioningAssistanceInformationControl {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let _ = decode::decode_sequence_header(data, true, 0)?;
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut transaction_id: Option<TransactionId> = None;
        let mut pos_assistance_information: Option<PosAssistanceInformation> = None;
        let mut pos_broadcast: Option<PosBroadcast> = None;
        let mut positioning_broadcast_cells: Option<PositioningBroadcastCells> = None;
        let mut routing_id: Option<RoutingId> = None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                78 => transaction_id = Some(TransactionId::decode(data)?),
                392 => pos_assistance_information = Some(PosAssistanceInformation::decode(data)?),
                393 => pos_broadcast = Some(PosBroadcast::decode(data)?),
                406 => positioning_broadcast_cells = Some(PositioningBroadcastCells::decode(data)?),
                394 => routing_id = Some(RoutingId::decode(data)?),
                x => return Err(per_codec_error_new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        let transaction_id = transaction_id.ok_or(per_codec_error_new(format!(
            "Missing mandatory IE transaction_id"
        )))?;
        Ok(Self {
            transaction_id,
            pos_assistance_information,
            pos_broadcast,
            positioning_broadcast_cells,
            routing_id,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        let ie = &mut Allocator::new_codec_data();
        self.transaction_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 78, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        if let Some(x) = &self.pos_assistance_information {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 392, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.pos_broadcast {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 393, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.positioning_broadcast_cells {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 406, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.routing_id {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 394, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        encode::encode_sequence_header(data, true, &BitString::new(), false)?;
        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for PositioningAssistanceInformationControl {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PositioningAssistanceInformationControl::decode_inner(data).map_err(
            |mut e: PerCodecError| {
                e.push_context("PositioningAssistanceInformationControl");
                e
            },
        )
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PositioningAssistanceInformationControl");
            e
        })
    }
}
// PositioningAssistanceInformationFeedback
#[derive(Clone, Debug)]
pub struct PositioningAssistanceInformationFeedback {
    pub transaction_id: TransactionId,
    pub pos_assistance_information_failure_list: Option<PosAssistanceInformationFailureList>,
    pub positioning_broadcast_cells: Option<PositioningBroadcastCells>,
    pub routing_id: Option<RoutingId>,
    pub criticality_diagnostics: Option<CriticalityDiagnostics>,
}

impl PositioningAssistanceInformationFeedback {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let _ = decode::decode_sequence_header(data, true, 0)?;
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut transaction_id: Option<TransactionId> = None;
        let mut pos_assistance_information_failure_list: Option<
            PosAssistanceInformationFailureList,
        > = None;
        let mut positioning_broadcast_cells: Option<PositioningBroadcastCells> = None;
        let mut routing_id: Option<RoutingId> = None;
        let mut criticality_diagnostics: Option<CriticalityDiagnostics> = None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                78 => transaction_id = Some(TransactionId::decode(data)?),
                395 => {
                    pos_assistance_information_failure_list =
                        Some(PosAssistanceInformationFailureList::decode(data)?)
                }
                406 => positioning_broadcast_cells = Some(PositioningBroadcastCells::decode(data)?),
                394 => routing_id = Some(RoutingId::decode(data)?),
                7 => criticality_diagnostics = Some(CriticalityDiagnostics::decode(data)?),
                x => return Err(per_codec_error_new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        let transaction_id = transaction_id.ok_or(per_codec_error_new(format!(
            "Missing mandatory IE transaction_id"
        )))?;
        Ok(Self {
            transaction_id,
            pos_assistance_information_failure_list,
            positioning_broadcast_cells,
            routing_id,
            criticality_diagnostics,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        let ie = &mut Allocator::new_codec_data();
        self.transaction_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 78, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        if let Some(x) = &self.pos_assistance_information_failure_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 395, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.positioning_broadcast_cells {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 406, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.routing_id {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 394, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.criticality_diagnostics {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 7, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        encode::encode_sequence_header(data, true, &BitString::new(), false)?;
        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for PositioningAssistanceInformationFeedback {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PositioningAssistanceInformationFeedback::decode_inner(data).map_err(
            |mut e: PerCodecError| {
                e.push_context("PositioningAssistanceInformationFeedback");
                e
            },
        )
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PositioningAssistanceInformationFeedback");
            e
        })
    }
}
// PositioningMeasurementRequest
#[derive(Clone, Debug)]
pub struct PositioningMeasurementRequest {
    pub transaction_id: TransactionId,
    pub lmf_measurement_id: LmfMeasurementId,
    pub ran_measurement_id: RanMeasurementId,
    pub trp_measurement_request_list: TrpMeasurementRequestList,
    pub pos_report_characteristics: PosReportCharacteristics,
    pub pos_measurement_periodicity: Option<MeasurementPeriodicity>,
    pub pos_measurement_quantities: PosMeasurementQuantities,
    pub sfn_initialisation_time: Option<RelativeTime1900>,
    pub srs_configuration: Option<SrsConfiguration>,
    pub measurement_beam_info_request: Option<MeasurementBeamInfoRequest>,
    pub system_frame_number: Option<SystemFrameNumber>,
    pub slot_number: Option<SlotNumber>,
    pub pos_measurement_periodicity_extended: Option<MeasurementPeriodicityExtended>,
    pub response_time: Option<ResponseTime>,
    pub measurement_characteristics_request_indicator:
        Option<MeasurementCharacteristicsRequestIndicator>,
    pub measurement_time_occasion: Option<MeasurementTimeOccasion>,
    pub pos_measurement_amount: Option<PosMeasurementAmount>,
    pub time_window_information_measurement_list: Option<TimeWindowInformationMeasurementList>,
}

impl PositioningMeasurementRequest {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let _ = decode::decode_sequence_header(data, true, 0)?;
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut transaction_id: Option<TransactionId> = None;
        let mut lmf_measurement_id: Option<LmfMeasurementId> = None;
        let mut ran_measurement_id: Option<RanMeasurementId> = None;
        let mut trp_measurement_request_list: Option<TrpMeasurementRequestList> = None;
        let mut pos_report_characteristics: Option<PosReportCharacteristics> = None;
        let mut pos_measurement_periodicity: Option<MeasurementPeriodicity> = None;
        let mut pos_measurement_quantities: Option<PosMeasurementQuantities> = None;
        let mut sfn_initialisation_time: Option<RelativeTime1900> = None;
        let mut srs_configuration: Option<SrsConfiguration> = None;
        let mut measurement_beam_info_request: Option<MeasurementBeamInfoRequest> = None;
        let mut system_frame_number: Option<SystemFrameNumber> = None;
        let mut slot_number: Option<SlotNumber> = None;
        let mut pos_measurement_periodicity_extended: Option<MeasurementPeriodicityExtended> = None;
        let mut response_time: Option<ResponseTime> = None;
        let mut measurement_characteristics_request_indicator: Option<
            MeasurementCharacteristicsRequestIndicator,
        > = None;
        let mut measurement_time_occasion: Option<MeasurementTimeOccasion> = None;
        let mut pos_measurement_amount: Option<PosMeasurementAmount> = None;
        let mut time_window_information_measurement_list: Option<
            TimeWindowInformationMeasurementList,
        > = None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                78 => transaction_id = Some(TransactionId::decode(data)?),
                402 => lmf_measurement_id = Some(LmfMeasurementId::decode(data)?),
                411 => ran_measurement_id = Some(RanMeasurementId::decode(data)?),
                422 => {
                    trp_measurement_request_list = Some(TrpMeasurementRequestList::decode(data)?)
                }
                408 => pos_report_characteristics = Some(PosReportCharacteristics::decode(data)?),
                409 => pos_measurement_periodicity = Some(MeasurementPeriodicity::decode(data)?),
                396 => pos_measurement_quantities = Some(PosMeasurementQuantities::decode(data)?),
                419 => sfn_initialisation_time = Some(RelativeTime1900::decode(data)?),
                407 => srs_configuration = Some(SrsConfiguration::decode(data)?),
                423 => {
                    measurement_beam_info_request = Some(MeasurementBeamInfoRequest::decode(data)?)
                }
                420 => system_frame_number = Some(SystemFrameNumber::decode(data)?),
                421 => slot_number = Some(SlotNumber::decode(data)?),
                438 => {
                    pos_measurement_periodicity_extended =
                        Some(MeasurementPeriodicityExtended::decode(data)?)
                }
                555 => response_time = Some(ResponseTime::decode(data)?),
                574 => {
                    measurement_characteristics_request_indicator =
                        Some(MeasurementCharacteristicsRequestIndicator::decode(data)?)
                }
                573 => measurement_time_occasion = Some(MeasurementTimeOccasion::decode(data)?),
                634 => pos_measurement_amount = Some(PosMeasurementAmount::decode(data)?),
                803 => {
                    time_window_information_measurement_list =
                        Some(TimeWindowInformationMeasurementList::decode(data)?)
                }
                x => return Err(per_codec_error_new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        let transaction_id = transaction_id.ok_or(per_codec_error_new(format!(
            "Missing mandatory IE transaction_id"
        )))?;
        let lmf_measurement_id = lmf_measurement_id.ok_or(per_codec_error_new(format!(
            "Missing mandatory IE lmf_measurement_id"
        )))?;
        let ran_measurement_id = ran_measurement_id.ok_or(per_codec_error_new(format!(
            "Missing mandatory IE ran_measurement_id"
        )))?;
        let trp_measurement_request_list = trp_measurement_request_list.ok_or(
            per_codec_error_new(format!("Missing mandatory IE trp_measurement_request_list")),
        )?;
        let pos_report_characteristics = pos_report_characteristics.ok_or(per_codec_error_new(
            format!("Missing mandatory IE pos_report_characteristics"),
        ))?;
        let pos_measurement_quantities = pos_measurement_quantities.ok_or(per_codec_error_new(
            format!("Missing mandatory IE pos_measurement_quantities"),
        ))?;
        Ok(Self {
            transaction_id,
            lmf_measurement_id,
            ran_measurement_id,
            trp_measurement_request_list,
            pos_report_characteristics,
            pos_measurement_periodicity,
            pos_measurement_quantities,
            sfn_initialisation_time,
            srs_configuration,
            measurement_beam_info_request,
            system_frame_number,
            slot_number,
            pos_measurement_periodicity_extended,
            response_time,
            measurement_characteristics_request_indicator,
            measurement_time_occasion,
            pos_measurement_amount,
            time_window_information_measurement_list,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        let ie = &mut Allocator::new_codec_data();
        self.transaction_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 78, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.lmf_measurement_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 402, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.ran_measurement_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 411, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.trp_measurement_request_list.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 422, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.pos_report_characteristics.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 408, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        if let Some(x) = &self.pos_measurement_periodicity {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 409, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        let ie = &mut Allocator::new_codec_data();
        self.pos_measurement_quantities.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 396, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        if let Some(x) = &self.sfn_initialisation_time {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 419, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.srs_configuration {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 407, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.measurement_beam_info_request {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 423, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.system_frame_number {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 420, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.slot_number {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 421, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.pos_measurement_periodicity_extended {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 438, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.response_time {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 555, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.measurement_characteristics_request_indicator {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 574, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.measurement_time_occasion {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 573, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.pos_measurement_amount {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 634, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.time_window_information_measurement_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 803, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        encode::encode_sequence_header(data, true, &BitString::new(), false)?;
        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for PositioningMeasurementRequest {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PositioningMeasurementRequest::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PositioningMeasurementRequest");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PositioningMeasurementRequest");
            e
        })
    }
}
// PositioningMeasurementResponse
#[derive(Clone, Debug)]
pub struct PositioningMeasurementResponse {
    pub transaction_id: TransactionId,
    pub lmf_measurement_id: LmfMeasurementId,
    pub ran_measurement_id: RanMeasurementId,
    pub pos_measurement_result_list: Option<PosMeasurementResultList>,
    pub criticality_diagnostics: Option<CriticalityDiagnostics>,
}

impl PositioningMeasurementResponse {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let _ = decode::decode_sequence_header(data, true, 0)?;
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut transaction_id: Option<TransactionId> = None;
        let mut lmf_measurement_id: Option<LmfMeasurementId> = None;
        let mut ran_measurement_id: Option<RanMeasurementId> = None;
        let mut pos_measurement_result_list: Option<PosMeasurementResultList> = None;
        let mut criticality_diagnostics: Option<CriticalityDiagnostics> = None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                78 => transaction_id = Some(TransactionId::decode(data)?),
                402 => lmf_measurement_id = Some(LmfMeasurementId::decode(data)?),
                411 => ran_measurement_id = Some(RanMeasurementId::decode(data)?),
                397 => pos_measurement_result_list = Some(PosMeasurementResultList::decode(data)?),
                7 => criticality_diagnostics = Some(CriticalityDiagnostics::decode(data)?),
                x => return Err(per_codec_error_new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        let transaction_id = transaction_id.ok_or(per_codec_error_new(format!(
            "Missing mandatory IE transaction_id"
        )))?;
        let lmf_measurement_id = lmf_measurement_id.ok_or(per_codec_error_new(format!(
            "Missing mandatory IE lmf_measurement_id"
        )))?;
        let ran_measurement_id = ran_measurement_id.ok_or(per_codec_error_new(format!(
            "Missing mandatory IE ran_measurement_id"
        )))?;
        Ok(Self {
            transaction_id,
            lmf_measurement_id,
            ran_measurement_id,
            pos_measurement_result_list,
            criticality_diagnostics,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        let ie = &mut Allocator::new_codec_data();
        self.transaction_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 78, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.lmf_measurement_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 402, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.ran_measurement_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 411, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        if let Some(x) = &self.pos_measurement_result_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 397, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.criticality_diagnostics {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 7, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        encode::encode_sequence_header(data, true, &BitString::new(), false)?;
        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for PositioningMeasurementResponse {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PositioningMeasurementResponse::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PositioningMeasurementResponse");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PositioningMeasurementResponse");
            e
        })
    }
}
// PositioningMeasurementFailure
#[derive(Clone, Debug)]
pub struct PositioningMeasurementFailure {
    pub transaction_id: TransactionId,
    pub lmf_measurement_id: LmfMeasurementId,
    pub ran_measurement_id: RanMeasurementId,
    pub cause: Cause,
    pub criticality_diagnostics: Option<CriticalityDiagnostics>,
}

impl PositioningMeasurementFailure {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let _ = decode::decode_sequence_header(data, true, 0)?;
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut transaction_id: Option<TransactionId> = None;
        let mut lmf_measurement_id: Option<LmfMeasurementId> = None;
        let mut ran_measurement_id: Option<RanMeasurementId> = None;
        let mut cause: Option<Cause> = None;
        let mut criticality_diagnostics: Option<CriticalityDiagnostics> = None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                78 => transaction_id = Some(TransactionId::decode(data)?),
                402 => lmf_measurement_id = Some(LmfMeasurementId::decode(data)?),
                411 => ran_measurement_id = Some(RanMeasurementId::decode(data)?),
                0 => cause = Some(Cause::decode(data)?),
                7 => criticality_diagnostics = Some(CriticalityDiagnostics::decode(data)?),
                x => return Err(per_codec_error_new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        let transaction_id = transaction_id.ok_or(per_codec_error_new(format!(
            "Missing mandatory IE transaction_id"
        )))?;
        let lmf_measurement_id = lmf_measurement_id.ok_or(per_codec_error_new(format!(
            "Missing mandatory IE lmf_measurement_id"
        )))?;
        let ran_measurement_id = ran_measurement_id.ok_or(per_codec_error_new(format!(
            "Missing mandatory IE ran_measurement_id"
        )))?;
        let cause = cause.ok_or(per_codec_error_new(format!("Missing mandatory IE cause")))?;
        Ok(Self {
            transaction_id,
            lmf_measurement_id,
            ran_measurement_id,
            cause,
            criticality_diagnostics,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        let ie = &mut Allocator::new_codec_data();
        self.transaction_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 78, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.lmf_measurement_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 402, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.ran_measurement_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 411, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.cause.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 0, false)?;
        Criticality::Ignore.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        if let Some(x) = &self.criticality_diagnostics {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 7, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        encode::encode_sequence_header(data, true, &BitString::new(), false)?;
        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for PositioningMeasurementFailure {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PositioningMeasurementFailure::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PositioningMeasurementFailure");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PositioningMeasurementFailure");
            e
        })
    }
}
// PositioningMeasurementReport
#[derive(Clone, Debug)]
pub struct PositioningMeasurementReport {
    pub transaction_id: TransactionId,
    pub lmf_measurement_id: LmfMeasurementId,
    pub ran_measurement_id: RanMeasurementId,
    pub pos_measurement_result_list: PosMeasurementResultList,
}

impl PositioningMeasurementReport {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let _ = decode::decode_sequence_header(data, true, 0)?;
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut transaction_id: Option<TransactionId> = None;
        let mut lmf_measurement_id: Option<LmfMeasurementId> = None;
        let mut ran_measurement_id: Option<RanMeasurementId> = None;
        let mut pos_measurement_result_list: Option<PosMeasurementResultList> = None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                78 => transaction_id = Some(TransactionId::decode(data)?),
                402 => lmf_measurement_id = Some(LmfMeasurementId::decode(data)?),
                411 => ran_measurement_id = Some(RanMeasurementId::decode(data)?),
                397 => pos_measurement_result_list = Some(PosMeasurementResultList::decode(data)?),
                x => return Err(per_codec_error_new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        let transaction_id = transaction_id.ok_or(per_codec_error_new(format!(
            "Missing mandatory IE transaction_id"
        )))?;
        let lmf_measurement_id = lmf_measurement_id.ok_or(per_codec_error_new(format!(
            "Missing mandatory IE lmf_measurement_id"
        )))?;
        let ran_measurement_id = ran_measurement_id.ok_or(per_codec_error_new(format!(
            "Missing mandatory IE ran_measurement_id"
        )))?;
        let pos_measurement_result_list = pos_measurement_result_list.ok_or(
            per_codec_error_new(format!("Missing mandatory IE pos_measurement_result_list")),
        )?;
        Ok(Self {
            transaction_id,
            lmf_measurement_id,
            ran_measurement_id,
            pos_measurement_result_list,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        let ie = &mut Allocator::new_codec_data();
        self.transaction_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 78, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.lmf_measurement_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 402, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.ran_measurement_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 411, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.pos_measurement_result_list.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 397, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        encode::encode_sequence_header(data, true, &BitString::new(), false)?;
        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for PositioningMeasurementReport {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PositioningMeasurementReport::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PositioningMeasurementReport");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PositioningMeasurementReport");
            e
        })
    }
}
// PositioningMeasurementAbort
#[derive(Clone, Debug)]
pub struct PositioningMeasurementAbort {
    pub transaction_id: TransactionId,
    pub lmf_measurement_id: LmfMeasurementId,
    pub ran_measurement_id: RanMeasurementId,
}

impl PositioningMeasurementAbort {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let _ = decode::decode_sequence_header(data, true, 0)?;
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut transaction_id: Option<TransactionId> = None;
        let mut lmf_measurement_id: Option<LmfMeasurementId> = None;
        let mut ran_measurement_id: Option<RanMeasurementId> = None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                78 => transaction_id = Some(TransactionId::decode(data)?),
                402 => lmf_measurement_id = Some(LmfMeasurementId::decode(data)?),
                411 => ran_measurement_id = Some(RanMeasurementId::decode(data)?),
                x => return Err(per_codec_error_new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        let transaction_id = transaction_id.ok_or(per_codec_error_new(format!(
            "Missing mandatory IE transaction_id"
        )))?;
        let lmf_measurement_id = lmf_measurement_id.ok_or(per_codec_error_new(format!(
            "Missing mandatory IE lmf_measurement_id"
        )))?;
        let ran_measurement_id = ran_measurement_id.ok_or(per_codec_error_new(format!(
            "Missing mandatory IE ran_measurement_id"
        )))?;
        Ok(Self {
            transaction_id,
            lmf_measurement_id,
            ran_measurement_id,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        let ie = &mut Allocator::new_codec_data();
        self.transaction_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 78, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.lmf_measurement_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 402, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.ran_measurement_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 411, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        encode::encode_sequence_header(data, true, &BitString::new(), false)?;
        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for PositioningMeasurementAbort {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PositioningMeasurementAbort::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PositioningMeasurementAbort");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PositioningMeasurementAbort");
            e
        })
    }
}
// PositioningMeasurementFailureIndication
#[derive(Clone, Debug)]
pub struct PositioningMeasurementFailureIndication {
    pub transaction_id: TransactionId,
    pub lmf_measurement_id: LmfMeasurementId,
    pub ran_measurement_id: RanMeasurementId,
    pub cause: Cause,
}

impl PositioningMeasurementFailureIndication {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let _ = decode::decode_sequence_header(data, true, 0)?;
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut transaction_id: Option<TransactionId> = None;
        let mut lmf_measurement_id: Option<LmfMeasurementId> = None;
        let mut ran_measurement_id: Option<RanMeasurementId> = None;
        let mut cause: Option<Cause> = None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                78 => transaction_id = Some(TransactionId::decode(data)?),
                402 => lmf_measurement_id = Some(LmfMeasurementId::decode(data)?),
                411 => ran_measurement_id = Some(RanMeasurementId::decode(data)?),
                0 => cause = Some(Cause::decode(data)?),
                x => return Err(per_codec_error_new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        let transaction_id = transaction_id.ok_or(per_codec_error_new(format!(
            "Missing mandatory IE transaction_id"
        )))?;
        let lmf_measurement_id = lmf_measurement_id.ok_or(per_codec_error_new(format!(
            "Missing mandatory IE lmf_measurement_id"
        )))?;
        let ran_measurement_id = ran_measurement_id.ok_or(per_codec_error_new(format!(
            "Missing mandatory IE ran_measurement_id"
        )))?;
        let cause = cause.ok_or(per_codec_error_new(format!("Missing mandatory IE cause")))?;
        Ok(Self {
            transaction_id,
            lmf_measurement_id,
            ran_measurement_id,
            cause,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        let ie = &mut Allocator::new_codec_data();
        self.transaction_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 78, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.lmf_measurement_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 402, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.ran_measurement_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 411, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.cause.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 0, false)?;
        Criticality::Ignore.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        encode::encode_sequence_header(data, true, &BitString::new(), false)?;
        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for PositioningMeasurementFailureIndication {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PositioningMeasurementFailureIndication::decode_inner(data).map_err(
            |mut e: PerCodecError| {
                e.push_context("PositioningMeasurementFailureIndication");
                e
            },
        )
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PositioningMeasurementFailureIndication");
            e
        })
    }
}
// PositioningMeasurementUpdate
#[derive(Clone, Debug)]
pub struct PositioningMeasurementUpdate {
    pub transaction_id: TransactionId,
    pub lmf_measurement_id: LmfMeasurementId,
    pub ran_measurement_id: RanMeasurementId,
    pub srs_configuration: Option<SrsConfiguration>,
    pub trp_measurement_update_list: Option<TrpMeasurementUpdateList>,
    pub measurement_characteristics_request_indicator:
        Option<MeasurementCharacteristicsRequestIndicator>,
    pub measurement_time_occasion: Option<MeasurementTimeOccasion>,
}

impl PositioningMeasurementUpdate {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let _ = decode::decode_sequence_header(data, true, 0)?;
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut transaction_id: Option<TransactionId> = None;
        let mut lmf_measurement_id: Option<LmfMeasurementId> = None;
        let mut ran_measurement_id: Option<RanMeasurementId> = None;
        let mut srs_configuration: Option<SrsConfiguration> = None;
        let mut trp_measurement_update_list: Option<TrpMeasurementUpdateList> = None;
        let mut measurement_characteristics_request_indicator: Option<
            MeasurementCharacteristicsRequestIndicator,
        > = None;
        let mut measurement_time_occasion: Option<MeasurementTimeOccasion> = None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                78 => transaction_id = Some(TransactionId::decode(data)?),
                402 => lmf_measurement_id = Some(LmfMeasurementId::decode(data)?),
                411 => ran_measurement_id = Some(RanMeasurementId::decode(data)?),
                407 => srs_configuration = Some(SrsConfiguration::decode(data)?),
                553 => trp_measurement_update_list = Some(TrpMeasurementUpdateList::decode(data)?),
                574 => {
                    measurement_characteristics_request_indicator =
                        Some(MeasurementCharacteristicsRequestIndicator::decode(data)?)
                }
                573 => measurement_time_occasion = Some(MeasurementTimeOccasion::decode(data)?),
                x => return Err(per_codec_error_new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        let transaction_id = transaction_id.ok_or(per_codec_error_new(format!(
            "Missing mandatory IE transaction_id"
        )))?;
        let lmf_measurement_id = lmf_measurement_id.ok_or(per_codec_error_new(format!(
            "Missing mandatory IE lmf_measurement_id"
        )))?;
        let ran_measurement_id = ran_measurement_id.ok_or(per_codec_error_new(format!(
            "Missing mandatory IE ran_measurement_id"
        )))?;
        Ok(Self {
            transaction_id,
            lmf_measurement_id,
            ran_measurement_id,
            srs_configuration,
            trp_measurement_update_list,
            measurement_characteristics_request_indicator,
            measurement_time_occasion,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        let ie = &mut Allocator::new_codec_data();
        self.transaction_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 78, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.lmf_measurement_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 402, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.ran_measurement_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 411, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        if let Some(x) = &self.srs_configuration {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 407, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.trp_measurement_update_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 553, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.measurement_characteristics_request_indicator {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 574, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.measurement_time_occasion {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 573, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        encode::encode_sequence_header(data, true, &BitString::new(), false)?;
        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for PositioningMeasurementUpdate {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PositioningMeasurementUpdate::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PositioningMeasurementUpdate");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PositioningMeasurementUpdate");
            e
        })
    }
}
// TrpInformationRequest
#[derive(Clone, Debug)]
pub struct TrpInformationRequest {
    pub transaction_id: TransactionId,
    pub trp_list: Option<TrpList>,
    pub trp_information_type_list_trp_req: TrpInformationTypeListTrpReq,
}

impl TrpInformationRequest {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let _ = decode::decode_sequence_header(data, true, 0)?;
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut transaction_id: Option<TransactionId> = None;
        let mut trp_list: Option<TrpList> = None;
        let mut trp_information_type_list_trp_req: Option<TrpInformationTypeListTrpReq> = None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                78 => transaction_id = Some(TransactionId::decode(data)?),
                410 => trp_list = Some(TrpList::decode(data)?),
                398 => {
                    trp_information_type_list_trp_req =
                        Some(TrpInformationTypeListTrpReq::decode(data)?)
                }
                x => return Err(per_codec_error_new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        let transaction_id = transaction_id.ok_or(per_codec_error_new(format!(
            "Missing mandatory IE transaction_id"
        )))?;
        let trp_information_type_list_trp_req =
            trp_information_type_list_trp_req.ok_or(per_codec_error_new(format!(
                "Missing mandatory IE trp_information_type_list_trp_req"
            )))?;
        Ok(Self {
            transaction_id,
            trp_list,
            trp_information_type_list_trp_req,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        let ie = &mut Allocator::new_codec_data();
        self.transaction_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 78, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        if let Some(x) = &self.trp_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 410, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        let ie = &mut Allocator::new_codec_data();
        self.trp_information_type_list_trp_req.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 398, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        encode::encode_sequence_header(data, true, &BitString::new(), false)?;
        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for TrpInformationRequest {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        TrpInformationRequest::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TrpInformationRequest");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TrpInformationRequest");
            e
        })
    }
}
// TrpInformationTypeListTrpReq
#[derive(Clone, Debug)]
pub struct TrpInformationTypeListTrpReq(pub NonEmpty<TrpInformationTypeItem>);

impl TrpInformationTypeListTrpReq {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(64), false)?;
            let mut items = vec![];
            for _ in 0..length {
                let _ = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _ = Criticality::decode(data)?;
                let _ = decode::decode_length_determinent(data, None, None, false)?;
                items.push(TrpInformationTypeItem::decode(data)?);
                data.decode_align()?;
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(64), false, self.0.len())?;
        for x in &self.0 {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(data, Some(0), Some(65535), false, 399, false)?;
            Criticality::Reject.encode(data)?;
            encode::encode_length_determinent(data, None, None, false, ie.length_in_bytes())?;
            data.append_aligned(ie);
        }
        Ok(())
    }
}

impl PerCodec for TrpInformationTypeListTrpReq {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        TrpInformationTypeListTrpReq::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TrpInformationTypeListTrpReq");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TrpInformationTypeListTrpReq");
            e
        })
    }
}
// TrpInformationResponse
#[derive(Clone, Debug)]
pub struct TrpInformationResponse {
    pub transaction_id: TransactionId,
    pub trp_information_list_trp_resp: TrpInformationListTrpResp,
    pub criticality_diagnostics: Option<CriticalityDiagnostics>,
}

impl TrpInformationResponse {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let _ = decode::decode_sequence_header(data, true, 0)?;
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut transaction_id: Option<TransactionId> = None;
        let mut trp_information_list_trp_resp: Option<TrpInformationListTrpResp> = None;
        let mut criticality_diagnostics: Option<CriticalityDiagnostics> = None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                78 => transaction_id = Some(TransactionId::decode(data)?),
                400 => {
                    trp_information_list_trp_resp = Some(TrpInformationListTrpResp::decode(data)?)
                }
                7 => criticality_diagnostics = Some(CriticalityDiagnostics::decode(data)?),
                x => return Err(per_codec_error_new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        let transaction_id = transaction_id.ok_or(per_codec_error_new(format!(
            "Missing mandatory IE transaction_id"
        )))?;
        let trp_information_list_trp_resp =
            trp_information_list_trp_resp.ok_or(per_codec_error_new(format!(
                "Missing mandatory IE trp_information_list_trp_resp"
            )))?;
        Ok(Self {
            transaction_id,
            trp_information_list_trp_resp,
            criticality_diagnostics,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        let ie = &mut Allocator::new_codec_data();
        self.transaction_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 78, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.trp_information_list_trp_resp.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 400, false)?;
        Criticality::Ignore.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        if let Some(x) = &self.criticality_diagnostics {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 7, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        encode::encode_sequence_header(data, true, &BitString::new(), false)?;
        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for TrpInformationResponse {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        TrpInformationResponse::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TrpInformationResponse");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TrpInformationResponse");
            e
        })
    }
}
// TrpInformationListTrpResp
#[derive(Clone, Debug)]
pub struct TrpInformationListTrpResp(pub NonEmpty<TrpInformationItem>);

impl TrpInformationListTrpResp {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            let mut items = vec![];
            for _ in 0..length {
                let _ = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _ = Criticality::decode(data)?;
                let _ = decode::decode_length_determinent(data, None, None, false)?;
                items.push(TrpInformationItem::decode(data)?);
                data.decode_align()?;
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(65535), false, self.0.len())?;
        for x in &self.0 {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(data, Some(0), Some(65535), false, 401, false)?;
            Criticality::Ignore.encode(data)?;
            encode::encode_length_determinent(data, None, None, false, ie.length_in_bytes())?;
            data.append_aligned(ie);
        }
        Ok(())
    }
}

impl PerCodec for TrpInformationListTrpResp {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        TrpInformationListTrpResp::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TrpInformationListTrpResp");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TrpInformationListTrpResp");
            e
        })
    }
}
// TrpInformationFailure
#[derive(Clone, Debug)]
pub struct TrpInformationFailure {
    pub transaction_id: TransactionId,
    pub cause: Cause,
    pub criticality_diagnostics: Option<CriticalityDiagnostics>,
}

impl TrpInformationFailure {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let _ = decode::decode_sequence_header(data, true, 0)?;
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut transaction_id: Option<TransactionId> = None;
        let mut cause: Option<Cause> = None;
        let mut criticality_diagnostics: Option<CriticalityDiagnostics> = None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                78 => transaction_id = Some(TransactionId::decode(data)?),
                0 => cause = Some(Cause::decode(data)?),
                7 => criticality_diagnostics = Some(CriticalityDiagnostics::decode(data)?),
                x => return Err(per_codec_error_new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        let transaction_id = transaction_id.ok_or(per_codec_error_new(format!(
            "Missing mandatory IE transaction_id"
        )))?;
        let cause = cause.ok_or(per_codec_error_new(format!("Missing mandatory IE cause")))?;
        Ok(Self {
            transaction_id,
            cause,
            criticality_diagnostics,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        let ie = &mut Allocator::new_codec_data();
        self.transaction_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 78, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.cause.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 0, false)?;
        Criticality::Ignore.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        if let Some(x) = &self.criticality_diagnostics {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 7, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        encode::encode_sequence_header(data, true, &BitString::new(), false)?;
        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for TrpInformationFailure {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        TrpInformationFailure::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TrpInformationFailure");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TrpInformationFailure");
            e
        })
    }
}
// PositioningInformationRequest
#[derive(Clone, Debug)]
pub struct PositioningInformationRequest {
    pub gnb_cu_ue_f1ap_id: GnbCuUeF1apId,
    pub gnb_du_ue_f1ap_id: GnbDuUeF1apId,
    pub requested_srs_transmission_characteristics: Option<RequestedSrsTransmissionCharacteristics>,
    pub ue_reporting_information: Option<UeReportingInformation>,
    pub srs_pos_rrc_inactive_query_indication: Option<SrsPosRrcInactiveQueryIndication>,
    pub time_window_information_srs_list: Option<TimeWindowInformationSrsList>,
    pub requested_srs_preconfiguration_characteristics_list:
        Option<RequestedSrsPreconfigurationCharacteristicsList>,
}

impl PositioningInformationRequest {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let _ = decode::decode_sequence_header(data, true, 0)?;
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut gnb_cu_ue_f1ap_id: Option<GnbCuUeF1apId> = None;
        let mut gnb_du_ue_f1ap_id: Option<GnbDuUeF1apId> = None;
        let mut requested_srs_transmission_characteristics: Option<
            RequestedSrsTransmissionCharacteristics,
        > = None;
        let mut ue_reporting_information: Option<UeReportingInformation> = None;
        let mut srs_pos_rrc_inactive_query_indication: Option<SrsPosRrcInactiveQueryIndication> =
            None;
        let mut time_window_information_srs_list: Option<TimeWindowInformationSrsList> = None;
        let mut requested_srs_preconfiguration_characteristics_list: Option<
            RequestedSrsPreconfigurationCharacteristicsList,
        > = None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                40 => gnb_cu_ue_f1ap_id = Some(GnbCuUeF1apId::decode(data)?),
                41 => gnb_du_ue_f1ap_id = Some(GnbDuUeF1apId::decode(data)?),
                391 => {
                    requested_srs_transmission_characteristics =
                        Some(RequestedSrsTransmissionCharacteristics::decode(data)?)
                }
                575 => ue_reporting_information = Some(UeReportingInformation::decode(data)?),
                689 => {
                    srs_pos_rrc_inactive_query_indication =
                        Some(SrsPosRrcInactiveQueryIndication::decode(data)?)
                }
                802 => {
                    time_window_information_srs_list =
                        Some(TimeWindowInformationSrsList::decode(data)?)
                }
                830 => {
                    requested_srs_preconfiguration_characteristics_list = Some(
                        RequestedSrsPreconfigurationCharacteristicsList::decode(data)?,
                    )
                }
                x => return Err(per_codec_error_new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        let gnb_cu_ue_f1ap_id = gnb_cu_ue_f1ap_id.ok_or(per_codec_error_new(format!(
            "Missing mandatory IE gnb_cu_ue_f1ap_id"
        )))?;
        let gnb_du_ue_f1ap_id = gnb_du_ue_f1ap_id.ok_or(per_codec_error_new(format!(
            "Missing mandatory IE gnb_du_ue_f1ap_id"
        )))?;
        Ok(Self {
            gnb_cu_ue_f1ap_id,
            gnb_du_ue_f1ap_id,
            requested_srs_transmission_characteristics,
            ue_reporting_information,
            srs_pos_rrc_inactive_query_indication,
            time_window_information_srs_list,
            requested_srs_preconfiguration_characteristics_list,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        let ie = &mut Allocator::new_codec_data();
        self.gnb_cu_ue_f1ap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 40, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.gnb_du_ue_f1ap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 41, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        if let Some(x) = &self.requested_srs_transmission_characteristics {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 391, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.ue_reporting_information {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 575, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.srs_pos_rrc_inactive_query_indication {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 689, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.time_window_information_srs_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 802, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.requested_srs_preconfiguration_characteristics_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 830, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        encode::encode_sequence_header(data, true, &BitString::new(), false)?;
        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for PositioningInformationRequest {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PositioningInformationRequest::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PositioningInformationRequest");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PositioningInformationRequest");
            e
        })
    }
}
// PositioningInformationResponse
#[derive(Clone, Debug)]
pub struct PositioningInformationResponse {
    pub gnb_cu_ue_f1ap_id: GnbCuUeF1apId,
    pub gnb_du_ue_f1ap_id: GnbDuUeF1apId,
    pub srs_configuration: Option<SrsConfiguration>,
    pub sfn_initialisation_time: Option<RelativeTime1900>,
    pub criticality_diagnostics: Option<CriticalityDiagnostics>,
    pub srs_pos_rrc_inactive_config: Option<SrsPosRrcInactiveConfig>,
    pub srs_pos_rrc_inactive_validity_area_config: Option<SrsPosRrcInactiveValidityAreaConfig>,
    pub srs_preconfiguration_list: Option<SrsPreconfigurationList>,
}

impl PositioningInformationResponse {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let _ = decode::decode_sequence_header(data, true, 0)?;
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut gnb_cu_ue_f1ap_id: Option<GnbCuUeF1apId> = None;
        let mut gnb_du_ue_f1ap_id: Option<GnbDuUeF1apId> = None;
        let mut srs_configuration: Option<SrsConfiguration> = None;
        let mut sfn_initialisation_time: Option<RelativeTime1900> = None;
        let mut criticality_diagnostics: Option<CriticalityDiagnostics> = None;
        let mut srs_pos_rrc_inactive_config: Option<SrsPosRrcInactiveConfig> = None;
        let mut srs_pos_rrc_inactive_validity_area_config: Option<
            SrsPosRrcInactiveValidityAreaConfig,
        > = None;
        let mut srs_preconfiguration_list: Option<SrsPreconfigurationList> = None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                40 => gnb_cu_ue_f1ap_id = Some(GnbCuUeF1apId::decode(data)?),
                41 => gnb_du_ue_f1ap_id = Some(GnbDuUeF1apId::decode(data)?),
                407 => srs_configuration = Some(SrsConfiguration::decode(data)?),
                419 => sfn_initialisation_time = Some(RelativeTime1900::decode(data)?),
                7 => criticality_diagnostics = Some(CriticalityDiagnostics::decode(data)?),
                674 => srs_pos_rrc_inactive_config = Some(SrsPosRrcInactiveConfig::decode(data)?),
                811 => {
                    srs_pos_rrc_inactive_validity_area_config =
                        Some(SrsPosRrcInactiveValidityAreaConfig::decode(data)?)
                }
                831 => srs_preconfiguration_list = Some(SrsPreconfigurationList::decode(data)?),
                x => return Err(per_codec_error_new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        let gnb_cu_ue_f1ap_id = gnb_cu_ue_f1ap_id.ok_or(per_codec_error_new(format!(
            "Missing mandatory IE gnb_cu_ue_f1ap_id"
        )))?;
        let gnb_du_ue_f1ap_id = gnb_du_ue_f1ap_id.ok_or(per_codec_error_new(format!(
            "Missing mandatory IE gnb_du_ue_f1ap_id"
        )))?;
        Ok(Self {
            gnb_cu_ue_f1ap_id,
            gnb_du_ue_f1ap_id,
            srs_configuration,
            sfn_initialisation_time,
            criticality_diagnostics,
            srs_pos_rrc_inactive_config,
            srs_pos_rrc_inactive_validity_area_config,
            srs_preconfiguration_list,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        let ie = &mut Allocator::new_codec_data();
        self.gnb_cu_ue_f1ap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 40, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.gnb_du_ue_f1ap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 41, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        if let Some(x) = &self.srs_configuration {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 407, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.sfn_initialisation_time {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 419, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.criticality_diagnostics {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 7, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.srs_pos_rrc_inactive_config {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 674, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.srs_pos_rrc_inactive_validity_area_config {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 811, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.srs_preconfiguration_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 831, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        encode::encode_sequence_header(data, true, &BitString::new(), false)?;
        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for PositioningInformationResponse {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PositioningInformationResponse::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PositioningInformationResponse");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PositioningInformationResponse");
            e
        })
    }
}
// PositioningInformationFailure
#[derive(Clone, Debug)]
pub struct PositioningInformationFailure {
    pub gnb_cu_ue_f1ap_id: GnbCuUeF1apId,
    pub gnb_du_ue_f1ap_id: GnbDuUeF1apId,
    pub cause: Cause,
    pub criticality_diagnostics: Option<CriticalityDiagnostics>,
}

impl PositioningInformationFailure {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let _ = decode::decode_sequence_header(data, true, 0)?;
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut gnb_cu_ue_f1ap_id: Option<GnbCuUeF1apId> = None;
        let mut gnb_du_ue_f1ap_id: Option<GnbDuUeF1apId> = None;
        let mut cause: Option<Cause> = None;
        let mut criticality_diagnostics: Option<CriticalityDiagnostics> = None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                40 => gnb_cu_ue_f1ap_id = Some(GnbCuUeF1apId::decode(data)?),
                41 => gnb_du_ue_f1ap_id = Some(GnbDuUeF1apId::decode(data)?),
                0 => cause = Some(Cause::decode(data)?),
                7 => criticality_diagnostics = Some(CriticalityDiagnostics::decode(data)?),
                x => return Err(per_codec_error_new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        let gnb_cu_ue_f1ap_id = gnb_cu_ue_f1ap_id.ok_or(per_codec_error_new(format!(
            "Missing mandatory IE gnb_cu_ue_f1ap_id"
        )))?;
        let gnb_du_ue_f1ap_id = gnb_du_ue_f1ap_id.ok_or(per_codec_error_new(format!(
            "Missing mandatory IE gnb_du_ue_f1ap_id"
        )))?;
        let cause = cause.ok_or(per_codec_error_new(format!("Missing mandatory IE cause")))?;
        Ok(Self {
            gnb_cu_ue_f1ap_id,
            gnb_du_ue_f1ap_id,
            cause,
            criticality_diagnostics,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        let ie = &mut Allocator::new_codec_data();
        self.gnb_cu_ue_f1ap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 40, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.gnb_du_ue_f1ap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 41, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.cause.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 0, false)?;
        Criticality::Ignore.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        if let Some(x) = &self.criticality_diagnostics {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 7, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        encode::encode_sequence_header(data, true, &BitString::new(), false)?;
        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for PositioningInformationFailure {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PositioningInformationFailure::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PositioningInformationFailure");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PositioningInformationFailure");
            e
        })
    }
}
// PositioningActivationRequest
#[derive(Clone, Debug)]
pub struct PositioningActivationRequest {
    pub gnb_cu_ue_f1ap_id: GnbCuUeF1apId,
    pub gnb_du_ue_f1ap_id: GnbDuUeF1apId,
    pub srs_type: SrsType,
    pub activation_time: Option<RelativeTime1900>,
}

impl PositioningActivationRequest {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let _ = decode::decode_sequence_header(data, true, 0)?;
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut gnb_cu_ue_f1ap_id: Option<GnbCuUeF1apId> = None;
        let mut gnb_du_ue_f1ap_id: Option<GnbDuUeF1apId> = None;
        let mut srs_type: Option<SrsType> = None;
        let mut activation_time: Option<RelativeTime1900> = None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                40 => gnb_cu_ue_f1ap_id = Some(GnbCuUeF1apId::decode(data)?),
                41 => gnb_du_ue_f1ap_id = Some(GnbDuUeF1apId::decode(data)?),
                403 => srs_type = Some(SrsType::decode(data)?),
                404 => activation_time = Some(RelativeTime1900::decode(data)?),
                x => return Err(per_codec_error_new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        let gnb_cu_ue_f1ap_id = gnb_cu_ue_f1ap_id.ok_or(per_codec_error_new(format!(
            "Missing mandatory IE gnb_cu_ue_f1ap_id"
        )))?;
        let gnb_du_ue_f1ap_id = gnb_du_ue_f1ap_id.ok_or(per_codec_error_new(format!(
            "Missing mandatory IE gnb_du_ue_f1ap_id"
        )))?;
        let srs_type = srs_type.ok_or(per_codec_error_new(format!(
            "Missing mandatory IE srs_type"
        )))?;
        Ok(Self {
            gnb_cu_ue_f1ap_id,
            gnb_du_ue_f1ap_id,
            srs_type,
            activation_time,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        let ie = &mut Allocator::new_codec_data();
        self.gnb_cu_ue_f1ap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 40, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.gnb_du_ue_f1ap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 41, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.srs_type.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 403, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        if let Some(x) = &self.activation_time {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 404, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        encode::encode_sequence_header(data, true, &BitString::new(), false)?;
        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for PositioningActivationRequest {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PositioningActivationRequest::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PositioningActivationRequest");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PositioningActivationRequest");
            e
        })
    }
}
// SrsType
#[derive(Clone, Debug)]
pub enum SrsType {
    SemipersistentSrs(SemipersistentSrs),
    AperiodicSrs(AperiodicSrs),
}

impl SrsType {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_choice_idx(data, 0, 2, false)?;
        if extended {
            return Err(per_codec_error_new("CHOICE additions not implemented"));
        }
        match idx {
            0 => Ok(Self::SemipersistentSrs(SemipersistentSrs::decode(data)?)),
            1 => Ok(Self::AperiodicSrs(AperiodicSrs::decode(data)?)),
            2 => {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _ = Criticality::decode(data)?;
                let _ = decode::decode_length_determinent(data, None, None, false)?;
                let result = match id {
                    x => Err(per_codec_error_new(format!("Unrecognised IE type {}", x))),
                };
                data.decode_align()?;
                result
            }
            _ => Err(per_codec_error_new("Unknown choice idx")),
        }
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        match self {
            Self::SemipersistentSrs(x) => {
                encode::encode_choice_idx(data, 0, 2, false, 0, false)?;
                x.encode(data)
            }
            Self::AperiodicSrs(x) => {
                encode::encode_choice_idx(data, 0, 2, false, 1, false)?;
                x.encode(data)
            }
        }
    }
}

impl PerCodec for SrsType {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        SrsType::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SrsType");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SrsType");
            e
        })
    }
}
// SemipersistentSrs
#[derive(Clone, Debug)]
pub struct SemipersistentSrs {
    pub srs_resource_set_id: SrsResourceSetId,
    pub srs_spatial_relation: Option<SpatialRelationInfo>,
    pub srs_spatial_relation_per_srs_resource: Option<SpatialRelationPerSrsResource>,
    pub aggregated_pos_srs_resource_set_list: Option<AggregatedPosSrsResourceSetList>,
}

impl SemipersistentSrs {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 2)?;
        let srs_resource_set_id = SrsResourceSetId::decode(data)?;
        let srs_spatial_relation = if optionals[0] {
            Some(SpatialRelationInfo::decode(data)?)
        } else {
            None
        };

        // Process the extension container
        let mut srs_spatial_relation_per_srs_resource: Option<SpatialRelationPerSrsResource> = None;
        let mut aggregated_pos_srs_resource_set_list: Option<AggregatedPosSrsResourceSetList> =
            None;

        if optionals[1] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    435 => {
                        srs_spatial_relation_per_srs_resource =
                            Some(SpatialRelationPerSrsResource::decode(data)?)
                    }
                    829 => {
                        aggregated_pos_srs_resource_set_list =
                            Some(AggregatedPosSrsResourceSetList::decode(data)?)
                    }
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            srs_resource_set_id,
            srs_spatial_relation,
            srs_spatial_relation_per_srs_resource,
            aggregated_pos_srs_resource_set_list,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();
        if let Some(x) = &self.srs_spatial_relation_per_srs_resource {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 435, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.aggregated_pos_srs_resource_set_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 829, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        let mut optionals = BitString::new();
        optionals.push(self.srs_spatial_relation.is_some());
        optionals.push(num_ies != 0);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.srs_resource_set_id.encode(data)?;
        if let Some(x) = &self.srs_spatial_relation {
            x.encode(data)?;
        }
        if num_ies != 0 {
            encode::encode_length_determinent(data, Some(1), Some(65535), false, num_ies)?;
            data.append_aligned(ies);
        }
        Ok(())
    }
}

impl PerCodec for SemipersistentSrs {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        SemipersistentSrs::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SemipersistentSrs");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SemipersistentSrs");
            e
        })
    }
}
// AperiodicSrs
#[derive(Clone, Debug)]
pub struct AperiodicSrs {
    pub aperiodic: Aperiodic,
    pub srs_resource_trigger: Option<SrsResourceTrigger>,
    pub aggregated_pos_srs_resource_set_list: Option<AggregatedPosSrsResourceSetList>,
}

impl AperiodicSrs {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 2)?;
        let aperiodic = Aperiodic::decode(data)?;
        let srs_resource_trigger = if optionals[0] {
            Some(SrsResourceTrigger::decode(data)?)
        } else {
            None
        };

        // Process the extension container
        let mut aggregated_pos_srs_resource_set_list: Option<AggregatedPosSrsResourceSetList> =
            None;

        if optionals[1] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    829 => {
                        aggregated_pos_srs_resource_set_list =
                            Some(AggregatedPosSrsResourceSetList::decode(data)?)
                    }
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            aperiodic,
            srs_resource_trigger,
            aggregated_pos_srs_resource_set_list,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();
        if let Some(x) = &self.aggregated_pos_srs_resource_set_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 829, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        let mut optionals = BitString::new();
        optionals.push(self.srs_resource_trigger.is_some());
        optionals.push(num_ies != 0);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.aperiodic.encode(data)?;
        if let Some(x) = &self.srs_resource_trigger {
            x.encode(data)?;
        }
        if num_ies != 0 {
            encode::encode_length_determinent(data, Some(1), Some(65535), false, num_ies)?;
            data.append_aligned(ies);
        }
        Ok(())
    }
}

impl PerCodec for AperiodicSrs {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        AperiodicSrs::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("AperiodicSrs");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("AperiodicSrs");
            e
        })
    }
}
// PositioningActivationResponse
#[derive(Clone, Debug)]
pub struct PositioningActivationResponse {
    pub gnb_cu_ue_f1ap_id: GnbCuUeF1apId,
    pub gnb_du_ue_f1ap_id: GnbDuUeF1apId,
    pub system_frame_number: Option<SystemFrameNumber>,
    pub slot_number: Option<SlotNumber>,
    pub criticality_diagnostics: Option<CriticalityDiagnostics>,
}

impl PositioningActivationResponse {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let _ = decode::decode_sequence_header(data, true, 0)?;
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut gnb_cu_ue_f1ap_id: Option<GnbCuUeF1apId> = None;
        let mut gnb_du_ue_f1ap_id: Option<GnbDuUeF1apId> = None;
        let mut system_frame_number: Option<SystemFrameNumber> = None;
        let mut slot_number: Option<SlotNumber> = None;
        let mut criticality_diagnostics: Option<CriticalityDiagnostics> = None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                40 => gnb_cu_ue_f1ap_id = Some(GnbCuUeF1apId::decode(data)?),
                41 => gnb_du_ue_f1ap_id = Some(GnbDuUeF1apId::decode(data)?),
                420 => system_frame_number = Some(SystemFrameNumber::decode(data)?),
                421 => slot_number = Some(SlotNumber::decode(data)?),
                7 => criticality_diagnostics = Some(CriticalityDiagnostics::decode(data)?),
                x => return Err(per_codec_error_new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        let gnb_cu_ue_f1ap_id = gnb_cu_ue_f1ap_id.ok_or(per_codec_error_new(format!(
            "Missing mandatory IE gnb_cu_ue_f1ap_id"
        )))?;
        let gnb_du_ue_f1ap_id = gnb_du_ue_f1ap_id.ok_or(per_codec_error_new(format!(
            "Missing mandatory IE gnb_du_ue_f1ap_id"
        )))?;
        Ok(Self {
            gnb_cu_ue_f1ap_id,
            gnb_du_ue_f1ap_id,
            system_frame_number,
            slot_number,
            criticality_diagnostics,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        let ie = &mut Allocator::new_codec_data();
        self.gnb_cu_ue_f1ap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 40, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.gnb_du_ue_f1ap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 41, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        if let Some(x) = &self.system_frame_number {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 420, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.slot_number {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 421, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.criticality_diagnostics {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 7, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        encode::encode_sequence_header(data, true, &BitString::new(), false)?;
        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for PositioningActivationResponse {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PositioningActivationResponse::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PositioningActivationResponse");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PositioningActivationResponse");
            e
        })
    }
}
// PositioningActivationFailure
#[derive(Clone, Debug)]
pub struct PositioningActivationFailure {
    pub gnb_cu_ue_f1ap_id: GnbCuUeF1apId,
    pub gnb_du_ue_f1ap_id: GnbDuUeF1apId,
    pub cause: Cause,
    pub criticality_diagnostics: Option<CriticalityDiagnostics>,
}

impl PositioningActivationFailure {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let _ = decode::decode_sequence_header(data, true, 0)?;
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut gnb_cu_ue_f1ap_id: Option<GnbCuUeF1apId> = None;
        let mut gnb_du_ue_f1ap_id: Option<GnbDuUeF1apId> = None;
        let mut cause: Option<Cause> = None;
        let mut criticality_diagnostics: Option<CriticalityDiagnostics> = None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                40 => gnb_cu_ue_f1ap_id = Some(GnbCuUeF1apId::decode(data)?),
                41 => gnb_du_ue_f1ap_id = Some(GnbDuUeF1apId::decode(data)?),
                0 => cause = Some(Cause::decode(data)?),
                7 => criticality_diagnostics = Some(CriticalityDiagnostics::decode(data)?),
                x => return Err(per_codec_error_new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        let gnb_cu_ue_f1ap_id = gnb_cu_ue_f1ap_id.ok_or(per_codec_error_new(format!(
            "Missing mandatory IE gnb_cu_ue_f1ap_id"
        )))?;
        let gnb_du_ue_f1ap_id = gnb_du_ue_f1ap_id.ok_or(per_codec_error_new(format!(
            "Missing mandatory IE gnb_du_ue_f1ap_id"
        )))?;
        let cause = cause.ok_or(per_codec_error_new(format!("Missing mandatory IE cause")))?;
        Ok(Self {
            gnb_cu_ue_f1ap_id,
            gnb_du_ue_f1ap_id,
            cause,
            criticality_diagnostics,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        let ie = &mut Allocator::new_codec_data();
        self.gnb_cu_ue_f1ap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 40, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.gnb_du_ue_f1ap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 41, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.cause.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 0, false)?;
        Criticality::Ignore.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        if let Some(x) = &self.criticality_diagnostics {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 7, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        encode::encode_sequence_header(data, true, &BitString::new(), false)?;
        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for PositioningActivationFailure {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PositioningActivationFailure::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PositioningActivationFailure");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PositioningActivationFailure");
            e
        })
    }
}
// PositioningDeactivation
#[derive(Clone, Debug)]
pub struct PositioningDeactivation {
    pub gnb_cu_ue_f1ap_id: GnbCuUeF1apId,
    pub gnb_du_ue_f1ap_id: GnbDuUeF1apId,
    pub abort_transmission: AbortTransmission,
}

impl PositioningDeactivation {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let _ = decode::decode_sequence_header(data, true, 0)?;
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut gnb_cu_ue_f1ap_id: Option<GnbCuUeF1apId> = None;
        let mut gnb_du_ue_f1ap_id: Option<GnbDuUeF1apId> = None;
        let mut abort_transmission: Option<AbortTransmission> = None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                40 => gnb_cu_ue_f1ap_id = Some(GnbCuUeF1apId::decode(data)?),
                41 => gnb_du_ue_f1ap_id = Some(GnbDuUeF1apId::decode(data)?),
                405 => abort_transmission = Some(AbortTransmission::decode(data)?),
                x => return Err(per_codec_error_new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        let gnb_cu_ue_f1ap_id = gnb_cu_ue_f1ap_id.ok_or(per_codec_error_new(format!(
            "Missing mandatory IE gnb_cu_ue_f1ap_id"
        )))?;
        let gnb_du_ue_f1ap_id = gnb_du_ue_f1ap_id.ok_or(per_codec_error_new(format!(
            "Missing mandatory IE gnb_du_ue_f1ap_id"
        )))?;
        let abort_transmission = abort_transmission.ok_or(per_codec_error_new(format!(
            "Missing mandatory IE abort_transmission"
        )))?;
        Ok(Self {
            gnb_cu_ue_f1ap_id,
            gnb_du_ue_f1ap_id,
            abort_transmission,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        let ie = &mut Allocator::new_codec_data();
        self.gnb_cu_ue_f1ap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 40, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.gnb_du_ue_f1ap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 41, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.abort_transmission.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 405, false)?;
        Criticality::Ignore.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        encode::encode_sequence_header(data, true, &BitString::new(), false)?;
        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for PositioningDeactivation {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PositioningDeactivation::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PositioningDeactivation");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PositioningDeactivation");
            e
        })
    }
}
// PositioningInformationUpdate
#[derive(Clone, Debug)]
pub struct PositioningInformationUpdate {
    pub gnb_cu_ue_f1ap_id: GnbCuUeF1apId,
    pub gnb_du_ue_f1ap_id: GnbDuUeF1apId,
    pub srs_configuration: Option<SrsConfiguration>,
    pub sfn_initialisation_time: Option<RelativeTime1900>,
}

impl PositioningInformationUpdate {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let _ = decode::decode_sequence_header(data, true, 0)?;
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut gnb_cu_ue_f1ap_id: Option<GnbCuUeF1apId> = None;
        let mut gnb_du_ue_f1ap_id: Option<GnbDuUeF1apId> = None;
        let mut srs_configuration: Option<SrsConfiguration> = None;
        let mut sfn_initialisation_time: Option<RelativeTime1900> = None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                40 => gnb_cu_ue_f1ap_id = Some(GnbCuUeF1apId::decode(data)?),
                41 => gnb_du_ue_f1ap_id = Some(GnbDuUeF1apId::decode(data)?),
                407 => srs_configuration = Some(SrsConfiguration::decode(data)?),
                419 => sfn_initialisation_time = Some(RelativeTime1900::decode(data)?),
                x => return Err(per_codec_error_new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        let gnb_cu_ue_f1ap_id = gnb_cu_ue_f1ap_id.ok_or(per_codec_error_new(format!(
            "Missing mandatory IE gnb_cu_ue_f1ap_id"
        )))?;
        let gnb_du_ue_f1ap_id = gnb_du_ue_f1ap_id.ok_or(per_codec_error_new(format!(
            "Missing mandatory IE gnb_du_ue_f1ap_id"
        )))?;
        Ok(Self {
            gnb_cu_ue_f1ap_id,
            gnb_du_ue_f1ap_id,
            srs_configuration,
            sfn_initialisation_time,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        let ie = &mut Allocator::new_codec_data();
        self.gnb_cu_ue_f1ap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 40, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.gnb_du_ue_f1ap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 41, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        if let Some(x) = &self.srs_configuration {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 407, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.sfn_initialisation_time {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 419, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        encode::encode_sequence_header(data, true, &BitString::new(), false)?;
        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for PositioningInformationUpdate {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PositioningInformationUpdate::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PositioningInformationUpdate");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PositioningInformationUpdate");
            e
        })
    }
}
// SrsInformationReservationNotification
#[derive(Clone, Debug)]
pub struct SrsInformationReservationNotification {
    pub transaction_id: TransactionId,
    pub srs_reservation_type: SrsReservationType,
    pub srs_information: Option<RequestedSrsTransmissionCharacteristics>,
    pub preconfigured_srs_information: Option<RequestedSrsPreconfigurationCharacteristicsList>,
}

impl SrsInformationReservationNotification {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let _ = decode::decode_sequence_header(data, true, 0)?;
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut transaction_id: Option<TransactionId> = None;
        let mut srs_reservation_type: Option<SrsReservationType> = None;
        let mut srs_information: Option<RequestedSrsTransmissionCharacteristics> = None;
        let mut preconfigured_srs_information: Option<
            RequestedSrsPreconfigurationCharacteristicsList,
        > = None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                78 => transaction_id = Some(TransactionId::decode(data)?),
                813 => srs_reservation_type = Some(SrsReservationType::decode(data)?),
                832 => {
                    srs_information = Some(RequestedSrsTransmissionCharacteristics::decode(data)?)
                }
                857 => {
                    preconfigured_srs_information = Some(
                        RequestedSrsPreconfigurationCharacteristicsList::decode(data)?,
                    )
                }
                x => return Err(per_codec_error_new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        let transaction_id = transaction_id.ok_or(per_codec_error_new(format!(
            "Missing mandatory IE transaction_id"
        )))?;
        let srs_reservation_type = srs_reservation_type.ok_or(per_codec_error_new(format!(
            "Missing mandatory IE srs_reservation_type"
        )))?;
        Ok(Self {
            transaction_id,
            srs_reservation_type,
            srs_information,
            preconfigured_srs_information,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        let ie = &mut Allocator::new_codec_data();
        self.transaction_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 78, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.srs_reservation_type.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 813, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        if let Some(x) = &self.srs_information {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 832, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.preconfigured_srs_information {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 857, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        encode::encode_sequence_header(data, true, &BitString::new(), false)?;
        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for SrsInformationReservationNotification {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        SrsInformationReservationNotification::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SrsInformationReservationNotification");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SrsInformationReservationNotification");
            e
        })
    }
}
// ECidMeasurementInitiationRequest
#[derive(Clone, Debug)]
pub struct ECidMeasurementInitiationRequest {
    pub gnb_cu_ue_f1ap_id: GnbCuUeF1apId,
    pub gnb_du_ue_f1ap_id: GnbDuUeF1apId,
    pub lmf_ue_measurement_id: LmfUeMeasurementId,
    pub ran_ue_measurement_id: RanUeMeasurementId,
    pub e_cid_report_characteristics: ECidReportCharacteristics,
    pub e_cid_measurement_periodicity: Option<MeasurementPeriodicity>,
    pub e_cid_measurement_quantities: ECidMeasurementQuantities,
    pub pos_measurement_periodicity_nr_ao_a: Option<PosMeasurementPeriodicityNrAoA>,
}

impl ECidMeasurementInitiationRequest {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let _ = decode::decode_sequence_header(data, true, 0)?;
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut gnb_cu_ue_f1ap_id: Option<GnbCuUeF1apId> = None;
        let mut gnb_du_ue_f1ap_id: Option<GnbDuUeF1apId> = None;
        let mut lmf_ue_measurement_id: Option<LmfUeMeasurementId> = None;
        let mut ran_ue_measurement_id: Option<RanUeMeasurementId> = None;
        let mut e_cid_report_characteristics: Option<ECidReportCharacteristics> = None;
        let mut e_cid_measurement_periodicity: Option<MeasurementPeriodicity> = None;
        let mut e_cid_measurement_quantities: Option<ECidMeasurementQuantities> = None;
        let mut pos_measurement_periodicity_nr_ao_a: Option<PosMeasurementPeriodicityNrAoA> = None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                40 => gnb_cu_ue_f1ap_id = Some(GnbCuUeF1apId::decode(data)?),
                41 => gnb_du_ue_f1ap_id = Some(GnbDuUeF1apId::decode(data)?),
                412 => lmf_ue_measurement_id = Some(LmfUeMeasurementId::decode(data)?),
                413 => ran_ue_measurement_id = Some(RanUeMeasurementId::decode(data)?),
                424 => {
                    e_cid_report_characteristics = Some(ECidReportCharacteristics::decode(data)?)
                }
                416 => e_cid_measurement_periodicity = Some(MeasurementPeriodicity::decode(data)?),
                414 => {
                    e_cid_measurement_quantities = Some(ECidMeasurementQuantities::decode(data)?)
                }
                672 => {
                    pos_measurement_periodicity_nr_ao_a =
                        Some(PosMeasurementPeriodicityNrAoA::decode(data)?)
                }
                x => return Err(per_codec_error_new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        let gnb_cu_ue_f1ap_id = gnb_cu_ue_f1ap_id.ok_or(per_codec_error_new(format!(
            "Missing mandatory IE gnb_cu_ue_f1ap_id"
        )))?;
        let gnb_du_ue_f1ap_id = gnb_du_ue_f1ap_id.ok_or(per_codec_error_new(format!(
            "Missing mandatory IE gnb_du_ue_f1ap_id"
        )))?;
        let lmf_ue_measurement_id = lmf_ue_measurement_id.ok_or(per_codec_error_new(format!(
            "Missing mandatory IE lmf_ue_measurement_id"
        )))?;
        let ran_ue_measurement_id = ran_ue_measurement_id.ok_or(per_codec_error_new(format!(
            "Missing mandatory IE ran_ue_measurement_id"
        )))?;
        let e_cid_report_characteristics = e_cid_report_characteristics.ok_or(
            per_codec_error_new(format!("Missing mandatory IE e_cid_report_characteristics")),
        )?;
        let e_cid_measurement_quantities = e_cid_measurement_quantities.ok_or(
            per_codec_error_new(format!("Missing mandatory IE e_cid_measurement_quantities")),
        )?;
        Ok(Self {
            gnb_cu_ue_f1ap_id,
            gnb_du_ue_f1ap_id,
            lmf_ue_measurement_id,
            ran_ue_measurement_id,
            e_cid_report_characteristics,
            e_cid_measurement_periodicity,
            e_cid_measurement_quantities,
            pos_measurement_periodicity_nr_ao_a,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        let ie = &mut Allocator::new_codec_data();
        self.gnb_cu_ue_f1ap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 40, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.gnb_du_ue_f1ap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 41, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.lmf_ue_measurement_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 412, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.ran_ue_measurement_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 413, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.e_cid_report_characteristics.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 424, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        if let Some(x) = &self.e_cid_measurement_periodicity {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 416, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        let ie = &mut Allocator::new_codec_data();
        self.e_cid_measurement_quantities.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 414, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        if let Some(x) = &self.pos_measurement_periodicity_nr_ao_a {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 672, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        encode::encode_sequence_header(data, true, &BitString::new(), false)?;
        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for ECidMeasurementInitiationRequest {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        ECidMeasurementInitiationRequest::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ECidMeasurementInitiationRequest");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ECidMeasurementInitiationRequest");
            e
        })
    }
}
// ECidMeasurementInitiationResponse
#[derive(Clone, Debug)]
pub struct ECidMeasurementInitiationResponse {
    pub gnb_cu_ue_f1ap_id: GnbCuUeF1apId,
    pub gnb_du_ue_f1ap_id: GnbDuUeF1apId,
    pub lmf_ue_measurement_id: LmfUeMeasurementId,
    pub ran_ue_measurement_id: RanUeMeasurementId,
    pub e_cid_measurement_result: Option<ECidMeasurementResult>,
    pub cell_portion_id: Option<CellPortionId>,
    pub criticality_diagnostics: Option<CriticalityDiagnostics>,
}

impl ECidMeasurementInitiationResponse {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let _ = decode::decode_sequence_header(data, true, 0)?;
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut gnb_cu_ue_f1ap_id: Option<GnbCuUeF1apId> = None;
        let mut gnb_du_ue_f1ap_id: Option<GnbDuUeF1apId> = None;
        let mut lmf_ue_measurement_id: Option<LmfUeMeasurementId> = None;
        let mut ran_ue_measurement_id: Option<RanUeMeasurementId> = None;
        let mut e_cid_measurement_result: Option<ECidMeasurementResult> = None;
        let mut cell_portion_id: Option<CellPortionId> = None;
        let mut criticality_diagnostics: Option<CriticalityDiagnostics> = None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                40 => gnb_cu_ue_f1ap_id = Some(GnbCuUeF1apId::decode(data)?),
                41 => gnb_du_ue_f1ap_id = Some(GnbDuUeF1apId::decode(data)?),
                412 => lmf_ue_measurement_id = Some(LmfUeMeasurementId::decode(data)?),
                413 => ran_ue_measurement_id = Some(RanUeMeasurementId::decode(data)?),
                417 => e_cid_measurement_result = Some(ECidMeasurementResult::decode(data)?),
                418 => cell_portion_id = Some(CellPortionId::decode(data)?),
                7 => criticality_diagnostics = Some(CriticalityDiagnostics::decode(data)?),
                x => return Err(per_codec_error_new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        let gnb_cu_ue_f1ap_id = gnb_cu_ue_f1ap_id.ok_or(per_codec_error_new(format!(
            "Missing mandatory IE gnb_cu_ue_f1ap_id"
        )))?;
        let gnb_du_ue_f1ap_id = gnb_du_ue_f1ap_id.ok_or(per_codec_error_new(format!(
            "Missing mandatory IE gnb_du_ue_f1ap_id"
        )))?;
        let lmf_ue_measurement_id = lmf_ue_measurement_id.ok_or(per_codec_error_new(format!(
            "Missing mandatory IE lmf_ue_measurement_id"
        )))?;
        let ran_ue_measurement_id = ran_ue_measurement_id.ok_or(per_codec_error_new(format!(
            "Missing mandatory IE ran_ue_measurement_id"
        )))?;
        Ok(Self {
            gnb_cu_ue_f1ap_id,
            gnb_du_ue_f1ap_id,
            lmf_ue_measurement_id,
            ran_ue_measurement_id,
            e_cid_measurement_result,
            cell_portion_id,
            criticality_diagnostics,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        let ie = &mut Allocator::new_codec_data();
        self.gnb_cu_ue_f1ap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 40, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.gnb_du_ue_f1ap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 41, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.lmf_ue_measurement_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 412, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.ran_ue_measurement_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 413, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        if let Some(x) = &self.e_cid_measurement_result {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 417, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.cell_portion_id {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 418, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.criticality_diagnostics {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 7, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        encode::encode_sequence_header(data, true, &BitString::new(), false)?;
        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for ECidMeasurementInitiationResponse {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        ECidMeasurementInitiationResponse::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ECidMeasurementInitiationResponse");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ECidMeasurementInitiationResponse");
            e
        })
    }
}
// ECidMeasurementInitiationFailure
#[derive(Clone, Debug)]
pub struct ECidMeasurementInitiationFailure {
    pub gnb_cu_ue_f1ap_id: GnbCuUeF1apId,
    pub gnb_du_ue_f1ap_id: GnbDuUeF1apId,
    pub lmf_ue_measurement_id: LmfUeMeasurementId,
    pub ran_ue_measurement_id: RanUeMeasurementId,
    pub cause: Cause,
    pub criticality_diagnostics: Option<CriticalityDiagnostics>,
}

impl ECidMeasurementInitiationFailure {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let _ = decode::decode_sequence_header(data, true, 0)?;
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut gnb_cu_ue_f1ap_id: Option<GnbCuUeF1apId> = None;
        let mut gnb_du_ue_f1ap_id: Option<GnbDuUeF1apId> = None;
        let mut lmf_ue_measurement_id: Option<LmfUeMeasurementId> = None;
        let mut ran_ue_measurement_id: Option<RanUeMeasurementId> = None;
        let mut cause: Option<Cause> = None;
        let mut criticality_diagnostics: Option<CriticalityDiagnostics> = None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                40 => gnb_cu_ue_f1ap_id = Some(GnbCuUeF1apId::decode(data)?),
                41 => gnb_du_ue_f1ap_id = Some(GnbDuUeF1apId::decode(data)?),
                412 => lmf_ue_measurement_id = Some(LmfUeMeasurementId::decode(data)?),
                413 => ran_ue_measurement_id = Some(RanUeMeasurementId::decode(data)?),
                0 => cause = Some(Cause::decode(data)?),
                7 => criticality_diagnostics = Some(CriticalityDiagnostics::decode(data)?),
                x => return Err(per_codec_error_new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        let gnb_cu_ue_f1ap_id = gnb_cu_ue_f1ap_id.ok_or(per_codec_error_new(format!(
            "Missing mandatory IE gnb_cu_ue_f1ap_id"
        )))?;
        let gnb_du_ue_f1ap_id = gnb_du_ue_f1ap_id.ok_or(per_codec_error_new(format!(
            "Missing mandatory IE gnb_du_ue_f1ap_id"
        )))?;
        let lmf_ue_measurement_id = lmf_ue_measurement_id.ok_or(per_codec_error_new(format!(
            "Missing mandatory IE lmf_ue_measurement_id"
        )))?;
        let ran_ue_measurement_id = ran_ue_measurement_id.ok_or(per_codec_error_new(format!(
            "Missing mandatory IE ran_ue_measurement_id"
        )))?;
        let cause = cause.ok_or(per_codec_error_new(format!("Missing mandatory IE cause")))?;
        Ok(Self {
            gnb_cu_ue_f1ap_id,
            gnb_du_ue_f1ap_id,
            lmf_ue_measurement_id,
            ran_ue_measurement_id,
            cause,
            criticality_diagnostics,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        let ie = &mut Allocator::new_codec_data();
        self.gnb_cu_ue_f1ap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 40, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.gnb_du_ue_f1ap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 41, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.lmf_ue_measurement_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 412, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.ran_ue_measurement_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 413, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.cause.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 0, false)?;
        Criticality::Ignore.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        if let Some(x) = &self.criticality_diagnostics {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 7, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        encode::encode_sequence_header(data, true, &BitString::new(), false)?;
        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for ECidMeasurementInitiationFailure {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        ECidMeasurementInitiationFailure::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ECidMeasurementInitiationFailure");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ECidMeasurementInitiationFailure");
            e
        })
    }
}
// ECidMeasurementFailureIndication
#[derive(Clone, Debug)]
pub struct ECidMeasurementFailureIndication {
    pub gnb_cu_ue_f1ap_id: GnbCuUeF1apId,
    pub gnb_du_ue_f1ap_id: GnbDuUeF1apId,
    pub lmf_ue_measurement_id: LmfUeMeasurementId,
    pub ran_ue_measurement_id: RanUeMeasurementId,
    pub cause: Cause,
}

impl ECidMeasurementFailureIndication {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let _ = decode::decode_sequence_header(data, true, 0)?;
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut gnb_cu_ue_f1ap_id: Option<GnbCuUeF1apId> = None;
        let mut gnb_du_ue_f1ap_id: Option<GnbDuUeF1apId> = None;
        let mut lmf_ue_measurement_id: Option<LmfUeMeasurementId> = None;
        let mut ran_ue_measurement_id: Option<RanUeMeasurementId> = None;
        let mut cause: Option<Cause> = None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                40 => gnb_cu_ue_f1ap_id = Some(GnbCuUeF1apId::decode(data)?),
                41 => gnb_du_ue_f1ap_id = Some(GnbDuUeF1apId::decode(data)?),
                412 => lmf_ue_measurement_id = Some(LmfUeMeasurementId::decode(data)?),
                413 => ran_ue_measurement_id = Some(RanUeMeasurementId::decode(data)?),
                0 => cause = Some(Cause::decode(data)?),
                x => return Err(per_codec_error_new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        let gnb_cu_ue_f1ap_id = gnb_cu_ue_f1ap_id.ok_or(per_codec_error_new(format!(
            "Missing mandatory IE gnb_cu_ue_f1ap_id"
        )))?;
        let gnb_du_ue_f1ap_id = gnb_du_ue_f1ap_id.ok_or(per_codec_error_new(format!(
            "Missing mandatory IE gnb_du_ue_f1ap_id"
        )))?;
        let lmf_ue_measurement_id = lmf_ue_measurement_id.ok_or(per_codec_error_new(format!(
            "Missing mandatory IE lmf_ue_measurement_id"
        )))?;
        let ran_ue_measurement_id = ran_ue_measurement_id.ok_or(per_codec_error_new(format!(
            "Missing mandatory IE ran_ue_measurement_id"
        )))?;
        let cause = cause.ok_or(per_codec_error_new(format!("Missing mandatory IE cause")))?;
        Ok(Self {
            gnb_cu_ue_f1ap_id,
            gnb_du_ue_f1ap_id,
            lmf_ue_measurement_id,
            ran_ue_measurement_id,
            cause,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        let ie = &mut Allocator::new_codec_data();
        self.gnb_cu_ue_f1ap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 40, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.gnb_du_ue_f1ap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 41, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.lmf_ue_measurement_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 412, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.ran_ue_measurement_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 413, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.cause.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 0, false)?;
        Criticality::Ignore.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        encode::encode_sequence_header(data, true, &BitString::new(), false)?;
        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for ECidMeasurementFailureIndication {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        ECidMeasurementFailureIndication::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ECidMeasurementFailureIndication");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ECidMeasurementFailureIndication");
            e
        })
    }
}
// ECidMeasurementReport
#[derive(Clone, Debug)]
pub struct ECidMeasurementReport {
    pub gnb_cu_ue_f1ap_id: GnbCuUeF1apId,
    pub gnb_du_ue_f1ap_id: GnbDuUeF1apId,
    pub lmf_ue_measurement_id: LmfUeMeasurementId,
    pub ran_ue_measurement_id: RanUeMeasurementId,
    pub e_cid_measurement_result: ECidMeasurementResult,
    pub cell_portion_id: Option<CellPortionId>,
}

impl ECidMeasurementReport {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let _ = decode::decode_sequence_header(data, true, 0)?;
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut gnb_cu_ue_f1ap_id: Option<GnbCuUeF1apId> = None;
        let mut gnb_du_ue_f1ap_id: Option<GnbDuUeF1apId> = None;
        let mut lmf_ue_measurement_id: Option<LmfUeMeasurementId> = None;
        let mut ran_ue_measurement_id: Option<RanUeMeasurementId> = None;
        let mut e_cid_measurement_result: Option<ECidMeasurementResult> = None;
        let mut cell_portion_id: Option<CellPortionId> = None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                40 => gnb_cu_ue_f1ap_id = Some(GnbCuUeF1apId::decode(data)?),
                41 => gnb_du_ue_f1ap_id = Some(GnbDuUeF1apId::decode(data)?),
                412 => lmf_ue_measurement_id = Some(LmfUeMeasurementId::decode(data)?),
                413 => ran_ue_measurement_id = Some(RanUeMeasurementId::decode(data)?),
                417 => e_cid_measurement_result = Some(ECidMeasurementResult::decode(data)?),
                418 => cell_portion_id = Some(CellPortionId::decode(data)?),
                x => return Err(per_codec_error_new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        let gnb_cu_ue_f1ap_id = gnb_cu_ue_f1ap_id.ok_or(per_codec_error_new(format!(
            "Missing mandatory IE gnb_cu_ue_f1ap_id"
        )))?;
        let gnb_du_ue_f1ap_id = gnb_du_ue_f1ap_id.ok_or(per_codec_error_new(format!(
            "Missing mandatory IE gnb_du_ue_f1ap_id"
        )))?;
        let lmf_ue_measurement_id = lmf_ue_measurement_id.ok_or(per_codec_error_new(format!(
            "Missing mandatory IE lmf_ue_measurement_id"
        )))?;
        let ran_ue_measurement_id = ran_ue_measurement_id.ok_or(per_codec_error_new(format!(
            "Missing mandatory IE ran_ue_measurement_id"
        )))?;
        let e_cid_measurement_result = e_cid_measurement_result.ok_or(per_codec_error_new(
            format!("Missing mandatory IE e_cid_measurement_result"),
        ))?;
        Ok(Self {
            gnb_cu_ue_f1ap_id,
            gnb_du_ue_f1ap_id,
            lmf_ue_measurement_id,
            ran_ue_measurement_id,
            e_cid_measurement_result,
            cell_portion_id,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        let ie = &mut Allocator::new_codec_data();
        self.gnb_cu_ue_f1ap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 40, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.gnb_du_ue_f1ap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 41, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.lmf_ue_measurement_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 412, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.ran_ue_measurement_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 413, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.e_cid_measurement_result.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 417, false)?;
        Criticality::Ignore.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        if let Some(x) = &self.cell_portion_id {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 418, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        encode::encode_sequence_header(data, true, &BitString::new(), false)?;
        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for ECidMeasurementReport {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        ECidMeasurementReport::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ECidMeasurementReport");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ECidMeasurementReport");
            e
        })
    }
}
// ECidMeasurementTerminationCommand
#[derive(Clone, Debug)]
pub struct ECidMeasurementTerminationCommand {
    pub gnb_cu_ue_f1ap_id: GnbCuUeF1apId,
    pub gnb_du_ue_f1ap_id: GnbDuUeF1apId,
    pub lmf_ue_measurement_id: LmfUeMeasurementId,
    pub ran_ue_measurement_id: RanUeMeasurementId,
}

impl ECidMeasurementTerminationCommand {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let _ = decode::decode_sequence_header(data, true, 0)?;
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut gnb_cu_ue_f1ap_id: Option<GnbCuUeF1apId> = None;
        let mut gnb_du_ue_f1ap_id: Option<GnbDuUeF1apId> = None;
        let mut lmf_ue_measurement_id: Option<LmfUeMeasurementId> = None;
        let mut ran_ue_measurement_id: Option<RanUeMeasurementId> = None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                40 => gnb_cu_ue_f1ap_id = Some(GnbCuUeF1apId::decode(data)?),
                41 => gnb_du_ue_f1ap_id = Some(GnbDuUeF1apId::decode(data)?),
                412 => lmf_ue_measurement_id = Some(LmfUeMeasurementId::decode(data)?),
                413 => ran_ue_measurement_id = Some(RanUeMeasurementId::decode(data)?),
                x => return Err(per_codec_error_new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        let gnb_cu_ue_f1ap_id = gnb_cu_ue_f1ap_id.ok_or(per_codec_error_new(format!(
            "Missing mandatory IE gnb_cu_ue_f1ap_id"
        )))?;
        let gnb_du_ue_f1ap_id = gnb_du_ue_f1ap_id.ok_or(per_codec_error_new(format!(
            "Missing mandatory IE gnb_du_ue_f1ap_id"
        )))?;
        let lmf_ue_measurement_id = lmf_ue_measurement_id.ok_or(per_codec_error_new(format!(
            "Missing mandatory IE lmf_ue_measurement_id"
        )))?;
        let ran_ue_measurement_id = ran_ue_measurement_id.ok_or(per_codec_error_new(format!(
            "Missing mandatory IE ran_ue_measurement_id"
        )))?;
        Ok(Self {
            gnb_cu_ue_f1ap_id,
            gnb_du_ue_f1ap_id,
            lmf_ue_measurement_id,
            ran_ue_measurement_id,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        let ie = &mut Allocator::new_codec_data();
        self.gnb_cu_ue_f1ap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 40, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.gnb_du_ue_f1ap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 41, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.lmf_ue_measurement_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 412, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.ran_ue_measurement_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 413, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        encode::encode_sequence_header(data, true, &BitString::new(), false)?;
        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for ECidMeasurementTerminationCommand {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        ECidMeasurementTerminationCommand::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ECidMeasurementTerminationCommand");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ECidMeasurementTerminationCommand");
            e
        })
    }
}
// BroadcastContextSetupRequest
#[derive(Clone, Debug)]
pub struct BroadcastContextSetupRequest {
    pub gnb_cu_mbs_f1ap_id: GnbCuMbsF1apId,
    pub mbs_session_id: MbsSessionId,
    pub mbs_service_area: Option<MbsServiceArea>,
    pub mbs_cu_to_du_rrc_information: MbsCuToDuRrcInformation,
    pub snssai: Snssai,
    pub broadcast_mr_bs_to_be_setup_list: BroadcastMrBsToBeSetupList,
    pub supported_ue_type_list: Option<SupportedUeTypeList>,
    pub associated_session_id: Option<AssociatedSessionId>,
    pub ran_sharing_assistance_information: Option<RanSharingAssistanceInformation>,
}

impl BroadcastContextSetupRequest {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let _ = decode::decode_sequence_header(data, true, 0)?;
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut gnb_cu_mbs_f1ap_id: Option<GnbCuMbsF1apId> = None;
        let mut mbs_session_id: Option<MbsSessionId> = None;
        let mut mbs_service_area: Option<MbsServiceArea> = None;
        let mut mbs_cu_to_du_rrc_information: Option<MbsCuToDuRrcInformation> = None;
        let mut snssai: Option<Snssai> = None;
        let mut broadcast_mr_bs_to_be_setup_list: Option<BroadcastMrBsToBeSetupList> = None;
        let mut supported_ue_type_list: Option<SupportedUeTypeList> = None;
        let mut associated_session_id: Option<AssociatedSessionId> = None;
        let mut ran_sharing_assistance_information: Option<RanSharingAssistanceInformation> = None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                451 => gnb_cu_mbs_f1ap_id = Some(GnbCuMbsF1apId::decode(data)?),
                455 => mbs_session_id = Some(MbsSessionId::decode(data)?),
                481 => mbs_service_area = Some(MbsServiceArea::decode(data)?),
                454 => mbs_cu_to_du_rrc_information = Some(MbsCuToDuRrcInformation::decode(data)?),
                456 => snssai = Some(Snssai::decode(data)?),
                474 => {
                    broadcast_mr_bs_to_be_setup_list =
                        Some(BroadcastMrBsToBeSetupList::decode(data)?)
                }
                717 => supported_ue_type_list = Some(SupportedUeTypeList::decode(data)?),
                767 => associated_session_id = Some(AssociatedSessionId::decode(data)?),
                844 => {
                    ran_sharing_assistance_information =
                        Some(RanSharingAssistanceInformation::decode(data)?)
                }
                x => return Err(per_codec_error_new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        let gnb_cu_mbs_f1ap_id = gnb_cu_mbs_f1ap_id.ok_or(per_codec_error_new(format!(
            "Missing mandatory IE gnb_cu_mbs_f1ap_id"
        )))?;
        let mbs_session_id = mbs_session_id.ok_or(per_codec_error_new(format!(
            "Missing mandatory IE mbs_session_id"
        )))?;
        let mbs_cu_to_du_rrc_information = mbs_cu_to_du_rrc_information.ok_or(
            per_codec_error_new(format!("Missing mandatory IE mbs_cu_to_du_rrc_information")),
        )?;
        let snssai = snssai.ok_or(per_codec_error_new(format!("Missing mandatory IE snssai")))?;
        let broadcast_mr_bs_to_be_setup_list =
            broadcast_mr_bs_to_be_setup_list.ok_or(per_codec_error_new(format!(
                "Missing mandatory IE broadcast_mr_bs_to_be_setup_list"
            )))?;
        Ok(Self {
            gnb_cu_mbs_f1ap_id,
            mbs_session_id,
            mbs_service_area,
            mbs_cu_to_du_rrc_information,
            snssai,
            broadcast_mr_bs_to_be_setup_list,
            supported_ue_type_list,
            associated_session_id,
            ran_sharing_assistance_information,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        let ie = &mut Allocator::new_codec_data();
        self.gnb_cu_mbs_f1ap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 451, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.mbs_session_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 455, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        if let Some(x) = &self.mbs_service_area {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 481, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        let ie = &mut Allocator::new_codec_data();
        self.mbs_cu_to_du_rrc_information.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 454, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.snssai.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 456, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.broadcast_mr_bs_to_be_setup_list.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 474, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        if let Some(x) = &self.supported_ue_type_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 717, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.associated_session_id {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 767, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.ran_sharing_assistance_information {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 844, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        encode::encode_sequence_header(data, true, &BitString::new(), false)?;
        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for BroadcastContextSetupRequest {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        BroadcastContextSetupRequest::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("BroadcastContextSetupRequest");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("BroadcastContextSetupRequest");
            e
        })
    }
}
// BroadcastMrBsToBeSetupList
#[derive(Clone, Debug)]
pub struct BroadcastMrBsToBeSetupList(pub NonEmpty<BroadcastMrBsToBeSetupItem>);

impl BroadcastMrBsToBeSetupList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(32), false)?;
            let mut items = vec![];
            for _ in 0..length {
                let _ = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _ = Criticality::decode(data)?;
                let _ = decode::decode_length_determinent(data, None, None, false)?;
                items.push(BroadcastMrBsToBeSetupItem::decode(data)?);
                data.decode_align()?;
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(32), false, self.0.len())?;
        for x in &self.0 {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(data, Some(0), Some(65535), false, 475, false)?;
            Criticality::Reject.encode(data)?;
            encode::encode_length_determinent(data, None, None, false, ie.length_in_bytes())?;
            data.append_aligned(ie);
        }
        Ok(())
    }
}

impl PerCodec for BroadcastMrBsToBeSetupList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        BroadcastMrBsToBeSetupList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("BroadcastMrBsToBeSetupList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("BroadcastMrBsToBeSetupList");
            e
        })
    }
}
// BroadcastContextSetupResponse
#[derive(Clone, Debug)]
pub struct BroadcastContextSetupResponse {
    pub gnb_cu_mbs_f1ap_id: GnbCuMbsF1apId,
    pub gnb_du_mbs_f1ap_id: GnbDuMbsF1apId,
    pub broadcast_mr_bs_setup_list: BroadcastMrBsSetupList,
    pub broadcast_mr_bs_failed_to_be_setup_list: Option<BroadcastMrBsFailedToBeSetupList>,
    pub broadcast_area_scope: Option<BroadcastAreaScope>,
    pub criticality_diagnostics: Option<CriticalityDiagnostics>,
}

impl BroadcastContextSetupResponse {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let _ = decode::decode_sequence_header(data, true, 0)?;
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut gnb_cu_mbs_f1ap_id: Option<GnbCuMbsF1apId> = None;
        let mut gnb_du_mbs_f1ap_id: Option<GnbDuMbsF1apId> = None;
        let mut broadcast_mr_bs_setup_list: Option<BroadcastMrBsSetupList> = None;
        let mut broadcast_mr_bs_failed_to_be_setup_list: Option<BroadcastMrBsFailedToBeSetupList> =
            None;
        let mut broadcast_area_scope: Option<BroadcastAreaScope> = None;
        let mut criticality_diagnostics: Option<CriticalityDiagnostics> = None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                451 => gnb_cu_mbs_f1ap_id = Some(GnbCuMbsF1apId::decode(data)?),
                452 => gnb_du_mbs_f1ap_id = Some(GnbDuMbsF1apId::decode(data)?),
                466 => broadcast_mr_bs_setup_list = Some(BroadcastMrBsSetupList::decode(data)?),
                460 => {
                    broadcast_mr_bs_failed_to_be_setup_list =
                        Some(BroadcastMrBsFailedToBeSetupList::decode(data)?)
                }
                646 => broadcast_area_scope = Some(BroadcastAreaScope::decode(data)?),
                7 => criticality_diagnostics = Some(CriticalityDiagnostics::decode(data)?),
                x => return Err(per_codec_error_new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        let gnb_cu_mbs_f1ap_id = gnb_cu_mbs_f1ap_id.ok_or(per_codec_error_new(format!(
            "Missing mandatory IE gnb_cu_mbs_f1ap_id"
        )))?;
        let gnb_du_mbs_f1ap_id = gnb_du_mbs_f1ap_id.ok_or(per_codec_error_new(format!(
            "Missing mandatory IE gnb_du_mbs_f1ap_id"
        )))?;
        let broadcast_mr_bs_setup_list = broadcast_mr_bs_setup_list.ok_or(per_codec_error_new(
            format!("Missing mandatory IE broadcast_mr_bs_setup_list"),
        ))?;
        Ok(Self {
            gnb_cu_mbs_f1ap_id,
            gnb_du_mbs_f1ap_id,
            broadcast_mr_bs_setup_list,
            broadcast_mr_bs_failed_to_be_setup_list,
            broadcast_area_scope,
            criticality_diagnostics,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        let ie = &mut Allocator::new_codec_data();
        self.gnb_cu_mbs_f1ap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 451, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.gnb_du_mbs_f1ap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 452, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.broadcast_mr_bs_setup_list.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 466, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        if let Some(x) = &self.broadcast_mr_bs_failed_to_be_setup_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 460, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.broadcast_area_scope {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 646, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.criticality_diagnostics {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 7, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        encode::encode_sequence_header(data, true, &BitString::new(), false)?;
        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for BroadcastContextSetupResponse {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        BroadcastContextSetupResponse::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("BroadcastContextSetupResponse");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("BroadcastContextSetupResponse");
            e
        })
    }
}
// BroadcastMrBsSetupList
#[derive(Clone, Debug)]
pub struct BroadcastMrBsSetupList(pub NonEmpty<BroadcastMrBsSetupItem>);

impl BroadcastMrBsSetupList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(32), false)?;
            let mut items = vec![];
            for _ in 0..length {
                let _ = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _ = Criticality::decode(data)?;
                let _ = decode::decode_length_determinent(data, None, None, false)?;
                items.push(BroadcastMrBsSetupItem::decode(data)?);
                data.decode_align()?;
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(32), false, self.0.len())?;
        for x in &self.0 {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(data, Some(0), Some(65535), false, 467, false)?;
            Criticality::Reject.encode(data)?;
            encode::encode_length_determinent(data, None, None, false, ie.length_in_bytes())?;
            data.append_aligned(ie);
        }
        Ok(())
    }
}

impl PerCodec for BroadcastMrBsSetupList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        BroadcastMrBsSetupList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("BroadcastMrBsSetupList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("BroadcastMrBsSetupList");
            e
        })
    }
}
// BroadcastMrBsFailedToBeSetupList
#[derive(Clone, Debug)]
pub struct BroadcastMrBsFailedToBeSetupList(pub NonEmpty<BroadcastMrBsFailedToBeSetupItem>);

impl BroadcastMrBsFailedToBeSetupList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(32), false)?;
            let mut items = vec![];
            for _ in 0..length {
                let _ = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _ = Criticality::decode(data)?;
                let _ = decode::decode_length_determinent(data, None, None, false)?;
                items.push(BroadcastMrBsFailedToBeSetupItem::decode(data)?);
                data.decode_align()?;
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(32), false, self.0.len())?;
        for x in &self.0 {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(data, Some(0), Some(65535), false, 461, false)?;
            Criticality::Ignore.encode(data)?;
            encode::encode_length_determinent(data, None, None, false, ie.length_in_bytes())?;
            data.append_aligned(ie);
        }
        Ok(())
    }
}

impl PerCodec for BroadcastMrBsFailedToBeSetupList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        BroadcastMrBsFailedToBeSetupList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("BroadcastMrBsFailedToBeSetupList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("BroadcastMrBsFailedToBeSetupList");
            e
        })
    }
}
// BroadcastContextSetupFailure
#[derive(Clone, Debug)]
pub struct BroadcastContextSetupFailure {
    pub gnb_cu_mbs_f1ap_id: GnbCuUeF1apId,
    pub gnb_du_mbs_f1ap_id: Option<GnbDuUeF1apId>,
    pub cause: Cause,
    pub criticality_diagnostics: Option<CriticalityDiagnostics>,
}

impl BroadcastContextSetupFailure {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let _ = decode::decode_sequence_header(data, true, 0)?;
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut gnb_cu_mbs_f1ap_id: Option<GnbCuUeF1apId> = None;
        let mut gnb_du_mbs_f1ap_id: Option<GnbDuUeF1apId> = None;
        let mut cause: Option<Cause> = None;
        let mut criticality_diagnostics: Option<CriticalityDiagnostics> = None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                451 => gnb_cu_mbs_f1ap_id = Some(GnbCuUeF1apId::decode(data)?),
                452 => gnb_du_mbs_f1ap_id = Some(GnbDuUeF1apId::decode(data)?),
                0 => cause = Some(Cause::decode(data)?),
                7 => criticality_diagnostics = Some(CriticalityDiagnostics::decode(data)?),
                x => return Err(per_codec_error_new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        let gnb_cu_mbs_f1ap_id = gnb_cu_mbs_f1ap_id.ok_or(per_codec_error_new(format!(
            "Missing mandatory IE gnb_cu_mbs_f1ap_id"
        )))?;
        let cause = cause.ok_or(per_codec_error_new(format!("Missing mandatory IE cause")))?;
        Ok(Self {
            gnb_cu_mbs_f1ap_id,
            gnb_du_mbs_f1ap_id,
            cause,
            criticality_diagnostics,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        let ie = &mut Allocator::new_codec_data();
        self.gnb_cu_mbs_f1ap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 451, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        if let Some(x) = &self.gnb_du_mbs_f1ap_id {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 452, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        let ie = &mut Allocator::new_codec_data();
        self.cause.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 0, false)?;
        Criticality::Ignore.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        if let Some(x) = &self.criticality_diagnostics {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 7, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        encode::encode_sequence_header(data, true, &BitString::new(), false)?;
        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for BroadcastContextSetupFailure {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        BroadcastContextSetupFailure::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("BroadcastContextSetupFailure");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("BroadcastContextSetupFailure");
            e
        })
    }
}
// BroadcastContextReleaseCommand
#[derive(Clone, Debug)]
pub struct BroadcastContextReleaseCommand {
    pub gnb_cu_mbs_f1ap_id: GnbCuMbsF1apId,
    pub gnb_du_mbs_f1ap_id: GnbDuMbsF1apId,
    pub cause: Cause,
}

impl BroadcastContextReleaseCommand {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let _ = decode::decode_sequence_header(data, true, 0)?;
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut gnb_cu_mbs_f1ap_id: Option<GnbCuMbsF1apId> = None;
        let mut gnb_du_mbs_f1ap_id: Option<GnbDuMbsF1apId> = None;
        let mut cause: Option<Cause> = None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                451 => gnb_cu_mbs_f1ap_id = Some(GnbCuMbsF1apId::decode(data)?),
                452 => gnb_du_mbs_f1ap_id = Some(GnbDuMbsF1apId::decode(data)?),
                0 => cause = Some(Cause::decode(data)?),
                x => return Err(per_codec_error_new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        let gnb_cu_mbs_f1ap_id = gnb_cu_mbs_f1ap_id.ok_or(per_codec_error_new(format!(
            "Missing mandatory IE gnb_cu_mbs_f1ap_id"
        )))?;
        let gnb_du_mbs_f1ap_id = gnb_du_mbs_f1ap_id.ok_or(per_codec_error_new(format!(
            "Missing mandatory IE gnb_du_mbs_f1ap_id"
        )))?;
        let cause = cause.ok_or(per_codec_error_new(format!("Missing mandatory IE cause")))?;
        Ok(Self {
            gnb_cu_mbs_f1ap_id,
            gnb_du_mbs_f1ap_id,
            cause,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        let ie = &mut Allocator::new_codec_data();
        self.gnb_cu_mbs_f1ap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 451, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.gnb_du_mbs_f1ap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 452, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.cause.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 0, false)?;
        Criticality::Ignore.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        encode::encode_sequence_header(data, true, &BitString::new(), false)?;
        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for BroadcastContextReleaseCommand {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        BroadcastContextReleaseCommand::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("BroadcastContextReleaseCommand");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("BroadcastContextReleaseCommand");
            e
        })
    }
}
// BroadcastContextReleaseComplete
#[derive(Clone, Debug)]
pub struct BroadcastContextReleaseComplete {
    pub gnb_cu_mbs_f1ap_id: GnbCuMbsF1apId,
    pub gnb_du_mbs_f1ap_id: GnbDuMbsF1apId,
    pub criticality_diagnostics: Option<CriticalityDiagnostics>,
}

impl BroadcastContextReleaseComplete {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let _ = decode::decode_sequence_header(data, true, 0)?;
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut gnb_cu_mbs_f1ap_id: Option<GnbCuMbsF1apId> = None;
        let mut gnb_du_mbs_f1ap_id: Option<GnbDuMbsF1apId> = None;
        let mut criticality_diagnostics: Option<CriticalityDiagnostics> = None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                451 => gnb_cu_mbs_f1ap_id = Some(GnbCuMbsF1apId::decode(data)?),
                452 => gnb_du_mbs_f1ap_id = Some(GnbDuMbsF1apId::decode(data)?),
                7 => criticality_diagnostics = Some(CriticalityDiagnostics::decode(data)?),
                x => return Err(per_codec_error_new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        let gnb_cu_mbs_f1ap_id = gnb_cu_mbs_f1ap_id.ok_or(per_codec_error_new(format!(
            "Missing mandatory IE gnb_cu_mbs_f1ap_id"
        )))?;
        let gnb_du_mbs_f1ap_id = gnb_du_mbs_f1ap_id.ok_or(per_codec_error_new(format!(
            "Missing mandatory IE gnb_du_mbs_f1ap_id"
        )))?;
        Ok(Self {
            gnb_cu_mbs_f1ap_id,
            gnb_du_mbs_f1ap_id,
            criticality_diagnostics,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        let ie = &mut Allocator::new_codec_data();
        self.gnb_cu_mbs_f1ap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 451, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.gnb_du_mbs_f1ap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 452, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        if let Some(x) = &self.criticality_diagnostics {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 7, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        encode::encode_sequence_header(data, true, &BitString::new(), false)?;
        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for BroadcastContextReleaseComplete {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        BroadcastContextReleaseComplete::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("BroadcastContextReleaseComplete");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("BroadcastContextReleaseComplete");
            e
        })
    }
}
// BroadcastContextReleaseRequest
#[derive(Clone, Debug)]
pub struct BroadcastContextReleaseRequest {
    pub gnb_cu_mbs_f1ap_id: GnbCuMbsF1apId,
    pub gnb_du_mbs_f1ap_id: GnbDuMbsF1apId,
    pub cause: Cause,
}

impl BroadcastContextReleaseRequest {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let _ = decode::decode_sequence_header(data, true, 0)?;
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut gnb_cu_mbs_f1ap_id: Option<GnbCuMbsF1apId> = None;
        let mut gnb_du_mbs_f1ap_id: Option<GnbDuMbsF1apId> = None;
        let mut cause: Option<Cause> = None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                451 => gnb_cu_mbs_f1ap_id = Some(GnbCuMbsF1apId::decode(data)?),
                452 => gnb_du_mbs_f1ap_id = Some(GnbDuMbsF1apId::decode(data)?),
                0 => cause = Some(Cause::decode(data)?),
                x => return Err(per_codec_error_new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        let gnb_cu_mbs_f1ap_id = gnb_cu_mbs_f1ap_id.ok_or(per_codec_error_new(format!(
            "Missing mandatory IE gnb_cu_mbs_f1ap_id"
        )))?;
        let gnb_du_mbs_f1ap_id = gnb_du_mbs_f1ap_id.ok_or(per_codec_error_new(format!(
            "Missing mandatory IE gnb_du_mbs_f1ap_id"
        )))?;
        let cause = cause.ok_or(per_codec_error_new(format!("Missing mandatory IE cause")))?;
        Ok(Self {
            gnb_cu_mbs_f1ap_id,
            gnb_du_mbs_f1ap_id,
            cause,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        let ie = &mut Allocator::new_codec_data();
        self.gnb_cu_mbs_f1ap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 451, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.gnb_du_mbs_f1ap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 452, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.cause.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 0, false)?;
        Criticality::Ignore.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        encode::encode_sequence_header(data, true, &BitString::new(), false)?;
        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for BroadcastContextReleaseRequest {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        BroadcastContextReleaseRequest::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("BroadcastContextReleaseRequest");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("BroadcastContextReleaseRequest");
            e
        })
    }
}
// BroadcastContextModificationRequest
#[derive(Clone, Debug)]
pub struct BroadcastContextModificationRequest {
    pub gnb_cu_mbs_f1ap_id: GnbCuMbsF1apId,
    pub gnb_du_mbs_f1ap_id: GnbDuMbsF1apId,
    pub mbs_service_area: Option<MbsServiceArea>,
    pub mbs_cu_to_du_rrc_information: MbsCuToDuRrcInformation,
    pub broadcast_mr_bs_to_be_setup_mod_list: Option<BroadcastMrBsToBeSetupModList>,
    pub broadcast_mr_bs_to_be_modified_list: Option<BroadcastMrBsToBeModifiedList>,
    pub broadcast_mr_bs_to_be_released_list: Option<BroadcastMrBsToBeReleasedList>,
    pub supported_ue_type_list: Option<SupportedUeTypeList>,
}

impl BroadcastContextModificationRequest {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let _ = decode::decode_sequence_header(data, true, 0)?;
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut gnb_cu_mbs_f1ap_id: Option<GnbCuMbsF1apId> = None;
        let mut gnb_du_mbs_f1ap_id: Option<GnbDuMbsF1apId> = None;
        let mut mbs_service_area: Option<MbsServiceArea> = None;
        let mut mbs_cu_to_du_rrc_information: Option<MbsCuToDuRrcInformation> = None;
        let mut broadcast_mr_bs_to_be_setup_mod_list: Option<BroadcastMrBsToBeSetupModList> = None;
        let mut broadcast_mr_bs_to_be_modified_list: Option<BroadcastMrBsToBeModifiedList> = None;
        let mut broadcast_mr_bs_to_be_released_list: Option<BroadcastMrBsToBeReleasedList> = None;
        let mut supported_ue_type_list: Option<SupportedUeTypeList> = None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                451 => gnb_cu_mbs_f1ap_id = Some(GnbCuMbsF1apId::decode(data)?),
                452 => gnb_du_mbs_f1ap_id = Some(GnbDuMbsF1apId::decode(data)?),
                481 => mbs_service_area = Some(MbsServiceArea::decode(data)?),
                454 => mbs_cu_to_du_rrc_information = Some(MbsCuToDuRrcInformation::decode(data)?),
                476 => {
                    broadcast_mr_bs_to_be_setup_mod_list =
                        Some(BroadcastMrBsToBeSetupModList::decode(data)?)
                }
                470 => {
                    broadcast_mr_bs_to_be_modified_list =
                        Some(BroadcastMrBsToBeModifiedList::decode(data)?)
                }
                472 => {
                    broadcast_mr_bs_to_be_released_list =
                        Some(BroadcastMrBsToBeReleasedList::decode(data)?)
                }
                717 => supported_ue_type_list = Some(SupportedUeTypeList::decode(data)?),
                x => return Err(per_codec_error_new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        let gnb_cu_mbs_f1ap_id = gnb_cu_mbs_f1ap_id.ok_or(per_codec_error_new(format!(
            "Missing mandatory IE gnb_cu_mbs_f1ap_id"
        )))?;
        let gnb_du_mbs_f1ap_id = gnb_du_mbs_f1ap_id.ok_or(per_codec_error_new(format!(
            "Missing mandatory IE gnb_du_mbs_f1ap_id"
        )))?;
        let mbs_cu_to_du_rrc_information = mbs_cu_to_du_rrc_information.ok_or(
            per_codec_error_new(format!("Missing mandatory IE mbs_cu_to_du_rrc_information")),
        )?;
        Ok(Self {
            gnb_cu_mbs_f1ap_id,
            gnb_du_mbs_f1ap_id,
            mbs_service_area,
            mbs_cu_to_du_rrc_information,
            broadcast_mr_bs_to_be_setup_mod_list,
            broadcast_mr_bs_to_be_modified_list,
            broadcast_mr_bs_to_be_released_list,
            supported_ue_type_list,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        let ie = &mut Allocator::new_codec_data();
        self.gnb_cu_mbs_f1ap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 451, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.gnb_du_mbs_f1ap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 452, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        if let Some(x) = &self.mbs_service_area {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 481, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        let ie = &mut Allocator::new_codec_data();
        self.mbs_cu_to_du_rrc_information.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 454, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        if let Some(x) = &self.broadcast_mr_bs_to_be_setup_mod_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 476, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.broadcast_mr_bs_to_be_modified_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 470, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.broadcast_mr_bs_to_be_released_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 472, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.supported_ue_type_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 717, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        encode::encode_sequence_header(data, true, &BitString::new(), false)?;
        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for BroadcastContextModificationRequest {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        BroadcastContextModificationRequest::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("BroadcastContextModificationRequest");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("BroadcastContextModificationRequest");
            e
        })
    }
}
// BroadcastMrBsToBeSetupModList
#[derive(Clone, Debug)]
pub struct BroadcastMrBsToBeSetupModList(pub NonEmpty<BroadcastMrBsToBeSetupModItem>);

impl BroadcastMrBsToBeSetupModList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(32), false)?;
            let mut items = vec![];
            for _ in 0..length {
                let _ = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _ = Criticality::decode(data)?;
                let _ = decode::decode_length_determinent(data, None, None, false)?;
                items.push(BroadcastMrBsToBeSetupModItem::decode(data)?);
                data.decode_align()?;
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(32), false, self.0.len())?;
        for x in &self.0 {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(data, Some(0), Some(65535), false, 477, false)?;
            Criticality::Reject.encode(data)?;
            encode::encode_length_determinent(data, None, None, false, ie.length_in_bytes())?;
            data.append_aligned(ie);
        }
        Ok(())
    }
}

impl PerCodec for BroadcastMrBsToBeSetupModList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        BroadcastMrBsToBeSetupModList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("BroadcastMrBsToBeSetupModList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("BroadcastMrBsToBeSetupModList");
            e
        })
    }
}
// BroadcastMrBsToBeModifiedList
#[derive(Clone, Debug)]
pub struct BroadcastMrBsToBeModifiedList(pub NonEmpty<BroadcastMrBsToBeModifiedItem>);

impl BroadcastMrBsToBeModifiedList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(32), false)?;
            let mut items = vec![];
            for _ in 0..length {
                let _ = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _ = Criticality::decode(data)?;
                let _ = decode::decode_length_determinent(data, None, None, false)?;
                items.push(BroadcastMrBsToBeModifiedItem::decode(data)?);
                data.decode_align()?;
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(32), false, self.0.len())?;
        for x in &self.0 {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(data, Some(0), Some(65535), false, 471, false)?;
            Criticality::Reject.encode(data)?;
            encode::encode_length_determinent(data, None, None, false, ie.length_in_bytes())?;
            data.append_aligned(ie);
        }
        Ok(())
    }
}

impl PerCodec for BroadcastMrBsToBeModifiedList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        BroadcastMrBsToBeModifiedList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("BroadcastMrBsToBeModifiedList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("BroadcastMrBsToBeModifiedList");
            e
        })
    }
}
// BroadcastMrBsToBeReleasedList
#[derive(Clone, Debug)]
pub struct BroadcastMrBsToBeReleasedList(pub NonEmpty<BroadcastMrBsToBeReleasedItem>);

impl BroadcastMrBsToBeReleasedList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(32), false)?;
            let mut items = vec![];
            for _ in 0..length {
                let _ = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _ = Criticality::decode(data)?;
                let _ = decode::decode_length_determinent(data, None, None, false)?;
                items.push(BroadcastMrBsToBeReleasedItem::decode(data)?);
                data.decode_align()?;
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(32), false, self.0.len())?;
        for x in &self.0 {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(data, Some(0), Some(65535), false, 473, false)?;
            Criticality::Reject.encode(data)?;
            encode::encode_length_determinent(data, None, None, false, ie.length_in_bytes())?;
            data.append_aligned(ie);
        }
        Ok(())
    }
}

impl PerCodec for BroadcastMrBsToBeReleasedList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        BroadcastMrBsToBeReleasedList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("BroadcastMrBsToBeReleasedList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("BroadcastMrBsToBeReleasedList");
            e
        })
    }
}
// BroadcastContextModificationResponse
#[derive(Clone, Debug)]
pub struct BroadcastContextModificationResponse {
    pub gnb_cu_mbs_f1ap_id: GnbCuMbsF1apId,
    pub gnb_du_mbs_f1ap_id: GnbDuMbsF1apId,
    pub broadcast_mr_bs_setup_mod_list: Option<BroadcastMrBsSetupModList>,
    pub broadcast_mr_bs_failed_to_be_setup_mod_list: Option<BroadcastMrBsFailedToBeSetupModList>,
    pub broadcast_mr_bs_modified_list: Option<BroadcastMrBsModifiedList>,
    pub broadcast_mr_bs_failed_to_be_modified_list: Option<BroadcastMrBsFailedToBeModifiedList>,
    pub criticality_diagnostics: Option<CriticalityDiagnostics>,
    pub broadcast_area_scope: Option<BroadcastAreaScope>,
}

impl BroadcastContextModificationResponse {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let _ = decode::decode_sequence_header(data, true, 0)?;
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut gnb_cu_mbs_f1ap_id: Option<GnbCuMbsF1apId> = None;
        let mut gnb_du_mbs_f1ap_id: Option<GnbDuMbsF1apId> = None;
        let mut broadcast_mr_bs_setup_mod_list: Option<BroadcastMrBsSetupModList> = None;
        let mut broadcast_mr_bs_failed_to_be_setup_mod_list: Option<
            BroadcastMrBsFailedToBeSetupModList,
        > = None;
        let mut broadcast_mr_bs_modified_list: Option<BroadcastMrBsModifiedList> = None;
        let mut broadcast_mr_bs_failed_to_be_modified_list: Option<
            BroadcastMrBsFailedToBeModifiedList,
        > = None;
        let mut criticality_diagnostics: Option<CriticalityDiagnostics> = None;
        let mut broadcast_area_scope: Option<BroadcastAreaScope> = None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                451 => gnb_cu_mbs_f1ap_id = Some(GnbCuMbsF1apId::decode(data)?),
                452 => gnb_du_mbs_f1ap_id = Some(GnbDuMbsF1apId::decode(data)?),
                468 => {
                    broadcast_mr_bs_setup_mod_list = Some(BroadcastMrBsSetupModList::decode(data)?)
                }
                462 => {
                    broadcast_mr_bs_failed_to_be_setup_mod_list =
                        Some(BroadcastMrBsFailedToBeSetupModList::decode(data)?)
                }
                464 => {
                    broadcast_mr_bs_modified_list = Some(BroadcastMrBsModifiedList::decode(data)?)
                }
                458 => {
                    broadcast_mr_bs_failed_to_be_modified_list =
                        Some(BroadcastMrBsFailedToBeModifiedList::decode(data)?)
                }
                7 => criticality_diagnostics = Some(CriticalityDiagnostics::decode(data)?),
                646 => broadcast_area_scope = Some(BroadcastAreaScope::decode(data)?),
                x => return Err(per_codec_error_new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        let gnb_cu_mbs_f1ap_id = gnb_cu_mbs_f1ap_id.ok_or(per_codec_error_new(format!(
            "Missing mandatory IE gnb_cu_mbs_f1ap_id"
        )))?;
        let gnb_du_mbs_f1ap_id = gnb_du_mbs_f1ap_id.ok_or(per_codec_error_new(format!(
            "Missing mandatory IE gnb_du_mbs_f1ap_id"
        )))?;
        Ok(Self {
            gnb_cu_mbs_f1ap_id,
            gnb_du_mbs_f1ap_id,
            broadcast_mr_bs_setup_mod_list,
            broadcast_mr_bs_failed_to_be_setup_mod_list,
            broadcast_mr_bs_modified_list,
            broadcast_mr_bs_failed_to_be_modified_list,
            criticality_diagnostics,
            broadcast_area_scope,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        let ie = &mut Allocator::new_codec_data();
        self.gnb_cu_mbs_f1ap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 451, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.gnb_du_mbs_f1ap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 452, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        if let Some(x) = &self.broadcast_mr_bs_setup_mod_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 468, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.broadcast_mr_bs_failed_to_be_setup_mod_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 462, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.broadcast_mr_bs_modified_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 464, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.broadcast_mr_bs_failed_to_be_modified_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 458, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.criticality_diagnostics {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 7, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.broadcast_area_scope {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 646, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        encode::encode_sequence_header(data, true, &BitString::new(), false)?;
        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for BroadcastContextModificationResponse {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        BroadcastContextModificationResponse::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("BroadcastContextModificationResponse");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("BroadcastContextModificationResponse");
            e
        })
    }
}
// BroadcastMrBsSetupModList
#[derive(Clone, Debug)]
pub struct BroadcastMrBsSetupModList(pub NonEmpty<BroadcastMrBsSetupModItem>);

impl BroadcastMrBsSetupModList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(32), false)?;
            let mut items = vec![];
            for _ in 0..length {
                let _ = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _ = Criticality::decode(data)?;
                let _ = decode::decode_length_determinent(data, None, None, false)?;
                items.push(BroadcastMrBsSetupModItem::decode(data)?);
                data.decode_align()?;
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(32), false, self.0.len())?;
        for x in &self.0 {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(data, Some(0), Some(65535), false, 469, false)?;
            Criticality::Reject.encode(data)?;
            encode::encode_length_determinent(data, None, None, false, ie.length_in_bytes())?;
            data.append_aligned(ie);
        }
        Ok(())
    }
}

impl PerCodec for BroadcastMrBsSetupModList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        BroadcastMrBsSetupModList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("BroadcastMrBsSetupModList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("BroadcastMrBsSetupModList");
            e
        })
    }
}
// BroadcastMrBsFailedToBeSetupModList
#[derive(Clone, Debug)]
pub struct BroadcastMrBsFailedToBeSetupModList(pub NonEmpty<BroadcastMrBsFailedToBeSetupModItem>);

impl BroadcastMrBsFailedToBeSetupModList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(32), false)?;
            let mut items = vec![];
            for _ in 0..length {
                let _ = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _ = Criticality::decode(data)?;
                let _ = decode::decode_length_determinent(data, None, None, false)?;
                items.push(BroadcastMrBsFailedToBeSetupModItem::decode(data)?);
                data.decode_align()?;
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(32), false, self.0.len())?;
        for x in &self.0 {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(data, Some(0), Some(65535), false, 463, false)?;
            Criticality::Ignore.encode(data)?;
            encode::encode_length_determinent(data, None, None, false, ie.length_in_bytes())?;
            data.append_aligned(ie);
        }
        Ok(())
    }
}

impl PerCodec for BroadcastMrBsFailedToBeSetupModList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        BroadcastMrBsFailedToBeSetupModList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("BroadcastMrBsFailedToBeSetupModList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("BroadcastMrBsFailedToBeSetupModList");
            e
        })
    }
}
// BroadcastMrBsModifiedList
#[derive(Clone, Debug)]
pub struct BroadcastMrBsModifiedList(pub NonEmpty<BroadcastMrBsModifiedItem>);

impl BroadcastMrBsModifiedList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(32), false)?;
            let mut items = vec![];
            for _ in 0..length {
                let _ = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _ = Criticality::decode(data)?;
                let _ = decode::decode_length_determinent(data, None, None, false)?;
                items.push(BroadcastMrBsModifiedItem::decode(data)?);
                data.decode_align()?;
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(32), false, self.0.len())?;
        for x in &self.0 {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(data, Some(0), Some(65535), false, 465, false)?;
            Criticality::Reject.encode(data)?;
            encode::encode_length_determinent(data, None, None, false, ie.length_in_bytes())?;
            data.append_aligned(ie);
        }
        Ok(())
    }
}

impl PerCodec for BroadcastMrBsModifiedList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        BroadcastMrBsModifiedList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("BroadcastMrBsModifiedList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("BroadcastMrBsModifiedList");
            e
        })
    }
}
// BroadcastMrBsFailedToBeModifiedList
#[derive(Clone, Debug)]
pub struct BroadcastMrBsFailedToBeModifiedList(pub NonEmpty<BroadcastMrBsFailedToBeModifiedItem>);

impl BroadcastMrBsFailedToBeModifiedList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(32), false)?;
            let mut items = vec![];
            for _ in 0..length {
                let _ = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _ = Criticality::decode(data)?;
                let _ = decode::decode_length_determinent(data, None, None, false)?;
                items.push(BroadcastMrBsFailedToBeModifiedItem::decode(data)?);
                data.decode_align()?;
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(32), false, self.0.len())?;
        for x in &self.0 {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(data, Some(0), Some(65535), false, 459, false)?;
            Criticality::Ignore.encode(data)?;
            encode::encode_length_determinent(data, None, None, false, ie.length_in_bytes())?;
            data.append_aligned(ie);
        }
        Ok(())
    }
}

impl PerCodec for BroadcastMrBsFailedToBeModifiedList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        BroadcastMrBsFailedToBeModifiedList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("BroadcastMrBsFailedToBeModifiedList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("BroadcastMrBsFailedToBeModifiedList");
            e
        })
    }
}
// BroadcastContextModificationFailure
#[derive(Clone, Debug)]
pub struct BroadcastContextModificationFailure {
    pub gnb_cu_mbs_f1ap_id: GnbCuMbsF1apId,
    pub gnb_du_mbs_f1ap_id: GnbDuMbsF1apId,
    pub cause: Cause,
    pub criticality_diagnostics: Option<CriticalityDiagnostics>,
}

impl BroadcastContextModificationFailure {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let _ = decode::decode_sequence_header(data, true, 0)?;
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut gnb_cu_mbs_f1ap_id: Option<GnbCuMbsF1apId> = None;
        let mut gnb_du_mbs_f1ap_id: Option<GnbDuMbsF1apId> = None;
        let mut cause: Option<Cause> = None;
        let mut criticality_diagnostics: Option<CriticalityDiagnostics> = None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                451 => gnb_cu_mbs_f1ap_id = Some(GnbCuMbsF1apId::decode(data)?),
                452 => gnb_du_mbs_f1ap_id = Some(GnbDuMbsF1apId::decode(data)?),
                0 => cause = Some(Cause::decode(data)?),
                7 => criticality_diagnostics = Some(CriticalityDiagnostics::decode(data)?),
                x => return Err(per_codec_error_new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        let gnb_cu_mbs_f1ap_id = gnb_cu_mbs_f1ap_id.ok_or(per_codec_error_new(format!(
            "Missing mandatory IE gnb_cu_mbs_f1ap_id"
        )))?;
        let gnb_du_mbs_f1ap_id = gnb_du_mbs_f1ap_id.ok_or(per_codec_error_new(format!(
            "Missing mandatory IE gnb_du_mbs_f1ap_id"
        )))?;
        let cause = cause.ok_or(per_codec_error_new(format!("Missing mandatory IE cause")))?;
        Ok(Self {
            gnb_cu_mbs_f1ap_id,
            gnb_du_mbs_f1ap_id,
            cause,
            criticality_diagnostics,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        let ie = &mut Allocator::new_codec_data();
        self.gnb_cu_mbs_f1ap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 451, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.gnb_du_mbs_f1ap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 452, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.cause.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 0, false)?;
        Criticality::Ignore.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        if let Some(x) = &self.criticality_diagnostics {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 7, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        encode::encode_sequence_header(data, true, &BitString::new(), false)?;
        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for BroadcastContextModificationFailure {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        BroadcastContextModificationFailure::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("BroadcastContextModificationFailure");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("BroadcastContextModificationFailure");
            e
        })
    }
}
// BroadcastTransportResourceRequest
#[derive(Clone, Debug)]
pub struct BroadcastTransportResourceRequest {
    pub gnb_cu_mbs_f1ap_id: GnbCuMbsF1apId,
    pub gnb_du_mbs_f1ap_id: GnbDuMbsF1apId,
    pub broadcast_mr_bs_transport_request_list: Option<BroadcastMrBsTransportRequestList>,
    pub f1u_path_failure: Option<F1uPathFailure>,
}

impl BroadcastTransportResourceRequest {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let _ = decode::decode_sequence_header(data, true, 0)?;
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut gnb_cu_mbs_f1ap_id: Option<GnbCuMbsF1apId> = None;
        let mut gnb_du_mbs_f1ap_id: Option<GnbDuMbsF1apId> = None;
        let mut broadcast_mr_bs_transport_request_list: Option<BroadcastMrBsTransportRequestList> =
            None;
        let mut f1u_path_failure: Option<F1uPathFailure> = None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                451 => gnb_cu_mbs_f1ap_id = Some(GnbCuMbsF1apId::decode(data)?),
                452 => gnb_du_mbs_f1ap_id = Some(GnbDuMbsF1apId::decode(data)?),
                789 => {
                    broadcast_mr_bs_transport_request_list =
                        Some(BroadcastMrBsTransportRequestList::decode(data)?)
                }
                846 => f1u_path_failure = Some(F1uPathFailure::decode(data)?),
                x => return Err(per_codec_error_new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        let gnb_cu_mbs_f1ap_id = gnb_cu_mbs_f1ap_id.ok_or(per_codec_error_new(format!(
            "Missing mandatory IE gnb_cu_mbs_f1ap_id"
        )))?;
        let gnb_du_mbs_f1ap_id = gnb_du_mbs_f1ap_id.ok_or(per_codec_error_new(format!(
            "Missing mandatory IE gnb_du_mbs_f1ap_id"
        )))?;
        Ok(Self {
            gnb_cu_mbs_f1ap_id,
            gnb_du_mbs_f1ap_id,
            broadcast_mr_bs_transport_request_list,
            f1u_path_failure,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        let ie = &mut Allocator::new_codec_data();
        self.gnb_cu_mbs_f1ap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 451, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.gnb_du_mbs_f1ap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 452, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        if let Some(x) = &self.broadcast_mr_bs_transport_request_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 789, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.f1u_path_failure {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 846, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        encode::encode_sequence_header(data, true, &BitString::new(), false)?;
        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for BroadcastTransportResourceRequest {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        BroadcastTransportResourceRequest::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("BroadcastTransportResourceRequest");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("BroadcastTransportResourceRequest");
            e
        })
    }
}
// BroadcastMrBsTransportRequestList
#[derive(Clone, Debug)]
pub struct BroadcastMrBsTransportRequestList(pub NonEmpty<BroadcastMrBsTransportRequestItem>);

impl BroadcastMrBsTransportRequestList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(32), false)?;
            let mut items = vec![];
            for _ in 0..length {
                let _ = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _ = Criticality::decode(data)?;
                let _ = decode::decode_length_determinent(data, None, None, false)?;
                items.push(BroadcastMrBsTransportRequestItem::decode(data)?);
                data.decode_align()?;
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(32), false, self.0.len())?;
        for x in &self.0 {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(data, Some(0), Some(65535), false, 790, false)?;
            Criticality::Reject.encode(data)?;
            encode::encode_length_determinent(data, None, None, false, ie.length_in_bytes())?;
            data.append_aligned(ie);
        }
        Ok(())
    }
}

impl PerCodec for BroadcastMrBsTransportRequestList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        BroadcastMrBsTransportRequestList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("BroadcastMrBsTransportRequestList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("BroadcastMrBsTransportRequestList");
            e
        })
    }
}
// MulticastGroupPaging
#[derive(Clone, Debug)]
pub struct MulticastGroupPaging {
    pub mbs_session_id: MbsSessionId,
    pub ue_identity_list_for_paging_list: Option<UeIdentityListForPagingList>,
    pub mc_paging_cell_list: Option<McPagingCellList>,
    pub indication_mc_inactive_reception: Option<IndicationMcInactiveReception>,
}

impl MulticastGroupPaging {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let _ = decode::decode_sequence_header(data, true, 0)?;
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut mbs_session_id: Option<MbsSessionId> = None;
        let mut ue_identity_list_for_paging_list: Option<UeIdentityListForPagingList> = None;
        let mut mc_paging_cell_list: Option<McPagingCellList> = None;
        let mut indication_mc_inactive_reception: Option<IndicationMcInactiveReception> = None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                455 => mbs_session_id = Some(MbsSessionId::decode(data)?),
                479 => {
                    ue_identity_list_for_paging_list =
                        Some(UeIdentityListForPagingList::decode(data)?)
                }
                687 => mc_paging_cell_list = Some(McPagingCellList::decode(data)?),
                768 => {
                    indication_mc_inactive_reception =
                        Some(IndicationMcInactiveReception::decode(data)?)
                }
                x => return Err(per_codec_error_new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        let mbs_session_id = mbs_session_id.ok_or(per_codec_error_new(format!(
            "Missing mandatory IE mbs_session_id"
        )))?;
        Ok(Self {
            mbs_session_id,
            ue_identity_list_for_paging_list,
            mc_paging_cell_list,
            indication_mc_inactive_reception,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        let ie = &mut Allocator::new_codec_data();
        self.mbs_session_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 455, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        if let Some(x) = &self.ue_identity_list_for_paging_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 479, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.mc_paging_cell_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 687, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.indication_mc_inactive_reception {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 768, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        encode::encode_sequence_header(data, true, &BitString::new(), false)?;
        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for MulticastGroupPaging {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        MulticastGroupPaging::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MulticastGroupPaging");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MulticastGroupPaging");
            e
        })
    }
}
// UeIdentityListForPagingList
#[derive(Clone, Debug)]
pub struct UeIdentityListForPagingList(pub NonEmpty<UeIdentityListForPagingItem>);

impl UeIdentityListForPagingList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(4096), false)?;
            let mut items = vec![];
            for _ in 0..length {
                let _ = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _ = Criticality::decode(data)?;
                let _ = decode::decode_length_determinent(data, None, None, false)?;
                items.push(UeIdentityListForPagingItem::decode(data)?);
                data.decode_align()?;
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(4096), false, self.0.len())?;
        for x in &self.0 {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(data, Some(0), Some(65535), false, 480, false)?;
            Criticality::Ignore.encode(data)?;
            encode::encode_length_determinent(data, None, None, false, ie.length_in_bytes())?;
            data.append_aligned(ie);
        }
        Ok(())
    }
}

impl PerCodec for UeIdentityListForPagingList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        UeIdentityListForPagingList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UeIdentityListForPagingList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UeIdentityListForPagingList");
            e
        })
    }
}
// McPagingCellList
#[derive(Clone, Debug)]
pub struct McPagingCellList(pub NonEmpty<McPagingCellItem>);

impl McPagingCellList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(512), false)?;
            let mut items = vec![];
            for _ in 0..length {
                let _ = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _ = Criticality::decode(data)?;
                let _ = decode::decode_length_determinent(data, None, None, false)?;
                items.push(McPagingCellItem::decode(data)?);
                data.decode_align()?;
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(512), false, self.0.len())?;
        for x in &self.0 {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(data, Some(0), Some(65535), false, 688, false)?;
            Criticality::Ignore.encode(data)?;
            encode::encode_length_determinent(data, None, None, false, ie.length_in_bytes())?;
            data.append_aligned(ie);
        }
        Ok(())
    }
}

impl PerCodec for McPagingCellList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        McPagingCellList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("McPagingCellList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("McPagingCellList");
            e
        })
    }
}
// MulticastContextSetupRequest
#[derive(Clone, Debug)]
pub struct MulticastContextSetupRequest {
    pub gnb_cu_mbs_f1ap_id: GnbCuMbsF1apId,
    pub mbs_session_id: MbsSessionId,
    pub mbs_service_area: Option<MbsServiceArea>,
    pub snssai: Snssai,
    pub multicast_mr_bs_to_be_setup_list: MulticastMrBsToBeSetupList,
    pub multicast_cu_2_du_rrc_info: Option<MulticastCu2DuRrcInfo>,
    pub mbs_multicast_session_reception_state: Option<MbsMulticastSessionReceptionState>,
}

impl MulticastContextSetupRequest {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let _ = decode::decode_sequence_header(data, true, 0)?;
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut gnb_cu_mbs_f1ap_id: Option<GnbCuMbsF1apId> = None;
        let mut mbs_session_id: Option<MbsSessionId> = None;
        let mut mbs_service_area: Option<MbsServiceArea> = None;
        let mut snssai: Option<Snssai> = None;
        let mut multicast_mr_bs_to_be_setup_list: Option<MulticastMrBsToBeSetupList> = None;
        let mut multicast_cu_2_du_rrc_info: Option<MulticastCu2DuRrcInfo> = None;
        let mut mbs_multicast_session_reception_state: Option<MbsMulticastSessionReceptionState> =
            None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                451 => gnb_cu_mbs_f1ap_id = Some(GnbCuMbsF1apId::decode(data)?),
                455 => mbs_session_id = Some(MbsSessionId::decode(data)?),
                481 => mbs_service_area = Some(MbsServiceArea::decode(data)?),
                456 => snssai = Some(Snssai::decode(data)?),
                498 => {
                    multicast_mr_bs_to_be_setup_list =
                        Some(MulticastMrBsToBeSetupList::decode(data)?)
                }
                769 => multicast_cu_2_du_rrc_info = Some(MulticastCu2DuRrcInfo::decode(data)?),
                770 => {
                    mbs_multicast_session_reception_state =
                        Some(MbsMulticastSessionReceptionState::decode(data)?)
                }
                x => return Err(per_codec_error_new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        let gnb_cu_mbs_f1ap_id = gnb_cu_mbs_f1ap_id.ok_or(per_codec_error_new(format!(
            "Missing mandatory IE gnb_cu_mbs_f1ap_id"
        )))?;
        let mbs_session_id = mbs_session_id.ok_or(per_codec_error_new(format!(
            "Missing mandatory IE mbs_session_id"
        )))?;
        let snssai = snssai.ok_or(per_codec_error_new(format!("Missing mandatory IE snssai")))?;
        let multicast_mr_bs_to_be_setup_list =
            multicast_mr_bs_to_be_setup_list.ok_or(per_codec_error_new(format!(
                "Missing mandatory IE multicast_mr_bs_to_be_setup_list"
            )))?;
        Ok(Self {
            gnb_cu_mbs_f1ap_id,
            mbs_session_id,
            mbs_service_area,
            snssai,
            multicast_mr_bs_to_be_setup_list,
            multicast_cu_2_du_rrc_info,
            mbs_multicast_session_reception_state,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        let ie = &mut Allocator::new_codec_data();
        self.gnb_cu_mbs_f1ap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 451, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.mbs_session_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 455, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        if let Some(x) = &self.mbs_service_area {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 481, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        let ie = &mut Allocator::new_codec_data();
        self.snssai.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 456, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.multicast_mr_bs_to_be_setup_list.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 498, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        if let Some(x) = &self.multicast_cu_2_du_rrc_info {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 769, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.mbs_multicast_session_reception_state {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 770, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        encode::encode_sequence_header(data, true, &BitString::new(), false)?;
        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for MulticastContextSetupRequest {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        MulticastContextSetupRequest::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MulticastContextSetupRequest");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MulticastContextSetupRequest");
            e
        })
    }
}
// MulticastMrBsToBeSetupList
#[derive(Clone, Debug)]
pub struct MulticastMrBsToBeSetupList(pub NonEmpty<MulticastMrBsToBeSetupItem>);

impl MulticastMrBsToBeSetupList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(32), false)?;
            let mut items = vec![];
            for _ in 0..length {
                let _ = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _ = Criticality::decode(data)?;
                let _ = decode::decode_length_determinent(data, None, None, false)?;
                items.push(MulticastMrBsToBeSetupItem::decode(data)?);
                data.decode_align()?;
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(32), false, self.0.len())?;
        for x in &self.0 {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(data, Some(0), Some(65535), false, 499, false)?;
            Criticality::Reject.encode(data)?;
            encode::encode_length_determinent(data, None, None, false, ie.length_in_bytes())?;
            data.append_aligned(ie);
        }
        Ok(())
    }
}

impl PerCodec for MulticastMrBsToBeSetupList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        MulticastMrBsToBeSetupList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MulticastMrBsToBeSetupList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MulticastMrBsToBeSetupList");
            e
        })
    }
}
// MulticastContextSetupResponse
#[derive(Clone, Debug)]
pub struct MulticastContextSetupResponse {
    pub gnb_cu_mbs_f1ap_id: GnbCuMbsF1apId,
    pub gnb_du_mbs_f1ap_id: GnbDuMbsF1apId,
    pub multicast_mr_bs_setup_list: MulticastMrBsSetupList,
    pub multicast_mr_bs_failed_to_be_setup_list: Option<MulticastMrBsFailedToBeSetupList>,
    pub criticality_diagnostics: Option<CriticalityDiagnostics>,
    pub multicast_du_2_cu_rrc_info: Option<MulticastDu2CuRrcInfo>,
}

impl MulticastContextSetupResponse {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let _ = decode::decode_sequence_header(data, true, 0)?;
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut gnb_cu_mbs_f1ap_id: Option<GnbCuMbsF1apId> = None;
        let mut gnb_du_mbs_f1ap_id: Option<GnbDuMbsF1apId> = None;
        let mut multicast_mr_bs_setup_list: Option<MulticastMrBsSetupList> = None;
        let mut multicast_mr_bs_failed_to_be_setup_list: Option<MulticastMrBsFailedToBeSetupList> =
            None;
        let mut criticality_diagnostics: Option<CriticalityDiagnostics> = None;
        let mut multicast_du_2_cu_rrc_info: Option<MulticastDu2CuRrcInfo> = None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                451 => gnb_cu_mbs_f1ap_id = Some(GnbCuMbsF1apId::decode(data)?),
                452 => gnb_du_mbs_f1ap_id = Some(GnbDuMbsF1apId::decode(data)?),
                490 => multicast_mr_bs_setup_list = Some(MulticastMrBsSetupList::decode(data)?),
                484 => {
                    multicast_mr_bs_failed_to_be_setup_list =
                        Some(MulticastMrBsFailedToBeSetupList::decode(data)?)
                }
                7 => criticality_diagnostics = Some(CriticalityDiagnostics::decode(data)?),
                772 => multicast_du_2_cu_rrc_info = Some(MulticastDu2CuRrcInfo::decode(data)?),
                x => return Err(per_codec_error_new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        let gnb_cu_mbs_f1ap_id = gnb_cu_mbs_f1ap_id.ok_or(per_codec_error_new(format!(
            "Missing mandatory IE gnb_cu_mbs_f1ap_id"
        )))?;
        let gnb_du_mbs_f1ap_id = gnb_du_mbs_f1ap_id.ok_or(per_codec_error_new(format!(
            "Missing mandatory IE gnb_du_mbs_f1ap_id"
        )))?;
        let multicast_mr_bs_setup_list = multicast_mr_bs_setup_list.ok_or(per_codec_error_new(
            format!("Missing mandatory IE multicast_mr_bs_setup_list"),
        ))?;
        Ok(Self {
            gnb_cu_mbs_f1ap_id,
            gnb_du_mbs_f1ap_id,
            multicast_mr_bs_setup_list,
            multicast_mr_bs_failed_to_be_setup_list,
            criticality_diagnostics,
            multicast_du_2_cu_rrc_info,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        let ie = &mut Allocator::new_codec_data();
        self.gnb_cu_mbs_f1ap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 451, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.gnb_du_mbs_f1ap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 452, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.multicast_mr_bs_setup_list.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 490, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        if let Some(x) = &self.multicast_mr_bs_failed_to_be_setup_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 484, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.criticality_diagnostics {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 7, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.multicast_du_2_cu_rrc_info {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 772, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        encode::encode_sequence_header(data, true, &BitString::new(), false)?;
        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for MulticastContextSetupResponse {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        MulticastContextSetupResponse::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MulticastContextSetupResponse");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MulticastContextSetupResponse");
            e
        })
    }
}
// MulticastMrBsSetupList
#[derive(Clone, Debug)]
pub struct MulticastMrBsSetupList(pub NonEmpty<MulticastMrBsSetupItem>);

impl MulticastMrBsSetupList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(32), false)?;
            let mut items = vec![];
            for _ in 0..length {
                let _ = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _ = Criticality::decode(data)?;
                let _ = decode::decode_length_determinent(data, None, None, false)?;
                items.push(MulticastMrBsSetupItem::decode(data)?);
                data.decode_align()?;
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(32), false, self.0.len())?;
        for x in &self.0 {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(data, Some(0), Some(65535), false, 491, false)?;
            Criticality::Reject.encode(data)?;
            encode::encode_length_determinent(data, None, None, false, ie.length_in_bytes())?;
            data.append_aligned(ie);
        }
        Ok(())
    }
}

impl PerCodec for MulticastMrBsSetupList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        MulticastMrBsSetupList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MulticastMrBsSetupList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MulticastMrBsSetupList");
            e
        })
    }
}
// MulticastMrBsFailedToBeSetupList
#[derive(Clone, Debug)]
pub struct MulticastMrBsFailedToBeSetupList(pub NonEmpty<MulticastMrBsFailedToBeSetupItem>);

impl MulticastMrBsFailedToBeSetupList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(32), false)?;
            let mut items = vec![];
            for _ in 0..length {
                let _ = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _ = Criticality::decode(data)?;
                let _ = decode::decode_length_determinent(data, None, None, false)?;
                items.push(MulticastMrBsFailedToBeSetupItem::decode(data)?);
                data.decode_align()?;
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(32), false, self.0.len())?;
        for x in &self.0 {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(data, Some(0), Some(65535), false, 485, false)?;
            Criticality::Ignore.encode(data)?;
            encode::encode_length_determinent(data, None, None, false, ie.length_in_bytes())?;
            data.append_aligned(ie);
        }
        Ok(())
    }
}

impl PerCodec for MulticastMrBsFailedToBeSetupList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        MulticastMrBsFailedToBeSetupList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MulticastMrBsFailedToBeSetupList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MulticastMrBsFailedToBeSetupList");
            e
        })
    }
}
// MulticastContextSetupFailure
#[derive(Clone, Debug)]
pub struct MulticastContextSetupFailure {
    pub gnb_cu_mbs_f1ap_id: GnbCuMbsF1apId,
    pub gnb_du_mbs_f1ap_id: Option<GnbDuMbsF1apId>,
    pub cause: Cause,
    pub criticality_diagnostics: Option<CriticalityDiagnostics>,
}

impl MulticastContextSetupFailure {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let _ = decode::decode_sequence_header(data, true, 0)?;
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut gnb_cu_mbs_f1ap_id: Option<GnbCuMbsF1apId> = None;
        let mut gnb_du_mbs_f1ap_id: Option<GnbDuMbsF1apId> = None;
        let mut cause: Option<Cause> = None;
        let mut criticality_diagnostics: Option<CriticalityDiagnostics> = None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                451 => gnb_cu_mbs_f1ap_id = Some(GnbCuMbsF1apId::decode(data)?),
                452 => gnb_du_mbs_f1ap_id = Some(GnbDuMbsF1apId::decode(data)?),
                0 => cause = Some(Cause::decode(data)?),
                7 => criticality_diagnostics = Some(CriticalityDiagnostics::decode(data)?),
                x => return Err(per_codec_error_new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        let gnb_cu_mbs_f1ap_id = gnb_cu_mbs_f1ap_id.ok_or(per_codec_error_new(format!(
            "Missing mandatory IE gnb_cu_mbs_f1ap_id"
        )))?;
        let cause = cause.ok_or(per_codec_error_new(format!("Missing mandatory IE cause")))?;
        Ok(Self {
            gnb_cu_mbs_f1ap_id,
            gnb_du_mbs_f1ap_id,
            cause,
            criticality_diagnostics,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        let ie = &mut Allocator::new_codec_data();
        self.gnb_cu_mbs_f1ap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 451, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        if let Some(x) = &self.gnb_du_mbs_f1ap_id {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 452, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        let ie = &mut Allocator::new_codec_data();
        self.cause.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 0, false)?;
        Criticality::Ignore.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        if let Some(x) = &self.criticality_diagnostics {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 7, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        encode::encode_sequence_header(data, true, &BitString::new(), false)?;
        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for MulticastContextSetupFailure {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        MulticastContextSetupFailure::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MulticastContextSetupFailure");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MulticastContextSetupFailure");
            e
        })
    }
}
// MulticastContextReleaseCommand
#[derive(Clone, Debug)]
pub struct MulticastContextReleaseCommand {
    pub gnb_cu_mbs_f1ap_id: GnbCuMbsF1apId,
    pub gnb_du_mbs_f1ap_id: GnbDuMbsF1apId,
    pub cause: Cause,
}

impl MulticastContextReleaseCommand {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let _ = decode::decode_sequence_header(data, true, 0)?;
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut gnb_cu_mbs_f1ap_id: Option<GnbCuMbsF1apId> = None;
        let mut gnb_du_mbs_f1ap_id: Option<GnbDuMbsF1apId> = None;
        let mut cause: Option<Cause> = None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                451 => gnb_cu_mbs_f1ap_id = Some(GnbCuMbsF1apId::decode(data)?),
                452 => gnb_du_mbs_f1ap_id = Some(GnbDuMbsF1apId::decode(data)?),
                0 => cause = Some(Cause::decode(data)?),
                x => return Err(per_codec_error_new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        let gnb_cu_mbs_f1ap_id = gnb_cu_mbs_f1ap_id.ok_or(per_codec_error_new(format!(
            "Missing mandatory IE gnb_cu_mbs_f1ap_id"
        )))?;
        let gnb_du_mbs_f1ap_id = gnb_du_mbs_f1ap_id.ok_or(per_codec_error_new(format!(
            "Missing mandatory IE gnb_du_mbs_f1ap_id"
        )))?;
        let cause = cause.ok_or(per_codec_error_new(format!("Missing mandatory IE cause")))?;
        Ok(Self {
            gnb_cu_mbs_f1ap_id,
            gnb_du_mbs_f1ap_id,
            cause,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        let ie = &mut Allocator::new_codec_data();
        self.gnb_cu_mbs_f1ap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 451, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.gnb_du_mbs_f1ap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 452, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.cause.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 0, false)?;
        Criticality::Ignore.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        encode::encode_sequence_header(data, true, &BitString::new(), false)?;
        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for MulticastContextReleaseCommand {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        MulticastContextReleaseCommand::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MulticastContextReleaseCommand");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MulticastContextReleaseCommand");
            e
        })
    }
}
// MulticastContextReleaseComplete
#[derive(Clone, Debug)]
pub struct MulticastContextReleaseComplete {
    pub gnb_cu_mbs_f1ap_id: GnbCuMbsF1apId,
    pub gnb_du_mbs_f1ap_id: GnbDuMbsF1apId,
    pub criticality_diagnostics: Option<CriticalityDiagnostics>,
}

impl MulticastContextReleaseComplete {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let _ = decode::decode_sequence_header(data, true, 0)?;
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut gnb_cu_mbs_f1ap_id: Option<GnbCuMbsF1apId> = None;
        let mut gnb_du_mbs_f1ap_id: Option<GnbDuMbsF1apId> = None;
        let mut criticality_diagnostics: Option<CriticalityDiagnostics> = None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                451 => gnb_cu_mbs_f1ap_id = Some(GnbCuMbsF1apId::decode(data)?),
                452 => gnb_du_mbs_f1ap_id = Some(GnbDuMbsF1apId::decode(data)?),
                7 => criticality_diagnostics = Some(CriticalityDiagnostics::decode(data)?),
                x => return Err(per_codec_error_new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        let gnb_cu_mbs_f1ap_id = gnb_cu_mbs_f1ap_id.ok_or(per_codec_error_new(format!(
            "Missing mandatory IE gnb_cu_mbs_f1ap_id"
        )))?;
        let gnb_du_mbs_f1ap_id = gnb_du_mbs_f1ap_id.ok_or(per_codec_error_new(format!(
            "Missing mandatory IE gnb_du_mbs_f1ap_id"
        )))?;
        Ok(Self {
            gnb_cu_mbs_f1ap_id,
            gnb_du_mbs_f1ap_id,
            criticality_diagnostics,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        let ie = &mut Allocator::new_codec_data();
        self.gnb_cu_mbs_f1ap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 451, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.gnb_du_mbs_f1ap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 452, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        if let Some(x) = &self.criticality_diagnostics {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 7, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        encode::encode_sequence_header(data, true, &BitString::new(), false)?;
        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for MulticastContextReleaseComplete {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        MulticastContextReleaseComplete::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MulticastContextReleaseComplete");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MulticastContextReleaseComplete");
            e
        })
    }
}
// MulticastContextReleaseRequest
#[derive(Clone, Debug)]
pub struct MulticastContextReleaseRequest {
    pub gnb_cu_mbs_f1ap_id: GnbCuMbsF1apId,
    pub gnb_du_mbs_f1ap_id: GnbDuMbsF1apId,
    pub cause: Cause,
}

impl MulticastContextReleaseRequest {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let _ = decode::decode_sequence_header(data, true, 0)?;
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut gnb_cu_mbs_f1ap_id: Option<GnbCuMbsF1apId> = None;
        let mut gnb_du_mbs_f1ap_id: Option<GnbDuMbsF1apId> = None;
        let mut cause: Option<Cause> = None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                451 => gnb_cu_mbs_f1ap_id = Some(GnbCuMbsF1apId::decode(data)?),
                452 => gnb_du_mbs_f1ap_id = Some(GnbDuMbsF1apId::decode(data)?),
                0 => cause = Some(Cause::decode(data)?),
                x => return Err(per_codec_error_new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        let gnb_cu_mbs_f1ap_id = gnb_cu_mbs_f1ap_id.ok_or(per_codec_error_new(format!(
            "Missing mandatory IE gnb_cu_mbs_f1ap_id"
        )))?;
        let gnb_du_mbs_f1ap_id = gnb_du_mbs_f1ap_id.ok_or(per_codec_error_new(format!(
            "Missing mandatory IE gnb_du_mbs_f1ap_id"
        )))?;
        let cause = cause.ok_or(per_codec_error_new(format!("Missing mandatory IE cause")))?;
        Ok(Self {
            gnb_cu_mbs_f1ap_id,
            gnb_du_mbs_f1ap_id,
            cause,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        let ie = &mut Allocator::new_codec_data();
        self.gnb_cu_mbs_f1ap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 451, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.gnb_du_mbs_f1ap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 452, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.cause.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 0, false)?;
        Criticality::Ignore.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        encode::encode_sequence_header(data, true, &BitString::new(), false)?;
        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for MulticastContextReleaseRequest {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        MulticastContextReleaseRequest::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MulticastContextReleaseRequest");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MulticastContextReleaseRequest");
            e
        })
    }
}
// MulticastContextModificationRequest
#[derive(Clone, Debug)]
pub struct MulticastContextModificationRequest {
    pub gnb_cu_mbs_f1ap_id: GnbCuMbsF1apId,
    pub gnb_du_mbs_f1ap_id: GnbDuMbsF1apId,
    pub mbs_service_area: Option<MbsServiceArea>,
    pub multicast_mr_bs_to_be_setup_mod_list: Option<MulticastMrBsToBeSetupModList>,
    pub multicast_mr_bs_to_be_modified_list: Option<MulticastMrBsToBeModifiedList>,
    pub multicast_mr_bs_to_be_released_list: Option<MulticastMrBsToBeReleasedList>,
    pub multicast_cu_2_du_rrc_info: Option<MulticastCu2DuRrcInfo>,
    pub mbs_multicast_session_reception_state: Option<MbsMulticastSessionReceptionState>,
}

impl MulticastContextModificationRequest {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let _ = decode::decode_sequence_header(data, true, 0)?;
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut gnb_cu_mbs_f1ap_id: Option<GnbCuMbsF1apId> = None;
        let mut gnb_du_mbs_f1ap_id: Option<GnbDuMbsF1apId> = None;
        let mut mbs_service_area: Option<MbsServiceArea> = None;
        let mut multicast_mr_bs_to_be_setup_mod_list: Option<MulticastMrBsToBeSetupModList> = None;
        let mut multicast_mr_bs_to_be_modified_list: Option<MulticastMrBsToBeModifiedList> = None;
        let mut multicast_mr_bs_to_be_released_list: Option<MulticastMrBsToBeReleasedList> = None;
        let mut multicast_cu_2_du_rrc_info: Option<MulticastCu2DuRrcInfo> = None;
        let mut mbs_multicast_session_reception_state: Option<MbsMulticastSessionReceptionState> =
            None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                451 => gnb_cu_mbs_f1ap_id = Some(GnbCuMbsF1apId::decode(data)?),
                452 => gnb_du_mbs_f1ap_id = Some(GnbDuMbsF1apId::decode(data)?),
                481 => mbs_service_area = Some(MbsServiceArea::decode(data)?),
                500 => {
                    multicast_mr_bs_to_be_setup_mod_list =
                        Some(MulticastMrBsToBeSetupModList::decode(data)?)
                }
                494 => {
                    multicast_mr_bs_to_be_modified_list =
                        Some(MulticastMrBsToBeModifiedList::decode(data)?)
                }
                496 => {
                    multicast_mr_bs_to_be_released_list =
                        Some(MulticastMrBsToBeReleasedList::decode(data)?)
                }
                769 => multicast_cu_2_du_rrc_info = Some(MulticastCu2DuRrcInfo::decode(data)?),
                770 => {
                    mbs_multicast_session_reception_state =
                        Some(MbsMulticastSessionReceptionState::decode(data)?)
                }
                x => return Err(per_codec_error_new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        let gnb_cu_mbs_f1ap_id = gnb_cu_mbs_f1ap_id.ok_or(per_codec_error_new(format!(
            "Missing mandatory IE gnb_cu_mbs_f1ap_id"
        )))?;
        let gnb_du_mbs_f1ap_id = gnb_du_mbs_f1ap_id.ok_or(per_codec_error_new(format!(
            "Missing mandatory IE gnb_du_mbs_f1ap_id"
        )))?;
        Ok(Self {
            gnb_cu_mbs_f1ap_id,
            gnb_du_mbs_f1ap_id,
            mbs_service_area,
            multicast_mr_bs_to_be_setup_mod_list,
            multicast_mr_bs_to_be_modified_list,
            multicast_mr_bs_to_be_released_list,
            multicast_cu_2_du_rrc_info,
            mbs_multicast_session_reception_state,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        let ie = &mut Allocator::new_codec_data();
        self.gnb_cu_mbs_f1ap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 451, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.gnb_du_mbs_f1ap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 452, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        if let Some(x) = &self.mbs_service_area {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 481, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.multicast_mr_bs_to_be_setup_mod_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 500, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.multicast_mr_bs_to_be_modified_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 494, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.multicast_mr_bs_to_be_released_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 496, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.multicast_cu_2_du_rrc_info {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 769, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.mbs_multicast_session_reception_state {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 770, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        encode::encode_sequence_header(data, true, &BitString::new(), false)?;
        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for MulticastContextModificationRequest {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        MulticastContextModificationRequest::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MulticastContextModificationRequest");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MulticastContextModificationRequest");
            e
        })
    }
}
// MulticastMrBsToBeSetupModList
#[derive(Clone, Debug)]
pub struct MulticastMrBsToBeSetupModList(pub NonEmpty<MulticastMrBsToBeSetupModItem>);

impl MulticastMrBsToBeSetupModList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(32), false)?;
            let mut items = vec![];
            for _ in 0..length {
                let _ = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _ = Criticality::decode(data)?;
                let _ = decode::decode_length_determinent(data, None, None, false)?;
                items.push(MulticastMrBsToBeSetupModItem::decode(data)?);
                data.decode_align()?;
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(32), false, self.0.len())?;
        for x in &self.0 {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(data, Some(0), Some(65535), false, 501, false)?;
            Criticality::Reject.encode(data)?;
            encode::encode_length_determinent(data, None, None, false, ie.length_in_bytes())?;
            data.append_aligned(ie);
        }
        Ok(())
    }
}

impl PerCodec for MulticastMrBsToBeSetupModList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        MulticastMrBsToBeSetupModList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MulticastMrBsToBeSetupModList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MulticastMrBsToBeSetupModList");
            e
        })
    }
}
// MulticastMrBsToBeModifiedList
#[derive(Clone, Debug)]
pub struct MulticastMrBsToBeModifiedList(pub NonEmpty<MulticastMrBsToBeModifiedItem>);

impl MulticastMrBsToBeModifiedList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(32), false)?;
            let mut items = vec![];
            for _ in 0..length {
                let _ = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _ = Criticality::decode(data)?;
                let _ = decode::decode_length_determinent(data, None, None, false)?;
                items.push(MulticastMrBsToBeModifiedItem::decode(data)?);
                data.decode_align()?;
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(32), false, self.0.len())?;
        for x in &self.0 {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(data, Some(0), Some(65535), false, 495, false)?;
            Criticality::Reject.encode(data)?;
            encode::encode_length_determinent(data, None, None, false, ie.length_in_bytes())?;
            data.append_aligned(ie);
        }
        Ok(())
    }
}

impl PerCodec for MulticastMrBsToBeModifiedList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        MulticastMrBsToBeModifiedList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MulticastMrBsToBeModifiedList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MulticastMrBsToBeModifiedList");
            e
        })
    }
}
// MulticastMrBsToBeReleasedList
#[derive(Clone, Debug)]
pub struct MulticastMrBsToBeReleasedList(pub NonEmpty<MulticastMrBsToBeReleasedItem>);

impl MulticastMrBsToBeReleasedList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(32), false)?;
            let mut items = vec![];
            for _ in 0..length {
                let _ = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _ = Criticality::decode(data)?;
                let _ = decode::decode_length_determinent(data, None, None, false)?;
                items.push(MulticastMrBsToBeReleasedItem::decode(data)?);
                data.decode_align()?;
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(32), false, self.0.len())?;
        for x in &self.0 {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(data, Some(0), Some(65535), false, 497, false)?;
            Criticality::Reject.encode(data)?;
            encode::encode_length_determinent(data, None, None, false, ie.length_in_bytes())?;
            data.append_aligned(ie);
        }
        Ok(())
    }
}

impl PerCodec for MulticastMrBsToBeReleasedList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        MulticastMrBsToBeReleasedList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MulticastMrBsToBeReleasedList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MulticastMrBsToBeReleasedList");
            e
        })
    }
}
// MulticastContextModificationResponse
#[derive(Clone, Debug)]
pub struct MulticastContextModificationResponse {
    pub gnb_cu_mbs_f1ap_id: GnbCuMbsF1apId,
    pub gnb_du_mbs_f1ap_id: GnbDuMbsF1apId,
    pub multicast_mr_bs_setup_mod_list: Option<MulticastMrBsSetupModList>,
    pub multicast_mr_bs_failed_to_be_setup_mod_list: Option<MulticastMrBsFailedToBeSetupModList>,
    pub multicast_mr_bs_modified_list: Option<MulticastMrBsModifiedList>,
    pub multicast_mr_bs_failed_to_be_modified_list: Option<MulticastMrBsFailedToBeModifiedList>,
    pub criticality_diagnostics: Option<CriticalityDiagnostics>,
    pub multicast_du_2_cu_rrc_info: Option<MulticastDu2CuRrcInfo>,
}

impl MulticastContextModificationResponse {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let _ = decode::decode_sequence_header(data, true, 0)?;
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut gnb_cu_mbs_f1ap_id: Option<GnbCuMbsF1apId> = None;
        let mut gnb_du_mbs_f1ap_id: Option<GnbDuMbsF1apId> = None;
        let mut multicast_mr_bs_setup_mod_list: Option<MulticastMrBsSetupModList> = None;
        let mut multicast_mr_bs_failed_to_be_setup_mod_list: Option<
            MulticastMrBsFailedToBeSetupModList,
        > = None;
        let mut multicast_mr_bs_modified_list: Option<MulticastMrBsModifiedList> = None;
        let mut multicast_mr_bs_failed_to_be_modified_list: Option<
            MulticastMrBsFailedToBeModifiedList,
        > = None;
        let mut criticality_diagnostics: Option<CriticalityDiagnostics> = None;
        let mut multicast_du_2_cu_rrc_info: Option<MulticastDu2CuRrcInfo> = None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                451 => gnb_cu_mbs_f1ap_id = Some(GnbCuMbsF1apId::decode(data)?),
                452 => gnb_du_mbs_f1ap_id = Some(GnbDuMbsF1apId::decode(data)?),
                492 => {
                    multicast_mr_bs_setup_mod_list = Some(MulticastMrBsSetupModList::decode(data)?)
                }
                486 => {
                    multicast_mr_bs_failed_to_be_setup_mod_list =
                        Some(MulticastMrBsFailedToBeSetupModList::decode(data)?)
                }
                488 => {
                    multicast_mr_bs_modified_list = Some(MulticastMrBsModifiedList::decode(data)?)
                }
                482 => {
                    multicast_mr_bs_failed_to_be_modified_list =
                        Some(MulticastMrBsFailedToBeModifiedList::decode(data)?)
                }
                7 => criticality_diagnostics = Some(CriticalityDiagnostics::decode(data)?),
                772 => multicast_du_2_cu_rrc_info = Some(MulticastDu2CuRrcInfo::decode(data)?),
                x => return Err(per_codec_error_new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        let gnb_cu_mbs_f1ap_id = gnb_cu_mbs_f1ap_id.ok_or(per_codec_error_new(format!(
            "Missing mandatory IE gnb_cu_mbs_f1ap_id"
        )))?;
        let gnb_du_mbs_f1ap_id = gnb_du_mbs_f1ap_id.ok_or(per_codec_error_new(format!(
            "Missing mandatory IE gnb_du_mbs_f1ap_id"
        )))?;
        Ok(Self {
            gnb_cu_mbs_f1ap_id,
            gnb_du_mbs_f1ap_id,
            multicast_mr_bs_setup_mod_list,
            multicast_mr_bs_failed_to_be_setup_mod_list,
            multicast_mr_bs_modified_list,
            multicast_mr_bs_failed_to_be_modified_list,
            criticality_diagnostics,
            multicast_du_2_cu_rrc_info,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        let ie = &mut Allocator::new_codec_data();
        self.gnb_cu_mbs_f1ap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 451, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.gnb_du_mbs_f1ap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 452, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        if let Some(x) = &self.multicast_mr_bs_setup_mod_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 492, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.multicast_mr_bs_failed_to_be_setup_mod_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 486, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.multicast_mr_bs_modified_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 488, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.multicast_mr_bs_failed_to_be_modified_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 482, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.criticality_diagnostics {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 7, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.multicast_du_2_cu_rrc_info {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 772, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        encode::encode_sequence_header(data, true, &BitString::new(), false)?;
        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for MulticastContextModificationResponse {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        MulticastContextModificationResponse::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MulticastContextModificationResponse");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MulticastContextModificationResponse");
            e
        })
    }
}
// MulticastMrBsSetupModList
#[derive(Clone, Debug)]
pub struct MulticastMrBsSetupModList(pub NonEmpty<MulticastMrBsSetupModItem>);

impl MulticastMrBsSetupModList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(32), false)?;
            let mut items = vec![];
            for _ in 0..length {
                let _ = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _ = Criticality::decode(data)?;
                let _ = decode::decode_length_determinent(data, None, None, false)?;
                items.push(MulticastMrBsSetupModItem::decode(data)?);
                data.decode_align()?;
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(32), false, self.0.len())?;
        for x in &self.0 {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(data, Some(0), Some(65535), false, 493, false)?;
            Criticality::Reject.encode(data)?;
            encode::encode_length_determinent(data, None, None, false, ie.length_in_bytes())?;
            data.append_aligned(ie);
        }
        Ok(())
    }
}

impl PerCodec for MulticastMrBsSetupModList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        MulticastMrBsSetupModList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MulticastMrBsSetupModList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MulticastMrBsSetupModList");
            e
        })
    }
}
// MulticastMrBsFailedToBeSetupModList
#[derive(Clone, Debug)]
pub struct MulticastMrBsFailedToBeSetupModList(pub NonEmpty<MulticastMrBsFailedToBeSetupModItem>);

impl MulticastMrBsFailedToBeSetupModList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(32), false)?;
            let mut items = vec![];
            for _ in 0..length {
                let _ = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _ = Criticality::decode(data)?;
                let _ = decode::decode_length_determinent(data, None, None, false)?;
                items.push(MulticastMrBsFailedToBeSetupModItem::decode(data)?);
                data.decode_align()?;
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(32), false, self.0.len())?;
        for x in &self.0 {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(data, Some(0), Some(65535), false, 487, false)?;
            Criticality::Ignore.encode(data)?;
            encode::encode_length_determinent(data, None, None, false, ie.length_in_bytes())?;
            data.append_aligned(ie);
        }
        Ok(())
    }
}

impl PerCodec for MulticastMrBsFailedToBeSetupModList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        MulticastMrBsFailedToBeSetupModList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MulticastMrBsFailedToBeSetupModList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MulticastMrBsFailedToBeSetupModList");
            e
        })
    }
}
// MulticastMrBsModifiedList
#[derive(Clone, Debug)]
pub struct MulticastMrBsModifiedList(pub NonEmpty<MulticastMrBsModifiedItem>);

impl MulticastMrBsModifiedList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(32), false)?;
            let mut items = vec![];
            for _ in 0..length {
                let _ = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _ = Criticality::decode(data)?;
                let _ = decode::decode_length_determinent(data, None, None, false)?;
                items.push(MulticastMrBsModifiedItem::decode(data)?);
                data.decode_align()?;
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(32), false, self.0.len())?;
        for x in &self.0 {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(data, Some(0), Some(65535), false, 489, false)?;
            Criticality::Reject.encode(data)?;
            encode::encode_length_determinent(data, None, None, false, ie.length_in_bytes())?;
            data.append_aligned(ie);
        }
        Ok(())
    }
}

impl PerCodec for MulticastMrBsModifiedList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        MulticastMrBsModifiedList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MulticastMrBsModifiedList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MulticastMrBsModifiedList");
            e
        })
    }
}
// MulticastMrBsFailedToBeModifiedList
#[derive(Clone, Debug)]
pub struct MulticastMrBsFailedToBeModifiedList(pub NonEmpty<MulticastMrBsFailedToBeModifiedItem>);

impl MulticastMrBsFailedToBeModifiedList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(32), false)?;
            let mut items = vec![];
            for _ in 0..length {
                let _ = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _ = Criticality::decode(data)?;
                let _ = decode::decode_length_determinent(data, None, None, false)?;
                items.push(MulticastMrBsFailedToBeModifiedItem::decode(data)?);
                data.decode_align()?;
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(32), false, self.0.len())?;
        for x in &self.0 {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(data, Some(0), Some(65535), false, 483, false)?;
            Criticality::Ignore.encode(data)?;
            encode::encode_length_determinent(data, None, None, false, ie.length_in_bytes())?;
            data.append_aligned(ie);
        }
        Ok(())
    }
}

impl PerCodec for MulticastMrBsFailedToBeModifiedList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        MulticastMrBsFailedToBeModifiedList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MulticastMrBsFailedToBeModifiedList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MulticastMrBsFailedToBeModifiedList");
            e
        })
    }
}
// MulticastContextModificationFailure
#[derive(Clone, Debug)]
pub struct MulticastContextModificationFailure {
    pub gnb_cu_mbs_f1ap_id: GnbCuMbsF1apId,
    pub gnb_du_mbs_f1ap_id: GnbDuMbsF1apId,
    pub cause: Cause,
    pub criticality_diagnostics: Option<CriticalityDiagnostics>,
}

impl MulticastContextModificationFailure {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let _ = decode::decode_sequence_header(data, true, 0)?;
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut gnb_cu_mbs_f1ap_id: Option<GnbCuMbsF1apId> = None;
        let mut gnb_du_mbs_f1ap_id: Option<GnbDuMbsF1apId> = None;
        let mut cause: Option<Cause> = None;
        let mut criticality_diagnostics: Option<CriticalityDiagnostics> = None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                451 => gnb_cu_mbs_f1ap_id = Some(GnbCuMbsF1apId::decode(data)?),
                452 => gnb_du_mbs_f1ap_id = Some(GnbDuMbsF1apId::decode(data)?),
                0 => cause = Some(Cause::decode(data)?),
                7 => criticality_diagnostics = Some(CriticalityDiagnostics::decode(data)?),
                x => return Err(per_codec_error_new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        let gnb_cu_mbs_f1ap_id = gnb_cu_mbs_f1ap_id.ok_or(per_codec_error_new(format!(
            "Missing mandatory IE gnb_cu_mbs_f1ap_id"
        )))?;
        let gnb_du_mbs_f1ap_id = gnb_du_mbs_f1ap_id.ok_or(per_codec_error_new(format!(
            "Missing mandatory IE gnb_du_mbs_f1ap_id"
        )))?;
        let cause = cause.ok_or(per_codec_error_new(format!("Missing mandatory IE cause")))?;
        Ok(Self {
            gnb_cu_mbs_f1ap_id,
            gnb_du_mbs_f1ap_id,
            cause,
            criticality_diagnostics,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        let ie = &mut Allocator::new_codec_data();
        self.gnb_cu_mbs_f1ap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 451, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.gnb_du_mbs_f1ap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 452, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.cause.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 0, false)?;
        Criticality::Ignore.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        if let Some(x) = &self.criticality_diagnostics {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 7, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        encode::encode_sequence_header(data, true, &BitString::new(), false)?;
        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for MulticastContextModificationFailure {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        MulticastContextModificationFailure::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MulticastContextModificationFailure");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MulticastContextModificationFailure");
            e
        })
    }
}
// MulticastContextNotificationIndication
#[derive(Clone, Debug)]
pub struct MulticastContextNotificationIndication {
    pub gnb_cu_mbs_f1ap_id: GnbCuMbsF1apId,
    pub gnb_du_mbs_f1ap_id: GnbDuMbsF1apId,
    pub multicast_du_2_cu_rrc_info: Option<MulticastDu2CuRrcInfo>,
}

impl MulticastContextNotificationIndication {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let _ = decode::decode_sequence_header(data, true, 0)?;
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut gnb_cu_mbs_f1ap_id: Option<GnbCuMbsF1apId> = None;
        let mut gnb_du_mbs_f1ap_id: Option<GnbDuMbsF1apId> = None;
        let mut multicast_du_2_cu_rrc_info: Option<MulticastDu2CuRrcInfo> = None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                451 => gnb_cu_mbs_f1ap_id = Some(GnbCuMbsF1apId::decode(data)?),
                452 => gnb_du_mbs_f1ap_id = Some(GnbDuMbsF1apId::decode(data)?),
                772 => multicast_du_2_cu_rrc_info = Some(MulticastDu2CuRrcInfo::decode(data)?),
                x => return Err(per_codec_error_new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        let gnb_cu_mbs_f1ap_id = gnb_cu_mbs_f1ap_id.ok_or(per_codec_error_new(format!(
            "Missing mandatory IE gnb_cu_mbs_f1ap_id"
        )))?;
        let gnb_du_mbs_f1ap_id = gnb_du_mbs_f1ap_id.ok_or(per_codec_error_new(format!(
            "Missing mandatory IE gnb_du_mbs_f1ap_id"
        )))?;
        Ok(Self {
            gnb_cu_mbs_f1ap_id,
            gnb_du_mbs_f1ap_id,
            multicast_du_2_cu_rrc_info,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        let ie = &mut Allocator::new_codec_data();
        self.gnb_cu_mbs_f1ap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 451, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.gnb_du_mbs_f1ap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 452, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        if let Some(x) = &self.multicast_du_2_cu_rrc_info {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 772, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        encode::encode_sequence_header(data, true, &BitString::new(), false)?;
        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for MulticastContextNotificationIndication {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        MulticastContextNotificationIndication::decode_inner(data).map_err(
            |mut e: PerCodecError| {
                e.push_context("MulticastContextNotificationIndication");
                e
            },
        )
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MulticastContextNotificationIndication");
            e
        })
    }
}
// MulticastContextNotificationConfirm
#[derive(Clone, Debug)]
pub struct MulticastContextNotificationConfirm {
    pub gnb_cu_mbs_f1ap_id: GnbCuMbsF1apId,
    pub gnb_du_mbs_f1ap_id: GnbDuMbsF1apId,
    pub criticality_diagnostics: Option<CriticalityDiagnostics>,
}

impl MulticastContextNotificationConfirm {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let _ = decode::decode_sequence_header(data, true, 0)?;
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut gnb_cu_mbs_f1ap_id: Option<GnbCuMbsF1apId> = None;
        let mut gnb_du_mbs_f1ap_id: Option<GnbDuMbsF1apId> = None;
        let mut criticality_diagnostics: Option<CriticalityDiagnostics> = None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                451 => gnb_cu_mbs_f1ap_id = Some(GnbCuMbsF1apId::decode(data)?),
                452 => gnb_du_mbs_f1ap_id = Some(GnbDuMbsF1apId::decode(data)?),
                7 => criticality_diagnostics = Some(CriticalityDiagnostics::decode(data)?),
                x => return Err(per_codec_error_new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        let gnb_cu_mbs_f1ap_id = gnb_cu_mbs_f1ap_id.ok_or(per_codec_error_new(format!(
            "Missing mandatory IE gnb_cu_mbs_f1ap_id"
        )))?;
        let gnb_du_mbs_f1ap_id = gnb_du_mbs_f1ap_id.ok_or(per_codec_error_new(format!(
            "Missing mandatory IE gnb_du_mbs_f1ap_id"
        )))?;
        Ok(Self {
            gnb_cu_mbs_f1ap_id,
            gnb_du_mbs_f1ap_id,
            criticality_diagnostics,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        let ie = &mut Allocator::new_codec_data();
        self.gnb_cu_mbs_f1ap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 451, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.gnb_du_mbs_f1ap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 452, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        if let Some(x) = &self.criticality_diagnostics {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 7, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        encode::encode_sequence_header(data, true, &BitString::new(), false)?;
        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for MulticastContextNotificationConfirm {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        MulticastContextNotificationConfirm::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MulticastContextNotificationConfirm");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MulticastContextNotificationConfirm");
            e
        })
    }
}
// MulticastContextNotificationRefuse
#[derive(Clone, Debug)]
pub struct MulticastContextNotificationRefuse {
    pub gnb_cu_mbs_f1ap_id: GnbCuMbsF1apId,
    pub gnb_du_mbs_f1ap_id: GnbDuMbsF1apId,
    pub criticality_diagnostics: Option<CriticalityDiagnostics>,
    pub cause: Cause,
}

impl MulticastContextNotificationRefuse {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let _ = decode::decode_sequence_header(data, true, 0)?;
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut gnb_cu_mbs_f1ap_id: Option<GnbCuMbsF1apId> = None;
        let mut gnb_du_mbs_f1ap_id: Option<GnbDuMbsF1apId> = None;
        let mut criticality_diagnostics: Option<CriticalityDiagnostics> = None;
        let mut cause: Option<Cause> = None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                451 => gnb_cu_mbs_f1ap_id = Some(GnbCuMbsF1apId::decode(data)?),
                452 => gnb_du_mbs_f1ap_id = Some(GnbDuMbsF1apId::decode(data)?),
                7 => criticality_diagnostics = Some(CriticalityDiagnostics::decode(data)?),
                0 => cause = Some(Cause::decode(data)?),
                x => return Err(per_codec_error_new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        let gnb_cu_mbs_f1ap_id = gnb_cu_mbs_f1ap_id.ok_or(per_codec_error_new(format!(
            "Missing mandatory IE gnb_cu_mbs_f1ap_id"
        )))?;
        let gnb_du_mbs_f1ap_id = gnb_du_mbs_f1ap_id.ok_or(per_codec_error_new(format!(
            "Missing mandatory IE gnb_du_mbs_f1ap_id"
        )))?;
        let cause = cause.ok_or(per_codec_error_new(format!("Missing mandatory IE cause")))?;
        Ok(Self {
            gnb_cu_mbs_f1ap_id,
            gnb_du_mbs_f1ap_id,
            criticality_diagnostics,
            cause,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        let ie = &mut Allocator::new_codec_data();
        self.gnb_cu_mbs_f1ap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 451, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.gnb_du_mbs_f1ap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 452, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        if let Some(x) = &self.criticality_diagnostics {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 7, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        let ie = &mut Allocator::new_codec_data();
        self.cause.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 0, false)?;
        Criticality::Ignore.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        encode::encode_sequence_header(data, true, &BitString::new(), false)?;
        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for MulticastContextNotificationRefuse {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        MulticastContextNotificationRefuse::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MulticastContextNotificationRefuse");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MulticastContextNotificationRefuse");
            e
        })
    }
}
// MulticastCommonConfigurationRequest
#[derive(Clone, Debug)]
pub struct MulticastCommonConfigurationRequest {
    pub transaction_id: TransactionId,
    pub multicast_cu_2_du_common_rrc_info: Option<MulticastCu2DuCommonRrcInfo>,
}

impl MulticastCommonConfigurationRequest {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let _ = decode::decode_sequence_header(data, true, 0)?;
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut transaction_id: Option<TransactionId> = None;
        let mut multicast_cu_2_du_common_rrc_info: Option<MulticastCu2DuCommonRrcInfo> = None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                78 => transaction_id = Some(TransactionId::decode(data)?),
                774 => {
                    multicast_cu_2_du_common_rrc_info =
                        Some(MulticastCu2DuCommonRrcInfo::decode(data)?)
                }
                x => return Err(per_codec_error_new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        let transaction_id = transaction_id.ok_or(per_codec_error_new(format!(
            "Missing mandatory IE transaction_id"
        )))?;
        Ok(Self {
            transaction_id,
            multicast_cu_2_du_common_rrc_info,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        let ie = &mut Allocator::new_codec_data();
        self.transaction_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 78, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        if let Some(x) = &self.multicast_cu_2_du_common_rrc_info {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 774, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        encode::encode_sequence_header(data, true, &BitString::new(), false)?;
        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for MulticastCommonConfigurationRequest {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        MulticastCommonConfigurationRequest::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MulticastCommonConfigurationRequest");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MulticastCommonConfigurationRequest");
            e
        })
    }
}
// MulticastCommonConfigurationResponse
#[derive(Clone, Debug)]
pub struct MulticastCommonConfigurationResponse {
    pub transaction_id: TransactionId,
    pub criticality_diagnostics: Option<CriticalityDiagnostics>,
}

impl MulticastCommonConfigurationResponse {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let _ = decode::decode_sequence_header(data, true, 0)?;
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut transaction_id: Option<TransactionId> = None;
        let mut criticality_diagnostics: Option<CriticalityDiagnostics> = None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                78 => transaction_id = Some(TransactionId::decode(data)?),
                7 => criticality_diagnostics = Some(CriticalityDiagnostics::decode(data)?),
                x => return Err(per_codec_error_new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        let transaction_id = transaction_id.ok_or(per_codec_error_new(format!(
            "Missing mandatory IE transaction_id"
        )))?;
        Ok(Self {
            transaction_id,
            criticality_diagnostics,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        let ie = &mut Allocator::new_codec_data();
        self.transaction_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 78, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        if let Some(x) = &self.criticality_diagnostics {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 7, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        encode::encode_sequence_header(data, true, &BitString::new(), false)?;
        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for MulticastCommonConfigurationResponse {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        MulticastCommonConfigurationResponse::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MulticastCommonConfigurationResponse");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MulticastCommonConfigurationResponse");
            e
        })
    }
}
// MulticastCommonConfigurationRefuse
#[derive(Clone, Debug)]
pub struct MulticastCommonConfigurationRefuse {
    pub transaction_id: TransactionId,
    pub cause: Cause,
    pub criticality_diagnostics: Option<CriticalityDiagnostics>,
}

impl MulticastCommonConfigurationRefuse {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let _ = decode::decode_sequence_header(data, true, 0)?;
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut transaction_id: Option<TransactionId> = None;
        let mut cause: Option<Cause> = None;
        let mut criticality_diagnostics: Option<CriticalityDiagnostics> = None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                78 => transaction_id = Some(TransactionId::decode(data)?),
                0 => cause = Some(Cause::decode(data)?),
                7 => criticality_diagnostics = Some(CriticalityDiagnostics::decode(data)?),
                x => return Err(per_codec_error_new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        let transaction_id = transaction_id.ok_or(per_codec_error_new(format!(
            "Missing mandatory IE transaction_id"
        )))?;
        let cause = cause.ok_or(per_codec_error_new(format!("Missing mandatory IE cause")))?;
        Ok(Self {
            transaction_id,
            cause,
            criticality_diagnostics,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        let ie = &mut Allocator::new_codec_data();
        self.transaction_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 78, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.cause.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 0, false)?;
        Criticality::Ignore.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        if let Some(x) = &self.criticality_diagnostics {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 7, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        encode::encode_sequence_header(data, true, &BitString::new(), false)?;
        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for MulticastCommonConfigurationRefuse {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        MulticastCommonConfigurationRefuse::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MulticastCommonConfigurationRefuse");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MulticastCommonConfigurationRefuse");
            e
        })
    }
}
// MulticastDistributionSetupRequest
#[derive(Clone, Debug)]
pub struct MulticastDistributionSetupRequest {
    pub gnb_cu_mbs_f1ap_id: GnbCuMbsF1apId,
    pub gnb_du_mbs_f1ap_id: GnbDuMbsF1apId,
    pub mbs_multicast_f1u_context_descriptor: MbsMulticastF1uContextDescriptor,
    pub multicast_f1u_context_to_be_setup_list: MulticastF1uContextToBeSetupList,
}

impl MulticastDistributionSetupRequest {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let _ = decode::decode_sequence_header(data, true, 0)?;
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut gnb_cu_mbs_f1ap_id: Option<GnbCuMbsF1apId> = None;
        let mut gnb_du_mbs_f1ap_id: Option<GnbDuMbsF1apId> = None;
        let mut mbs_multicast_f1u_context_descriptor: Option<MbsMulticastF1uContextDescriptor> =
            None;
        let mut multicast_f1u_context_to_be_setup_list: Option<MulticastF1uContextToBeSetupList> =
            None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                451 => gnb_cu_mbs_f1ap_id = Some(GnbCuMbsF1apId::decode(data)?),
                452 => gnb_du_mbs_f1ap_id = Some(GnbDuMbsF1apId::decode(data)?),
                502 => {
                    mbs_multicast_f1u_context_descriptor =
                        Some(MbsMulticastF1uContextDescriptor::decode(data)?)
                }
                503 => {
                    multicast_f1u_context_to_be_setup_list =
                        Some(MulticastF1uContextToBeSetupList::decode(data)?)
                }
                x => return Err(per_codec_error_new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        let gnb_cu_mbs_f1ap_id = gnb_cu_mbs_f1ap_id.ok_or(per_codec_error_new(format!(
            "Missing mandatory IE gnb_cu_mbs_f1ap_id"
        )))?;
        let gnb_du_mbs_f1ap_id = gnb_du_mbs_f1ap_id.ok_or(per_codec_error_new(format!(
            "Missing mandatory IE gnb_du_mbs_f1ap_id"
        )))?;
        let mbs_multicast_f1u_context_descriptor =
            mbs_multicast_f1u_context_descriptor.ok_or(per_codec_error_new(format!(
                "Missing mandatory IE mbs_multicast_f1u_context_descriptor"
            )))?;
        let multicast_f1u_context_to_be_setup_list =
            multicast_f1u_context_to_be_setup_list.ok_or(per_codec_error_new(format!(
                "Missing mandatory IE multicast_f1u_context_to_be_setup_list"
            )))?;
        Ok(Self {
            gnb_cu_mbs_f1ap_id,
            gnb_du_mbs_f1ap_id,
            mbs_multicast_f1u_context_descriptor,
            multicast_f1u_context_to_be_setup_list,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        let ie = &mut Allocator::new_codec_data();
        self.gnb_cu_mbs_f1ap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 451, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.gnb_du_mbs_f1ap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 452, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.mbs_multicast_f1u_context_descriptor.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 502, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.multicast_f1u_context_to_be_setup_list.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 503, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        encode::encode_sequence_header(data, true, &BitString::new(), false)?;
        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for MulticastDistributionSetupRequest {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        MulticastDistributionSetupRequest::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MulticastDistributionSetupRequest");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MulticastDistributionSetupRequest");
            e
        })
    }
}
// MulticastF1uContextToBeSetupList
#[derive(Clone, Debug)]
pub struct MulticastF1uContextToBeSetupList(pub NonEmpty<MulticastF1uContextToBeSetupItem>);

impl MulticastF1uContextToBeSetupList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(32), false)?;
            let mut items = vec![];
            for _ in 0..length {
                let _ = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _ = Criticality::decode(data)?;
                let _ = decode::decode_length_determinent(data, None, None, false)?;
                items.push(MulticastF1uContextToBeSetupItem::decode(data)?);
                data.decode_align()?;
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(32), false, self.0.len())?;
        for x in &self.0 {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(data, Some(0), Some(65535), false, 504, false)?;
            Criticality::Reject.encode(data)?;
            encode::encode_length_determinent(data, None, None, false, ie.length_in_bytes())?;
            data.append_aligned(ie);
        }
        Ok(())
    }
}

impl PerCodec for MulticastF1uContextToBeSetupList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        MulticastF1uContextToBeSetupList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MulticastF1uContextToBeSetupList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MulticastF1uContextToBeSetupList");
            e
        })
    }
}
// MulticastDistributionSetupResponse
#[derive(Clone, Debug)]
pub struct MulticastDistributionSetupResponse {
    pub gnb_cu_mbs_f1ap_id: GnbCuMbsF1apId,
    pub gnb_du_mbs_f1ap_id: GnbDuMbsF1apId,
    pub mbs_multicast_f1u_context_descriptor: MbsMulticastF1uContextDescriptor,
    pub multicast_f1u_context_setup_list: MulticastF1uContextSetupList,
    pub multicast_f1u_context_failed_to_be_setup_list:
        Option<MulticastF1uContextFailedToBeSetupList>,
    pub criticality_diagnostics: Option<CriticalityDiagnostics>,
    pub multicast_f1u_context_reference_cu: MulticastF1uContextReferenceCu,
}

impl MulticastDistributionSetupResponse {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let _ = decode::decode_sequence_header(data, true, 0)?;
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut gnb_cu_mbs_f1ap_id: Option<GnbCuMbsF1apId> = None;
        let mut gnb_du_mbs_f1ap_id: Option<GnbDuMbsF1apId> = None;
        let mut mbs_multicast_f1u_context_descriptor: Option<MbsMulticastF1uContextDescriptor> =
            None;
        let mut multicast_f1u_context_setup_list: Option<MulticastF1uContextSetupList> = None;
        let mut multicast_f1u_context_failed_to_be_setup_list: Option<
            MulticastF1uContextFailedToBeSetupList,
        > = None;
        let mut criticality_diagnostics: Option<CriticalityDiagnostics> = None;
        let mut multicast_f1u_context_reference_cu: Option<MulticastF1uContextReferenceCu> = None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                451 => gnb_cu_mbs_f1ap_id = Some(GnbCuMbsF1apId::decode(data)?),
                452 => gnb_du_mbs_f1ap_id = Some(GnbDuMbsF1apId::decode(data)?),
                502 => {
                    mbs_multicast_f1u_context_descriptor =
                        Some(MbsMulticastF1uContextDescriptor::decode(data)?)
                }
                505 => {
                    multicast_f1u_context_setup_list =
                        Some(MulticastF1uContextSetupList::decode(data)?)
                }
                507 => {
                    multicast_f1u_context_failed_to_be_setup_list =
                        Some(MulticastF1uContextFailedToBeSetupList::decode(data)?)
                }
                7 => criticality_diagnostics = Some(CriticalityDiagnostics::decode(data)?),
                681 => {
                    multicast_f1u_context_reference_cu =
                        Some(MulticastF1uContextReferenceCu::decode(data)?)
                }
                x => return Err(per_codec_error_new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        let gnb_cu_mbs_f1ap_id = gnb_cu_mbs_f1ap_id.ok_or(per_codec_error_new(format!(
            "Missing mandatory IE gnb_cu_mbs_f1ap_id"
        )))?;
        let gnb_du_mbs_f1ap_id = gnb_du_mbs_f1ap_id.ok_or(per_codec_error_new(format!(
            "Missing mandatory IE gnb_du_mbs_f1ap_id"
        )))?;
        let mbs_multicast_f1u_context_descriptor =
            mbs_multicast_f1u_context_descriptor.ok_or(per_codec_error_new(format!(
                "Missing mandatory IE mbs_multicast_f1u_context_descriptor"
            )))?;
        let multicast_f1u_context_setup_list =
            multicast_f1u_context_setup_list.ok_or(per_codec_error_new(format!(
                "Missing mandatory IE multicast_f1u_context_setup_list"
            )))?;
        let multicast_f1u_context_reference_cu =
            multicast_f1u_context_reference_cu.ok_or(per_codec_error_new(format!(
                "Missing mandatory IE multicast_f1u_context_reference_cu"
            )))?;
        Ok(Self {
            gnb_cu_mbs_f1ap_id,
            gnb_du_mbs_f1ap_id,
            mbs_multicast_f1u_context_descriptor,
            multicast_f1u_context_setup_list,
            multicast_f1u_context_failed_to_be_setup_list,
            criticality_diagnostics,
            multicast_f1u_context_reference_cu,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        let ie = &mut Allocator::new_codec_data();
        self.gnb_cu_mbs_f1ap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 451, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.gnb_du_mbs_f1ap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 452, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.mbs_multicast_f1u_context_descriptor.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 502, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.multicast_f1u_context_setup_list.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 505, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        if let Some(x) = &self.multicast_f1u_context_failed_to_be_setup_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 507, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.criticality_diagnostics {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 7, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        let ie = &mut Allocator::new_codec_data();
        self.multicast_f1u_context_reference_cu.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 681, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        encode::encode_sequence_header(data, true, &BitString::new(), false)?;
        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for MulticastDistributionSetupResponse {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        MulticastDistributionSetupResponse::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MulticastDistributionSetupResponse");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MulticastDistributionSetupResponse");
            e
        })
    }
}
// MulticastF1uContextSetupList
#[derive(Clone, Debug)]
pub struct MulticastF1uContextSetupList(pub NonEmpty<MulticastF1uContextSetupItem>);

impl MulticastF1uContextSetupList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(32), false)?;
            let mut items = vec![];
            for _ in 0..length {
                let _ = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _ = Criticality::decode(data)?;
                let _ = decode::decode_length_determinent(data, None, None, false)?;
                items.push(MulticastF1uContextSetupItem::decode(data)?);
                data.decode_align()?;
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(32), false, self.0.len())?;
        for x in &self.0 {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(data, Some(0), Some(65535), false, 506, false)?;
            Criticality::Reject.encode(data)?;
            encode::encode_length_determinent(data, None, None, false, ie.length_in_bytes())?;
            data.append_aligned(ie);
        }
        Ok(())
    }
}

impl PerCodec for MulticastF1uContextSetupList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        MulticastF1uContextSetupList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MulticastF1uContextSetupList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MulticastF1uContextSetupList");
            e
        })
    }
}
// MulticastF1uContextFailedToBeSetupList
#[derive(Clone, Debug)]
pub struct MulticastF1uContextFailedToBeSetupList(
    pub NonEmpty<MulticastF1uContextFailedToBeSetupItem>,
);

impl MulticastF1uContextFailedToBeSetupList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(32), false)?;
            let mut items = vec![];
            for _ in 0..length {
                let _ = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _ = Criticality::decode(data)?;
                let _ = decode::decode_length_determinent(data, None, None, false)?;
                items.push(MulticastF1uContextFailedToBeSetupItem::decode(data)?);
                data.decode_align()?;
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(32), false, self.0.len())?;
        for x in &self.0 {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(data, Some(0), Some(65535), false, 508, false)?;
            Criticality::Ignore.encode(data)?;
            encode::encode_length_determinent(data, None, None, false, ie.length_in_bytes())?;
            data.append_aligned(ie);
        }
        Ok(())
    }
}

impl PerCodec for MulticastF1uContextFailedToBeSetupList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        MulticastF1uContextFailedToBeSetupList::decode_inner(data).map_err(
            |mut e: PerCodecError| {
                e.push_context("MulticastF1uContextFailedToBeSetupList");
                e
            },
        )
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MulticastF1uContextFailedToBeSetupList");
            e
        })
    }
}
// MulticastDistributionSetupFailure
#[derive(Clone, Debug)]
pub struct MulticastDistributionSetupFailure {
    pub gnb_cu_mbs_f1ap_id: GnbCuMbsF1apId,
    pub gnb_du_mbs_f1ap_id: Option<GnbDuMbsF1apId>,
    pub mbs_multicast_f1u_context_descriptor: MbsMulticastF1uContextDescriptor,
    pub cause: Cause,
    pub criticality_diagnostics: Option<CriticalityDiagnostics>,
}

impl MulticastDistributionSetupFailure {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let _ = decode::decode_sequence_header(data, true, 0)?;
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut gnb_cu_mbs_f1ap_id: Option<GnbCuMbsF1apId> = None;
        let mut gnb_du_mbs_f1ap_id: Option<GnbDuMbsF1apId> = None;
        let mut mbs_multicast_f1u_context_descriptor: Option<MbsMulticastF1uContextDescriptor> =
            None;
        let mut cause: Option<Cause> = None;
        let mut criticality_diagnostics: Option<CriticalityDiagnostics> = None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                451 => gnb_cu_mbs_f1ap_id = Some(GnbCuMbsF1apId::decode(data)?),
                452 => gnb_du_mbs_f1ap_id = Some(GnbDuMbsF1apId::decode(data)?),
                502 => {
                    mbs_multicast_f1u_context_descriptor =
                        Some(MbsMulticastF1uContextDescriptor::decode(data)?)
                }
                0 => cause = Some(Cause::decode(data)?),
                7 => criticality_diagnostics = Some(CriticalityDiagnostics::decode(data)?),
                x => return Err(per_codec_error_new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        let gnb_cu_mbs_f1ap_id = gnb_cu_mbs_f1ap_id.ok_or(per_codec_error_new(format!(
            "Missing mandatory IE gnb_cu_mbs_f1ap_id"
        )))?;
        let mbs_multicast_f1u_context_descriptor =
            mbs_multicast_f1u_context_descriptor.ok_or(per_codec_error_new(format!(
                "Missing mandatory IE mbs_multicast_f1u_context_descriptor"
            )))?;
        let cause = cause.ok_or(per_codec_error_new(format!("Missing mandatory IE cause")))?;
        Ok(Self {
            gnb_cu_mbs_f1ap_id,
            gnb_du_mbs_f1ap_id,
            mbs_multicast_f1u_context_descriptor,
            cause,
            criticality_diagnostics,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        let ie = &mut Allocator::new_codec_data();
        self.gnb_cu_mbs_f1ap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 451, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        if let Some(x) = &self.gnb_du_mbs_f1ap_id {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 452, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        let ie = &mut Allocator::new_codec_data();
        self.mbs_multicast_f1u_context_descriptor.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 502, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.cause.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 0, false)?;
        Criticality::Ignore.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        if let Some(x) = &self.criticality_diagnostics {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 7, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        encode::encode_sequence_header(data, true, &BitString::new(), false)?;
        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for MulticastDistributionSetupFailure {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        MulticastDistributionSetupFailure::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MulticastDistributionSetupFailure");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MulticastDistributionSetupFailure");
            e
        })
    }
}
// MulticastDistributionReleaseCommand
#[derive(Clone, Debug)]
pub struct MulticastDistributionReleaseCommand {
    pub gnb_cu_mbs_f1ap_id: GnbCuMbsF1apId,
    pub gnb_du_mbs_f1ap_id: GnbDuMbsF1apId,
    pub mbs_multicast_f1u_context_descriptor: MbsMulticastF1uContextDescriptor,
    pub cause: Cause,
}

impl MulticastDistributionReleaseCommand {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let _ = decode::decode_sequence_header(data, true, 0)?;
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut gnb_cu_mbs_f1ap_id: Option<GnbCuMbsF1apId> = None;
        let mut gnb_du_mbs_f1ap_id: Option<GnbDuMbsF1apId> = None;
        let mut mbs_multicast_f1u_context_descriptor: Option<MbsMulticastF1uContextDescriptor> =
            None;
        let mut cause: Option<Cause> = None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                451 => gnb_cu_mbs_f1ap_id = Some(GnbCuMbsF1apId::decode(data)?),
                452 => gnb_du_mbs_f1ap_id = Some(GnbDuMbsF1apId::decode(data)?),
                502 => {
                    mbs_multicast_f1u_context_descriptor =
                        Some(MbsMulticastF1uContextDescriptor::decode(data)?)
                }
                0 => cause = Some(Cause::decode(data)?),
                x => return Err(per_codec_error_new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        let gnb_cu_mbs_f1ap_id = gnb_cu_mbs_f1ap_id.ok_or(per_codec_error_new(format!(
            "Missing mandatory IE gnb_cu_mbs_f1ap_id"
        )))?;
        let gnb_du_mbs_f1ap_id = gnb_du_mbs_f1ap_id.ok_or(per_codec_error_new(format!(
            "Missing mandatory IE gnb_du_mbs_f1ap_id"
        )))?;
        let mbs_multicast_f1u_context_descriptor =
            mbs_multicast_f1u_context_descriptor.ok_or(per_codec_error_new(format!(
                "Missing mandatory IE mbs_multicast_f1u_context_descriptor"
            )))?;
        let cause = cause.ok_or(per_codec_error_new(format!("Missing mandatory IE cause")))?;
        Ok(Self {
            gnb_cu_mbs_f1ap_id,
            gnb_du_mbs_f1ap_id,
            mbs_multicast_f1u_context_descriptor,
            cause,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        let ie = &mut Allocator::new_codec_data();
        self.gnb_cu_mbs_f1ap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 451, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.gnb_du_mbs_f1ap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 452, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.mbs_multicast_f1u_context_descriptor.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 502, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.cause.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 0, false)?;
        Criticality::Ignore.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        encode::encode_sequence_header(data, true, &BitString::new(), false)?;
        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for MulticastDistributionReleaseCommand {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        MulticastDistributionReleaseCommand::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MulticastDistributionReleaseCommand");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MulticastDistributionReleaseCommand");
            e
        })
    }
}
// MulticastDistributionReleaseComplete
#[derive(Clone, Debug)]
pub struct MulticastDistributionReleaseComplete {
    pub gnb_cu_mbs_f1ap_id: GnbCuMbsF1apId,
    pub gnb_du_mbs_f1ap_id: GnbDuMbsF1apId,
    pub mbs_multicast_f1u_context_descriptor: MbsMulticastF1uContextDescriptor,
    pub criticality_diagnostics: Option<CriticalityDiagnostics>,
}

impl MulticastDistributionReleaseComplete {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let _ = decode::decode_sequence_header(data, true, 0)?;
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut gnb_cu_mbs_f1ap_id: Option<GnbCuMbsF1apId> = None;
        let mut gnb_du_mbs_f1ap_id: Option<GnbDuMbsF1apId> = None;
        let mut mbs_multicast_f1u_context_descriptor: Option<MbsMulticastF1uContextDescriptor> =
            None;
        let mut criticality_diagnostics: Option<CriticalityDiagnostics> = None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                451 => gnb_cu_mbs_f1ap_id = Some(GnbCuMbsF1apId::decode(data)?),
                452 => gnb_du_mbs_f1ap_id = Some(GnbDuMbsF1apId::decode(data)?),
                502 => {
                    mbs_multicast_f1u_context_descriptor =
                        Some(MbsMulticastF1uContextDescriptor::decode(data)?)
                }
                7 => criticality_diagnostics = Some(CriticalityDiagnostics::decode(data)?),
                x => return Err(per_codec_error_new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        let gnb_cu_mbs_f1ap_id = gnb_cu_mbs_f1ap_id.ok_or(per_codec_error_new(format!(
            "Missing mandatory IE gnb_cu_mbs_f1ap_id"
        )))?;
        let gnb_du_mbs_f1ap_id = gnb_du_mbs_f1ap_id.ok_or(per_codec_error_new(format!(
            "Missing mandatory IE gnb_du_mbs_f1ap_id"
        )))?;
        let mbs_multicast_f1u_context_descriptor =
            mbs_multicast_f1u_context_descriptor.ok_or(per_codec_error_new(format!(
                "Missing mandatory IE mbs_multicast_f1u_context_descriptor"
            )))?;
        Ok(Self {
            gnb_cu_mbs_f1ap_id,
            gnb_du_mbs_f1ap_id,
            mbs_multicast_f1u_context_descriptor,
            criticality_diagnostics,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        let ie = &mut Allocator::new_codec_data();
        self.gnb_cu_mbs_f1ap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 451, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.gnb_du_mbs_f1ap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 452, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.mbs_multicast_f1u_context_descriptor.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 502, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        if let Some(x) = &self.criticality_diagnostics {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 7, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        encode::encode_sequence_header(data, true, &BitString::new(), false)?;
        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for MulticastDistributionReleaseComplete {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        MulticastDistributionReleaseComplete::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MulticastDistributionReleaseComplete");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MulticastDistributionReleaseComplete");
            e
        })
    }
}
// PdcMeasurementInitiationRequest
#[derive(Clone, Debug)]
pub struct PdcMeasurementInitiationRequest {
    pub gnb_cu_ue_f1ap_id: GnbCuUeF1apId,
    pub gnb_du_ue_f1ap_id: GnbDuUeF1apId,
    pub ran_ue_pdc_meas_id: RanUePdcMeasId,
    pub pdc_report_type: PdcReportType,
    pub pdc_measurement_periodicity: Option<PdcMeasurementPeriodicity>,
    pub pdc_measurement_quantities: PdcMeasurementQuantities,
}

impl PdcMeasurementInitiationRequest {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let _ = decode::decode_sequence_header(data, true, 0)?;
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut gnb_cu_ue_f1ap_id: Option<GnbCuUeF1apId> = None;
        let mut gnb_du_ue_f1ap_id: Option<GnbDuUeF1apId> = None;
        let mut ran_ue_pdc_meas_id: Option<RanUePdcMeasId> = None;
        let mut pdc_report_type: Option<PdcReportType> = None;
        let mut pdc_measurement_periodicity: Option<PdcMeasurementPeriodicity> = None;
        let mut pdc_measurement_quantities: Option<PdcMeasurementQuantities> = None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                40 => gnb_cu_ue_f1ap_id = Some(GnbCuUeF1apId::decode(data)?),
                41 => gnb_du_ue_f1ap_id = Some(GnbDuUeF1apId::decode(data)?),
                546 => ran_ue_pdc_meas_id = Some(RanUePdcMeasId::decode(data)?),
                545 => pdc_report_type = Some(PdcReportType::decode(data)?),
                541 => pdc_measurement_periodicity = Some(PdcMeasurementPeriodicity::decode(data)?),
                542 => pdc_measurement_quantities = Some(PdcMeasurementQuantities::decode(data)?),
                x => return Err(per_codec_error_new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        let gnb_cu_ue_f1ap_id = gnb_cu_ue_f1ap_id.ok_or(per_codec_error_new(format!(
            "Missing mandatory IE gnb_cu_ue_f1ap_id"
        )))?;
        let gnb_du_ue_f1ap_id = gnb_du_ue_f1ap_id.ok_or(per_codec_error_new(format!(
            "Missing mandatory IE gnb_du_ue_f1ap_id"
        )))?;
        let ran_ue_pdc_meas_id = ran_ue_pdc_meas_id.ok_or(per_codec_error_new(format!(
            "Missing mandatory IE ran_ue_pdc_meas_id"
        )))?;
        let pdc_report_type = pdc_report_type.ok_or(per_codec_error_new(format!(
            "Missing mandatory IE pdc_report_type"
        )))?;
        let pdc_measurement_quantities = pdc_measurement_quantities.ok_or(per_codec_error_new(
            format!("Missing mandatory IE pdc_measurement_quantities"),
        ))?;
        Ok(Self {
            gnb_cu_ue_f1ap_id,
            gnb_du_ue_f1ap_id,
            ran_ue_pdc_meas_id,
            pdc_report_type,
            pdc_measurement_periodicity,
            pdc_measurement_quantities,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        let ie = &mut Allocator::new_codec_data();
        self.gnb_cu_ue_f1ap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 40, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.gnb_du_ue_f1ap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 41, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.ran_ue_pdc_meas_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 546, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.pdc_report_type.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 545, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        if let Some(x) = &self.pdc_measurement_periodicity {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 541, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        let ie = &mut Allocator::new_codec_data();
        self.pdc_measurement_quantities.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 542, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        encode::encode_sequence_header(data, true, &BitString::new(), false)?;
        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for PdcMeasurementInitiationRequest {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PdcMeasurementInitiationRequest::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PdcMeasurementInitiationRequest");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PdcMeasurementInitiationRequest");
            e
        })
    }
}
// PdcMeasurementInitiationResponse
#[derive(Clone, Debug)]
pub struct PdcMeasurementInitiationResponse {
    pub gnb_cu_ue_f1ap_id: GnbCuUeF1apId,
    pub gnb_du_ue_f1ap_id: GnbDuUeF1apId,
    pub ran_ue_pdc_meas_id: RanUePdcMeasId,
    pub pdc_measurement_result: Option<PdcMeasurementResult>,
    pub criticality_diagnostics: Option<CriticalityDiagnostics>,
}

impl PdcMeasurementInitiationResponse {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let _ = decode::decode_sequence_header(data, true, 0)?;
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut gnb_cu_ue_f1ap_id: Option<GnbCuUeF1apId> = None;
        let mut gnb_du_ue_f1ap_id: Option<GnbDuUeF1apId> = None;
        let mut ran_ue_pdc_meas_id: Option<RanUePdcMeasId> = None;
        let mut pdc_measurement_result: Option<PdcMeasurementResult> = None;
        let mut criticality_diagnostics: Option<CriticalityDiagnostics> = None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                40 => gnb_cu_ue_f1ap_id = Some(GnbCuUeF1apId::decode(data)?),
                41 => gnb_du_ue_f1ap_id = Some(GnbDuUeF1apId::decode(data)?),
                546 => ran_ue_pdc_meas_id = Some(RanUePdcMeasId::decode(data)?),
                544 => pdc_measurement_result = Some(PdcMeasurementResult::decode(data)?),
                7 => criticality_diagnostics = Some(CriticalityDiagnostics::decode(data)?),
                x => return Err(per_codec_error_new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        let gnb_cu_ue_f1ap_id = gnb_cu_ue_f1ap_id.ok_or(per_codec_error_new(format!(
            "Missing mandatory IE gnb_cu_ue_f1ap_id"
        )))?;
        let gnb_du_ue_f1ap_id = gnb_du_ue_f1ap_id.ok_or(per_codec_error_new(format!(
            "Missing mandatory IE gnb_du_ue_f1ap_id"
        )))?;
        let ran_ue_pdc_meas_id = ran_ue_pdc_meas_id.ok_or(per_codec_error_new(format!(
            "Missing mandatory IE ran_ue_pdc_meas_id"
        )))?;
        Ok(Self {
            gnb_cu_ue_f1ap_id,
            gnb_du_ue_f1ap_id,
            ran_ue_pdc_meas_id,
            pdc_measurement_result,
            criticality_diagnostics,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        let ie = &mut Allocator::new_codec_data();
        self.gnb_cu_ue_f1ap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 40, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.gnb_du_ue_f1ap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 41, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.ran_ue_pdc_meas_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 546, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        if let Some(x) = &self.pdc_measurement_result {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 544, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.criticality_diagnostics {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 7, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        encode::encode_sequence_header(data, true, &BitString::new(), false)?;
        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for PdcMeasurementInitiationResponse {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PdcMeasurementInitiationResponse::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PdcMeasurementInitiationResponse");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PdcMeasurementInitiationResponse");
            e
        })
    }
}
// PdcMeasurementInitiationFailure
#[derive(Clone, Debug)]
pub struct PdcMeasurementInitiationFailure {
    pub gnb_cu_ue_f1ap_id: GnbCuUeF1apId,
    pub gnb_du_ue_f1ap_id: GnbDuUeF1apId,
    pub ran_ue_pdc_meas_id: RanUePdcMeasId,
    pub cause: Cause,
    pub criticality_diagnostics: Option<CriticalityDiagnostics>,
}

impl PdcMeasurementInitiationFailure {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let _ = decode::decode_sequence_header(data, true, 0)?;
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut gnb_cu_ue_f1ap_id: Option<GnbCuUeF1apId> = None;
        let mut gnb_du_ue_f1ap_id: Option<GnbDuUeF1apId> = None;
        let mut ran_ue_pdc_meas_id: Option<RanUePdcMeasId> = None;
        let mut cause: Option<Cause> = None;
        let mut criticality_diagnostics: Option<CriticalityDiagnostics> = None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                40 => gnb_cu_ue_f1ap_id = Some(GnbCuUeF1apId::decode(data)?),
                41 => gnb_du_ue_f1ap_id = Some(GnbDuUeF1apId::decode(data)?),
                546 => ran_ue_pdc_meas_id = Some(RanUePdcMeasId::decode(data)?),
                0 => cause = Some(Cause::decode(data)?),
                7 => criticality_diagnostics = Some(CriticalityDiagnostics::decode(data)?),
                x => return Err(per_codec_error_new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        let gnb_cu_ue_f1ap_id = gnb_cu_ue_f1ap_id.ok_or(per_codec_error_new(format!(
            "Missing mandatory IE gnb_cu_ue_f1ap_id"
        )))?;
        let gnb_du_ue_f1ap_id = gnb_du_ue_f1ap_id.ok_or(per_codec_error_new(format!(
            "Missing mandatory IE gnb_du_ue_f1ap_id"
        )))?;
        let ran_ue_pdc_meas_id = ran_ue_pdc_meas_id.ok_or(per_codec_error_new(format!(
            "Missing mandatory IE ran_ue_pdc_meas_id"
        )))?;
        let cause = cause.ok_or(per_codec_error_new(format!("Missing mandatory IE cause")))?;
        Ok(Self {
            gnb_cu_ue_f1ap_id,
            gnb_du_ue_f1ap_id,
            ran_ue_pdc_meas_id,
            cause,
            criticality_diagnostics,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        let ie = &mut Allocator::new_codec_data();
        self.gnb_cu_ue_f1ap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 40, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.gnb_du_ue_f1ap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 41, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.ran_ue_pdc_meas_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 546, false)?;
        Criticality::Ignore.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.cause.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 0, false)?;
        Criticality::Ignore.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        if let Some(x) = &self.criticality_diagnostics {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 7, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        encode::encode_sequence_header(data, true, &BitString::new(), false)?;
        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for PdcMeasurementInitiationFailure {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PdcMeasurementInitiationFailure::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PdcMeasurementInitiationFailure");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PdcMeasurementInitiationFailure");
            e
        })
    }
}
// PdcMeasurementReport
#[derive(Clone, Debug)]
pub struct PdcMeasurementReport {
    pub gnb_cu_ue_f1ap_id: GnbCuUeF1apId,
    pub gnb_du_ue_f1ap_id: GnbDuUeF1apId,
    pub ran_ue_pdc_meas_id: RanUePdcMeasId,
    pub pdc_measurement_result: PdcMeasurementResult,
}

impl PdcMeasurementReport {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let _ = decode::decode_sequence_header(data, true, 0)?;
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut gnb_cu_ue_f1ap_id: Option<GnbCuUeF1apId> = None;
        let mut gnb_du_ue_f1ap_id: Option<GnbDuUeF1apId> = None;
        let mut ran_ue_pdc_meas_id: Option<RanUePdcMeasId> = None;
        let mut pdc_measurement_result: Option<PdcMeasurementResult> = None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                40 => gnb_cu_ue_f1ap_id = Some(GnbCuUeF1apId::decode(data)?),
                41 => gnb_du_ue_f1ap_id = Some(GnbDuUeF1apId::decode(data)?),
                546 => ran_ue_pdc_meas_id = Some(RanUePdcMeasId::decode(data)?),
                544 => pdc_measurement_result = Some(PdcMeasurementResult::decode(data)?),
                x => return Err(per_codec_error_new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        let gnb_cu_ue_f1ap_id = gnb_cu_ue_f1ap_id.ok_or(per_codec_error_new(format!(
            "Missing mandatory IE gnb_cu_ue_f1ap_id"
        )))?;
        let gnb_du_ue_f1ap_id = gnb_du_ue_f1ap_id.ok_or(per_codec_error_new(format!(
            "Missing mandatory IE gnb_du_ue_f1ap_id"
        )))?;
        let ran_ue_pdc_meas_id = ran_ue_pdc_meas_id.ok_or(per_codec_error_new(format!(
            "Missing mandatory IE ran_ue_pdc_meas_id"
        )))?;
        let pdc_measurement_result = pdc_measurement_result.ok_or(per_codec_error_new(format!(
            "Missing mandatory IE pdc_measurement_result"
        )))?;
        Ok(Self {
            gnb_cu_ue_f1ap_id,
            gnb_du_ue_f1ap_id,
            ran_ue_pdc_meas_id,
            pdc_measurement_result,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        let ie = &mut Allocator::new_codec_data();
        self.gnb_cu_ue_f1ap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 40, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.gnb_du_ue_f1ap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 41, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.ran_ue_pdc_meas_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 546, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.pdc_measurement_result.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 544, false)?;
        Criticality::Ignore.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        encode::encode_sequence_header(data, true, &BitString::new(), false)?;
        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for PdcMeasurementReport {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PdcMeasurementReport::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PdcMeasurementReport");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PdcMeasurementReport");
            e
        })
    }
}
// PdcMeasurementTerminationCommand
#[derive(Clone, Debug)]
pub struct PdcMeasurementTerminationCommand {
    pub gnb_cu_ue_f1ap_id: GnbCuUeF1apId,
    pub gnb_du_ue_f1ap_id: GnbDuUeF1apId,
    pub ran_ue_pdc_meas_id: RanUePdcMeasId,
}

impl PdcMeasurementTerminationCommand {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let _ = decode::decode_sequence_header(data, true, 0)?;
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut gnb_cu_ue_f1ap_id: Option<GnbCuUeF1apId> = None;
        let mut gnb_du_ue_f1ap_id: Option<GnbDuUeF1apId> = None;
        let mut ran_ue_pdc_meas_id: Option<RanUePdcMeasId> = None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                40 => gnb_cu_ue_f1ap_id = Some(GnbCuUeF1apId::decode(data)?),
                41 => gnb_du_ue_f1ap_id = Some(GnbDuUeF1apId::decode(data)?),
                546 => ran_ue_pdc_meas_id = Some(RanUePdcMeasId::decode(data)?),
                x => return Err(per_codec_error_new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        let gnb_cu_ue_f1ap_id = gnb_cu_ue_f1ap_id.ok_or(per_codec_error_new(format!(
            "Missing mandatory IE gnb_cu_ue_f1ap_id"
        )))?;
        let gnb_du_ue_f1ap_id = gnb_du_ue_f1ap_id.ok_or(per_codec_error_new(format!(
            "Missing mandatory IE gnb_du_ue_f1ap_id"
        )))?;
        let ran_ue_pdc_meas_id = ran_ue_pdc_meas_id.ok_or(per_codec_error_new(format!(
            "Missing mandatory IE ran_ue_pdc_meas_id"
        )))?;
        Ok(Self {
            gnb_cu_ue_f1ap_id,
            gnb_du_ue_f1ap_id,
            ran_ue_pdc_meas_id,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        let ie = &mut Allocator::new_codec_data();
        self.gnb_cu_ue_f1ap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 40, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.gnb_du_ue_f1ap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 41, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.ran_ue_pdc_meas_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 546, false)?;
        Criticality::Ignore.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        encode::encode_sequence_header(data, true, &BitString::new(), false)?;
        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for PdcMeasurementTerminationCommand {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PdcMeasurementTerminationCommand::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PdcMeasurementTerminationCommand");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PdcMeasurementTerminationCommand");
            e
        })
    }
}
// PdcMeasurementFailureIndication
#[derive(Clone, Debug)]
pub struct PdcMeasurementFailureIndication {
    pub gnb_cu_ue_f1ap_id: GnbCuUeF1apId,
    pub gnb_du_ue_f1ap_id: GnbDuUeF1apId,
    pub ran_ue_pdc_meas_id: RanUePdcMeasId,
    pub cause: Cause,
}

impl PdcMeasurementFailureIndication {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let _ = decode::decode_sequence_header(data, true, 0)?;
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut gnb_cu_ue_f1ap_id: Option<GnbCuUeF1apId> = None;
        let mut gnb_du_ue_f1ap_id: Option<GnbDuUeF1apId> = None;
        let mut ran_ue_pdc_meas_id: Option<RanUePdcMeasId> = None;
        let mut cause: Option<Cause> = None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                40 => gnb_cu_ue_f1ap_id = Some(GnbCuUeF1apId::decode(data)?),
                41 => gnb_du_ue_f1ap_id = Some(GnbDuUeF1apId::decode(data)?),
                546 => ran_ue_pdc_meas_id = Some(RanUePdcMeasId::decode(data)?),
                0 => cause = Some(Cause::decode(data)?),
                x => return Err(per_codec_error_new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        let gnb_cu_ue_f1ap_id = gnb_cu_ue_f1ap_id.ok_or(per_codec_error_new(format!(
            "Missing mandatory IE gnb_cu_ue_f1ap_id"
        )))?;
        let gnb_du_ue_f1ap_id = gnb_du_ue_f1ap_id.ok_or(per_codec_error_new(format!(
            "Missing mandatory IE gnb_du_ue_f1ap_id"
        )))?;
        let ran_ue_pdc_meas_id = ran_ue_pdc_meas_id.ok_or(per_codec_error_new(format!(
            "Missing mandatory IE ran_ue_pdc_meas_id"
        )))?;
        let cause = cause.ok_or(per_codec_error_new(format!("Missing mandatory IE cause")))?;
        Ok(Self {
            gnb_cu_ue_f1ap_id,
            gnb_du_ue_f1ap_id,
            ran_ue_pdc_meas_id,
            cause,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        let ie = &mut Allocator::new_codec_data();
        self.gnb_cu_ue_f1ap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 40, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.gnb_du_ue_f1ap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 41, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.ran_ue_pdc_meas_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 546, false)?;
        Criticality::Ignore.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.cause.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 0, false)?;
        Criticality::Ignore.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        encode::encode_sequence_header(data, true, &BitString::new(), false)?;
        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for PdcMeasurementFailureIndication {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PdcMeasurementFailureIndication::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PdcMeasurementFailureIndication");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PdcMeasurementFailureIndication");
            e
        })
    }
}
// PrsConfigurationRequest
#[derive(Clone, Debug)]
pub struct PrsConfigurationRequest {
    pub transaction_id: TransactionId,
    pub prs_config_request_type: PrsConfigRequestType,
    pub prstrp_list: PrstrpList,
}

impl PrsConfigurationRequest {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let _ = decode::decode_sequence_header(data, true, 0)?;
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut transaction_id: Option<TransactionId> = None;
        let mut prs_config_request_type: Option<PrsConfigRequestType> = None;
        let mut prstrp_list: Option<PrstrpList> = None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                78 => transaction_id = Some(TransactionId::decode(data)?),
                571 => prs_config_request_type = Some(PrsConfigRequestType::decode(data)?),
                549 => prstrp_list = Some(PrstrpList::decode(data)?),
                x => return Err(per_codec_error_new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        let transaction_id = transaction_id.ok_or(per_codec_error_new(format!(
            "Missing mandatory IE transaction_id"
        )))?;
        let prs_config_request_type = prs_config_request_type.ok_or(per_codec_error_new(
            format!("Missing mandatory IE prs_config_request_type"),
        ))?;
        let prstrp_list = prstrp_list.ok_or(per_codec_error_new(format!(
            "Missing mandatory IE prstrp_list"
        )))?;
        Ok(Self {
            transaction_id,
            prs_config_request_type,
            prstrp_list,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        let ie = &mut Allocator::new_codec_data();
        self.transaction_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 78, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.prs_config_request_type.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 571, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.prstrp_list.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 549, false)?;
        Criticality::Ignore.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        encode::encode_sequence_header(data, true, &BitString::new(), false)?;
        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for PrsConfigurationRequest {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PrsConfigurationRequest::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PrsConfigurationRequest");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PrsConfigurationRequest");
            e
        })
    }
}
// PrsConfigurationResponse
#[derive(Clone, Debug)]
pub struct PrsConfigurationResponse {
    pub transaction_id: TransactionId,
    pub prs_transmission_trp_list: Option<PrsTransmissionTrpList>,
    pub criticality_diagnostics: Option<CriticalityDiagnostics>,
}

impl PrsConfigurationResponse {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let _ = decode::decode_sequence_header(data, true, 0)?;
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut transaction_id: Option<TransactionId> = None;
        let mut prs_transmission_trp_list: Option<PrsTransmissionTrpList> = None;
        let mut criticality_diagnostics: Option<CriticalityDiagnostics> = None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                78 => transaction_id = Some(TransactionId::decode(data)?),
                550 => prs_transmission_trp_list = Some(PrsTransmissionTrpList::decode(data)?),
                7 => criticality_diagnostics = Some(CriticalityDiagnostics::decode(data)?),
                x => return Err(per_codec_error_new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        let transaction_id = transaction_id.ok_or(per_codec_error_new(format!(
            "Missing mandatory IE transaction_id"
        )))?;
        Ok(Self {
            transaction_id,
            prs_transmission_trp_list,
            criticality_diagnostics,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        let ie = &mut Allocator::new_codec_data();
        self.transaction_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 78, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        if let Some(x) = &self.prs_transmission_trp_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 550, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.criticality_diagnostics {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 7, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        encode::encode_sequence_header(data, true, &BitString::new(), false)?;
        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for PrsConfigurationResponse {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PrsConfigurationResponse::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PrsConfigurationResponse");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PrsConfigurationResponse");
            e
        })
    }
}
// PrsConfigurationFailure
#[derive(Clone, Debug)]
pub struct PrsConfigurationFailure {
    pub transaction_id: TransactionId,
    pub cause: Cause,
    pub criticality_diagnostics: Option<CriticalityDiagnostics>,
}

impl PrsConfigurationFailure {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let _ = decode::decode_sequence_header(data, true, 0)?;
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut transaction_id: Option<TransactionId> = None;
        let mut cause: Option<Cause> = None;
        let mut criticality_diagnostics: Option<CriticalityDiagnostics> = None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                78 => transaction_id = Some(TransactionId::decode(data)?),
                0 => cause = Some(Cause::decode(data)?),
                7 => criticality_diagnostics = Some(CriticalityDiagnostics::decode(data)?),
                x => return Err(per_codec_error_new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        let transaction_id = transaction_id.ok_or(per_codec_error_new(format!(
            "Missing mandatory IE transaction_id"
        )))?;
        let cause = cause.ok_or(per_codec_error_new(format!("Missing mandatory IE cause")))?;
        Ok(Self {
            transaction_id,
            cause,
            criticality_diagnostics,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        let ie = &mut Allocator::new_codec_data();
        self.transaction_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 78, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.cause.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 0, false)?;
        Criticality::Ignore.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        if let Some(x) = &self.criticality_diagnostics {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 7, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        encode::encode_sequence_header(data, true, &BitString::new(), false)?;
        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for PrsConfigurationFailure {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PrsConfigurationFailure::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PrsConfigurationFailure");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PrsConfigurationFailure");
            e
        })
    }
}
// MeasurementPreconfigurationRequired
#[derive(Clone, Debug)]
pub struct MeasurementPreconfigurationRequired {
    pub gnb_cu_ue_f1ap_id: GnbCuUeF1apId,
    pub gnb_du_ue_f1ap_id: GnbDuUeF1apId,
    pub trp_prs_info_list: TrpPrsInfoList,
}

impl MeasurementPreconfigurationRequired {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let _ = decode::decode_sequence_header(data, true, 0)?;
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut gnb_cu_ue_f1ap_id: Option<GnbCuUeF1apId> = None;
        let mut gnb_du_ue_f1ap_id: Option<GnbDuUeF1apId> = None;
        let mut trp_prs_info_list: Option<TrpPrsInfoList> = None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                40 => gnb_cu_ue_f1ap_id = Some(GnbCuUeF1apId::decode(data)?),
                41 => gnb_du_ue_f1ap_id = Some(GnbDuUeF1apId::decode(data)?),
                569 => trp_prs_info_list = Some(TrpPrsInfoList::decode(data)?),
                x => return Err(per_codec_error_new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        let gnb_cu_ue_f1ap_id = gnb_cu_ue_f1ap_id.ok_or(per_codec_error_new(format!(
            "Missing mandatory IE gnb_cu_ue_f1ap_id"
        )))?;
        let gnb_du_ue_f1ap_id = gnb_du_ue_f1ap_id.ok_or(per_codec_error_new(format!(
            "Missing mandatory IE gnb_du_ue_f1ap_id"
        )))?;
        let trp_prs_info_list = trp_prs_info_list.ok_or(per_codec_error_new(format!(
            "Missing mandatory IE trp_prs_info_list"
        )))?;
        Ok(Self {
            gnb_cu_ue_f1ap_id,
            gnb_du_ue_f1ap_id,
            trp_prs_info_list,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        let ie = &mut Allocator::new_codec_data();
        self.gnb_cu_ue_f1ap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 40, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.gnb_du_ue_f1ap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 41, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.trp_prs_info_list.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 569, false)?;
        Criticality::Ignore.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        encode::encode_sequence_header(data, true, &BitString::new(), false)?;
        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for MeasurementPreconfigurationRequired {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        MeasurementPreconfigurationRequired::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MeasurementPreconfigurationRequired");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MeasurementPreconfigurationRequired");
            e
        })
    }
}
// MeasurementPreconfigurationConfirm
#[derive(Clone, Debug)]
pub struct MeasurementPreconfigurationConfirm {
    pub gnb_cu_ue_f1ap_id: GnbCuUeF1apId,
    pub gnb_du_ue_f1ap_id: GnbDuUeF1apId,
    pub pos_meas_gap_pre_config_list: Option<PosMeasGapPreConfigList>,
    pub criticality_diagnostics: Option<CriticalityDiagnostics>,
}

impl MeasurementPreconfigurationConfirm {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let _ = decode::decode_sequence_header(data, true, 0)?;
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut gnb_cu_ue_f1ap_id: Option<GnbCuUeF1apId> = None;
        let mut gnb_du_ue_f1ap_id: Option<GnbDuUeF1apId> = None;
        let mut pos_meas_gap_pre_config_list: Option<PosMeasGapPreConfigList> = None;
        let mut criticality_diagnostics: Option<CriticalityDiagnostics> = None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                40 => gnb_cu_ue_f1ap_id = Some(GnbCuUeF1apId::decode(data)?),
                41 => gnb_du_ue_f1ap_id = Some(GnbDuUeF1apId::decode(data)?),
                650 => pos_meas_gap_pre_config_list = Some(PosMeasGapPreConfigList::decode(data)?),
                7 => criticality_diagnostics = Some(CriticalityDiagnostics::decode(data)?),
                x => return Err(per_codec_error_new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        let gnb_cu_ue_f1ap_id = gnb_cu_ue_f1ap_id.ok_or(per_codec_error_new(format!(
            "Missing mandatory IE gnb_cu_ue_f1ap_id"
        )))?;
        let gnb_du_ue_f1ap_id = gnb_du_ue_f1ap_id.ok_or(per_codec_error_new(format!(
            "Missing mandatory IE gnb_du_ue_f1ap_id"
        )))?;
        Ok(Self {
            gnb_cu_ue_f1ap_id,
            gnb_du_ue_f1ap_id,
            pos_meas_gap_pre_config_list,
            criticality_diagnostics,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        let ie = &mut Allocator::new_codec_data();
        self.gnb_cu_ue_f1ap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 40, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.gnb_du_ue_f1ap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 41, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        if let Some(x) = &self.pos_meas_gap_pre_config_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 650, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.criticality_diagnostics {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 7, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        encode::encode_sequence_header(data, true, &BitString::new(), false)?;
        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for MeasurementPreconfigurationConfirm {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        MeasurementPreconfigurationConfirm::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MeasurementPreconfigurationConfirm");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MeasurementPreconfigurationConfirm");
            e
        })
    }
}
// MeasurementPreconfigurationRefuse
#[derive(Clone, Debug)]
pub struct MeasurementPreconfigurationRefuse {
    pub gnb_cu_ue_f1ap_id: GnbCuUeF1apId,
    pub gnb_du_ue_f1ap_id: GnbDuUeF1apId,
    pub cause: Cause,
    pub criticality_diagnostics: Option<CriticalityDiagnostics>,
}

impl MeasurementPreconfigurationRefuse {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let _ = decode::decode_sequence_header(data, true, 0)?;
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut gnb_cu_ue_f1ap_id: Option<GnbCuUeF1apId> = None;
        let mut gnb_du_ue_f1ap_id: Option<GnbDuUeF1apId> = None;
        let mut cause: Option<Cause> = None;
        let mut criticality_diagnostics: Option<CriticalityDiagnostics> = None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                40 => gnb_cu_ue_f1ap_id = Some(GnbCuUeF1apId::decode(data)?),
                41 => gnb_du_ue_f1ap_id = Some(GnbDuUeF1apId::decode(data)?),
                0 => cause = Some(Cause::decode(data)?),
                7 => criticality_diagnostics = Some(CriticalityDiagnostics::decode(data)?),
                x => return Err(per_codec_error_new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        let gnb_cu_ue_f1ap_id = gnb_cu_ue_f1ap_id.ok_or(per_codec_error_new(format!(
            "Missing mandatory IE gnb_cu_ue_f1ap_id"
        )))?;
        let gnb_du_ue_f1ap_id = gnb_du_ue_f1ap_id.ok_or(per_codec_error_new(format!(
            "Missing mandatory IE gnb_du_ue_f1ap_id"
        )))?;
        let cause = cause.ok_or(per_codec_error_new(format!("Missing mandatory IE cause")))?;
        Ok(Self {
            gnb_cu_ue_f1ap_id,
            gnb_du_ue_f1ap_id,
            cause,
            criticality_diagnostics,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        let ie = &mut Allocator::new_codec_data();
        self.gnb_cu_ue_f1ap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 40, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.gnb_du_ue_f1ap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 41, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.cause.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 0, false)?;
        Criticality::Ignore.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        if let Some(x) = &self.criticality_diagnostics {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 7, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        encode::encode_sequence_header(data, true, &BitString::new(), false)?;
        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for MeasurementPreconfigurationRefuse {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        MeasurementPreconfigurationRefuse::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MeasurementPreconfigurationRefuse");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MeasurementPreconfigurationRefuse");
            e
        })
    }
}
// MeasurementActivation
#[derive(Clone, Debug)]
pub struct MeasurementActivation {
    pub gnb_cu_ue_f1ap_id: GnbCuUeF1apId,
    pub gnb_du_ue_f1ap_id: GnbDuUeF1apId,
    pub activation_request_type: ActivationRequestType,
    pub prs_measurement_info_list: Option<PrsMeasurementInfoList>,
}

impl MeasurementActivation {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let _ = decode::decode_sequence_header(data, true, 0)?;
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut gnb_cu_ue_f1ap_id: Option<GnbCuUeF1apId> = None;
        let mut gnb_du_ue_f1ap_id: Option<GnbDuUeF1apId> = None;
        let mut activation_request_type: Option<ActivationRequestType> = None;
        let mut prs_measurement_info_list: Option<PrsMeasurementInfoList> = None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                40 => gnb_cu_ue_f1ap_id = Some(GnbCuUeF1apId::decode(data)?),
                41 => gnb_du_ue_f1ap_id = Some(GnbDuUeF1apId::decode(data)?),
                649 => activation_request_type = Some(ActivationRequestType::decode(data)?),
                570 => prs_measurement_info_list = Some(PrsMeasurementInfoList::decode(data)?),
                x => return Err(per_codec_error_new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        let gnb_cu_ue_f1ap_id = gnb_cu_ue_f1ap_id.ok_or(per_codec_error_new(format!(
            "Missing mandatory IE gnb_cu_ue_f1ap_id"
        )))?;
        let gnb_du_ue_f1ap_id = gnb_du_ue_f1ap_id.ok_or(per_codec_error_new(format!(
            "Missing mandatory IE gnb_du_ue_f1ap_id"
        )))?;
        let activation_request_type = activation_request_type.ok_or(per_codec_error_new(
            format!("Missing mandatory IE activation_request_type"),
        ))?;
        Ok(Self {
            gnb_cu_ue_f1ap_id,
            gnb_du_ue_f1ap_id,
            activation_request_type,
            prs_measurement_info_list,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        let ie = &mut Allocator::new_codec_data();
        self.gnb_cu_ue_f1ap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 40, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.gnb_du_ue_f1ap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 41, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.activation_request_type.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 649, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        if let Some(x) = &self.prs_measurement_info_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 570, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        encode::encode_sequence_header(data, true, &BitString::new(), false)?;
        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for MeasurementActivation {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        MeasurementActivation::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MeasurementActivation");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MeasurementActivation");
            e
        })
    }
}
// QoEInformationTransfer
#[derive(Clone, Debug)]
pub struct QoEInformationTransfer {
    pub gnb_cu_ue_f1ap_id: GnbCuUeF1apId,
    pub gnb_du_ue_f1ap_id: GnbDuUeF1apId,
    pub qo_e_information: Option<QoEInformation>,
}

impl QoEInformationTransfer {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let _ = decode::decode_sequence_header(data, true, 0)?;
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut gnb_cu_ue_f1ap_id: Option<GnbCuUeF1apId> = None;
        let mut gnb_du_ue_f1ap_id: Option<GnbDuUeF1apId> = None;
        let mut qo_e_information: Option<QoEInformation> = None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                40 => gnb_cu_ue_f1ap_id = Some(GnbCuUeF1apId::decode(data)?),
                41 => gnb_du_ue_f1ap_id = Some(GnbDuUeF1apId::decode(data)?),
                585 => qo_e_information = Some(QoEInformation::decode(data)?),
                x => return Err(per_codec_error_new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        let gnb_cu_ue_f1ap_id = gnb_cu_ue_f1ap_id.ok_or(per_codec_error_new(format!(
            "Missing mandatory IE gnb_cu_ue_f1ap_id"
        )))?;
        let gnb_du_ue_f1ap_id = gnb_du_ue_f1ap_id.ok_or(per_codec_error_new(format!(
            "Missing mandatory IE gnb_du_ue_f1ap_id"
        )))?;
        Ok(Self {
            gnb_cu_ue_f1ap_id,
            gnb_du_ue_f1ap_id,
            qo_e_information,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        let ie = &mut Allocator::new_codec_data();
        self.gnb_cu_ue_f1ap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 40, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.gnb_du_ue_f1ap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 41, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        if let Some(x) = &self.qo_e_information {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 585, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        encode::encode_sequence_header(data, true, &BitString::new(), false)?;
        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for QoEInformationTransfer {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        QoEInformationTransfer::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("QoEInformationTransfer");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("QoEInformationTransfer");
            e
        })
    }
}
// PosSystemInformationDeliveryCommand
#[derive(Clone, Debug)]
pub struct PosSystemInformationDeliveryCommand {
    pub transaction_id: TransactionId,
    pub nr_cgi: NrCgi,
    pub pos_si_type_list: PosSiTypeList,
    pub confirmed_ue_id: GnbDuUeF1apId,
}

impl PosSystemInformationDeliveryCommand {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let _ = decode::decode_sequence_header(data, true, 0)?;
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut transaction_id: Option<TransactionId> = None;
        let mut nr_cgi: Option<NrCgi> = None;
        let mut pos_si_type_list: Option<PosSiTypeList> = None;
        let mut confirmed_ue_id: Option<GnbDuUeF1apId> = None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                78 => transaction_id = Some(TransactionId::decode(data)?),
                111 => nr_cgi = Some(NrCgi::decode(data)?),
                682 => pos_si_type_list = Some(PosSiTypeList::decode(data)?),
                156 => confirmed_ue_id = Some(GnbDuUeF1apId::decode(data)?),
                x => return Err(per_codec_error_new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        let transaction_id = transaction_id.ok_or(per_codec_error_new(format!(
            "Missing mandatory IE transaction_id"
        )))?;
        let nr_cgi = nr_cgi.ok_or(per_codec_error_new(format!("Missing mandatory IE nr_cgi")))?;
        let pos_si_type_list = pos_si_type_list.ok_or(per_codec_error_new(format!(
            "Missing mandatory IE pos_si_type_list"
        )))?;
        let confirmed_ue_id = confirmed_ue_id.ok_or(per_codec_error_new(format!(
            "Missing mandatory IE confirmed_ue_id"
        )))?;
        Ok(Self {
            transaction_id,
            nr_cgi,
            pos_si_type_list,
            confirmed_ue_id,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        let ie = &mut Allocator::new_codec_data();
        self.transaction_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 78, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.nr_cgi.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 111, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.pos_si_type_list.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 682, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.confirmed_ue_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 156, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        encode::encode_sequence_header(data, true, &BitString::new(), false)?;
        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for PosSystemInformationDeliveryCommand {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PosSystemInformationDeliveryCommand::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PosSystemInformationDeliveryCommand");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PosSystemInformationDeliveryCommand");
            e
        })
    }
}
// DuCuCellSwitchNotification
#[derive(Clone, Debug)]
pub struct DuCuCellSwitchNotification {
    pub gnb_cu_ue_f1ap_id: GnbCuUeF1apId,
    pub gnb_du_ue_f1ap_id: GnbDuUeF1apId,
    pub nr_cgi: NrCgi,
    pub ltm_cell_switch_information: Option<LtmCellSwitchInformation>,
    pub ta_information_list: Option<TaInformationList>,
}

impl DuCuCellSwitchNotification {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let _ = decode::decode_sequence_header(data, true, 0)?;
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut gnb_cu_ue_f1ap_id: Option<GnbCuUeF1apId> = None;
        let mut gnb_du_ue_f1ap_id: Option<GnbDuUeF1apId> = None;
        let mut nr_cgi: Option<NrCgi> = None;
        let mut ltm_cell_switch_information: Option<LtmCellSwitchInformation> = None;
        let mut ta_information_list: Option<TaInformationList> = None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                40 => gnb_cu_ue_f1ap_id = Some(GnbCuUeF1apId::decode(data)?),
                41 => gnb_du_ue_f1ap_id = Some(GnbDuUeF1apId::decode(data)?),
                111 => nr_cgi = Some(NrCgi::decode(data)?),
                729 => ltm_cell_switch_information = Some(LtmCellSwitchInformation::decode(data)?),
                837 => ta_information_list = Some(TaInformationList::decode(data)?),
                x => return Err(per_codec_error_new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        let gnb_cu_ue_f1ap_id = gnb_cu_ue_f1ap_id.ok_or(per_codec_error_new(format!(
            "Missing mandatory IE gnb_cu_ue_f1ap_id"
        )))?;
        let gnb_du_ue_f1ap_id = gnb_du_ue_f1ap_id.ok_or(per_codec_error_new(format!(
            "Missing mandatory IE gnb_du_ue_f1ap_id"
        )))?;
        let nr_cgi = nr_cgi.ok_or(per_codec_error_new(format!("Missing mandatory IE nr_cgi")))?;
        Ok(Self {
            gnb_cu_ue_f1ap_id,
            gnb_du_ue_f1ap_id,
            nr_cgi,
            ltm_cell_switch_information,
            ta_information_list,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        let ie = &mut Allocator::new_codec_data();
        self.gnb_cu_ue_f1ap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 40, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.gnb_du_ue_f1ap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 41, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.nr_cgi.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 111, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        if let Some(x) = &self.ltm_cell_switch_information {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 729, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.ta_information_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 837, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        encode::encode_sequence_header(data, true, &BitString::new(), false)?;
        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for DuCuCellSwitchNotification {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        DuCuCellSwitchNotification::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DuCuCellSwitchNotification");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DuCuCellSwitchNotification");
            e
        })
    }
}
// CuDuCellSwitchNotification
#[derive(Clone, Debug)]
pub struct CuDuCellSwitchNotification {
    pub gnb_cu_ue_f1ap_id: GnbCuUeF1apId,
    pub gnb_du_ue_f1ap_id: GnbDuUeF1apId,
    pub nr_cgi: NrCgi,
    pub ltm_cell_switch_information: Option<LtmCellSwitchInformation>,
    pub ta_information_list: Option<TaInformationList>,
}

impl CuDuCellSwitchNotification {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let _ = decode::decode_sequence_header(data, true, 0)?;
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut gnb_cu_ue_f1ap_id: Option<GnbCuUeF1apId> = None;
        let mut gnb_du_ue_f1ap_id: Option<GnbDuUeF1apId> = None;
        let mut nr_cgi: Option<NrCgi> = None;
        let mut ltm_cell_switch_information: Option<LtmCellSwitchInformation> = None;
        let mut ta_information_list: Option<TaInformationList> = None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                40 => gnb_cu_ue_f1ap_id = Some(GnbCuUeF1apId::decode(data)?),
                41 => gnb_du_ue_f1ap_id = Some(GnbDuUeF1apId::decode(data)?),
                111 => nr_cgi = Some(NrCgi::decode(data)?),
                729 => ltm_cell_switch_information = Some(LtmCellSwitchInformation::decode(data)?),
                837 => ta_information_list = Some(TaInformationList::decode(data)?),
                x => return Err(per_codec_error_new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        let gnb_cu_ue_f1ap_id = gnb_cu_ue_f1ap_id.ok_or(per_codec_error_new(format!(
            "Missing mandatory IE gnb_cu_ue_f1ap_id"
        )))?;
        let gnb_du_ue_f1ap_id = gnb_du_ue_f1ap_id.ok_or(per_codec_error_new(format!(
            "Missing mandatory IE gnb_du_ue_f1ap_id"
        )))?;
        let nr_cgi = nr_cgi.ok_or(per_codec_error_new(format!("Missing mandatory IE nr_cgi")))?;
        Ok(Self {
            gnb_cu_ue_f1ap_id,
            gnb_du_ue_f1ap_id,
            nr_cgi,
            ltm_cell_switch_information,
            ta_information_list,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        let ie = &mut Allocator::new_codec_data();
        self.gnb_cu_ue_f1ap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 40, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.gnb_du_ue_f1ap_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 41, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.nr_cgi.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 111, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        if let Some(x) = &self.ltm_cell_switch_information {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 729, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.ta_information_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 837, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        encode::encode_sequence_header(data, true, &BitString::new(), false)?;
        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for CuDuCellSwitchNotification {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        CuDuCellSwitchNotification::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CuDuCellSwitchNotification");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CuDuCellSwitchNotification");
            e
        })
    }
}
// DuCuTaInformationTransfer
#[derive(Clone, Debug)]
pub struct DuCuTaInformationTransfer {
    pub transaction_id: TransactionId,
    pub du_to_cu_ta_information_list: DuToCuTaInformationList,
}

impl DuCuTaInformationTransfer {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let _ = decode::decode_sequence_header(data, true, 0)?;
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut transaction_id: Option<TransactionId> = None;
        let mut du_to_cu_ta_information_list: Option<DuToCuTaInformationList> = None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                78 => transaction_id = Some(TransactionId::decode(data)?),
                730 => du_to_cu_ta_information_list = Some(DuToCuTaInformationList::decode(data)?),
                x => return Err(per_codec_error_new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        let transaction_id = transaction_id.ok_or(per_codec_error_new(format!(
            "Missing mandatory IE transaction_id"
        )))?;
        let du_to_cu_ta_information_list = du_to_cu_ta_information_list.ok_or(
            per_codec_error_new(format!("Missing mandatory IE du_to_cu_ta_information_list")),
        )?;
        Ok(Self {
            transaction_id,
            du_to_cu_ta_information_list,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        let ie = &mut Allocator::new_codec_data();
        self.transaction_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 78, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.du_to_cu_ta_information_list.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 730, false)?;
        Criticality::Ignore.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        encode::encode_sequence_header(data, true, &BitString::new(), false)?;
        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for DuCuTaInformationTransfer {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        DuCuTaInformationTransfer::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DuCuTaInformationTransfer");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DuCuTaInformationTransfer");
            e
        })
    }
}
// CuDuTaInformationTransfer
#[derive(Clone, Debug)]
pub struct CuDuTaInformationTransfer {
    pub transaction_id: TransactionId,
    pub cu_to_du_ta_information_list: CuToDuTaInformationList,
}

impl CuDuTaInformationTransfer {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let _ = decode::decode_sequence_header(data, true, 0)?;
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut transaction_id: Option<TransactionId> = None;
        let mut cu_to_du_ta_information_list: Option<CuToDuTaInformationList> = None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                78 => transaction_id = Some(TransactionId::decode(data)?),
                798 => cu_to_du_ta_information_list = Some(CuToDuTaInformationList::decode(data)?),
                x => return Err(per_codec_error_new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        let transaction_id = transaction_id.ok_or(per_codec_error_new(format!(
            "Missing mandatory IE transaction_id"
        )))?;
        let cu_to_du_ta_information_list = cu_to_du_ta_information_list.ok_or(
            per_codec_error_new(format!("Missing mandatory IE cu_to_du_ta_information_list")),
        )?;
        Ok(Self {
            transaction_id,
            cu_to_du_ta_information_list,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        let ie = &mut Allocator::new_codec_data();
        self.transaction_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 78, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.cu_to_du_ta_information_list.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 798, false)?;
        Criticality::Ignore.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        encode::encode_sequence_header(data, true, &BitString::new(), false)?;
        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for CuDuTaInformationTransfer {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        CuDuTaInformationTransfer::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CuDuTaInformationTransfer");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CuDuTaInformationTransfer");
            e
        })
    }
}
// QoEInformationTransferControl
#[derive(Clone, Debug)]
pub struct QoEInformationTransferControl {
    pub transaction_id: TransactionId,
    pub deactivation_indication: Option<DeactivationIndication>,
}

impl QoEInformationTransferControl {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let _ = decode::decode_sequence_header(data, true, 0)?;
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut transaction_id: Option<TransactionId> = None;
        let mut deactivation_indication: Option<DeactivationIndication> = None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                78 => transaction_id = Some(TransactionId::decode(data)?),
                733 => deactivation_indication = Some(DeactivationIndication::decode(data)?),
                x => return Err(per_codec_error_new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        let transaction_id = transaction_id.ok_or(per_codec_error_new(format!(
            "Missing mandatory IE transaction_id"
        )))?;
        Ok(Self {
            transaction_id,
            deactivation_indication,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        let ie = &mut Allocator::new_codec_data();
        self.transaction_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 78, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        if let Some(x) = &self.deactivation_indication {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 733, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        encode::encode_sequence_header(data, true, &BitString::new(), false)?;
        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for QoEInformationTransferControl {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        QoEInformationTransferControl::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("QoEInformationTransferControl");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("QoEInformationTransferControl");
            e
        })
    }
}
// RachIndication
#[derive(Clone, Debug)]
pub struct RachIndication {
    pub transaction_id: TransactionId,
    pub ra_report_indication_list: RaReportIndicationList,
}

impl RachIndication {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let _ = decode::decode_sequence_header(data, true, 0)?;
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut transaction_id: Option<TransactionId> = None;
        let mut ra_report_indication_list: Option<RaReportIndicationList> = None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                78 => transaction_id = Some(TransactionId::decode(data)?),
                734 => ra_report_indication_list = Some(RaReportIndicationList::decode(data)?),
                x => return Err(per_codec_error_new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        let transaction_id = transaction_id.ok_or(per_codec_error_new(format!(
            "Missing mandatory IE transaction_id"
        )))?;
        let ra_report_indication_list = ra_report_indication_list.ok_or(per_codec_error_new(
            format!("Missing mandatory IE ra_report_indication_list"),
        ))?;
        Ok(Self {
            transaction_id,
            ra_report_indication_list,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        let ie = &mut Allocator::new_codec_data();
        self.transaction_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 78, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.ra_report_indication_list.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 734, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        encode::encode_sequence_header(data, true, &BitString::new(), false)?;
        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for RachIndication {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        RachIndication::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("RachIndication");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("RachIndication");
            e
        })
    }
}
// TimingSynchronisationStatusRequest
#[derive(Clone, Debug)]
pub struct TimingSynchronisationStatusRequest {
    pub transaction_id: TransactionId,
    pub rantss_request_type: RantssRequestType,
}

impl TimingSynchronisationStatusRequest {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let _ = decode::decode_sequence_header(data, true, 0)?;
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut transaction_id: Option<TransactionId> = None;
        let mut rantss_request_type: Option<RantssRequestType> = None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                78 => transaction_id = Some(TransactionId::decode(data)?),
                749 => rantss_request_type = Some(RantssRequestType::decode(data)?),
                x => return Err(per_codec_error_new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        let transaction_id = transaction_id.ok_or(per_codec_error_new(format!(
            "Missing mandatory IE transaction_id"
        )))?;
        let rantss_request_type = rantss_request_type.ok_or(per_codec_error_new(format!(
            "Missing mandatory IE rantss_request_type"
        )))?;
        Ok(Self {
            transaction_id,
            rantss_request_type,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        let ie = &mut Allocator::new_codec_data();
        self.transaction_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 78, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.rantss_request_type.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 749, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        encode::encode_sequence_header(data, true, &BitString::new(), false)?;
        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for TimingSynchronisationStatusRequest {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        TimingSynchronisationStatusRequest::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TimingSynchronisationStatusRequest");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TimingSynchronisationStatusRequest");
            e
        })
    }
}
// TimingSynchronisationStatusResponse
#[derive(Clone, Debug)]
pub struct TimingSynchronisationStatusResponse {
    pub transaction_id: TransactionId,
    pub criticality_diagnostics: Option<CriticalityDiagnostics>,
}

impl TimingSynchronisationStatusResponse {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let _ = decode::decode_sequence_header(data, true, 0)?;
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut transaction_id: Option<TransactionId> = None;
        let mut criticality_diagnostics: Option<CriticalityDiagnostics> = None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                78 => transaction_id = Some(TransactionId::decode(data)?),
                7 => criticality_diagnostics = Some(CriticalityDiagnostics::decode(data)?),
                x => return Err(per_codec_error_new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        let transaction_id = transaction_id.ok_or(per_codec_error_new(format!(
            "Missing mandatory IE transaction_id"
        )))?;
        Ok(Self {
            transaction_id,
            criticality_diagnostics,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        let ie = &mut Allocator::new_codec_data();
        self.transaction_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 78, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        if let Some(x) = &self.criticality_diagnostics {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 7, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        encode::encode_sequence_header(data, true, &BitString::new(), false)?;
        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for TimingSynchronisationStatusResponse {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        TimingSynchronisationStatusResponse::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TimingSynchronisationStatusResponse");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TimingSynchronisationStatusResponse");
            e
        })
    }
}
// TimingSynchronisationStatusFailure
#[derive(Clone, Debug)]
pub struct TimingSynchronisationStatusFailure {
    pub transaction_id: TransactionId,
    pub cause: Cause,
    pub criticality_diagnostics: Option<CriticalityDiagnostics>,
}

impl TimingSynchronisationStatusFailure {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let _ = decode::decode_sequence_header(data, true, 0)?;
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut transaction_id: Option<TransactionId> = None;
        let mut cause: Option<Cause> = None;
        let mut criticality_diagnostics: Option<CriticalityDiagnostics> = None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                78 => transaction_id = Some(TransactionId::decode(data)?),
                0 => cause = Some(Cause::decode(data)?),
                7 => criticality_diagnostics = Some(CriticalityDiagnostics::decode(data)?),
                x => return Err(per_codec_error_new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        let transaction_id = transaction_id.ok_or(per_codec_error_new(format!(
            "Missing mandatory IE transaction_id"
        )))?;
        let cause = cause.ok_or(per_codec_error_new(format!("Missing mandatory IE cause")))?;
        Ok(Self {
            transaction_id,
            cause,
            criticality_diagnostics,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        let ie = &mut Allocator::new_codec_data();
        self.transaction_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 78, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.cause.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 0, false)?;
        Criticality::Ignore.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        if let Some(x) = &self.criticality_diagnostics {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 7, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        encode::encode_sequence_header(data, true, &BitString::new(), false)?;
        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for TimingSynchronisationStatusFailure {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        TimingSynchronisationStatusFailure::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TimingSynchronisationStatusFailure");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TimingSynchronisationStatusFailure");
            e
        })
    }
}
// TimingSynchronisationStatusReport
#[derive(Clone, Debug)]
pub struct TimingSynchronisationStatusReport {
    pub transaction_id: TransactionId,
    pub ran_timing_synchronisation_status_info: RanTimingSynchronisationStatusInfo,
}

impl TimingSynchronisationStatusReport {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let _ = decode::decode_sequence_header(data, true, 0)?;
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut transaction_id: Option<TransactionId> = None;
        let mut ran_timing_synchronisation_status_info: Option<RanTimingSynchronisationStatusInfo> =
            None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                78 => transaction_id = Some(TransactionId::decode(data)?),
                750 => {
                    ran_timing_synchronisation_status_info =
                        Some(RanTimingSynchronisationStatusInfo::decode(data)?)
                }
                x => return Err(per_codec_error_new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        let transaction_id = transaction_id.ok_or(per_codec_error_new(format!(
            "Missing mandatory IE transaction_id"
        )))?;
        let ran_timing_synchronisation_status_info =
            ran_timing_synchronisation_status_info.ok_or(per_codec_error_new(format!(
                "Missing mandatory IE ran_timing_synchronisation_status_info"
            )))?;
        Ok(Self {
            transaction_id,
            ran_timing_synchronisation_status_info,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        let ie = &mut Allocator::new_codec_data();
        self.transaction_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 78, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        let ie = &mut Allocator::new_codec_data();
        self.ran_timing_synchronisation_status_info.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 750, false)?;
        Criticality::Ignore.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        encode::encode_sequence_header(data, true, &BitString::new(), false)?;
        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for TimingSynchronisationStatusReport {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        TimingSynchronisationStatusReport::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TimingSynchronisationStatusReport");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TimingSynchronisationStatusReport");
            e
        })
    }
}
// DuCuAccessAndMobilityIndication
#[derive(Clone, Debug)]
pub struct DuCuAccessAndMobilityIndication {
    pub transaction_id: TransactionId,
    pub dllbt_failure_information_list: Option<DllbtFailureInformationList>,
}

impl DuCuAccessAndMobilityIndication {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let _ = decode::decode_sequence_header(data, true, 0)?;
        let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

        let mut transaction_id: Option<TransactionId> = None;
        let mut dllbt_failure_information_list: Option<DllbtFailureInformationList> = None;

        for _ in 0..num_ies {
            let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
            let _ = Criticality::decode(data)?;
            let _ = decode::decode_length_determinent(data, None, None, false)?;
            match id {
                78 => transaction_id = Some(TransactionId::decode(data)?),
                795 => {
                    dllbt_failure_information_list =
                        Some(DllbtFailureInformationList::decode(data)?)
                }
                x => return Err(per_codec_error_new(format!("Unrecognised IE type {}", x))),
            }
            data.decode_align()?;
        }
        let transaction_id = transaction_id.ok_or(per_codec_error_new(format!(
            "Missing mandatory IE transaction_id"
        )))?;
        Ok(Self {
            transaction_id,
            dllbt_failure_information_list,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();

        let ie = &mut Allocator::new_codec_data();
        self.transaction_id.encode(ie)?;
        encode::encode_integer(ies, Some(0), Some(65535), false, 78, false)?;
        Criticality::Reject.encode(ies)?;
        encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
        ies.append_aligned(ie);
        num_ies += 1;

        if let Some(x) = &self.dllbt_failure_information_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 795, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        encode::encode_sequence_header(data, true, &BitString::new(), false)?;
        encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
        data.append_aligned(ies);
        Ok(())
    }
}

impl PerCodec for DuCuAccessAndMobilityIndication {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        DuCuAccessAndMobilityIndication::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DuCuAccessAndMobilityIndication");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DuCuAccessAndMobilityIndication");
            e
        })
    }
}
// Aperiodic
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum Aperiodic {
    True,
}

impl Aperiodic {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(0), true)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(0),
            true,
            *self as i128,
            (*self as u32) >= 1,
        )
    }
}

impl PerCodec for Aperiodic {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Aperiodic::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("Aperiodic");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("Aperiodic");
            e
        })
    }
}
