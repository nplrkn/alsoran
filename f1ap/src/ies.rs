// Autogenerated from F1AP-IEs.asn
#![allow(clippy::all)]
use super::common::*;
use asn1_per::{aper::*, *};
use xxap::*;
#[allow(unused_imports)]
use xxap::{GtpTunnel, PduSessionId, TransportLayerAddress};

// AbortTransmission
#[derive(Clone, Debug)]
pub enum AbortTransmission {
    SrsResourceSetId(SrsResourceSetId),
    ReleaseAll,
    AggregatedPosSrsResourceSetList(AggregatedPosSrsResourceSetList),
}

impl AbortTransmission {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_choice_idx(data, 0, 2, false)?;
        if extended {
            return Err(per_codec_error_new("CHOICE additions not implemented"));
        }
        match idx {
            0 => Ok(Self::SrsResourceSetId(SrsResourceSetId::decode(data)?)),
            1 => Ok(Self::ReleaseAll),
            2 => {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _ = Criticality::decode(data)?;
                let _ = decode::decode_length_determinent(data, None, None, false)?;
                let result = match id {
                    829 => Ok(Self::AggregatedPosSrsResourceSetList(
                        AggregatedPosSrsResourceSetList::decode(data)?,
                    )),
                    x => Err(per_codec_error_new(format!("Unrecognised IE type {}", x))),
                };
                data.decode_align()?;
                result
            }
            _ => Err(per_codec_error_new("Unknown choice idx")),
        }
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        match self {
            Self::SrsResourceSetId(x) => {
                encode::encode_choice_idx(data, 0, 2, false, 0, false)?;
                x.encode(data)
            }
            Self::ReleaseAll => {
                encode::encode_choice_idx(data, 0, 2, false, 1, false)?;
                Ok(())
            }
            Self::AggregatedPosSrsResourceSetList(x) => {
                encode::encode_choice_idx(data, 0, 2, false, 2, false)?;
                encode::encode_integer(data, Some(0), Some(65535), false, 829, false)?;
                Criticality::Ignore.encode(data)?;
                let ie = &mut Allocator::new_codec_data();
                x.encode(ie)?;
                encode::encode_length_determinent(data, None, None, false, ie.length_in_bytes())?;
                Ok(data.append_aligned(ie))
            }
        }
    }
}

impl PerCodec for AbortTransmission {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        AbortTransmission::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("AbortTransmission");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("AbortTransmission");
            e
        })
    }
}
// AccessPointPosition
#[derive(Clone, Debug)]
pub struct AccessPointPosition {
    pub latitude_sign: LatitudeSign,
    pub latitude: u32,
    pub longitude: i32,
    pub direction_of_altitude: DirectionOfAltitude,
    pub altitude: u16,
    pub uncertainty_semi_major: u8,
    pub uncertainty_semi_minor: u8,
    pub orientation_of_major_axis: u8,
    pub uncertainty_altitude: u8,
    pub confidence: u8,
}

impl AccessPointPosition {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, false, 1)?;
        let latitude_sign = LatitudeSign::decode(data)?;
        let latitude = decode::decode_integer(data, Some(0), Some(8388607), false)?.0 as u32;
        let longitude =
            decode::decode_integer(data, Some(-8388608), Some(8388607), false)?.0 as i32;
        let direction_of_altitude = DirectionOfAltitude::decode(data)?;
        let altitude = decode::decode_integer(data, Some(0), Some(32767), false)?.0 as u16;
        let uncertainty_semi_major =
            decode::decode_integer(data, Some(0), Some(127), false)?.0 as u8;
        let uncertainty_semi_minor =
            decode::decode_integer(data, Some(0), Some(127), false)?.0 as u8;
        let orientation_of_major_axis =
            decode::decode_integer(data, Some(0), Some(179), false)?.0 as u8;
        let uncertainty_altitude = decode::decode_integer(data, Some(0), Some(127), false)?.0 as u8;
        let confidence = decode::decode_integer(data, Some(0), Some(100), false)?.0 as u8;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            latitude_sign,
            latitude,
            longitude,
            direction_of_altitude,
            altitude,
            uncertainty_semi_major,
            uncertainty_semi_minor,
            orientation_of_major_axis,
            uncertainty_altitude,
            confidence,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, false, &optionals, false)?;
        self.latitude_sign.encode(data)?;
        encode::encode_integer(
            data,
            Some(0),
            Some(8388607),
            false,
            self.latitude as i128,
            false,
        )?;
        encode::encode_integer(
            data,
            Some(-8388608),
            Some(8388607),
            false,
            self.longitude as i128,
            false,
        )?;
        self.direction_of_altitude.encode(data)?;
        encode::encode_integer(
            data,
            Some(0),
            Some(32767),
            false,
            self.altitude as i128,
            false,
        )?;
        encode::encode_integer(
            data,
            Some(0),
            Some(127),
            false,
            self.uncertainty_semi_major as i128,
            false,
        )?;
        encode::encode_integer(
            data,
            Some(0),
            Some(127),
            false,
            self.uncertainty_semi_minor as i128,
            false,
        )?;
        encode::encode_integer(
            data,
            Some(0),
            Some(179),
            false,
            self.orientation_of_major_axis as i128,
            false,
        )?;
        encode::encode_integer(
            data,
            Some(0),
            Some(127),
            false,
            self.uncertainty_altitude as i128,
            false,
        )?;
        encode::encode_integer(
            data,
            Some(0),
            Some(100),
            false,
            self.confidence as i128,
            false,
        )?;

        Ok(())
    }
}

impl PerCodec for AccessPointPosition {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        AccessPointPosition::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("AccessPointPosition");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("AccessPointPosition");
            e
        })
    }
}
// ActivatedCellsMappingListItem
#[derive(Clone, Debug)]
pub struct ActivatedCellsMappingListItem {
    pub nr_cg_ifor_target_logical_du: NrCgi,
    pub nr_cg_ifor_source_logical_du: NrCgi,
}

impl ActivatedCellsMappingListItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let nr_cg_ifor_target_logical_du = NrCgi::decode(data)?;
        let nr_cg_ifor_source_logical_du = NrCgi::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            nr_cg_ifor_target_logical_du,
            nr_cg_ifor_source_logical_du,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.nr_cg_ifor_target_logical_du.encode(data)?;
        self.nr_cg_ifor_source_logical_du.encode(data)?;

        Ok(())
    }
}

impl PerCodec for ActivatedCellsMappingListItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        ActivatedCellsMappingListItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ActivatedCellsMappingListItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ActivatedCellsMappingListItem");
            e
        })
    }
}
// ActivatedCellsToBeUpdatedList
#[derive(Clone, Debug)]
pub struct ActivatedCellsToBeUpdatedList(pub NonEmpty<ActivatedCellsToBeUpdatedListItem>);

impl ActivatedCellsToBeUpdatedList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(512), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(ActivatedCellsToBeUpdatedListItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(512), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for ActivatedCellsToBeUpdatedList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        ActivatedCellsToBeUpdatedList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ActivatedCellsToBeUpdatedList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ActivatedCellsToBeUpdatedList");
            e
        })
    }
}
// ActivatedCellsToBeUpdatedListItem
#[derive(Clone, Debug)]
pub struct ActivatedCellsToBeUpdatedListItem {
    pub nr_cgi: NrCgi,
    pub iab_du_cell_resource_configuration_mode_info: IabDuCellResourceConfigurationModeInfo,
}

impl ActivatedCellsToBeUpdatedListItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, false, 1)?;
        let nr_cgi = NrCgi::decode(data)?;
        let iab_du_cell_resource_configuration_mode_info =
            IabDuCellResourceConfigurationModeInfo::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            nr_cgi,
            iab_du_cell_resource_configuration_mode_info,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, false, &optionals, false)?;
        self.nr_cgi.encode(data)?;
        self.iab_du_cell_resource_configuration_mode_info
            .encode(data)?;

        Ok(())
    }
}

impl PerCodec for ActivatedCellsToBeUpdatedListItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        ActivatedCellsToBeUpdatedListItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ActivatedCellsToBeUpdatedListItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ActivatedCellsToBeUpdatedListItem");
            e
        })
    }
}
// ActivationRequestType
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum ActivationRequestType {
    Activate,
    Deactivate,
}

impl ActivationRequestType {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(1), true)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(1),
            true,
            *self as i128,
            (*self as u32) >= 2,
        )
    }
}

impl PerCodec for ActivationRequestType {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        ActivationRequestType::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ActivationRequestType");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ActivationRequestType");
            e
        })
    }
}
// ActiveUlBwp
#[derive(Clone, Debug)]
pub struct ActiveUlBwp {
    pub location_and_bandwidth: u16,
    pub subcarrier_spacing: SubcarrierSpacing1,
    pub cyclic_prefix: CyclicPrefix,
    pub tx_direct_current_location: u16,
    pub shift7dot5k_hz: Option<Shift7dot5kHz>,
    pub srs_config: SrsConfig,
}

impl ActiveUlBwp {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, false, 2)?;
        let location_and_bandwidth =
            decode::decode_integer(data, Some(0), Some(37949), true)?.0 as u16;
        let subcarrier_spacing = SubcarrierSpacing1::decode(data)?;
        let cyclic_prefix = CyclicPrefix::decode(data)?;
        let tx_direct_current_location =
            decode::decode_integer(data, Some(0), Some(3301), true)?.0 as u16;
        let shift7dot5k_hz = if optionals[0] {
            Some(Shift7dot5kHz::decode(data)?)
        } else {
            None
        };
        let srs_config = SrsConfig::decode(data)?;

        // Process the extension container

        if optionals[1] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            location_and_bandwidth,
            subcarrier_spacing,
            cyclic_prefix,
            tx_direct_current_location,
            shift7dot5k_hz,
            srs_config,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.shift7dot5k_hz.is_some());
        optionals.push(false);

        encode::encode_sequence_header(data, false, &optionals, false)?;
        encode::encode_integer(
            data,
            Some(0),
            Some(37949),
            true,
            self.location_and_bandwidth as i128,
            false,
        )?;
        self.subcarrier_spacing.encode(data)?;
        self.cyclic_prefix.encode(data)?;
        encode::encode_integer(
            data,
            Some(0),
            Some(3301),
            true,
            self.tx_direct_current_location as i128,
            false,
        )?;
        if let Some(x) = &self.shift7dot5k_hz {
            x.encode(data)?;
        }
        self.srs_config.encode(data)?;

        Ok(())
    }
}

impl PerCodec for ActiveUlBwp {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        ActiveUlBwp::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ActiveUlBwp");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ActiveUlBwp");
            e
        })
    }
}
// AdditionalDuplicationIndication
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum AdditionalDuplicationIndication {
    Three,
    Four,
}

impl AdditionalDuplicationIndication {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(1), true)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(1),
            true,
            *self as i128,
            (*self as u32) >= 2,
        )
    }
}

impl PerCodec for AdditionalDuplicationIndication {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        AdditionalDuplicationIndication::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("AdditionalDuplicationIndication");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("AdditionalDuplicationIndication");
            e
        })
    }
}
// AdditionalPathList
#[derive(Clone, Debug)]
pub struct AdditionalPathList(pub NonEmpty<AdditionalPathItem>);

impl AdditionalPathList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(2), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(AdditionalPathItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(2), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for AdditionalPathList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        AdditionalPathList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("AdditionalPathList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("AdditionalPathList");
            e
        })
    }
}
// AdditionalPathItem
#[derive(Clone, Debug)]
pub struct AdditionalPathItem {
    pub relative_path_delay: RelativePathDelay,
    pub path_quality: Option<TrpMeasurementQuality>,
    pub multiple_ul_ao_a: Option<MultipleUlAoA>,
    pub path_power: Option<UlSrsRsrpp>,
}

impl AdditionalPathItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, false, 2)?;
        let relative_path_delay = RelativePathDelay::decode(data)?;
        let path_quality = if optionals[0] {
            Some(TrpMeasurementQuality::decode(data)?)
        } else {
            None
        };

        // Process the extension container
        let mut multiple_ul_ao_a: Option<MultipleUlAoA> = None;
        let mut path_power: Option<UlSrsRsrpp> = None;

        if optionals[1] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    558 => multiple_ul_ao_a = Some(MultipleUlAoA::decode(data)?),
                    636 => path_power = Some(UlSrsRsrpp::decode(data)?),
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            relative_path_delay,
            path_quality,
            multiple_ul_ao_a,
            path_power,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();
        if let Some(x) = &self.multiple_ul_ao_a {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 558, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.path_power {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 636, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        let mut optionals = BitString::new();
        optionals.push(self.path_quality.is_some());
        optionals.push(num_ies != 0);

        encode::encode_sequence_header(data, false, &optionals, false)?;
        self.relative_path_delay.encode(data)?;
        if let Some(x) = &self.path_quality {
            x.encode(data)?;
        }
        if num_ies != 0 {
            encode::encode_length_determinent(data, Some(1), Some(65535), false, num_ies)?;
            data.append_aligned(ies);
        }
        Ok(())
    }
}

impl PerCodec for AdditionalPathItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        AdditionalPathItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("AdditionalPathItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("AdditionalPathItem");
            e
        })
    }
}
// ExtendedAdditionalPathList
#[derive(Clone, Debug)]
pub struct ExtendedAdditionalPathList(pub NonEmpty<ExtendedAdditionalPathListItem>);

impl ExtendedAdditionalPathList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(8), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(ExtendedAdditionalPathListItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(8), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for ExtendedAdditionalPathList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        ExtendedAdditionalPathList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ExtendedAdditionalPathList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ExtendedAdditionalPathList");
            e
        })
    }
}
// ExtendedAdditionalPathListItem
#[derive(Clone, Debug)]
pub struct ExtendedAdditionalPathListItem {
    pub relative_time_of_path: RelativePathDelay,
    pub path_quality: Option<TrpMeasurementQuality>,
    pub multiple_ul_ao_a: Option<MultipleUlAoA>,
    pub path_power: Option<UlSrsRsrpp>,
}

impl ExtendedAdditionalPathListItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 4)?;
        let relative_time_of_path = RelativePathDelay::decode(data)?;
        let path_quality = if optionals[0] {
            Some(TrpMeasurementQuality::decode(data)?)
        } else {
            None
        };
        let multiple_ul_ao_a = if optionals[1] {
            Some(MultipleUlAoA::decode(data)?)
        } else {
            None
        };
        let path_power = if optionals[2] {
            Some(UlSrsRsrpp::decode(data)?)
        } else {
            None
        };

        // Process the extension container

        if optionals[3] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            relative_time_of_path,
            path_quality,
            multiple_ul_ao_a,
            path_power,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.path_quality.is_some());
        optionals.push(self.multiple_ul_ao_a.is_some());
        optionals.push(self.path_power.is_some());
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.relative_time_of_path.encode(data)?;
        if let Some(x) = &self.path_quality {
            x.encode(data)?;
        }
        if let Some(x) = &self.multiple_ul_ao_a {
            x.encode(data)?;
        }
        if let Some(x) = &self.path_power {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl PerCodec for ExtendedAdditionalPathListItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        ExtendedAdditionalPathListItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ExtendedAdditionalPathListItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ExtendedAdditionalPathListItem");
            e
        })
    }
}
// AdditionalPdcpDuplicationTnlList
#[derive(Clone, Debug)]
pub struct AdditionalPdcpDuplicationTnlList(pub NonEmpty<AdditionalPdcpDuplicationTnlItem>);

impl AdditionalPdcpDuplicationTnlList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(2), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(AdditionalPdcpDuplicationTnlItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(2), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for AdditionalPdcpDuplicationTnlList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        AdditionalPdcpDuplicationTnlList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("AdditionalPdcpDuplicationTnlList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("AdditionalPdcpDuplicationTnlList");
            e
        })
    }
}
// AdditionalPdcpDuplicationTnlItem
#[derive(Clone, Debug)]
pub struct AdditionalPdcpDuplicationTnlItem {
    pub additional_pdcp_duplication_up_tnl_information: UpTransportLayerInformation,
    pub bh_info: Option<BhInfo>,
}

impl AdditionalPdcpDuplicationTnlItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let additional_pdcp_duplication_up_tnl_information =
            UpTransportLayerInformation::decode(data)?;

        // Process the extension container
        let mut bh_info: Option<BhInfo> = None;

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    280 => bh_info = Some(BhInfo::decode(data)?),
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            additional_pdcp_duplication_up_tnl_information,
            bh_info,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();
        if let Some(x) = &self.bh_info {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 280, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        let mut optionals = BitString::new();
        optionals.push(num_ies != 0);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.additional_pdcp_duplication_up_tnl_information
            .encode(data)?;
        if num_ies != 0 {
            encode::encode_length_determinent(data, Some(1), Some(65535), false, num_ies)?;
            data.append_aligned(ies);
        }
        Ok(())
    }
}

impl PerCodec for AdditionalPdcpDuplicationTnlItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        AdditionalPdcpDuplicationTnlItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("AdditionalPdcpDuplicationTnlItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("AdditionalPdcpDuplicationTnlItem");
            e
        })
    }
}
// AdditionalSibMessageList
#[derive(Clone, Debug)]
pub struct AdditionalSibMessageList(pub NonEmpty<AdditionalSibMessageListItem>);

impl AdditionalSibMessageList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(63), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(AdditionalSibMessageListItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(63), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for AdditionalSibMessageList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        AdditionalSibMessageList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("AdditionalSibMessageList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("AdditionalSibMessageList");
            e
        })
    }
}
// AdditionalSibMessageListItem
#[derive(Clone, Debug)]
pub struct AdditionalSibMessageListItem {
    pub additional_sib: Vec<u8>,
}

impl AdditionalSibMessageListItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, false, 1)?;
        let additional_sib = decode::decode_octetstring(data, None, None, false)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self { additional_sib })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, false, &optionals, false)?;
        encode::encode_octetstring(data, None, None, false, &self.additional_sib, false)?;

        Ok(())
    }
}

impl PerCodec for AdditionalSibMessageListItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        AdditionalSibMessageListItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("AdditionalSibMessageListItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("AdditionalSibMessageListItem");
            e
        })
    }
}
// AdditionalRrmPriorityIndex
#[derive(Clone, Debug)]
pub struct AdditionalRrmPriorityIndex(pub BitString);

impl AdditionalRrmPriorityIndex {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(decode::decode_bitstring(
            data,
            Some(32),
            Some(32),
            false,
        )?))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_bitstring(data, Some(32), Some(32), false, &self.0, false)
    }
}

impl PerCodec for AdditionalRrmPriorityIndex {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        AdditionalRrmPriorityIndex::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("AdditionalRrmPriorityIndex");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("AdditionalRrmPriorityIndex");
            e
        })
    }
}
// AffectedCellsAndBeamsList
#[derive(Clone, Debug)]
pub struct AffectedCellsAndBeamsList(pub NonEmpty<AffectedCellsAndBeamsItem>);

impl AffectedCellsAndBeamsList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(32), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(AffectedCellsAndBeamsItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(32), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for AffectedCellsAndBeamsList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        AffectedCellsAndBeamsList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("AffectedCellsAndBeamsList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("AffectedCellsAndBeamsList");
            e
        })
    }
}
// AffectedCellsAndBeamsItem
#[derive(Clone, Debug)]
pub struct AffectedCellsAndBeamsItem {
    pub nr_cgi: NrCgi,
    pub affected_ssb_list: Option<AffectedSsbList>,
}

impl AffectedCellsAndBeamsItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 2)?;
        let nr_cgi = NrCgi::decode(data)?;
        let affected_ssb_list = if optionals[0] {
            Some(AffectedSsbList::decode(data)?)
        } else {
            None
        };

        // Process the extension container

        if optionals[1] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            nr_cgi,
            affected_ssb_list,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.affected_ssb_list.is_some());
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.nr_cgi.encode(data)?;
        if let Some(x) = &self.affected_ssb_list {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl PerCodec for AffectedCellsAndBeamsItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        AffectedCellsAndBeamsItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("AffectedCellsAndBeamsItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("AffectedCellsAndBeamsItem");
            e
        })
    }
}
// AffectedSsbList
#[derive(Clone, Debug)]
pub struct AffectedSsbList(pub NonEmpty<AffectedSsbItem>);

impl AffectedSsbList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(64), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(AffectedSsbItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(64), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for AffectedSsbList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        AffectedSsbList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("AffectedSsbList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("AffectedSsbList");
            e
        })
    }
}
// AffectedSsbItem
#[derive(Clone, Debug)]
pub struct AffectedSsbItem {
    pub ssb_index: u8,
}

impl AffectedSsbItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let ssb_index = decode::decode_integer(data, Some(0), Some(63), false)?.0 as u8;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self { ssb_index })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        encode::encode_integer(
            data,
            Some(0),
            Some(63),
            false,
            self.ssb_index as i128,
            false,
        )?;

        Ok(())
    }
}

impl PerCodec for AffectedSsbItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        AffectedSsbItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("AffectedSsbItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("AffectedSsbItem");
            e
        })
    }
}
// AggregatedPosSrsResourceIdList
#[derive(Clone, Debug)]
pub struct AggregatedPosSrsResourceIdList(pub NonEmpty<AggregatedPosSrsResourceIdItem>);

impl AggregatedPosSrsResourceIdList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(2), Some(3), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(AggregatedPosSrsResourceIdItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(2), Some(3), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for AggregatedPosSrsResourceIdList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        AggregatedPosSrsResourceIdList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("AggregatedPosSrsResourceIdList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("AggregatedPosSrsResourceIdList");
            e
        })
    }
}
// AggregatedPosSrsResourceIdItem
#[derive(Clone, Debug)]
pub struct AggregatedPosSrsResourceIdItem {
    pub positioning_srs: SrsPosResourceId,
    pub point_a: Option<PointA>,
    pub scs_specific_carrier: Option<ScsSpecificCarrier>,
    pub nr_pci: Option<NrPci>,
}

impl AggregatedPosSrsResourceIdItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let positioning_srs = SrsPosResourceId::decode(data)?;

        // Process the extension container
        let mut point_a: Option<PointA> = None;
        let mut scs_specific_carrier: Option<ScsSpecificCarrier> = None;
        let mut nr_pci: Option<NrPci> = None;

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    839 => point_a = Some(PointA::decode(data)?),
                    840 => scs_specific_carrier = Some(ScsSpecificCarrier::decode(data)?),
                    841 => nr_pci = Some(NrPci::decode(data)?),
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            positioning_srs,
            point_a,
            scs_specific_carrier,
            nr_pci,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();
        if let Some(x) = &self.point_a {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 839, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.scs_specific_carrier {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 840, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.nr_pci {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 841, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        let mut optionals = BitString::new();
        optionals.push(num_ies != 0);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.positioning_srs.encode(data)?;
        if num_ies != 0 {
            encode::encode_length_determinent(data, Some(1), Some(65535), false, num_ies)?;
            data.append_aligned(ies);
        }
        Ok(())
    }
}

impl PerCodec for AggregatedPosSrsResourceIdItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        AggregatedPosSrsResourceIdItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("AggregatedPosSrsResourceIdItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("AggregatedPosSrsResourceIdItem");
            e
        })
    }
}
// AggregatedPosSrsResourceSetList
#[derive(Clone, Debug)]
pub struct AggregatedPosSrsResourceSetList(pub NonEmpty<AggregatedPosSrsResourceSetItem>);

impl AggregatedPosSrsResourceSetList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(32), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(AggregatedPosSrsResourceSetItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(32), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for AggregatedPosSrsResourceSetList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        AggregatedPosSrsResourceSetList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("AggregatedPosSrsResourceSetList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("AggregatedPosSrsResourceSetList");
            e
        })
    }
}
// AggregatedPosSrsResourceSetItem
#[derive(Clone, Debug)]
pub struct AggregatedPosSrsResourceSetItem {
    pub combined_pos_srs_resource_set_list: CombinedPosSrsResourceSetList,
}

impl AggregatedPosSrsResourceSetItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let combined_pos_srs_resource_set_list = CombinedPosSrsResourceSetList::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            combined_pos_srs_resource_set_list,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.combined_pos_srs_resource_set_list.encode(data)?;

        Ok(())
    }
}

impl PerCodec for AggregatedPosSrsResourceSetItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        AggregatedPosSrsResourceSetItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("AggregatedPosSrsResourceSetItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("AggregatedPosSrsResourceSetItem");
            e
        })
    }
}
// CombinedPosSrsResourceSetList
#[derive(Clone, Debug)]
pub struct CombinedPosSrsResourceSetList(pub NonEmpty<CombinedPosSrsResourceSetItem>);

impl CombinedPosSrsResourceSetList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(2), Some(3), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(CombinedPosSrsResourceSetItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(2), Some(3), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for CombinedPosSrsResourceSetList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        CombinedPosSrsResourceSetList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CombinedPosSrsResourceSetList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CombinedPosSrsResourceSetList");
            e
        })
    }
}
// CombinedPosSrsResourceSetItem
#[derive(Clone, Debug)]
pub struct CombinedPosSrsResourceSetItem {
    pub point_a: u32,
    pub nr_pci: Option<NrPci>,
    pub pos_srs_resource_set_id: u8,
    pub scs_specific_carrier: ScsSpecificCarrier,
}

impl CombinedPosSrsResourceSetItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 2)?;
        let point_a = decode::decode_integer(data, Some(0), Some(3279165), false)?.0 as u32;
        let nr_pci = if optionals[0] {
            Some(NrPci::decode(data)?)
        } else {
            None
        };
        let pos_srs_resource_set_id =
            decode::decode_integer(data, Some(0), Some(15), false)?.0 as u8;
        let scs_specific_carrier = ScsSpecificCarrier::decode(data)?;

        // Process the extension container

        if optionals[1] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            point_a,
            nr_pci,
            pos_srs_resource_set_id,
            scs_specific_carrier,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.nr_pci.is_some());
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        encode::encode_integer(
            data,
            Some(0),
            Some(3279165),
            false,
            self.point_a as i128,
            false,
        )?;
        if let Some(x) = &self.nr_pci {
            x.encode(data)?;
        }
        encode::encode_integer(
            data,
            Some(0),
            Some(15),
            false,
            self.pos_srs_resource_set_id as i128,
            false,
        )?;
        self.scs_specific_carrier.encode(data)?;

        Ok(())
    }
}

impl PerCodec for CombinedPosSrsResourceSetItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        CombinedPosSrsResourceSetItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CombinedPosSrsResourceSetItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CombinedPosSrsResourceSetItem");
            e
        })
    }
}
// AggregatedPrsResourceSetList
#[derive(Clone, Debug)]
pub struct AggregatedPrsResourceSetList(pub NonEmpty<AggregatedPrsResourceSetItem>);

impl AggregatedPrsResourceSetList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(2), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(AggregatedPrsResourceSetItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(2), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for AggregatedPrsResourceSetList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        AggregatedPrsResourceSetList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("AggregatedPrsResourceSetList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("AggregatedPrsResourceSetList");
            e
        })
    }
}
// AggregatedPrsResourceSetItem
#[derive(Clone, Debug)]
pub struct AggregatedPrsResourceSetItem {
    pub dl_prs_resource_set_list: DlPrsResourceSetList,
}

impl AggregatedPrsResourceSetItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let dl_prs_resource_set_list = DlPrsResourceSetList::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            dl_prs_resource_set_list,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.dl_prs_resource_set_list.encode(data)?;

        Ok(())
    }
}

impl PerCodec for AggregatedPrsResourceSetItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        AggregatedPrsResourceSetItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("AggregatedPrsResourceSetItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("AggregatedPrsResourceSetItem");
            e
        })
    }
}
// DlPrsResourceSetList
#[derive(Clone, Debug)]
pub struct DlPrsResourceSetList(pub NonEmpty<DlPrsResourceSetItem>);

impl DlPrsResourceSetList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(3), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(DlPrsResourceSetItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(3), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for DlPrsResourceSetList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        DlPrsResourceSetList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DlPrsResourceSetList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DlPrsResourceSetList");
            e
        })
    }
}
// DlPrsResourceSetItem
#[derive(Clone, Debug)]
pub struct DlPrsResourceSetItem {
    pub dl_prs_resource_set_index: u8,
}

impl DlPrsResourceSetItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let dl_prs_resource_set_index =
            decode::decode_integer(data, Some(1), Some(8), false)?.0 as u8;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            dl_prs_resource_set_index,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        encode::encode_integer(
            data,
            Some(1),
            Some(8),
            false,
            self.dl_prs_resource_set_index as i128,
            false,
        )?;

        Ok(())
    }
}

impl PerCodec for DlPrsResourceSetItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        DlPrsResourceSetItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DlPrsResourceSetItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DlPrsResourceSetItem");
            e
        })
    }
}
// AggressorCellList
#[derive(Clone, Debug)]
pub struct AggressorCellList(pub NonEmpty<AggressorCellListItem>);

impl AggressorCellList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(512), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(AggressorCellListItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(512), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for AggressorCellList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        AggressorCellList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("AggressorCellList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("AggressorCellList");
            e
        })
    }
}
// AggressorCellListItem
#[derive(Clone, Debug)]
pub struct AggressorCellListItem {
    pub aggressor_cell_id: NrCgi,
}

impl AggressorCellListItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, false, 1)?;
        let aggressor_cell_id = NrCgi::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self { aggressor_cell_id })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, false, &optionals, false)?;
        self.aggressor_cell_id.encode(data)?;

        Ok(())
    }
}

impl PerCodec for AggressorCellListItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        AggressorCellListItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("AggressorCellListItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("AggressorCellListItem");
            e
        })
    }
}
// AggressorGnbSetId
#[derive(Clone, Debug)]
pub struct AggressorGnbSetId {
    pub aggressor_gnb_set_id: GnbSetId,
}

impl AggressorGnbSetId {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, false, 1)?;
        let aggressor_gnb_set_id = GnbSetId::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            aggressor_gnb_set_id,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, false, &optionals, false)?;
        self.aggressor_gnb_set_id.encode(data)?;

        Ok(())
    }
}

impl PerCodec for AggressorGnbSetId {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        AggressorGnbSetId::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("AggressorGnbSetId");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("AggressorGnbSetId");
            e
        })
    }
}
// AllocationAndRetentionPriority
#[derive(Clone, Debug)]
pub struct AllocationAndRetentionPriority {
    pub priority_level: PriorityLevel,
    pub pre_emption_capability: PreEmptionCapability,
    pub pre_emption_vulnerability: PreEmptionVulnerability,
}

impl AllocationAndRetentionPriority {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let priority_level = PriorityLevel::decode(data)?;
        let pre_emption_capability = PreEmptionCapability::decode(data)?;
        let pre_emption_vulnerability = PreEmptionVulnerability::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            priority_level,
            pre_emption_capability,
            pre_emption_vulnerability,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.priority_level.encode(data)?;
        self.pre_emption_capability.encode(data)?;
        self.pre_emption_vulnerability.encode(data)?;

        Ok(())
    }
}

impl PerCodec for AllocationAndRetentionPriority {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        AllocationAndRetentionPriority::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("AllocationAndRetentionPriority");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("AllocationAndRetentionPriority");
            e
        })
    }
}
// AlternativeQosParaSetList
#[derive(Clone, Debug)]
pub struct AlternativeQosParaSetList(pub NonEmpty<AlternativeQosParaSetItem>);

impl AlternativeQosParaSetList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(8), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(AlternativeQosParaSetItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(8), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for AlternativeQosParaSetList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        AlternativeQosParaSetList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("AlternativeQosParaSetList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("AlternativeQosParaSetList");
            e
        })
    }
}
// AlternativeQosParaSetItem
#[derive(Clone, Debug)]
pub struct AlternativeQosParaSetItem {
    pub alternative_qos_para_set_index: QosParaSetIndex,
    pub guaranteed_flow_bit_rate_dl: Option<BitRate>,
    pub guaranteed_flow_bit_rate_ul: Option<BitRate>,
    pub packet_delay_budget: Option<PacketDelayBudget>,
    pub packet_error_rate: Option<PacketErrorRate>,
    pub max_data_burst_volume: Option<MaxDataBurstVolume>,
}

impl AlternativeQosParaSetItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 5)?;
        let alternative_qos_para_set_index = QosParaSetIndex::decode(data)?;
        let guaranteed_flow_bit_rate_dl = if optionals[0] {
            Some(BitRate::decode(data)?)
        } else {
            None
        };
        let guaranteed_flow_bit_rate_ul = if optionals[1] {
            Some(BitRate::decode(data)?)
        } else {
            None
        };
        let packet_delay_budget = if optionals[2] {
            Some(PacketDelayBudget::decode(data)?)
        } else {
            None
        };
        let packet_error_rate = if optionals[3] {
            Some(PacketErrorRate::decode(data)?)
        } else {
            None
        };

        // Process the extension container
        let mut max_data_burst_volume: Option<MaxDataBurstVolume> = None;

        if optionals[4] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    836 => max_data_burst_volume = Some(MaxDataBurstVolume::decode(data)?),
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            alternative_qos_para_set_index,
            guaranteed_flow_bit_rate_dl,
            guaranteed_flow_bit_rate_ul,
            packet_delay_budget,
            packet_error_rate,
            max_data_burst_volume,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();
        if let Some(x) = &self.max_data_burst_volume {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 836, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        let mut optionals = BitString::new();
        optionals.push(self.guaranteed_flow_bit_rate_dl.is_some());
        optionals.push(self.guaranteed_flow_bit_rate_ul.is_some());
        optionals.push(self.packet_delay_budget.is_some());
        optionals.push(self.packet_error_rate.is_some());
        optionals.push(num_ies != 0);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.alternative_qos_para_set_index.encode(data)?;
        if let Some(x) = &self.guaranteed_flow_bit_rate_dl {
            x.encode(data)?;
        }
        if let Some(x) = &self.guaranteed_flow_bit_rate_ul {
            x.encode(data)?;
        }
        if let Some(x) = &self.packet_delay_budget {
            x.encode(data)?;
        }
        if let Some(x) = &self.packet_error_rate {
            x.encode(data)?;
        }
        if num_ies != 0 {
            encode::encode_length_determinent(data, Some(1), Some(65535), false, num_ies)?;
            data.append_aligned(ies);
        }
        Ok(())
    }
}

impl PerCodec for AlternativeQosParaSetItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        AlternativeQosParaSetItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("AlternativeQosParaSetItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("AlternativeQosParaSetItem");
            e
        })
    }
}
// AngleMeasurementQuality
#[derive(Clone, Debug)]
pub struct AngleMeasurementQuality {
    pub azimuth_quality: u8,
    pub zenith_quality: Option<u8>,
    pub resolution: Resolution,
}

impl AngleMeasurementQuality {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, false, 2)?;
        let azimuth_quality = decode::decode_integer(data, Some(0), Some(255), false)?.0 as u8;
        let zenith_quality = if optionals[0] {
            Some(decode::decode_integer(data, Some(0), Some(255), false)?.0 as u8)
        } else {
            None
        };
        let resolution = Resolution::decode(data)?;

        // Process the extension container

        if optionals[1] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            azimuth_quality,
            zenith_quality,
            resolution,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.zenith_quality.is_some());
        optionals.push(false);

        encode::encode_sequence_header(data, false, &optionals, false)?;
        encode::encode_integer(
            data,
            Some(0),
            Some(255),
            false,
            self.azimuth_quality as i128,
            false,
        )?;
        if let Some(x) = &self.zenith_quality {
            encode::encode_integer(data, Some(0), Some(255), false, *x as i128, false)?;
        }
        self.resolution.encode(data)?;

        Ok(())
    }
}

impl PerCodec for AngleMeasurementQuality {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        AngleMeasurementQuality::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("AngleMeasurementQuality");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("AngleMeasurementQuality");
            e
        })
    }
}
// AperiodicSrsResourceTriggerList
#[derive(Clone, Debug)]
pub struct AperiodicSrsResourceTriggerList(pub NonEmpty<AperiodicSrsResourceTrigger>);

impl AperiodicSrsResourceTriggerList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(3), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(AperiodicSrsResourceTrigger::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(3), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for AperiodicSrsResourceTriggerList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        AperiodicSrsResourceTriggerList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("AperiodicSrsResourceTriggerList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("AperiodicSrsResourceTriggerList");
            e
        })
    }
}
// AperiodicSrsResourceTrigger
#[derive(Clone, Copy, Debug)]
pub struct AperiodicSrsResourceTrigger(pub u8);

impl AperiodicSrsResourceTrigger {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(
            decode::decode_integer(data, Some(1), Some(3), false)?.0 as u8,
        ))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_integer(data, Some(1), Some(3), false, self.0 as i128, false)
    }
}

impl PerCodec for AperiodicSrsResourceTrigger {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        AperiodicSrsResourceTrigger::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("AperiodicSrsResourceTrigger");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("AperiodicSrsResourceTrigger");
            e
        })
    }
}
// AssociatedSCellItem
#[derive(Clone, Debug)]
pub struct AssociatedSCellItem {
    pub s_cell_id: NrCgi,
}

impl AssociatedSCellItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, false, 1)?;
        let s_cell_id = NrCgi::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self { s_cell_id })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, false, &optionals, false)?;
        self.s_cell_id.encode(data)?;

        Ok(())
    }
}

impl PerCodec for AssociatedSCellItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        AssociatedSCellItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("AssociatedSCellItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("AssociatedSCellItem");
            e
        })
    }
}
// AssociatedSessionId
#[derive(Clone, Debug)]
pub struct AssociatedSessionId(pub Vec<u8>);

impl AssociatedSessionId {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(decode::decode_octetstring(data, None, None, false)?))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_octetstring(data, None, None, false, &self.0, false)
    }
}

impl PerCodec for AssociatedSessionId {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        AssociatedSessionId::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("AssociatedSessionId");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("AssociatedSessionId");
            e
        })
    }
}
// AvailablePlmnList
#[derive(Clone, Debug)]
pub struct AvailablePlmnList(pub NonEmpty<AvailablePlmnListItem>);

impl AvailablePlmnList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(6), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(AvailablePlmnListItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(6), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for AvailablePlmnList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        AvailablePlmnList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("AvailablePlmnList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("AvailablePlmnList");
            e
        })
    }
}
// AvailablePlmnListItem
#[derive(Clone, Debug)]
pub struct AvailablePlmnListItem {
    pub plmn_identity: PlmnIdentity,
}

impl AvailablePlmnListItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, false, 1)?;
        let plmn_identity = PlmnIdentity::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self { plmn_identity })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, false, &optionals, false)?;
        self.plmn_identity.encode(data)?;

        Ok(())
    }
}

impl PerCodec for AvailablePlmnListItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        AvailablePlmnListItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("AvailablePlmnListItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("AvailablePlmnListItem");
            e
        })
    }
}
// AvailableSnpnIdList
#[derive(Clone, Debug)]
pub struct AvailableSnpnIdList(pub NonEmpty<AvailableSnpnIdListItem>);

impl AvailableSnpnIdList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(12), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(AvailableSnpnIdListItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(12), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for AvailableSnpnIdList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        AvailableSnpnIdList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("AvailableSnpnIdList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("AvailableSnpnIdList");
            e
        })
    }
}
// AvailableSnpnIdListItem
#[derive(Clone, Debug)]
pub struct AvailableSnpnIdListItem {
    pub plmn_identity: PlmnIdentity,
    pub available_nid_list: BroadcastNidList,
}

impl AvailableSnpnIdListItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let plmn_identity = PlmnIdentity::decode(data)?;
        let available_nid_list = BroadcastNidList::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            plmn_identity,
            available_nid_list,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.plmn_identity.encode(data)?;
        self.available_nid_list.encode(data)?;

        Ok(())
    }
}

impl PerCodec for AvailableSnpnIdListItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        AvailableSnpnIdListItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("AvailableSnpnIdListItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("AvailableSnpnIdListItem");
            e
        })
    }
}
// AveragingWindow
#[derive(Clone, Copy, Debug)]
pub struct AveragingWindow(pub u16);

impl AveragingWindow {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(
            decode::decode_integer(data, Some(0), Some(4095), true)?.0 as u16,
        ))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_integer(data, Some(0), Some(4095), true, self.0 as i128, false)
    }
}

impl PerCodec for AveragingWindow {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        AveragingWindow::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("AveragingWindow");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("AveragingWindow");
            e
        })
    }
}
// AreaScope
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum AreaScope {
    True,
}

impl AreaScope {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(0), true)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(0),
            true,
            *self as i128,
            (*self as u32) >= 1,
        )
    }
}

impl PerCodec for AreaScope {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        AreaScope::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("AreaScope");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("AreaScope");
            e
        })
    }
}
// AoAAssistanceInfo
#[derive(Clone, Debug)]
pub struct AoAAssistanceInfo {
    pub angle_measurement: AngleMeasurementType,
    pub lcs_to_gcs_translation: Option<LcsToGcsTranslation>,
}

impl AoAAssistanceInfo {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 2)?;
        let angle_measurement = AngleMeasurementType::decode(data)?;
        let lcs_to_gcs_translation = if optionals[0] {
            Some(LcsToGcsTranslation::decode(data)?)
        } else {
            None
        };

        // Process the extension container

        if optionals[1] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            angle_measurement,
            lcs_to_gcs_translation,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.lcs_to_gcs_translation.is_some());
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.angle_measurement.encode(data)?;
        if let Some(x) = &self.lcs_to_gcs_translation {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl PerCodec for AoAAssistanceInfo {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        AoAAssistanceInfo::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("AoAAssistanceInfo");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("AoAAssistanceInfo");
            e
        })
    }
}
// AngleMeasurementType
#[derive(Clone, Debug)]
pub enum AngleMeasurementType {
    ExpectedUlAoA(ExpectedUlAoA),
    ExpectedZoA(ExpectedZoAOnly),
}

impl AngleMeasurementType {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_choice_idx(data, 0, 2, false)?;
        if extended {
            return Err(per_codec_error_new("CHOICE additions not implemented"));
        }
        match idx {
            0 => Ok(Self::ExpectedUlAoA(ExpectedUlAoA::decode(data)?)),
            1 => Ok(Self::ExpectedZoA(ExpectedZoAOnly::decode(data)?)),
            2 => {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _ = Criticality::decode(data)?;
                let _ = decode::decode_length_determinent(data, None, None, false)?;
                let result = match id {
                    x => Err(per_codec_error_new(format!("Unrecognised IE type {}", x))),
                };
                data.decode_align()?;
                result
            }
            _ => Err(per_codec_error_new("Unknown choice idx")),
        }
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        match self {
            Self::ExpectedUlAoA(x) => {
                encode::encode_choice_idx(data, 0, 2, false, 0, false)?;
                x.encode(data)
            }
            Self::ExpectedZoA(x) => {
                encode::encode_choice_idx(data, 0, 2, false, 1, false)?;
                x.encode(data)
            }
        }
    }
}

impl PerCodec for AngleMeasurementType {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        AngleMeasurementType::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("AngleMeasurementType");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("AngleMeasurementType");
            e
        })
    }
}
// AppLayerBufferLevelList
#[derive(Clone, Debug)]
pub struct AppLayerBufferLevelList(pub Vec<u8>);

impl AppLayerBufferLevelList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(decode::decode_octetstring(data, None, None, false)?))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_octetstring(data, None, None, false, &self.0, false)
    }
}

impl PerCodec for AppLayerBufferLevelList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        AppLayerBufferLevelList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("AppLayerBufferLevelList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("AppLayerBufferLevelList");
            e
        })
    }
}
// ArpId
#[derive(Clone, Copy, Debug)]
pub struct ArpId(pub u8);

impl ArpId {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(
            decode::decode_integer(data, Some(1), Some(16), true)?.0 as u8,
        ))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_integer(data, Some(1), Some(16), true, self.0 as i128, false)
    }
}

impl PerCodec for ArpId {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        ArpId::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ArpId");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ArpId");
            e
        })
    }
}
// ArpLocationInformation
#[derive(Clone, Debug)]
pub struct ArpLocationInformation(pub NonEmpty<ArpLocationInformationItem>);

impl ArpLocationInformation {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(16), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(ArpLocationInformationItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(16), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for ArpLocationInformation {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        ArpLocationInformation::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ArpLocationInformation");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ArpLocationInformation");
            e
        })
    }
}
// ArpLocationInformationItem
#[derive(Clone, Debug)]
pub struct ArpLocationInformationItem {
    pub arp_id: ArpId,
    pub arp_location_type: ArpLocationType,
}

impl ArpLocationInformationItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let arp_id = ArpId::decode(data)?;
        let arp_location_type = ArpLocationType::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            arp_id,
            arp_location_type,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.arp_id.encode(data)?;
        self.arp_location_type.encode(data)?;

        Ok(())
    }
}

impl PerCodec for ArpLocationInformationItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        ArpLocationInformationItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ArpLocationInformationItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ArpLocationInformationItem");
            e
        })
    }
}
// ArpLocationType
#[derive(Clone, Debug)]
pub enum ArpLocationType {
    ArpPositionRelativeGeodetic(RelativeGeodeticLocation),
    ArpPositionRelativeCartesian(RelativeCartesianLocation),
}

impl ArpLocationType {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_choice_idx(data, 0, 2, false)?;
        if extended {
            return Err(per_codec_error_new("CHOICE additions not implemented"));
        }
        match idx {
            0 => Ok(Self::ArpPositionRelativeGeodetic(
                RelativeGeodeticLocation::decode(data)?,
            )),
            1 => Ok(Self::ArpPositionRelativeCartesian(
                RelativeCartesianLocation::decode(data)?,
            )),
            2 => {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _ = Criticality::decode(data)?;
                let _ = decode::decode_length_determinent(data, None, None, false)?;
                let result = match id {
                    x => Err(per_codec_error_new(format!("Unrecognised IE type {}", x))),
                };
                data.decode_align()?;
                result
            }
            _ => Err(per_codec_error_new("Unknown choice idx")),
        }
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        match self {
            Self::ArpPositionRelativeGeodetic(x) => {
                encode::encode_choice_idx(data, 0, 2, false, 0, false)?;
                x.encode(data)
            }
            Self::ArpPositionRelativeCartesian(x) => {
                encode::encode_choice_idx(data, 0, 2, false, 1, false)?;
                x.encode(data)
            }
        }
    }
}

impl PerCodec for ArpLocationType {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        ArpLocationType::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ArpLocationType");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ArpLocationType");
            e
        })
    }
}
// BapHeaderRewritingAddedListItem
#[derive(Clone, Debug)]
pub struct BapHeaderRewritingAddedListItem {
    pub ingress_bap_routing_id: BapRoutingId,
    pub egress_bap_routing_id: BapRoutingId,
    pub non_f1terminating_topology_indicator: Option<NonF1terminatingTopologyIndicator>,
}

impl BapHeaderRewritingAddedListItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, false, 2)?;
        let ingress_bap_routing_id = BapRoutingId::decode(data)?;
        let egress_bap_routing_id = BapRoutingId::decode(data)?;
        let non_f1terminating_topology_indicator = if optionals[0] {
            Some(NonF1terminatingTopologyIndicator::decode(data)?)
        } else {
            None
        };

        // Process the extension container

        if optionals[1] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            ingress_bap_routing_id,
            egress_bap_routing_id,
            non_f1terminating_topology_indicator,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.non_f1terminating_topology_indicator.is_some());
        optionals.push(false);

        encode::encode_sequence_header(data, false, &optionals, false)?;
        self.ingress_bap_routing_id.encode(data)?;
        self.egress_bap_routing_id.encode(data)?;
        if let Some(x) = &self.non_f1terminating_topology_indicator {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl PerCodec for BapHeaderRewritingAddedListItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        BapHeaderRewritingAddedListItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("BapHeaderRewritingAddedListItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("BapHeaderRewritingAddedListItem");
            e
        })
    }
}
// BapHeaderRewritingRemovedListItem
#[derive(Clone, Debug)]
pub struct BapHeaderRewritingRemovedListItem {
    pub ingress_bap_routing_id: BapRoutingId,
}

impl BapHeaderRewritingRemovedListItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, false, 1)?;
        let ingress_bap_routing_id = BapRoutingId::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            ingress_bap_routing_id,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, false, &optionals, false)?;
        self.ingress_bap_routing_id.encode(data)?;

        Ok(())
    }
}

impl PerCodec for BapHeaderRewritingRemovedListItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        BapHeaderRewritingRemovedListItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("BapHeaderRewritingRemovedListItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("BapHeaderRewritingRemovedListItem");
            e
        })
    }
}
// BandwidthSrs
#[derive(Clone, Debug)]
pub enum BandwidthSrs {
    Fr1(Fr1Bandwidth),
    Fr2(Fr2Bandwidth),
}

impl BandwidthSrs {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_choice_idx(data, 0, 2, false)?;
        if extended {
            return Err(per_codec_error_new("CHOICE additions not implemented"));
        }
        match idx {
            0 => Ok(Self::Fr1(Fr1Bandwidth::decode(data)?)),
            1 => Ok(Self::Fr2(Fr2Bandwidth::decode(data)?)),
            2 => {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _ = Criticality::decode(data)?;
                let _ = decode::decode_length_determinent(data, None, None, false)?;
                let result = match id {
                    x => Err(per_codec_error_new(format!("Unrecognised IE type {}", x))),
                };
                data.decode_align()?;
                result
            }
            _ => Err(per_codec_error_new("Unknown choice idx")),
        }
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        match self {
            Self::Fr1(x) => {
                encode::encode_choice_idx(data, 0, 2, false, 0, false)?;
                x.encode(data)
            }
            Self::Fr2(x) => {
                encode::encode_choice_idx(data, 0, 2, false, 1, false)?;
                x.encode(data)
            }
        }
    }
}

impl PerCodec for BandwidthSrs {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        BandwidthSrs::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("BandwidthSrs");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("BandwidthSrs");
            e
        })
    }
}
// BapAddress
#[derive(Clone, Debug)]
pub struct BapAddress(pub BitString);

impl BapAddress {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(decode::decode_bitstring(
            data,
            Some(10),
            Some(10),
            false,
        )?))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_bitstring(data, Some(10), Some(10), false, &self.0, false)
    }
}

impl PerCodec for BapAddress {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        BapAddress::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("BapAddress");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("BapAddress");
            e
        })
    }
}
// BapCtrlPduChannel
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum BapCtrlPduChannel {
    True,
}

impl BapCtrlPduChannel {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(0), true)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(0),
            true,
            *self as i128,
            (*self as u32) >= 1,
        )
    }
}

impl PerCodec for BapCtrlPduChannel {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        BapCtrlPduChannel::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("BapCtrlPduChannel");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("BapCtrlPduChannel");
            e
        })
    }
}
// BaPlayerBhrlCchannelMappingInfo
#[derive(Clone, Debug)]
pub struct BaPlayerBhrlCchannelMappingInfo {
    pub ba_player_bhrl_cchannel_mapping_info_to_add: Option<BaPlayerBhrlCchannelMappingInfoList>,
    pub ba_player_bhrl_cchannel_mapping_info_to_remove: Option<MappingInformationtoRemove>,
}

impl BaPlayerBhrlCchannelMappingInfo {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 3)?;
        let ba_player_bhrl_cchannel_mapping_info_to_add = if optionals[0] {
            Some(BaPlayerBhrlCchannelMappingInfoList::decode(data)?)
        } else {
            None
        };
        let ba_player_bhrl_cchannel_mapping_info_to_remove = if optionals[1] {
            Some(MappingInformationtoRemove::decode(data)?)
        } else {
            None
        };

        // Process the extension container

        if optionals[2] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            ba_player_bhrl_cchannel_mapping_info_to_add,
            ba_player_bhrl_cchannel_mapping_info_to_remove,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.ba_player_bhrl_cchannel_mapping_info_to_add.is_some());
        optionals.push(
            self.ba_player_bhrl_cchannel_mapping_info_to_remove
                .is_some(),
        );
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        if let Some(x) = &self.ba_player_bhrl_cchannel_mapping_info_to_add {
            x.encode(data)?;
        }
        if let Some(x) = &self.ba_player_bhrl_cchannel_mapping_info_to_remove {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl PerCodec for BaPlayerBhrlCchannelMappingInfo {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        BaPlayerBhrlCchannelMappingInfo::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("BaPlayerBhrlCchannelMappingInfo");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("BaPlayerBhrlCchannelMappingInfo");
            e
        })
    }
}
// BaPlayerBhrlCchannelMappingInfoList
#[derive(Clone, Debug)]
pub struct BaPlayerBhrlCchannelMappingInfoList(pub NonEmpty<BaPlayerBhrlCchannelMappingInfoItem>);

impl BaPlayerBhrlCchannelMappingInfoList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(67108864), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(BaPlayerBhrlCchannelMappingInfoItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(67108864), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for BaPlayerBhrlCchannelMappingInfoList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        BaPlayerBhrlCchannelMappingInfoList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("BaPlayerBhrlCchannelMappingInfoList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("BaPlayerBhrlCchannelMappingInfoList");
            e
        })
    }
}
// BaPlayerBhrlCchannelMappingInfoItem
#[derive(Clone, Debug)]
pub struct BaPlayerBhrlCchannelMappingInfoItem {
    pub mapping_information_index: MappingInformationIndex,
    pub prior_hop_bap_address: Option<BapAddress>,
    pub ingressb_hrlc_channel_id: Option<BhrlcChannelId>,
    pub next_hop_bap_address: Option<BapAddress>,
    pub egressb_hrlc_channel_id: Option<BhrlcChannelId>,
    pub ingress_non_f1terminating_topology_indicator:
        Option<IngressNonF1terminatingTopologyIndicator>,
    pub egress_non_f1terminating_topology_indicator:
        Option<EgressNonF1terminatingTopologyIndicator>,
}

impl BaPlayerBhrlCchannelMappingInfoItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 5)?;
        let mapping_information_index = MappingInformationIndex::decode(data)?;
        let prior_hop_bap_address = if optionals[0] {
            Some(BapAddress::decode(data)?)
        } else {
            None
        };
        let ingressb_hrlc_channel_id = if optionals[1] {
            Some(BhrlcChannelId::decode(data)?)
        } else {
            None
        };
        let next_hop_bap_address = if optionals[2] {
            Some(BapAddress::decode(data)?)
        } else {
            None
        };
        let egressb_hrlc_channel_id = if optionals[3] {
            Some(BhrlcChannelId::decode(data)?)
        } else {
            None
        };

        // Process the extension container
        let mut ingress_non_f1terminating_topology_indicator: Option<
            IngressNonF1terminatingTopologyIndicator,
        > = None;
        let mut egress_non_f1terminating_topology_indicator: Option<
            EgressNonF1terminatingTopologyIndicator,
        > = None;

        if optionals[4] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    519 => {
                        ingress_non_f1terminating_topology_indicator =
                            Some(IngressNonF1terminatingTopologyIndicator::decode(data)?)
                    }
                    518 => {
                        egress_non_f1terminating_topology_indicator =
                            Some(EgressNonF1terminatingTopologyIndicator::decode(data)?)
                    }
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            mapping_information_index,
            prior_hop_bap_address,
            ingressb_hrlc_channel_id,
            next_hop_bap_address,
            egressb_hrlc_channel_id,
            ingress_non_f1terminating_topology_indicator,
            egress_non_f1terminating_topology_indicator,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();
        if let Some(x) = &self.ingress_non_f1terminating_topology_indicator {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 519, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.egress_non_f1terminating_topology_indicator {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 518, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        let mut optionals = BitString::new();
        optionals.push(self.prior_hop_bap_address.is_some());
        optionals.push(self.ingressb_hrlc_channel_id.is_some());
        optionals.push(self.next_hop_bap_address.is_some());
        optionals.push(self.egressb_hrlc_channel_id.is_some());
        optionals.push(num_ies != 0);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.mapping_information_index.encode(data)?;
        if let Some(x) = &self.prior_hop_bap_address {
            x.encode(data)?;
        }
        if let Some(x) = &self.ingressb_hrlc_channel_id {
            x.encode(data)?;
        }
        if let Some(x) = &self.next_hop_bap_address {
            x.encode(data)?;
        }
        if let Some(x) = &self.egressb_hrlc_channel_id {
            x.encode(data)?;
        }
        if num_ies != 0 {
            encode::encode_length_determinent(data, Some(1), Some(65535), false, num_ies)?;
            data.append_aligned(ies);
        }
        Ok(())
    }
}

impl PerCodec for BaPlayerBhrlCchannelMappingInfoItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        BaPlayerBhrlCchannelMappingInfoItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("BaPlayerBhrlCchannelMappingInfoItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("BaPlayerBhrlCchannelMappingInfoItem");
            e
        })
    }
}
// BapPathId
#[derive(Clone, Debug)]
pub struct BapPathId(pub BitString);

impl BapPathId {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(decode::decode_bitstring(
            data,
            Some(10),
            Some(10),
            false,
        )?))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_bitstring(data, Some(10), Some(10), false, &self.0, false)
    }
}

impl PerCodec for BapPathId {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        BapPathId::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("BapPathId");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("BapPathId");
            e
        })
    }
}
// BapRoutingId
#[derive(Clone, Debug)]
pub struct BapRoutingId {
    pub bap_address: BapAddress,
    pub bap_path_id: BapPathId,
}

impl BapRoutingId {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, false, 1)?;
        let bap_address = BapAddress::decode(data)?;
        let bap_path_id = BapPathId::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            bap_address,
            bap_path_id,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, false, &optionals, false)?;
        self.bap_address.encode(data)?;
        self.bap_path_id.encode(data)?;

        Ok(())
    }
}

impl PerCodec for BapRoutingId {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        BapRoutingId::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("BapRoutingId");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("BapRoutingId");
            e
        })
    }
}
// BarringExemptionforEmerCallInfo
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum BarringExemptionforEmerCallInfo {
    True,
}

impl BarringExemptionforEmerCallInfo {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(0), true)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(0),
            true,
            *self as i128,
            (*self as u32) >= 1,
        )
    }
}

impl PerCodec for BarringExemptionforEmerCallInfo {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        BarringExemptionforEmerCallInfo::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("BarringExemptionforEmerCallInfo");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("BarringExemptionforEmerCallInfo");
            e
        })
    }
}
// BcBearerContextF1uTnlInfo
#[derive(Clone, Debug)]
pub enum BcBearerContextF1uTnlInfo {
    Locationindpendent(Mbsf1uInformation),
    Locationdependent(LocationDependentMbsf1uInformation),
}

impl BcBearerContextF1uTnlInfo {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_choice_idx(data, 0, 2, false)?;
        if extended {
            return Err(per_codec_error_new("CHOICE additions not implemented"));
        }
        match idx {
            0 => Ok(Self::Locationindpendent(Mbsf1uInformation::decode(data)?)),
            1 => Ok(Self::Locationdependent(
                LocationDependentMbsf1uInformation::decode(data)?,
            )),
            2 => {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _ = Criticality::decode(data)?;
                let _ = decode::decode_length_determinent(data, None, None, false)?;
                let result = match id {
                    x => Err(per_codec_error_new(format!("Unrecognised IE type {}", x))),
                };
                data.decode_align()?;
                result
            }
            _ => Err(per_codec_error_new("Unknown choice idx")),
        }
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        match self {
            Self::Locationindpendent(x) => {
                encode::encode_choice_idx(data, 0, 2, false, 0, false)?;
                x.encode(data)
            }
            Self::Locationdependent(x) => {
                encode::encode_choice_idx(data, 0, 2, false, 1, false)?;
                x.encode(data)
            }
        }
    }
}

impl PerCodec for BcBearerContextF1uTnlInfo {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        BcBearerContextF1uTnlInfo::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("BcBearerContextF1uTnlInfo");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("BcBearerContextF1uTnlInfo");
            e
        })
    }
}
// BitRate
#[derive(Clone, Copy, Debug)]
pub struct BitRate(pub u64);

impl BitRate {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(
            decode::decode_integer(data, Some(0), Some(4000000000000), true)?.0 as u64,
        ))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_integer(
            data,
            Some(0),
            Some(4000000000000),
            true,
            self.0 as i128,
            false,
        )
    }
}

impl PerCodec for BitRate {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        BitRate::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("BitRate");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("BitRate");
            e
        })
    }
}
// BearerTypeChange
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum BearerTypeChange {
    True,
}

impl BearerTypeChange {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(0), true)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(0),
            true,
            *self as i128,
            (*self as u32) >= 1,
        )
    }
}

impl PerCodec for BearerTypeChange {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        BearerTypeChange::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("BearerTypeChange");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("BearerTypeChange");
            e
        })
    }
}
// BhrlcChannelId
#[derive(Clone, Debug)]
pub struct BhrlcChannelId(pub BitString);

impl BhrlcChannelId {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(decode::decode_bitstring(
            data,
            Some(16),
            Some(16),
            false,
        )?))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_bitstring(data, Some(16), Some(16), false, &self.0, false)
    }
}

impl PerCodec for BhrlcChannelId {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        BhrlcChannelId::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("BhrlcChannelId");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("BhrlcChannelId");
            e
        })
    }
}
// BhChannelsFailedToBeModifiedItem
#[derive(Clone, Debug)]
pub struct BhChannelsFailedToBeModifiedItem {
    pub bhrlc_channel_id: BhrlcChannelId,
    pub cause: Option<Cause>,
}

impl BhChannelsFailedToBeModifiedItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, false, 2)?;
        let bhrlc_channel_id = BhrlcChannelId::decode(data)?;
        let cause = if optionals[0] {
            Some(Cause::decode(data)?)
        } else {
            None
        };

        // Process the extension container

        if optionals[1] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            bhrlc_channel_id,
            cause,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.cause.is_some());
        optionals.push(false);

        encode::encode_sequence_header(data, false, &optionals, false)?;
        self.bhrlc_channel_id.encode(data)?;
        if let Some(x) = &self.cause {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl PerCodec for BhChannelsFailedToBeModifiedItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        BhChannelsFailedToBeModifiedItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("BhChannelsFailedToBeModifiedItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("BhChannelsFailedToBeModifiedItem");
            e
        })
    }
}
// BhChannelsFailedToBeSetupItem
#[derive(Clone, Debug)]
pub struct BhChannelsFailedToBeSetupItem {
    pub bhrlc_channel_id: BhrlcChannelId,
    pub cause: Option<Cause>,
}

impl BhChannelsFailedToBeSetupItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, false, 2)?;
        let bhrlc_channel_id = BhrlcChannelId::decode(data)?;
        let cause = if optionals[0] {
            Some(Cause::decode(data)?)
        } else {
            None
        };

        // Process the extension container

        if optionals[1] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            bhrlc_channel_id,
            cause,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.cause.is_some());
        optionals.push(false);

        encode::encode_sequence_header(data, false, &optionals, false)?;
        self.bhrlc_channel_id.encode(data)?;
        if let Some(x) = &self.cause {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl PerCodec for BhChannelsFailedToBeSetupItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        BhChannelsFailedToBeSetupItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("BhChannelsFailedToBeSetupItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("BhChannelsFailedToBeSetupItem");
            e
        })
    }
}
// BhChannelsFailedToBeSetupModItem
#[derive(Clone, Debug)]
pub struct BhChannelsFailedToBeSetupModItem {
    pub bhrlc_channel_id: BhrlcChannelId,
    pub cause: Option<Cause>,
}

impl BhChannelsFailedToBeSetupModItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, false, 2)?;
        let bhrlc_channel_id = BhrlcChannelId::decode(data)?;
        let cause = if optionals[0] {
            Some(Cause::decode(data)?)
        } else {
            None
        };

        // Process the extension container

        if optionals[1] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            bhrlc_channel_id,
            cause,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.cause.is_some());
        optionals.push(false);

        encode::encode_sequence_header(data, false, &optionals, false)?;
        self.bhrlc_channel_id.encode(data)?;
        if let Some(x) = &self.cause {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl PerCodec for BhChannelsFailedToBeSetupModItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        BhChannelsFailedToBeSetupModItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("BhChannelsFailedToBeSetupModItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("BhChannelsFailedToBeSetupModItem");
            e
        })
    }
}
// BhChannelsModifiedItem
#[derive(Clone, Debug)]
pub struct BhChannelsModifiedItem {
    pub bhrlc_channel_id: BhrlcChannelId,
}

impl BhChannelsModifiedItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, false, 1)?;
        let bhrlc_channel_id = BhrlcChannelId::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self { bhrlc_channel_id })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, false, &optionals, false)?;
        self.bhrlc_channel_id.encode(data)?;

        Ok(())
    }
}

impl PerCodec for BhChannelsModifiedItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        BhChannelsModifiedItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("BhChannelsModifiedItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("BhChannelsModifiedItem");
            e
        })
    }
}
// BhChannelsRequiredToBeReleasedItem
#[derive(Clone, Debug)]
pub struct BhChannelsRequiredToBeReleasedItem {
    pub bhrlc_channel_id: BhrlcChannelId,
}

impl BhChannelsRequiredToBeReleasedItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, false, 1)?;
        let bhrlc_channel_id = BhrlcChannelId::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self { bhrlc_channel_id })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, false, &optionals, false)?;
        self.bhrlc_channel_id.encode(data)?;

        Ok(())
    }
}

impl PerCodec for BhChannelsRequiredToBeReleasedItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        BhChannelsRequiredToBeReleasedItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("BhChannelsRequiredToBeReleasedItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("BhChannelsRequiredToBeReleasedItem");
            e
        })
    }
}
// BhChannelsSetupItem
#[derive(Clone, Debug)]
pub struct BhChannelsSetupItem {
    pub bhrlc_channel_id: BhrlcChannelId,
}

impl BhChannelsSetupItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, false, 1)?;
        let bhrlc_channel_id = BhrlcChannelId::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self { bhrlc_channel_id })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, false, &optionals, false)?;
        self.bhrlc_channel_id.encode(data)?;

        Ok(())
    }
}

impl PerCodec for BhChannelsSetupItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        BhChannelsSetupItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("BhChannelsSetupItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("BhChannelsSetupItem");
            e
        })
    }
}
// BhChannelsSetupModItem
#[derive(Clone, Debug)]
pub struct BhChannelsSetupModItem {
    pub bhrlc_channel_id: BhrlcChannelId,
}

impl BhChannelsSetupModItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, false, 1)?;
        let bhrlc_channel_id = BhrlcChannelId::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self { bhrlc_channel_id })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, false, &optionals, false)?;
        self.bhrlc_channel_id.encode(data)?;

        Ok(())
    }
}

impl PerCodec for BhChannelsSetupModItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        BhChannelsSetupModItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("BhChannelsSetupModItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("BhChannelsSetupModItem");
            e
        })
    }
}
// BhChannelsToBeModifiedItem
#[derive(Clone, Debug)]
pub struct BhChannelsToBeModifiedItem {
    pub bhrlc_channel_id: BhrlcChannelId,
    pub bh_qos_information: BhQosInformation,
    pub rl_cmode: Option<RlcMode>,
    pub bap_ctrl_pdu_channel: Option<BapCtrlPduChannel>,
    pub traffic_mapping_info: Option<TrafficMappingInfo>,
}

impl BhChannelsToBeModifiedItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, false, 4)?;
        let bhrlc_channel_id = BhrlcChannelId::decode(data)?;
        let bh_qos_information = BhQosInformation::decode(data)?;
        let rl_cmode = if optionals[0] {
            Some(RlcMode::decode(data)?)
        } else {
            None
        };
        let bap_ctrl_pdu_channel = if optionals[1] {
            Some(BapCtrlPduChannel::decode(data)?)
        } else {
            None
        };
        let traffic_mapping_info = if optionals[2] {
            Some(TrafficMappingInfo::decode(data)?)
        } else {
            None
        };

        // Process the extension container

        if optionals[3] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            bhrlc_channel_id,
            bh_qos_information,
            rl_cmode,
            bap_ctrl_pdu_channel,
            traffic_mapping_info,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.rl_cmode.is_some());
        optionals.push(self.bap_ctrl_pdu_channel.is_some());
        optionals.push(self.traffic_mapping_info.is_some());
        optionals.push(false);

        encode::encode_sequence_header(data, false, &optionals, false)?;
        self.bhrlc_channel_id.encode(data)?;
        self.bh_qos_information.encode(data)?;
        if let Some(x) = &self.rl_cmode {
            x.encode(data)?;
        }
        if let Some(x) = &self.bap_ctrl_pdu_channel {
            x.encode(data)?;
        }
        if let Some(x) = &self.traffic_mapping_info {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl PerCodec for BhChannelsToBeModifiedItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        BhChannelsToBeModifiedItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("BhChannelsToBeModifiedItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("BhChannelsToBeModifiedItem");
            e
        })
    }
}
// BhChannelsToBeReleasedItem
#[derive(Clone, Debug)]
pub struct BhChannelsToBeReleasedItem {
    pub bhrlc_channel_id: BhrlcChannelId,
}

impl BhChannelsToBeReleasedItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, false, 1)?;
        let bhrlc_channel_id = BhrlcChannelId::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self { bhrlc_channel_id })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, false, &optionals, false)?;
        self.bhrlc_channel_id.encode(data)?;

        Ok(())
    }
}

impl PerCodec for BhChannelsToBeReleasedItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        BhChannelsToBeReleasedItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("BhChannelsToBeReleasedItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("BhChannelsToBeReleasedItem");
            e
        })
    }
}
// BhChannelsToBeSetupItem
#[derive(Clone, Debug)]
pub struct BhChannelsToBeSetupItem {
    pub bhrlc_channel_id: BhrlcChannelId,
    pub bh_qos_information: BhQosInformation,
    pub rl_cmode: RlcMode,
    pub bap_ctrl_pdu_channel: Option<BapCtrlPduChannel>,
    pub traffic_mapping_info: Option<TrafficMappingInfo>,
}

impl BhChannelsToBeSetupItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, false, 3)?;
        let bhrlc_channel_id = BhrlcChannelId::decode(data)?;
        let bh_qos_information = BhQosInformation::decode(data)?;
        let rl_cmode = RlcMode::decode(data)?;
        let bap_ctrl_pdu_channel = if optionals[0] {
            Some(BapCtrlPduChannel::decode(data)?)
        } else {
            None
        };
        let traffic_mapping_info = if optionals[1] {
            Some(TrafficMappingInfo::decode(data)?)
        } else {
            None
        };

        // Process the extension container

        if optionals[2] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            bhrlc_channel_id,
            bh_qos_information,
            rl_cmode,
            bap_ctrl_pdu_channel,
            traffic_mapping_info,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.bap_ctrl_pdu_channel.is_some());
        optionals.push(self.traffic_mapping_info.is_some());
        optionals.push(false);

        encode::encode_sequence_header(data, false, &optionals, false)?;
        self.bhrlc_channel_id.encode(data)?;
        self.bh_qos_information.encode(data)?;
        self.rl_cmode.encode(data)?;
        if let Some(x) = &self.bap_ctrl_pdu_channel {
            x.encode(data)?;
        }
        if let Some(x) = &self.traffic_mapping_info {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl PerCodec for BhChannelsToBeSetupItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        BhChannelsToBeSetupItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("BhChannelsToBeSetupItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("BhChannelsToBeSetupItem");
            e
        })
    }
}
// BhChannelsToBeSetupModItem
#[derive(Clone, Debug)]
pub struct BhChannelsToBeSetupModItem {
    pub bhrlc_channel_id: BhrlcChannelId,
    pub bh_qos_information: BhQosInformation,
    pub rl_cmode: RlcMode,
    pub bap_ctrl_pdu_channel: Option<BapCtrlPduChannel>,
    pub traffic_mapping_info: Option<TrafficMappingInfo>,
}

impl BhChannelsToBeSetupModItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, false, 3)?;
        let bhrlc_channel_id = BhrlcChannelId::decode(data)?;
        let bh_qos_information = BhQosInformation::decode(data)?;
        let rl_cmode = RlcMode::decode(data)?;
        let bap_ctrl_pdu_channel = if optionals[0] {
            Some(BapCtrlPduChannel::decode(data)?)
        } else {
            None
        };
        let traffic_mapping_info = if optionals[1] {
            Some(TrafficMappingInfo::decode(data)?)
        } else {
            None
        };

        // Process the extension container

        if optionals[2] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            bhrlc_channel_id,
            bh_qos_information,
            rl_cmode,
            bap_ctrl_pdu_channel,
            traffic_mapping_info,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.bap_ctrl_pdu_channel.is_some());
        optionals.push(self.traffic_mapping_info.is_some());
        optionals.push(false);

        encode::encode_sequence_header(data, false, &optionals, false)?;
        self.bhrlc_channel_id.encode(data)?;
        self.bh_qos_information.encode(data)?;
        self.rl_cmode.encode(data)?;
        if let Some(x) = &self.bap_ctrl_pdu_channel {
            x.encode(data)?;
        }
        if let Some(x) = &self.traffic_mapping_info {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl PerCodec for BhChannelsToBeSetupModItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        BhChannelsToBeSetupModItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("BhChannelsToBeSetupModItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("BhChannelsToBeSetupModItem");
            e
        })
    }
}
// BhInfo
#[derive(Clone, Debug)]
pub struct BhInfo {
    pub ba_prouting_id: Option<BapRoutingId>,
    pub egress_bhrlcch_list: Option<EgressBhrlcchList>,
    pub non_f1terminating_topology_indicator: Option<NonF1terminatingTopologyIndicator>,
}

impl BhInfo {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, false, 3)?;
        let ba_prouting_id = if optionals[0] {
            Some(BapRoutingId::decode(data)?)
        } else {
            None
        };
        let egress_bhrlcch_list = if optionals[1] {
            Some(EgressBhrlcchList::decode(data)?)
        } else {
            None
        };

        // Process the extension container
        let mut non_f1terminating_topology_indicator: Option<NonF1terminatingTopologyIndicator> =
            None;

        if optionals[2] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    517 => {
                        non_f1terminating_topology_indicator =
                            Some(NonF1terminatingTopologyIndicator::decode(data)?)
                    }
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            ba_prouting_id,
            egress_bhrlcch_list,
            non_f1terminating_topology_indicator,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();
        if let Some(x) = &self.non_f1terminating_topology_indicator {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 517, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        let mut optionals = BitString::new();
        optionals.push(self.ba_prouting_id.is_some());
        optionals.push(self.egress_bhrlcch_list.is_some());
        optionals.push(num_ies != 0);

        encode::encode_sequence_header(data, false, &optionals, false)?;
        if let Some(x) = &self.ba_prouting_id {
            x.encode(data)?;
        }
        if let Some(x) = &self.egress_bhrlcch_list {
            x.encode(data)?;
        }
        if num_ies != 0 {
            encode::encode_length_determinent(data, Some(1), Some(65535), false, num_ies)?;
            data.append_aligned(ies);
        }
        Ok(())
    }
}

impl PerCodec for BhInfo {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        BhInfo::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("BhInfo");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("BhInfo");
            e
        })
    }
}
// BhQosInformation
#[derive(Clone, Debug)]
pub enum BhQosInformation {
    BhrlcchQos(QosFlowLevelQosParameters),
    EutranBhrlcchQos(EutranQos),
    CpTrafficType(CpTrafficType),
}

impl BhQosInformation {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_choice_idx(data, 0, 3, false)?;
        if extended {
            return Err(per_codec_error_new("CHOICE additions not implemented"));
        }
        match idx {
            0 => Ok(Self::BhrlcchQos(QosFlowLevelQosParameters::decode(data)?)),
            1 => Ok(Self::EutranBhrlcchQos(EutranQos::decode(data)?)),
            2 => Ok(Self::CpTrafficType(CpTrafficType::decode(data)?)),
            3 => {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _ = Criticality::decode(data)?;
                let _ = decode::decode_length_determinent(data, None, None, false)?;
                let result = match id {
                    x => Err(per_codec_error_new(format!("Unrecognised IE type {}", x))),
                };
                data.decode_align()?;
                result
            }
            _ => Err(per_codec_error_new("Unknown choice idx")),
        }
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        match self {
            Self::BhrlcchQos(x) => {
                encode::encode_choice_idx(data, 0, 3, false, 0, false)?;
                x.encode(data)
            }
            Self::EutranBhrlcchQos(x) => {
                encode::encode_choice_idx(data, 0, 3, false, 1, false)?;
                x.encode(data)
            }
            Self::CpTrafficType(x) => {
                encode::encode_choice_idx(data, 0, 3, false, 2, false)?;
                x.encode(data)
            }
        }
    }
}

impl PerCodec for BhQosInformation {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        BhQosInformation::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("BhQosInformation");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("BhQosInformation");
            e
        })
    }
}
// BhrlcchList
#[derive(Clone, Debug)]
pub struct BhrlcchList(pub NonEmpty<BhrlcchItem>);

impl BhrlcchList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(65536), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(BhrlcchItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(65536), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for BhrlcchList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        BhrlcchList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("BhrlcchList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("BhrlcchList");
            e
        })
    }
}
// BhrlcchItem
#[derive(Clone, Debug)]
pub struct BhrlcchItem {
    pub bhrlc_channel_id: BhrlcChannelId,
}

impl BhrlcchItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, false, 1)?;
        let bhrlc_channel_id = BhrlcChannelId::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self { bhrlc_channel_id })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, false, &optionals, false)?;
        self.bhrlc_channel_id.encode(data)?;

        Ok(())
    }
}

impl PerCodec for BhrlcchItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        BhrlcchItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("BhrlcchItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("BhrlcchItem");
            e
        })
    }
}
// BhRoutingInformationAddedListItem
#[derive(Clone, Debug)]
pub struct BhRoutingInformationAddedListItem {
    pub bap_routing_id: BapRoutingId,
    pub next_hop_bap_address: BapAddress,
    pub non_f1terminating_topology_indicator: Option<NonF1terminatingTopologyIndicator>,
}

impl BhRoutingInformationAddedListItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, false, 1)?;
        let bap_routing_id = BapRoutingId::decode(data)?;
        let next_hop_bap_address = BapAddress::decode(data)?;

        // Process the extension container
        let mut non_f1terminating_topology_indicator: Option<NonF1terminatingTopologyIndicator> =
            None;

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    517 => {
                        non_f1terminating_topology_indicator =
                            Some(NonF1terminatingTopologyIndicator::decode(data)?)
                    }
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            bap_routing_id,
            next_hop_bap_address,
            non_f1terminating_topology_indicator,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();
        if let Some(x) = &self.non_f1terminating_topology_indicator {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 517, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        let mut optionals = BitString::new();
        optionals.push(num_ies != 0);

        encode::encode_sequence_header(data, false, &optionals, false)?;
        self.bap_routing_id.encode(data)?;
        self.next_hop_bap_address.encode(data)?;
        if num_ies != 0 {
            encode::encode_length_determinent(data, Some(1), Some(65535), false, num_ies)?;
            data.append_aligned(ies);
        }
        Ok(())
    }
}

impl PerCodec for BhRoutingInformationAddedListItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        BhRoutingInformationAddedListItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("BhRoutingInformationAddedListItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("BhRoutingInformationAddedListItem");
            e
        })
    }
}
// BhRoutingInformationRemovedListItem
#[derive(Clone, Debug)]
pub struct BhRoutingInformationRemovedListItem {
    pub bap_routing_id: BapRoutingId,
}

impl BhRoutingInformationRemovedListItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, false, 1)?;
        let bap_routing_id = BapRoutingId::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self { bap_routing_id })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, false, &optionals, false)?;
        self.bap_routing_id.encode(data)?;

        Ok(())
    }
}

impl PerCodec for BhRoutingInformationRemovedListItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        BhRoutingInformationRemovedListItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("BhRoutingInformationRemovedListItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("BhRoutingInformationRemovedListItem");
            e
        })
    }
}
// BPlmnIdInfoList
#[derive(Clone, Debug)]
pub struct BPlmnIdInfoList(pub NonEmpty<BPlmnIdInfoItem>);

impl BPlmnIdInfoList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(12), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(BPlmnIdInfoItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(12), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for BPlmnIdInfoList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        BPlmnIdInfoList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("BPlmnIdInfoList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("BPlmnIdInfoList");
            e
        })
    }
}
// BPlmnIdInfoItem
#[derive(Clone, Debug)]
pub struct BPlmnIdInfoItem {
    pub plmn_identity_list: AvailablePlmnList,
    pub extended_plmn_identity_list: Option<ExtendedAvailablePlmnList>,
    pub five_gs_tac: Option<FiveGsTac>,
    pub nr_cell_id: NrCellIdentity,
    pub ranac: Option<Ranac>,
    pub configured_tac_indication: Option<ConfiguredTacIndication>,
    pub npn_broadcast_information: Option<NpnBroadcastInformation>,
}

impl BPlmnIdInfoItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 4)?;
        let plmn_identity_list = AvailablePlmnList::decode(data)?;
        let extended_plmn_identity_list = if optionals[0] {
            Some(ExtendedAvailablePlmnList::decode(data)?)
        } else {
            None
        };
        let five_gs_tac = if optionals[1] {
            Some(FiveGsTac::decode(data)?)
        } else {
            None
        };
        let nr_cell_id = NrCellIdentity::decode(data)?;
        let ranac = if optionals[2] {
            Some(Ranac::decode(data)?)
        } else {
            None
        };

        // Process the extension container
        let mut configured_tac_indication: Option<ConfiguredTacIndication> = None;
        let mut npn_broadcast_information: Option<NpnBroadcastInformation> = None;

        if optionals[3] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    425 => configured_tac_indication = Some(ConfiguredTacIndication::decode(data)?),
                    383 => npn_broadcast_information = Some(NpnBroadcastInformation::decode(data)?),
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            plmn_identity_list,
            extended_plmn_identity_list,
            five_gs_tac,
            nr_cell_id,
            ranac,
            configured_tac_indication,
            npn_broadcast_information,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();
        if let Some(x) = &self.configured_tac_indication {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 425, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.npn_broadcast_information {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 383, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        let mut optionals = BitString::new();
        optionals.push(self.extended_plmn_identity_list.is_some());
        optionals.push(self.five_gs_tac.is_some());
        optionals.push(self.ranac.is_some());
        optionals.push(num_ies != 0);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.plmn_identity_list.encode(data)?;
        if let Some(x) = &self.extended_plmn_identity_list {
            x.encode(data)?;
        }
        if let Some(x) = &self.five_gs_tac {
            x.encode(data)?;
        }
        self.nr_cell_id.encode(data)?;
        if let Some(x) = &self.ranac {
            x.encode(data)?;
        }
        if num_ies != 0 {
            encode::encode_length_determinent(data, Some(1), Some(65535), false, num_ies)?;
            data.append_aligned(ies);
        }
        Ok(())
    }
}

impl PerCodec for BPlmnIdInfoItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        BPlmnIdInfoItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("BPlmnIdInfoItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("BPlmnIdInfoItem");
            e
        })
    }
}
// ServedPlmnsList
#[derive(Clone, Debug)]
pub struct ServedPlmnsList(pub NonEmpty<ServedPlmnsItem>);

impl ServedPlmnsList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(6), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(ServedPlmnsItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(6), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for ServedPlmnsList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        ServedPlmnsList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ServedPlmnsList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ServedPlmnsList");
            e
        })
    }
}
// ServedPlmnsItem
#[derive(Clone, Debug)]
pub struct ServedPlmnsItem {
    pub plmn_identity: PlmnIdentity,
    pub tai_slice_support_list: Option<SliceSupportList>,
    pub npn_support_info: Option<NpnSupportInfo>,
    pub extended_tai_slice_support_list: Option<ExtendedSliceSupportList>,
    pub tainsag_support_list: Option<NsagSupportList>,
}

impl ServedPlmnsItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let plmn_identity = PlmnIdentity::decode(data)?;

        // Process the extension container
        let mut tai_slice_support_list: Option<SliceSupportList> = None;
        let mut npn_support_info: Option<NpnSupportInfo> = None;
        let mut extended_tai_slice_support_list: Option<ExtendedSliceSupportList> = None;
        let mut tainsag_support_list: Option<NsagSupportList> = None;

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    131 => tai_slice_support_list = Some(SliceSupportList::decode(data)?),
                    384 => npn_support_info = Some(NpnSupportInfo::decode(data)?),
                    390 => {
                        extended_tai_slice_support_list =
                            Some(ExtendedSliceSupportList::decode(data)?)
                    }
                    644 => tainsag_support_list = Some(NsagSupportList::decode(data)?),
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            plmn_identity,
            tai_slice_support_list,
            npn_support_info,
            extended_tai_slice_support_list,
            tainsag_support_list,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();
        if let Some(x) = &self.tai_slice_support_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 131, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.npn_support_info {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 384, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.extended_tai_slice_support_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 390, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.tainsag_support_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 644, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        let mut optionals = BitString::new();
        optionals.push(num_ies != 0);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.plmn_identity.encode(data)?;
        if num_ies != 0 {
            encode::encode_length_determinent(data, Some(1), Some(65535), false, num_ies)?;
            data.append_aligned(ies);
        }
        Ok(())
    }
}

impl PerCodec for ServedPlmnsItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        ServedPlmnsItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ServedPlmnsItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ServedPlmnsItem");
            e
        })
    }
}
// BroadcastCagList
#[derive(Clone, Debug)]
pub struct BroadcastCagList(pub NonEmpty<Cagid>);

impl BroadcastCagList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(12), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(Cagid::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(12), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for BroadcastCagList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        BroadcastCagList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("BroadcastCagList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("BroadcastCagList");
            e
        })
    }
}
// BroadcastMrBsFailedToBeModifiedItem
#[derive(Clone, Debug)]
pub struct BroadcastMrBsFailedToBeModifiedItem {
    pub mrb_id: MrbId,
    pub cause: Option<Cause>,
}

impl BroadcastMrBsFailedToBeModifiedItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 2)?;
        let mrb_id = MrbId::decode(data)?;
        let cause = if optionals[0] {
            Some(Cause::decode(data)?)
        } else {
            None
        };

        // Process the extension container

        if optionals[1] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self { mrb_id, cause })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.cause.is_some());
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.mrb_id.encode(data)?;
        if let Some(x) = &self.cause {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl PerCodec for BroadcastMrBsFailedToBeModifiedItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        BroadcastMrBsFailedToBeModifiedItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("BroadcastMrBsFailedToBeModifiedItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("BroadcastMrBsFailedToBeModifiedItem");
            e
        })
    }
}
// BroadcastMrBsFailedToBeSetupItem
#[derive(Clone, Debug)]
pub struct BroadcastMrBsFailedToBeSetupItem {
    pub mrb_id: MrbId,
    pub cause: Option<Cause>,
}

impl BroadcastMrBsFailedToBeSetupItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 2)?;
        let mrb_id = MrbId::decode(data)?;
        let cause = if optionals[0] {
            Some(Cause::decode(data)?)
        } else {
            None
        };

        // Process the extension container

        if optionals[1] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self { mrb_id, cause })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.cause.is_some());
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.mrb_id.encode(data)?;
        if let Some(x) = &self.cause {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl PerCodec for BroadcastMrBsFailedToBeSetupItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        BroadcastMrBsFailedToBeSetupItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("BroadcastMrBsFailedToBeSetupItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("BroadcastMrBsFailedToBeSetupItem");
            e
        })
    }
}
// BroadcastMrBsFailedToBeSetupModItem
#[derive(Clone, Debug)]
pub struct BroadcastMrBsFailedToBeSetupModItem {
    pub mrb_id: MrbId,
    pub cause: Option<Cause>,
}

impl BroadcastMrBsFailedToBeSetupModItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 2)?;
        let mrb_id = MrbId::decode(data)?;
        let cause = if optionals[0] {
            Some(Cause::decode(data)?)
        } else {
            None
        };

        // Process the extension container

        if optionals[1] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self { mrb_id, cause })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.cause.is_some());
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.mrb_id.encode(data)?;
        if let Some(x) = &self.cause {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl PerCodec for BroadcastMrBsFailedToBeSetupModItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        BroadcastMrBsFailedToBeSetupModItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("BroadcastMrBsFailedToBeSetupModItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("BroadcastMrBsFailedToBeSetupModItem");
            e
        })
    }
}
// BroadcastMrBsModifiedItem
#[derive(Clone, Debug)]
pub struct BroadcastMrBsModifiedItem {
    pub mrb_id: MrbId,
    pub bc_bearer_ctxt_f1u_tnl_infoat_du: Option<BcBearerContextF1uTnlInfo>,
}

impl BroadcastMrBsModifiedItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 2)?;
        let mrb_id = MrbId::decode(data)?;
        let bc_bearer_ctxt_f1u_tnl_infoat_du = if optionals[0] {
            Some(BcBearerContextF1uTnlInfo::decode(data)?)
        } else {
            None
        };

        // Process the extension container

        if optionals[1] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            mrb_id,
            bc_bearer_ctxt_f1u_tnl_infoat_du,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.bc_bearer_ctxt_f1u_tnl_infoat_du.is_some());
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.mrb_id.encode(data)?;
        if let Some(x) = &self.bc_bearer_ctxt_f1u_tnl_infoat_du {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl PerCodec for BroadcastMrBsModifiedItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        BroadcastMrBsModifiedItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("BroadcastMrBsModifiedItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("BroadcastMrBsModifiedItem");
            e
        })
    }
}
// BroadcastMrBsSetupItem
#[derive(Clone, Debug)]
pub struct BroadcastMrBsSetupItem {
    pub mrb_id: MrbId,
    pub bc_bearer_ctxt_f1u_tnl_infoat_du: BcBearerContextF1uTnlInfo,
}

impl BroadcastMrBsSetupItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let mrb_id = MrbId::decode(data)?;
        let bc_bearer_ctxt_f1u_tnl_infoat_du = BcBearerContextF1uTnlInfo::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            mrb_id,
            bc_bearer_ctxt_f1u_tnl_infoat_du,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.mrb_id.encode(data)?;
        self.bc_bearer_ctxt_f1u_tnl_infoat_du.encode(data)?;

        Ok(())
    }
}

impl PerCodec for BroadcastMrBsSetupItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        BroadcastMrBsSetupItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("BroadcastMrBsSetupItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("BroadcastMrBsSetupItem");
            e
        })
    }
}
// BroadcastMrBsSetupModItem
#[derive(Clone, Debug)]
pub struct BroadcastMrBsSetupModItem {
    pub mrb_id: MrbId,
    pub bc_bearer_ctxt_f1u_tnl_infoat_du: BcBearerContextF1uTnlInfo,
}

impl BroadcastMrBsSetupModItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let mrb_id = MrbId::decode(data)?;
        let bc_bearer_ctxt_f1u_tnl_infoat_du = BcBearerContextF1uTnlInfo::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            mrb_id,
            bc_bearer_ctxt_f1u_tnl_infoat_du,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.mrb_id.encode(data)?;
        self.bc_bearer_ctxt_f1u_tnl_infoat_du.encode(data)?;

        Ok(())
    }
}

impl PerCodec for BroadcastMrBsSetupModItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        BroadcastMrBsSetupModItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("BroadcastMrBsSetupModItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("BroadcastMrBsSetupModItem");
            e
        })
    }
}
// BroadcastMrBsToBeModifiedItem
#[derive(Clone, Debug)]
pub struct BroadcastMrBsToBeModifiedItem {
    pub mrb_id: MrbId,
    pub mrb_qos_information: Option<QosFlowLevelQosParameters>,
    pub mbs_flows_mapped_to_mrb_list: Option<MbsFlowsMappedToMrbList>,
    pub bc_bearer_ctxt_f1u_tnl_infoat_cu: Option<BcBearerContextF1uTnlInfo>,
}

impl BroadcastMrBsToBeModifiedItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 4)?;
        let mrb_id = MrbId::decode(data)?;
        let mrb_qos_information = if optionals[0] {
            Some(QosFlowLevelQosParameters::decode(data)?)
        } else {
            None
        };
        let mbs_flows_mapped_to_mrb_list = if optionals[1] {
            Some(MbsFlowsMappedToMrbList::decode(data)?)
        } else {
            None
        };
        let bc_bearer_ctxt_f1u_tnl_infoat_cu = if optionals[2] {
            Some(BcBearerContextF1uTnlInfo::decode(data)?)
        } else {
            None
        };

        // Process the extension container

        if optionals[3] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            mrb_id,
            mrb_qos_information,
            mbs_flows_mapped_to_mrb_list,
            bc_bearer_ctxt_f1u_tnl_infoat_cu,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.mrb_qos_information.is_some());
        optionals.push(self.mbs_flows_mapped_to_mrb_list.is_some());
        optionals.push(self.bc_bearer_ctxt_f1u_tnl_infoat_cu.is_some());
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.mrb_id.encode(data)?;
        if let Some(x) = &self.mrb_qos_information {
            x.encode(data)?;
        }
        if let Some(x) = &self.mbs_flows_mapped_to_mrb_list {
            x.encode(data)?;
        }
        if let Some(x) = &self.bc_bearer_ctxt_f1u_tnl_infoat_cu {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl PerCodec for BroadcastMrBsToBeModifiedItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        BroadcastMrBsToBeModifiedItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("BroadcastMrBsToBeModifiedItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("BroadcastMrBsToBeModifiedItem");
            e
        })
    }
}
// BroadcastMrBsToBeReleasedItem
#[derive(Clone, Debug)]
pub struct BroadcastMrBsToBeReleasedItem {
    pub mrb_id: MrbId,
}

impl BroadcastMrBsToBeReleasedItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let mrb_id = MrbId::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self { mrb_id })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.mrb_id.encode(data)?;

        Ok(())
    }
}

impl PerCodec for BroadcastMrBsToBeReleasedItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        BroadcastMrBsToBeReleasedItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("BroadcastMrBsToBeReleasedItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("BroadcastMrBsToBeReleasedItem");
            e
        })
    }
}
// BroadcastMrBsToBeSetupItem
#[derive(Clone, Debug)]
pub struct BroadcastMrBsToBeSetupItem {
    pub mrb_id: MrbId,
    pub mrb_qos_information: QosFlowLevelQosParameters,
    pub mbs_flows_mapped_to_mrb_list: MbsFlowsMappedToMrbList,
    pub bc_bearer_ctxt_f1u_tnl_infoat_cu: BcBearerContextF1uTnlInfo,
}

impl BroadcastMrBsToBeSetupItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let mrb_id = MrbId::decode(data)?;
        let mrb_qos_information = QosFlowLevelQosParameters::decode(data)?;
        let mbs_flows_mapped_to_mrb_list = MbsFlowsMappedToMrbList::decode(data)?;
        let bc_bearer_ctxt_f1u_tnl_infoat_cu = BcBearerContextF1uTnlInfo::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            mrb_id,
            mrb_qos_information,
            mbs_flows_mapped_to_mrb_list,
            bc_bearer_ctxt_f1u_tnl_infoat_cu,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.mrb_id.encode(data)?;
        self.mrb_qos_information.encode(data)?;
        self.mbs_flows_mapped_to_mrb_list.encode(data)?;
        self.bc_bearer_ctxt_f1u_tnl_infoat_cu.encode(data)?;

        Ok(())
    }
}

impl PerCodec for BroadcastMrBsToBeSetupItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        BroadcastMrBsToBeSetupItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("BroadcastMrBsToBeSetupItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("BroadcastMrBsToBeSetupItem");
            e
        })
    }
}
// BroadcastMrBsToBeSetupModItem
#[derive(Clone, Debug)]
pub struct BroadcastMrBsToBeSetupModItem {
    pub mrb_id: MrbId,
    pub mrb_qos_information: QosFlowLevelQosParameters,
    pub mbs_flows_mapped_to_mrb_list: MbsFlowsMappedToMrbList,
    pub bc_bearer_ctxt_f1u_tnl_infoat_cu: BcBearerContextF1uTnlInfo,
}

impl BroadcastMrBsToBeSetupModItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let mrb_id = MrbId::decode(data)?;
        let mrb_qos_information = QosFlowLevelQosParameters::decode(data)?;
        let mbs_flows_mapped_to_mrb_list = MbsFlowsMappedToMrbList::decode(data)?;
        let bc_bearer_ctxt_f1u_tnl_infoat_cu = BcBearerContextF1uTnlInfo::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            mrb_id,
            mrb_qos_information,
            mbs_flows_mapped_to_mrb_list,
            bc_bearer_ctxt_f1u_tnl_infoat_cu,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.mrb_id.encode(data)?;
        self.mrb_qos_information.encode(data)?;
        self.mbs_flows_mapped_to_mrb_list.encode(data)?;
        self.bc_bearer_ctxt_f1u_tnl_infoat_cu.encode(data)?;

        Ok(())
    }
}

impl PerCodec for BroadcastMrBsToBeSetupModItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        BroadcastMrBsToBeSetupModItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("BroadcastMrBsToBeSetupModItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("BroadcastMrBsToBeSetupModItem");
            e
        })
    }
}
// BroadcastNidList
#[derive(Clone, Debug)]
pub struct BroadcastNidList(pub NonEmpty<Nid>);

impl BroadcastNidList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(12), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(Nid::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(12), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for BroadcastNidList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        BroadcastNidList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("BroadcastNidList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("BroadcastNidList");
            e
        })
    }
}
// BroadcastSnpnIdList
#[derive(Clone, Debug)]
pub struct BroadcastSnpnIdList(pub NonEmpty<BroadcastSnpnIdListItem>);

impl BroadcastSnpnIdList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(12), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(BroadcastSnpnIdListItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(12), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for BroadcastSnpnIdList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        BroadcastSnpnIdList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("BroadcastSnpnIdList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("BroadcastSnpnIdList");
            e
        })
    }
}
// BroadcastSnpnIdListItem
#[derive(Clone, Debug)]
pub struct BroadcastSnpnIdListItem {
    pub plmn_identity: PlmnIdentity,
    pub broadcast_nid_list: BroadcastNidList,
}

impl BroadcastSnpnIdListItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let plmn_identity = PlmnIdentity::decode(data)?;
        let broadcast_nid_list = BroadcastNidList::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            plmn_identity,
            broadcast_nid_list,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.plmn_identity.encode(data)?;
        self.broadcast_nid_list.encode(data)?;

        Ok(())
    }
}

impl PerCodec for BroadcastSnpnIdListItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        BroadcastSnpnIdListItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("BroadcastSnpnIdListItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("BroadcastSnpnIdListItem");
            e
        })
    }
}
// BroadcastPniNpnIdList
#[derive(Clone, Debug)]
pub struct BroadcastPniNpnIdList(pub NonEmpty<BroadcastPniNpnIdListItem>);

impl BroadcastPniNpnIdList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(12), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(BroadcastPniNpnIdListItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(12), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for BroadcastPniNpnIdList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        BroadcastPniNpnIdList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("BroadcastPniNpnIdList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("BroadcastPniNpnIdList");
            e
        })
    }
}
// BroadcastPniNpnIdListItem
#[derive(Clone, Debug)]
pub struct BroadcastPniNpnIdListItem {
    pub plmn_identity: PlmnIdentity,
    pub broadcast_cag_list: BroadcastCagList,
}

impl BroadcastPniNpnIdListItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let plmn_identity = PlmnIdentity::decode(data)?;
        let broadcast_cag_list = BroadcastCagList::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            plmn_identity,
            broadcast_cag_list,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.plmn_identity.encode(data)?;
        self.broadcast_cag_list.encode(data)?;

        Ok(())
    }
}

impl PerCodec for BroadcastPniNpnIdListItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        BroadcastPniNpnIdListItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("BroadcastPniNpnIdListItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("BroadcastPniNpnIdListItem");
            e
        })
    }
}
// BroadcastAreaScope
#[derive(Clone, Debug)]
pub enum BroadcastAreaScope {
    CompleteSuccess,
    PartialSuccess(PartialSuccessCell),
}

impl BroadcastAreaScope {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_choice_idx(data, 0, 2, false)?;
        if extended {
            return Err(per_codec_error_new("CHOICE additions not implemented"));
        }
        match idx {
            0 => Ok(Self::CompleteSuccess),
            1 => Ok(Self::PartialSuccess(PartialSuccessCell::decode(data)?)),
            2 => {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _ = Criticality::decode(data)?;
                let _ = decode::decode_length_determinent(data, None, None, false)?;
                let result = match id {
                    x => Err(per_codec_error_new(format!("Unrecognised IE type {}", x))),
                };
                data.decode_align()?;
                result
            }
            _ => Err(per_codec_error_new("Unknown choice idx")),
        }
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        match self {
            Self::CompleteSuccess => {
                encode::encode_choice_idx(data, 0, 2, false, 0, false)?;
                Ok(())
            }
            Self::PartialSuccess(x) => {
                encode::encode_choice_idx(data, 0, 2, false, 1, false)?;
                x.encode(data)
            }
        }
    }
}

impl PerCodec for BroadcastAreaScope {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        BroadcastAreaScope::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("BroadcastAreaScope");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("BroadcastAreaScope");
            e
        })
    }
}
// BroadcastCellList
#[derive(Clone, Debug)]
pub struct BroadcastCellList(pub NonEmpty<BroadcastCellListItem>);

impl BroadcastCellList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(512), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(BroadcastCellListItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(512), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for BroadcastCellList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        BroadcastCellList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("BroadcastCellList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("BroadcastCellList");
            e
        })
    }
}
// BroadcastCellListItem
#[derive(Clone, Debug)]
pub struct BroadcastCellListItem {
    pub cell_id: NrCgi,
}

impl BroadcastCellListItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let cell_id = NrCgi::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self { cell_id })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.cell_id.encode(data)?;

        Ok(())
    }
}

impl PerCodec for BroadcastCellListItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        BroadcastCellListItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("BroadcastCellListItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("BroadcastCellListItem");
            e
        })
    }
}
// BufferSizeThresh
#[derive(Clone, Copy, Debug)]
pub struct BufferSizeThresh(pub u32);

impl BufferSizeThresh {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(
            decode::decode_integer(data, Some(0), Some(16777215), false)?.0 as u32,
        ))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_integer(data, Some(0), Some(16777215), false, self.0 as i128, false)
    }
}

impl PerCodec for BufferSizeThresh {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        BufferSizeThresh::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("BufferSizeThresh");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("BufferSizeThresh");
            e
        })
    }
}
// BurstArrivalTime
#[derive(Clone, Debug)]
pub struct BurstArrivalTime(pub Vec<u8>);

impl BurstArrivalTime {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(decode::decode_octetstring(data, None, None, false)?))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_octetstring(data, None, None, false, &self.0, false)
    }
}

impl PerCodec for BurstArrivalTime {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        BurstArrivalTime::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("BurstArrivalTime");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("BurstArrivalTime");
            e
        })
    }
}
// BwAggregationRequestIndication
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum BwAggregationRequestIndication {
    True,
}

impl BwAggregationRequestIndication {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(0), true)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(0),
            true,
            *self as i128,
            (*self as u32) >= 1,
        )
    }
}

impl PerCodec for BwAggregationRequestIndication {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        BwAggregationRequestIndication::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("BwAggregationRequestIndication");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("BwAggregationRequestIndication");
            e
        })
    }
}
// BwpId
#[derive(Clone, Copy, Debug)]
pub struct BwpId(pub u8);

impl BwpId {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(
            decode::decode_integer(data, Some(0), Some(4), false)?.0 as u8,
        ))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_integer(data, Some(0), Some(4), false, self.0 as i128, false)
    }
}

impl PerCodec for BwpId {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        BwpId::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("BwpId");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("BwpId");
            e
        })
    }
}
// BurstArrivalTimeWindow
#[derive(Clone, Debug)]
pub struct BurstArrivalTimeWindow {
    pub burst_arrival_time_window_start: u32,
    pub burst_arrival_time_window_end: u32,
}

impl BurstArrivalTimeWindow {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let burst_arrival_time_window_start =
            decode::decode_integer(data, Some(0), Some(640000), true)?.0 as u32;
        let burst_arrival_time_window_end =
            decode::decode_integer(data, Some(0), Some(640000), true)?.0 as u32;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            burst_arrival_time_window_start,
            burst_arrival_time_window_end,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        encode::encode_integer(
            data,
            Some(0),
            Some(640000),
            true,
            self.burst_arrival_time_window_start as i128,
            false,
        )?;
        encode::encode_integer(
            data,
            Some(0),
            Some(640000),
            true,
            self.burst_arrival_time_window_end as i128,
            false,
        )?;

        Ok(())
    }
}

impl PerCodec for BurstArrivalTimeWindow {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        BurstArrivalTimeWindow::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("BurstArrivalTimeWindow");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("BurstArrivalTimeWindow");
            e
        })
    }
}
// BroadcastMrBsTransportRequestItem
#[derive(Clone, Debug)]
pub struct BroadcastMrBsTransportRequestItem {
    pub mrb_id: MrbId,
    pub bc_bearer_ctxt_f1u_tnl_infoat_du: BcBearerContextF1uTnlInfo,
}

impl BroadcastMrBsTransportRequestItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let mrb_id = MrbId::decode(data)?;
        let bc_bearer_ctxt_f1u_tnl_infoat_du = BcBearerContextF1uTnlInfo::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            mrb_id,
            bc_bearer_ctxt_f1u_tnl_infoat_du,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.mrb_id.encode(data)?;
        self.bc_bearer_ctxt_f1u_tnl_infoat_du.encode(data)?;

        Ok(())
    }
}

impl PerCodec for BroadcastMrBsTransportRequestItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        BroadcastMrBsTransportRequestItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("BroadcastMrBsTransportRequestItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("BroadcastMrBsTransportRequestItem");
            e
        })
    }
}
// Cagid
#[derive(Clone, Debug)]
pub struct Cagid(pub BitString);

impl Cagid {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(decode::decode_bitstring(
            data,
            Some(32),
            Some(32),
            false,
        )?))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_bitstring(data, Some(32), Some(32), false, &self.0, false)
    }
}

impl PerCodec for Cagid {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Cagid::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("Cagid");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("Cagid");
            e
        })
    }
}
// CancelAllWarningMessagesIndicator
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum CancelAllWarningMessagesIndicator {
    True,
}

impl CancelAllWarningMessagesIndicator {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(0), true)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(0),
            true,
            *self as i128,
            (*self as u32) >= 1,
        )
    }
}

impl PerCodec for CancelAllWarningMessagesIndicator {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        CancelAllWarningMessagesIndicator::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CancelAllWarningMessagesIndicator");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CancelAllWarningMessagesIndicator");
            e
        })
    }
}
// CandidateSpCellItem
#[derive(Clone, Debug)]
pub struct CandidateSpCellItem {
    pub candidate_sp_cell_id: NrCgi,
}

impl CandidateSpCellItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let candidate_sp_cell_id = NrCgi::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            candidate_sp_cell_id,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.candidate_sp_cell_id.encode(data)?;

        Ok(())
    }
}

impl PerCodec for CandidateSpCellItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        CandidateSpCellItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CandidateSpCellItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CandidateSpCellItem");
            e
        })
    }
}
// CapacityValue
#[derive(Clone, Debug)]
pub struct CapacityValue {
    pub capacity_value: u8,
    pub ssb_area_capacity_value_list: Option<SsbAreaCapacityValueList>,
}

impl CapacityValue {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, false, 2)?;
        let capacity_value = decode::decode_integer(data, Some(0), Some(100), false)?.0 as u8;
        let ssb_area_capacity_value_list = if optionals[0] {
            Some(SsbAreaCapacityValueList::decode(data)?)
        } else {
            None
        };

        // Process the extension container

        if optionals[1] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            capacity_value,
            ssb_area_capacity_value_list,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.ssb_area_capacity_value_list.is_some());
        optionals.push(false);

        encode::encode_sequence_header(data, false, &optionals, false)?;
        encode::encode_integer(
            data,
            Some(0),
            Some(100),
            false,
            self.capacity_value as i128,
            false,
        )?;
        if let Some(x) = &self.ssb_area_capacity_value_list {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl PerCodec for CapacityValue {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        CapacityValue::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CapacityValue");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CapacityValue");
            e
        })
    }
}
// Cause
#[derive(Clone, Debug)]
pub enum Cause {
    RadioNetwork(CauseRadioNetwork),
    Transport(CauseTransport),
    Protocol(CauseProtocol),
    Misc(CauseMisc),
}

impl Cause {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_choice_idx(data, 0, 4, false)?;
        if extended {
            return Err(per_codec_error_new("CHOICE additions not implemented"));
        }
        match idx {
            0 => Ok(Self::RadioNetwork(CauseRadioNetwork::decode(data)?)),
            1 => Ok(Self::Transport(CauseTransport::decode(data)?)),
            2 => Ok(Self::Protocol(CauseProtocol::decode(data)?)),
            3 => Ok(Self::Misc(CauseMisc::decode(data)?)),
            4 => {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _ = Criticality::decode(data)?;
                let _ = decode::decode_length_determinent(data, None, None, false)?;
                let result = match id {
                    x => Err(per_codec_error_new(format!("Unrecognised IE type {}", x))),
                };
                data.decode_align()?;
                result
            }
            _ => Err(per_codec_error_new("Unknown choice idx")),
        }
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        match self {
            Self::RadioNetwork(x) => {
                encode::encode_choice_idx(data, 0, 4, false, 0, false)?;
                x.encode(data)
            }
            Self::Transport(x) => {
                encode::encode_choice_idx(data, 0, 4, false, 1, false)?;
                x.encode(data)
            }
            Self::Protocol(x) => {
                encode::encode_choice_idx(data, 0, 4, false, 2, false)?;
                x.encode(data)
            }
            Self::Misc(x) => {
                encode::encode_choice_idx(data, 0, 4, false, 3, false)?;
                x.encode(data)
            }
        }
    }
}

impl PerCodec for Cause {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Cause::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("Cause");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("Cause");
            e
        })
    }
}
// CauseMisc
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum CauseMisc {
    ControlProcessingOverload,
    NotEnoughUserPlaneProcessingResources,
    HardwareFailure,
    OmIntervention,
    Unspecified,
}

impl CauseMisc {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(4), true)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(4),
            true,
            *self as i128,
            (*self as u32) >= 5,
        )
    }
}

impl PerCodec for CauseMisc {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        CauseMisc::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CauseMisc");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CauseMisc");
            e
        })
    }
}
// CauseProtocol
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum CauseProtocol {
    TransferSyntaxError,
    AbstractSyntaxErrorReject,
    AbstractSyntaxErrorIgnoreAndNotify,
    MessageNotCompatibleWithReceiverState,
    SemanticError,
    AbstractSyntaxErrorFalselyConstructedMessage,
    Unspecified,
}

impl CauseProtocol {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(6), true)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(6),
            true,
            *self as i128,
            (*self as u32) >= 7,
        )
    }
}

impl PerCodec for CauseProtocol {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        CauseProtocol::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CauseProtocol");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CauseProtocol");
            e
        })
    }
}
// CauseRadioNetwork
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum CauseRadioNetwork {
    Unspecified,
    RlFailureRlc,
    UnknownOrAlreadyAllocatedGnbCuUeF1apId,
    UnknownOrAlreadyAllocatedGnbDuUeF1apId,
    UnknownOrInconsistentPairOfUeF1apId,
    InteractionWithOtherProcedure,
    NotSupportedQciValue,
    ActionDesirableForRadioReasons,
    NoRadioResourcesAvailable,
    ProcedureCancelled,
    NormalRelease,
    CellNotAvailable,
    RlFailureOthers,
    UeRejection,
    ResourcesNotAvailableForTheSlice,
    AmfInitiatedAbnormalRelease,
    ReleaseDueToPreEmption,
    PlmnNotServedByTheGnbCu,
    MultipleDrbIdInstances,
    UnknownDrbId,
    MultipleBhRlcChIdInstances,
    UnknownBhRlcChId,
    ChoCpcResourcesTobechanged,
    NpnNotSupported,
    NpnAccessDenied,
    GnbCuCellCapacityExceeded,
    ReportCharacteristicsEmpty,
    ExistingMeasurementId,
    MeasurementTemporarilyNotAvailable,
    MeasurementNotSupportedForTheObject,
    UnknownBhAddress,
    UnknownBapRoutingId,
    InsufficientUeCapabilities,
    ScgActivationDeactivationFailure,
    ScgDeactivationFailureDueToDataTransmission,
    RequestedItemNotSupportedOnTime,
    UnknownOrAlreadyAllocatedGnbCuMbsF1apId,
    UnknownOrAlreadyAllocatedGnbDuMbsF1apId,
    UnknownOrInconsistentPairOfMbsF1apId,
    UnknownOrInconsistentMrbId,
    TatSdtExpiry,
    LtmCommandTriggered,
    SsbNotAvailable,
}

impl CauseRadioNetwork {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(10), true)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(10),
            true,
            *self as i128,
            (*self as u32) >= 11,
        )
    }
}

impl PerCodec for CauseRadioNetwork {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        CauseRadioNetwork::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CauseRadioNetwork");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CauseRadioNetwork");
            e
        })
    }
}
// CauseTransport
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum CauseTransport {
    Unspecified,
    TransportResourceUnavailable,
    UnknownTnlAddressForIab,
    UnknownUpTnlInformationForIab,
}

impl CauseTransport {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(1), true)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(1),
            true,
            *self as i128,
            (*self as u32) >= 2,
        )
    }
}

impl PerCodec for CauseTransport {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        CauseTransport::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CauseTransport");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CauseTransport");
            e
        })
    }
}
// CellGroupConfig
#[derive(Clone, Debug)]
pub struct CellGroupConfig(pub Vec<u8>);

impl CellGroupConfig {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(decode::decode_octetstring(data, None, None, false)?))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_octetstring(data, None, None, false, &self.0, false)
    }
}

impl PerCodec for CellGroupConfig {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        CellGroupConfig::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CellGroupConfig");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CellGroupConfig");
            e
        })
    }
}
// CellCapacityClassValue
#[derive(Clone, Copy, Debug)]
pub struct CellCapacityClassValue(pub u8);

impl CellCapacityClassValue {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(
            decode::decode_integer(data, Some(1), Some(100), true)?.0 as u8,
        ))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_integer(data, Some(1), Some(100), true, self.0 as i128, false)
    }
}

impl PerCodec for CellCapacityClassValue {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        CellCapacityClassValue::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CellCapacityClassValue");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CellCapacityClassValue");
            e
        })
    }
}
// CellDirection
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum CellDirection {
    DlOnly,
    UlOnly,
}

impl CellDirection {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(1), false)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(1),
            false,
            *self as i128,
            (*self as u32) >= 2,
        )
    }
}

impl PerCodec for CellDirection {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        CellDirection::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CellDirection");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CellDirection");
            e
        })
    }
}
// CellMeasurementResultList
#[derive(Clone, Debug)]
pub struct CellMeasurementResultList(pub NonEmpty<CellMeasurementResultItem>);

impl CellMeasurementResultList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(512), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(CellMeasurementResultItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(512), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for CellMeasurementResultList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        CellMeasurementResultList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CellMeasurementResultList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CellMeasurementResultList");
            e
        })
    }
}
// CellMeasurementResultItem
#[derive(Clone, Debug)]
pub struct CellMeasurementResultItem {
    pub cell_id: NrCgi,
    pub radio_resource_status: Option<RadioResourceStatus>,
    pub composite_available_capacity_group: Option<CompositeAvailableCapacityGroup>,
    pub slice_available_capacity: Option<SliceAvailableCapacity>,
    pub numberof_active_ues: Option<NumberofActiveUes>,
    pub nr_u_channel_list: Option<NrUChannelList>,
}

impl CellMeasurementResultItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, false, 5)?;
        let cell_id = NrCgi::decode(data)?;
        let radio_resource_status = if optionals[0] {
            Some(RadioResourceStatus::decode(data)?)
        } else {
            None
        };
        let composite_available_capacity_group = if optionals[1] {
            Some(CompositeAvailableCapacityGroup::decode(data)?)
        } else {
            None
        };
        let slice_available_capacity = if optionals[2] {
            Some(SliceAvailableCapacity::decode(data)?)
        } else {
            None
        };
        let numberof_active_ues = if optionals[3] {
            Some(NumberofActiveUes::decode(data)?)
        } else {
            None
        };

        // Process the extension container
        let mut nr_u_channel_list: Option<NrUChannelList> = None;

        if optionals[4] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    444 => nr_u_channel_list = Some(NrUChannelList::decode(data)?),
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            cell_id,
            radio_resource_status,
            composite_available_capacity_group,
            slice_available_capacity,
            numberof_active_ues,
            nr_u_channel_list,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();
        if let Some(x) = &self.nr_u_channel_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 444, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        let mut optionals = BitString::new();
        optionals.push(self.radio_resource_status.is_some());
        optionals.push(self.composite_available_capacity_group.is_some());
        optionals.push(self.slice_available_capacity.is_some());
        optionals.push(self.numberof_active_ues.is_some());
        optionals.push(num_ies != 0);

        encode::encode_sequence_header(data, false, &optionals, false)?;
        self.cell_id.encode(data)?;
        if let Some(x) = &self.radio_resource_status {
            x.encode(data)?;
        }
        if let Some(x) = &self.composite_available_capacity_group {
            x.encode(data)?;
        }
        if let Some(x) = &self.slice_available_capacity {
            x.encode(data)?;
        }
        if let Some(x) = &self.numberof_active_ues {
            x.encode(data)?;
        }
        if num_ies != 0 {
            encode::encode_length_determinent(data, Some(1), Some(65535), false, num_ies)?;
            data.append_aligned(ies);
        }
        Ok(())
    }
}

impl PerCodec for CellMeasurementResultItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        CellMeasurementResultItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CellMeasurementResultItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CellMeasurementResultItem");
            e
        })
    }
}
// CellPortionId
#[derive(Clone, Copy, Debug)]
pub struct CellPortionId(pub u16);

impl CellPortionId {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(
            decode::decode_integer(data, Some(0), Some(4095), true)?.0 as u16,
        ))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_integer(data, Some(0), Some(4095), true, self.0 as i128, false)
    }
}

impl PerCodec for CellPortionId {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        CellPortionId::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CellPortionId");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CellPortionId");
            e
        })
    }
}
// CellsForSonList
#[derive(Clone, Debug)]
pub struct CellsForSonList(pub NonEmpty<CellsForSonItem>);

impl CellsForSonList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(256), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(CellsForSonItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(256), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for CellsForSonList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        CellsForSonList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CellsForSonList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CellsForSonList");
            e
        })
    }
}
// CellsForSonItem
#[derive(Clone, Debug)]
pub struct CellsForSonItem {
    pub nr_cgi: NrCgi,
    pub neighbour_nr_cells_for_son_list: Option<NeighbourNrCellsForSonList>,
}

impl CellsForSonItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 2)?;
        let nr_cgi = NrCgi::decode(data)?;
        let neighbour_nr_cells_for_son_list = if optionals[0] {
            Some(NeighbourNrCellsForSonList::decode(data)?)
        } else {
            None
        };

        // Process the extension container

        if optionals[1] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            nr_cgi,
            neighbour_nr_cells_for_son_list,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.neighbour_nr_cells_for_son_list.is_some());
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.nr_cgi.encode(data)?;
        if let Some(x) = &self.neighbour_nr_cells_for_son_list {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl PerCodec for CellsForSonItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        CellsForSonItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CellsForSonItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CellsForSonItem");
            e
        })
    }
}
// CellsFailedToBeActivatedListItem
#[derive(Clone, Debug)]
pub struct CellsFailedToBeActivatedListItem {
    pub nr_cgi: NrCgi,
    pub cause: Cause,
}

impl CellsFailedToBeActivatedListItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let nr_cgi = NrCgi::decode(data)?;
        let cause = Cause::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self { nr_cgi, cause })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.nr_cgi.encode(data)?;
        self.cause.encode(data)?;

        Ok(())
    }
}

impl PerCodec for CellsFailedToBeActivatedListItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        CellsFailedToBeActivatedListItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CellsFailedToBeActivatedListItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CellsFailedToBeActivatedListItem");
            e
        })
    }
}
// CellsStatusItem
#[derive(Clone, Debug)]
pub struct CellsStatusItem {
    pub nr_cgi: NrCgi,
    pub service_status: ServiceStatus,
}

impl CellsStatusItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let nr_cgi = NrCgi::decode(data)?;
        let service_status = ServiceStatus::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            nr_cgi,
            service_status,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.nr_cgi.encode(data)?;
        self.service_status.encode(data)?;

        Ok(())
    }
}

impl PerCodec for CellsStatusItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        CellsStatusItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CellsStatusItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CellsStatusItem");
            e
        })
    }
}
// CellsToBeBroadcastItem
#[derive(Clone, Debug)]
pub struct CellsToBeBroadcastItem {
    pub nr_cgi: NrCgi,
}

impl CellsToBeBroadcastItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let nr_cgi = NrCgi::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self { nr_cgi })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.nr_cgi.encode(data)?;

        Ok(())
    }
}

impl PerCodec for CellsToBeBroadcastItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        CellsToBeBroadcastItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CellsToBeBroadcastItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CellsToBeBroadcastItem");
            e
        })
    }
}
// CellsBroadcastCompletedItem
#[derive(Clone, Debug)]
pub struct CellsBroadcastCompletedItem {
    pub nr_cgi: NrCgi,
}

impl CellsBroadcastCompletedItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let nr_cgi = NrCgi::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self { nr_cgi })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.nr_cgi.encode(data)?;

        Ok(())
    }
}

impl PerCodec for CellsBroadcastCompletedItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        CellsBroadcastCompletedItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CellsBroadcastCompletedItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CellsBroadcastCompletedItem");
            e
        })
    }
}
// BroadcastToBeCancelledItem
#[derive(Clone, Debug)]
pub struct BroadcastToBeCancelledItem {
    pub nr_cgi: NrCgi,
}

impl BroadcastToBeCancelledItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let nr_cgi = NrCgi::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self { nr_cgi })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.nr_cgi.encode(data)?;

        Ok(())
    }
}

impl PerCodec for BroadcastToBeCancelledItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        BroadcastToBeCancelledItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("BroadcastToBeCancelledItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("BroadcastToBeCancelledItem");
            e
        })
    }
}
// CellsBroadcastCancelledItem
#[derive(Clone, Debug)]
pub struct CellsBroadcastCancelledItem {
    pub nr_cgi: NrCgi,
    pub number_of_broadcasts: NumberOfBroadcasts,
}

impl CellsBroadcastCancelledItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let nr_cgi = NrCgi::decode(data)?;
        let number_of_broadcasts = NumberOfBroadcasts::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            nr_cgi,
            number_of_broadcasts,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.nr_cgi.encode(data)?;
        self.number_of_broadcasts.encode(data)?;

        Ok(())
    }
}

impl PerCodec for CellsBroadcastCancelledItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        CellsBroadcastCancelledItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CellsBroadcastCancelledItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CellsBroadcastCancelledItem");
            e
        })
    }
}
// CellsToBeActivatedListItem
#[derive(Clone, Debug)]
pub struct CellsToBeActivatedListItem {
    pub nr_cgi: NrCgi,
    pub nr_pci: Option<NrPci>,
    pub gnb_cu_system_information: Option<GnbCuSystemInformation>,
    pub available_plmn_list: Option<AvailablePlmnList>,
    pub extended_available_plmn_list: Option<ExtendedAvailablePlmnList>,
    pub iab_info_iab_donor_cu: Option<IabInfoIabDonorCu>,
    pub available_snpn_id_list: Option<AvailableSnpnIdList>,
    pub mbs_broadcast_neighbour_cell_list: Option<MbsBroadcastNeighbourCellList>,
    pub ss_bs_within_the_cell_tobe_activated_list: Option<SsBsToBeActivatedList>,
}

impl CellsToBeActivatedListItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 2)?;
        let nr_cgi = NrCgi::decode(data)?;
        let nr_pci = if optionals[0] {
            Some(NrPci::decode(data)?)
        } else {
            None
        };

        // Process the extension container
        let mut gnb_cu_system_information: Option<GnbCuSystemInformation> = None;
        let mut available_plmn_list: Option<AvailablePlmnList> = None;
        let mut extended_available_plmn_list: Option<ExtendedAvailablePlmnList> = None;
        let mut iab_info_iab_donor_cu: Option<IabInfoIabDonorCu> = None;
        let mut available_snpn_id_list: Option<AvailableSnpnIdList> = None;
        let mut mbs_broadcast_neighbour_cell_list: Option<MbsBroadcastNeighbourCellList> = None;
        let mut ss_bs_within_the_cell_tobe_activated_list: Option<SsBsToBeActivatedList> = None;

        if optionals[1] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    118 => gnb_cu_system_information = Some(GnbCuSystemInformation::decode(data)?),
                    179 => available_plmn_list = Some(AvailablePlmnList::decode(data)?),
                    197 => {
                        extended_available_plmn_list =
                            Some(ExtendedAvailablePlmnList::decode(data)?)
                    }
                    291 => iab_info_iab_donor_cu = Some(IabInfoIabDonorCu::decode(data)?),
                    386 => available_snpn_id_list = Some(AvailableSnpnIdList::decode(data)?),
                    457 => {
                        mbs_broadcast_neighbour_cell_list =
                            Some(MbsBroadcastNeighbourCellList::decode(data)?)
                    }
                    744 => {
                        ss_bs_within_the_cell_tobe_activated_list =
                            Some(SsBsToBeActivatedList::decode(data)?)
                    }
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            nr_cgi,
            nr_pci,
            gnb_cu_system_information,
            available_plmn_list,
            extended_available_plmn_list,
            iab_info_iab_donor_cu,
            available_snpn_id_list,
            mbs_broadcast_neighbour_cell_list,
            ss_bs_within_the_cell_tobe_activated_list,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();
        if let Some(x) = &self.gnb_cu_system_information {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 118, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.available_plmn_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 179, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.extended_available_plmn_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 197, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.iab_info_iab_donor_cu {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 291, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.available_snpn_id_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 386, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.mbs_broadcast_neighbour_cell_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 457, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.ss_bs_within_the_cell_tobe_activated_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 744, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        let mut optionals = BitString::new();
        optionals.push(self.nr_pci.is_some());
        optionals.push(num_ies != 0);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.nr_cgi.encode(data)?;
        if let Some(x) = &self.nr_pci {
            x.encode(data)?;
        }
        if num_ies != 0 {
            encode::encode_length_determinent(data, Some(1), Some(65535), false, num_ies)?;
            data.append_aligned(ies);
        }
        Ok(())
    }
}

impl PerCodec for CellsToBeActivatedListItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        CellsToBeActivatedListItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CellsToBeActivatedListItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CellsToBeActivatedListItem");
            e
        })
    }
}
// CellsWithSsBsActivatedList
#[derive(Clone, Debug)]
pub struct CellsWithSsBsActivatedList(pub NonEmpty<CellsWithSsBsActivatedListItem>);

impl CellsWithSsBsActivatedList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(512), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(CellsWithSsBsActivatedListItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(512), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for CellsWithSsBsActivatedList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        CellsWithSsBsActivatedList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CellsWithSsBsActivatedList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CellsWithSsBsActivatedList");
            e
        })
    }
}
// CellsWithSsBsActivatedListItem
#[derive(Clone, Debug)]
pub struct CellsWithSsBsActivatedListItem {
    pub nr_cgi: NrCgi,
    pub ss_bs_activated_list: SsBsActivatedList,
}

impl CellsWithSsBsActivatedListItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, false, 1)?;
        let nr_cgi = NrCgi::decode(data)?;
        let ss_bs_activated_list = SsBsActivatedList::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            nr_cgi,
            ss_bs_activated_list,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, false, &optionals, false)?;
        self.nr_cgi.encode(data)?;
        self.ss_bs_activated_list.encode(data)?;

        Ok(())
    }
}

impl PerCodec for CellsWithSsBsActivatedListItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        CellsWithSsBsActivatedListItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CellsWithSsBsActivatedListItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CellsWithSsBsActivatedListItem");
            e
        })
    }
}
// CellsAllowedToBeDeactivatedListItem
#[derive(Clone, Debug)]
pub struct CellsAllowedToBeDeactivatedListItem {
    pub nr_cgi: NrCgi,
}

impl CellsAllowedToBeDeactivatedListItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let nr_cgi = NrCgi::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self { nr_cgi })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.nr_cgi.encode(data)?;

        Ok(())
    }
}

impl PerCodec for CellsAllowedToBeDeactivatedListItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        CellsAllowedToBeDeactivatedListItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CellsAllowedToBeDeactivatedListItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CellsAllowedToBeDeactivatedListItem");
            e
        })
    }
}
// CellsToBeDeactivatedListItem
#[derive(Clone, Debug)]
pub struct CellsToBeDeactivatedListItem {
    pub nr_cgi: NrCgi,
}

impl CellsToBeDeactivatedListItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let nr_cgi = NrCgi::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self { nr_cgi })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.nr_cgi.encode(data)?;

        Ok(())
    }
}

impl PerCodec for CellsToBeDeactivatedListItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        CellsToBeDeactivatedListItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CellsToBeDeactivatedListItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CellsToBeDeactivatedListItem");
            e
        })
    }
}
// CellsToBeBarredItem
#[derive(Clone, Debug)]
pub struct CellsToBeBarredItem {
    pub nr_cgi: NrCgi,
    pub cell_barred: CellBarred,
    pub iab_barred: Option<IabBarred>,
    pub mobile_iab_barred: Option<MobileIabBarred>,
}

impl CellsToBeBarredItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, false, 1)?;
        let nr_cgi = NrCgi::decode(data)?;
        let cell_barred = CellBarred::decode(data)?;

        // Process the extension container
        let mut iab_barred: Option<IabBarred> = None;
        let mut mobile_iab_barred: Option<MobileIabBarred> = None;

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    298 => iab_barred = Some(IabBarred::decode(data)?),
                    788 => mobile_iab_barred = Some(MobileIabBarred::decode(data)?),
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            nr_cgi,
            cell_barred,
            iab_barred,
            mobile_iab_barred,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();
        if let Some(x) = &self.iab_barred {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 298, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.mobile_iab_barred {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 788, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        let mut optionals = BitString::new();
        optionals.push(num_ies != 0);

        encode::encode_sequence_header(data, false, &optionals, false)?;
        self.nr_cgi.encode(data)?;
        self.cell_barred.encode(data)?;
        if num_ies != 0 {
            encode::encode_length_determinent(data, Some(1), Some(65535), false, num_ies)?;
            data.append_aligned(ies);
        }
        Ok(())
    }
}

impl PerCodec for CellsToBeBarredItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        CellsToBeBarredItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CellsToBeBarredItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CellsToBeBarredItem");
            e
        })
    }
}
// CellBarred
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum CellBarred {
    Barred,
    NotBarred,
}

impl CellBarred {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(1), true)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(1),
            true,
            *self as i128,
            (*self as u32) >= 2,
        )
    }
}

impl PerCodec for CellBarred {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        CellBarred::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CellBarred");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CellBarred");
            e
        })
    }
}
// CellSize
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum CellSize {
    Verysmall,
    Small,
    Medium,
    Large,
}

impl CellSize {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(3), true)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(3),
            true,
            *self as i128,
            (*self as u32) >= 4,
        )
    }
}

impl PerCodec for CellSize {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        CellSize::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CellSize");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CellSize");
            e
        })
    }
}
// CellToReportList
#[derive(Clone, Debug)]
pub struct CellToReportList(pub NonEmpty<CellToReportItem>);

impl CellToReportList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(512), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(CellToReportItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(512), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for CellToReportList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        CellToReportList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CellToReportList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CellToReportList");
            e
        })
    }
}
// CellToReportItem
#[derive(Clone, Debug)]
pub struct CellToReportItem {
    pub cell_id: NrCgi,
    pub ssb_to_report_list: Option<SsbToReportList>,
    pub slice_to_report_list: Option<SliceToReportList>,
}

impl CellToReportItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, false, 3)?;
        let cell_id = NrCgi::decode(data)?;
        let ssb_to_report_list = if optionals[0] {
            Some(SsbToReportList::decode(data)?)
        } else {
            None
        };
        let slice_to_report_list = if optionals[1] {
            Some(SliceToReportList::decode(data)?)
        } else {
            None
        };

        // Process the extension container

        if optionals[2] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            cell_id,
            ssb_to_report_list,
            slice_to_report_list,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.ssb_to_report_list.is_some());
        optionals.push(self.slice_to_report_list.is_some());
        optionals.push(false);

        encode::encode_sequence_header(data, false, &optionals, false)?;
        self.cell_id.encode(data)?;
        if let Some(x) = &self.ssb_to_report_list {
            x.encode(data)?;
        }
        if let Some(x) = &self.slice_to_report_list {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl PerCodec for CellToReportItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        CellToReportItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CellToReportItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CellToReportItem");
            e
        })
    }
}
// CellType
#[derive(Clone, Debug)]
pub struct CellType {
    pub cell_size: CellSize,
}

impl CellType {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let cell_size = CellSize::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self { cell_size })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.cell_size.encode(data)?;

        Ok(())
    }
}

impl PerCodec for CellType {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        CellType::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CellType");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CellType");
            e
        })
    }
}
// CellUlConfigured
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum CellUlConfigured {
    None,
    Ul,
    Sul,
    UlAndSul,
}

impl CellUlConfigured {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(3), true)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(3),
            true,
            *self as i128,
            (*self as u32) >= 4,
        )
    }
}

impl PerCodec for CellUlConfigured {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        CellUlConfigured::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CellUlConfigured");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CellUlConfigured");
            e
        })
    }
}
// CgSdtQueryIndication
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum CgSdtQueryIndication {
    True,
}

impl CgSdtQueryIndication {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(0), true)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(0),
            true,
            *self as i128,
            (*self as u32) >= 1,
        )
    }
}

impl PerCodec for CgSdtQueryIndication {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        CgSdtQueryIndication::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CgSdtQueryIndication");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CgSdtQueryIndication");
            e
        })
    }
}
// CgSdtKeptIndicator
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum CgSdtKeptIndicator {
    True,
}

impl CgSdtKeptIndicator {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(0), true)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(0),
            true,
            *self as i128,
            (*self as u32) >= 1,
        )
    }
}

impl PerCodec for CgSdtKeptIndicator {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        CgSdtKeptIndicator::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CgSdtKeptIndicator");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CgSdtKeptIndicator");
            e
        })
    }
}
// CgSdTindicatorSetup
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum CgSdTindicatorSetup {
    True,
}

impl CgSdTindicatorSetup {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(0), true)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(0),
            true,
            *self as i128,
            (*self as u32) >= 1,
        )
    }
}

impl PerCodec for CgSdTindicatorSetup {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        CgSdTindicatorSetup::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CgSdTindicatorSetup");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CgSdTindicatorSetup");
            e
        })
    }
}
// CgSdTindicatorMod
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum CgSdTindicatorMod {
    True,
    False,
}

impl CgSdTindicatorMod {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(1), true)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(1),
            true,
            *self as i128,
            (*self as u32) >= 2,
        )
    }
}

impl PerCodec for CgSdTindicatorMod {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        CgSdTindicatorMod::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CgSdTindicatorMod");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CgSdTindicatorMod");
            e
        })
    }
}
// CgSdtSessionInfo
#[derive(Clone, Debug)]
pub struct CgSdtSessionInfo {
    pub gnb_cu_ue_f1ap_id: GnbCuUeF1apId,
    pub gnb_du_ue_f1ap_id: GnbDuUeF1apId,
}

impl CgSdtSessionInfo {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let gnb_cu_ue_f1ap_id = GnbCuUeF1apId::decode(data)?;
        let gnb_du_ue_f1ap_id = GnbDuUeF1apId::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            gnb_cu_ue_f1ap_id,
            gnb_du_ue_f1ap_id,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.gnb_cu_ue_f1ap_id.encode(data)?;
        self.gnb_du_ue_f1ap_id.encode(data)?;

        Ok(())
    }
}

impl PerCodec for CgSdtSessionInfo {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        CgSdtSessionInfo::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CgSdtSessionInfo");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CgSdtSessionInfo");
            e
        })
    }
}
// ChannelOccupancyTimePercentage
#[derive(Clone, Copy, Debug)]
pub struct ChannelOccupancyTimePercentage(pub u8);

impl ChannelOccupancyTimePercentage {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(
            decode::decode_integer(data, Some(0), Some(100), true)?.0 as u8,
        ))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_integer(data, Some(0), Some(100), true, self.0 as i128, false)
    }
}

impl PerCodec for ChannelOccupancyTimePercentage {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        ChannelOccupancyTimePercentage::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ChannelOccupancyTimePercentage");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ChannelOccupancyTimePercentage");
            e
        })
    }
}
// ChildIabNodesNaResourceList
#[derive(Clone, Debug)]
pub struct ChildIabNodesNaResourceList(pub NonEmpty<ChildIabNodesNaResourceListItem>);

impl ChildIabNodesNaResourceList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(1024), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(ChildIabNodesNaResourceListItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(1024), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for ChildIabNodesNaResourceList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        ChildIabNodesNaResourceList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ChildIabNodesNaResourceList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ChildIabNodesNaResourceList");
            e
        })
    }
}
// ChildIabNodesNaResourceListItem
#[derive(Clone, Debug)]
pub struct ChildIabNodesNaResourceListItem {
    pub gnb_cu_ue_f1ap_id: GnbCuUeF1apId,
    pub gnb_du_ue_f1ap_id: GnbDuUeF1apId,
    pub na_resource_configuration_list: Option<NaResourceConfigurationList>,
}

impl ChildIabNodesNaResourceListItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, false, 2)?;
        let gnb_cu_ue_f1ap_id = GnbCuUeF1apId::decode(data)?;
        let gnb_du_ue_f1ap_id = GnbDuUeF1apId::decode(data)?;
        let na_resource_configuration_list = if optionals[0] {
            Some(NaResourceConfigurationList::decode(data)?)
        } else {
            None
        };

        // Process the extension container

        if optionals[1] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            gnb_cu_ue_f1ap_id,
            gnb_du_ue_f1ap_id,
            na_resource_configuration_list,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.na_resource_configuration_list.is_some());
        optionals.push(false);

        encode::encode_sequence_header(data, false, &optionals, false)?;
        self.gnb_cu_ue_f1ap_id.encode(data)?;
        self.gnb_du_ue_f1ap_id.encode(data)?;
        if let Some(x) = &self.na_resource_configuration_list {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl PerCodec for ChildIabNodesNaResourceListItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        ChildIabNodesNaResourceListItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ChildIabNodesNaResourceListItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ChildIabNodesNaResourceListItem");
            e
        })
    }
}
// ChildNodeCellsList
#[derive(Clone, Debug)]
pub struct ChildNodeCellsList(pub NonEmpty<ChildNodeCellsListItem>);

impl ChildNodeCellsList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(1024), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(ChildNodeCellsListItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(1024), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for ChildNodeCellsList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        ChildNodeCellsList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ChildNodeCellsList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ChildNodeCellsList");
            e
        })
    }
}
// ChildNodeCellsListItem
#[derive(Clone, Debug)]
pub struct ChildNodeCellsListItem {
    pub nr_cgi: NrCgi,
    pub iab_du_cell_resource_configuration_mode_info:
        Option<IabDuCellResourceConfigurationModeInfo>,
    pub iab_stc_info: Option<IabStcInfo>,
    pub rach_config_common: Option<RachConfigCommon>,
    pub rach_config_common_iab: Option<RachConfigCommonIab>,
    pub csi_rs_configuration: Option<Vec<u8>>,
    pub sr_configuration: Option<Vec<u8>>,
    pub pdcch_config_sib_1: Option<Vec<u8>>,
    pub scs_common: Option<Vec<u8>>,
    pub multiplexing_info: Option<MultiplexingInfo>,
}

impl ChildNodeCellsListItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, false, 10)?;
        let nr_cgi = NrCgi::decode(data)?;
        let iab_du_cell_resource_configuration_mode_info = if optionals[0] {
            Some(IabDuCellResourceConfigurationModeInfo::decode(data)?)
        } else {
            None
        };
        let iab_stc_info = if optionals[1] {
            Some(IabStcInfo::decode(data)?)
        } else {
            None
        };
        let rach_config_common = if optionals[2] {
            Some(RachConfigCommon::decode(data)?)
        } else {
            None
        };
        let rach_config_common_iab = if optionals[3] {
            Some(RachConfigCommonIab::decode(data)?)
        } else {
            None
        };
        let csi_rs_configuration = if optionals[4] {
            Some(decode::decode_octetstring(data, None, None, false)?)
        } else {
            None
        };
        let sr_configuration = if optionals[5] {
            Some(decode::decode_octetstring(data, None, None, false)?)
        } else {
            None
        };
        let pdcch_config_sib_1 = if optionals[6] {
            Some(decode::decode_octetstring(data, None, None, false)?)
        } else {
            None
        };
        let scs_common = if optionals[7] {
            Some(decode::decode_octetstring(data, None, None, false)?)
        } else {
            None
        };
        let multiplexing_info = if optionals[8] {
            Some(MultiplexingInfo::decode(data)?)
        } else {
            None
        };

        // Process the extension container

        if optionals[9] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            nr_cgi,
            iab_du_cell_resource_configuration_mode_info,
            iab_stc_info,
            rach_config_common,
            rach_config_common_iab,
            csi_rs_configuration,
            sr_configuration,
            pdcch_config_sib_1,
            scs_common,
            multiplexing_info,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.iab_du_cell_resource_configuration_mode_info.is_some());
        optionals.push(self.iab_stc_info.is_some());
        optionals.push(self.rach_config_common.is_some());
        optionals.push(self.rach_config_common_iab.is_some());
        optionals.push(self.csi_rs_configuration.is_some());
        optionals.push(self.sr_configuration.is_some());
        optionals.push(self.pdcch_config_sib_1.is_some());
        optionals.push(self.scs_common.is_some());
        optionals.push(self.multiplexing_info.is_some());
        optionals.push(false);

        encode::encode_sequence_header(data, false, &optionals, false)?;
        self.nr_cgi.encode(data)?;
        if let Some(x) = &self.iab_du_cell_resource_configuration_mode_info {
            x.encode(data)?;
        }
        if let Some(x) = &self.iab_stc_info {
            x.encode(data)?;
        }
        if let Some(x) = &self.rach_config_common {
            x.encode(data)?;
        }
        if let Some(x) = &self.rach_config_common_iab {
            x.encode(data)?;
        }
        if let Some(x) = &self.csi_rs_configuration {
            encode::encode_octetstring(data, None, None, false, &x, false)?;
        }
        if let Some(x) = &self.sr_configuration {
            encode::encode_octetstring(data, None, None, false, &x, false)?;
        }
        if let Some(x) = &self.pdcch_config_sib_1 {
            encode::encode_octetstring(data, None, None, false, &x, false)?;
        }
        if let Some(x) = &self.scs_common {
            encode::encode_octetstring(data, None, None, false, &x, false)?;
        }
        if let Some(x) = &self.multiplexing_info {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl PerCodec for ChildNodeCellsListItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        ChildNodeCellsListItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ChildNodeCellsListItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ChildNodeCellsListItem");
            e
        })
    }
}
// ChildNodesList
#[derive(Clone, Debug)]
pub struct ChildNodesList(pub NonEmpty<ChildNodesListItem>);

impl ChildNodesList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(1024), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(ChildNodesListItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(1024), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for ChildNodesList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        ChildNodesList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ChildNodesList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ChildNodesList");
            e
        })
    }
}
// ChildNodesListItem
#[derive(Clone, Debug)]
pub struct ChildNodesListItem {
    pub gnb_cu_ue_f1ap_id: GnbCuUeF1apId,
    pub gnb_du_ue_f1ap_id: GnbDuUeF1apId,
    pub child_node_cells_list: Option<ChildNodeCellsList>,
}

impl ChildNodesListItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, false, 2)?;
        let gnb_cu_ue_f1ap_id = GnbCuUeF1apId::decode(data)?;
        let gnb_du_ue_f1ap_id = GnbDuUeF1apId::decode(data)?;
        let child_node_cells_list = if optionals[0] {
            Some(ChildNodeCellsList::decode(data)?)
        } else {
            None
        };

        // Process the extension container

        if optionals[1] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            gnb_cu_ue_f1ap_id,
            gnb_du_ue_f1ap_id,
            child_node_cells_list,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.child_node_cells_list.is_some());
        optionals.push(false);

        encode::encode_sequence_header(data, false, &optionals, false)?;
        self.gnb_cu_ue_f1ap_id.encode(data)?;
        self.gnb_du_ue_f1ap_id.encode(data)?;
        if let Some(x) = &self.child_node_cells_list {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl PerCodec for ChildNodesListItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        ChildNodesListItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ChildNodesListItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ChildNodesListItem");
            e
        })
    }
}
// ChOtriggerInterDu
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum ChOtriggerInterDu {
    ChoInitiation,
    ChoReplace,
}

impl ChOtriggerInterDu {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(1), true)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(1),
            true,
            *self as i128,
            (*self as u32) >= 2,
        )
    }
}

impl PerCodec for ChOtriggerInterDu {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        ChOtriggerInterDu::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ChOtriggerInterDu");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ChOtriggerInterDu");
            e
        })
    }
}
// ChOtriggerIntraDu
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum ChOtriggerIntraDu {
    ChoInitiation,
    ChoReplace,
    ChoCancel,
}

impl ChOtriggerIntraDu {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(2), true)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(2),
            true,
            *self as i128,
            (*self as u32) >= 3,
        )
    }
}

impl PerCodec for ChOtriggerIntraDu {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        ChOtriggerIntraDu::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ChOtriggerIntraDu");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ChOtriggerIntraDu");
            e
        })
    }
}
// CnSubgroupId
#[derive(Clone, Copy, Debug)]
pub struct CnSubgroupId(pub u8);

impl CnSubgroupId {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(
            decode::decode_integer(data, Some(0), Some(7), true)?.0 as u8,
        ))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_integer(data, Some(0), Some(7), true, self.0 as i128, false)
    }
}

impl PerCodec for CnSubgroupId {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        CnSubgroupId::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CnSubgroupId");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CnSubgroupId");
            e
        })
    }
}
// CnUePagingIdentity
#[derive(Clone, Debug)]
pub enum CnUePagingIdentity {
    FiveGSTmsi(BitString),
}

impl CnUePagingIdentity {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_choice_idx(data, 0, 1, false)?;
        if extended {
            return Err(per_codec_error_new("CHOICE additions not implemented"));
        }
        match idx {
            0 => Ok(Self::FiveGSTmsi(decode::decode_bitstring(
                data,
                Some(48),
                Some(48),
                false,
            )?)),
            1 => {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _ = Criticality::decode(data)?;
                let _ = decode::decode_length_determinent(data, None, None, false)?;
                let result = match id {
                    x => Err(per_codec_error_new(format!("Unrecognised IE type {}", x))),
                };
                data.decode_align()?;
                result
            }
            _ => Err(per_codec_error_new("Unknown choice idx")),
        }
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        match self {
            Self::FiveGSTmsi(x) => {
                encode::encode_choice_idx(data, 0, 1, false, 0, false)?;
                encode::encode_bitstring(data, Some(48), Some(48), false, &x, false)
            }
        }
    }
}

impl PerCodec for CnUePagingIdentity {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        CnUePagingIdentity::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CnUePagingIdentity");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CnUePagingIdentity");
            e
        })
    }
}
// CompositeAvailableCapacityGroup
#[derive(Clone, Debug)]
pub struct CompositeAvailableCapacityGroup {
    pub composite_available_capacity_downlink: CompositeAvailableCapacity,
    pub composite_available_capacity_uplink: CompositeAvailableCapacity,
    pub composite_available_capacity_sul: Option<CompositeAvailableCapacity>,
}

impl CompositeAvailableCapacityGroup {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, false, 1)?;
        let composite_available_capacity_downlink = CompositeAvailableCapacity::decode(data)?;
        let composite_available_capacity_uplink = CompositeAvailableCapacity::decode(data)?;

        // Process the extension container
        let mut composite_available_capacity_sul: Option<CompositeAvailableCapacity> = None;

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    442 => {
                        composite_available_capacity_sul =
                            Some(CompositeAvailableCapacity::decode(data)?)
                    }
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            composite_available_capacity_downlink,
            composite_available_capacity_uplink,
            composite_available_capacity_sul,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();
        if let Some(x) = &self.composite_available_capacity_sul {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 442, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        let mut optionals = BitString::new();
        optionals.push(num_ies != 0);

        encode::encode_sequence_header(data, false, &optionals, false)?;
        self.composite_available_capacity_downlink.encode(data)?;
        self.composite_available_capacity_uplink.encode(data)?;
        if num_ies != 0 {
            encode::encode_length_determinent(data, Some(1), Some(65535), false, num_ies)?;
            data.append_aligned(ies);
        }
        Ok(())
    }
}

impl PerCodec for CompositeAvailableCapacityGroup {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        CompositeAvailableCapacityGroup::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CompositeAvailableCapacityGroup");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CompositeAvailableCapacityGroup");
            e
        })
    }
}
// CompositeAvailableCapacity
#[derive(Clone, Debug)]
pub struct CompositeAvailableCapacity {
    pub cell_capacity_class_value: Option<CellCapacityClassValue>,
    pub capacity_value: CapacityValue,
}

impl CompositeAvailableCapacity {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, false, 2)?;
        let cell_capacity_class_value = if optionals[0] {
            Some(CellCapacityClassValue::decode(data)?)
        } else {
            None
        };
        let capacity_value = CapacityValue::decode(data)?;

        // Process the extension container

        if optionals[1] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            cell_capacity_class_value,
            capacity_value,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.cell_capacity_class_value.is_some());
        optionals.push(false);

        encode::encode_sequence_header(data, false, &optionals, false)?;
        if let Some(x) = &self.cell_capacity_class_value {
            x.encode(data)?;
        }
        self.capacity_value.encode(data)?;

        Ok(())
    }
}

impl PerCodec for CompositeAvailableCapacity {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        CompositeAvailableCapacity::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CompositeAvailableCapacity");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CompositeAvailableCapacity");
            e
        })
    }
}
// ChoProbability
#[derive(Clone, Copy, Debug)]
pub struct ChoProbability(pub u8);

impl ChoProbability {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(
            decode::decode_integer(data, Some(1), Some(100), false)?.0 as u8,
        ))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_integer(data, Some(1), Some(100), false, self.0 as i128, false)
    }
}

impl PerCodec for ChoProbability {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        ChoProbability::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ChoProbability");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ChoProbability");
            e
        })
    }
}
// ConditionalInterDuMobilityInformation
#[derive(Clone, Debug)]
pub struct ConditionalInterDuMobilityInformation {
    pub cho_trigger: ChOtriggerInterDu,
    pub target_gnb_du_ue_f1apid: Option<GnbDuUeF1apId>,
    pub estimated_arrival_probability: Option<ChoProbability>,
    pub scpac_request: Option<ScpacRequest>,
    pub s_cpac_lower_layer_reference_config_request: Option<SCpacLowerLayerReferenceConfigRequest>,
}

impl ConditionalInterDuMobilityInformation {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 2)?;
        let cho_trigger = ChOtriggerInterDu::decode(data)?;
        let target_gnb_du_ue_f1apid = if optionals[0] {
            Some(GnbDuUeF1apId::decode(data)?)
        } else {
            None
        };

        // Process the extension container
        let mut estimated_arrival_probability: Option<ChoProbability> = None;
        let mut scpac_request: Option<ScpacRequest> = None;
        let mut s_cpac_lower_layer_reference_config_request: Option<
            SCpacLowerLayerReferenceConfigRequest,
        > = None;

        if optionals[1] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    433 => estimated_arrival_probability = Some(ChoProbability::decode(data)?),
                    786 => scpac_request = Some(ScpacRequest::decode(data)?),
                    791 => {
                        s_cpac_lower_layer_reference_config_request =
                            Some(SCpacLowerLayerReferenceConfigRequest::decode(data)?)
                    }
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            cho_trigger,
            target_gnb_du_ue_f1apid,
            estimated_arrival_probability,
            scpac_request,
            s_cpac_lower_layer_reference_config_request,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();
        if let Some(x) = &self.estimated_arrival_probability {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 433, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.scpac_request {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 786, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.s_cpac_lower_layer_reference_config_request {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 791, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        let mut optionals = BitString::new();
        optionals.push(self.target_gnb_du_ue_f1apid.is_some());
        optionals.push(num_ies != 0);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.cho_trigger.encode(data)?;
        if let Some(x) = &self.target_gnb_du_ue_f1apid {
            x.encode(data)?;
        }
        if num_ies != 0 {
            encode::encode_length_determinent(data, Some(1), Some(65535), false, num_ies)?;
            data.append_aligned(ies);
        }
        Ok(())
    }
}

impl PerCodec for ConditionalInterDuMobilityInformation {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        ConditionalInterDuMobilityInformation::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ConditionalInterDuMobilityInformation");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ConditionalInterDuMobilityInformation");
            e
        })
    }
}
// ConditionalIntraDuMobilityInformation
#[derive(Clone, Debug)]
pub struct ConditionalIntraDuMobilityInformation {
    pub cho_trigger: ChOtriggerIntraDu,
    pub target_cells_tocancel: Option<TargetCellList>,
    pub estimated_arrival_probability: Option<ChoProbability>,
    pub scpac_request: Option<ScpacRequest>,
    pub s_cpac_lower_layer_reference_config_request: Option<SCpacLowerLayerReferenceConfigRequest>,
}

impl ConditionalIntraDuMobilityInformation {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 2)?;
        let cho_trigger = ChOtriggerIntraDu::decode(data)?;
        let target_cells_tocancel = if optionals[0] {
            Some(TargetCellList::decode(data)?)
        } else {
            None
        };

        // Process the extension container
        let mut estimated_arrival_probability: Option<ChoProbability> = None;
        let mut scpac_request: Option<ScpacRequest> = None;
        let mut s_cpac_lower_layer_reference_config_request: Option<
            SCpacLowerLayerReferenceConfigRequest,
        > = None;

        if optionals[1] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    433 => estimated_arrival_probability = Some(ChoProbability::decode(data)?),
                    786 => scpac_request = Some(ScpacRequest::decode(data)?),
                    791 => {
                        s_cpac_lower_layer_reference_config_request =
                            Some(SCpacLowerLayerReferenceConfigRequest::decode(data)?)
                    }
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            cho_trigger,
            target_cells_tocancel,
            estimated_arrival_probability,
            scpac_request,
            s_cpac_lower_layer_reference_config_request,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();
        if let Some(x) = &self.estimated_arrival_probability {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 433, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.scpac_request {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 786, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.s_cpac_lower_layer_reference_config_request {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 791, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        let mut optionals = BitString::new();
        optionals.push(self.target_cells_tocancel.is_some());
        optionals.push(num_ies != 0);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.cho_trigger.encode(data)?;
        if let Some(x) = &self.target_cells_tocancel {
            x.encode(data)?;
        }
        if num_ies != 0 {
            encode::encode_length_determinent(data, Some(1), Some(65535), false, num_ies)?;
            data.append_aligned(ies);
        }
        Ok(())
    }
}

impl PerCodec for ConditionalIntraDuMobilityInformation {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        ConditionalIntraDuMobilityInformation::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ConditionalIntraDuMobilityInformation");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ConditionalIntraDuMobilityInformation");
            e
        })
    }
}
// ConfigRestrictInfoDaps
#[derive(Clone, Debug)]
pub struct ConfigRestrictInfoDaps(pub Vec<u8>);

impl ConfigRestrictInfoDaps {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(decode::decode_octetstring(data, None, None, false)?))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_octetstring(data, None, None, false, &self.0, false)
    }
}

impl PerCodec for ConfigRestrictInfoDaps {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        ConfigRestrictInfoDaps::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ConfigRestrictInfoDaps");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ConfigRestrictInfoDaps");
            e
        })
    }
}
// ConfiguredTacIndication
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum ConfiguredTacIndication {
    True,
}

impl ConfiguredTacIndication {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(0), true)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(0),
            true,
            *self as i128,
            (*self as u32) >= 1,
        )
    }
}

impl PerCodec for ConfiguredTacIndication {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        ConfiguredTacIndication::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ConfiguredTacIndication");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ConfiguredTacIndication");
            e
        })
    }
}
// ConfiguredBwpList
#[derive(Clone, Debug)]
pub struct ConfiguredBwpList(pub NonEmpty<ConfiguredBwpItem>);

impl ConfiguredBwpList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(8), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(ConfiguredBwpItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(8), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for ConfiguredBwpList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        ConfiguredBwpList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ConfiguredBwpList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ConfiguredBwpList");
            e
        })
    }
}
// ConfiguredBwpItem
#[derive(Clone, Debug)]
pub struct ConfiguredBwpItem {
    pub bwp_id: BwpId,
    pub bwp_location_and_bandwidth: u16,
}

impl ConfiguredBwpItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let bwp_id = BwpId::decode(data)?;
        let bwp_location_and_bandwidth =
            decode::decode_integer(data, Some(0), Some(37949), false)?.0 as u16;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            bwp_id,
            bwp_location_and_bandwidth,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.bwp_id.encode(data)?;
        encode::encode_integer(
            data,
            Some(0),
            Some(37949),
            false,
            self.bwp_location_and_bandwidth as i128,
            false,
        )?;

        Ok(())
    }
}

impl PerCodec for ConfiguredBwpItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        ConfiguredBwpItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ConfiguredBwpItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ConfiguredBwpItem");
            e
        })
    }
}
// CoordinateId
#[derive(Clone, Copy, Debug)]
pub struct CoordinateId(pub u16);

impl CoordinateId {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(
            decode::decode_integer(data, Some(0), Some(511), true)?.0 as u16,
        ))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_integer(data, Some(0), Some(511), true, self.0 as i128, false)
    }
}

impl PerCodec for CoordinateId {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        CoordinateId::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CoordinateId");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CoordinateId");
            e
        })
    }
}
// CoverageModificationNotification
#[derive(Clone, Debug)]
pub struct CoverageModificationNotification {
    pub coverage_modification_list: CoverageModificationList,
}

impl CoverageModificationNotification {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let coverage_modification_list = CoverageModificationList::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            coverage_modification_list,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.coverage_modification_list.encode(data)?;

        Ok(())
    }
}

impl PerCodec for CoverageModificationNotification {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        CoverageModificationNotification::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CoverageModificationNotification");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CoverageModificationNotification");
            e
        })
    }
}
// CoverageModificationList
#[derive(Clone, Debug)]
pub struct CoverageModificationList(pub NonEmpty<CoverageModificationItem>);

impl CoverageModificationList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(512), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(CoverageModificationItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(512), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for CoverageModificationList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        CoverageModificationList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CoverageModificationList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CoverageModificationList");
            e
        })
    }
}
// CoverageModificationItem
#[derive(Clone, Debug)]
pub struct CoverageModificationItem {
    pub nr_cgi: NrCgi,
    pub cell_coverage_state: CellCoverageState,
    pub ssb_coverage_modification_list: Option<SsbCoverageModificationList>,
    pub coverage_modification_cause: Option<CcoIssueDetection>,
}

impl CoverageModificationItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 2)?;
        let nr_cgi = NrCgi::decode(data)?;
        let cell_coverage_state = CellCoverageState::decode(data)?;
        let ssb_coverage_modification_list = if optionals[0] {
            Some(SsbCoverageModificationList::decode(data)?)
        } else {
            None
        };

        // Process the extension container
        let mut coverage_modification_cause: Option<CcoIssueDetection> = None;

        if optionals[1] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    748 => coverage_modification_cause = Some(CcoIssueDetection::decode(data)?),
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            nr_cgi,
            cell_coverage_state,
            ssb_coverage_modification_list,
            coverage_modification_cause,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();
        if let Some(x) = &self.coverage_modification_cause {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 748, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        let mut optionals = BitString::new();
        optionals.push(self.ssb_coverage_modification_list.is_some());
        optionals.push(num_ies != 0);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.nr_cgi.encode(data)?;
        self.cell_coverage_state.encode(data)?;
        if let Some(x) = &self.ssb_coverage_modification_list {
            x.encode(data)?;
        }
        if num_ies != 0 {
            encode::encode_length_determinent(data, Some(1), Some(65535), false, num_ies)?;
            data.append_aligned(ies);
        }
        Ok(())
    }
}

impl PerCodec for CoverageModificationItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        CoverageModificationItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CoverageModificationItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CoverageModificationItem");
            e
        })
    }
}
// CellCoverageState
#[derive(Clone, Copy, Debug)]
pub struct CellCoverageState(pub u8);

impl CellCoverageState {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(
            decode::decode_integer(data, Some(0), Some(63), true)?.0 as u8,
        ))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_integer(data, Some(0), Some(63), true, self.0 as i128, false)
    }
}

impl PerCodec for CellCoverageState {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        CellCoverageState::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CellCoverageState");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CellCoverageState");
            e
        })
    }
}
// CcoAssistanceInformation
#[derive(Clone, Debug)]
pub struct CcoAssistanceInformation {
    pub cco_issue_detection: Option<CcoIssueDetection>,
    pub affected_cells_and_beams_list: Option<AffectedCellsAndBeamsList>,
}

impl CcoAssistanceInformation {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 3)?;
        let cco_issue_detection = if optionals[0] {
            Some(CcoIssueDetection::decode(data)?)
        } else {
            None
        };
        let affected_cells_and_beams_list = if optionals[1] {
            Some(AffectedCellsAndBeamsList::decode(data)?)
        } else {
            None
        };

        // Process the extension container

        if optionals[2] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            cco_issue_detection,
            affected_cells_and_beams_list,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.cco_issue_detection.is_some());
        optionals.push(self.affected_cells_and_beams_list.is_some());
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        if let Some(x) = &self.cco_issue_detection {
            x.encode(data)?;
        }
        if let Some(x) = &self.affected_cells_and_beams_list {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl PerCodec for CcoAssistanceInformation {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        CcoAssistanceInformation::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CcoAssistanceInformation");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CcoAssistanceInformation");
            e
        })
    }
}
// CcoIssueDetection
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum CcoIssueDetection {
    Coverage,
    CellEdgeCapacity,
    NetworkEnergySaving,
}

impl CcoIssueDetection {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(1), true)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(1),
            true,
            *self as i128,
            (*self as u32) >= 2,
        )
    }
}

impl PerCodec for CcoIssueDetection {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        CcoIssueDetection::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CcoIssueDetection");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CcoIssueDetection");
            e
        })
    }
}
// CpTransportLayerAddress
#[derive(Clone, Debug)]
pub enum CpTransportLayerAddress {
    EndpointIpAddress(TransportLayerAddress),
    EndpointIpAddressAndPort(EndpointIpAddressAndPort),
}

impl CpTransportLayerAddress {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_choice_idx(data, 0, 2, false)?;
        if extended {
            return Err(per_codec_error_new("CHOICE additions not implemented"));
        }
        match idx {
            0 => Ok(Self::EndpointIpAddress(TransportLayerAddress::decode(
                data,
            )?)),
            1 => Ok(Self::EndpointIpAddressAndPort(
                EndpointIpAddressAndPort::decode(data)?,
            )),
            2 => {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _ = Criticality::decode(data)?;
                let _ = decode::decode_length_determinent(data, None, None, false)?;
                let result = match id {
                    x => Err(per_codec_error_new(format!("Unrecognised IE type {}", x))),
                };
                data.decode_align()?;
                result
            }
            _ => Err(per_codec_error_new("Unknown choice idx")),
        }
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        match self {
            Self::EndpointIpAddress(x) => {
                encode::encode_choice_idx(data, 0, 2, false, 0, false)?;
                x.encode(data)
            }
            Self::EndpointIpAddressAndPort(x) => {
                encode::encode_choice_idx(data, 0, 2, false, 1, false)?;
                x.encode(data)
            }
        }
    }
}

impl PerCodec for CpTransportLayerAddress {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        CpTransportLayerAddress::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CpTransportLayerAddress");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CpTransportLayerAddress");
            e
        })
    }
}
// CpacmcgInformation
#[derive(Clone, Debug)]
pub struct CpacmcgInformation {
    pub cpac_trigger: CpacTrigger,
    pub pscellid: NrCgi,
}

impl CpacmcgInformation {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let cpac_trigger = CpacTrigger::decode(data)?;
        let pscellid = NrCgi::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            cpac_trigger,
            pscellid,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.cpac_trigger.encode(data)?;
        self.pscellid.encode(data)?;

        Ok(())
    }
}

impl PerCodec for CpacmcgInformation {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        CpacmcgInformation::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CpacmcgInformation");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CpacmcgInformation");
            e
        })
    }
}
// CpacTrigger
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum CpacTrigger {
    CpacPreparation,
    CpacExecuted,
}

impl CpacTrigger {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(1), true)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(1),
            true,
            *self as i128,
            (*self as u32) >= 2,
        )
    }
}

impl PerCodec for CpacTrigger {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        CpacTrigger::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CpacTrigger");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CpacTrigger");
            e
        })
    }
}
// CpTrafficType
#[derive(Clone, Copy, Debug)]
pub struct CpTrafficType(pub u8);

impl CpTrafficType {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(
            decode::decode_integer(data, Some(1), Some(3), true)?.0 as u8,
        ))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_integer(data, Some(1), Some(3), true, self.0 as i128, false)
    }
}

impl PerCodec for CpTrafficType {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        CpTrafficType::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CpTrafficType");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CpTrafficType");
            e
        })
    }
}
// CriticalityDiagnostics
#[derive(Clone, Debug)]
pub struct CriticalityDiagnostics {
    pub procedure_code: Option<ProcedureCode>,
    pub triggering_message: Option<TriggeringMessage>,
    pub procedure_criticality: Option<Criticality>,
    pub transaction_id: Option<TransactionId>,
    pub i_es_criticality_diagnostics: Option<CriticalityDiagnosticsIeList>,
}

impl CriticalityDiagnostics {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 6)?;
        let procedure_code = if optionals[0] {
            Some(ProcedureCode::decode(data)?)
        } else {
            None
        };
        let triggering_message = if optionals[1] {
            Some(TriggeringMessage::decode(data)?)
        } else {
            None
        };
        let procedure_criticality = if optionals[2] {
            Some(Criticality::decode(data)?)
        } else {
            None
        };
        let transaction_id = if optionals[3] {
            Some(TransactionId::decode(data)?)
        } else {
            None
        };
        let i_es_criticality_diagnostics = if optionals[4] {
            Some(CriticalityDiagnosticsIeList::decode(data)?)
        } else {
            None
        };

        // Process the extension container

        if optionals[5] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            procedure_code,
            triggering_message,
            procedure_criticality,
            transaction_id,
            i_es_criticality_diagnostics,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.procedure_code.is_some());
        optionals.push(self.triggering_message.is_some());
        optionals.push(self.procedure_criticality.is_some());
        optionals.push(self.transaction_id.is_some());
        optionals.push(self.i_es_criticality_diagnostics.is_some());
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        if let Some(x) = &self.procedure_code {
            x.encode(data)?;
        }
        if let Some(x) = &self.triggering_message {
            x.encode(data)?;
        }
        if let Some(x) = &self.procedure_criticality {
            x.encode(data)?;
        }
        if let Some(x) = &self.transaction_id {
            x.encode(data)?;
        }
        if let Some(x) = &self.i_es_criticality_diagnostics {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl PerCodec for CriticalityDiagnostics {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        CriticalityDiagnostics::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CriticalityDiagnostics");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CriticalityDiagnostics");
            e
        })
    }
}
// CriticalityDiagnosticsIeList
#[derive(Clone, Debug)]
pub struct CriticalityDiagnosticsIeList(pub NonEmpty<CriticalityDiagnosticsIeItem>);

impl CriticalityDiagnosticsIeList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(256), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(CriticalityDiagnosticsIeItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(256), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for CriticalityDiagnosticsIeList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        CriticalityDiagnosticsIeList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CriticalityDiagnosticsIeList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CriticalityDiagnosticsIeList");
            e
        })
    }
}
// CriticalityDiagnosticsIeItem
#[derive(Clone, Debug)]
pub struct CriticalityDiagnosticsIeItem {
    pub ie_criticality: Criticality,
    pub ie_id: ProtocolIeId,
    pub type_of_error: TypeOfError,
}

impl CriticalityDiagnosticsIeItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let ie_criticality = Criticality::decode(data)?;
        let ie_id = ProtocolIeId::decode(data)?;
        let type_of_error = TypeOfError::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            ie_criticality,
            ie_id,
            type_of_error,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.ie_criticality.encode(data)?;
        self.ie_id.encode(data)?;
        self.type_of_error.encode(data)?;

        Ok(())
    }
}

impl PerCodec for CriticalityDiagnosticsIeItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        CriticalityDiagnosticsIeItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CriticalityDiagnosticsIeItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CriticalityDiagnosticsIeItem");
            e
        })
    }
}
// CRnti
#[derive(Clone, Copy, Debug)]
pub struct CRnti(pub u16);

impl CRnti {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(
            decode::decode_integer(data, Some(0), Some(65535), true)?.0 as u16,
        ))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_integer(data, Some(0), Some(65535), true, self.0 as i128, false)
    }
}

impl PerCodec for CRnti {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        CRnti::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CRnti");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CRnti");
            e
        })
    }
}
// CuDuRadioInformationType
#[derive(Clone, Debug)]
pub enum CuDuRadioInformationType {
    Rim(CuDuRimInformation),
}

impl CuDuRadioInformationType {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_choice_idx(data, 0, 1, false)?;
        if extended {
            return Err(per_codec_error_new("CHOICE additions not implemented"));
        }
        match idx {
            0 => Ok(Self::Rim(CuDuRimInformation::decode(data)?)),
            1 => {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _ = Criticality::decode(data)?;
                let _ = decode::decode_length_determinent(data, None, None, false)?;
                let result = match id {
                    x => Err(per_codec_error_new(format!("Unrecognised IE type {}", x))),
                };
                data.decode_align()?;
                result
            }
            _ => Err(per_codec_error_new("Unknown choice idx")),
        }
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        match self {
            Self::Rim(x) => {
                encode::encode_choice_idx(data, 0, 1, false, 0, false)?;
                x.encode(data)
            }
        }
    }
}

impl PerCodec for CuDuRadioInformationType {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        CuDuRadioInformationType::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CuDuRadioInformationType");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CuDuRadioInformationType");
            e
        })
    }
}
// CuDuRimInformation
#[derive(Clone, Debug)]
pub struct CuDuRimInformation {
    pub victim_gnb_set_id: GnbSetId,
    pub rimrs_detection_status: RimrsDetectionStatus,
}

impl CuDuRimInformation {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, false, 1)?;
        let victim_gnb_set_id = GnbSetId::decode(data)?;
        let rimrs_detection_status = RimrsDetectionStatus::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            victim_gnb_set_id,
            rimrs_detection_status,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, false, &optionals, false)?;
        self.victim_gnb_set_id.encode(data)?;
        self.rimrs_detection_status.encode(data)?;

        Ok(())
    }
}

impl PerCodec for CuDuRimInformation {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        CuDuRimInformation::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CuDuRimInformation");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CuDuRimInformation");
            e
        })
    }
}
// CuToDuRrcInformation
#[derive(Clone, Debug)]
pub struct CuToDuRrcInformation {
    pub cg_config_info: Option<CgConfigInfo>,
    pub ue_capability_rat_container_list: Option<UeCapabilityRatContainerList>,
    pub meas_config: Option<MeasConfig>,
    pub handover_preparation_information: Option<HandoverPreparationInformation>,
    pub cell_group_config: Option<CellGroupConfig>,
    pub measurement_timing_configuration: Option<MeasurementTimingConfiguration>,
    pub ue_assistance_information: Option<UeAssistanceInformation>,
    pub cg_config: Option<CgConfig>,
    pub ue_assistance_information_eutra: Option<UeAssistanceInformationEutra>,
    pub location_measurement_information: Option<LocationMeasurementInformation>,
    pub musim_gap_config: Option<MusimGapConfig>,
    pub sdt_mac_phy_cg_config: Option<SdtMacPhyCgConfig>,
    pub mbs_interest_indication: Option<MbsInterestIndication>,
    pub need_for_gaps_info_nr: Option<NeedForGapsInfoNr>,
    pub need_for_gap_ncsg_info_nr: Option<NeedForGapNcsgInfoNr>,
    pub need_for_gap_ncsg_info_eutra: Option<NeedForGapNcsgInfoEutra>,
    pub config_restrict_info_daps: Option<ConfigRestrictInfoDaps>,
    pub preconfigured_measurement_gap_request: Option<PreconfiguredMeasurementGapRequest>,
    pub need_for_interruption_info_nr: Option<NeedForInterruptionInfoNr>,
    pub musim_capability_restriction_indication: Option<MusimCapabilityRestrictionIndication>,
    pub musim_candidate_band_list: Option<MusimCandidateBandList>,
}

impl CuToDuRrcInformation {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 4)?;
        let cg_config_info = if optionals[0] {
            Some(CgConfigInfo::decode(data)?)
        } else {
            None
        };
        let ue_capability_rat_container_list = if optionals[1] {
            Some(UeCapabilityRatContainerList::decode(data)?)
        } else {
            None
        };
        let meas_config = if optionals[2] {
            Some(MeasConfig::decode(data)?)
        } else {
            None
        };

        // Process the extension container
        let mut handover_preparation_information: Option<HandoverPreparationInformation> = None;
        let mut cell_group_config: Option<CellGroupConfig> = None;
        let mut measurement_timing_configuration: Option<MeasurementTimingConfiguration> = None;
        let mut ue_assistance_information: Option<UeAssistanceInformation> = None;
        let mut cg_config: Option<CgConfig> = None;
        let mut ue_assistance_information_eutra: Option<UeAssistanceInformationEutra> = None;
        let mut location_measurement_information: Option<LocationMeasurementInformation> = None;
        let mut musim_gap_config: Option<MusimGapConfig> = None;
        let mut sdt_mac_phy_cg_config: Option<SdtMacPhyCgConfig> = None;
        let mut mbs_interest_indication: Option<MbsInterestIndication> = None;
        let mut need_for_gaps_info_nr: Option<NeedForGapsInfoNr> = None;
        let mut need_for_gap_ncsg_info_nr: Option<NeedForGapNcsgInfoNr> = None;
        let mut need_for_gap_ncsg_info_eutra: Option<NeedForGapNcsgInfoEutra> = None;
        let mut config_restrict_info_daps: Option<ConfigRestrictInfoDaps> = None;
        let mut preconfigured_measurement_gap_request: Option<PreconfiguredMeasurementGapRequest> =
            None;
        let mut need_for_interruption_info_nr: Option<NeedForInterruptionInfoNr> = None;
        let mut musim_capability_restriction_indication: Option<
            MusimCapabilityRestrictionIndication,
        > = None;
        let mut musim_candidate_band_list: Option<MusimCandidateBandList> = None;

        if optionals[3] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    119 => {
                        handover_preparation_information =
                            Some(HandoverPreparationInformation::decode(data)?)
                    }
                    173 => cell_group_config = Some(CellGroupConfig::decode(data)?),
                    163 => {
                        measurement_timing_configuration =
                            Some(MeasurementTimingConfiguration::decode(data)?)
                    }
                    214 => ue_assistance_information = Some(UeAssistanceInformation::decode(data)?),
                    234 => cg_config = Some(CgConfig::decode(data)?),
                    339 => {
                        ue_assistance_information_eutra =
                            Some(UeAssistanceInformationEutra::decode(data)?)
                    }
                    440 => {
                        location_measurement_information =
                            Some(LocationMeasurementInformation::decode(data)?)
                    }
                    621 => musim_gap_config = Some(MusimGapConfig::decode(data)?),
                    587 => sdt_mac_phy_cg_config = Some(SdtMacPhyCgConfig::decode(data)?),
                    652 => mbs_interest_indication = Some(MbsInterestIndication::decode(data)?),
                    665 => need_for_gaps_info_nr = Some(NeedForGapsInfoNr::decode(data)?),
                    666 => need_for_gap_ncsg_info_nr = Some(NeedForGapNcsgInfoNr::decode(data)?),
                    667 => {
                        need_for_gap_ncsg_info_eutra = Some(NeedForGapNcsgInfoEutra::decode(data)?)
                    }
                    678 => config_restrict_info_daps = Some(ConfigRestrictInfoDaps::decode(data)?),
                    710 => {
                        preconfigured_measurement_gap_request =
                            Some(PreconfiguredMeasurementGapRequest::decode(data)?)
                    }
                    715 => {
                        need_for_interruption_info_nr =
                            Some(NeedForInterruptionInfoNr::decode(data)?)
                    }
                    718 => {
                        musim_capability_restriction_indication =
                            Some(MusimCapabilityRestrictionIndication::decode(data)?)
                    }
                    793 => musim_candidate_band_list = Some(MusimCandidateBandList::decode(data)?),
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            cg_config_info,
            ue_capability_rat_container_list,
            meas_config,
            handover_preparation_information,
            cell_group_config,
            measurement_timing_configuration,
            ue_assistance_information,
            cg_config,
            ue_assistance_information_eutra,
            location_measurement_information,
            musim_gap_config,
            sdt_mac_phy_cg_config,
            mbs_interest_indication,
            need_for_gaps_info_nr,
            need_for_gap_ncsg_info_nr,
            need_for_gap_ncsg_info_eutra,
            config_restrict_info_daps,
            preconfigured_measurement_gap_request,
            need_for_interruption_info_nr,
            musim_capability_restriction_indication,
            musim_candidate_band_list,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();
        if let Some(x) = &self.handover_preparation_information {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 119, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.cell_group_config {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 173, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.measurement_timing_configuration {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 163, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.ue_assistance_information {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 214, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.cg_config {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 234, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.ue_assistance_information_eutra {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 339, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.location_measurement_information {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 440, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.musim_gap_config {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 621, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.sdt_mac_phy_cg_config {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 587, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.mbs_interest_indication {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 652, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.need_for_gaps_info_nr {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 665, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.need_for_gap_ncsg_info_nr {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 666, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.need_for_gap_ncsg_info_eutra {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 667, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.config_restrict_info_daps {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 678, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.preconfigured_measurement_gap_request {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 710, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.need_for_interruption_info_nr {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 715, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.musim_capability_restriction_indication {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 718, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.musim_candidate_band_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 793, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        let mut optionals = BitString::new();
        optionals.push(self.cg_config_info.is_some());
        optionals.push(self.ue_capability_rat_container_list.is_some());
        optionals.push(self.meas_config.is_some());
        optionals.push(num_ies != 0);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        if let Some(x) = &self.cg_config_info {
            x.encode(data)?;
        }
        if let Some(x) = &self.ue_capability_rat_container_list {
            x.encode(data)?;
        }
        if let Some(x) = &self.meas_config {
            x.encode(data)?;
        }
        if num_ies != 0 {
            encode::encode_length_determinent(data, Some(1), Some(65535), false, num_ies)?;
            data.append_aligned(ies);
        }
        Ok(())
    }
}

impl PerCodec for CuToDuRrcInformation {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        CuToDuRrcInformation::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CuToDuRrcInformation");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CuToDuRrcInformation");
            e
        })
    }
}
// CuToDuTaInformationList
#[derive(Clone, Debug)]
pub struct CuToDuTaInformationList(pub NonEmpty<CuToDuTaInformationItem>);

impl CuToDuTaInformationList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(8), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(CuToDuTaInformationItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(8), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for CuToDuTaInformationList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        CuToDuTaInformationList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CuToDuTaInformationList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CuToDuTaInformationList");
            e
        })
    }
}
// CuToDuTaInformationItem
#[derive(Clone, Debug)]
pub struct CuToDuTaInformationItem {
    pub nr_cgi: NrCgi,
    pub ta_value: TaValue,
    pub preamble_index: PreambleIndex,
    pub ra_rnti: RaRnti,
    pub tag_id_pointer: Option<TagIdPointer>,
}

impl CuToDuTaInformationItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 2)?;
        let nr_cgi = NrCgi::decode(data)?;
        let ta_value = TaValue::decode(data)?;
        let preamble_index = PreambleIndex::decode(data)?;
        let ra_rnti = RaRnti::decode(data)?;
        let tag_id_pointer = if optionals[0] {
            Some(TagIdPointer::decode(data)?)
        } else {
            None
        };

        // Process the extension container

        if optionals[1] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            nr_cgi,
            ta_value,
            preamble_index,
            ra_rnti,
            tag_id_pointer,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.tag_id_pointer.is_some());
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.nr_cgi.encode(data)?;
        self.ta_value.encode(data)?;
        self.preamble_index.encode(data)?;
        self.ra_rnti.encode(data)?;
        if let Some(x) = &self.tag_id_pointer {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl PerCodec for CuToDuTaInformationItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        CuToDuTaInformationItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CuToDuTaInformationItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CuToDuTaInformationItem");
            e
        })
    }
}
// CsiResourceConfiguration
#[derive(Clone, Debug)]
pub struct CsiResourceConfiguration {
    pub csi_resource_config_to_add_mod_list: Option<Vec<u8>>,
    pub csi_resource_config_to_release_list: Option<Vec<u8>>,
}

impl CsiResourceConfiguration {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, false, 3)?;
        let csi_resource_config_to_add_mod_list = if optionals[0] {
            Some(decode::decode_octetstring(data, None, None, false)?)
        } else {
            None
        };
        let csi_resource_config_to_release_list = if optionals[1] {
            Some(decode::decode_octetstring(data, None, None, false)?)
        } else {
            None
        };

        // Process the extension container

        if optionals[2] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            csi_resource_config_to_add_mod_list,
            csi_resource_config_to_release_list,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.csi_resource_config_to_add_mod_list.is_some());
        optionals.push(self.csi_resource_config_to_release_list.is_some());
        optionals.push(false);

        encode::encode_sequence_header(data, false, &optionals, false)?;
        if let Some(x) = &self.csi_resource_config_to_add_mod_list {
            encode::encode_octetstring(data, None, None, false, &x, false)?;
        }
        if let Some(x) = &self.csi_resource_config_to_release_list {
            encode::encode_octetstring(data, None, None, false, &x, false)?;
        }

        Ok(())
    }
}

impl PerCodec for CsiResourceConfiguration {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        CsiResourceConfiguration::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CsiResourceConfiguration");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CsiResourceConfiguration");
            e
        })
    }
}
// DapsHoStatus
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum DapsHoStatus {
    Initiation,
}

impl DapsHoStatus {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(0), true)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(0),
            true,
            *self as i128,
            (*self as u32) >= 1,
        )
    }
}

impl PerCodec for DapsHoStatus {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        DapsHoStatus::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DapsHoStatus");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DapsHoStatus");
            e
        })
    }
}
// DcBasedDuplicationConfigured
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum DcBasedDuplicationConfigured {
    True,
    False,
}

impl DcBasedDuplicationConfigured {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(0), true)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(0),
            true,
            *self as i128,
            (*self as u32) >= 1,
        )
    }
}

impl PerCodec for DcBasedDuplicationConfigured {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        DcBasedDuplicationConfigured::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DcBasedDuplicationConfigured");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DcBasedDuplicationConfigured");
            e
        })
    }
}
// DeactivationIndication
#[derive(Clone, Debug)]
pub enum DeactivationIndication {
    PerUe(DeactivationIndicationList),
    DeactivateAll,
}

impl DeactivationIndication {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_choice_idx(data, 0, 2, false)?;
        if extended {
            return Err(per_codec_error_new("CHOICE additions not implemented"));
        }
        match idx {
            0 => Ok(Self::PerUe(DeactivationIndicationList::decode(data)?)),
            1 => Ok(Self::DeactivateAll),
            2 => {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _ = Criticality::decode(data)?;
                let _ = decode::decode_length_determinent(data, None, None, false)?;
                let result = match id {
                    x => Err(per_codec_error_new(format!("Unrecognised IE type {}", x))),
                };
                data.decode_align()?;
                result
            }
            _ => Err(per_codec_error_new("Unknown choice idx")),
        }
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        match self {
            Self::PerUe(x) => {
                encode::encode_choice_idx(data, 0, 2, false, 0, false)?;
                x.encode(data)
            }
            Self::DeactivateAll => {
                encode::encode_choice_idx(data, 0, 2, false, 1, false)?;
                Ok(())
            }
        }
    }
}

impl PerCodec for DeactivationIndication {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        DeactivationIndication::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DeactivationIndication");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DeactivationIndication");
            e
        })
    }
}
// DeactivationIndicationList
#[derive(Clone, Debug)]
pub struct DeactivationIndicationList(pub NonEmpty<DeactivationIndicationListItem>);

impl DeactivationIndicationList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(512), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(DeactivationIndicationListItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(512), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for DeactivationIndicationList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        DeactivationIndicationList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DeactivationIndicationList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DeactivationIndicationList");
            e
        })
    }
}
// DeactivationIndicationListItem
#[derive(Clone, Debug)]
pub struct DeactivationIndicationListItem {
    pub gnb_cu_ue_f1ap_id: GnbCuUeF1apId,
    pub gnb_du_ue_f1ap_id: GnbDuUeF1apId,
}

impl DeactivationIndicationListItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let gnb_cu_ue_f1ap_id = GnbCuUeF1apId::decode(data)?;
        let gnb_du_ue_f1ap_id = GnbDuUeF1apId::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            gnb_cu_ue_f1ap_id,
            gnb_du_ue_f1ap_id,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.gnb_cu_ue_f1ap_id.encode(data)?;
        self.gnb_du_ue_f1ap_id.encode(data)?;

        Ok(())
    }
}

impl PerCodec for DeactivationIndicationListItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        DeactivationIndicationListItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DeactivationIndicationListItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DeactivationIndicationListItem");
            e
        })
    }
}
// DedicatedSiDeliveryNeededUeItem
#[derive(Clone, Debug)]
pub struct DedicatedSiDeliveryNeededUeItem {
    pub gnb_cu_ue_f1ap_id: GnbCuUeF1apId,
    pub nr_cgi: NrCgi,
}

impl DedicatedSiDeliveryNeededUeItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let gnb_cu_ue_f1ap_id = GnbCuUeF1apId::decode(data)?;
        let nr_cgi = NrCgi::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            gnb_cu_ue_f1ap_id,
            nr_cgi,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.gnb_cu_ue_f1ap_id.encode(data)?;
        self.nr_cgi.encode(data)?;

        Ok(())
    }
}

impl PerCodec for DedicatedSiDeliveryNeededUeItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        DedicatedSiDeliveryNeededUeItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DedicatedSiDeliveryNeededUeItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DedicatedSiDeliveryNeededUeItem");
            e
        })
    }
}
// DedicatedSiDeliveryIndication
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum DedicatedSiDeliveryIndication {
    True,
}

impl DedicatedSiDeliveryIndication {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(0), true)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(0),
            true,
            *self as i128,
            (*self as u32) >= 1,
        )
    }
}

impl PerCodec for DedicatedSiDeliveryIndication {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        DedicatedSiDeliveryIndication::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DedicatedSiDeliveryIndication");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DedicatedSiDeliveryIndication");
            e
        })
    }
}
// DlPrs
#[derive(Clone, Debug)]
pub struct DlPrs {
    pub prsid: u8,
    pub dl_prs_resource_set_id: PrsResourceSetId,
    pub dl_prs_resource_id: Option<PrsResourceId>,
}

impl DlPrs {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, false, 2)?;
        let prsid = decode::decode_integer(data, Some(0), Some(255), false)?.0 as u8;
        let dl_prs_resource_set_id = PrsResourceSetId::decode(data)?;
        let dl_prs_resource_id = if optionals[0] {
            Some(PrsResourceId::decode(data)?)
        } else {
            None
        };

        // Process the extension container

        if optionals[1] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            prsid,
            dl_prs_resource_set_id,
            dl_prs_resource_id,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.dl_prs_resource_id.is_some());
        optionals.push(false);

        encode::encode_sequence_header(data, false, &optionals, false)?;
        encode::encode_integer(data, Some(0), Some(255), false, self.prsid as i128, false)?;
        self.dl_prs_resource_set_id.encode(data)?;
        if let Some(x) = &self.dl_prs_resource_id {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl PerCodec for DlPrs {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        DlPrs::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DlPrs");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DlPrs");
            e
        })
    }
}
// DlPrsMutingPattern
#[derive(Clone, Debug)]
pub enum DlPrsMutingPattern {
    Two(BitString),
    Four(BitString),
    Six(BitString),
    Eight(BitString),
    Sixteen(BitString),
    ThirtyTwo(BitString),
}

impl DlPrsMutingPattern {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_choice_idx(data, 0, 6, false)?;
        if extended {
            return Err(per_codec_error_new("CHOICE additions not implemented"));
        }
        match idx {
            0 => Ok(Self::Two(decode::decode_bitstring(
                data,
                Some(2),
                Some(2),
                false,
            )?)),
            1 => Ok(Self::Four(decode::decode_bitstring(
                data,
                Some(4),
                Some(4),
                false,
            )?)),
            2 => Ok(Self::Six(decode::decode_bitstring(
                data,
                Some(6),
                Some(6),
                false,
            )?)),
            3 => Ok(Self::Eight(decode::decode_bitstring(
                data,
                Some(8),
                Some(8),
                false,
            )?)),
            4 => Ok(Self::Sixteen(decode::decode_bitstring(
                data,
                Some(16),
                Some(16),
                false,
            )?)),
            5 => Ok(Self::ThirtyTwo(decode::decode_bitstring(
                data,
                Some(32),
                Some(32),
                false,
            )?)),
            6 => {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _ = Criticality::decode(data)?;
                let _ = decode::decode_length_determinent(data, None, None, false)?;
                let result = match id {
                    x => Err(per_codec_error_new(format!("Unrecognised IE type {}", x))),
                };
                data.decode_align()?;
                result
            }
            _ => Err(per_codec_error_new("Unknown choice idx")),
        }
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        match self {
            Self::Two(x) => {
                encode::encode_choice_idx(data, 0, 6, false, 0, false)?;
                encode::encode_bitstring(data, Some(2), Some(2), false, &x, false)
            }
            Self::Four(x) => {
                encode::encode_choice_idx(data, 0, 6, false, 1, false)?;
                encode::encode_bitstring(data, Some(4), Some(4), false, &x, false)
            }
            Self::Six(x) => {
                encode::encode_choice_idx(data, 0, 6, false, 2, false)?;
                encode::encode_bitstring(data, Some(6), Some(6), false, &x, false)
            }
            Self::Eight(x) => {
                encode::encode_choice_idx(data, 0, 6, false, 3, false)?;
                encode::encode_bitstring(data, Some(8), Some(8), false, &x, false)
            }
            Self::Sixteen(x) => {
                encode::encode_choice_idx(data, 0, 6, false, 4, false)?;
                encode::encode_bitstring(data, Some(16), Some(16), false, &x, false)
            }
            Self::ThirtyTwo(x) => {
                encode::encode_choice_idx(data, 0, 6, false, 5, false)?;
                encode::encode_bitstring(data, Some(32), Some(32), false, &x, false)
            }
        }
    }
}

impl PerCodec for DlPrsMutingPattern {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        DlPrsMutingPattern::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DlPrsMutingPattern");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DlPrsMutingPattern");
            e
        })
    }
}
// DlprsResourceCoordinates
#[derive(Clone, Debug)]
pub struct DlprsResourceCoordinates {
    pub listof_dl_prs_resource_set_arp: NonEmpty<DlprsResourceSetArp>,
}

impl DlprsResourceCoordinates {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, false, 1)?;
        let listof_dl_prs_resource_set_arp = {
            let length = decode::decode_length_determinent(data, Some(1), Some(2), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(DlprsResourceSetArp::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        };

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            listof_dl_prs_resource_set_arp,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, false, &optionals, false)?;
        encode::encode_length_determinent(
            data,
            Some(1),
            Some(2),
            false,
            self.listof_dl_prs_resource_set_arp.len(),
        )?;
        for x in &self.listof_dl_prs_resource_set_arp {
            x.encode(data)?;
        }
        Ok(())?;

        Ok(())
    }
}

impl PerCodec for DlprsResourceCoordinates {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        DlprsResourceCoordinates::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DlprsResourceCoordinates");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DlprsResourceCoordinates");
            e
        })
    }
}
// DlprsResourceSetArp
#[derive(Clone, Debug)]
pub struct DlprsResourceSetArp {
    pub dl_prs_resource_set_id: PrsResourceSetId,
    pub dl_prs_resource_set_arp_location: DlPrsResourceSetArpLocation,
    pub listof_dl_prs_resource_arp: NonEmpty<DlprsResourceArp>,
}

impl DlprsResourceSetArp {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, false, 1)?;
        let dl_prs_resource_set_id = PrsResourceSetId::decode(data)?;
        let dl_prs_resource_set_arp_location = DlPrsResourceSetArpLocation::decode(data)?;
        let listof_dl_prs_resource_arp = {
            let length = decode::decode_length_determinent(data, Some(1), Some(64), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(DlprsResourceArp::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        };

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            dl_prs_resource_set_id,
            dl_prs_resource_set_arp_location,
            listof_dl_prs_resource_arp,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, false, &optionals, false)?;
        self.dl_prs_resource_set_id.encode(data)?;
        self.dl_prs_resource_set_arp_location.encode(data)?;
        encode::encode_length_determinent(
            data,
            Some(1),
            Some(64),
            false,
            self.listof_dl_prs_resource_arp.len(),
        )?;
        for x in &self.listof_dl_prs_resource_arp {
            x.encode(data)?;
        }
        Ok(())?;

        Ok(())
    }
}

impl PerCodec for DlprsResourceSetArp {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        DlprsResourceSetArp::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DlprsResourceSetArp");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DlprsResourceSetArp");
            e
        })
    }
}
// DlPrsResourceSetArpLocation
#[derive(Clone, Debug)]
pub enum DlPrsResourceSetArpLocation {
    RelativeGeodeticLocation(RelativeGeodeticLocation),
    RelativeCartesianLocation(RelativeCartesianLocation),
}

impl DlPrsResourceSetArpLocation {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_choice_idx(data, 0, 2, false)?;
        if extended {
            return Err(per_codec_error_new("CHOICE additions not implemented"));
        }
        match idx {
            0 => Ok(Self::RelativeGeodeticLocation(
                RelativeGeodeticLocation::decode(data)?,
            )),
            1 => Ok(Self::RelativeCartesianLocation(
                RelativeCartesianLocation::decode(data)?,
            )),
            2 => {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _ = Criticality::decode(data)?;
                let _ = decode::decode_length_determinent(data, None, None, false)?;
                let result = match id {
                    x => Err(per_codec_error_new(format!("Unrecognised IE type {}", x))),
                };
                data.decode_align()?;
                result
            }
            _ => Err(per_codec_error_new("Unknown choice idx")),
        }
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        match self {
            Self::RelativeGeodeticLocation(x) => {
                encode::encode_choice_idx(data, 0, 2, false, 0, false)?;
                x.encode(data)
            }
            Self::RelativeCartesianLocation(x) => {
                encode::encode_choice_idx(data, 0, 2, false, 1, false)?;
                x.encode(data)
            }
        }
    }
}

impl PerCodec for DlPrsResourceSetArpLocation {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        DlPrsResourceSetArpLocation::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DlPrsResourceSetArpLocation");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DlPrsResourceSetArpLocation");
            e
        })
    }
}
// DlprsResourceArp
#[derive(Clone, Debug)]
pub struct DlprsResourceArp {
    pub dl_prs_resource_id: PrsResourceId,
    pub dl_prs_resource_arp_location: DlPrsResourceArpLocation,
}

impl DlprsResourceArp {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, false, 1)?;
        let dl_prs_resource_id = PrsResourceId::decode(data)?;
        let dl_prs_resource_arp_location = DlPrsResourceArpLocation::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            dl_prs_resource_id,
            dl_prs_resource_arp_location,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, false, &optionals, false)?;
        self.dl_prs_resource_id.encode(data)?;
        self.dl_prs_resource_arp_location.encode(data)?;

        Ok(())
    }
}

impl PerCodec for DlprsResourceArp {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        DlprsResourceArp::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DlprsResourceArp");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DlprsResourceArp");
            e
        })
    }
}
// DlPrsResourceArpLocation
#[derive(Clone, Debug)]
pub enum DlPrsResourceArpLocation {
    RelativeGeodeticLocation(RelativeGeodeticLocation),
    RelativeCartesianLocation(RelativeCartesianLocation),
}

impl DlPrsResourceArpLocation {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_choice_idx(data, 0, 2, false)?;
        if extended {
            return Err(per_codec_error_new("CHOICE additions not implemented"));
        }
        match idx {
            0 => Ok(Self::RelativeGeodeticLocation(
                RelativeGeodeticLocation::decode(data)?,
            )),
            1 => Ok(Self::RelativeCartesianLocation(
                RelativeCartesianLocation::decode(data)?,
            )),
            2 => {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _ = Criticality::decode(data)?;
                let _ = decode::decode_length_determinent(data, None, None, false)?;
                let result = match id {
                    x => Err(per_codec_error_new(format!("Unrecognised IE type {}", x))),
                };
                data.decode_align()?;
                result
            }
            _ => Err(per_codec_error_new("Unknown choice idx")),
        }
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        match self {
            Self::RelativeGeodeticLocation(x) => {
                encode::encode_choice_idx(data, 0, 2, false, 0, false)?;
                x.encode(data)
            }
            Self::RelativeCartesianLocation(x) => {
                encode::encode_choice_idx(data, 0, 2, false, 1, false)?;
                x.encode(data)
            }
        }
    }
}

impl PerCodec for DlPrsResourceArpLocation {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        DlPrsResourceArpLocation::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DlPrsResourceArpLocation");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DlPrsResourceArpLocation");
            e
        })
    }
}
// DlUpTnlAddressToUpdateListItem
#[derive(Clone, Debug)]
pub struct DlUpTnlAddressToUpdateListItem {
    pub old_ip_adress: TransportLayerAddress,
    pub new_ip_adress: TransportLayerAddress,
}

impl DlUpTnlAddressToUpdateListItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let old_ip_adress = TransportLayerAddress::decode(data)?;
        let new_ip_adress = TransportLayerAddress::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            old_ip_adress,
            new_ip_adress,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.old_ip_adress.encode(data)?;
        self.new_ip_adress.encode(data)?;

        Ok(())
    }
}

impl PerCodec for DlUpTnlAddressToUpdateListItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        DlUpTnlAddressToUpdateListItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DlUpTnlAddressToUpdateListItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DlUpTnlAddressToUpdateListItem");
            e
        })
    }
}
// DlUpTnlInformationToBeSetupList
#[derive(Clone, Debug)]
pub struct DlUpTnlInformationToBeSetupList(pub NonEmpty<DlUpTnlInformationToBeSetupItem>);

impl DlUpTnlInformationToBeSetupList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(2), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(DlUpTnlInformationToBeSetupItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(2), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for DlUpTnlInformationToBeSetupList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        DlUpTnlInformationToBeSetupList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DlUpTnlInformationToBeSetupList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DlUpTnlInformationToBeSetupList");
            e
        })
    }
}
// DlUpTnlInformationToBeSetupItem
#[derive(Clone, Debug)]
pub struct DlUpTnlInformationToBeSetupItem {
    pub dl_up_tnl_information: UpTransportLayerInformation,
}

impl DlUpTnlInformationToBeSetupItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let dl_up_tnl_information = UpTransportLayerInformation::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            dl_up_tnl_information,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.dl_up_tnl_information.encode(data)?;

        Ok(())
    }
}

impl PerCodec for DlUpTnlInformationToBeSetupItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        DlUpTnlInformationToBeSetupItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DlUpTnlInformationToBeSetupItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DlUpTnlInformationToBeSetupItem");
            e
        })
    }
}
// DrbActivityItem
#[derive(Clone, Debug)]
pub struct DrbActivityItem {
    pub drb_id: DrbId,
    pub drb_activity: Option<DrbActivity>,
}

impl DrbActivityItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 2)?;
        let drb_id = DrbId::decode(data)?;
        let drb_activity = if optionals[0] {
            Some(DrbActivity::decode(data)?)
        } else {
            None
        };

        // Process the extension container

        if optionals[1] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            drb_id,
            drb_activity,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.drb_activity.is_some());
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.drb_id.encode(data)?;
        if let Some(x) = &self.drb_activity {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl PerCodec for DrbActivityItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        DrbActivityItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DrbActivityItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DrbActivityItem");
            e
        })
    }
}
// DrbActivity
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum DrbActivity {
    Active,
    NotActive,
}

impl DrbActivity {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(1), false)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(1),
            false,
            *self as i128,
            (*self as u32) >= 2,
        )
    }
}

impl PerCodec for DrbActivity {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        DrbActivity::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DrbActivity");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DrbActivity");
            e
        })
    }
}
// DrbId
#[derive(Clone, Copy, Debug)]
pub struct DrbId(pub u8);

impl DrbId {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(
            decode::decode_integer(data, Some(1), Some(32), true)?.0 as u8,
        ))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_integer(data, Some(1), Some(32), true, self.0 as i128, false)
    }
}

impl PerCodec for DrbId {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        DrbId::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DrbId");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DrbId");
            e
        })
    }
}
// DrbsFailedToBeModifiedItem
#[derive(Clone, Debug)]
pub struct DrbsFailedToBeModifiedItem {
    pub drb_id: DrbId,
    pub cause: Option<Cause>,
}

impl DrbsFailedToBeModifiedItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 2)?;
        let drb_id = DrbId::decode(data)?;
        let cause = if optionals[0] {
            Some(Cause::decode(data)?)
        } else {
            None
        };

        // Process the extension container

        if optionals[1] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self { drb_id, cause })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.cause.is_some());
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.drb_id.encode(data)?;
        if let Some(x) = &self.cause {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl PerCodec for DrbsFailedToBeModifiedItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        DrbsFailedToBeModifiedItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DrbsFailedToBeModifiedItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DrbsFailedToBeModifiedItem");
            e
        })
    }
}
// DrbsFailedToBeSetupItem
#[derive(Clone, Debug)]
pub struct DrbsFailedToBeSetupItem {
    pub drb_id: DrbId,
    pub cause: Option<Cause>,
}

impl DrbsFailedToBeSetupItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 2)?;
        let drb_id = DrbId::decode(data)?;
        let cause = if optionals[0] {
            Some(Cause::decode(data)?)
        } else {
            None
        };

        // Process the extension container

        if optionals[1] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self { drb_id, cause })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.cause.is_some());
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.drb_id.encode(data)?;
        if let Some(x) = &self.cause {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl PerCodec for DrbsFailedToBeSetupItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        DrbsFailedToBeSetupItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DrbsFailedToBeSetupItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DrbsFailedToBeSetupItem");
            e
        })
    }
}
// DrbsFailedToBeSetupModItem
#[derive(Clone, Debug)]
pub struct DrbsFailedToBeSetupModItem {
    pub drb_id: DrbId,
    pub cause: Option<Cause>,
}

impl DrbsFailedToBeSetupModItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 2)?;
        let drb_id = DrbId::decode(data)?;
        let cause = if optionals[0] {
            Some(Cause::decode(data)?)
        } else {
            None
        };

        // Process the extension container

        if optionals[1] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self { drb_id, cause })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.cause.is_some());
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.drb_id.encode(data)?;
        if let Some(x) = &self.cause {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl PerCodec for DrbsFailedToBeSetupModItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        DrbsFailedToBeSetupModItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DrbsFailedToBeSetupModItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DrbsFailedToBeSetupModItem");
            e
        })
    }
}
// DrbInformation
#[derive(Clone, Debug)]
pub struct DrbInformation {
    pub drb_qos: QosFlowLevelQosParameters,
    pub snssai: Snssai,
    pub notification_control: Option<NotificationControl>,
    pub flows_mapped_to_drb_list: FlowsMappedToDrbList,
    pub ecn_markingor_congestion_information_reporting_request:
        Option<EcnMarkingorCongestionInformationReportingRequest>,
    pub p_sib_ased_s_du_discard_ul: Option<PSibAsedSDuDiscardUl>,
}

impl DrbInformation {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, false, 2)?;
        let drb_qos = QosFlowLevelQosParameters::decode(data)?;
        let snssai = Snssai::decode(data)?;
        let notification_control = if optionals[0] {
            Some(NotificationControl::decode(data)?)
        } else {
            None
        };
        let flows_mapped_to_drb_list = FlowsMappedToDrbList::decode(data)?;

        // Process the extension container
        let mut ecn_markingor_congestion_information_reporting_request: Option<
            EcnMarkingorCongestionInformationReportingRequest,
        > = None;
        let mut p_sib_ased_s_du_discard_ul: Option<PSibAsedSDuDiscardUl> = None;

        if optionals[1] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    777 => {
                        ecn_markingor_congestion_information_reporting_request = Some(
                            EcnMarkingorCongestionInformationReportingRequest::decode(data)?,
                        )
                    }
                    796 => p_sib_ased_s_du_discard_ul = Some(PSibAsedSDuDiscardUl::decode(data)?),
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            drb_qos,
            snssai,
            notification_control,
            flows_mapped_to_drb_list,
            ecn_markingor_congestion_information_reporting_request,
            p_sib_ased_s_du_discard_ul,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();
        if let Some(x) = &self.ecn_markingor_congestion_information_reporting_request {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 777, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.p_sib_ased_s_du_discard_ul {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 796, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        let mut optionals = BitString::new();
        optionals.push(self.notification_control.is_some());
        optionals.push(num_ies != 0);

        encode::encode_sequence_header(data, false, &optionals, false)?;
        self.drb_qos.encode(data)?;
        self.snssai.encode(data)?;
        if let Some(x) = &self.notification_control {
            x.encode(data)?;
        }
        self.flows_mapped_to_drb_list.encode(data)?;
        if num_ies != 0 {
            encode::encode_length_determinent(data, Some(1), Some(65535), false, num_ies)?;
            data.append_aligned(ies);
        }
        Ok(())
    }
}

impl PerCodec for DrbInformation {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        DrbInformation::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DrbInformation");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DrbInformation");
            e
        })
    }
}
// DrbsModifiedItem
#[derive(Clone, Debug)]
pub struct DrbsModifiedItem {
    pub drb_id: DrbId,
    pub lcid: Option<Lcid>,
    pub dl_up_tnl_information_to_be_setup_list: DlUpTnlInformationToBeSetupList,
    pub rlc_status: Option<RlcStatus>,
    pub additional_pdcp_duplication_tnl_list: Option<AdditionalPdcpDuplicationTnlList>,
    pub current_qos_para_set_index: Option<QosParaSetIndex>,
    pub tsc_traffic_characteristics_feedback: Option<TscTrafficCharacteristicsFeedback>,
    pub ecn_markingor_congestion_information_reporting_status:
        Option<EcnMarkingorCongestionInformationReportingStatus>,
}

impl DrbsModifiedItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 2)?;
        let drb_id = DrbId::decode(data)?;
        let lcid = if optionals[0] {
            Some(Lcid::decode(data)?)
        } else {
            None
        };
        let dl_up_tnl_information_to_be_setup_list = DlUpTnlInformationToBeSetupList::decode(data)?;

        // Process the extension container
        let mut rlc_status: Option<RlcStatus> = None;
        let mut additional_pdcp_duplication_tnl_list: Option<AdditionalPdcpDuplicationTnlList> =
            None;
        let mut current_qos_para_set_index: Option<QosParaSetIndex> = None;
        let mut tsc_traffic_characteristics_feedback: Option<TscTrafficCharacteristicsFeedback> =
            None;
        let mut ecn_markingor_congestion_information_reporting_status: Option<
            EcnMarkingorCongestionInformationReportingStatus,
        > = None;

        if optionals[1] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    160 => rlc_status = Some(RlcStatus::decode(data)?),
                    370 => {
                        additional_pdcp_duplication_tnl_list =
                            Some(AdditionalPdcpDuplicationTnlList::decode(data)?)
                    }
                    344 => current_qos_para_set_index = Some(QosParaSetIndex::decode(data)?),
                    751 => {
                        tsc_traffic_characteristics_feedback =
                            Some(TscTrafficCharacteristicsFeedback::decode(data)?)
                    }
                    778 => {
                        ecn_markingor_congestion_information_reporting_status = Some(
                            EcnMarkingorCongestionInformationReportingStatus::decode(data)?,
                        )
                    }
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            drb_id,
            lcid,
            dl_up_tnl_information_to_be_setup_list,
            rlc_status,
            additional_pdcp_duplication_tnl_list,
            current_qos_para_set_index,
            tsc_traffic_characteristics_feedback,
            ecn_markingor_congestion_information_reporting_status,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();
        if let Some(x) = &self.rlc_status {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 160, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.additional_pdcp_duplication_tnl_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 370, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.current_qos_para_set_index {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 344, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.tsc_traffic_characteristics_feedback {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 751, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.ecn_markingor_congestion_information_reporting_status {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 778, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        let mut optionals = BitString::new();
        optionals.push(self.lcid.is_some());
        optionals.push(num_ies != 0);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.drb_id.encode(data)?;
        if let Some(x) = &self.lcid {
            x.encode(data)?;
        }
        self.dl_up_tnl_information_to_be_setup_list.encode(data)?;
        if num_ies != 0 {
            encode::encode_length_determinent(data, Some(1), Some(65535), false, num_ies)?;
            data.append_aligned(ies);
        }
        Ok(())
    }
}

impl PerCodec for DrbsModifiedItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        DrbsModifiedItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DrbsModifiedItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DrbsModifiedItem");
            e
        })
    }
}
// DrbsModifiedConfItem
#[derive(Clone, Debug)]
pub struct DrbsModifiedConfItem {
    pub drb_id: DrbId,
    pub ul_up_tnl_information_to_be_setup_list: UlUpTnlInformationToBeSetupList,
    pub additional_pdcp_duplication_tnl_list: Option<AdditionalPdcpDuplicationTnlList>,
}

impl DrbsModifiedConfItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let drb_id = DrbId::decode(data)?;
        let ul_up_tnl_information_to_be_setup_list = UlUpTnlInformationToBeSetupList::decode(data)?;

        // Process the extension container
        let mut additional_pdcp_duplication_tnl_list: Option<AdditionalPdcpDuplicationTnlList> =
            None;

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    370 => {
                        additional_pdcp_duplication_tnl_list =
                            Some(AdditionalPdcpDuplicationTnlList::decode(data)?)
                    }
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            drb_id,
            ul_up_tnl_information_to_be_setup_list,
            additional_pdcp_duplication_tnl_list,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();
        if let Some(x) = &self.additional_pdcp_duplication_tnl_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 370, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        let mut optionals = BitString::new();
        optionals.push(num_ies != 0);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.drb_id.encode(data)?;
        self.ul_up_tnl_information_to_be_setup_list.encode(data)?;
        if num_ies != 0 {
            encode::encode_length_determinent(data, Some(1), Some(65535), false, num_ies)?;
            data.append_aligned(ies);
        }
        Ok(())
    }
}

impl PerCodec for DrbsModifiedConfItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        DrbsModifiedConfItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DrbsModifiedConfItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DrbsModifiedConfItem");
            e
        })
    }
}
// DrbNotifyItem
#[derive(Clone, Debug)]
pub struct DrbNotifyItem {
    pub drb_id: DrbId,
    pub notification_cause: NotificationCause,
    pub current_qos_para_set_index: Option<QosParaSetNotifyIndex>,
    pub tsc_traffic_characteristics_feedback: Option<TscTrafficCharacteristicsFeedback>,
}

impl DrbNotifyItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let drb_id = DrbId::decode(data)?;
        let notification_cause = NotificationCause::decode(data)?;

        // Process the extension container
        let mut current_qos_para_set_index: Option<QosParaSetNotifyIndex> = None;
        let mut tsc_traffic_characteristics_feedback: Option<TscTrafficCharacteristicsFeedback> =
            None;

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    344 => current_qos_para_set_index = Some(QosParaSetNotifyIndex::decode(data)?),
                    751 => {
                        tsc_traffic_characteristics_feedback =
                            Some(TscTrafficCharacteristicsFeedback::decode(data)?)
                    }
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            drb_id,
            notification_cause,
            current_qos_para_set_index,
            tsc_traffic_characteristics_feedback,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();
        if let Some(x) = &self.current_qos_para_set_index {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 344, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.tsc_traffic_characteristics_feedback {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 751, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        let mut optionals = BitString::new();
        optionals.push(num_ies != 0);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.drb_id.encode(data)?;
        self.notification_cause.encode(data)?;
        if num_ies != 0 {
            encode::encode_length_determinent(data, Some(1), Some(65535), false, num_ies)?;
            data.append_aligned(ies);
        }
        Ok(())
    }
}

impl PerCodec for DrbNotifyItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        DrbNotifyItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DrbNotifyItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DrbNotifyItem");
            e
        })
    }
}
// DrbsRequiredToBeModifiedItem
#[derive(Clone, Debug)]
pub struct DrbsRequiredToBeModifiedItem {
    pub drb_id: DrbId,
    pub dl_up_tnl_information_to_be_setup_list: DlUpTnlInformationToBeSetupList,
    pub rlc_status: Option<RlcStatus>,
    pub additional_pdcp_duplication_tnl_list: Option<AdditionalPdcpDuplicationTnlList>,
}

impl DrbsRequiredToBeModifiedItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let drb_id = DrbId::decode(data)?;
        let dl_up_tnl_information_to_be_setup_list = DlUpTnlInformationToBeSetupList::decode(data)?;

        // Process the extension container
        let mut rlc_status: Option<RlcStatus> = None;
        let mut additional_pdcp_duplication_tnl_list: Option<AdditionalPdcpDuplicationTnlList> =
            None;

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    160 => rlc_status = Some(RlcStatus::decode(data)?),
                    370 => {
                        additional_pdcp_duplication_tnl_list =
                            Some(AdditionalPdcpDuplicationTnlList::decode(data)?)
                    }
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            drb_id,
            dl_up_tnl_information_to_be_setup_list,
            rlc_status,
            additional_pdcp_duplication_tnl_list,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();
        if let Some(x) = &self.rlc_status {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 160, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.additional_pdcp_duplication_tnl_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 370, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        let mut optionals = BitString::new();
        optionals.push(num_ies != 0);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.drb_id.encode(data)?;
        self.dl_up_tnl_information_to_be_setup_list.encode(data)?;
        if num_ies != 0 {
            encode::encode_length_determinent(data, Some(1), Some(65535), false, num_ies)?;
            data.append_aligned(ies);
        }
        Ok(())
    }
}

impl PerCodec for DrbsRequiredToBeModifiedItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        DrbsRequiredToBeModifiedItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DrbsRequiredToBeModifiedItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DrbsRequiredToBeModifiedItem");
            e
        })
    }
}
// DrbsRequiredToBeReleasedItem
#[derive(Clone, Debug)]
pub struct DrbsRequiredToBeReleasedItem {
    pub drb_id: DrbId,
}

impl DrbsRequiredToBeReleasedItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let drb_id = DrbId::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self { drb_id })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.drb_id.encode(data)?;

        Ok(())
    }
}

impl PerCodec for DrbsRequiredToBeReleasedItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        DrbsRequiredToBeReleasedItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DrbsRequiredToBeReleasedItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DrbsRequiredToBeReleasedItem");
            e
        })
    }
}
// DrbsSetupItem
#[derive(Clone, Debug)]
pub struct DrbsSetupItem {
    pub drb_id: DrbId,
    pub lcid: Option<Lcid>,
    pub dl_up_tnl_information_to_be_setup_list: DlUpTnlInformationToBeSetupList,
    pub additional_pdcp_duplication_tnl_list: Option<AdditionalPdcpDuplicationTnlList>,
    pub current_qos_para_set_index: Option<QosParaSetIndex>,
    pub tsc_traffic_characteristics_feedback: Option<TscTrafficCharacteristicsFeedback>,
    pub ecn_markingor_congestion_information_reporting_status:
        Option<EcnMarkingorCongestionInformationReportingStatus>,
}

impl DrbsSetupItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 2)?;
        let drb_id = DrbId::decode(data)?;
        let lcid = if optionals[0] {
            Some(Lcid::decode(data)?)
        } else {
            None
        };
        let dl_up_tnl_information_to_be_setup_list = DlUpTnlInformationToBeSetupList::decode(data)?;

        // Process the extension container
        let mut additional_pdcp_duplication_tnl_list: Option<AdditionalPdcpDuplicationTnlList> =
            None;
        let mut current_qos_para_set_index: Option<QosParaSetIndex> = None;
        let mut tsc_traffic_characteristics_feedback: Option<TscTrafficCharacteristicsFeedback> =
            None;
        let mut ecn_markingor_congestion_information_reporting_status: Option<
            EcnMarkingorCongestionInformationReportingStatus,
        > = None;

        if optionals[1] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    370 => {
                        additional_pdcp_duplication_tnl_list =
                            Some(AdditionalPdcpDuplicationTnlList::decode(data)?)
                    }
                    344 => current_qos_para_set_index = Some(QosParaSetIndex::decode(data)?),
                    751 => {
                        tsc_traffic_characteristics_feedback =
                            Some(TscTrafficCharacteristicsFeedback::decode(data)?)
                    }
                    778 => {
                        ecn_markingor_congestion_information_reporting_status = Some(
                            EcnMarkingorCongestionInformationReportingStatus::decode(data)?,
                        )
                    }
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            drb_id,
            lcid,
            dl_up_tnl_information_to_be_setup_list,
            additional_pdcp_duplication_tnl_list,
            current_qos_para_set_index,
            tsc_traffic_characteristics_feedback,
            ecn_markingor_congestion_information_reporting_status,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();
        if let Some(x) = &self.additional_pdcp_duplication_tnl_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 370, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.current_qos_para_set_index {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 344, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.tsc_traffic_characteristics_feedback {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 751, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.ecn_markingor_congestion_information_reporting_status {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 778, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        let mut optionals = BitString::new();
        optionals.push(self.lcid.is_some());
        optionals.push(num_ies != 0);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.drb_id.encode(data)?;
        if let Some(x) = &self.lcid {
            x.encode(data)?;
        }
        self.dl_up_tnl_information_to_be_setup_list.encode(data)?;
        if num_ies != 0 {
            encode::encode_length_determinent(data, Some(1), Some(65535), false, num_ies)?;
            data.append_aligned(ies);
        }
        Ok(())
    }
}

impl PerCodec for DrbsSetupItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        DrbsSetupItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DrbsSetupItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DrbsSetupItem");
            e
        })
    }
}
// DrbsSetupModItem
#[derive(Clone, Debug)]
pub struct DrbsSetupModItem {
    pub drb_id: DrbId,
    pub lcid: Option<Lcid>,
    pub dl_up_tnl_information_to_be_setup_list: DlUpTnlInformationToBeSetupList,
    pub additional_pdcp_duplication_tnl_list: Option<AdditionalPdcpDuplicationTnlList>,
    pub current_qos_para_set_index: Option<QosParaSetIndex>,
    pub tsc_traffic_characteristics_feedback: Option<TscTrafficCharacteristicsFeedback>,
    pub ecn_markingor_congestion_information_reporting_status:
        Option<EcnMarkingorCongestionInformationReportingStatus>,
}

impl DrbsSetupModItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 2)?;
        let drb_id = DrbId::decode(data)?;
        let lcid = if optionals[0] {
            Some(Lcid::decode(data)?)
        } else {
            None
        };
        let dl_up_tnl_information_to_be_setup_list = DlUpTnlInformationToBeSetupList::decode(data)?;

        // Process the extension container
        let mut additional_pdcp_duplication_tnl_list: Option<AdditionalPdcpDuplicationTnlList> =
            None;
        let mut current_qos_para_set_index: Option<QosParaSetIndex> = None;
        let mut tsc_traffic_characteristics_feedback: Option<TscTrafficCharacteristicsFeedback> =
            None;
        let mut ecn_markingor_congestion_information_reporting_status: Option<
            EcnMarkingorCongestionInformationReportingStatus,
        > = None;

        if optionals[1] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    370 => {
                        additional_pdcp_duplication_tnl_list =
                            Some(AdditionalPdcpDuplicationTnlList::decode(data)?)
                    }
                    344 => current_qos_para_set_index = Some(QosParaSetIndex::decode(data)?),
                    751 => {
                        tsc_traffic_characteristics_feedback =
                            Some(TscTrafficCharacteristicsFeedback::decode(data)?)
                    }
                    778 => {
                        ecn_markingor_congestion_information_reporting_status = Some(
                            EcnMarkingorCongestionInformationReportingStatus::decode(data)?,
                        )
                    }
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            drb_id,
            lcid,
            dl_up_tnl_information_to_be_setup_list,
            additional_pdcp_duplication_tnl_list,
            current_qos_para_set_index,
            tsc_traffic_characteristics_feedback,
            ecn_markingor_congestion_information_reporting_status,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();
        if let Some(x) = &self.additional_pdcp_duplication_tnl_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 370, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.current_qos_para_set_index {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 344, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.tsc_traffic_characteristics_feedback {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 751, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.ecn_markingor_congestion_information_reporting_status {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 778, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        let mut optionals = BitString::new();
        optionals.push(self.lcid.is_some());
        optionals.push(num_ies != 0);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.drb_id.encode(data)?;
        if let Some(x) = &self.lcid {
            x.encode(data)?;
        }
        self.dl_up_tnl_information_to_be_setup_list.encode(data)?;
        if num_ies != 0 {
            encode::encode_length_determinent(data, Some(1), Some(65535), false, num_ies)?;
            data.append_aligned(ies);
        }
        Ok(())
    }
}

impl PerCodec for DrbsSetupModItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        DrbsSetupModItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DrbsSetupModItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DrbsSetupModItem");
            e
        })
    }
}
// DrbsToBeModifiedItem
#[derive(Clone, Debug)]
pub struct DrbsToBeModifiedItem {
    pub drb_id: DrbId,
    pub qos_information: Option<QosInformation>,
    pub ul_up_tnl_information_to_be_setup_list: UlUpTnlInformationToBeSetupList,
    pub ul_configuration: Option<UlConfiguration>,
    pub dlpdcpsn_length: Option<PdcpsnLength>,
    pub ulpdcpsn_length: Option<PdcpsnLength>,
    pub bearer_type_change: Option<BearerTypeChange>,
    pub rlc_mode: Option<RlcMode>,
    pub duplication_activation: Option<DuplicationActivation>,
    pub dc_based_duplication_configured: Option<DcBasedDuplicationConfigured>,
    pub dc_based_duplication_activation: Option<DuplicationActivation>,
    pub additional_pdcp_duplication_tnl_list: Option<AdditionalPdcpDuplicationTnlList>,
    pub rlc_duplication_information: Option<RlcDuplicationInformation>,
    pub transmission_stop_indicator: Option<TransmissionStopIndicator>,
    pub cg_sd_tindicator_mod: Option<CgSdTindicatorMod>,
}

impl DrbsToBeModifiedItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 3)?;
        let drb_id = DrbId::decode(data)?;
        let qos_information = if optionals[0] {
            Some(QosInformation::decode(data)?)
        } else {
            None
        };
        let ul_up_tnl_information_to_be_setup_list = UlUpTnlInformationToBeSetupList::decode(data)?;
        let ul_configuration = if optionals[1] {
            Some(UlConfiguration::decode(data)?)
        } else {
            None
        };

        // Process the extension container
        let mut dlpdcpsn_length: Option<PdcpsnLength> = None;
        let mut ulpdcpsn_length: Option<PdcpsnLength> = None;
        let mut bearer_type_change: Option<BearerTypeChange> = None;
        let mut rlc_mode: Option<RlcMode> = None;
        let mut duplication_activation: Option<DuplicationActivation> = None;
        let mut dc_based_duplication_configured: Option<DcBasedDuplicationConfigured> = None;
        let mut dc_based_duplication_activation: Option<DuplicationActivation> = None;
        let mut additional_pdcp_duplication_tnl_list: Option<AdditionalPdcpDuplicationTnlList> =
            None;
        let mut rlc_duplication_information: Option<RlcDuplicationInformation> = None;
        let mut transmission_stop_indicator: Option<TransmissionStopIndicator> = None;
        let mut cg_sd_tindicator_mod: Option<CgSdTindicatorMod> = None;

        if optionals[2] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    161 => dlpdcpsn_length = Some(PdcpsnLength::decode(data)?),
                    192 => ulpdcpsn_length = Some(PdcpsnLength::decode(data)?),
                    186 => bearer_type_change = Some(BearerTypeChange::decode(data)?),
                    187 => rlc_mode = Some(RlcMode::decode(data)?),
                    188 => duplication_activation = Some(DuplicationActivation::decode(data)?),
                    176 => {
                        dc_based_duplication_configured =
                            Some(DcBasedDuplicationConfigured::decode(data)?)
                    }
                    177 => {
                        dc_based_duplication_activation = Some(DuplicationActivation::decode(data)?)
                    }
                    370 => {
                        additional_pdcp_duplication_tnl_list =
                            Some(AdditionalPdcpDuplicationTnlList::decode(data)?)
                    }
                    371 => {
                        rlc_duplication_information = Some(RlcDuplicationInformation::decode(data)?)
                    }
                    430 => {
                        transmission_stop_indicator = Some(TransmissionStopIndicator::decode(data)?)
                    }
                    590 => cg_sd_tindicator_mod = Some(CgSdTindicatorMod::decode(data)?),
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            drb_id,
            qos_information,
            ul_up_tnl_information_to_be_setup_list,
            ul_configuration,
            dlpdcpsn_length,
            ulpdcpsn_length,
            bearer_type_change,
            rlc_mode,
            duplication_activation,
            dc_based_duplication_configured,
            dc_based_duplication_activation,
            additional_pdcp_duplication_tnl_list,
            rlc_duplication_information,
            transmission_stop_indicator,
            cg_sd_tindicator_mod,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();
        if let Some(x) = &self.dlpdcpsn_length {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 161, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.ulpdcpsn_length {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 192, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.bearer_type_change {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 186, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.rlc_mode {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 187, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.duplication_activation {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 188, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.dc_based_duplication_configured {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 176, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.dc_based_duplication_activation {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 177, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.additional_pdcp_duplication_tnl_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 370, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.rlc_duplication_information {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 371, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.transmission_stop_indicator {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 430, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.cg_sd_tindicator_mod {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 590, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        let mut optionals = BitString::new();
        optionals.push(self.qos_information.is_some());
        optionals.push(self.ul_configuration.is_some());
        optionals.push(num_ies != 0);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.drb_id.encode(data)?;
        if let Some(x) = &self.qos_information {
            x.encode(data)?;
        }
        self.ul_up_tnl_information_to_be_setup_list.encode(data)?;
        if let Some(x) = &self.ul_configuration {
            x.encode(data)?;
        }
        if num_ies != 0 {
            encode::encode_length_determinent(data, Some(1), Some(65535), false, num_ies)?;
            data.append_aligned(ies);
        }
        Ok(())
    }
}

impl PerCodec for DrbsToBeModifiedItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        DrbsToBeModifiedItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DrbsToBeModifiedItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DrbsToBeModifiedItem");
            e
        })
    }
}
// DrbsToBeReleasedItem
#[derive(Clone, Debug)]
pub struct DrbsToBeReleasedItem {
    pub drb_id: DrbId,
}

impl DrbsToBeReleasedItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let drb_id = DrbId::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self { drb_id })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.drb_id.encode(data)?;

        Ok(())
    }
}

impl PerCodec for DrbsToBeReleasedItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        DrbsToBeReleasedItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DrbsToBeReleasedItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DrbsToBeReleasedItem");
            e
        })
    }
}
// DrbsToBeSetupItem
#[derive(Clone, Debug)]
pub struct DrbsToBeSetupItem {
    pub drb_id: DrbId,
    pub qos_information: QosInformation,
    pub ul_up_tnl_information_to_be_setup_list: UlUpTnlInformationToBeSetupList,
    pub rlc_mode: RlcMode,
    pub ul_configuration: Option<UlConfiguration>,
    pub duplication_activation: Option<DuplicationActivation>,
    pub dc_based_duplication_configured: Option<DcBasedDuplicationConfigured>,
    pub dc_based_duplication_activation: Option<DuplicationActivation>,
    pub dlpdcpsn_length: Option<PdcpsnLength>,
    pub ulpdcpsn_length: Option<PdcpsnLength>,
    pub additional_pdcp_duplication_tnl_list: Option<AdditionalPdcpDuplicationTnlList>,
    pub rlc_duplication_information: Option<RlcDuplicationInformation>,
    pub sdtrlc_bearer_configuration: Option<SdtrlcBearerConfiguration>,
}

impl DrbsToBeSetupItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 3)?;
        let drb_id = DrbId::decode(data)?;
        let qos_information = QosInformation::decode(data)?;
        let ul_up_tnl_information_to_be_setup_list = UlUpTnlInformationToBeSetupList::decode(data)?;
        let rlc_mode = RlcMode::decode(data)?;
        let ul_configuration = if optionals[0] {
            Some(UlConfiguration::decode(data)?)
        } else {
            None
        };
        let duplication_activation = if optionals[1] {
            Some(DuplicationActivation::decode(data)?)
        } else {
            None
        };

        // Process the extension container
        let mut dc_based_duplication_configured: Option<DcBasedDuplicationConfigured> = None;
        let mut dc_based_duplication_activation: Option<DuplicationActivation> = None;
        let mut dlpdcpsn_length: Option<PdcpsnLength> = None;
        let mut ulpdcpsn_length: Option<PdcpsnLength> = None;
        let mut additional_pdcp_duplication_tnl_list: Option<AdditionalPdcpDuplicationTnlList> =
            None;
        let mut rlc_duplication_information: Option<RlcDuplicationInformation> = None;
        let mut sdtrlc_bearer_configuration: Option<SdtrlcBearerConfiguration> = None;

        if optionals[2] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    176 => {
                        dc_based_duplication_configured =
                            Some(DcBasedDuplicationConfigured::decode(data)?)
                    }
                    177 => {
                        dc_based_duplication_activation = Some(DuplicationActivation::decode(data)?)
                    }
                    161 => dlpdcpsn_length = Some(PdcpsnLength::decode(data)?),
                    192 => ulpdcpsn_length = Some(PdcpsnLength::decode(data)?),
                    370 => {
                        additional_pdcp_duplication_tnl_list =
                            Some(AdditionalPdcpDuplicationTnlList::decode(data)?)
                    }
                    371 => {
                        rlc_duplication_information = Some(RlcDuplicationInformation::decode(data)?)
                    }
                    593 => {
                        sdtrlc_bearer_configuration = Some(SdtrlcBearerConfiguration::decode(data)?)
                    }
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            drb_id,
            qos_information,
            ul_up_tnl_information_to_be_setup_list,
            rlc_mode,
            ul_configuration,
            duplication_activation,
            dc_based_duplication_configured,
            dc_based_duplication_activation,
            dlpdcpsn_length,
            ulpdcpsn_length,
            additional_pdcp_duplication_tnl_list,
            rlc_duplication_information,
            sdtrlc_bearer_configuration,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();
        if let Some(x) = &self.dc_based_duplication_configured {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 176, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.dc_based_duplication_activation {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 177, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.dlpdcpsn_length {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 161, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.ulpdcpsn_length {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 192, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.additional_pdcp_duplication_tnl_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 370, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.rlc_duplication_information {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 371, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.sdtrlc_bearer_configuration {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 593, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        let mut optionals = BitString::new();
        optionals.push(self.ul_configuration.is_some());
        optionals.push(self.duplication_activation.is_some());
        optionals.push(num_ies != 0);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.drb_id.encode(data)?;
        self.qos_information.encode(data)?;
        self.ul_up_tnl_information_to_be_setup_list.encode(data)?;
        self.rlc_mode.encode(data)?;
        if let Some(x) = &self.ul_configuration {
            x.encode(data)?;
        }
        if let Some(x) = &self.duplication_activation {
            x.encode(data)?;
        }
        if num_ies != 0 {
            encode::encode_length_determinent(data, Some(1), Some(65535), false, num_ies)?;
            data.append_aligned(ies);
        }
        Ok(())
    }
}

impl PerCodec for DrbsToBeSetupItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        DrbsToBeSetupItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DrbsToBeSetupItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DrbsToBeSetupItem");
            e
        })
    }
}
// DrbsToBeSetupModItem
#[derive(Clone, Debug)]
pub struct DrbsToBeSetupModItem {
    pub drb_id: DrbId,
    pub qos_information: QosInformation,
    pub ul_up_tnl_information_to_be_setup_list: UlUpTnlInformationToBeSetupList,
    pub rlc_mode: RlcMode,
    pub ul_configuration: Option<UlConfiguration>,
    pub duplication_activation: Option<DuplicationActivation>,
    pub dc_based_duplication_configured: Option<DcBasedDuplicationConfigured>,
    pub dc_based_duplication_activation: Option<DuplicationActivation>,
    pub dlpdcpsn_length: Option<PdcpsnLength>,
    pub ulpdcpsn_length: Option<PdcpsnLength>,
    pub additional_pdcp_duplication_tnl_list: Option<AdditionalPdcpDuplicationTnlList>,
    pub rlc_duplication_information: Option<RlcDuplicationInformation>,
    pub cg_sd_tindicator_setup: Option<CgSdTindicatorSetup>,
}

impl DrbsToBeSetupModItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 3)?;
        let drb_id = DrbId::decode(data)?;
        let qos_information = QosInformation::decode(data)?;
        let ul_up_tnl_information_to_be_setup_list = UlUpTnlInformationToBeSetupList::decode(data)?;
        let rlc_mode = RlcMode::decode(data)?;
        let ul_configuration = if optionals[0] {
            Some(UlConfiguration::decode(data)?)
        } else {
            None
        };
        let duplication_activation = if optionals[1] {
            Some(DuplicationActivation::decode(data)?)
        } else {
            None
        };

        // Process the extension container
        let mut dc_based_duplication_configured: Option<DcBasedDuplicationConfigured> = None;
        let mut dc_based_duplication_activation: Option<DuplicationActivation> = None;
        let mut dlpdcpsn_length: Option<PdcpsnLength> = None;
        let mut ulpdcpsn_length: Option<PdcpsnLength> = None;
        let mut additional_pdcp_duplication_tnl_list: Option<AdditionalPdcpDuplicationTnlList> =
            None;
        let mut rlc_duplication_information: Option<RlcDuplicationInformation> = None;
        let mut cg_sd_tindicator_setup: Option<CgSdTindicatorSetup> = None;

        if optionals[2] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    176 => {
                        dc_based_duplication_configured =
                            Some(DcBasedDuplicationConfigured::decode(data)?)
                    }
                    177 => {
                        dc_based_duplication_activation = Some(DuplicationActivation::decode(data)?)
                    }
                    161 => dlpdcpsn_length = Some(PdcpsnLength::decode(data)?),
                    192 => ulpdcpsn_length = Some(PdcpsnLength::decode(data)?),
                    370 => {
                        additional_pdcp_duplication_tnl_list =
                            Some(AdditionalPdcpDuplicationTnlList::decode(data)?)
                    }
                    371 => {
                        rlc_duplication_information = Some(RlcDuplicationInformation::decode(data)?)
                    }
                    589 => cg_sd_tindicator_setup = Some(CgSdTindicatorSetup::decode(data)?),
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            drb_id,
            qos_information,
            ul_up_tnl_information_to_be_setup_list,
            rlc_mode,
            ul_configuration,
            duplication_activation,
            dc_based_duplication_configured,
            dc_based_duplication_activation,
            dlpdcpsn_length,
            ulpdcpsn_length,
            additional_pdcp_duplication_tnl_list,
            rlc_duplication_information,
            cg_sd_tindicator_setup,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();
        if let Some(x) = &self.dc_based_duplication_configured {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 176, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.dc_based_duplication_activation {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 177, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.dlpdcpsn_length {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 161, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.ulpdcpsn_length {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 192, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.additional_pdcp_duplication_tnl_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 370, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.rlc_duplication_information {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 371, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.cg_sd_tindicator_setup {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 589, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        let mut optionals = BitString::new();
        optionals.push(self.ul_configuration.is_some());
        optionals.push(self.duplication_activation.is_some());
        optionals.push(num_ies != 0);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.drb_id.encode(data)?;
        self.qos_information.encode(data)?;
        self.ul_up_tnl_information_to_be_setup_list.encode(data)?;
        self.rlc_mode.encode(data)?;
        if let Some(x) = &self.ul_configuration {
            x.encode(data)?;
        }
        if let Some(x) = &self.duplication_activation {
            x.encode(data)?;
        }
        if num_ies != 0 {
            encode::encode_length_determinent(data, Some(1), Some(65535), false, num_ies)?;
            data.append_aligned(ies);
        }
        Ok(())
    }
}

impl PerCodec for DrbsToBeSetupModItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        DrbsToBeSetupModItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DrbsToBeSetupModItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DrbsToBeSetupModItem");
            e
        })
    }
}
// DrbList
#[derive(Clone, Debug)]
pub struct DrbList(pub NonEmpty<DrbListItem>);

impl DrbList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(64), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(DrbListItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(64), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for DrbList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        DrbList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DrbList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DrbList");
            e
        })
    }
}
// DrbListItem
#[derive(Clone, Debug)]
pub struct DrbListItem {
    pub drb_id: DrbId,
}

impl DrbListItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, false, 1)?;
        let drb_id = DrbId::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self { drb_id })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, false, &optionals, false)?;
        self.drb_id.encode(data)?;

        Ok(())
    }
}

impl PerCodec for DrbListItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        DrbListItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DrbListItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DrbListItem");
            e
        })
    }
}
// DrxCycle
#[derive(Clone, Debug)]
pub struct DrxCycle {
    pub long_drx_cycle_length: LongDrxCycleLength,
    pub short_drx_cycle_length: Option<ShortDrxCycleLength>,
    pub short_drx_cycle_timer: Option<ShortDrxCycleTimer>,
}

impl DrxCycle {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 3)?;
        let long_drx_cycle_length = LongDrxCycleLength::decode(data)?;
        let short_drx_cycle_length = if optionals[0] {
            Some(ShortDrxCycleLength::decode(data)?)
        } else {
            None
        };
        let short_drx_cycle_timer = if optionals[1] {
            Some(ShortDrxCycleTimer::decode(data)?)
        } else {
            None
        };

        // Process the extension container

        if optionals[2] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            long_drx_cycle_length,
            short_drx_cycle_length,
            short_drx_cycle_timer,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.short_drx_cycle_length.is_some());
        optionals.push(self.short_drx_cycle_timer.is_some());
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.long_drx_cycle_length.encode(data)?;
        if let Some(x) = &self.short_drx_cycle_length {
            x.encode(data)?;
        }
        if let Some(x) = &self.short_drx_cycle_timer {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl PerCodec for DrxCycle {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        DrxCycle::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DrxCycle");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DrxCycle");
            e
        })
    }
}
// NonIntegerDrxCycle
#[derive(Clone, Debug)]
pub struct NonIntegerDrxCycle {
    pub long_non_integer_drx_cycle_length: LongNonIntegerDrxCycleLength,
    pub short_non_integer_drx_cycle_length: Option<ShortNonIntegerDrxCycleLength>,
    pub short_drx_cycle_timer: Option<ShortDrxCycleTimer>,
}

impl NonIntegerDrxCycle {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 3)?;
        let long_non_integer_drx_cycle_length = LongNonIntegerDrxCycleLength::decode(data)?;
        let short_non_integer_drx_cycle_length = if optionals[0] {
            Some(ShortNonIntegerDrxCycleLength::decode(data)?)
        } else {
            None
        };
        let short_drx_cycle_timer = if optionals[1] {
            Some(ShortDrxCycleTimer::decode(data)?)
        } else {
            None
        };

        // Process the extension container

        if optionals[2] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            long_non_integer_drx_cycle_length,
            short_non_integer_drx_cycle_length,
            short_drx_cycle_timer,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.short_non_integer_drx_cycle_length.is_some());
        optionals.push(self.short_drx_cycle_timer.is_some());
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.long_non_integer_drx_cycle_length.encode(data)?;
        if let Some(x) = &self.short_non_integer_drx_cycle_length {
            x.encode(data)?;
        }
        if let Some(x) = &self.short_drx_cycle_timer {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl PerCodec for NonIntegerDrxCycle {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        NonIntegerDrxCycle::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NonIntegerDrxCycle");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NonIntegerDrxCycle");
            e
        })
    }
}
// DrxConfig
#[derive(Clone, Debug)]
pub struct DrxConfig(pub Vec<u8>);

impl DrxConfig {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(decode::decode_octetstring(data, None, None, false)?))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_octetstring(data, None, None, false, &self.0, false)
    }
}

impl PerCodec for DrxConfig {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        DrxConfig::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DrxConfig");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DrxConfig");
            e
        })
    }
}
// DrxConfigurationIndicator
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum DrxConfigurationIndicator {
    Release,
}

impl DrxConfigurationIndicator {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(0), true)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(0),
            true,
            *self as i128,
            (*self as u32) >= 1,
        )
    }
}

impl PerCodec for DrxConfigurationIndicator {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        DrxConfigurationIndicator::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DrxConfigurationIndicator");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DrxConfigurationIndicator");
            e
        })
    }
}
// DrxLongCycleStartOffset
#[derive(Clone, Copy, Debug)]
pub struct DrxLongCycleStartOffset(pub u16);

impl DrxLongCycleStartOffset {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(
            decode::decode_integer(data, Some(0), Some(10239), false)?.0 as u16,
        ))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_integer(data, Some(0), Some(10239), false, self.0 as i128, false)
    }
}

impl PerCodec for DrxLongCycleStartOffset {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        DrxLongCycleStartOffset::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DrxLongCycleStartOffset");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DrxLongCycleStartOffset");
            e
        })
    }
}
// DsInformationList
#[derive(Clone, Debug)]
pub struct DsInformationList(pub Vec<Dscp>);

impl DsInformationList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(0), Some(64), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(Dscp::decode(data)?);
            }
            items
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(0), Some(64), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for DsInformationList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        DsInformationList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DsInformationList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DsInformationList");
            e
        })
    }
}
// Dscp
#[derive(Clone, Debug)]
pub struct Dscp(pub BitString);

impl Dscp {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(decode::decode_bitstring(
            data,
            Some(6),
            Some(6),
            false,
        )?))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_bitstring(data, Some(6), Some(6), false, &self.0, false)
    }
}

impl PerCodec for Dscp {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Dscp::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("Dscp");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("Dscp");
            e
        })
    }
}
// DuToCuRrcContainer
#[derive(Clone, Debug)]
pub struct DuToCuRrcContainer(pub Vec<u8>);

impl DuToCuRrcContainer {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(decode::decode_octetstring(data, None, None, false)?))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_octetstring(data, None, None, false, &self.0, false)
    }
}

impl PerCodec for DuToCuRrcContainer {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        DuToCuRrcContainer::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DuToCuRrcContainer");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DuToCuRrcContainer");
            e
        })
    }
}
// DuCuRadioInformationType
#[derive(Clone, Debug)]
pub enum DuCuRadioInformationType {
    Rim(DuCuRimInformation),
}

impl DuCuRadioInformationType {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_choice_idx(data, 0, 1, false)?;
        if extended {
            return Err(per_codec_error_new("CHOICE additions not implemented"));
        }
        match idx {
            0 => Ok(Self::Rim(DuCuRimInformation::decode(data)?)),
            1 => {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _ = Criticality::decode(data)?;
                let _ = decode::decode_length_determinent(data, None, None, false)?;
                let result = match id {
                    x => Err(per_codec_error_new(format!("Unrecognised IE type {}", x))),
                };
                data.decode_align()?;
                result
            }
            _ => Err(per_codec_error_new("Unknown choice idx")),
        }
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        match self {
            Self::Rim(x) => {
                encode::encode_choice_idx(data, 0, 1, false, 0, false)?;
                x.encode(data)
            }
        }
    }
}

impl PerCodec for DuCuRadioInformationType {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        DuCuRadioInformationType::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DuCuRadioInformationType");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DuCuRadioInformationType");
            e
        })
    }
}
// DuCuRimInformation
#[derive(Clone, Debug)]
pub struct DuCuRimInformation {
    pub victim_gnb_set_id: GnbSetId,
    pub rimrs_detection_status: RimrsDetectionStatus,
    pub aggressor_cell_list: AggressorCellList,
}

impl DuCuRimInformation {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, false, 1)?;
        let victim_gnb_set_id = GnbSetId::decode(data)?;
        let rimrs_detection_status = RimrsDetectionStatus::decode(data)?;
        let aggressor_cell_list = AggressorCellList::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            victim_gnb_set_id,
            rimrs_detection_status,
            aggressor_cell_list,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, false, &optionals, false)?;
        self.victim_gnb_set_id.encode(data)?;
        self.rimrs_detection_status.encode(data)?;
        self.aggressor_cell_list.encode(data)?;

        Ok(())
    }
}

impl PerCodec for DuCuRimInformation {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        DuCuRimInformation::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DuCuRimInformation");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DuCuRimInformation");
            e
        })
    }
}
// DuFSlotConfigItem
#[derive(Clone, Debug)]
pub enum DuFSlotConfigItem {
    ExplicitFormat(ExplicitFormat),
    ImplicitFormat(ImplicitFormat),
}

impl DuFSlotConfigItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_choice_idx(data, 0, 2, false)?;
        if extended {
            return Err(per_codec_error_new("CHOICE additions not implemented"));
        }
        match idx {
            0 => Ok(Self::ExplicitFormat(ExplicitFormat::decode(data)?)),
            1 => Ok(Self::ImplicitFormat(ImplicitFormat::decode(data)?)),
            2 => {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _ = Criticality::decode(data)?;
                let _ = decode::decode_length_determinent(data, None, None, false)?;
                let result = match id {
                    x => Err(per_codec_error_new(format!("Unrecognised IE type {}", x))),
                };
                data.decode_align()?;
                result
            }
            _ => Err(per_codec_error_new("Unknown choice idx")),
        }
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        match self {
            Self::ExplicitFormat(x) => {
                encode::encode_choice_idx(data, 0, 2, false, 0, false)?;
                x.encode(data)
            }
            Self::ImplicitFormat(x) => {
                encode::encode_choice_idx(data, 0, 2, false, 1, false)?;
                x.encode(data)
            }
        }
    }
}

impl PerCodec for DuFSlotConfigItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        DuFSlotConfigItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DuFSlotConfigItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DuFSlotConfigItem");
            e
        })
    }
}
// DuFSlotConfigList
#[derive(Clone, Debug)]
pub struct DuFSlotConfigList(pub NonEmpty<DuFSlotConfigItem>);

impl DuFSlotConfigList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(320), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(DuFSlotConfigItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(320), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for DuFSlotConfigList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        DuFSlotConfigList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DuFSlotConfigList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DuFSlotConfigList");
            e
        })
    }
}
// DuFSlotformatIndex
#[derive(Clone, Copy, Debug)]
pub struct DuFSlotformatIndex(pub u8);

impl DuFSlotformatIndex {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(
            decode::decode_integer(data, Some(0), Some(254), false)?.0 as u8,
        ))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_integer(data, Some(0), Some(254), false, self.0 as i128, false)
    }
}

impl PerCodec for DuFSlotformatIndex {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        DuFSlotformatIndex::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DuFSlotformatIndex");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DuFSlotformatIndex");
            e
        })
    }
}
// DuFTransmissionPeriodicity
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum DuFTransmissionPeriodicity {
    Ms0p5,
    Ms0p625,
    Ms1,
    Ms1p25,
    Ms2,
    Ms2p5,
    Ms5,
    Ms10,
}

impl DuFTransmissionPeriodicity {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(7), true)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(7),
            true,
            *self as i128,
            (*self as u32) >= 8,
        )
    }
}

impl PerCodec for DuFTransmissionPeriodicity {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        DuFTransmissionPeriodicity::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DuFTransmissionPeriodicity");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DuFTransmissionPeriodicity");
            e
        })
    }
}
// DuRxMtRx
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum DuRxMtRx {
    Supported,
    NotSupported,
}

impl DuRxMtRx {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(1), false)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(1),
            false,
            *self as i128,
            (*self as u32) >= 2,
        )
    }
}

impl PerCodec for DuRxMtRx {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        DuRxMtRx::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DuRxMtRx");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DuRxMtRx");
            e
        })
    }
}
// DuTxMtTx
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum DuTxMtTx {
    Supported,
    NotSupported,
}

impl DuTxMtTx {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(1), false)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(1),
            false,
            *self as i128,
            (*self as u32) >= 2,
        )
    }
}

impl PerCodec for DuTxMtTx {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        DuTxMtTx::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DuTxMtTx");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DuTxMtTx");
            e
        })
    }
}
// DuRxMtTx
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum DuRxMtTx {
    Supported,
    NotSupported,
}

impl DuRxMtTx {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(1), false)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(1),
            false,
            *self as i128,
            (*self as u32) >= 2,
        )
    }
}

impl PerCodec for DuRxMtTx {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        DuRxMtTx::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DuRxMtTx");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DuRxMtTx");
            e
        })
    }
}
// DuTxMtRx
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum DuTxMtRx {
    Supported,
    NotSupported,
}

impl DuTxMtRx {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(1), false)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(1),
            false,
            *self as i128,
            (*self as u32) >= 2,
        )
    }
}

impl PerCodec for DuTxMtRx {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        DuTxMtRx::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DuTxMtRx");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DuTxMtRx");
            e
        })
    }
}
// DuRxMtRxExtend
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum DuRxMtRxExtend {
    Supported,
    NotSupported,
    SupportedAndFdmRequired,
}

impl DuRxMtRxExtend {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(2), true)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(2),
            true,
            *self as i128,
            (*self as u32) >= 3,
        )
    }
}

impl PerCodec for DuRxMtRxExtend {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        DuRxMtRxExtend::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DuRxMtRxExtend");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DuRxMtRxExtend");
            e
        })
    }
}
// DuTxMtTxExtend
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum DuTxMtTxExtend {
    Supported,
    NotSupported,
    SupportedAndFdmRequired,
}

impl DuTxMtTxExtend {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(2), true)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(2),
            true,
            *self as i128,
            (*self as u32) >= 3,
        )
    }
}

impl PerCodec for DuTxMtTxExtend {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        DuTxMtTxExtend::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DuTxMtTxExtend");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DuTxMtTxExtend");
            e
        })
    }
}
// DuRxMtTxExtend
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum DuRxMtTxExtend {
    Supported,
    NotSupported,
    SupportedAndFdmRequired,
}

impl DuRxMtTxExtend {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(2), true)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(2),
            true,
            *self as i128,
            (*self as u32) >= 3,
        )
    }
}

impl PerCodec for DuRxMtTxExtend {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        DuRxMtTxExtend::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DuRxMtTxExtend");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DuRxMtTxExtend");
            e
        })
    }
}
// DuTxMtRxExtend
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum DuTxMtRxExtend {
    Supported,
    NotSupported,
    SupportedAndFdmRequired,
}

impl DuTxMtRxExtend {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(2), true)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(2),
            true,
            *self as i128,
            (*self as u32) >= 3,
        )
    }
}

impl PerCodec for DuTxMtRxExtend {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        DuTxMtRxExtend::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DuTxMtRxExtend");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DuTxMtRxExtend");
            e
        })
    }
}
// DuToCuRrcInformation
#[derive(Clone, Debug)]
pub struct DuToCuRrcInformation {
    pub cell_group_config: CellGroupConfig,
    pub meas_gap_config: Option<MeasGapConfig>,
    pub requested_p_max_fr1: Option<Vec<u8>>,
    pub drx_long_cycle_start_offset: Option<DrxLongCycleStartOffset>,
    pub selected_band_combination_index: Option<SelectedBandCombinationIndex>,
    pub selected_feature_set_entry_index: Option<SelectedFeatureSetEntryIndex>,
    pub ph_info_scg: Option<PhInfoScg>,
    pub requested_band_combination_index: Option<RequestedBandCombinationIndex>,
    pub requested_feature_set_entry_index: Option<RequestedFeatureSetEntryIndex>,
    pub drx_config: Option<DrxConfig>,
    pub pdcch_blind_detection_scg: Option<PdcchBlindDetectionScg>,
    pub requested_pdcch_blind_detection_scg: Option<RequestedPdcchBlindDetectionScg>,
    pub ph_info_mcg: Option<PhInfoMcg>,
    pub meas_gap_sharing_config: Option<MeasGapSharingConfig>,
    pub sl_phy_mac_rlc_config: Option<SlPhyMacRlcConfig>,
    pub sl_config_dedicated_eutra_info: Option<SlConfigDedicatedEutraInfo>,
    pub requested_p_max_fr2: Option<RequestedPMaxFr2>,
    pub sdt_mac_phy_cg_config: Option<SdtMacPhyCgConfig>,
    pub musim_gap_config: Option<MusimGapConfig>,
    pub sl_rlc_channel_to_add_mod_list: Option<SlRlcChannelToAddModList>,
    pub inter_frequency_config_no_gap: Option<InterFrequencyConfigNoGap>,
    pub ul_gap_fr2_config: Option<UlGapFr2Config>,
    pub two_phr_mode_mcg: Option<TwoPhrModeMcg>,
    pub two_phr_mode_scg: Option<TwoPhrModeScg>,
    pub ncd_ssb_red_cap_initial_bwp_sdt: Option<NcdSsbRedCapInitialBwpSdt>,
    pub serv_cell_info_list: Option<ServCellInfoList>,
    pub sl_phy_mac_rlc_config_ext: Option<SlPhyMacRlcConfigExt>,
}

impl DuToCuRrcInformation {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 3)?;
        let cell_group_config = CellGroupConfig::decode(data)?;
        let meas_gap_config = if optionals[0] {
            Some(MeasGapConfig::decode(data)?)
        } else {
            None
        };
        let requested_p_max_fr1 = if optionals[1] {
            Some(decode::decode_octetstring(data, None, None, false)?)
        } else {
            None
        };

        // Process the extension container
        let mut drx_long_cycle_start_offset: Option<DrxLongCycleStartOffset> = None;
        let mut selected_band_combination_index: Option<SelectedBandCombinationIndex> = None;
        let mut selected_feature_set_entry_index: Option<SelectedFeatureSetEntryIndex> = None;
        let mut ph_info_scg: Option<PhInfoScg> = None;
        let mut requested_band_combination_index: Option<RequestedBandCombinationIndex> = None;
        let mut requested_feature_set_entry_index: Option<RequestedFeatureSetEntryIndex> = None;
        let mut drx_config: Option<DrxConfig> = None;
        let mut pdcch_blind_detection_scg: Option<PdcchBlindDetectionScg> = None;
        let mut requested_pdcch_blind_detection_scg: Option<RequestedPdcchBlindDetectionScg> = None;
        let mut ph_info_mcg: Option<PhInfoMcg> = None;
        let mut meas_gap_sharing_config: Option<MeasGapSharingConfig> = None;
        let mut sl_phy_mac_rlc_config: Option<SlPhyMacRlcConfig> = None;
        let mut sl_config_dedicated_eutra_info: Option<SlConfigDedicatedEutraInfo> = None;
        let mut requested_p_max_fr2: Option<RequestedPMaxFr2> = None;
        let mut sdt_mac_phy_cg_config: Option<SdtMacPhyCgConfig> = None;
        let mut musim_gap_config: Option<MusimGapConfig> = None;
        let mut sl_rlc_channel_to_add_mod_list: Option<SlRlcChannelToAddModList> = None;
        let mut inter_frequency_config_no_gap: Option<InterFrequencyConfigNoGap> = None;
        let mut ul_gap_fr2_config: Option<UlGapFr2Config> = None;
        let mut two_phr_mode_mcg: Option<TwoPhrModeMcg> = None;
        let mut two_phr_mode_scg: Option<TwoPhrModeScg> = None;
        let mut ncd_ssb_red_cap_initial_bwp_sdt: Option<NcdSsbRedCapInitialBwpSdt> = None;
        let mut serv_cell_info_list: Option<ServCellInfoList> = None;
        let mut sl_phy_mac_rlc_config_ext: Option<SlPhyMacRlcConfigExt> = None;

        if optionals[2] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    191 => {
                        drx_long_cycle_start_offset = Some(DrxLongCycleStartOffset::decode(data)?)
                    }
                    193 => {
                        selected_band_combination_index =
                            Some(SelectedBandCombinationIndex::decode(data)?)
                    }
                    194 => {
                        selected_feature_set_entry_index =
                            Some(SelectedFeatureSetEntryIndex::decode(data)?)
                    }
                    208 => ph_info_scg = Some(PhInfoScg::decode(data)?),
                    209 => {
                        requested_band_combination_index =
                            Some(RequestedBandCombinationIndex::decode(data)?)
                    }
                    210 => {
                        requested_feature_set_entry_index =
                            Some(RequestedFeatureSetEntryIndex::decode(data)?)
                    }
                    212 => drx_config = Some(DrxConfig::decode(data)?),
                    235 => pdcch_blind_detection_scg = Some(PdcchBlindDetectionScg::decode(data)?),
                    236 => {
                        requested_pdcch_blind_detection_scg =
                            Some(RequestedPdcchBlindDetectionScg::decode(data)?)
                    }
                    237 => ph_info_mcg = Some(PhInfoMcg::decode(data)?),
                    238 => meas_gap_sharing_config = Some(MeasGapSharingConfig::decode(data)?),
                    341 => sl_phy_mac_rlc_config = Some(SlPhyMacRlcConfig::decode(data)?),
                    342 => {
                        sl_config_dedicated_eutra_info =
                            Some(SlConfigDedicatedEutraInfo::decode(data)?)
                    }
                    211 => requested_p_max_fr2 = Some(RequestedPMaxFr2::decode(data)?),
                    587 => sdt_mac_phy_cg_config = Some(SdtMacPhyCgConfig::decode(data)?),
                    621 => musim_gap_config = Some(MusimGapConfig::decode(data)?),
                    645 => {
                        sl_rlc_channel_to_add_mod_list =
                            Some(SlRlcChannelToAddModList::decode(data)?)
                    }
                    651 => {
                        inter_frequency_config_no_gap =
                            Some(InterFrequencyConfigNoGap::decode(data)?)
                    }
                    677 => ul_gap_fr2_config = Some(UlGapFr2Config::decode(data)?),
                    692 => two_phr_mode_mcg = Some(TwoPhrModeMcg::decode(data)?),
                    693 => two_phr_mode_scg = Some(TwoPhrModeScg::decode(data)?),
                    701 => {
                        ncd_ssb_red_cap_initial_bwp_sdt =
                            Some(NcdSsbRedCapInitialBwpSdt::decode(data)?)
                    }
                    707 => serv_cell_info_list = Some(ServCellInfoList::decode(data)?),
                    800 => sl_phy_mac_rlc_config_ext = Some(SlPhyMacRlcConfigExt::decode(data)?),
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            cell_group_config,
            meas_gap_config,
            requested_p_max_fr1,
            drx_long_cycle_start_offset,
            selected_band_combination_index,
            selected_feature_set_entry_index,
            ph_info_scg,
            requested_band_combination_index,
            requested_feature_set_entry_index,
            drx_config,
            pdcch_blind_detection_scg,
            requested_pdcch_blind_detection_scg,
            ph_info_mcg,
            meas_gap_sharing_config,
            sl_phy_mac_rlc_config,
            sl_config_dedicated_eutra_info,
            requested_p_max_fr2,
            sdt_mac_phy_cg_config,
            musim_gap_config,
            sl_rlc_channel_to_add_mod_list,
            inter_frequency_config_no_gap,
            ul_gap_fr2_config,
            two_phr_mode_mcg,
            two_phr_mode_scg,
            ncd_ssb_red_cap_initial_bwp_sdt,
            serv_cell_info_list,
            sl_phy_mac_rlc_config_ext,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();
        if let Some(x) = &self.drx_long_cycle_start_offset {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 191, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.selected_band_combination_index {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 193, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.selected_feature_set_entry_index {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 194, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.ph_info_scg {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 208, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.requested_band_combination_index {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 209, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.requested_feature_set_entry_index {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 210, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.drx_config {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 212, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.pdcch_blind_detection_scg {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 235, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.requested_pdcch_blind_detection_scg {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 236, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.ph_info_mcg {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 237, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.meas_gap_sharing_config {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 238, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.sl_phy_mac_rlc_config {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 341, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.sl_config_dedicated_eutra_info {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 342, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.requested_p_max_fr2 {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 211, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.sdt_mac_phy_cg_config {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 587, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.musim_gap_config {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 621, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.sl_rlc_channel_to_add_mod_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 645, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.inter_frequency_config_no_gap {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 651, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.ul_gap_fr2_config {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 677, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.two_phr_mode_mcg {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 692, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.two_phr_mode_scg {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 693, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.ncd_ssb_red_cap_initial_bwp_sdt {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 701, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.serv_cell_info_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 707, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.sl_phy_mac_rlc_config_ext {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 800, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        let mut optionals = BitString::new();
        optionals.push(self.meas_gap_config.is_some());
        optionals.push(self.requested_p_max_fr1.is_some());
        optionals.push(num_ies != 0);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.cell_group_config.encode(data)?;
        if let Some(x) = &self.meas_gap_config {
            x.encode(data)?;
        }
        if let Some(x) = &self.requested_p_max_fr1 {
            encode::encode_octetstring(data, None, None, false, &x, false)?;
        }
        if num_ies != 0 {
            encode::encode_length_determinent(data, Some(1), Some(65535), false, num_ies)?;
            data.append_aligned(ies);
        }
        Ok(())
    }
}

impl PerCodec for DuToCuRrcInformation {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        DuToCuRrcInformation::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DuToCuRrcInformation");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DuToCuRrcInformation");
            e
        })
    }
}
// DuToCuTaInformationList
#[derive(Clone, Debug)]
pub struct DuToCuTaInformationList(pub NonEmpty<DuToCuTaInformationItem>);

impl DuToCuTaInformationList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(8), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(DuToCuTaInformationItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(8), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for DuToCuTaInformationList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        DuToCuTaInformationList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DuToCuTaInformationList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DuToCuTaInformationList");
            e
        })
    }
}
// DuToCuTaInformationItem
#[derive(Clone, Debug)]
pub struct DuToCuTaInformationItem {
    pub nr_cgi: NrCgi,
    pub ta_value: TaValue,
    pub preamble_index: PreambleIndex,
    pub ra_rnti: RaRnti,
    pub source_gnb_du_id: GnbDuId,
    pub tag_id_pointer: Option<TagIdPointer>,
}

impl DuToCuTaInformationItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 2)?;
        let nr_cgi = NrCgi::decode(data)?;
        let ta_value = TaValue::decode(data)?;
        let preamble_index = PreambleIndex::decode(data)?;
        let ra_rnti = RaRnti::decode(data)?;
        let source_gnb_du_id = GnbDuId::decode(data)?;
        let tag_id_pointer = if optionals[0] {
            Some(TagIdPointer::decode(data)?)
        } else {
            None
        };

        // Process the extension container

        if optionals[1] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            nr_cgi,
            ta_value,
            preamble_index,
            ra_rnti,
            source_gnb_du_id,
            tag_id_pointer,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.tag_id_pointer.is_some());
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.nr_cgi.encode(data)?;
        self.ta_value.encode(data)?;
        self.preamble_index.encode(data)?;
        self.ra_rnti.encode(data)?;
        self.source_gnb_du_id.encode(data)?;
        if let Some(x) = &self.tag_id_pointer {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl PerCodec for DuToCuTaInformationItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        DuToCuTaInformationItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DuToCuTaInformationItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DuToCuTaInformationItem");
            e
        })
    }
}
// DuplicationActivation
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum DuplicationActivation {
    Active,
    Inactive,
}

impl DuplicationActivation {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(1), true)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(1),
            true,
            *self as i128,
            (*self as u32) >= 2,
        )
    }
}

impl PerCodec for DuplicationActivation {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        DuplicationActivation::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DuplicationActivation");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DuplicationActivation");
            e
        })
    }
}
// DuplicationIndication
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum DuplicationIndication {
    True,
    False,
}

impl DuplicationIndication {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(0), true)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(0),
            true,
            *self as i128,
            (*self as u32) >= 1,
        )
    }
}

impl PerCodec for DuplicationIndication {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        DuplicationIndication::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DuplicationIndication");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DuplicationIndication");
            e
        })
    }
}
// DuplicationState
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum DuplicationState {
    Active,
    Inactive,
}

impl DuplicationState {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(1), true)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(1),
            true,
            *self as i128,
            (*self as u32) >= 2,
        )
    }
}

impl PerCodec for DuplicationState {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        DuplicationState::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DuplicationState");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DuplicationState");
            e
        })
    }
}
// Dynamic5qiDescriptor
#[derive(Clone, Debug)]
pub struct Dynamic5qiDescriptor {
    pub qos_priority_level: u8,
    pub packet_delay_budget: PacketDelayBudget,
    pub packet_error_rate: PacketErrorRate,
    pub five_qi: Option<u8>,
    pub delay_critical: Option<DelayCritical>,
    pub averaging_window: Option<AveragingWindow>,
    pub max_data_burst_volume: Option<MaxDataBurstVolume>,
    pub extended_packet_delay_budget: Option<ExtendedPacketDelayBudget>,
    pub cn_packet_delay_budget_downlink: Option<ExtendedPacketDelayBudget>,
    pub cn_packet_delay_budget_uplink: Option<ExtendedPacketDelayBudget>,
}

impl Dynamic5qiDescriptor {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, false, 5)?;
        let qos_priority_level = decode::decode_integer(data, Some(1), Some(127), false)?.0 as u8;
        let packet_delay_budget = PacketDelayBudget::decode(data)?;
        let packet_error_rate = PacketErrorRate::decode(data)?;
        let five_qi = if optionals[0] {
            Some(decode::decode_integer(data, Some(0), Some(255), true)?.0 as u8)
        } else {
            None
        };
        let delay_critical = if optionals[1] {
            Some(DelayCritical::decode(data)?)
        } else {
            None
        };
        let averaging_window = if optionals[2] {
            Some(AveragingWindow::decode(data)?)
        } else {
            None
        };
        let max_data_burst_volume = if optionals[3] {
            Some(MaxDataBurstVolume::decode(data)?)
        } else {
            None
        };

        // Process the extension container
        let mut extended_packet_delay_budget: Option<ExtendedPacketDelayBudget> = None;
        let mut cn_packet_delay_budget_downlink: Option<ExtendedPacketDelayBudget> = None;
        let mut cn_packet_delay_budget_uplink: Option<ExtendedPacketDelayBudget> = None;

        if optionals[4] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    363 => {
                        extended_packet_delay_budget =
                            Some(ExtendedPacketDelayBudget::decode(data)?)
                    }
                    362 => {
                        cn_packet_delay_budget_downlink =
                            Some(ExtendedPacketDelayBudget::decode(data)?)
                    }
                    369 => {
                        cn_packet_delay_budget_uplink =
                            Some(ExtendedPacketDelayBudget::decode(data)?)
                    }
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            qos_priority_level,
            packet_delay_budget,
            packet_error_rate,
            five_qi,
            delay_critical,
            averaging_window,
            max_data_burst_volume,
            extended_packet_delay_budget,
            cn_packet_delay_budget_downlink,
            cn_packet_delay_budget_uplink,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();
        if let Some(x) = &self.extended_packet_delay_budget {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 363, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.cn_packet_delay_budget_downlink {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 362, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.cn_packet_delay_budget_uplink {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 369, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        let mut optionals = BitString::new();
        optionals.push(self.five_qi.is_some());
        optionals.push(self.delay_critical.is_some());
        optionals.push(self.averaging_window.is_some());
        optionals.push(self.max_data_burst_volume.is_some());
        optionals.push(num_ies != 0);

        encode::encode_sequence_header(data, false, &optionals, false)?;
        encode::encode_integer(
            data,
            Some(1),
            Some(127),
            false,
            self.qos_priority_level as i128,
            false,
        )?;
        self.packet_delay_budget.encode(data)?;
        self.packet_error_rate.encode(data)?;
        if let Some(x) = &self.five_qi {
            encode::encode_integer(data, Some(0), Some(255), true, *x as i128, false)?;
        }
        if let Some(x) = &self.delay_critical {
            x.encode(data)?;
        }
        if let Some(x) = &self.averaging_window {
            x.encode(data)?;
        }
        if let Some(x) = &self.max_data_burst_volume {
            x.encode(data)?;
        }
        if num_ies != 0 {
            encode::encode_length_determinent(data, Some(1), Some(65535), false, num_ies)?;
            data.append_aligned(ies);
        }
        Ok(())
    }
}

impl PerCodec for Dynamic5qiDescriptor {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Dynamic5qiDescriptor::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("Dynamic5qiDescriptor");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("Dynamic5qiDescriptor");
            e
        })
    }
}
// DynamicPqiDescriptor
#[derive(Clone, Debug)]
pub struct DynamicPqiDescriptor {
    pub resource_type: Option<ResourceType1>,
    pub qos_priority_level: u8,
    pub packet_delay_budget: PacketDelayBudget,
    pub packet_error_rate: PacketErrorRate,
    pub averaging_window: Option<AveragingWindow>,
    pub max_data_burst_volume: Option<MaxDataBurstVolume>,
}

impl DynamicPqiDescriptor {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, false, 4)?;
        let resource_type = if optionals[0] {
            Some(ResourceType1::decode(data)?)
        } else {
            None
        };
        let qos_priority_level = decode::decode_integer(data, Some(1), Some(8), true)?.0 as u8;
        let packet_delay_budget = PacketDelayBudget::decode(data)?;
        let packet_error_rate = PacketErrorRate::decode(data)?;
        let averaging_window = if optionals[1] {
            Some(AveragingWindow::decode(data)?)
        } else {
            None
        };
        let max_data_burst_volume = if optionals[2] {
            Some(MaxDataBurstVolume::decode(data)?)
        } else {
            None
        };

        // Process the extension container

        if optionals[3] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            resource_type,
            qos_priority_level,
            packet_delay_budget,
            packet_error_rate,
            averaging_window,
            max_data_burst_volume,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.resource_type.is_some());
        optionals.push(self.averaging_window.is_some());
        optionals.push(self.max_data_burst_volume.is_some());
        optionals.push(false);

        encode::encode_sequence_header(data, false, &optionals, false)?;
        if let Some(x) = &self.resource_type {
            x.encode(data)?;
        }
        encode::encode_integer(
            data,
            Some(1),
            Some(8),
            true,
            self.qos_priority_level as i128,
            false,
        )?;
        self.packet_delay_budget.encode(data)?;
        self.packet_error_rate.encode(data)?;
        if let Some(x) = &self.averaging_window {
            x.encode(data)?;
        }
        if let Some(x) = &self.max_data_burst_volume {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl PerCodec for DynamicPqiDescriptor {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        DynamicPqiDescriptor::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DynamicPqiDescriptor");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DynamicPqiDescriptor");
            e
        })
    }
}
// DllbtFailureInformationRequest
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum DllbtFailureInformationRequest {
    Inquiry,
}

impl DllbtFailureInformationRequest {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(0), true)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(0),
            true,
            *self as i128,
            (*self as u32) >= 1,
        )
    }
}

impl PerCodec for DllbtFailureInformationRequest {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        DllbtFailureInformationRequest::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DllbtFailureInformationRequest");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DllbtFailureInformationRequest");
            e
        })
    }
}
// DllbtFailureInformationList
#[derive(Clone, Debug)]
pub struct DllbtFailureInformationList(pub NonEmpty<DllbtFailureInformationListItem>);

impl DllbtFailureInformationList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(64), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(DllbtFailureInformationListItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(64), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for DllbtFailureInformationList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        DllbtFailureInformationList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DllbtFailureInformationList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DllbtFailureInformationList");
            e
        })
    }
}
// DllbtFailureInformationListItem
#[derive(Clone, Debug)]
pub struct DllbtFailureInformationListItem {
    pub ue_assistant_identifier: GnbCuUeF1apId,
    pub number_of_dl_lbt_failures: Option<u16>,
}

impl DllbtFailureInformationListItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 2)?;
        let ue_assistant_identifier = GnbCuUeF1apId::decode(data)?;
        let number_of_dl_lbt_failures = if optionals[0] {
            Some(decode::decode_integer(data, Some(1), Some(1000), true)?.0 as u16)
        } else {
            None
        };

        // Process the extension container

        if optionals[1] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            ue_assistant_identifier,
            number_of_dl_lbt_failures,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.number_of_dl_lbt_failures.is_some());
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.ue_assistant_identifier.encode(data)?;
        if let Some(x) = &self.number_of_dl_lbt_failures {
            encode::encode_integer(data, Some(1), Some(1000), true, *x as i128, false)?;
        }

        Ok(())
    }
}

impl PerCodec for DllbtFailureInformationListItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        DllbtFailureInformationListItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DllbtFailureInformationListItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DllbtFailureInformationListItem");
            e
        })
    }
}
// EarlyUlSyncConfig
#[derive(Clone, Debug)]
pub struct EarlyUlSyncConfig {
    pub rach: RachConfiguration,
    pub ltm_gnb_du_i_ds_preamble_index_list: Option<LtmGnbDuIDsPreambleIndexList>,
}

impl EarlyUlSyncConfig {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 2)?;
        let rach = RachConfiguration::decode(data)?;
        let ltm_gnb_du_i_ds_preamble_index_list = if optionals[0] {
            Some(LtmGnbDuIDsPreambleIndexList::decode(data)?)
        } else {
            None
        };

        // Process the extension container

        if optionals[1] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            rach,
            ltm_gnb_du_i_ds_preamble_index_list,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.ltm_gnb_du_i_ds_preamble_index_list.is_some());
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.rach.encode(data)?;
        if let Some(x) = &self.ltm_gnb_du_i_ds_preamble_index_list {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl PerCodec for EarlyUlSyncConfig {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        EarlyUlSyncConfig::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("EarlyUlSyncConfig");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("EarlyUlSyncConfig");
            e
        })
    }
}
// EarlySyncInformationRequest
#[derive(Clone, Debug)]
pub struct EarlySyncInformationRequest {
    pub requestfor_rach_configuration: RequestforRachConfiguration,
    pub ltm_gnb_du_i_ds_list: LtmGnbDuIDsList,
}

impl EarlySyncInformationRequest {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let requestfor_rach_configuration = RequestforRachConfiguration::decode(data)?;
        let ltm_gnb_du_i_ds_list = LtmGnbDuIDsList::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            requestfor_rach_configuration,
            ltm_gnb_du_i_ds_list,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.requestfor_rach_configuration.encode(data)?;
        self.ltm_gnb_du_i_ds_list.encode(data)?;

        Ok(())
    }
}

impl PerCodec for EarlySyncInformationRequest {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        EarlySyncInformationRequest::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("EarlySyncInformationRequest");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("EarlySyncInformationRequest");
            e
        })
    }
}
// EarlySyncInformation
#[derive(Clone, Debug)]
pub struct EarlySyncInformation {
    pub tci_states_configurations_list: TciStatesConfigurationsList,
    pub early_ul_sync_config: Option<EarlyUlSyncConfig>,
    pub early_ul_sync_config_sul: Option<EarlyUlSyncConfig>,
}

impl EarlySyncInformation {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 3)?;
        let tci_states_configurations_list = TciStatesConfigurationsList::decode(data)?;
        let early_ul_sync_config = if optionals[0] {
            Some(EarlyUlSyncConfig::decode(data)?)
        } else {
            None
        };
        let early_ul_sync_config_sul = if optionals[1] {
            Some(EarlyUlSyncConfig::decode(data)?)
        } else {
            None
        };

        // Process the extension container

        if optionals[2] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            tci_states_configurations_list,
            early_ul_sync_config,
            early_ul_sync_config_sul,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.early_ul_sync_config.is_some());
        optionals.push(self.early_ul_sync_config_sul.is_some());
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.tci_states_configurations_list.encode(data)?;
        if let Some(x) = &self.early_ul_sync_config {
            x.encode(data)?;
        }
        if let Some(x) = &self.early_ul_sync_config_sul {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl PerCodec for EarlySyncInformation {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        EarlySyncInformation::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("EarlySyncInformation");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("EarlySyncInformation");
            e
        })
    }
}
// EarlySyncCandidateCellInformationList
#[derive(Clone, Debug)]
pub struct EarlySyncCandidateCellInformationList(
    pub NonEmpty<EarlySyncCandidateCellInformationItem>,
);

impl EarlySyncCandidateCellInformationList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(8), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(EarlySyncCandidateCellInformationItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(8), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for EarlySyncCandidateCellInformationList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        EarlySyncCandidateCellInformationList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("EarlySyncCandidateCellInformationList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("EarlySyncCandidateCellInformationList");
            e
        })
    }
}
// EarlySyncCandidateCellInformationItem
#[derive(Clone, Debug)]
pub struct EarlySyncCandidateCellInformationItem {
    pub nr_cgi: NrCgi,
    pub tci_states_configurations_list: Option<TciStatesConfigurationsList>,
    pub early_ul_sync_config: Option<EarlyUlSyncConfig>,
    pub early_ul_sync_config_sul: Option<EarlyUlSyncConfig>,
    pub ta_assistance_info: Option<TaAssistanceInfo>,
    pub ue_based_t_ameasurement_config: Option<Vec<u8>>,
    pub ssb_positions_in_burst: Option<SsbPositionsInBurst>,
}

impl EarlySyncCandidateCellInformationItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 6)?;
        let nr_cgi = NrCgi::decode(data)?;
        let tci_states_configurations_list = if optionals[0] {
            Some(TciStatesConfigurationsList::decode(data)?)
        } else {
            None
        };
        let early_ul_sync_config = if optionals[1] {
            Some(EarlyUlSyncConfig::decode(data)?)
        } else {
            None
        };
        let early_ul_sync_config_sul = if optionals[2] {
            Some(EarlyUlSyncConfig::decode(data)?)
        } else {
            None
        };
        let ta_assistance_info = if optionals[3] {
            Some(TaAssistanceInfo::decode(data)?)
        } else {
            None
        };
        let ue_based_t_ameasurement_config = if optionals[4] {
            Some(decode::decode_octetstring(data, None, None, false)?)
        } else {
            None
        };

        // Process the extension container
        let mut ssb_positions_in_burst: Option<SsbPositionsInBurst> = None;

        if optionals[5] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    357 => ssb_positions_in_burst = Some(SsbPositionsInBurst::decode(data)?),
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            nr_cgi,
            tci_states_configurations_list,
            early_ul_sync_config,
            early_ul_sync_config_sul,
            ta_assistance_info,
            ue_based_t_ameasurement_config,
            ssb_positions_in_burst,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();
        if let Some(x) = &self.ssb_positions_in_burst {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 357, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        let mut optionals = BitString::new();
        optionals.push(self.tci_states_configurations_list.is_some());
        optionals.push(self.early_ul_sync_config.is_some());
        optionals.push(self.early_ul_sync_config_sul.is_some());
        optionals.push(self.ta_assistance_info.is_some());
        optionals.push(self.ue_based_t_ameasurement_config.is_some());
        optionals.push(num_ies != 0);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.nr_cgi.encode(data)?;
        if let Some(x) = &self.tci_states_configurations_list {
            x.encode(data)?;
        }
        if let Some(x) = &self.early_ul_sync_config {
            x.encode(data)?;
        }
        if let Some(x) = &self.early_ul_sync_config_sul {
            x.encode(data)?;
        }
        if let Some(x) = &self.ta_assistance_info {
            x.encode(data)?;
        }
        if let Some(x) = &self.ue_based_t_ameasurement_config {
            encode::encode_octetstring(data, None, None, false, &x, false)?;
        }
        if num_ies != 0 {
            encode::encode_length_determinent(data, Some(1), Some(65535), false, num_ies)?;
            data.append_aligned(ies);
        }
        Ok(())
    }
}

impl PerCodec for EarlySyncCandidateCellInformationItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        EarlySyncCandidateCellInformationItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("EarlySyncCandidateCellInformationItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("EarlySyncCandidateCellInformationItem");
            e
        })
    }
}
// EarlySyncServingCellInformation
#[derive(Clone, Debug)]
pub struct EarlySyncServingCellInformation {
    pub ue_based_t_ameasurement_config: Option<Vec<u8>>,
}

impl EarlySyncServingCellInformation {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 2)?;
        let ue_based_t_ameasurement_config = if optionals[0] {
            Some(decode::decode_octetstring(data, None, None, false)?)
        } else {
            None
        };

        // Process the extension container

        if optionals[1] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            ue_based_t_ameasurement_config,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.ue_based_t_ameasurement_config.is_some());
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        if let Some(x) = &self.ue_based_t_ameasurement_config {
            encode::encode_octetstring(data, None, None, false, &x, false)?;
        }

        Ok(())
    }
}

impl PerCodec for EarlySyncServingCellInformation {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        EarlySyncServingCellInformation::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("EarlySyncServingCellInformation");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("EarlySyncServingCellInformation");
            e
        })
    }
}
// ECidMeasurementQuantities
#[derive(Clone, Debug)]
pub struct ECidMeasurementQuantities(pub NonEmpty<ECidMeasurementQuantitiesItem>);

impl ECidMeasurementQuantities {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(64), false)?;
            let mut items = vec![];
            for _ in 0..length {
                let _ = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _ = Criticality::decode(data)?;
                let _ = decode::decode_length_determinent(data, None, None, false)?;
                items.push(ECidMeasurementQuantitiesItem::decode(data)?);
                data.decode_align()?;
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(64), false, self.0.len())?;
        for x in &self.0 {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(data, Some(0), Some(65535), false, 415, false)?;
            Criticality::Reject.encode(data)?;
            encode::encode_length_determinent(data, None, None, false, ie.length_in_bytes())?;
            data.append_aligned(ie);
        }
        Ok(())
    }
}

impl PerCodec for ECidMeasurementQuantities {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        ECidMeasurementQuantities::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ECidMeasurementQuantities");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ECidMeasurementQuantities");
            e
        })
    }
}
// ECidMeasurementQuantitiesItem
#[derive(Clone, Debug)]
pub struct ECidMeasurementQuantitiesItem {
    pub e_ci_dmeasurement_quantities_value: ECidMeasurementQuantitiesValue,
}

impl ECidMeasurementQuantitiesItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, false, 1)?;
        let e_ci_dmeasurement_quantities_value = ECidMeasurementQuantitiesValue::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            e_ci_dmeasurement_quantities_value,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, false, &optionals, false)?;
        self.e_ci_dmeasurement_quantities_value.encode(data)?;

        Ok(())
    }
}

impl PerCodec for ECidMeasurementQuantitiesItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        ECidMeasurementQuantitiesItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ECidMeasurementQuantitiesItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ECidMeasurementQuantitiesItem");
            e
        })
    }
}
// ECidMeasurementQuantitiesValue
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum ECidMeasurementQuantitiesValue {
    Default,
    AngleOfArrivalNr,
    TimingAdvanceNr,
}

impl ECidMeasurementQuantitiesValue {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(1), true)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(1),
            true,
            *self as i128,
            (*self as u32) >= 2,
        )
    }
}

impl PerCodec for ECidMeasurementQuantitiesValue {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        ECidMeasurementQuantitiesValue::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ECidMeasurementQuantitiesValue");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ECidMeasurementQuantitiesValue");
            e
        })
    }
}
// ECidMeasurementResult
#[derive(Clone, Debug)]
pub struct ECidMeasurementResult {
    pub geographical_coordinates: Option<GeographicalCoordinates>,
    pub measured_results_list: Option<ECidMeasuredResultsList>,
    pub mobile_access_point_location: Option<MobileTrpLocationInformation>,
    pub e_cid_measured_results_associated_info_list: Option<ECidMeasuredResultsAssociatedInfoList>,
}

impl ECidMeasurementResult {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, false, 3)?;
        let geographical_coordinates = if optionals[0] {
            Some(GeographicalCoordinates::decode(data)?)
        } else {
            None
        };
        let measured_results_list = if optionals[1] {
            Some(ECidMeasuredResultsList::decode(data)?)
        } else {
            None
        };

        // Process the extension container
        let mut mobile_access_point_location: Option<MobileTrpLocationInformation> = None;
        let mut e_cid_measured_results_associated_info_list: Option<
            ECidMeasuredResultsAssociatedInfoList,
        > = None;

        if optionals[2] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    766 => {
                        mobile_access_point_location =
                            Some(MobileTrpLocationInformation::decode(data)?)
                    }
                    834 => {
                        e_cid_measured_results_associated_info_list =
                            Some(ECidMeasuredResultsAssociatedInfoList::decode(data)?)
                    }
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            geographical_coordinates,
            measured_results_list,
            mobile_access_point_location,
            e_cid_measured_results_associated_info_list,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();
        if let Some(x) = &self.mobile_access_point_location {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 766, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.e_cid_measured_results_associated_info_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 834, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        let mut optionals = BitString::new();
        optionals.push(self.geographical_coordinates.is_some());
        optionals.push(self.measured_results_list.is_some());
        optionals.push(num_ies != 0);

        encode::encode_sequence_header(data, false, &optionals, false)?;
        if let Some(x) = &self.geographical_coordinates {
            x.encode(data)?;
        }
        if let Some(x) = &self.measured_results_list {
            x.encode(data)?;
        }
        if num_ies != 0 {
            encode::encode_length_determinent(data, Some(1), Some(65535), false, num_ies)?;
            data.append_aligned(ies);
        }
        Ok(())
    }
}

impl PerCodec for ECidMeasurementResult {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        ECidMeasurementResult::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ECidMeasurementResult");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ECidMeasurementResult");
            e
        })
    }
}
// ECidMeasuredResultsList
#[derive(Clone, Debug)]
pub struct ECidMeasuredResultsList(pub NonEmpty<ECidMeasuredResultsItem>);

impl ECidMeasuredResultsList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(64), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(ECidMeasuredResultsItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(64), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for ECidMeasuredResultsList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        ECidMeasuredResultsList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ECidMeasuredResultsList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ECidMeasuredResultsList");
            e
        })
    }
}
// ECidMeasuredResultsItem
#[derive(Clone, Debug)]
pub struct ECidMeasuredResultsItem {
    pub e_cid_measured_results_value: ECidMeasuredResultsValue,
}

impl ECidMeasuredResultsItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, false, 1)?;
        let e_cid_measured_results_value = ECidMeasuredResultsValue::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            e_cid_measured_results_value,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, false, &optionals, false)?;
        self.e_cid_measured_results_value.encode(data)?;

        Ok(())
    }
}

impl PerCodec for ECidMeasuredResultsItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        ECidMeasuredResultsItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ECidMeasuredResultsItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ECidMeasuredResultsItem");
            e
        })
    }
}
// ECidMeasuredResultsValue
#[derive(Clone, Debug)]
pub enum ECidMeasuredResultsValue {
    ValueAngleofArrivalNr(UlAoA),
    NrTadv(NrTadv),
}

impl ECidMeasuredResultsValue {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_choice_idx(data, 0, 1, false)?;
        if extended {
            return Err(per_codec_error_new("CHOICE additions not implemented"));
        }
        match idx {
            0 => Ok(Self::ValueAngleofArrivalNr(UlAoA::decode(data)?)),
            1 => {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _ = Criticality::decode(data)?;
                let _ = decode::decode_length_determinent(data, None, None, false)?;
                let result = match id {
                    584 => Ok(Self::NrTadv(NrTadv::decode(data)?)),
                    x => Err(per_codec_error_new(format!("Unrecognised IE type {}", x))),
                };
                data.decode_align()?;
                result
            }
            _ => Err(per_codec_error_new("Unknown choice idx")),
        }
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        match self {
            Self::ValueAngleofArrivalNr(x) => {
                encode::encode_choice_idx(data, 0, 1, false, 0, false)?;
                x.encode(data)
            }
            Self::NrTadv(x) => {
                encode::encode_choice_idx(data, 0, 1, false, 1, false)?;
                encode::encode_integer(data, Some(0), Some(65535), false, 584, false)?;
                Criticality::Ignore.encode(data)?;
                let ie = &mut Allocator::new_codec_data();
                x.encode(ie)?;
                encode::encode_length_determinent(data, None, None, false, ie.length_in_bytes())?;
                Ok(data.append_aligned(ie))
            }
        }
    }
}

impl PerCodec for ECidMeasuredResultsValue {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        ECidMeasuredResultsValue::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ECidMeasuredResultsValue");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ECidMeasuredResultsValue");
            e
        })
    }
}
// ECidMeasuredResultsAssociatedInfoList
#[derive(Clone, Debug)]
pub struct ECidMeasuredResultsAssociatedInfoList(
    pub NonEmpty<ECidMeasuredResultsAssociatedInfoItem>,
);

impl ECidMeasuredResultsAssociatedInfoList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(64), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(ECidMeasuredResultsAssociatedInfoItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(64), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for ECidMeasuredResultsAssociatedInfoList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        ECidMeasuredResultsAssociatedInfoList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ECidMeasuredResultsAssociatedInfoList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ECidMeasuredResultsAssociatedInfoList");
            e
        })
    }
}
// ECidMeasuredResultsAssociatedInfoItem
#[derive(Clone, Debug)]
pub struct ECidMeasuredResultsAssociatedInfoItem {
    pub time_stamp: Option<TimeStamp>,
    pub measurement_quality: Option<TrpMeasurementQuality>,
}

impl ECidMeasuredResultsAssociatedInfoItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 3)?;
        let time_stamp = if optionals[0] {
            Some(TimeStamp::decode(data)?)
        } else {
            None
        };
        let measurement_quality = if optionals[1] {
            Some(TrpMeasurementQuality::decode(data)?)
        } else {
            None
        };

        // Process the extension container

        if optionals[2] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            time_stamp,
            measurement_quality,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.time_stamp.is_some());
        optionals.push(self.measurement_quality.is_some());
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        if let Some(x) = &self.time_stamp {
            x.encode(data)?;
        }
        if let Some(x) = &self.measurement_quality {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl PerCodec for ECidMeasuredResultsAssociatedInfoItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        ECidMeasuredResultsAssociatedInfoItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ECidMeasuredResultsAssociatedInfoItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ECidMeasuredResultsAssociatedInfoItem");
            e
        })
    }
}
// ECidReportCharacteristics
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum ECidReportCharacteristics {
    OnDemand,
    Periodic,
}

impl ECidReportCharacteristics {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(1), true)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(1),
            true,
            *self as i128,
            (*self as u32) >= 2,
        )
    }
}

impl PerCodec for ECidReportCharacteristics {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        ECidReportCharacteristics::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ECidReportCharacteristics");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ECidReportCharacteristics");
            e
        })
    }
}
// EgressBhrlcchList
#[derive(Clone, Debug)]
pub struct EgressBhrlcchList(pub NonEmpty<EgressBhrlcchItem>);

impl EgressBhrlcchList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(2), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(EgressBhrlcchItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(2), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for EgressBhrlcchList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        EgressBhrlcchList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("EgressBhrlcchList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("EgressBhrlcchList");
            e
        })
    }
}
// EgressBhrlcchItem
#[derive(Clone, Debug)]
pub struct EgressBhrlcchItem {
    pub next_hop_bap_address: BapAddress,
    pub bhrlc_channel_id: BhrlcChannelId,
}

impl EgressBhrlcchItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, false, 1)?;
        let next_hop_bap_address = BapAddress::decode(data)?;
        let bhrlc_channel_id = BhrlcChannelId::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            next_hop_bap_address,
            bhrlc_channel_id,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, false, &optionals, false)?;
        self.next_hop_bap_address.encode(data)?;
        self.bhrlc_channel_id.encode(data)?;

        Ok(())
    }
}

impl PerCodec for EgressBhrlcchItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        EgressBhrlcchItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("EgressBhrlcchItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("EgressBhrlcchItem");
            e
        })
    }
}
// EgressNonF1terminatingTopologyIndicator
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum EgressNonF1terminatingTopologyIndicator {
    True,
}

impl EgressNonF1terminatingTopologyIndicator {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(0), true)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(0),
            true,
            *self as i128,
            (*self as u32) >= 1,
        )
    }
}

impl PerCodec for EgressNonF1terminatingTopologyIndicator {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        EgressNonF1terminatingTopologyIndicator::decode_inner(data).map_err(
            |mut e: PerCodecError| {
                e.push_context("EgressNonF1terminatingTopologyIndicator");
                e
            },
        )
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("EgressNonF1terminatingTopologyIndicator");
            e
        })
    }
}
// EndpointIpAddressAndPort
#[derive(Clone, Debug)]
pub struct EndpointIpAddressAndPort {
    pub endpoint_ip_address: TransportLayerAddress,
    pub port_number: Option<PortNumber>,
}

impl EndpointIpAddressAndPort {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, false, 1)?;
        let endpoint_ip_address = TransportLayerAddress::decode(data)?;

        // Process the extension container
        let mut port_number: Option<PortNumber> = None;

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    230 => port_number = Some(PortNumber::decode(data)?),
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            endpoint_ip_address,
            port_number,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();
        if let Some(x) = &self.port_number {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 230, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        let mut optionals = BitString::new();
        optionals.push(num_ies != 0);

        encode::encode_sequence_header(data, false, &optionals, false)?;
        self.endpoint_ip_address.encode(data)?;
        if num_ies != 0 {
            encode::encode_length_determinent(data, Some(1), Some(65535), false, num_ies)?;
            data.append_aligned(ies);
        }
        Ok(())
    }
}

impl PerCodec for EndpointIpAddressAndPort {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        EndpointIpAddressAndPort::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("EndpointIpAddressAndPort");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("EndpointIpAddressAndPort");
            e
        })
    }
}
// EnergyDetectionThreshold
#[derive(Clone, Copy, Debug)]
pub struct EnergyDetectionThreshold(pub i8);

impl EnergyDetectionThreshold {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(
            decode::decode_integer(data, Some(-100), Some(-50), true)?.0 as i8,
        ))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_integer(data, Some(-100), Some(-50), true, self.0 as i128, false)
    }
}

impl PerCodec for EnergyDetectionThreshold {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        EnergyDetectionThreshold::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("EnergyDetectionThreshold");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("EnergyDetectionThreshold");
            e
        })
    }
}
// ExtendedAvailablePlmnList
#[derive(Clone, Debug)]
pub struct ExtendedAvailablePlmnList(pub NonEmpty<ExtendedAvailablePlmnItem>);

impl ExtendedAvailablePlmnList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(6), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(ExtendedAvailablePlmnItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(6), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for ExtendedAvailablePlmnList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        ExtendedAvailablePlmnList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ExtendedAvailablePlmnList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ExtendedAvailablePlmnList");
            e
        })
    }
}
// ExtendedAvailablePlmnItem
#[derive(Clone, Debug)]
pub struct ExtendedAvailablePlmnItem {
    pub plmn_identity: PlmnIdentity,
}

impl ExtendedAvailablePlmnItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, false, 1)?;
        let plmn_identity = PlmnIdentity::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self { plmn_identity })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, false, &optionals, false)?;
        self.plmn_identity.encode(data)?;

        Ok(())
    }
}

impl PerCodec for ExtendedAvailablePlmnItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        ExtendedAvailablePlmnItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ExtendedAvailablePlmnItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ExtendedAvailablePlmnItem");
            e
        })
    }
}
// ExplicitFormat
#[derive(Clone, Debug)]
pub struct ExplicitFormat {
    pub permutation: Permutation,
    pub noof_downlink_symbols: Option<NoofDownlinkSymbols>,
    pub noof_uplink_symbols: Option<NoofUplinkSymbols>,
}

impl ExplicitFormat {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, false, 3)?;
        let permutation = Permutation::decode(data)?;
        let noof_downlink_symbols = if optionals[0] {
            Some(NoofDownlinkSymbols::decode(data)?)
        } else {
            None
        };
        let noof_uplink_symbols = if optionals[1] {
            Some(NoofUplinkSymbols::decode(data)?)
        } else {
            None
        };

        // Process the extension container

        if optionals[2] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            permutation,
            noof_downlink_symbols,
            noof_uplink_symbols,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.noof_downlink_symbols.is_some());
        optionals.push(self.noof_uplink_symbols.is_some());
        optionals.push(false);

        encode::encode_sequence_header(data, false, &optionals, false)?;
        self.permutation.encode(data)?;
        if let Some(x) = &self.noof_downlink_symbols {
            x.encode(data)?;
        }
        if let Some(x) = &self.noof_uplink_symbols {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl PerCodec for ExplicitFormat {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        ExplicitFormat::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ExplicitFormat");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ExplicitFormat");
            e
        })
    }
}
// ExtendedServedPlmnsList
#[derive(Clone, Debug)]
pub struct ExtendedServedPlmnsList(pub NonEmpty<ExtendedServedPlmnsItem>);

impl ExtendedServedPlmnsList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(6), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(ExtendedServedPlmnsItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(6), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for ExtendedServedPlmnsList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        ExtendedServedPlmnsList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ExtendedServedPlmnsList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ExtendedServedPlmnsList");
            e
        })
    }
}
// ExtendedServedPlmnsItem
#[derive(Clone, Debug)]
pub struct ExtendedServedPlmnsItem {
    pub plmn_identity: PlmnIdentity,
    pub tai_slice_support_list: Option<SliceSupportList>,
    pub npn_support_info: Option<NpnSupportInfo>,
    pub extended_tai_slice_support_list: Option<ExtendedSliceSupportList>,
    pub tainsag_support_list: Option<NsagSupportList>,
}

impl ExtendedServedPlmnsItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 2)?;
        let plmn_identity = PlmnIdentity::decode(data)?;
        let tai_slice_support_list = if optionals[0] {
            Some(SliceSupportList::decode(data)?)
        } else {
            None
        };

        // Process the extension container
        let mut npn_support_info: Option<NpnSupportInfo> = None;
        let mut extended_tai_slice_support_list: Option<ExtendedSliceSupportList> = None;
        let mut tainsag_support_list: Option<NsagSupportList> = None;

        if optionals[1] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    384 => npn_support_info = Some(NpnSupportInfo::decode(data)?),
                    390 => {
                        extended_tai_slice_support_list =
                            Some(ExtendedSliceSupportList::decode(data)?)
                    }
                    644 => tainsag_support_list = Some(NsagSupportList::decode(data)?),
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            plmn_identity,
            tai_slice_support_list,
            npn_support_info,
            extended_tai_slice_support_list,
            tainsag_support_list,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();
        if let Some(x) = &self.npn_support_info {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 384, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.extended_tai_slice_support_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 390, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.tainsag_support_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 644, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        let mut optionals = BitString::new();
        optionals.push(self.tai_slice_support_list.is_some());
        optionals.push(num_ies != 0);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.plmn_identity.encode(data)?;
        if let Some(x) = &self.tai_slice_support_list {
            x.encode(data)?;
        }
        if num_ies != 0 {
            encode::encode_length_determinent(data, Some(1), Some(65535), false, num_ies)?;
            data.append_aligned(ies);
        }
        Ok(())
    }
}

impl PerCodec for ExtendedServedPlmnsItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        ExtendedServedPlmnsItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ExtendedServedPlmnsItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ExtendedServedPlmnsItem");
            e
        })
    }
}
// ExtendedSliceSupportList
#[derive(Clone, Debug)]
pub struct ExtendedSliceSupportList(pub NonEmpty<SliceSupportItem>);

impl ExtendedSliceSupportList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(SliceSupportItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(65535), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for ExtendedSliceSupportList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        ExtendedSliceSupportList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ExtendedSliceSupportList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ExtendedSliceSupportList");
            e
        })
    }
}
// ExtendedUeIdentityIndexValue
#[derive(Clone, Debug)]
pub struct ExtendedUeIdentityIndexValue(pub BitString);

impl ExtendedUeIdentityIndexValue {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(decode::decode_bitstring(
            data,
            Some(16),
            Some(16),
            false,
        )?))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_bitstring(data, Some(16), Some(16), false, &self.0, false)
    }
}

impl PerCodec for ExtendedUeIdentityIndexValue {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        ExtendedUeIdentityIndexValue::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ExtendedUeIdentityIndexValue");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ExtendedUeIdentityIndexValue");
            e
        })
    }
}
// EutraCellsList
#[derive(Clone, Debug)]
pub struct EutraCellsList(pub NonEmpty<EutraCellsListItem>);

impl EutraCellsList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(256), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(EutraCellsListItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(256), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for EutraCellsList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        EutraCellsList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("EutraCellsList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("EutraCellsList");
            e
        })
    }
}
// EutraCellsListItem
#[derive(Clone, Debug)]
pub struct EutraCellsListItem {
    pub eutra_cell_id: EutraCellId,
    pub served_eutra_cells_information: ServedEutraCellsInformation,
}

impl EutraCellsListItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, false, 1)?;
        let eutra_cell_id = EutraCellId::decode(data)?;
        let served_eutra_cells_information = ServedEutraCellsInformation::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            eutra_cell_id,
            served_eutra_cells_information,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, false, &optionals, false)?;
        self.eutra_cell_id.encode(data)?;
        self.served_eutra_cells_information.encode(data)?;

        Ok(())
    }
}

impl PerCodec for EutraCellsListItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        EutraCellsListItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("EutraCellsListItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("EutraCellsListItem");
            e
        })
    }
}
// EutraCellId
#[derive(Clone, Debug)]
pub struct EutraCellId(pub BitString);

impl EutraCellId {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(decode::decode_bitstring(
            data,
            Some(28),
            Some(28),
            false,
        )?))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_bitstring(data, Some(28), Some(28), false, &self.0, false)
    }
}

impl PerCodec for EutraCellId {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        EutraCellId::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("EutraCellId");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("EutraCellId");
            e
        })
    }
}
// EutraCoexFddInfo
#[derive(Clone, Debug)]
pub struct EutraCoexFddInfo {
    pub ul_earfcn: Option<ExtendedEarfcn>,
    pub dl_earfcn: ExtendedEarfcn,
    pub ul_transmission_bandwidth: Option<EutraTransmissionBandwidth>,
    pub dl_transmission_bandwidth: EutraTransmissionBandwidth,
}

impl EutraCoexFddInfo {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 3)?;
        let ul_earfcn = if optionals[0] {
            Some(ExtendedEarfcn::decode(data)?)
        } else {
            None
        };
        let dl_earfcn = ExtendedEarfcn::decode(data)?;
        let ul_transmission_bandwidth = if optionals[1] {
            Some(EutraTransmissionBandwidth::decode(data)?)
        } else {
            None
        };
        let dl_transmission_bandwidth = EutraTransmissionBandwidth::decode(data)?;

        // Process the extension container

        if optionals[2] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            ul_earfcn,
            dl_earfcn,
            ul_transmission_bandwidth,
            dl_transmission_bandwidth,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.ul_earfcn.is_some());
        optionals.push(self.ul_transmission_bandwidth.is_some());
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        if let Some(x) = &self.ul_earfcn {
            x.encode(data)?;
        }
        self.dl_earfcn.encode(data)?;
        if let Some(x) = &self.ul_transmission_bandwidth {
            x.encode(data)?;
        }
        self.dl_transmission_bandwidth.encode(data)?;

        Ok(())
    }
}

impl PerCodec for EutraCoexFddInfo {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        EutraCoexFddInfo::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("EutraCoexFddInfo");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("EutraCoexFddInfo");
            e
        })
    }
}
// EutraCoexModeInfo
#[derive(Clone, Debug)]
pub enum EutraCoexModeInfo {
    Fdd(EutraCoexFddInfo),
    Tdd(EutraCoexTddInfo),
}

impl EutraCoexModeInfo {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_choice_idx(data, 0, 1, true)?;
        if extended {
            return Err(per_codec_error_new("CHOICE additions not implemented"));
        }
        match idx {
            0 => Ok(Self::Fdd(EutraCoexFddInfo::decode(data)?)),
            1 => Ok(Self::Tdd(EutraCoexTddInfo::decode(data)?)),
            _ => Err(per_codec_error_new("Unknown choice idx")),
        }
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        match self {
            Self::Fdd(x) => {
                encode::encode_choice_idx(data, 0, 1, true, 0, false)?;
                x.encode(data)
            }
            Self::Tdd(x) => {
                encode::encode_choice_idx(data, 0, 1, true, 1, false)?;
                x.encode(data)
            }
        }
    }
}

impl PerCodec for EutraCoexModeInfo {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        EutraCoexModeInfo::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("EutraCoexModeInfo");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("EutraCoexModeInfo");
            e
        })
    }
}
// EutraCoexTddInfo
#[derive(Clone, Debug)]
pub struct EutraCoexTddInfo {
    pub earfcn: ExtendedEarfcn,
    pub transmission_bandwidth: EutraTransmissionBandwidth,
    pub subframe_assignment: EutraSubframeAssignment,
    pub special_subframe_info: EutraSpecialSubframeInfo,
}

impl EutraCoexTddInfo {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let earfcn = ExtendedEarfcn::decode(data)?;
        let transmission_bandwidth = EutraTransmissionBandwidth::decode(data)?;
        let subframe_assignment = EutraSubframeAssignment::decode(data)?;
        let special_subframe_info = EutraSpecialSubframeInfo::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            earfcn,
            transmission_bandwidth,
            subframe_assignment,
            special_subframe_info,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.earfcn.encode(data)?;
        self.transmission_bandwidth.encode(data)?;
        self.subframe_assignment.encode(data)?;
        self.special_subframe_info.encode(data)?;

        Ok(())
    }
}

impl PerCodec for EutraCoexTddInfo {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        EutraCoexTddInfo::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("EutraCoexTddInfo");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("EutraCoexTddInfo");
            e
        })
    }
}
// EutraCyclicPrefixDl
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum EutraCyclicPrefixDl {
    Normal,
    Extended,
}

impl EutraCyclicPrefixDl {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(1), true)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(1),
            true,
            *self as i128,
            (*self as u32) >= 2,
        )
    }
}

impl PerCodec for EutraCyclicPrefixDl {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        EutraCyclicPrefixDl::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("EutraCyclicPrefixDl");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("EutraCyclicPrefixDl");
            e
        })
    }
}
// EutraCyclicPrefixUl
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum EutraCyclicPrefixUl {
    Normal,
    Extended,
}

impl EutraCyclicPrefixUl {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(1), true)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(1),
            true,
            *self as i128,
            (*self as u32) >= 2,
        )
    }
}

impl PerCodec for EutraCyclicPrefixUl {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        EutraCyclicPrefixUl::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("EutraCyclicPrefixUl");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("EutraCyclicPrefixUl");
            e
        })
    }
}
// EutraPrachConfiguration
#[derive(Clone, Debug)]
pub struct EutraPrachConfiguration {
    pub root_sequence_index: u16,
    pub zero_correlation_index: u8,
    pub high_speed_flag: bool,
    pub prach_freq_offset: u8,
    pub prach_config_index: Option<u8>,
}

impl EutraPrachConfiguration {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 2)?;
        let root_sequence_index = decode::decode_integer(data, Some(0), Some(837), false)?.0 as u16;
        let zero_correlation_index =
            decode::decode_integer(data, Some(0), Some(15), false)?.0 as u8;
        let high_speed_flag = decode::decode_bool(data)?;
        let prach_freq_offset = decode::decode_integer(data, Some(0), Some(94), false)?.0 as u8;
        let prach_config_index = if optionals[0] {
            Some(decode::decode_integer(data, Some(0), Some(63), false)?.0 as u8)
        } else {
            None
        };

        // Process the extension container

        if optionals[1] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            root_sequence_index,
            zero_correlation_index,
            high_speed_flag,
            prach_freq_offset,
            prach_config_index,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.prach_config_index.is_some());
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        encode::encode_integer(
            data,
            Some(0),
            Some(837),
            false,
            self.root_sequence_index as i128,
            false,
        )?;
        encode::encode_integer(
            data,
            Some(0),
            Some(15),
            false,
            self.zero_correlation_index as i128,
            false,
        )?;
        encode::encode_bool(data, self.high_speed_flag)?;
        encode::encode_integer(
            data,
            Some(0),
            Some(94),
            false,
            self.prach_freq_offset as i128,
            false,
        )?;
        if let Some(x) = &self.prach_config_index {
            encode::encode_integer(data, Some(0), Some(63), false, *x as i128, false)?;
        }

        Ok(())
    }
}

impl PerCodec for EutraPrachConfiguration {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        EutraPrachConfiguration::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("EutraPrachConfiguration");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("EutraPrachConfiguration");
            e
        })
    }
}
// EutraSpecialSubframeInfo
#[derive(Clone, Debug)]
pub struct EutraSpecialSubframeInfo {
    pub special_subframe_patterns: EutraSpecialSubframePatterns,
    pub cyclic_prefix_dl: EutraCyclicPrefixDl,
    pub cyclic_prefix_ul: EutraCyclicPrefixUl,
}

impl EutraSpecialSubframeInfo {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let special_subframe_patterns = EutraSpecialSubframePatterns::decode(data)?;
        let cyclic_prefix_dl = EutraCyclicPrefixDl::decode(data)?;
        let cyclic_prefix_ul = EutraCyclicPrefixUl::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            special_subframe_patterns,
            cyclic_prefix_dl,
            cyclic_prefix_ul,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.special_subframe_patterns.encode(data)?;
        self.cyclic_prefix_dl.encode(data)?;
        self.cyclic_prefix_ul.encode(data)?;

        Ok(())
    }
}

impl PerCodec for EutraSpecialSubframeInfo {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        EutraSpecialSubframeInfo::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("EutraSpecialSubframeInfo");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("EutraSpecialSubframeInfo");
            e
        })
    }
}
// EutraSpecialSubframePatterns
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum EutraSpecialSubframePatterns {
    Ssp0,
    Ssp1,
    Ssp2,
    Ssp3,
    Ssp4,
    Ssp5,
    Ssp6,
    Ssp7,
    Ssp8,
    Ssp9,
    Ssp10,
}

impl EutraSpecialSubframePatterns {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(10), true)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(10),
            true,
            *self as i128,
            (*self as u32) >= 11,
        )
    }
}

impl PerCodec for EutraSpecialSubframePatterns {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        EutraSpecialSubframePatterns::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("EutraSpecialSubframePatterns");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("EutraSpecialSubframePatterns");
            e
        })
    }
}
// EutraSubframeAssignment
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum EutraSubframeAssignment {
    Sa0,
    Sa1,
    Sa2,
    Sa3,
    Sa4,
    Sa5,
    Sa6,
}

impl EutraSubframeAssignment {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(6), true)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(6),
            true,
            *self as i128,
            (*self as u32) >= 7,
        )
    }
}

impl PerCodec for EutraSubframeAssignment {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        EutraSubframeAssignment::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("EutraSubframeAssignment");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("EutraSubframeAssignment");
            e
        })
    }
}
// EutraTransmissionBandwidth
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum EutraTransmissionBandwidth {
    Bw6,
    Bw15,
    Bw25,
    Bw50,
    Bw75,
    Bw100,
}

impl EutraTransmissionBandwidth {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(5), true)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(5),
            true,
            *self as i128,
            (*self as u32) >= 6,
        )
    }
}

impl PerCodec for EutraTransmissionBandwidth {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        EutraTransmissionBandwidth::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("EutraTransmissionBandwidth");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("EutraTransmissionBandwidth");
            e
        })
    }
}
// EutranQos
#[derive(Clone, Debug)]
pub struct EutranQos {
    pub qci: Qci,
    pub allocation_and_retention_priority: AllocationAndRetentionPriority,
    pub gbr_qos_information: Option<GbrQosInformation>,
    pub enb_dl_tnl_address: Option<TransportLayerAddress>,
}

impl EutranQos {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 2)?;
        let qci = Qci::decode(data)?;
        let allocation_and_retention_priority = AllocationAndRetentionPriority::decode(data)?;
        let gbr_qos_information = if optionals[0] {
            Some(GbrQosInformation::decode(data)?)
        } else {
            None
        };

        // Process the extension container
        let mut enb_dl_tnl_address: Option<TransportLayerAddress> = None;

        if optionals[1] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    437 => enb_dl_tnl_address = Some(TransportLayerAddress::decode(data)?),
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            qci,
            allocation_and_retention_priority,
            gbr_qos_information,
            enb_dl_tnl_address,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();
        if let Some(x) = &self.enb_dl_tnl_address {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 437, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        let mut optionals = BitString::new();
        optionals.push(self.gbr_qos_information.is_some());
        optionals.push(num_ies != 0);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.qci.encode(data)?;
        self.allocation_and_retention_priority.encode(data)?;
        if let Some(x) = &self.gbr_qos_information {
            x.encode(data)?;
        }
        if num_ies != 0 {
            encode::encode_length_determinent(data, Some(1), Some(65535), false, num_ies)?;
            data.append_aligned(ies);
        }
        Ok(())
    }
}

impl PerCodec for EutranQos {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        EutranQos::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("EutranQos");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("EutranQos");
            e
        })
    }
}
// ExecuteDuplication
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum ExecuteDuplication {
    True,
}

impl ExecuteDuplication {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(0), true)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(0),
            true,
            *self as i128,
            (*self as u32) >= 1,
        )
    }
}

impl PerCodec for ExecuteDuplication {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        ExecuteDuplication::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ExecuteDuplication");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ExecuteDuplication");
            e
        })
    }
}
// ExtendedEarfcn
#[derive(Clone, Copy, Debug)]
pub struct ExtendedEarfcn(pub u32);

impl ExtendedEarfcn {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(
            decode::decode_integer(data, Some(0), Some(262143), false)?.0 as u32,
        ))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_integer(data, Some(0), Some(262143), false, self.0 as i128, false)
    }
}

impl PerCodec for ExtendedEarfcn {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        ExtendedEarfcn::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ExtendedEarfcn");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ExtendedEarfcn");
            e
        })
    }
}
// EutraModeInfo
#[derive(Clone, Debug)]
pub enum EutraModeInfo {
    Eutrafdd(EutraFddInfo),
    Eutratdd(EutraTddInfo),
}

impl EutraModeInfo {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_choice_idx(data, 0, 2, false)?;
        if extended {
            return Err(per_codec_error_new("CHOICE additions not implemented"));
        }
        match idx {
            0 => Ok(Self::Eutrafdd(EutraFddInfo::decode(data)?)),
            1 => Ok(Self::Eutratdd(EutraTddInfo::decode(data)?)),
            2 => {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _ = Criticality::decode(data)?;
                let _ = decode::decode_length_determinent(data, None, None, false)?;
                let result = match id {
                    x => Err(per_codec_error_new(format!("Unrecognised IE type {}", x))),
                };
                data.decode_align()?;
                result
            }
            _ => Err(per_codec_error_new("Unknown choice idx")),
        }
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        match self {
            Self::Eutrafdd(x) => {
                encode::encode_choice_idx(data, 0, 2, false, 0, false)?;
                x.encode(data)
            }
            Self::Eutratdd(x) => {
                encode::encode_choice_idx(data, 0, 2, false, 1, false)?;
                x.encode(data)
            }
        }
    }
}

impl PerCodec for EutraModeInfo {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        EutraModeInfo::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("EutraModeInfo");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("EutraModeInfo");
            e
        })
    }
}
// EutraNrCellResourceCoordinationReqContainer
#[derive(Clone, Debug)]
pub struct EutraNrCellResourceCoordinationReqContainer(pub Vec<u8>);

impl EutraNrCellResourceCoordinationReqContainer {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(decode::decode_octetstring(data, None, None, false)?))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_octetstring(data, None, None, false, &self.0, false)
    }
}

impl PerCodec for EutraNrCellResourceCoordinationReqContainer {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        EutraNrCellResourceCoordinationReqContainer::decode_inner(data).map_err(
            |mut e: PerCodecError| {
                e.push_context("EutraNrCellResourceCoordinationReqContainer");
                e
            },
        )
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("EutraNrCellResourceCoordinationReqContainer");
            e
        })
    }
}
// EutraNrCellResourceCoordinationReqAckContainer
#[derive(Clone, Debug)]
pub struct EutraNrCellResourceCoordinationReqAckContainer(pub Vec<u8>);

impl EutraNrCellResourceCoordinationReqAckContainer {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(decode::decode_octetstring(data, None, None, false)?))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_octetstring(data, None, None, false, &self.0, false)
    }
}

impl PerCodec for EutraNrCellResourceCoordinationReqAckContainer {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        EutraNrCellResourceCoordinationReqAckContainer::decode_inner(data).map_err(
            |mut e: PerCodecError| {
                e.push_context("EutraNrCellResourceCoordinationReqAckContainer");
                e
            },
        )
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("EutraNrCellResourceCoordinationReqAckContainer");
            e
        })
    }
}
// EutraFddInfo
#[derive(Clone, Debug)]
pub struct EutraFddInfo {
    pub ul_offset_to_point_a: OffsetToPointA,
    pub dl_offset_to_point_a: OffsetToPointA,
}

impl EutraFddInfo {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let ul_offset_to_point_a = OffsetToPointA::decode(data)?;
        let dl_offset_to_point_a = OffsetToPointA::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            ul_offset_to_point_a,
            dl_offset_to_point_a,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.ul_offset_to_point_a.encode(data)?;
        self.dl_offset_to_point_a.encode(data)?;

        Ok(())
    }
}

impl PerCodec for EutraFddInfo {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        EutraFddInfo::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("EutraFddInfo");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("EutraFddInfo");
            e
        })
    }
}
// EutraTddInfo
#[derive(Clone, Debug)]
pub struct EutraTddInfo {
    pub offset_to_point_a: OffsetToPointA,
}

impl EutraTddInfo {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let offset_to_point_a = OffsetToPointA::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self { offset_to_point_a })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.offset_to_point_a.encode(data)?;

        Ok(())
    }
}

impl PerCodec for EutraTddInfo {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        EutraTddInfo::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("EutraTddInfo");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("EutraTddInfo");
            e
        })
    }
}
// EventType
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum EventType {
    OnDemand,
    Periodic,
    Stop,
}

impl EventType {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(2), true)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(2),
            true,
            *self as i128,
            (*self as u32) >= 3,
        )
    }
}

impl PerCodec for EventType {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        EventType::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("EventType");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("EventType");
            e
        })
    }
}
// ExtendedPacketDelayBudget
#[derive(Clone, Copy, Debug)]
pub struct ExtendedPacketDelayBudget(pub i128);

impl ExtendedPacketDelayBudget {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(
            decode::decode_integer(data, Some(1), Some(65535), true)?.0,
        ))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_integer(data, Some(1), Some(65535), true, self.0, false)
    }
}

impl PerCodec for ExtendedPacketDelayBudget {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        ExtendedPacketDelayBudget::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ExtendedPacketDelayBudget");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ExtendedPacketDelayBudget");
            e
        })
    }
}
// ExpectedUlAoA
#[derive(Clone, Debug)]
pub struct ExpectedUlAoA {
    pub expected_azimuth_ao_a: ExpectedAzimuthAoA,
    pub expected_zenith_ao_a: Option<ExpectedZenithAoA>,
}

impl ExpectedUlAoA {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 2)?;
        let expected_azimuth_ao_a = ExpectedAzimuthAoA::decode(data)?;
        let expected_zenith_ao_a = if optionals[0] {
            Some(ExpectedZenithAoA::decode(data)?)
        } else {
            None
        };

        // Process the extension container

        if optionals[1] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            expected_azimuth_ao_a,
            expected_zenith_ao_a,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.expected_zenith_ao_a.is_some());
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.expected_azimuth_ao_a.encode(data)?;
        if let Some(x) = &self.expected_zenith_ao_a {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl PerCodec for ExpectedUlAoA {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        ExpectedUlAoA::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ExpectedUlAoA");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ExpectedUlAoA");
            e
        })
    }
}
// ExpectedZoAOnly
#[derive(Clone, Debug)]
pub struct ExpectedZoAOnly {
    pub expected_zo_a_only: ExpectedZenithAoA,
}

impl ExpectedZoAOnly {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let expected_zo_a_only = ExpectedZenithAoA::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self { expected_zo_a_only })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.expected_zo_a_only.encode(data)?;

        Ok(())
    }
}

impl PerCodec for ExpectedZoAOnly {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        ExpectedZoAOnly::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ExpectedZoAOnly");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ExpectedZoAOnly");
            e
        })
    }
}
// ExpectedAzimuthAoA
#[derive(Clone, Debug)]
pub struct ExpectedAzimuthAoA {
    pub expected_azimuth_ao_a_value: ExpectedValueAoA,
    pub expected_azimuth_ao_a_uncertainty: UncertaintyRangeAoA,
}

impl ExpectedAzimuthAoA {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let expected_azimuth_ao_a_value = ExpectedValueAoA::decode(data)?;
        let expected_azimuth_ao_a_uncertainty = UncertaintyRangeAoA::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            expected_azimuth_ao_a_value,
            expected_azimuth_ao_a_uncertainty,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.expected_azimuth_ao_a_value.encode(data)?;
        self.expected_azimuth_ao_a_uncertainty.encode(data)?;

        Ok(())
    }
}

impl PerCodec for ExpectedAzimuthAoA {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        ExpectedAzimuthAoA::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ExpectedAzimuthAoA");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ExpectedAzimuthAoA");
            e
        })
    }
}
// ExpectedZenithAoA
#[derive(Clone, Debug)]
pub struct ExpectedZenithAoA {
    pub expected_zenith_ao_a_value: ExpectedValueZoA,
    pub expected_zenith_ao_a_uncertainty: UncertaintyRangeZoA,
}

impl ExpectedZenithAoA {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let expected_zenith_ao_a_value = ExpectedValueZoA::decode(data)?;
        let expected_zenith_ao_a_uncertainty = UncertaintyRangeZoA::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            expected_zenith_ao_a_value,
            expected_zenith_ao_a_uncertainty,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.expected_zenith_ao_a_value.encode(data)?;
        self.expected_zenith_ao_a_uncertainty.encode(data)?;

        Ok(())
    }
}

impl PerCodec for ExpectedZenithAoA {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        ExpectedZenithAoA::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ExpectedZenithAoA");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ExpectedZenithAoA");
            e
        })
    }
}
// ExpectedValueAoA
#[derive(Clone, Copy, Debug)]
pub struct ExpectedValueAoA(pub u16);

impl ExpectedValueAoA {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(
            decode::decode_integer(data, Some(0), Some(3599), false)?.0 as u16,
        ))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_integer(data, Some(0), Some(3599), false, self.0 as i128, false)
    }
}

impl PerCodec for ExpectedValueAoA {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        ExpectedValueAoA::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ExpectedValueAoA");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ExpectedValueAoA");
            e
        })
    }
}
// ExpectedValueZoA
#[derive(Clone, Copy, Debug)]
pub struct ExpectedValueZoA(pub u16);

impl ExpectedValueZoA {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(
            decode::decode_integer(data, Some(0), Some(1799), false)?.0 as u16,
        ))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_integer(data, Some(0), Some(1799), false, self.0 as i128, false)
    }
}

impl PerCodec for ExpectedValueZoA {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        ExpectedValueZoA::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ExpectedValueZoA");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ExpectedValueZoA");
            e
        })
    }
}
// EcnMarkingorCongestionInformationReportingRequest
#[derive(Clone, Debug)]
pub enum EcnMarkingorCongestionInformationReportingRequest {
    EcnMarking(EcNmarkingRequest),
    CongestionInformation(CongestionInformationRequest),
}

impl EcnMarkingorCongestionInformationReportingRequest {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_choice_idx(data, 0, 2, false)?;
        if extended {
            return Err(per_codec_error_new("CHOICE additions not implemented"));
        }
        match idx {
            0 => Ok(Self::EcnMarking(EcNmarkingRequest::decode(data)?)),
            1 => Ok(Self::CongestionInformation(
                CongestionInformationRequest::decode(data)?,
            )),
            2 => {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _ = Criticality::decode(data)?;
                let _ = decode::decode_length_determinent(data, None, None, false)?;
                let result = match id {
                    x => Err(per_codec_error_new(format!("Unrecognised IE type {}", x))),
                };
                data.decode_align()?;
                result
            }
            _ => Err(per_codec_error_new("Unknown choice idx")),
        }
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        match self {
            Self::EcnMarking(x) => {
                encode::encode_choice_idx(data, 0, 2, false, 0, false)?;
                x.encode(data)
            }
            Self::CongestionInformation(x) => {
                encode::encode_choice_idx(data, 0, 2, false, 1, false)?;
                x.encode(data)
            }
        }
    }
}

impl PerCodec for EcnMarkingorCongestionInformationReportingRequest {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        EcnMarkingorCongestionInformationReportingRequest::decode_inner(data).map_err(
            |mut e: PerCodecError| {
                e.push_context("EcnMarkingorCongestionInformationReportingRequest");
                e
            },
        )
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("EcnMarkingorCongestionInformationReportingRequest");
            e
        })
    }
}
// EcNmarkingRequest
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum EcNmarkingRequest {
    Ul,
    Dl,
    Both,
    Stop,
}

impl EcNmarkingRequest {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(3), true)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(3),
            true,
            *self as i128,
            (*self as u32) >= 4,
        )
    }
}

impl PerCodec for EcNmarkingRequest {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        EcNmarkingRequest::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("EcNmarkingRequest");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("EcNmarkingRequest");
            e
        })
    }
}
// CongestionInformationRequest
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum CongestionInformationRequest {
    Ul,
    Dl,
    Both,
    Stop,
}

impl CongestionInformationRequest {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(3), true)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(3),
            true,
            *self as i128,
            (*self as u32) >= 4,
        )
    }
}

impl PerCodec for CongestionInformationRequest {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        CongestionInformationRequest::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CongestionInformationRequest");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CongestionInformationRequest");
            e
        })
    }
}
// EcnMarkingorCongestionInformationReportingStatus
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum EcnMarkingorCongestionInformationReportingStatus {
    Active,
    NotActive,
}

impl EcnMarkingorCongestionInformationReportingStatus {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(1), true)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(1),
            true,
            *self as i128,
            (*self as u32) >= 2,
        )
    }
}

impl PerCodec for EcnMarkingorCongestionInformationReportingStatus {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        EcnMarkingorCongestionInformationReportingStatus::decode_inner(data).map_err(
            |mut e: PerCodecError| {
                e.push_context("EcnMarkingorCongestionInformationReportingStatus");
                e
            },
        )
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("EcnMarkingorCongestionInformationReportingStatus");
            e
        })
    }
}
// F1cPathNsa
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum F1cPathNsa {
    Lte,
    Nr,
    Both,
}

impl F1cPathNsa {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(2), false)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(2),
            false,
            *self as i128,
            (*self as u32) >= 3,
        )
    }
}

impl PerCodec for F1cPathNsa {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        F1cPathNsa::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("F1cPathNsa");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("F1cPathNsa");
            e
        })
    }
}
// F1cTransferPath
#[derive(Clone, Debug)]
pub struct F1cTransferPath {
    pub f1c_path_nsa: F1cPathNsa,
}

impl F1cTransferPath {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let f1c_path_nsa = F1cPathNsa::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self { f1c_path_nsa })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.f1c_path_nsa.encode(data)?;

        Ok(())
    }
}

impl PerCodec for F1cTransferPath {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        F1cTransferPath::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("F1cTransferPath");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("F1cTransferPath");
            e
        })
    }
}
// F1cPathNrDc
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum F1cPathNrDc {
    Mcg,
    Scg,
    Both,
}

impl F1cPathNrDc {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(2), false)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(2),
            false,
            *self as i128,
            (*self as u32) >= 3,
        )
    }
}

impl PerCodec for F1cPathNrDc {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        F1cPathNrDc::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("F1cPathNrDc");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("F1cPathNrDc");
            e
        })
    }
}
// F1cTransferPathNrDc
#[derive(Clone, Debug)]
pub struct F1cTransferPathNrDc {
    pub f1c_path_nr_dc: F1cPathNrDc,
}

impl F1cTransferPathNrDc {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let f1c_path_nr_dc = F1cPathNrDc::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self { f1c_path_nr_dc })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.f1c_path_nr_dc.encode(data)?;

        Ok(())
    }
}

impl PerCodec for F1cTransferPathNrDc {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        F1cTransferPathNrDc::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("F1cTransferPathNrDc");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("F1cTransferPathNrDc");
            e
        })
    }
}
// F1uPathFailure
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum F1uPathFailure {
    True,
}

impl F1uPathFailure {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(0), true)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(0),
            true,
            *self as i128,
            (*self as u32) >= 1,
        )
    }
}

impl PerCodec for F1uPathFailure {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        F1uPathFailure::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("F1uPathFailure");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("F1uPathFailure");
            e
        })
    }
}
// F1uTunnelNotEstablished
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum F1uTunnelNotEstablished {
    True,
}

impl F1uTunnelNotEstablished {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(0), true)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(0),
            true,
            *self as i128,
            (*self as u32) >= 1,
        )
    }
}

impl PerCodec for F1uTunnelNotEstablished {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        F1uTunnelNotEstablished::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("F1uTunnelNotEstablished");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("F1uTunnelNotEstablished");
            e
        })
    }
}
// FddInfo
#[derive(Clone, Debug)]
pub struct FddInfo {
    pub ul_nr_freq_info: NrFreqInfo,
    pub dl_nr_freq_info: NrFreqInfo,
    pub ul_transmission_bandwidth: TransmissionBandwidth,
    pub dl_transmission_bandwidth: TransmissionBandwidth,
    pub ul_carrier_list: Option<NrCarrierList>,
    pub dl_carrier_list: Option<NrCarrierList>,
}

impl FddInfo {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let ul_nr_freq_info = NrFreqInfo::decode(data)?;
        let dl_nr_freq_info = NrFreqInfo::decode(data)?;
        let ul_transmission_bandwidth = TransmissionBandwidth::decode(data)?;
        let dl_transmission_bandwidth = TransmissionBandwidth::decode(data)?;

        // Process the extension container
        let mut ul_carrier_list: Option<NrCarrierList> = None;
        let mut dl_carrier_list: Option<NrCarrierList> = None;

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    355 => ul_carrier_list = Some(NrCarrierList::decode(data)?),
                    389 => dl_carrier_list = Some(NrCarrierList::decode(data)?),
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            ul_nr_freq_info,
            dl_nr_freq_info,
            ul_transmission_bandwidth,
            dl_transmission_bandwidth,
            ul_carrier_list,
            dl_carrier_list,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();
        if let Some(x) = &self.ul_carrier_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 355, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.dl_carrier_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 389, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        let mut optionals = BitString::new();
        optionals.push(num_ies != 0);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.ul_nr_freq_info.encode(data)?;
        self.dl_nr_freq_info.encode(data)?;
        self.ul_transmission_bandwidth.encode(data)?;
        self.dl_transmission_bandwidth.encode(data)?;
        if num_ies != 0 {
            encode::encode_length_determinent(data, Some(1), Some(65535), false, num_ies)?;
            data.append_aligned(ies);
        }
        Ok(())
    }
}

impl PerCodec for FddInfo {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        FddInfo::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("FddInfo");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("FddInfo");
            e
        })
    }
}
// FddInfoRel16
#[derive(Clone, Debug)]
pub struct FddInfoRel16 {
    pub ul_freq_info: Option<FreqInfoRel16>,
    pub sul_freq_info: Option<FreqInfoRel16>,
}

impl FddInfoRel16 {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 3)?;
        let ul_freq_info = if optionals[0] {
            Some(FreqInfoRel16::decode(data)?)
        } else {
            None
        };
        let sul_freq_info = if optionals[1] {
            Some(FreqInfoRel16::decode(data)?)
        } else {
            None
        };

        // Process the extension container

        if optionals[2] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            ul_freq_info,
            sul_freq_info,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.ul_freq_info.is_some());
        optionals.push(self.sul_freq_info.is_some());
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        if let Some(x) = &self.ul_freq_info {
            x.encode(data)?;
        }
        if let Some(x) = &self.sul_freq_info {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl PerCodec for FddInfoRel16 {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        FddInfoRel16::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("FddInfoRel16");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("FddInfoRel16");
            e
        })
    }
}
// FiveGProSeAuthorized
#[derive(Clone, Debug)]
pub struct FiveGProSeAuthorized {
    pub five_g_pro_se_direct_discovery: Option<FiveGProSeDirectDiscovery>,
    pub five_g_pro_se_direct_communication: Option<FiveGProSeDirectCommunication>,
    pub five_g_pro_se_layer_2_ue_to_network_relay: Option<FiveGProSeLayer2UeToNetworkRelay>,
    pub five_g_pro_se_layer_3_ue_to_network_relay: Option<FiveGProSeLayer3UeToNetworkRelay>,
    pub five_g_pro_se_layer_2_remote_ue: Option<FiveGProSeLayer2RemoteUe>,
    pub five_g_pro_se_layer_2_multipath: Option<FiveGProSeLayer2Multipath>,
    pub five_g_pro_se_layer_2_ue_to_ue_relay: Option<FiveGProSeLayer2UeToUeRelay>,
    pub five_g_pro_se_layer_2_ue_to_ue_remote: Option<FiveGProSeLayer2UeToUeRemote>,
}

impl FiveGProSeAuthorized {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 6)?;
        let five_g_pro_se_direct_discovery = if optionals[0] {
            Some(FiveGProSeDirectDiscovery::decode(data)?)
        } else {
            None
        };
        let five_g_pro_se_direct_communication = if optionals[1] {
            Some(FiveGProSeDirectCommunication::decode(data)?)
        } else {
            None
        };
        let five_g_pro_se_layer_2_ue_to_network_relay = if optionals[2] {
            Some(FiveGProSeLayer2UeToNetworkRelay::decode(data)?)
        } else {
            None
        };
        let five_g_pro_se_layer_3_ue_to_network_relay = if optionals[3] {
            Some(FiveGProSeLayer3UeToNetworkRelay::decode(data)?)
        } else {
            None
        };
        let five_g_pro_se_layer_2_remote_ue = if optionals[4] {
            Some(FiveGProSeLayer2RemoteUe::decode(data)?)
        } else {
            None
        };

        // Process the extension container
        let mut five_g_pro_se_layer_2_multipath: Option<FiveGProSeLayer2Multipath> = None;
        let mut five_g_pro_se_layer_2_ue_to_ue_relay: Option<FiveGProSeLayer2UeToUeRelay> = None;
        let mut five_g_pro_se_layer_2_ue_to_ue_remote: Option<FiveGProSeLayer2UeToUeRemote> = None;

        if optionals[5] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    738 => {
                        five_g_pro_se_layer_2_multipath =
                            Some(FiveGProSeLayer2Multipath::decode(data)?)
                    }
                    739 => {
                        five_g_pro_se_layer_2_ue_to_ue_relay =
                            Some(FiveGProSeLayer2UeToUeRelay::decode(data)?)
                    }
                    740 => {
                        five_g_pro_se_layer_2_ue_to_ue_remote =
                            Some(FiveGProSeLayer2UeToUeRemote::decode(data)?)
                    }
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            five_g_pro_se_direct_discovery,
            five_g_pro_se_direct_communication,
            five_g_pro_se_layer_2_ue_to_network_relay,
            five_g_pro_se_layer_3_ue_to_network_relay,
            five_g_pro_se_layer_2_remote_ue,
            five_g_pro_se_layer_2_multipath,
            five_g_pro_se_layer_2_ue_to_ue_relay,
            five_g_pro_se_layer_2_ue_to_ue_remote,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();
        if let Some(x) = &self.five_g_pro_se_layer_2_multipath {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 738, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.five_g_pro_se_layer_2_ue_to_ue_relay {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 739, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.five_g_pro_se_layer_2_ue_to_ue_remote {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 740, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        let mut optionals = BitString::new();
        optionals.push(self.five_g_pro_se_direct_discovery.is_some());
        optionals.push(self.five_g_pro_se_direct_communication.is_some());
        optionals.push(self.five_g_pro_se_layer_2_ue_to_network_relay.is_some());
        optionals.push(self.five_g_pro_se_layer_3_ue_to_network_relay.is_some());
        optionals.push(self.five_g_pro_se_layer_2_remote_ue.is_some());
        optionals.push(num_ies != 0);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        if let Some(x) = &self.five_g_pro_se_direct_discovery {
            x.encode(data)?;
        }
        if let Some(x) = &self.five_g_pro_se_direct_communication {
            x.encode(data)?;
        }
        if let Some(x) = &self.five_g_pro_se_layer_2_ue_to_network_relay {
            x.encode(data)?;
        }
        if let Some(x) = &self.five_g_pro_se_layer_3_ue_to_network_relay {
            x.encode(data)?;
        }
        if let Some(x) = &self.five_g_pro_se_layer_2_remote_ue {
            x.encode(data)?;
        }
        if num_ies != 0 {
            encode::encode_length_determinent(data, Some(1), Some(65535), false, num_ies)?;
            data.append_aligned(ies);
        }
        Ok(())
    }
}

impl PerCodec for FiveGProSeAuthorized {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        FiveGProSeAuthorized::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("FiveGProSeAuthorized");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("FiveGProSeAuthorized");
            e
        })
    }
}
// FiveGProSeDirectDiscovery
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum FiveGProSeDirectDiscovery {
    Authorized,
    NotAuthorized,
}

impl FiveGProSeDirectDiscovery {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(1), true)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(1),
            true,
            *self as i128,
            (*self as u32) >= 2,
        )
    }
}

impl PerCodec for FiveGProSeDirectDiscovery {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        FiveGProSeDirectDiscovery::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("FiveGProSeDirectDiscovery");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("FiveGProSeDirectDiscovery");
            e
        })
    }
}
// FiveGProSeDirectCommunication
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum FiveGProSeDirectCommunication {
    Authorized,
    NotAuthorized,
}

impl FiveGProSeDirectCommunication {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(1), true)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(1),
            true,
            *self as i128,
            (*self as u32) >= 2,
        )
    }
}

impl PerCodec for FiveGProSeDirectCommunication {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        FiveGProSeDirectCommunication::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("FiveGProSeDirectCommunication");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("FiveGProSeDirectCommunication");
            e
        })
    }
}
// FiveGProSeLayer2UeToNetworkRelay
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum FiveGProSeLayer2UeToNetworkRelay {
    Authorized,
    NotAuthorized,
}

impl FiveGProSeLayer2UeToNetworkRelay {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(1), true)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(1),
            true,
            *self as i128,
            (*self as u32) >= 2,
        )
    }
}

impl PerCodec for FiveGProSeLayer2UeToNetworkRelay {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        FiveGProSeLayer2UeToNetworkRelay::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("FiveGProSeLayer2UeToNetworkRelay");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("FiveGProSeLayer2UeToNetworkRelay");
            e
        })
    }
}
// FiveGProSeLayer3UeToNetworkRelay
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum FiveGProSeLayer3UeToNetworkRelay {
    Authorized,
    NotAuthorized,
}

impl FiveGProSeLayer3UeToNetworkRelay {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(1), true)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(1),
            true,
            *self as i128,
            (*self as u32) >= 2,
        )
    }
}

impl PerCodec for FiveGProSeLayer3UeToNetworkRelay {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        FiveGProSeLayer3UeToNetworkRelay::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("FiveGProSeLayer3UeToNetworkRelay");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("FiveGProSeLayer3UeToNetworkRelay");
            e
        })
    }
}
// FiveGProSeLayer2RemoteUe
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum FiveGProSeLayer2RemoteUe {
    Authorized,
    NotAuthorized,
}

impl FiveGProSeLayer2RemoteUe {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(1), true)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(1),
            true,
            *self as i128,
            (*self as u32) >= 2,
        )
    }
}

impl PerCodec for FiveGProSeLayer2RemoteUe {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        FiveGProSeLayer2RemoteUe::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("FiveGProSeLayer2RemoteUe");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("FiveGProSeLayer2RemoteUe");
            e
        })
    }
}
// FiveGProSeLayer2Multipath
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum FiveGProSeLayer2Multipath {
    Authorized,
    NotAuthorized,
}

impl FiveGProSeLayer2Multipath {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(1), true)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(1),
            true,
            *self as i128,
            (*self as u32) >= 2,
        )
    }
}

impl PerCodec for FiveGProSeLayer2Multipath {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        FiveGProSeLayer2Multipath::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("FiveGProSeLayer2Multipath");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("FiveGProSeLayer2Multipath");
            e
        })
    }
}
// FiveGProSeLayer2UeToUeRelay
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum FiveGProSeLayer2UeToUeRelay {
    Authorized,
    NotAuthorized,
}

impl FiveGProSeLayer2UeToUeRelay {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(1), true)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(1),
            true,
            *self as i128,
            (*self as u32) >= 2,
        )
    }
}

impl PerCodec for FiveGProSeLayer2UeToUeRelay {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        FiveGProSeLayer2UeToUeRelay::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("FiveGProSeLayer2UeToUeRelay");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("FiveGProSeLayer2UeToUeRelay");
            e
        })
    }
}
// FiveGProSeLayer2UeToUeRemote
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum FiveGProSeLayer2UeToUeRemote {
    Authorized,
    NotAuthorized,
}

impl FiveGProSeLayer2UeToUeRemote {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(1), true)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(1),
            true,
            *self as i128,
            (*self as u32) >= 2,
        )
    }
}

impl PerCodec for FiveGProSeLayer2UeToUeRemote {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        FiveGProSeLayer2UeToUeRemote::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("FiveGProSeLayer2UeToUeRemote");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("FiveGProSeLayer2UeToUeRemote");
            e
        })
    }
}
// FiveQi
#[derive(Clone, Copy, Debug)]
pub struct FiveQi(pub u8);

impl FiveQi {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(
            decode::decode_integer(data, Some(0), Some(255), true)?.0 as u8,
        ))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_integer(data, Some(0), Some(255), true, self.0 as i128, false)
    }
}

impl PerCodec for FiveQi {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        FiveQi::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("FiveQi");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("FiveQi");
            e
        })
    }
}
// FlowsMappedToDrbList
#[derive(Clone, Debug)]
pub struct FlowsMappedToDrbList(pub NonEmpty<FlowsMappedToDrbItem>);

impl FlowsMappedToDrbList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(64), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(FlowsMappedToDrbItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(64), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for FlowsMappedToDrbList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        FlowsMappedToDrbList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("FlowsMappedToDrbList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("FlowsMappedToDrbList");
            e
        })
    }
}
// FlowsMappedToDrbItem
#[derive(Clone, Debug)]
pub struct FlowsMappedToDrbItem {
    pub qos_flow_identifier: QosFlowIdentifier,
    pub qos_flow_level_qos_parameters: QosFlowLevelQosParameters,
    pub qos_flow_mapping_indication: Option<QosFlowMappingIndication>,
    pub tsc_traffic_characteristics: Option<TscTrafficCharacteristics>,
}

impl FlowsMappedToDrbItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, false, 1)?;
        let qos_flow_identifier = QosFlowIdentifier::decode(data)?;
        let qos_flow_level_qos_parameters = QosFlowLevelQosParameters::decode(data)?;

        // Process the extension container
        let mut qos_flow_mapping_indication: Option<QosFlowMappingIndication> = None;
        let mut tsc_traffic_characteristics: Option<TscTrafficCharacteristics> = None;

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    183 => {
                        qos_flow_mapping_indication = Some(QosFlowMappingIndication::decode(data)?)
                    }
                    364 => {
                        tsc_traffic_characteristics = Some(TscTrafficCharacteristics::decode(data)?)
                    }
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            qos_flow_identifier,
            qos_flow_level_qos_parameters,
            qos_flow_mapping_indication,
            tsc_traffic_characteristics,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();
        if let Some(x) = &self.qos_flow_mapping_indication {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 183, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.tsc_traffic_characteristics {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 364, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        let mut optionals = BitString::new();
        optionals.push(num_ies != 0);

        encode::encode_sequence_header(data, false, &optionals, false)?;
        self.qos_flow_identifier.encode(data)?;
        self.qos_flow_level_qos_parameters.encode(data)?;
        if num_ies != 0 {
            encode::encode_length_determinent(data, Some(1), Some(65535), false, num_ies)?;
            data.append_aligned(ies);
        }
        Ok(())
    }
}

impl PerCodec for FlowsMappedToDrbItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        FlowsMappedToDrbItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("FlowsMappedToDrbItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("FlowsMappedToDrbItem");
            e
        })
    }
}
// Fr1Bandwidth
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum Fr1Bandwidth {
    Bw5,
    Bw10,
    Bw20,
    Bw40,
    Bw50,
    Bw80,
    Bw100,
    Bw160,
    Bw200,
    Bw15,
    Bw25,
    Bw30,
    Bw60,
    Bw35,
    Bw45,
    Bw70,
    Bw90,
}

impl Fr1Bandwidth {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(6), true)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(6),
            true,
            *self as i128,
            (*self as u32) >= 7,
        )
    }
}

impl PerCodec for Fr1Bandwidth {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Fr1Bandwidth::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("Fr1Bandwidth");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("Fr1Bandwidth");
            e
        })
    }
}
// Fr2Bandwidth
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum Fr2Bandwidth {
    Bw50,
    Bw100,
    Bw200,
    Bw400,
    Bw800,
    Bw1600,
    Bw2000,
    Bw600,
}

impl Fr2Bandwidth {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(3), true)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(3),
            true,
            *self as i128,
            (*self as u32) >= 4,
        )
    }
}

impl PerCodec for Fr2Bandwidth {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Fr2Bandwidth::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("Fr2Bandwidth");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("Fr2Bandwidth");
            e
        })
    }
}
// FreqBandNrItem
#[derive(Clone, Debug)]
pub struct FreqBandNrItem {
    pub freq_band_indicator_nr: u16,
    pub supported_sul_band_list: Vec<SupportedSulFreqBandItem>,
}

impl FreqBandNrItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let freq_band_indicator_nr =
            decode::decode_integer(data, Some(1), Some(1024), true)?.0 as u16;
        let supported_sul_band_list = {
            let length = decode::decode_length_determinent(data, Some(0), Some(32), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(SupportedSulFreqBandItem::decode(data)?);
            }
            items
        };

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            freq_band_indicator_nr,
            supported_sul_band_list,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        encode::encode_integer(
            data,
            Some(1),
            Some(1024),
            true,
            self.freq_band_indicator_nr as i128,
            false,
        )?;
        encode::encode_length_determinent(
            data,
            Some(0),
            Some(32),
            false,
            self.supported_sul_band_list.len(),
        )?;
        for x in &self.supported_sul_band_list {
            x.encode(data)?;
        }
        Ok(())?;

        Ok(())
    }
}

impl PerCodec for FreqBandNrItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        FreqBandNrItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("FreqBandNrItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("FreqBandNrItem");
            e
        })
    }
}
// FreqDomainLength
#[derive(Clone, Debug)]
pub enum FreqDomainLength {
    L839(L839Info),
    L139(L139Info),
    L571Info(L571Info),
    L1151Info(L1151Info),
}

impl FreqDomainLength {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_choice_idx(data, 0, 2, false)?;
        if extended {
            return Err(per_codec_error_new("CHOICE additions not implemented"));
        }
        match idx {
            0 => Ok(Self::L839(L839Info::decode(data)?)),
            1 => Ok(Self::L139(L139Info::decode(data)?)),
            2 => {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _ = Criticality::decode(data)?;
                let _ = decode::decode_length_determinent(data, None, None, false)?;
                let result = match id {
                    659 => Ok(Self::L571Info(L571Info::decode(data)?)),
                    660 => Ok(Self::L1151Info(L1151Info::decode(data)?)),
                    x => Err(per_codec_error_new(format!("Unrecognised IE type {}", x))),
                };
                data.decode_align()?;
                result
            }
            _ => Err(per_codec_error_new("Unknown choice idx")),
        }
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        match self {
            Self::L839(x) => {
                encode::encode_choice_idx(data, 0, 2, false, 0, false)?;
                x.encode(data)
            }
            Self::L139(x) => {
                encode::encode_choice_idx(data, 0, 2, false, 1, false)?;
                x.encode(data)
            }
            Self::L571Info(x) => {
                encode::encode_choice_idx(data, 0, 2, false, 2, false)?;
                encode::encode_integer(data, Some(0), Some(65535), false, 659, false)?;
                Criticality::Reject.encode(data)?;
                let ie = &mut Allocator::new_codec_data();
                x.encode(ie)?;
                encode::encode_length_determinent(data, None, None, false, ie.length_in_bytes())?;
                Ok(data.append_aligned(ie))
            }
            Self::L1151Info(x) => {
                encode::encode_choice_idx(data, 0, 2, false, 2, false)?;
                encode::encode_integer(data, Some(0), Some(65535), false, 660, false)?;
                Criticality::Reject.encode(data)?;
                let ie = &mut Allocator::new_codec_data();
                x.encode(ie)?;
                encode::encode_length_determinent(data, None, None, false, ie.length_in_bytes())?;
                Ok(data.append_aligned(ie))
            }
        }
    }
}

impl PerCodec for FreqDomainLength {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        FreqDomainLength::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("FreqDomainLength");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("FreqDomainLength");
            e
        })
    }
}
// FreqInfoRel16
#[derive(Clone, Debug)]
pub struct FreqInfoRel16 {
    pub nr_arfcn: Option<u32>,
    pub frequency_shift7p5khz: Option<FrequencyShift7p5khz>,
    pub carrier_list: Option<NrCarrierList>,
}

impl FreqInfoRel16 {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 4)?;
        let nr_arfcn = if optionals[0] {
            Some(decode::decode_integer(data, Some(0), Some(3279165), false)?.0 as u32)
        } else {
            None
        };
        let frequency_shift7p5khz = if optionals[1] {
            Some(FrequencyShift7p5khz::decode(data)?)
        } else {
            None
        };
        let carrier_list = if optionals[2] {
            Some(NrCarrierList::decode(data)?)
        } else {
            None
        };

        // Process the extension container

        if optionals[3] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            nr_arfcn,
            frequency_shift7p5khz,
            carrier_list,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.nr_arfcn.is_some());
        optionals.push(self.frequency_shift7p5khz.is_some());
        optionals.push(self.carrier_list.is_some());
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        if let Some(x) = &self.nr_arfcn {
            encode::encode_integer(data, Some(0), Some(3279165), false, *x as i128, false)?;
        }
        if let Some(x) = &self.frequency_shift7p5khz {
            x.encode(data)?;
        }
        if let Some(x) = &self.carrier_list {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl PerCodec for FreqInfoRel16 {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        FreqInfoRel16::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("FreqInfoRel16");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("FreqInfoRel16");
            e
        })
    }
}
// FrequencyShift7p5khz
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum FrequencyShift7p5khz {
    False,
    True,
}

impl FrequencyShift7p5khz {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(1), true)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(1),
            true,
            *self as i128,
            (*self as u32) >= 2,
        )
    }
}

impl PerCodec for FrequencyShift7p5khz {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        FrequencyShift7p5khz::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("FrequencyShift7p5khz");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("FrequencyShift7p5khz");
            e
        })
    }
}
// FrequencyDomainHsnaConfigurationList
#[derive(Clone, Debug)]
pub struct FrequencyDomainHsnaConfigurationList(pub NonEmpty<FrequencyDomainHsnaConfigurationItem>);

impl FrequencyDomainHsnaConfigurationList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(8), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(FrequencyDomainHsnaConfigurationItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(8), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for FrequencyDomainHsnaConfigurationList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        FrequencyDomainHsnaConfigurationList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("FrequencyDomainHsnaConfigurationList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("FrequencyDomainHsnaConfigurationList");
            e
        })
    }
}
// FrequencyDomainHsnaConfigurationItem
#[derive(Clone, Debug)]
pub struct FrequencyDomainHsnaConfigurationItem {
    pub rb_set_index: u8,
    pub frequency_domain_hsna_slot_configuration_list: FrequencyDomainHsnaSlotConfigurationList,
}

impl FrequencyDomainHsnaConfigurationItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, false, 1)?;
        let rb_set_index = decode::decode_integer(data, Some(0), Some(7), true)?.0 as u8;
        let frequency_domain_hsna_slot_configuration_list =
            FrequencyDomainHsnaSlotConfigurationList::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            rb_set_index,
            frequency_domain_hsna_slot_configuration_list,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, false, &optionals, false)?;
        encode::encode_integer(
            data,
            Some(0),
            Some(7),
            true,
            self.rb_set_index as i128,
            false,
        )?;
        self.frequency_domain_hsna_slot_configuration_list
            .encode(data)?;

        Ok(())
    }
}

impl PerCodec for FrequencyDomainHsnaConfigurationItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        FrequencyDomainHsnaConfigurationItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("FrequencyDomainHsnaConfigurationItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("FrequencyDomainHsnaConfigurationItem");
            e
        })
    }
}
// FrequencyDomainHsnaSlotConfigurationList
#[derive(Clone, Debug)]
pub struct FrequencyDomainHsnaSlotConfigurationList(
    pub NonEmpty<FrequencyDomainHsnaSlotConfigurationItem>,
);

impl FrequencyDomainHsnaSlotConfigurationList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(5120), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(FrequencyDomainHsnaSlotConfigurationItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(5120), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for FrequencyDomainHsnaSlotConfigurationList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        FrequencyDomainHsnaSlotConfigurationList::decode_inner(data).map_err(
            |mut e: PerCodecError| {
                e.push_context("FrequencyDomainHsnaSlotConfigurationList");
                e
            },
        )
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("FrequencyDomainHsnaSlotConfigurationList");
            e
        })
    }
}
// FrequencyDomainHsnaSlotConfigurationItem
#[derive(Clone, Debug)]
pub struct FrequencyDomainHsnaSlotConfigurationItem {
    pub slot_index: Option<u16>,
    pub hsna_downlink: Option<HsnaDownlink>,
    pub hsna_uplink: Option<HsnaUplink>,
    pub hsna_flexible: Option<HsnaFlexible>,
}

impl FrequencyDomainHsnaSlotConfigurationItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, false, 5)?;
        let slot_index = if optionals[0] {
            Some(decode::decode_integer(data, Some(0), Some(5119), false)?.0 as u16)
        } else {
            None
        };
        let hsna_downlink = if optionals[1] {
            Some(HsnaDownlink::decode(data)?)
        } else {
            None
        };
        let hsna_uplink = if optionals[2] {
            Some(HsnaUplink::decode(data)?)
        } else {
            None
        };
        let hsna_flexible = if optionals[3] {
            Some(HsnaFlexible::decode(data)?)
        } else {
            None
        };

        // Process the extension container

        if optionals[4] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            slot_index,
            hsna_downlink,
            hsna_uplink,
            hsna_flexible,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.slot_index.is_some());
        optionals.push(self.hsna_downlink.is_some());
        optionals.push(self.hsna_uplink.is_some());
        optionals.push(self.hsna_flexible.is_some());
        optionals.push(false);

        encode::encode_sequence_header(data, false, &optionals, false)?;
        if let Some(x) = &self.slot_index {
            encode::encode_integer(data, Some(0), Some(5119), false, *x as i128, false)?;
        }
        if let Some(x) = &self.hsna_downlink {
            x.encode(data)?;
        }
        if let Some(x) = &self.hsna_uplink {
            x.encode(data)?;
        }
        if let Some(x) = &self.hsna_flexible {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl PerCodec for FrequencyDomainHsnaSlotConfigurationItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        FrequencyDomainHsnaSlotConfigurationItem::decode_inner(data).map_err(
            |mut e: PerCodecError| {
                e.push_context("FrequencyDomainHsnaSlotConfigurationItem");
                e
            },
        )
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("FrequencyDomainHsnaSlotConfigurationItem");
            e
        })
    }
}
// FullConfiguration
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum FullConfiguration {
    Full,
}

impl FullConfiguration {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(0), true)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(0),
            true,
            *self as i128,
            (*self as u32) >= 1,
        )
    }
}

impl PerCodec for FullConfiguration {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        FullConfiguration::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("FullConfiguration");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("FullConfiguration");
            e
        })
    }
}
// FlowsMappedToSlDrbList
#[derive(Clone, Debug)]
pub struct FlowsMappedToSlDrbList(pub NonEmpty<FlowsMappedToSlDrbItem>);

impl FlowsMappedToSlDrbList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(2048), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(FlowsMappedToSlDrbItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(2048), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for FlowsMappedToSlDrbList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        FlowsMappedToSlDrbList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("FlowsMappedToSlDrbList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("FlowsMappedToSlDrbList");
            e
        })
    }
}
// FlowsMappedToSlDrbItem
#[derive(Clone, Debug)]
pub struct FlowsMappedToSlDrbItem {
    pub pc_5_qos_flow_identifier: Pc5QosFlowIdentifier,
}

impl FlowsMappedToSlDrbItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let pc_5_qos_flow_identifier = Pc5QosFlowIdentifier::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            pc_5_qos_flow_identifier,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.pc_5_qos_flow_identifier.encode(data)?;

        Ok(())
    }
}

impl PerCodec for FlowsMappedToSlDrbItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        FlowsMappedToSlDrbItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("FlowsMappedToSlDrbItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("FlowsMappedToSlDrbItem");
            e
        })
    }
}
// GbrQosInformation
#[derive(Clone, Debug)]
pub struct GbrQosInformation {
    pub e_rab_maximum_bitrate_dl: BitRate,
    pub e_rab_maximum_bitrate_ul: BitRate,
    pub e_rab_guaranteed_bitrate_dl: BitRate,
    pub e_rab_guaranteed_bitrate_ul: BitRate,
}

impl GbrQosInformation {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let e_rab_maximum_bitrate_dl = BitRate::decode(data)?;
        let e_rab_maximum_bitrate_ul = BitRate::decode(data)?;
        let e_rab_guaranteed_bitrate_dl = BitRate::decode(data)?;
        let e_rab_guaranteed_bitrate_ul = BitRate::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            e_rab_maximum_bitrate_dl,
            e_rab_maximum_bitrate_ul,
            e_rab_guaranteed_bitrate_dl,
            e_rab_guaranteed_bitrate_ul,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.e_rab_maximum_bitrate_dl.encode(data)?;
        self.e_rab_maximum_bitrate_ul.encode(data)?;
        self.e_rab_guaranteed_bitrate_dl.encode(data)?;
        self.e_rab_guaranteed_bitrate_ul.encode(data)?;

        Ok(())
    }
}

impl PerCodec for GbrQosInformation {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        GbrQosInformation::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("GbrQosInformation");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("GbrQosInformation");
            e
        })
    }
}
// GbrQosFlowInformation
#[derive(Clone, Debug)]
pub struct GbrQosFlowInformation {
    pub max_flow_bit_rate_downlink: BitRate,
    pub max_flow_bit_rate_uplink: BitRate,
    pub guaranteed_flow_bit_rate_downlink: BitRate,
    pub guaranteed_flow_bit_rate_uplink: BitRate,
    pub max_packet_loss_rate_downlink: Option<MaxPacketLossRate>,
    pub max_packet_loss_rate_uplink: Option<MaxPacketLossRate>,
    pub alternative_qos_para_set_list: Option<AlternativeQosParaSetList>,
}

impl GbrQosFlowInformation {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 3)?;
        let max_flow_bit_rate_downlink = BitRate::decode(data)?;
        let max_flow_bit_rate_uplink = BitRate::decode(data)?;
        let guaranteed_flow_bit_rate_downlink = BitRate::decode(data)?;
        let guaranteed_flow_bit_rate_uplink = BitRate::decode(data)?;
        let max_packet_loss_rate_downlink = if optionals[0] {
            Some(MaxPacketLossRate::decode(data)?)
        } else {
            None
        };
        let max_packet_loss_rate_uplink = if optionals[1] {
            Some(MaxPacketLossRate::decode(data)?)
        } else {
            None
        };

        // Process the extension container
        let mut alternative_qos_para_set_list: Option<AlternativeQosParaSetList> = None;

        if optionals[2] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    343 => {
                        alternative_qos_para_set_list =
                            Some(AlternativeQosParaSetList::decode(data)?)
                    }
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            max_flow_bit_rate_downlink,
            max_flow_bit_rate_uplink,
            guaranteed_flow_bit_rate_downlink,
            guaranteed_flow_bit_rate_uplink,
            max_packet_loss_rate_downlink,
            max_packet_loss_rate_uplink,
            alternative_qos_para_set_list,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();
        if let Some(x) = &self.alternative_qos_para_set_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 343, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        let mut optionals = BitString::new();
        optionals.push(self.max_packet_loss_rate_downlink.is_some());
        optionals.push(self.max_packet_loss_rate_uplink.is_some());
        optionals.push(num_ies != 0);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.max_flow_bit_rate_downlink.encode(data)?;
        self.max_flow_bit_rate_uplink.encode(data)?;
        self.guaranteed_flow_bit_rate_downlink.encode(data)?;
        self.guaranteed_flow_bit_rate_uplink.encode(data)?;
        if let Some(x) = &self.max_packet_loss_rate_downlink {
            x.encode(data)?;
        }
        if let Some(x) = &self.max_packet_loss_rate_uplink {
            x.encode(data)?;
        }
        if num_ies != 0 {
            encode::encode_length_determinent(data, Some(1), Some(65535), false, num_ies)?;
            data.append_aligned(ies);
        }
        Ok(())
    }
}

impl PerCodec for GbrQosFlowInformation {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        GbrQosFlowInformation::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("GbrQosFlowInformation");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("GbrQosFlowInformation");
            e
        })
    }
}
// CgConfig
#[derive(Clone, Debug)]
pub struct CgConfig(pub Vec<u8>);

impl CgConfig {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(decode::decode_octetstring(data, None, None, false)?))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_octetstring(data, None, None, false, &self.0, false)
    }
}

impl PerCodec for CgConfig {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        CgConfig::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CgConfig");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CgConfig");
            e
        })
    }
}
// GeographicalCoordinates
#[derive(Clone, Debug)]
pub struct GeographicalCoordinates {
    pub trp_position_definition_type: TrpPositionDefinitionType,
    pub dlprs_resource_coordinates: Option<DlprsResourceCoordinates>,
    pub arp_location_info: Option<ArpLocationInformation>,
}

impl GeographicalCoordinates {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, false, 2)?;
        let trp_position_definition_type = TrpPositionDefinitionType::decode(data)?;
        let dlprs_resource_coordinates = if optionals[0] {
            Some(DlprsResourceCoordinates::decode(data)?)
        } else {
            None
        };

        // Process the extension container
        let mut arp_location_info: Option<ArpLocationInformation> = None;

        if optionals[1] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    556 => arp_location_info = Some(ArpLocationInformation::decode(data)?),
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            trp_position_definition_type,
            dlprs_resource_coordinates,
            arp_location_info,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();
        if let Some(x) = &self.arp_location_info {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 556, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        let mut optionals = BitString::new();
        optionals.push(self.dlprs_resource_coordinates.is_some());
        optionals.push(num_ies != 0);

        encode::encode_sequence_header(data, false, &optionals, false)?;
        self.trp_position_definition_type.encode(data)?;
        if let Some(x) = &self.dlprs_resource_coordinates {
            x.encode(data)?;
        }
        if num_ies != 0 {
            encode::encode_length_determinent(data, Some(1), Some(65535), false, num_ies)?;
            data.append_aligned(ies);
        }
        Ok(())
    }
}

impl PerCodec for GeographicalCoordinates {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        GeographicalCoordinates::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("GeographicalCoordinates");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("GeographicalCoordinates");
            e
        })
    }
}
// GlobalGnbId
#[derive(Clone, Debug)]
pub struct GlobalGnbId {
    pub plmn_identity: PlmnIdentity,
    pub gnb_id: GnbId,
}

impl GlobalGnbId {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let plmn_identity = PlmnIdentity::decode(data)?;
        let gnb_id = GnbId::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            plmn_identity,
            gnb_id,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.plmn_identity.encode(data)?;
        self.gnb_id.encode(data)?;

        Ok(())
    }
}

impl PerCodec for GlobalGnbId {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        GlobalGnbId::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("GlobalGnbId");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("GlobalGnbId");
            e
        })
    }
}
// GnbId
#[derive(Clone, Debug)]
pub enum GnbId {
    GnbId(BitString),
}

impl GnbId {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_choice_idx(data, 0, 1, false)?;
        if extended {
            return Err(per_codec_error_new("CHOICE additions not implemented"));
        }
        match idx {
            0 => Ok(Self::GnbId(decode::decode_bitstring(
                data,
                Some(22),
                Some(32),
                false,
            )?)),
            1 => {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _ = Criticality::decode(data)?;
                let _ = decode::decode_length_determinent(data, None, None, false)?;
                let result = match id {
                    x => Err(per_codec_error_new(format!("Unrecognised IE type {}", x))),
                };
                data.decode_align()?;
                result
            }
            _ => Err(per_codec_error_new("Unknown choice idx")),
        }
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        match self {
            Self::GnbId(x) => {
                encode::encode_choice_idx(data, 0, 1, false, 0, false)?;
                encode::encode_bitstring(data, Some(22), Some(32), false, &x, false)
            }
        }
    }
}

impl PerCodec for GnbId {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        GnbId::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("GnbId");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("GnbId");
            e
        })
    }
}
// GnbCuMbsF1apId
#[derive(Clone, Copy, Debug)]
pub struct GnbCuMbsF1apId(pub u32);

impl GnbCuMbsF1apId {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(
            decode::decode_integer(data, Some(0), Some(4294967295), false)?.0 as u32,
        ))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_integer(
            data,
            Some(0),
            Some(4294967295),
            false,
            self.0 as i128,
            false,
        )
    }
}

impl PerCodec for GnbCuMbsF1apId {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        GnbCuMbsF1apId::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("GnbCuMbsF1apId");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("GnbCuMbsF1apId");
            e
        })
    }
}
// GnbCuMeasurementId
#[derive(Clone, Copy, Debug)]
pub struct GnbCuMeasurementId(pub u16);

impl GnbCuMeasurementId {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(
            decode::decode_integer(data, Some(0), Some(4095), true)?.0 as u16,
        ))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_integer(data, Some(0), Some(4095), true, self.0 as i128, false)
    }
}

impl PerCodec for GnbCuMeasurementId {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        GnbCuMeasurementId::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("GnbCuMeasurementId");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("GnbCuMeasurementId");
            e
        })
    }
}
// GnbDuMeasurementId
#[derive(Clone, Copy, Debug)]
pub struct GnbDuMeasurementId(pub u16);

impl GnbDuMeasurementId {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(
            decode::decode_integer(data, Some(0), Some(4095), true)?.0 as u16,
        ))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_integer(data, Some(0), Some(4095), true, self.0 as i128, false)
    }
}

impl PerCodec for GnbDuMeasurementId {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        GnbDuMeasurementId::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("GnbDuMeasurementId");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("GnbDuMeasurementId");
            e
        })
    }
}
// GnbCuSystemInformation
#[derive(Clone, Debug)]
pub struct GnbCuSystemInformation {
    pub sib_type_to_be_updated_list: NonEmpty<SibTypeToBeUpdatedListItem>,
    pub system_information_area_id: Option<SystemInformationAreaId>,
}

impl GnbCuSystemInformation {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let sib_type_to_be_updated_list = {
            let length = decode::decode_length_determinent(data, Some(1), Some(32), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(SibTypeToBeUpdatedListItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        };

        // Process the extension container
        let mut system_information_area_id: Option<SystemInformationAreaId> = None;

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    239 => {
                        system_information_area_id = Some(SystemInformationAreaId::decode(data)?)
                    }
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            sib_type_to_be_updated_list,
            system_information_area_id,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();
        if let Some(x) = &self.system_information_area_id {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 239, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        let mut optionals = BitString::new();
        optionals.push(num_ies != 0);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        encode::encode_length_determinent(
            data,
            Some(1),
            Some(32),
            false,
            self.sib_type_to_be_updated_list.len(),
        )?;
        for x in &self.sib_type_to_be_updated_list {
            x.encode(data)?;
        }
        Ok(())?;
        if num_ies != 0 {
            encode::encode_length_determinent(data, Some(1), Some(65535), false, num_ies)?;
            data.append_aligned(ies);
        }
        Ok(())
    }
}

impl PerCodec for GnbCuSystemInformation {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        GnbCuSystemInformation::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("GnbCuSystemInformation");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("GnbCuSystemInformation");
            e
        })
    }
}
// GnbCuTnlAssociationSetupItem
#[derive(Clone, Debug)]
pub struct GnbCuTnlAssociationSetupItem {
    pub tnl_association_transport_layer_address: CpTransportLayerAddress,
}

impl GnbCuTnlAssociationSetupItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, false, 1)?;
        let tnl_association_transport_layer_address = CpTransportLayerAddress::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            tnl_association_transport_layer_address,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, false, &optionals, false)?;
        self.tnl_association_transport_layer_address.encode(data)?;

        Ok(())
    }
}

impl PerCodec for GnbCuTnlAssociationSetupItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        GnbCuTnlAssociationSetupItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("GnbCuTnlAssociationSetupItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("GnbCuTnlAssociationSetupItem");
            e
        })
    }
}
// GnbCuTnlAssociationFailedToSetupItem
#[derive(Clone, Debug)]
pub struct GnbCuTnlAssociationFailedToSetupItem {
    pub tnl_association_transport_layer_address: CpTransportLayerAddress,
    pub cause: Cause,
}

impl GnbCuTnlAssociationFailedToSetupItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, false, 1)?;
        let tnl_association_transport_layer_address = CpTransportLayerAddress::decode(data)?;
        let cause = Cause::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            tnl_association_transport_layer_address,
            cause,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, false, &optionals, false)?;
        self.tnl_association_transport_layer_address.encode(data)?;
        self.cause.encode(data)?;

        Ok(())
    }
}

impl PerCodec for GnbCuTnlAssociationFailedToSetupItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        GnbCuTnlAssociationFailedToSetupItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("GnbCuTnlAssociationFailedToSetupItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("GnbCuTnlAssociationFailedToSetupItem");
            e
        })
    }
}
// GnbCuTnlAssociationToAddItem
#[derive(Clone, Debug)]
pub struct GnbCuTnlAssociationToAddItem {
    pub tnl_association_transport_layer_address: CpTransportLayerAddress,
    pub tnl_association_usage: TnlAssociationUsage,
}

impl GnbCuTnlAssociationToAddItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, false, 1)?;
        let tnl_association_transport_layer_address = CpTransportLayerAddress::decode(data)?;
        let tnl_association_usage = TnlAssociationUsage::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            tnl_association_transport_layer_address,
            tnl_association_usage,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, false, &optionals, false)?;
        self.tnl_association_transport_layer_address.encode(data)?;
        self.tnl_association_usage.encode(data)?;

        Ok(())
    }
}

impl PerCodec for GnbCuTnlAssociationToAddItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        GnbCuTnlAssociationToAddItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("GnbCuTnlAssociationToAddItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("GnbCuTnlAssociationToAddItem");
            e
        })
    }
}
// GnbCuTnlAssociationToRemoveItem
#[derive(Clone, Debug)]
pub struct GnbCuTnlAssociationToRemoveItem {
    pub tnl_association_transport_layer_address: CpTransportLayerAddress,
    pub tnl_association_transport_layer_address_gnb_du: Option<CpTransportLayerAddress>,
}

impl GnbCuTnlAssociationToRemoveItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, false, 1)?;
        let tnl_association_transport_layer_address = CpTransportLayerAddress::decode(data)?;

        // Process the extension container
        let mut tnl_association_transport_layer_address_gnb_du: Option<CpTransportLayerAddress> =
            None;

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    229 => {
                        tnl_association_transport_layer_address_gnb_du =
                            Some(CpTransportLayerAddress::decode(data)?)
                    }
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            tnl_association_transport_layer_address,
            tnl_association_transport_layer_address_gnb_du,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();
        if let Some(x) = &self.tnl_association_transport_layer_address_gnb_du {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 229, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        let mut optionals = BitString::new();
        optionals.push(num_ies != 0);

        encode::encode_sequence_header(data, false, &optionals, false)?;
        self.tnl_association_transport_layer_address.encode(data)?;
        if num_ies != 0 {
            encode::encode_length_determinent(data, Some(1), Some(65535), false, num_ies)?;
            data.append_aligned(ies);
        }
        Ok(())
    }
}

impl PerCodec for GnbCuTnlAssociationToRemoveItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        GnbCuTnlAssociationToRemoveItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("GnbCuTnlAssociationToRemoveItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("GnbCuTnlAssociationToRemoveItem");
            e
        })
    }
}
// GnbCuTnlAssociationToUpdateItem
#[derive(Clone, Debug)]
pub struct GnbCuTnlAssociationToUpdateItem {
    pub tnl_association_transport_layer_address: CpTransportLayerAddress,
    pub tnl_association_usage: Option<TnlAssociationUsage>,
}

impl GnbCuTnlAssociationToUpdateItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, false, 2)?;
        let tnl_association_transport_layer_address = CpTransportLayerAddress::decode(data)?;
        let tnl_association_usage = if optionals[0] {
            Some(TnlAssociationUsage::decode(data)?)
        } else {
            None
        };

        // Process the extension container

        if optionals[1] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            tnl_association_transport_layer_address,
            tnl_association_usage,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.tnl_association_usage.is_some());
        optionals.push(false);

        encode::encode_sequence_header(data, false, &optionals, false)?;
        self.tnl_association_transport_layer_address.encode(data)?;
        if let Some(x) = &self.tnl_association_usage {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl PerCodec for GnbCuTnlAssociationToUpdateItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        GnbCuTnlAssociationToUpdateItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("GnbCuTnlAssociationToUpdateItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("GnbCuTnlAssociationToUpdateItem");
            e
        })
    }
}
// GnbCuUeF1apId
#[derive(Clone, Copy, Debug)]
pub struct GnbCuUeF1apId(pub u32);

impl GnbCuUeF1apId {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(
            decode::decode_integer(data, Some(0), Some(4294967295), false)?.0 as u32,
        ))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_integer(
            data,
            Some(0),
            Some(4294967295),
            false,
            self.0 as i128,
            false,
        )
    }
}

impl PerCodec for GnbCuUeF1apId {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        GnbCuUeF1apId::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("GnbCuUeF1apId");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("GnbCuUeF1apId");
            e
        })
    }
}
// GnbDuCellResourceConfiguration
#[derive(Clone, Debug)]
pub struct GnbDuCellResourceConfiguration {
    pub subcarrier_spacing: SubcarrierSpacing,
    pub du_f_transmission_periodicity: Option<DuFTransmissionPeriodicity>,
    pub du_f_slot_config_list: Option<DuFSlotConfigList>,
    pub hsna_transmission_periodicity: HsnaTransmissionPeriodicity,
    pub hs_nsa_slot_config_list: Option<HsnaSlotConfigList>,
    pub rb_set_configuration: Option<RbSetConfiguration>,
    pub frequency_domain_hsna_configuration_list: Option<FrequencyDomainHsnaConfigurationList>,
    pub child_iab_nodes_na_resource_list: Option<ChildIabNodesNaResourceList>,
    pub parent_iab_nodes_na_resource_configuration_list:
        Option<ParentIabNodesNaResourceConfigurationList>,
}

impl GnbDuCellResourceConfiguration {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, false, 4)?;
        let subcarrier_spacing = SubcarrierSpacing::decode(data)?;
        let du_f_transmission_periodicity = if optionals[0] {
            Some(DuFTransmissionPeriodicity::decode(data)?)
        } else {
            None
        };
        let du_f_slot_config_list = if optionals[1] {
            Some(DuFSlotConfigList::decode(data)?)
        } else {
            None
        };
        let hsna_transmission_periodicity = HsnaTransmissionPeriodicity::decode(data)?;
        let hs_nsa_slot_config_list = if optionals[2] {
            Some(HsnaSlotConfigList::decode(data)?)
        } else {
            None
        };

        // Process the extension container
        let mut rb_set_configuration: Option<RbSetConfiguration> = None;
        let mut frequency_domain_hsna_configuration_list: Option<
            FrequencyDomainHsnaConfigurationList,
        > = None;
        let mut child_iab_nodes_na_resource_list: Option<ChildIabNodesNaResourceList> = None;
        let mut parent_iab_nodes_na_resource_configuration_list: Option<
            ParentIabNodesNaResourceConfigurationList,
        > = None;

        if optionals[3] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    520 => rb_set_configuration = Some(RbSetConfiguration::decode(data)?),
                    521 => {
                        frequency_domain_hsna_configuration_list =
                            Some(FrequencyDomainHsnaConfigurationList::decode(data)?)
                    }
                    522 => {
                        child_iab_nodes_na_resource_list =
                            Some(ChildIabNodesNaResourceList::decode(data)?)
                    }
                    523 => {
                        parent_iab_nodes_na_resource_configuration_list =
                            Some(ParentIabNodesNaResourceConfigurationList::decode(data)?)
                    }
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            subcarrier_spacing,
            du_f_transmission_periodicity,
            du_f_slot_config_list,
            hsna_transmission_periodicity,
            hs_nsa_slot_config_list,
            rb_set_configuration,
            frequency_domain_hsna_configuration_list,
            child_iab_nodes_na_resource_list,
            parent_iab_nodes_na_resource_configuration_list,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();
        if let Some(x) = &self.rb_set_configuration {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 520, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.frequency_domain_hsna_configuration_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 521, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.child_iab_nodes_na_resource_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 522, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.parent_iab_nodes_na_resource_configuration_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 523, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        let mut optionals = BitString::new();
        optionals.push(self.du_f_transmission_periodicity.is_some());
        optionals.push(self.du_f_slot_config_list.is_some());
        optionals.push(self.hs_nsa_slot_config_list.is_some());
        optionals.push(num_ies != 0);

        encode::encode_sequence_header(data, false, &optionals, false)?;
        self.subcarrier_spacing.encode(data)?;
        if let Some(x) = &self.du_f_transmission_periodicity {
            x.encode(data)?;
        }
        if let Some(x) = &self.du_f_slot_config_list {
            x.encode(data)?;
        }
        self.hsna_transmission_periodicity.encode(data)?;
        if let Some(x) = &self.hs_nsa_slot_config_list {
            x.encode(data)?;
        }
        if num_ies != 0 {
            encode::encode_length_determinent(data, Some(1), Some(65535), false, num_ies)?;
            data.append_aligned(ies);
        }
        Ok(())
    }
}

impl PerCodec for GnbDuCellResourceConfiguration {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        GnbDuCellResourceConfiguration::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("GnbDuCellResourceConfiguration");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("GnbDuCellResourceConfiguration");
            e
        })
    }
}
// GnbDuMbsF1apId
#[derive(Clone, Copy, Debug)]
pub struct GnbDuMbsF1apId(pub u32);

impl GnbDuMbsF1apId {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(
            decode::decode_integer(data, Some(0), Some(4294967295), false)?.0 as u32,
        ))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_integer(
            data,
            Some(0),
            Some(4294967295),
            false,
            self.0 as i128,
            false,
        )
    }
}

impl PerCodec for GnbDuMbsF1apId {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        GnbDuMbsF1apId::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("GnbDuMbsF1apId");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("GnbDuMbsF1apId");
            e
        })
    }
}
// GnbDuUeF1apId
#[derive(Clone, Copy, Debug)]
pub struct GnbDuUeF1apId(pub u32);

impl GnbDuUeF1apId {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(
            decode::decode_integer(data, Some(0), Some(4294967295), false)?.0 as u32,
        ))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_integer(
            data,
            Some(0),
            Some(4294967295),
            false,
            self.0 as i128,
            false,
        )
    }
}

impl PerCodec for GnbDuUeF1apId {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        GnbDuUeF1apId::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("GnbDuUeF1apId");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("GnbDuUeF1apId");
            e
        })
    }
}
// GnbDuId
#[derive(Clone, Copy, Debug)]
pub struct GnbDuId(pub u64);

impl GnbDuId {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(
            decode::decode_integer(data, Some(0), Some(68719476735), false)?.0 as u64,
        ))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_integer(
            data,
            Some(0),
            Some(68719476735),
            false,
            self.0 as i128,
            false,
        )
    }
}

impl PerCodec for GnbDuId {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        GnbDuId::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("GnbDuId");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("GnbDuId");
            e
        })
    }
}
// GnbCuName
#[derive(Clone, Debug)]
pub struct GnbCuName(pub String);

impl GnbCuName {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(decode::decode_printable_string(
            data,
            Some(1),
            Some(150),
            true,
        )?))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_printable_string(data, Some(1), Some(150), true, &self.0, false)
    }
}

impl PerCodec for GnbCuName {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        GnbCuName::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("GnbCuName");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("GnbCuName");
            e
        })
    }
}
// GnbDuName
#[derive(Clone, Debug)]
pub struct GnbDuName(pub String);

impl GnbDuName {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(decode::decode_printable_string(
            data,
            Some(1),
            Some(150),
            true,
        )?))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_printable_string(data, Some(1), Some(150), true, &self.0, false)
    }
}

impl PerCodec for GnbDuName {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        GnbDuName::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("GnbDuName");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("GnbDuName");
            e
        })
    }
}
// ExtendedGnbCuName
#[derive(Clone, Debug)]
pub struct ExtendedGnbCuName {
    pub gnb_cu_name_visible_string: Option<GnbCuNameVisibleString>,
    pub gnb_cu_name_utf8_string: Option<GnbCuNameUtf8String>,
}

impl ExtendedGnbCuName {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 3)?;
        let gnb_cu_name_visible_string = if optionals[0] {
            Some(GnbCuNameVisibleString::decode(data)?)
        } else {
            None
        };
        let gnb_cu_name_utf8_string = if optionals[1] {
            Some(GnbCuNameUtf8String::decode(data)?)
        } else {
            None
        };

        // Process the extension container

        if optionals[2] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            gnb_cu_name_visible_string,
            gnb_cu_name_utf8_string,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.gnb_cu_name_visible_string.is_some());
        optionals.push(self.gnb_cu_name_utf8_string.is_some());
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        if let Some(x) = &self.gnb_cu_name_visible_string {
            x.encode(data)?;
        }
        if let Some(x) = &self.gnb_cu_name_utf8_string {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl PerCodec for ExtendedGnbCuName {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        ExtendedGnbCuName::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ExtendedGnbCuName");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ExtendedGnbCuName");
            e
        })
    }
}
// GnbCuNameVisibleString
#[derive(Clone, Debug)]
pub struct GnbCuNameVisibleString(pub String);

impl GnbCuNameVisibleString {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(decode::decode_visible_string(
            data,
            Some(1),
            Some(150),
            true,
        )?))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_visible_string(data, Some(1), Some(150), true, &self.0, false)
    }
}

impl PerCodec for GnbCuNameVisibleString {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        GnbCuNameVisibleString::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("GnbCuNameVisibleString");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("GnbCuNameVisibleString");
            e
        })
    }
}
// GnbCuNameUtf8String
#[derive(Clone, Debug)]
pub struct GnbCuNameUtf8String(pub String);

impl GnbCuNameUtf8String {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(decode::decode_utf8_string(
            data,
            Some(1),
            Some(150),
            true,
        )?))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_utf8_string(data, Some(1), Some(150), true, &self.0, false)
    }
}

impl PerCodec for GnbCuNameUtf8String {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        GnbCuNameUtf8String::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("GnbCuNameUtf8String");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("GnbCuNameUtf8String");
            e
        })
    }
}
// ExtendedGnbDuName
#[derive(Clone, Debug)]
pub struct ExtendedGnbDuName {
    pub gnb_du_name_visible_string: Option<GnbDuNameVisibleString>,
    pub gnb_du_name_utf8_string: Option<GnbDuNameUtf8String>,
}

impl ExtendedGnbDuName {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 3)?;
        let gnb_du_name_visible_string = if optionals[0] {
            Some(GnbDuNameVisibleString::decode(data)?)
        } else {
            None
        };
        let gnb_du_name_utf8_string = if optionals[1] {
            Some(GnbDuNameUtf8String::decode(data)?)
        } else {
            None
        };

        // Process the extension container

        if optionals[2] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            gnb_du_name_visible_string,
            gnb_du_name_utf8_string,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.gnb_du_name_visible_string.is_some());
        optionals.push(self.gnb_du_name_utf8_string.is_some());
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        if let Some(x) = &self.gnb_du_name_visible_string {
            x.encode(data)?;
        }
        if let Some(x) = &self.gnb_du_name_utf8_string {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl PerCodec for ExtendedGnbDuName {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        ExtendedGnbDuName::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ExtendedGnbDuName");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ExtendedGnbDuName");
            e
        })
    }
}
// GnbDuNameVisibleString
#[derive(Clone, Debug)]
pub struct GnbDuNameVisibleString(pub String);

impl GnbDuNameVisibleString {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(decode::decode_visible_string(
            data,
            Some(1),
            Some(150),
            true,
        )?))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_visible_string(data, Some(1), Some(150), true, &self.0, false)
    }
}

impl PerCodec for GnbDuNameVisibleString {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        GnbDuNameVisibleString::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("GnbDuNameVisibleString");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("GnbDuNameVisibleString");
            e
        })
    }
}
// GnbDuNameUtf8String
#[derive(Clone, Debug)]
pub struct GnbDuNameUtf8String(pub String);

impl GnbDuNameUtf8String {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(decode::decode_utf8_string(
            data,
            Some(1),
            Some(150),
            true,
        )?))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_utf8_string(data, Some(1), Some(150), true, &self.0, false)
    }
}

impl PerCodec for GnbDuNameUtf8String {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        GnbDuNameUtf8String::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("GnbDuNameUtf8String");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("GnbDuNameUtf8String");
            e
        })
    }
}
// GnbDuServedCellsItem
#[derive(Clone, Debug)]
pub struct GnbDuServedCellsItem {
    pub served_cell_information: ServedCellInformation,
    pub gnb_du_system_information: Option<GnbDuSystemInformation>,
}

impl GnbDuServedCellsItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 2)?;
        let served_cell_information = ServedCellInformation::decode(data)?;
        let gnb_du_system_information = if optionals[0] {
            Some(GnbDuSystemInformation::decode(data)?)
        } else {
            None
        };

        // Process the extension container

        if optionals[1] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            served_cell_information,
            gnb_du_system_information,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.gnb_du_system_information.is_some());
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.served_cell_information.encode(data)?;
        if let Some(x) = &self.gnb_du_system_information {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl PerCodec for GnbDuServedCellsItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        GnbDuServedCellsItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("GnbDuServedCellsItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("GnbDuServedCellsItem");
            e
        })
    }
}
// GnbDuSystemInformation
#[derive(Clone, Debug)]
pub struct GnbDuSystemInformation {
    pub mib_message: MibMessage,
    pub sib_1_message: Sib1Message,
    pub sib_12_message: Option<Sib12Message>,
    pub sib_13_message: Option<Sib13Message>,
    pub sib_14_message: Option<Sib14Message>,
    pub sib_10_message: Option<Sib10Message>,
    pub sib_17_message: Option<Sib17Message>,
    pub sib_20_message: Option<Sib20Message>,
    pub sib_15_message: Option<Sib15Message>,
    pub sib_24_message: Option<Sib24Message>,
    pub sib_22_message: Option<Sib22Message>,
    pub sib_23_message: Option<Sib23Message>,
    pub sib_17bis_message: Option<Sib17bisMessage>,
}

impl GnbDuSystemInformation {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let mib_message = MibMessage::decode(data)?;
        let sib_1_message = Sib1Message::decode(data)?;

        // Process the extension container
        let mut sib_12_message: Option<Sib12Message> = None;
        let mut sib_13_message: Option<Sib13Message> = None;
        let mut sib_14_message: Option<Sib14Message> = None;
        let mut sib_10_message: Option<Sib10Message> = None;
        let mut sib_17_message: Option<Sib17Message> = None;
        let mut sib_20_message: Option<Sib20Message> = None;
        let mut sib_15_message: Option<Sib15Message> = None;
        let mut sib_24_message: Option<Sib24Message> = None;
        let mut sib_22_message: Option<Sib22Message> = None;
        let mut sib_23_message: Option<Sib23Message> = None;
        let mut sib_17bis_message: Option<Sib17bisMessage> = None;

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    310 => sib_12_message = Some(Sib12Message::decode(data)?),
                    311 => sib_13_message = Some(Sib13Message::decode(data)?),
                    312 => sib_14_message = Some(Sib14Message::decode(data)?),
                    387 => sib_10_message = Some(Sib10Message::decode(data)?),
                    625 => sib_17_message = Some(Sib17Message::decode(data)?),
                    627 => sib_20_message = Some(Sib20Message::decode(data)?),
                    648 => sib_15_message = Some(Sib15Message::decode(data)?),
                    773 => sib_24_message = Some(Sib24Message::decode(data)?),
                    797 => sib_22_message = Some(Sib22Message::decode(data)?),
                    848 => sib_23_message = Some(Sib23Message::decode(data)?),
                    850 => sib_17bis_message = Some(Sib17bisMessage::decode(data)?),
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            mib_message,
            sib_1_message,
            sib_12_message,
            sib_13_message,
            sib_14_message,
            sib_10_message,
            sib_17_message,
            sib_20_message,
            sib_15_message,
            sib_24_message,
            sib_22_message,
            sib_23_message,
            sib_17bis_message,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();
        if let Some(x) = &self.sib_12_message {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 310, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.sib_13_message {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 311, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.sib_14_message {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 312, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.sib_10_message {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 387, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.sib_17_message {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 625, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.sib_20_message {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 627, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.sib_15_message {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 648, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.sib_24_message {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 773, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.sib_22_message {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 797, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.sib_23_message {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 848, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.sib_17bis_message {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 850, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        let mut optionals = BitString::new();
        optionals.push(num_ies != 0);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.mib_message.encode(data)?;
        self.sib_1_message.encode(data)?;
        if num_ies != 0 {
            encode::encode_length_determinent(data, Some(1), Some(65535), false, num_ies)?;
            data.append_aligned(ies);
        }
        Ok(())
    }
}

impl PerCodec for GnbDuSystemInformation {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        GnbDuSystemInformation::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("GnbDuSystemInformation");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("GnbDuSystemInformation");
            e
        })
    }
}
// GnbDuConfigurationQuery
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum GnbDuConfigurationQuery {
    True,
}

impl GnbDuConfigurationQuery {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(0), true)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(0),
            true,
            *self as i128,
            (*self as u32) >= 1,
        )
    }
}

impl PerCodec for GnbDuConfigurationQuery {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        GnbDuConfigurationQuery::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("GnbDuConfigurationQuery");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("GnbDuConfigurationQuery");
            e
        })
    }
}
// GnbDuOverloadInformation
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum GnbDuOverloadInformation {
    Overloaded,
    NotOverloaded,
}

impl GnbDuOverloadInformation {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(1), false)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(1),
            false,
            *self as i128,
            (*self as u32) >= 2,
        )
    }
}

impl PerCodec for GnbDuOverloadInformation {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        GnbDuOverloadInformation::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("GnbDuOverloadInformation");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("GnbDuOverloadInformation");
            e
        })
    }
}
// GnbDuTnlAssociationToRemoveItem
#[derive(Clone, Debug)]
pub struct GnbDuTnlAssociationToRemoveItem {
    pub tnl_association_transport_layer_address: CpTransportLayerAddress,
    pub tnl_association_transport_layer_address_gnb_cu: Option<CpTransportLayerAddress>,
}

impl GnbDuTnlAssociationToRemoveItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, false, 2)?;
        let tnl_association_transport_layer_address = CpTransportLayerAddress::decode(data)?;
        let tnl_association_transport_layer_address_gnb_cu = if optionals[0] {
            Some(CpTransportLayerAddress::decode(data)?)
        } else {
            None
        };

        // Process the extension container

        if optionals[1] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            tnl_association_transport_layer_address,
            tnl_association_transport_layer_address_gnb_cu,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(
            self.tnl_association_transport_layer_address_gnb_cu
                .is_some(),
        );
        optionals.push(false);

        encode::encode_sequence_header(data, false, &optionals, false)?;
        self.tnl_association_transport_layer_address.encode(data)?;
        if let Some(x) = &self.tnl_association_transport_layer_address_gnb_cu {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl PerCodec for GnbDuTnlAssociationToRemoveItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        GnbDuTnlAssociationToRemoveItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("GnbDuTnlAssociationToRemoveItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("GnbDuTnlAssociationToRemoveItem");
            e
        })
    }
}
// GnbDuUeSliceMaximumBitRateList
#[derive(Clone, Debug)]
pub struct GnbDuUeSliceMaximumBitRateList(pub NonEmpty<GnbDuUeSliceMaximumBitRateItem>);

impl GnbDuUeSliceMaximumBitRateList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(8), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(GnbDuUeSliceMaximumBitRateItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(8), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for GnbDuUeSliceMaximumBitRateList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        GnbDuUeSliceMaximumBitRateList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("GnbDuUeSliceMaximumBitRateList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("GnbDuUeSliceMaximumBitRateList");
            e
        })
    }
}
// GnbDuUeSliceMaximumBitRateItem
#[derive(Clone, Debug)]
pub struct GnbDuUeSliceMaximumBitRateItem {
    pub snssai: Snssai,
    pub ue_slice_maximum_bit_rate_ul: BitRate,
}

impl GnbDuUeSliceMaximumBitRateItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let snssai = Snssai::decode(data)?;
        let ue_slice_maximum_bit_rate_ul = BitRate::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            snssai,
            ue_slice_maximum_bit_rate_ul,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.snssai.encode(data)?;
        self.ue_slice_maximum_bit_rate_ul.encode(data)?;

        Ok(())
    }
}

impl PerCodec for GnbDuUeSliceMaximumBitRateItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        GnbDuUeSliceMaximumBitRateItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("GnbDuUeSliceMaximumBitRateItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("GnbDuUeSliceMaximumBitRateItem");
            e
        })
    }
}
// GnbRxTxTimeDiff
#[derive(Clone, Debug)]
pub struct GnbRxTxTimeDiff {
    pub rx_tx_time_diff: GnbRxTxTimeDiffMeas,
    pub additional_path_list: Option<AdditionalPathList>,
    pub extended_additional_path_list: Option<ExtendedAdditionalPathList>,
    pub trpteg_information: Option<TrptegInformation>,
}

impl GnbRxTxTimeDiff {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, false, 2)?;
        let rx_tx_time_diff = GnbRxTxTimeDiffMeas::decode(data)?;
        let additional_path_list = if optionals[0] {
            Some(AdditionalPathList::decode(data)?)
        } else {
            None
        };

        // Process the extension container
        let mut extended_additional_path_list: Option<ExtendedAdditionalPathList> = None;
        let mut trpteg_information: Option<TrptegInformation> = None;

        if optionals[1] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    561 => {
                        extended_additional_path_list =
                            Some(ExtendedAdditionalPathList::decode(data)?)
                    }
                    567 => trpteg_information = Some(TrptegInformation::decode(data)?),
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            rx_tx_time_diff,
            additional_path_list,
            extended_additional_path_list,
            trpteg_information,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();
        if let Some(x) = &self.extended_additional_path_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 561, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.trpteg_information {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 567, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        let mut optionals = BitString::new();
        optionals.push(self.additional_path_list.is_some());
        optionals.push(num_ies != 0);

        encode::encode_sequence_header(data, false, &optionals, false)?;
        self.rx_tx_time_diff.encode(data)?;
        if let Some(x) = &self.additional_path_list {
            x.encode(data)?;
        }
        if num_ies != 0 {
            encode::encode_length_determinent(data, Some(1), Some(65535), false, num_ies)?;
            data.append_aligned(ies);
        }
        Ok(())
    }
}

impl PerCodec for GnbRxTxTimeDiff {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        GnbRxTxTimeDiff::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("GnbRxTxTimeDiff");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("GnbRxTxTimeDiff");
            e
        })
    }
}
// GnbRxTxTimeDiffMeas
#[derive(Clone, Debug)]
pub enum GnbRxTxTimeDiffMeas {
    K0(u32),
    K1(u32),
    K2(u32),
    K3(u32),
    K4(u32),
    K5(u16),
    ReportingGranularitykminus1(ReportingGranularitykminus1),
    ReportingGranularitykminus2(ReportingGranularitykminus2),
    ReportingGranularitykminus3(ReportingGranularitykminus3),
    ReportingGranularitykminus4(ReportingGranularitykminus4),
    ReportingGranularitykminus5(ReportingGranularitykminus5),
    ReportingGranularitykminus6(ReportingGranularitykminus6),
}

impl GnbRxTxTimeDiffMeas {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_choice_idx(data, 0, 6, false)?;
        if extended {
            return Err(per_codec_error_new("CHOICE additions not implemented"));
        }
        match idx {
            0 => Ok(Self::K0(
                decode::decode_integer(data, Some(0), Some(1970049), false)?.0 as u32,
            )),
            1 => Ok(Self::K1(
                decode::decode_integer(data, Some(0), Some(985025), false)?.0 as u32,
            )),
            2 => Ok(Self::K2(
                decode::decode_integer(data, Some(0), Some(492513), false)?.0 as u32,
            )),
            3 => Ok(Self::K3(
                decode::decode_integer(data, Some(0), Some(246257), false)?.0 as u32,
            )),
            4 => Ok(Self::K4(
                decode::decode_integer(data, Some(0), Some(123129), false)?.0 as u32,
            )),
            5 => Ok(Self::K5(
                decode::decode_integer(data, Some(0), Some(61565), false)?.0 as u16,
            )),
            6 => {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _ = Criticality::decode(data)?;
                let _ = decode::decode_length_determinent(data, None, None, false)?;
                let result = match id {
                    806 => Ok(Self::ReportingGranularitykminus1(
                        ReportingGranularitykminus1::decode(data)?,
                    )),
                    807 => Ok(Self::ReportingGranularitykminus2(
                        ReportingGranularitykminus2::decode(data)?,
                    )),
                    821 => Ok(Self::ReportingGranularitykminus3(
                        ReportingGranularitykminus3::decode(data)?,
                    )),
                    822 => Ok(Self::ReportingGranularitykminus4(
                        ReportingGranularitykminus4::decode(data)?,
                    )),
                    823 => Ok(Self::ReportingGranularitykminus5(
                        ReportingGranularitykminus5::decode(data)?,
                    )),
                    824 => Ok(Self::ReportingGranularitykminus6(
                        ReportingGranularitykminus6::decode(data)?,
                    )),
                    x => Err(per_codec_error_new(format!("Unrecognised IE type {}", x))),
                };
                data.decode_align()?;
                result
            }
            _ => Err(per_codec_error_new("Unknown choice idx")),
        }
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        match self {
            Self::K0(x) => {
                encode::encode_choice_idx(data, 0, 6, false, 0, false)?;
                encode::encode_integer(data, Some(0), Some(1970049), false, *x as i128, false)
            }
            Self::K1(x) => {
                encode::encode_choice_idx(data, 0, 6, false, 1, false)?;
                encode::encode_integer(data, Some(0), Some(985025), false, *x as i128, false)
            }
            Self::K2(x) => {
                encode::encode_choice_idx(data, 0, 6, false, 2, false)?;
                encode::encode_integer(data, Some(0), Some(492513), false, *x as i128, false)
            }
            Self::K3(x) => {
                encode::encode_choice_idx(data, 0, 6, false, 3, false)?;
                encode::encode_integer(data, Some(0), Some(246257), false, *x as i128, false)
            }
            Self::K4(x) => {
                encode::encode_choice_idx(data, 0, 6, false, 4, false)?;
                encode::encode_integer(data, Some(0), Some(123129), false, *x as i128, false)
            }
            Self::K5(x) => {
                encode::encode_choice_idx(data, 0, 6, false, 5, false)?;
                encode::encode_integer(data, Some(0), Some(61565), false, *x as i128, false)
            }
            Self::ReportingGranularitykminus1(x) => {
                encode::encode_choice_idx(data, 0, 6, false, 6, false)?;
                encode::encode_integer(data, Some(0), Some(65535), false, 806, false)?;
                Criticality::Ignore.encode(data)?;
                let ie = &mut Allocator::new_codec_data();
                x.encode(ie)?;
                encode::encode_length_determinent(data, None, None, false, ie.length_in_bytes())?;
                Ok(data.append_aligned(ie))
            }
            Self::ReportingGranularitykminus2(x) => {
                encode::encode_choice_idx(data, 0, 6, false, 6, false)?;
                encode::encode_integer(data, Some(0), Some(65535), false, 807, false)?;
                Criticality::Ignore.encode(data)?;
                let ie = &mut Allocator::new_codec_data();
                x.encode(ie)?;
                encode::encode_length_determinent(data, None, None, false, ie.length_in_bytes())?;
                Ok(data.append_aligned(ie))
            }
            Self::ReportingGranularitykminus3(x) => {
                encode::encode_choice_idx(data, 0, 6, false, 6, false)?;
                encode::encode_integer(data, Some(0), Some(65535), false, 821, false)?;
                Criticality::Ignore.encode(data)?;
                let ie = &mut Allocator::new_codec_data();
                x.encode(ie)?;
                encode::encode_length_determinent(data, None, None, false, ie.length_in_bytes())?;
                Ok(data.append_aligned(ie))
            }
            Self::ReportingGranularitykminus4(x) => {
                encode::encode_choice_idx(data, 0, 6, false, 6, false)?;
                encode::encode_integer(data, Some(0), Some(65535), false, 822, false)?;
                Criticality::Ignore.encode(data)?;
                let ie = &mut Allocator::new_codec_data();
                x.encode(ie)?;
                encode::encode_length_determinent(data, None, None, false, ie.length_in_bytes())?;
                Ok(data.append_aligned(ie))
            }
            Self::ReportingGranularitykminus5(x) => {
                encode::encode_choice_idx(data, 0, 6, false, 6, false)?;
                encode::encode_integer(data, Some(0), Some(65535), false, 823, false)?;
                Criticality::Ignore.encode(data)?;
                let ie = &mut Allocator::new_codec_data();
                x.encode(ie)?;
                encode::encode_length_determinent(data, None, None, false, ie.length_in_bytes())?;
                Ok(data.append_aligned(ie))
            }
            Self::ReportingGranularitykminus6(x) => {
                encode::encode_choice_idx(data, 0, 6, false, 6, false)?;
                encode::encode_integer(data, Some(0), Some(65535), false, 824, false)?;
                Criticality::Ignore.encode(data)?;
                let ie = &mut Allocator::new_codec_data();
                x.encode(ie)?;
                encode::encode_length_determinent(data, None, None, false, ie.length_in_bytes())?;
                Ok(data.append_aligned(ie))
            }
        }
    }
}

impl PerCodec for GnbRxTxTimeDiffMeas {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        GnbRxTxTimeDiffMeas::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("GnbRxTxTimeDiffMeas");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("GnbRxTxTimeDiffMeas");
            e
        })
    }
}
// GnbSetId
#[derive(Clone, Debug)]
pub struct GnbSetId(pub BitString);

impl GnbSetId {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(decode::decode_bitstring(
            data,
            Some(22),
            Some(22),
            false,
        )?))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_bitstring(data, Some(22), Some(22), false, &self.0, false)
    }
}

impl PerCodec for GnbSetId {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        GnbSetId::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("GnbSetId");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("GnbSetId");
            e
        })
    }
}
// GtptlAs
#[derive(Clone, Debug)]
pub struct GtptlAs(pub NonEmpty<GtptlaItem>);

impl GtptlAs {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(16), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(GtptlaItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(16), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for GtptlAs {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        GtptlAs::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("GtptlAs");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("GtptlAs");
            e
        })
    }
}
// GtptlaItem
#[derive(Clone, Debug)]
pub struct GtptlaItem {
    pub gtp_transport_layer_address: TransportLayerAddress,
}

impl GtptlaItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, false, 1)?;
        let gtp_transport_layer_address = TransportLayerAddress::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            gtp_transport_layer_address,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, false, &optionals, false)?;
        self.gtp_transport_layer_address.encode(data)?;

        Ok(())
    }
}

impl PerCodec for GtptlaItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        GtptlaItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("GtptlaItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("GtptlaItem");
            e
        })
    }
}
// HandoverPreparationInformation
#[derive(Clone, Debug)]
pub struct HandoverPreparationInformation(pub Vec<u8>);

impl HandoverPreparationInformation {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(decode::decode_octetstring(data, None, None, false)?))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_octetstring(data, None, None, false, &self.0, false)
    }
}

impl PerCodec for HandoverPreparationInformation {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        HandoverPreparationInformation::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("HandoverPreparationInformation");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("HandoverPreparationInformation");
            e
        })
    }
}
// HardwareLoadIndicator
#[derive(Clone, Debug)]
pub struct HardwareLoadIndicator {
    pub dl_hardware_load_indicator: u8,
    pub ul_hardware_load_indicator: u8,
}

impl HardwareLoadIndicator {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let dl_hardware_load_indicator =
            decode::decode_integer(data, Some(0), Some(100), true)?.0 as u8;
        let ul_hardware_load_indicator =
            decode::decode_integer(data, Some(0), Some(100), true)?.0 as u8;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            dl_hardware_load_indicator,
            ul_hardware_load_indicator,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        encode::encode_integer(
            data,
            Some(0),
            Some(100),
            true,
            self.dl_hardware_load_indicator as i128,
            false,
        )?;
        encode::encode_integer(
            data,
            Some(0),
            Some(100),
            true,
            self.ul_hardware_load_indicator as i128,
            false,
        )?;

        Ok(())
    }
}

impl PerCodec for HardwareLoadIndicator {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        HardwareLoadIndicator::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("HardwareLoadIndicator");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("HardwareLoadIndicator");
            e
        })
    }
}
// HsnaSlotConfigList
#[derive(Clone, Debug)]
pub struct HsnaSlotConfigList(pub NonEmpty<HsnaSlotConfigItem>);

impl HsnaSlotConfigList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(5120), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(HsnaSlotConfigItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(5120), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for HsnaSlotConfigList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        HsnaSlotConfigList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("HsnaSlotConfigList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("HsnaSlotConfigList");
            e
        })
    }
}
// HsnaSlotConfigItem
#[derive(Clone, Debug)]
pub struct HsnaSlotConfigItem {
    pub hsna_downlink: Option<HsnaDownlink>,
    pub hsna_uplink: Option<HsnaUplink>,
    pub hsna_flexible: Option<HsnaFlexible>,
}

impl HsnaSlotConfigItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, false, 4)?;
        let hsna_downlink = if optionals[0] {
            Some(HsnaDownlink::decode(data)?)
        } else {
            None
        };
        let hsna_uplink = if optionals[1] {
            Some(HsnaUplink::decode(data)?)
        } else {
            None
        };
        let hsna_flexible = if optionals[2] {
            Some(HsnaFlexible::decode(data)?)
        } else {
            None
        };

        // Process the extension container

        if optionals[3] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            hsna_downlink,
            hsna_uplink,
            hsna_flexible,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.hsna_downlink.is_some());
        optionals.push(self.hsna_uplink.is_some());
        optionals.push(self.hsna_flexible.is_some());
        optionals.push(false);

        encode::encode_sequence_header(data, false, &optionals, false)?;
        if let Some(x) = &self.hsna_downlink {
            x.encode(data)?;
        }
        if let Some(x) = &self.hsna_uplink {
            x.encode(data)?;
        }
        if let Some(x) = &self.hsna_flexible {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl PerCodec for HsnaSlotConfigItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        HsnaSlotConfigItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("HsnaSlotConfigItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("HsnaSlotConfigItem");
            e
        })
    }
}
// HsnaDownlink
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum HsnaDownlink {
    Hard,
    Soft,
    Notavailable,
}

impl HsnaDownlink {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(2), false)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(2),
            false,
            *self as i128,
            (*self as u32) >= 3,
        )
    }
}

impl PerCodec for HsnaDownlink {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        HsnaDownlink::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("HsnaDownlink");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("HsnaDownlink");
            e
        })
    }
}
// HsnaFlexible
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum HsnaFlexible {
    Hard,
    Soft,
    Notavailable,
}

impl HsnaFlexible {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(2), false)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(2),
            false,
            *self as i128,
            (*self as u32) >= 3,
        )
    }
}

impl PerCodec for HsnaFlexible {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        HsnaFlexible::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("HsnaFlexible");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("HsnaFlexible");
            e
        })
    }
}
// HsnaUplink
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum HsnaUplink {
    Hard,
    Soft,
    Notavailable,
}

impl HsnaUplink {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(2), false)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(2),
            false,
            *self as i128,
            (*self as u32) >= 3,
        )
    }
}

impl PerCodec for HsnaUplink {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        HsnaUplink::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("HsnaUplink");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("HsnaUplink");
            e
        })
    }
}
// HsnaTransmissionPeriodicity
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum HsnaTransmissionPeriodicity {
    Ms0p5,
    Ms0p625,
    Ms1,
    Ms1p25,
    Ms2,
    Ms2p5,
    Ms5,
    Ms10,
    Ms20,
    Ms40,
    Ms80,
    Ms160,
}

impl HsnaTransmissionPeriodicity {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(11), true)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(11),
            true,
            *self as i128,
            (*self as u32) >= 12,
        )
    }
}

impl PerCodec for HsnaTransmissionPeriodicity {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        HsnaTransmissionPeriodicity::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("HsnaTransmissionPeriodicity");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("HsnaTransmissionPeriodicity");
            e
        })
    }
}
// HashedUeIdentityIndexValue
#[derive(Clone, Debug)]
pub struct HashedUeIdentityIndexValue(pub BitString);

impl HashedUeIdentityIndexValue {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(decode::decode_bitstring(
            data,
            Some(13),
            Some(13),
            true,
        )?))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_bitstring(data, Some(13), Some(13), true, &self.0, false)
    }
}

impl PerCodec for HashedUeIdentityIndexValue {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        HashedUeIdentityIndexValue::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("HashedUeIdentityIndexValue");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("HashedUeIdentityIndexValue");
            e
        })
    }
}
// IabBarred
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum IabBarred {
    Barred,
    NotBarred,
}

impl IabBarred {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(1), true)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(1),
            true,
            *self as i128,
            (*self as u32) >= 2,
        )
    }
}

impl PerCodec for IabBarred {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        IabBarred::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("IabBarred");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("IabBarred");
            e
        })
    }
}
// IabConditionalRrcMessageDeliveryIndication
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum IabConditionalRrcMessageDeliveryIndication {
    True,
}

impl IabConditionalRrcMessageDeliveryIndication {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(0), true)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(0),
            true,
            *self as i128,
            (*self as u32) >= 1,
        )
    }
}

impl PerCodec for IabConditionalRrcMessageDeliveryIndication {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        IabConditionalRrcMessageDeliveryIndication::decode_inner(data).map_err(
            |mut e: PerCodecError| {
                e.push_context("IabConditionalRrcMessageDeliveryIndication");
                e
            },
        )
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("IabConditionalRrcMessageDeliveryIndication");
            e
        })
    }
}
// IabCongestionIndication
#[derive(Clone, Debug)]
pub struct IabCongestionIndication {
    pub iab_congestion_indication_list: IabCongestionIndicationList,
}

impl IabCongestionIndication {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, false, 1)?;
        let iab_congestion_indication_list = IabCongestionIndicationList::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            iab_congestion_indication_list,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, false, &optionals, false)?;
        self.iab_congestion_indication_list.encode(data)?;

        Ok(())
    }
}

impl PerCodec for IabCongestionIndication {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        IabCongestionIndication::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("IabCongestionIndication");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("IabCongestionIndication");
            e
        })
    }
}
// IabCongestionIndicationList
#[derive(Clone, Debug)]
pub struct IabCongestionIndicationList(pub NonEmpty<IabCongestionIndicationItem>);

impl IabCongestionIndicationList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(1024), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(IabCongestionIndicationItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(1024), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for IabCongestionIndicationList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        IabCongestionIndicationList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("IabCongestionIndicationList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("IabCongestionIndicationList");
            e
        })
    }
}
// IabCongestionIndicationItem
#[derive(Clone, Debug)]
pub struct IabCongestionIndicationItem {
    pub child_node_identifier: BapAddress,
    pub bhrlcch_list: Option<BhrlcchList>,
}

impl IabCongestionIndicationItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, false, 2)?;
        let child_node_identifier = BapAddress::decode(data)?;
        let bhrlcch_list = if optionals[0] {
            Some(BhrlcchList::decode(data)?)
        } else {
            None
        };

        // Process the extension container

        if optionals[1] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            child_node_identifier,
            bhrlcch_list,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.bhrlcch_list.is_some());
        optionals.push(false);

        encode::encode_sequence_header(data, false, &optionals, false)?;
        self.child_node_identifier.encode(data)?;
        if let Some(x) = &self.bhrlcch_list {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl PerCodec for IabCongestionIndicationItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        IabCongestionIndicationItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("IabCongestionIndicationItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("IabCongestionIndicationItem");
            e
        })
    }
}
// IabInfoIabDonorCu
#[derive(Clone, Debug)]
pub struct IabInfoIabDonorCu {
    pub iab_stc_info: Option<IabStcInfo>,
}

impl IabInfoIabDonorCu {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, false, 2)?;
        let iab_stc_info = if optionals[0] {
            Some(IabStcInfo::decode(data)?)
        } else {
            None
        };

        // Process the extension container

        if optionals[1] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self { iab_stc_info })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.iab_stc_info.is_some());
        optionals.push(false);

        encode::encode_sequence_header(data, false, &optionals, false)?;
        if let Some(x) = &self.iab_stc_info {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl PerCodec for IabInfoIabDonorCu {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        IabInfoIabDonorCu::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("IabInfoIabDonorCu");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("IabInfoIabDonorCu");
            e
        })
    }
}
// IabInfoIabDu
#[derive(Clone, Debug)]
pub struct IabInfoIabDu {
    pub multiplexing_info: Option<MultiplexingInfo>,
    pub iab_stc_info: Option<IabStcInfo>,
}

impl IabInfoIabDu {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, false, 3)?;
        let multiplexing_info = if optionals[0] {
            Some(MultiplexingInfo::decode(data)?)
        } else {
            None
        };
        let iab_stc_info = if optionals[1] {
            Some(IabStcInfo::decode(data)?)
        } else {
            None
        };

        // Process the extension container

        if optionals[2] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            multiplexing_info,
            iab_stc_info,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.multiplexing_info.is_some());
        optionals.push(self.iab_stc_info.is_some());
        optionals.push(false);

        encode::encode_sequence_header(data, false, &optionals, false)?;
        if let Some(x) = &self.multiplexing_info {
            x.encode(data)?;
        }
        if let Some(x) = &self.iab_stc_info {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl PerCodec for IabInfoIabDu {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        IabInfoIabDu::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("IabInfoIabDu");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("IabInfoIabDu");
            e
        })
    }
}
// IabMtCellList
#[derive(Clone, Debug)]
pub struct IabMtCellList(pub NonEmpty<IabMtCellListItem>);

impl IabMtCellList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(32), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(IabMtCellListItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(32), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for IabMtCellList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        IabMtCellList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("IabMtCellList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("IabMtCellList");
            e
        })
    }
}
// IabMtCellListItem
#[derive(Clone, Debug)]
pub struct IabMtCellListItem {
    pub nr_cell_identity: NrCellIdentity,
    pub du_rx_mt_rx: DuRxMtRx,
    pub du_tx_mt_tx: DuTxMtTx,
    pub du_rx_mt_tx: DuRxMtTx,
    pub du_tx_mt_rx: DuTxMtRx,
    pub du_rx_mt_rx_extend: Option<DuRxMtRxExtend>,
    pub du_tx_mt_tx_extend: Option<DuTxMtTxExtend>,
    pub du_rx_mt_tx_extend: Option<DuRxMtTxExtend>,
    pub du_tx_mt_rx_extend: Option<DuTxMtRxExtend>,
}

impl IabMtCellListItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, false, 1)?;
        let nr_cell_identity = NrCellIdentity::decode(data)?;
        let du_rx_mt_rx = DuRxMtRx::decode(data)?;
        let du_tx_mt_tx = DuTxMtTx::decode(data)?;
        let du_rx_mt_tx = DuRxMtTx::decode(data)?;
        let du_tx_mt_rx = DuTxMtRx::decode(data)?;

        // Process the extension container
        let mut du_rx_mt_rx_extend: Option<DuRxMtRxExtend> = None;
        let mut du_tx_mt_tx_extend: Option<DuTxMtTxExtend> = None;
        let mut du_rx_mt_tx_extend: Option<DuRxMtTxExtend> = None;
        let mut du_tx_mt_rx_extend: Option<DuTxMtRxExtend> = None;

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    637 => du_rx_mt_rx_extend = Some(DuRxMtRxExtend::decode(data)?),
                    638 => du_tx_mt_tx_extend = Some(DuTxMtTxExtend::decode(data)?),
                    639 => du_rx_mt_tx_extend = Some(DuRxMtTxExtend::decode(data)?),
                    640 => du_tx_mt_rx_extend = Some(DuTxMtRxExtend::decode(data)?),
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            nr_cell_identity,
            du_rx_mt_rx,
            du_tx_mt_tx,
            du_rx_mt_tx,
            du_tx_mt_rx,
            du_rx_mt_rx_extend,
            du_tx_mt_tx_extend,
            du_rx_mt_tx_extend,
            du_tx_mt_rx_extend,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();
        if let Some(x) = &self.du_rx_mt_rx_extend {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 637, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.du_tx_mt_tx_extend {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 638, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.du_rx_mt_tx_extend {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 639, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.du_tx_mt_rx_extend {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 640, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        let mut optionals = BitString::new();
        optionals.push(num_ies != 0);

        encode::encode_sequence_header(data, false, &optionals, false)?;
        self.nr_cell_identity.encode(data)?;
        self.du_rx_mt_rx.encode(data)?;
        self.du_tx_mt_tx.encode(data)?;
        self.du_rx_mt_tx.encode(data)?;
        self.du_tx_mt_rx.encode(data)?;
        if num_ies != 0 {
            encode::encode_length_determinent(data, Some(1), Some(65535), false, num_ies)?;
            data.append_aligned(ies);
        }
        Ok(())
    }
}

impl PerCodec for IabMtCellListItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        IabMtCellListItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("IabMtCellListItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("IabMtCellListItem");
            e
        })
    }
}
// IabMtCellNaResourceConfigurationModeInfo
#[derive(Clone, Debug)]
pub enum IabMtCellNaResourceConfigurationModeInfo {
    Fdd(IabMtCellNaResourceConfigurationFddInfo),
    Tdd(IabMtCellNaResourceConfigurationTddInfo),
}

impl IabMtCellNaResourceConfigurationModeInfo {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_choice_idx(data, 0, 2, false)?;
        if extended {
            return Err(per_codec_error_new("CHOICE additions not implemented"));
        }
        match idx {
            0 => Ok(Self::Fdd(IabMtCellNaResourceConfigurationFddInfo::decode(
                data,
            )?)),
            1 => Ok(Self::Tdd(IabMtCellNaResourceConfigurationTddInfo::decode(
                data,
            )?)),
            2 => {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _ = Criticality::decode(data)?;
                let _ = decode::decode_length_determinent(data, None, None, false)?;
                let result = match id {
                    x => Err(per_codec_error_new(format!("Unrecognised IE type {}", x))),
                };
                data.decode_align()?;
                result
            }
            _ => Err(per_codec_error_new("Unknown choice idx")),
        }
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        match self {
            Self::Fdd(x) => {
                encode::encode_choice_idx(data, 0, 2, false, 0, false)?;
                x.encode(data)
            }
            Self::Tdd(x) => {
                encode::encode_choice_idx(data, 0, 2, false, 1, false)?;
                x.encode(data)
            }
        }
    }
}

impl PerCodec for IabMtCellNaResourceConfigurationModeInfo {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        IabMtCellNaResourceConfigurationModeInfo::decode_inner(data).map_err(
            |mut e: PerCodecError| {
                e.push_context("IabMtCellNaResourceConfigurationModeInfo");
                e
            },
        )
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("IabMtCellNaResourceConfigurationModeInfo");
            e
        })
    }
}
// IabMtCellNaResourceConfigurationFddInfo
#[derive(Clone, Debug)]
pub struct IabMtCellNaResourceConfigurationFddInfo {
    pub gnb_du_cell_na_resource_configuration_fdd_ul: GnbDuCellResourceConfiguration,
    pub gnb_du_cell_na_resource_configuration_fdd_dl: GnbDuCellResourceConfiguration,
    pub ul_freq_info: Option<NrFreqInfo>,
    pub ul_transmission_bandwidth: Option<TransmissionBandwidth>,
    pub ul_nr_carrier_list: Option<NrCarrierList>,
    pub dl_freq_info: Option<NrFreqInfo>,
    pub dl_transmission_bandwidth: Option<TransmissionBandwidth>,
    pub dl_nr_carrier_list: Option<NrCarrierList>,
}

impl IabMtCellNaResourceConfigurationFddInfo {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 7)?;
        let gnb_du_cell_na_resource_configuration_fdd_ul =
            GnbDuCellResourceConfiguration::decode(data)?;
        let gnb_du_cell_na_resource_configuration_fdd_dl =
            GnbDuCellResourceConfiguration::decode(data)?;
        let ul_freq_info = if optionals[0] {
            Some(NrFreqInfo::decode(data)?)
        } else {
            None
        };
        let ul_transmission_bandwidth = if optionals[1] {
            Some(TransmissionBandwidth::decode(data)?)
        } else {
            None
        };
        let ul_nr_carrier_list = if optionals[2] {
            Some(NrCarrierList::decode(data)?)
        } else {
            None
        };
        let dl_freq_info = if optionals[3] {
            Some(NrFreqInfo::decode(data)?)
        } else {
            None
        };
        let dl_transmission_bandwidth = if optionals[4] {
            Some(TransmissionBandwidth::decode(data)?)
        } else {
            None
        };
        let dl_nr_carrier_list = if optionals[5] {
            Some(NrCarrierList::decode(data)?)
        } else {
            None
        };

        // Process the extension container

        if optionals[6] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            gnb_du_cell_na_resource_configuration_fdd_ul,
            gnb_du_cell_na_resource_configuration_fdd_dl,
            ul_freq_info,
            ul_transmission_bandwidth,
            ul_nr_carrier_list,
            dl_freq_info,
            dl_transmission_bandwidth,
            dl_nr_carrier_list,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.ul_freq_info.is_some());
        optionals.push(self.ul_transmission_bandwidth.is_some());
        optionals.push(self.ul_nr_carrier_list.is_some());
        optionals.push(self.dl_freq_info.is_some());
        optionals.push(self.dl_transmission_bandwidth.is_some());
        optionals.push(self.dl_nr_carrier_list.is_some());
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.gnb_du_cell_na_resource_configuration_fdd_ul
            .encode(data)?;
        self.gnb_du_cell_na_resource_configuration_fdd_dl
            .encode(data)?;
        if let Some(x) = &self.ul_freq_info {
            x.encode(data)?;
        }
        if let Some(x) = &self.ul_transmission_bandwidth {
            x.encode(data)?;
        }
        if let Some(x) = &self.ul_nr_carrier_list {
            x.encode(data)?;
        }
        if let Some(x) = &self.dl_freq_info {
            x.encode(data)?;
        }
        if let Some(x) = &self.dl_transmission_bandwidth {
            x.encode(data)?;
        }
        if let Some(x) = &self.dl_nr_carrier_list {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl PerCodec for IabMtCellNaResourceConfigurationFddInfo {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        IabMtCellNaResourceConfigurationFddInfo::decode_inner(data).map_err(
            |mut e: PerCodecError| {
                e.push_context("IabMtCellNaResourceConfigurationFddInfo");
                e
            },
        )
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("IabMtCellNaResourceConfigurationFddInfo");
            e
        })
    }
}
// IabMtCellNaResourceConfigurationTddInfo
#[derive(Clone, Debug)]
pub struct IabMtCellNaResourceConfigurationTddInfo {
    pub gnb_du_cell_na_resourc_configuration_tdd: GnbDuCellResourceConfiguration,
    pub nr_freq_info: Option<NrFreqInfo>,
    pub transmission_bandwidth: Option<TransmissionBandwidth>,
    pub nr_carrier_list: Option<NrCarrierList>,
}

impl IabMtCellNaResourceConfigurationTddInfo {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 4)?;
        let gnb_du_cell_na_resourc_configuration_tdd =
            GnbDuCellResourceConfiguration::decode(data)?;
        let nr_freq_info = if optionals[0] {
            Some(NrFreqInfo::decode(data)?)
        } else {
            None
        };
        let transmission_bandwidth = if optionals[1] {
            Some(TransmissionBandwidth::decode(data)?)
        } else {
            None
        };
        let nr_carrier_list = if optionals[2] {
            Some(NrCarrierList::decode(data)?)
        } else {
            None
        };

        // Process the extension container

        if optionals[3] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            gnb_du_cell_na_resourc_configuration_tdd,
            nr_freq_info,
            transmission_bandwidth,
            nr_carrier_list,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.nr_freq_info.is_some());
        optionals.push(self.transmission_bandwidth.is_some());
        optionals.push(self.nr_carrier_list.is_some());
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.gnb_du_cell_na_resourc_configuration_tdd.encode(data)?;
        if let Some(x) = &self.nr_freq_info {
            x.encode(data)?;
        }
        if let Some(x) = &self.transmission_bandwidth {
            x.encode(data)?;
        }
        if let Some(x) = &self.nr_carrier_list {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl PerCodec for IabMtCellNaResourceConfigurationTddInfo {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        IabMtCellNaResourceConfigurationTddInfo::decode_inner(data).map_err(
            |mut e: PerCodecError| {
                e.push_context("IabMtCellNaResourceConfigurationTddInfo");
                e
            },
        )
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("IabMtCellNaResourceConfigurationTddInfo");
            e
        })
    }
}
// IabStcInfo
#[derive(Clone, Debug)]
pub struct IabStcInfo {
    pub iab_stc_info_list: IabStcInfoList,
}

impl IabStcInfo {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, false, 1)?;
        let iab_stc_info_list = IabStcInfoList::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self { iab_stc_info_list })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, false, &optionals, false)?;
        self.iab_stc_info_list.encode(data)?;

        Ok(())
    }
}

impl PerCodec for IabStcInfo {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        IabStcInfo::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("IabStcInfo");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("IabStcInfo");
            e
        })
    }
}
// IabStcInfoList
#[derive(Clone, Debug)]
pub struct IabStcInfoList(pub NonEmpty<IabStcInfoItem>);

impl IabStcInfoList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(45), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(IabStcInfoItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(45), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for IabStcInfoList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        IabStcInfoList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("IabStcInfoList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("IabStcInfoList");
            e
        })
    }
}
// IabStcInfoItem
#[derive(Clone, Debug)]
pub struct IabStcInfoItem {
    pub ssb_freq_info: SsbFreqInfo,
    pub ssb_subcarrier_spacing: SsbSubcarrierSpacing,
    pub ssb_transmission_periodicity: SsbTransmissionPeriodicity,
    pub ssb_transmission_timing_offset: SsbTransmissionTimingOffset,
    pub ssb_transmission_bitmap: SsbTransmissionBitmap,
}

impl IabStcInfoItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, false, 1)?;
        let ssb_freq_info = SsbFreqInfo::decode(data)?;
        let ssb_subcarrier_spacing = SsbSubcarrierSpacing::decode(data)?;
        let ssb_transmission_periodicity = SsbTransmissionPeriodicity::decode(data)?;
        let ssb_transmission_timing_offset = SsbTransmissionTimingOffset::decode(data)?;
        let ssb_transmission_bitmap = SsbTransmissionBitmap::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            ssb_freq_info,
            ssb_subcarrier_spacing,
            ssb_transmission_periodicity,
            ssb_transmission_timing_offset,
            ssb_transmission_bitmap,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, false, &optionals, false)?;
        self.ssb_freq_info.encode(data)?;
        self.ssb_subcarrier_spacing.encode(data)?;
        self.ssb_transmission_periodicity.encode(data)?;
        self.ssb_transmission_timing_offset.encode(data)?;
        self.ssb_transmission_bitmap.encode(data)?;

        Ok(())
    }
}

impl PerCodec for IabStcInfoItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        IabStcInfoItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("IabStcInfoItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("IabStcInfoItem");
            e
        })
    }
}
// IabAllocatedTnlAddressItem
#[derive(Clone, Debug)]
pub struct IabAllocatedTnlAddressItem {
    pub iabtnl_address: IabtnlAddress,
    pub iabtnl_address_usage: Option<IabtnlAddressUsage>,
}

impl IabAllocatedTnlAddressItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, false, 2)?;
        let iabtnl_address = IabtnlAddress::decode(data)?;
        let iabtnl_address_usage = if optionals[0] {
            Some(IabtnlAddressUsage::decode(data)?)
        } else {
            None
        };

        // Process the extension container

        if optionals[1] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            iabtnl_address,
            iabtnl_address_usage,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.iabtnl_address_usage.is_some());
        optionals.push(false);

        encode::encode_sequence_header(data, false, &optionals, false)?;
        self.iabtnl_address.encode(data)?;
        if let Some(x) = &self.iabtnl_address_usage {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl PerCodec for IabAllocatedTnlAddressItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        IabAllocatedTnlAddressItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("IabAllocatedTnlAddressItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("IabAllocatedTnlAddressItem");
            e
        })
    }
}
// IabDuCellResourceConfigurationModeInfo
#[derive(Clone, Debug)]
pub enum IabDuCellResourceConfigurationModeInfo {
    Fdd(IabDuCellResourceConfigurationFddInfo),
    Tdd(IabDuCellResourceConfigurationTddInfo),
}

impl IabDuCellResourceConfigurationModeInfo {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_choice_idx(data, 0, 2, false)?;
        if extended {
            return Err(per_codec_error_new("CHOICE additions not implemented"));
        }
        match idx {
            0 => Ok(Self::Fdd(IabDuCellResourceConfigurationFddInfo::decode(
                data,
            )?)),
            1 => Ok(Self::Tdd(IabDuCellResourceConfigurationTddInfo::decode(
                data,
            )?)),
            2 => {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _ = Criticality::decode(data)?;
                let _ = decode::decode_length_determinent(data, None, None, false)?;
                let result = match id {
                    x => Err(per_codec_error_new(format!("Unrecognised IE type {}", x))),
                };
                data.decode_align()?;
                result
            }
            _ => Err(per_codec_error_new("Unknown choice idx")),
        }
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        match self {
            Self::Fdd(x) => {
                encode::encode_choice_idx(data, 0, 2, false, 0, false)?;
                x.encode(data)
            }
            Self::Tdd(x) => {
                encode::encode_choice_idx(data, 0, 2, false, 1, false)?;
                x.encode(data)
            }
        }
    }
}

impl PerCodec for IabDuCellResourceConfigurationModeInfo {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        IabDuCellResourceConfigurationModeInfo::decode_inner(data).map_err(
            |mut e: PerCodecError| {
                e.push_context("IabDuCellResourceConfigurationModeInfo");
                e
            },
        )
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("IabDuCellResourceConfigurationModeInfo");
            e
        })
    }
}
// IabDuCellResourceConfigurationFddInfo
#[derive(Clone, Debug)]
pub struct IabDuCellResourceConfigurationFddInfo {
    pub gnb_du_cell_resource_configuration_fdd_ul: GnbDuCellResourceConfiguration,
    pub gnb_du_cell_resource_configuration_fdd_dl: GnbDuCellResourceConfiguration,
    pub ul_freq_info: Option<NrFreqInfo>,
    pub ul_transmission_bandwidth: Option<TransmissionBandwidth>,
    pub ul_nr_carrier_list: Option<NrCarrierList>,
    pub dl_freq_info: Option<NrFreqInfo>,
    pub dl_transmission_bandwidth: Option<TransmissionBandwidth>,
    pub dl_nr_carrier_list: Option<NrCarrierList>,
}

impl IabDuCellResourceConfigurationFddInfo {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let gnb_du_cell_resource_configuration_fdd_ul =
            GnbDuCellResourceConfiguration::decode(data)?;
        let gnb_du_cell_resource_configuration_fdd_dl =
            GnbDuCellResourceConfiguration::decode(data)?;

        // Process the extension container
        let mut ul_freq_info: Option<NrFreqInfo> = None;
        let mut ul_transmission_bandwidth: Option<TransmissionBandwidth> = None;
        let mut ul_nr_carrier_list: Option<NrCarrierList> = None;
        let mut dl_freq_info: Option<NrFreqInfo> = None;
        let mut dl_transmission_bandwidth: Option<TransmissionBandwidth> = None;
        let mut dl_nr_carrier_list: Option<NrCarrierList> = None;

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    524 => ul_freq_info = Some(NrFreqInfo::decode(data)?),
                    525 => ul_transmission_bandwidth = Some(TransmissionBandwidth::decode(data)?),
                    528 => ul_nr_carrier_list = Some(NrCarrierList::decode(data)?),
                    526 => dl_freq_info = Some(NrFreqInfo::decode(data)?),
                    527 => dl_transmission_bandwidth = Some(TransmissionBandwidth::decode(data)?),
                    529 => dl_nr_carrier_list = Some(NrCarrierList::decode(data)?),
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            gnb_du_cell_resource_configuration_fdd_ul,
            gnb_du_cell_resource_configuration_fdd_dl,
            ul_freq_info,
            ul_transmission_bandwidth,
            ul_nr_carrier_list,
            dl_freq_info,
            dl_transmission_bandwidth,
            dl_nr_carrier_list,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();
        if let Some(x) = &self.ul_freq_info {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 524, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.ul_transmission_bandwidth {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 525, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.ul_nr_carrier_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 528, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.dl_freq_info {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 526, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.dl_transmission_bandwidth {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 527, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.dl_nr_carrier_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 529, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        let mut optionals = BitString::new();
        optionals.push(num_ies != 0);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.gnb_du_cell_resource_configuration_fdd_ul
            .encode(data)?;
        self.gnb_du_cell_resource_configuration_fdd_dl
            .encode(data)?;
        if num_ies != 0 {
            encode::encode_length_determinent(data, Some(1), Some(65535), false, num_ies)?;
            data.append_aligned(ies);
        }
        Ok(())
    }
}

impl PerCodec for IabDuCellResourceConfigurationFddInfo {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        IabDuCellResourceConfigurationFddInfo::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("IabDuCellResourceConfigurationFddInfo");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("IabDuCellResourceConfigurationFddInfo");
            e
        })
    }
}
// IabDuCellResourceConfigurationTddInfo
#[derive(Clone, Debug)]
pub struct IabDuCellResourceConfigurationTddInfo {
    pub gnb_du_cell_resourc_configuration_tdd: GnbDuCellResourceConfiguration,
    pub nr_freq_info: Option<NrFreqInfo>,
    pub transmission_bandwidth: Option<TransmissionBandwidth>,
    pub nr_carrier_list: Option<NrCarrierList>,
}

impl IabDuCellResourceConfigurationTddInfo {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let gnb_du_cell_resourc_configuration_tdd = GnbDuCellResourceConfiguration::decode(data)?;

        // Process the extension container
        let mut nr_freq_info: Option<NrFreqInfo> = None;
        let mut transmission_bandwidth: Option<TransmissionBandwidth> = None;
        let mut nr_carrier_list: Option<NrCarrierList> = None;

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    530 => nr_freq_info = Some(NrFreqInfo::decode(data)?),
                    531 => transmission_bandwidth = Some(TransmissionBandwidth::decode(data)?),
                    532 => nr_carrier_list = Some(NrCarrierList::decode(data)?),
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            gnb_du_cell_resourc_configuration_tdd,
            nr_freq_info,
            transmission_bandwidth,
            nr_carrier_list,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();
        if let Some(x) = &self.nr_freq_info {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 530, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.transmission_bandwidth {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 531, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.nr_carrier_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 532, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        let mut optionals = BitString::new();
        optionals.push(num_ies != 0);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.gnb_du_cell_resourc_configuration_tdd.encode(data)?;
        if num_ies != 0 {
            encode::encode_length_determinent(data, Some(1), Some(65535), false, num_ies)?;
            data.append_aligned(ies);
        }
        Ok(())
    }
}

impl PerCodec for IabDuCellResourceConfigurationTddInfo {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        IabDuCellResourceConfigurationTddInfo::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("IabDuCellResourceConfigurationTddInfo");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("IabDuCellResourceConfigurationTddInfo");
            e
        })
    }
}
// IabiPv6RequestType
#[derive(Clone, Debug)]
pub enum IabiPv6RequestType {
    IPv6Address(IabtnlAddressesRequested),
    IPv6Prefix(IabtnlAddressesRequested),
}

impl IabiPv6RequestType {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_choice_idx(data, 0, 2, false)?;
        if extended {
            return Err(per_codec_error_new("CHOICE additions not implemented"));
        }
        match idx {
            0 => Ok(Self::IPv6Address(IabtnlAddressesRequested::decode(data)?)),
            1 => Ok(Self::IPv6Prefix(IabtnlAddressesRequested::decode(data)?)),
            2 => {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _ = Criticality::decode(data)?;
                let _ = decode::decode_length_determinent(data, None, None, false)?;
                let result = match id {
                    x => Err(per_codec_error_new(format!("Unrecognised IE type {}", x))),
                };
                data.decode_align()?;
                result
            }
            _ => Err(per_codec_error_new("Unknown choice idx")),
        }
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        match self {
            Self::IPv6Address(x) => {
                encode::encode_choice_idx(data, 0, 2, false, 0, false)?;
                x.encode(data)
            }
            Self::IPv6Prefix(x) => {
                encode::encode_choice_idx(data, 0, 2, false, 1, false)?;
                x.encode(data)
            }
        }
    }
}

impl PerCodec for IabiPv6RequestType {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        IabiPv6RequestType::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("IabiPv6RequestType");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("IabiPv6RequestType");
            e
        })
    }
}
// IabtnlAddress
#[derive(Clone, Debug)]
pub enum IabtnlAddress {
    IPv4Address(BitString),
    IPv6Address(BitString),
    IPv6Prefix(BitString),
}

impl IabtnlAddress {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_choice_idx(data, 0, 3, false)?;
        if extended {
            return Err(per_codec_error_new("CHOICE additions not implemented"));
        }
        match idx {
            0 => Ok(Self::IPv4Address(decode::decode_bitstring(
                data,
                Some(32),
                Some(32),
                false,
            )?)),
            1 => Ok(Self::IPv6Address(decode::decode_bitstring(
                data,
                Some(128),
                Some(128),
                false,
            )?)),
            2 => Ok(Self::IPv6Prefix(decode::decode_bitstring(
                data,
                Some(64),
                Some(64),
                false,
            )?)),
            3 => {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _ = Criticality::decode(data)?;
                let _ = decode::decode_length_determinent(data, None, None, false)?;
                let result = match id {
                    x => Err(per_codec_error_new(format!("Unrecognised IE type {}", x))),
                };
                data.decode_align()?;
                result
            }
            _ => Err(per_codec_error_new("Unknown choice idx")),
        }
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        match self {
            Self::IPv4Address(x) => {
                encode::encode_choice_idx(data, 0, 3, false, 0, false)?;
                encode::encode_bitstring(data, Some(32), Some(32), false, &x, false)
            }
            Self::IPv6Address(x) => {
                encode::encode_choice_idx(data, 0, 3, false, 1, false)?;
                encode::encode_bitstring(data, Some(128), Some(128), false, &x, false)
            }
            Self::IPv6Prefix(x) => {
                encode::encode_choice_idx(data, 0, 3, false, 2, false)?;
                encode::encode_bitstring(data, Some(64), Some(64), false, &x, false)
            }
        }
    }
}

impl PerCodec for IabtnlAddress {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        IabtnlAddress::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("IabtnlAddress");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("IabtnlAddress");
            e
        })
    }
}
// IabtnlAddressesRequested
#[derive(Clone, Debug)]
pub struct IabtnlAddressesRequested {
    pub tnl_addresses_or_prefixes_requested_all_traffic: Option<u16>,
    pub tnl_addresses_or_prefixes_requested_f1_c: Option<u16>,
    pub tnl_addresses_or_prefixes_requested_f1_u: Option<u16>,
    pub tnl_addresses_or_prefixes_requested_no_nf1: Option<u16>,
}

impl IabtnlAddressesRequested {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, false, 5)?;
        let tnl_addresses_or_prefixes_requested_all_traffic = if optionals[0] {
            Some(decode::decode_integer(data, Some(1), Some(256), false)?.0 as u16)
        } else {
            None
        };
        let tnl_addresses_or_prefixes_requested_f1_c = if optionals[1] {
            Some(decode::decode_integer(data, Some(1), Some(256), false)?.0 as u16)
        } else {
            None
        };
        let tnl_addresses_or_prefixes_requested_f1_u = if optionals[2] {
            Some(decode::decode_integer(data, Some(1), Some(256), false)?.0 as u16)
        } else {
            None
        };
        let tnl_addresses_or_prefixes_requested_no_nf1 = if optionals[3] {
            Some(decode::decode_integer(data, Some(1), Some(256), false)?.0 as u16)
        } else {
            None
        };

        // Process the extension container

        if optionals[4] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            tnl_addresses_or_prefixes_requested_all_traffic,
            tnl_addresses_or_prefixes_requested_f1_c,
            tnl_addresses_or_prefixes_requested_f1_u,
            tnl_addresses_or_prefixes_requested_no_nf1,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(
            self.tnl_addresses_or_prefixes_requested_all_traffic
                .is_some(),
        );
        optionals.push(self.tnl_addresses_or_prefixes_requested_f1_c.is_some());
        optionals.push(self.tnl_addresses_or_prefixes_requested_f1_u.is_some());
        optionals.push(self.tnl_addresses_or_prefixes_requested_no_nf1.is_some());
        optionals.push(false);

        encode::encode_sequence_header(data, false, &optionals, false)?;
        if let Some(x) = &self.tnl_addresses_or_prefixes_requested_all_traffic {
            encode::encode_integer(data, Some(1), Some(256), false, *x as i128, false)?;
        }
        if let Some(x) = &self.tnl_addresses_or_prefixes_requested_f1_c {
            encode::encode_integer(data, Some(1), Some(256), false, *x as i128, false)?;
        }
        if let Some(x) = &self.tnl_addresses_or_prefixes_requested_f1_u {
            encode::encode_integer(data, Some(1), Some(256), false, *x as i128, false)?;
        }
        if let Some(x) = &self.tnl_addresses_or_prefixes_requested_no_nf1 {
            encode::encode_integer(data, Some(1), Some(256), false, *x as i128, false)?;
        }

        Ok(())
    }
}

impl PerCodec for IabtnlAddressesRequested {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        IabtnlAddressesRequested::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("IabtnlAddressesRequested");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("IabtnlAddressesRequested");
            e
        })
    }
}
// IabTnlAddressesToRemoveItem
#[derive(Clone, Debug)]
pub struct IabTnlAddressesToRemoveItem {
    pub iabtnl_address: IabtnlAddress,
}

impl IabTnlAddressesToRemoveItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, false, 1)?;
        let iabtnl_address = IabtnlAddress::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self { iabtnl_address })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, false, &optionals, false)?;
        self.iabtnl_address.encode(data)?;

        Ok(())
    }
}

impl PerCodec for IabTnlAddressesToRemoveItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        IabTnlAddressesToRemoveItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("IabTnlAddressesToRemoveItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("IabTnlAddressesToRemoveItem");
            e
        })
    }
}
// IabTnlAddressesException
#[derive(Clone, Debug)]
pub struct IabTnlAddressesException {
    pub iabtnl_address_list: IabtnlAddressList,
}

impl IabTnlAddressesException {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, false, 1)?;
        let iabtnl_address_list = IabtnlAddressList::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            iabtnl_address_list,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, false, &optionals, false)?;
        self.iabtnl_address_list.encode(data)?;

        Ok(())
    }
}

impl PerCodec for IabTnlAddressesException {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        IabTnlAddressesException::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("IabTnlAddressesException");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("IabTnlAddressesException");
            e
        })
    }
}
// IabtnlAddressList
#[derive(Clone, Debug)]
pub struct IabtnlAddressList(pub NonEmpty<IabtnlAddressItem>);

impl IabtnlAddressList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(1024), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(IabtnlAddressItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(1024), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for IabtnlAddressList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        IabtnlAddressList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("IabtnlAddressList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("IabtnlAddressList");
            e
        })
    }
}
// IabtnlAddressItem
#[derive(Clone, Debug)]
pub struct IabtnlAddressItem {
    pub iabtnl_address: IabtnlAddress,
}

impl IabtnlAddressItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, false, 1)?;
        let iabtnl_address = IabtnlAddress::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self { iabtnl_address })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, false, &optionals, false)?;
        self.iabtnl_address.encode(data)?;

        Ok(())
    }
}

impl PerCodec for IabtnlAddressItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        IabtnlAddressItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("IabtnlAddressItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("IabtnlAddressItem");
            e
        })
    }
}
// IabtnlAddressUsage
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum IabtnlAddressUsage {
    F1C,
    F1U,
    NonF1,
}

impl IabtnlAddressUsage {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(2), true)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(2),
            true,
            *self as i128,
            (*self as u32) >= 3,
        )
    }
}

impl PerCodec for IabtnlAddressUsage {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        IabtnlAddressUsage::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("IabtnlAddressUsage");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("IabtnlAddressUsage");
            e
        })
    }
}
// IaBv4AddressesRequested
#[derive(Clone, Debug)]
pub struct IaBv4AddressesRequested {
    pub ia_bv_4_addresses_requested: IabtnlAddressesRequested,
}

impl IaBv4AddressesRequested {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, false, 1)?;
        let ia_bv_4_addresses_requested = IabtnlAddressesRequested::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            ia_bv_4_addresses_requested,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, false, &optionals, false)?;
        self.ia_bv_4_addresses_requested.encode(data)?;

        Ok(())
    }
}

impl PerCodec for IaBv4AddressesRequested {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        IaBv4AddressesRequested::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("IaBv4AddressesRequested");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("IaBv4AddressesRequested");
            e
        })
    }
}
// MobileIabMtUserLocationInformation
#[derive(Clone, Debug)]
pub struct MobileIabMtUserLocationInformation {
    pub nr_cgi: NrCgi,
    pub tai: Tai,
}

impl MobileIabMtUserLocationInformation {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, false, 1)?;
        let nr_cgi = NrCgi::decode(data)?;
        let tai = Tai::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self { nr_cgi, tai })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, false, &optionals, false)?;
        self.nr_cgi.encode(data)?;
        self.tai.encode(data)?;

        Ok(())
    }
}

impl PerCodec for MobileIabMtUserLocationInformation {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        MobileIabMtUserLocationInformation::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MobileIabMtUserLocationInformation");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MobileIabMtUserLocationInformation");
            e
        })
    }
}
// ImplicitFormat
#[derive(Clone, Debug)]
pub struct ImplicitFormat {
    pub du_f_slotformat_index: DuFSlotformatIndex,
}

impl ImplicitFormat {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, false, 1)?;
        let du_f_slotformat_index = DuFSlotformatIndex::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            du_f_slotformat_index,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, false, &optionals, false)?;
        self.du_f_slotformat_index.encode(data)?;

        Ok(())
    }
}

impl PerCodec for ImplicitFormat {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        ImplicitFormat::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ImplicitFormat");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ImplicitFormat");
            e
        })
    }
}
// IgnorePrachConfiguration
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum IgnorePrachConfiguration {
    True,
}

impl IgnorePrachConfiguration {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(0), true)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(0),
            true,
            *self as i128,
            (*self as u32) >= 1,
        )
    }
}

impl PerCodec for IgnorePrachConfiguration {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        IgnorePrachConfiguration::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("IgnorePrachConfiguration");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("IgnorePrachConfiguration");
            e
        })
    }
}
// IgnoreResourceCoordinationContainer
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum IgnoreResourceCoordinationContainer {
    Yes,
}

impl IgnoreResourceCoordinationContainer {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(0), true)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(0),
            true,
            *self as i128,
            (*self as u32) >= 1,
        )
    }
}

impl PerCodec for IgnoreResourceCoordinationContainer {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        IgnoreResourceCoordinationContainer::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("IgnoreResourceCoordinationContainer");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("IgnoreResourceCoordinationContainer");
            e
        })
    }
}
// InactivityMonitoringRequest
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum InactivityMonitoringRequest {
    True,
}

impl InactivityMonitoringRequest {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(0), true)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(0),
            true,
            *self as i128,
            (*self as u32) >= 1,
        )
    }
}

impl PerCodec for InactivityMonitoringRequest {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        InactivityMonitoringRequest::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("InactivityMonitoringRequest");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("InactivityMonitoringRequest");
            e
        })
    }
}
// InactivityMonitoringResponse
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum InactivityMonitoringResponse {
    NotSupported,
}

impl InactivityMonitoringResponse {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(0), true)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(0),
            true,
            *self as i128,
            (*self as u32) >= 1,
        )
    }
}

impl PerCodec for InactivityMonitoringResponse {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        InactivityMonitoringResponse::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("InactivityMonitoringResponse");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("InactivityMonitoringResponse");
            e
        })
    }
}
// IndirectPathAddition
#[derive(Clone, Debug)]
pub struct IndirectPathAddition {
    pub target_relay_ue_id: BitString,
    pub remote_ue_local_id: RemoteUeLocalId,
}

impl IndirectPathAddition {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let target_relay_ue_id = decode::decode_bitstring(data, Some(24), Some(24), false)?;
        let remote_ue_local_id = RemoteUeLocalId::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            target_relay_ue_id,
            remote_ue_local_id,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        encode::encode_bitstring(
            data,
            Some(24),
            Some(24),
            false,
            &self.target_relay_ue_id,
            false,
        )?;
        self.remote_ue_local_id.encode(data)?;

        Ok(())
    }
}

impl PerCodec for IndirectPathAddition {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        IndirectPathAddition::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("IndirectPathAddition");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("IndirectPathAddition");
            e
        })
    }
}
// InterfacesToTrace
#[derive(Clone, Debug)]
pub struct InterfacesToTrace(pub BitString);

impl InterfacesToTrace {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(decode::decode_bitstring(
            data,
            Some(8),
            Some(8),
            false,
        )?))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_bitstring(data, Some(8), Some(8), false, &self.0, false)
    }
}

impl PerCodec for InterfacesToTrace {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        InterfacesToTrace::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("InterfacesToTrace");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("InterfacesToTrace");
            e
        })
    }
}
// IntendedTddDlUlConfig
#[derive(Clone, Debug)]
pub struct IntendedTddDlUlConfig {
    pub nr_scs: NrScs1,
    pub nr_cp: NrCp,
    pub nr_dl_ul_tx_periodicity: NrDlUlTxPeriodicity,
    pub slot_configuration_list: SlotConfigurationList,
}

impl IntendedTddDlUlConfig {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, false, 1)?;
        let nr_scs = NrScs1::decode(data)?;
        let nr_cp = NrCp::decode(data)?;
        let nr_dl_ul_tx_periodicity = NrDlUlTxPeriodicity::decode(data)?;
        let slot_configuration_list = SlotConfigurationList::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            nr_scs,
            nr_cp,
            nr_dl_ul_tx_periodicity,
            slot_configuration_list,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, false, &optionals, false)?;
        self.nr_scs.encode(data)?;
        self.nr_cp.encode(data)?;
        self.nr_dl_ul_tx_periodicity.encode(data)?;
        self.slot_configuration_list.encode(data)?;

        Ok(())
    }
}

impl PerCodec for IntendedTddDlUlConfig {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        IntendedTddDlUlConfig::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("IntendedTddDlUlConfig");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("IntendedTddDlUlConfig");
            e
        })
    }
}
// InterFrequencyConfigNoGap
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum InterFrequencyConfigNoGap {
    True,
}

impl InterFrequencyConfigNoGap {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(0), true)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(0),
            true,
            *self as i128,
            (*self as u32) >= 1,
        )
    }
}

impl PerCodec for InterFrequencyConfigNoGap {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        InterFrequencyConfigNoGap::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("InterFrequencyConfigNoGap");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("InterFrequencyConfigNoGap");
            e
        })
    }
}
// IngressNonF1terminatingTopologyIndicator
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum IngressNonF1terminatingTopologyIndicator {
    True,
}

impl IngressNonF1terminatingTopologyIndicator {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(0), true)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(0),
            true,
            *self as i128,
            (*self as u32) >= 1,
        )
    }
}

impl PerCodec for IngressNonF1terminatingTopologyIndicator {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        IngressNonF1terminatingTopologyIndicator::decode_inner(data).map_err(
            |mut e: PerCodecError| {
                e.push_context("IngressNonF1terminatingTopologyIndicator");
                e
            },
        )
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("IngressNonF1terminatingTopologyIndicator");
            e
        })
    }
}
// IndicationMcInactiveReception
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum IndicationMcInactiveReception {
    True,
}

impl IndicationMcInactiveReception {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(0), true)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(0),
            true,
            *self as i128,
            (*self as u32) >= 1,
        )
    }
}

impl PerCodec for IndicationMcInactiveReception {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        IndicationMcInactiveReception::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("IndicationMcInactiveReception");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("IndicationMcInactiveReception");
            e
        })
    }
}
// LtmResetInformation
#[derive(Clone, Debug)]
pub struct LtmResetInformation {
    pub serving_cell_l2_reset_configuration: Option<Vec<u8>>,
    pub ltml2_reset_configuration_list: Option<Ltml2ResetConfigurationList>,
}

impl LtmResetInformation {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 3)?;
        let serving_cell_l2_reset_configuration = if optionals[0] {
            Some(decode::decode_octetstring(data, None, None, false)?)
        } else {
            None
        };
        let ltml2_reset_configuration_list = if optionals[1] {
            Some(Ltml2ResetConfigurationList::decode(data)?)
        } else {
            None
        };

        // Process the extension container

        if optionals[2] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            serving_cell_l2_reset_configuration,
            ltml2_reset_configuration_list,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.serving_cell_l2_reset_configuration.is_some());
        optionals.push(self.ltml2_reset_configuration_list.is_some());
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        if let Some(x) = &self.serving_cell_l2_reset_configuration {
            encode::encode_octetstring(data, None, None, false, &x, false)?;
        }
        if let Some(x) = &self.ltml2_reset_configuration_list {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl PerCodec for LtmResetInformation {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        LtmResetInformation::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("LtmResetInformation");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("LtmResetInformation");
            e
        })
    }
}
// Ltml2ResetConfigurationList
#[derive(Clone, Debug)]
pub struct Ltml2ResetConfigurationList(pub NonEmpty<Ltml2ResetConfigurationItem>);

impl Ltml2ResetConfigurationList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(8), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(Ltml2ResetConfigurationItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(8), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for Ltml2ResetConfigurationList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ltml2ResetConfigurationList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("Ltml2ResetConfigurationList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("Ltml2ResetConfigurationList");
            e
        })
    }
}
// Ltml2ResetConfigurationItem
#[derive(Clone, Debug)]
pub struct Ltml2ResetConfigurationItem {
    pub cell_id: NrCgi,
    pub ltm_l2_reset_configuration: Vec<u8>,
}

impl Ltml2ResetConfigurationItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, false, 1)?;
        let cell_id = NrCgi::decode(data)?;
        let ltm_l2_reset_configuration = decode::decode_octetstring(data, None, None, false)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            cell_id,
            ltm_l2_reset_configuration,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, false, &optionals, false)?;
        self.cell_id.encode(data)?;
        encode::encode_octetstring(
            data,
            None,
            None,
            false,
            &self.ltm_l2_reset_configuration,
            false,
        )?;

        Ok(())
    }
}

impl PerCodec for Ltml2ResetConfigurationItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ltml2ResetConfigurationItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("Ltml2ResetConfigurationItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("Ltml2ResetConfigurationItem");
            e
        })
    }
}
// IpHeaderInformation
#[derive(Clone, Debug)]
pub struct IpHeaderInformation {
    pub destination_iabtnl_address: IabtnlAddress,
    pub ds_information_list: Option<DsInformationList>,
    pub i_pv_6_flow_label: Option<BitString>,
}

impl IpHeaderInformation {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 3)?;
        let destination_iabtnl_address = IabtnlAddress::decode(data)?;
        let ds_information_list = if optionals[0] {
            Some(DsInformationList::decode(data)?)
        } else {
            None
        };
        let i_pv_6_flow_label = if optionals[1] {
            Some(decode::decode_bitstring(data, Some(20), Some(20), false)?)
        } else {
            None
        };

        // Process the extension container

        if optionals[2] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            destination_iabtnl_address,
            ds_information_list,
            i_pv_6_flow_label,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.ds_information_list.is_some());
        optionals.push(self.i_pv_6_flow_label.is_some());
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.destination_iabtnl_address.encode(data)?;
        if let Some(x) = &self.ds_information_list {
            x.encode(data)?;
        }
        if let Some(x) = &self.i_pv_6_flow_label {
            encode::encode_bitstring(data, Some(20), Some(20), false, &x, false)?;
        }

        Ok(())
    }
}

impl PerCodec for IpHeaderInformation {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        IpHeaderInformation::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("IpHeaderInformation");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("IpHeaderInformation");
            e
        })
    }
}
// IPtolayer2TrafficMappingInfo
#[derive(Clone, Debug)]
pub struct IPtolayer2TrafficMappingInfo {
    pub i_ptolayer_2_traffic_mapping_info_to_add: Option<IPtolayer2TrafficMappingInfoList>,
    pub i_ptolayer_2_traffic_mapping_info_to_remove: Option<MappingInformationtoRemove>,
}

impl IPtolayer2TrafficMappingInfo {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 3)?;
        let i_ptolayer_2_traffic_mapping_info_to_add = if optionals[0] {
            Some(IPtolayer2TrafficMappingInfoList::decode(data)?)
        } else {
            None
        };
        let i_ptolayer_2_traffic_mapping_info_to_remove = if optionals[1] {
            Some(MappingInformationtoRemove::decode(data)?)
        } else {
            None
        };

        // Process the extension container

        if optionals[2] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            i_ptolayer_2_traffic_mapping_info_to_add,
            i_ptolayer_2_traffic_mapping_info_to_remove,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.i_ptolayer_2_traffic_mapping_info_to_add.is_some());
        optionals.push(self.i_ptolayer_2_traffic_mapping_info_to_remove.is_some());
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        if let Some(x) = &self.i_ptolayer_2_traffic_mapping_info_to_add {
            x.encode(data)?;
        }
        if let Some(x) = &self.i_ptolayer_2_traffic_mapping_info_to_remove {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl PerCodec for IPtolayer2TrafficMappingInfo {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        IPtolayer2TrafficMappingInfo::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("IPtolayer2TrafficMappingInfo");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("IPtolayer2TrafficMappingInfo");
            e
        })
    }
}
// IPtolayer2TrafficMappingInfoList
#[derive(Clone, Debug)]
pub struct IPtolayer2TrafficMappingInfoList(pub NonEmpty<IPtolayer2TrafficMappingInfoItem>);

impl IPtolayer2TrafficMappingInfoList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(67108864), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(IPtolayer2TrafficMappingInfoItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(67108864), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for IPtolayer2TrafficMappingInfoList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        IPtolayer2TrafficMappingInfoList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("IPtolayer2TrafficMappingInfoList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("IPtolayer2TrafficMappingInfoList");
            e
        })
    }
}
// IPtolayer2TrafficMappingInfoItem
#[derive(Clone, Debug)]
pub struct IPtolayer2TrafficMappingInfoItem {
    pub mapping_information_index: MappingInformationIndex,
    pub ip_header_information: IpHeaderInformation,
    pub bh_info: BhInfo,
}

impl IPtolayer2TrafficMappingInfoItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let mapping_information_index = MappingInformationIndex::decode(data)?;
        let ip_header_information = IpHeaderInformation::decode(data)?;
        let bh_info = BhInfo::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            mapping_information_index,
            ip_header_information,
            bh_info,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.mapping_information_index.encode(data)?;
        self.ip_header_information.encode(data)?;
        self.bh_info.encode(data)?;

        Ok(())
    }
}

impl PerCodec for IPtolayer2TrafficMappingInfoItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        IPtolayer2TrafficMappingInfoItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("IPtolayer2TrafficMappingInfoItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("IPtolayer2TrafficMappingInfoItem");
            e
        })
    }
}
// JointorDlTciStateId
#[derive(Clone, Debug)]
pub struct JointorDlTciStateId(pub Vec<u8>);

impl JointorDlTciStateId {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(decode::decode_octetstring(data, None, None, false)?))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_octetstring(data, None, None, false, &self.0, false)
    }
}

impl PerCodec for JointorDlTciStateId {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        JointorDlTciStateId::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("JointorDlTciStateId");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("JointorDlTciStateId");
            e
        })
    }
}
// Ltea2xServicesAuthorized
#[derive(Clone, Debug)]
pub struct Ltea2xServicesAuthorized {
    pub aerial_ue: Option<AerialUe>,
    pub controller_ue: Option<ControllerUe>,
}

impl Ltea2xServicesAuthorized {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, false, 3)?;
        let aerial_ue = if optionals[0] {
            Some(AerialUe::decode(data)?)
        } else {
            None
        };
        let controller_ue = if optionals[1] {
            Some(ControllerUe::decode(data)?)
        } else {
            None
        };

        // Process the extension container

        if optionals[2] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            aerial_ue,
            controller_ue,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.aerial_ue.is_some());
        optionals.push(self.controller_ue.is_some());
        optionals.push(false);

        encode::encode_sequence_header(data, false, &optionals, false)?;
        if let Some(x) = &self.aerial_ue {
            x.encode(data)?;
        }
        if let Some(x) = &self.controller_ue {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl PerCodec for Ltea2xServicesAuthorized {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ltea2xServicesAuthorized::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("Ltea2xServicesAuthorized");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("Ltea2xServicesAuthorized");
            e
        })
    }
}
// L139Info
#[derive(Clone, Debug)]
pub struct L139Info {
    pub prach_scs: PrachScs,
    pub root_sequence_index: Option<u8>,
}

impl L139Info {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 2)?;
        let prach_scs = PrachScs::decode(data)?;
        let root_sequence_index = if optionals[0] {
            Some(decode::decode_integer(data, Some(0), Some(137), false)?.0 as u8)
        } else {
            None
        };

        // Process the extension container

        if optionals[1] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            prach_scs,
            root_sequence_index,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.root_sequence_index.is_some());
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.prach_scs.encode(data)?;
        if let Some(x) = &self.root_sequence_index {
            encode::encode_integer(data, Some(0), Some(137), false, *x as i128, false)?;
        }

        Ok(())
    }
}

impl PerCodec for L139Info {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        L139Info::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("L139Info");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("L139Info");
            e
        })
    }
}
// L839Info
#[derive(Clone, Debug)]
pub struct L839Info {
    pub root_sequence_index: u16,
    pub restricted_set_config: RestrictedSetConfig,
}

impl L839Info {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let root_sequence_index = decode::decode_integer(data, Some(0), Some(837), false)?.0 as u16;
        let restricted_set_config = RestrictedSetConfig::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            root_sequence_index,
            restricted_set_config,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        encode::encode_integer(
            data,
            Some(0),
            Some(837),
            false,
            self.root_sequence_index as i128,
            false,
        )?;
        self.restricted_set_config.encode(data)?;

        Ok(())
    }
}

impl PerCodec for L839Info {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        L839Info::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("L839Info");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("L839Info");
            e
        })
    }
}
// L571Info
#[derive(Clone, Debug)]
pub struct L571Info {
    pub prach_scs_for_l571: PrachScsForL571,
    pub root_sequence_index: u16,
}

impl L571Info {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let prach_scs_for_l571 = PrachScsForL571::decode(data)?;
        let root_sequence_index = decode::decode_integer(data, Some(0), Some(569), false)?.0 as u16;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            prach_scs_for_l571,
            root_sequence_index,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.prach_scs_for_l571.encode(data)?;
        encode::encode_integer(
            data,
            Some(0),
            Some(569),
            false,
            self.root_sequence_index as i128,
            false,
        )?;

        Ok(())
    }
}

impl PerCodec for L571Info {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        L571Info::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("L571Info");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("L571Info");
            e
        })
    }
}
// L1151Info
#[derive(Clone, Debug)]
pub struct L1151Info {
    pub prach_scs_for_l1151: PrachScsForL1151,
    pub root_sequence_index: u16,
}

impl L1151Info {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let prach_scs_for_l1151 = PrachScsForL1151::decode(data)?;
        let root_sequence_index =
            decode::decode_integer(data, Some(0), Some(1149), false)?.0 as u16;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            prach_scs_for_l1151,
            root_sequence_index,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.prach_scs_for_l1151.encode(data)?;
        encode::encode_integer(
            data,
            Some(0),
            Some(1149),
            false,
            self.root_sequence_index as i128,
            false,
        )?;

        Ok(())
    }
}

impl PerCodec for L1151Info {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        L1151Info::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("L1151Info");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("L1151Info");
            e
        })
    }
}
// LastUsedCellIndication
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum LastUsedCellIndication {
    True,
}

impl LastUsedCellIndication {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(0), true)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(0),
            true,
            *self as i128,
            (*self as u32) >= 1,
        )
    }
}

impl PerCodec for LastUsedCellIndication {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        LastUsedCellIndication::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("LastUsedCellIndication");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("LastUsedCellIndication");
            e
        })
    }
}
// Lcid
#[derive(Clone, Copy, Debug)]
pub struct Lcid(pub u8);

impl Lcid {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(
            decode::decode_integer(data, Some(1), Some(32), true)?.0 as u8,
        ))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_integer(data, Some(1), Some(32), true, self.0 as i128, false)
    }
}

impl PerCodec for Lcid {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Lcid::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("Lcid");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("Lcid");
            e
        })
    }
}
// LcsToGcsTranslation
#[derive(Clone, Debug)]
pub struct LcsToGcsTranslation {
    pub alpha: u16,
    pub beta: u16,
    pub gamma: u16,
}

impl LcsToGcsTranslation {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let alpha = decode::decode_integer(data, Some(0), Some(3599), false)?.0 as u16;
        let beta = decode::decode_integer(data, Some(0), Some(3599), false)?.0 as u16;
        let gamma = decode::decode_integer(data, Some(0), Some(3599), false)?.0 as u16;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self { alpha, beta, gamma })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        encode::encode_integer(data, Some(0), Some(3599), false, self.alpha as i128, false)?;
        encode::encode_integer(data, Some(0), Some(3599), false, self.beta as i128, false)?;
        encode::encode_integer(data, Some(0), Some(3599), false, self.gamma as i128, false)?;

        Ok(())
    }
}

impl PerCodec for LcsToGcsTranslation {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        LcsToGcsTranslation::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("LcsToGcsTranslation");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("LcsToGcsTranslation");
            e
        })
    }
}
// LcStoGcsTranslationList
#[derive(Clone, Debug)]
pub struct LcStoGcsTranslationList(pub NonEmpty<LcStoGcsTranslation>);

impl LcStoGcsTranslationList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(3), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(LcStoGcsTranslation::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(3), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for LcStoGcsTranslationList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        LcStoGcsTranslationList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("LcStoGcsTranslationList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("LcStoGcsTranslationList");
            e
        })
    }
}
// LcStoGcsTranslation
#[derive(Clone, Debug)]
pub struct LcStoGcsTranslation {
    pub alpha: u16,
    pub alpha_fine: Option<u8>,
    pub beta: u16,
    pub beta_fine: Option<u8>,
    pub gamma: u16,
    pub gamma_fine: Option<u8>,
}

impl LcStoGcsTranslation {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, false, 4)?;
        let alpha = decode::decode_integer(data, Some(0), Some(359), false)?.0 as u16;
        let alpha_fine = if optionals[0] {
            Some(decode::decode_integer(data, Some(0), Some(9), false)?.0 as u8)
        } else {
            None
        };
        let beta = decode::decode_integer(data, Some(0), Some(359), false)?.0 as u16;
        let beta_fine = if optionals[1] {
            Some(decode::decode_integer(data, Some(0), Some(9), false)?.0 as u8)
        } else {
            None
        };
        let gamma = decode::decode_integer(data, Some(0), Some(359), false)?.0 as u16;
        let gamma_fine = if optionals[2] {
            Some(decode::decode_integer(data, Some(0), Some(9), false)?.0 as u8)
        } else {
            None
        };

        // Process the extension container

        if optionals[3] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            alpha,
            alpha_fine,
            beta,
            beta_fine,
            gamma,
            gamma_fine,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.alpha_fine.is_some());
        optionals.push(self.beta_fine.is_some());
        optionals.push(self.gamma_fine.is_some());
        optionals.push(false);

        encode::encode_sequence_header(data, false, &optionals, false)?;
        encode::encode_integer(data, Some(0), Some(359), false, self.alpha as i128, false)?;
        if let Some(x) = &self.alpha_fine {
            encode::encode_integer(data, Some(0), Some(9), false, *x as i128, false)?;
        }
        encode::encode_integer(data, Some(0), Some(359), false, self.beta as i128, false)?;
        if let Some(x) = &self.beta_fine {
            encode::encode_integer(data, Some(0), Some(9), false, *x as i128, false)?;
        }
        encode::encode_integer(data, Some(0), Some(359), false, self.gamma as i128, false)?;
        if let Some(x) = &self.gamma_fine {
            encode::encode_integer(data, Some(0), Some(9), false, *x as i128, false)?;
        }

        Ok(())
    }
}

impl PerCodec for LcStoGcsTranslation {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        LcStoGcsTranslation::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("LcStoGcsTranslation");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("LcStoGcsTranslation");
            e
        })
    }
}
// LmfMeasurementId
#[derive(Clone, Copy, Debug)]
pub struct LmfMeasurementId(pub u32);

impl LmfMeasurementId {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(
            decode::decode_integer(data, Some(1), Some(65536), true)?.0 as u32,
        ))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_integer(data, Some(1), Some(65536), true, self.0 as i128, false)
    }
}

impl PerCodec for LmfMeasurementId {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        LmfMeasurementId::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("LmfMeasurementId");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("LmfMeasurementId");
            e
        })
    }
}
// LmfUeMeasurementId
#[derive(Clone, Copy, Debug)]
pub struct LmfUeMeasurementId(pub u16);

impl LmfUeMeasurementId {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(
            decode::decode_integer(data, Some(1), Some(256), true)?.0 as u16,
        ))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_integer(data, Some(1), Some(256), true, self.0 as i128, false)
    }
}

impl PerCodec for LmfUeMeasurementId {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        LmfUeMeasurementId::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("LmfUeMeasurementId");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("LmfUeMeasurementId");
            e
        })
    }
}
// LocationDependentMbsf1uInformation
#[derive(Clone, Debug)]
pub struct LocationDependentMbsf1uInformation(pub NonEmpty<LocationDependentMbsf1uInformationItem>);

impl LocationDependentMbsf1uInformation {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(256), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(LocationDependentMbsf1uInformationItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(256), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for LocationDependentMbsf1uInformation {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        LocationDependentMbsf1uInformation::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("LocationDependentMbsf1uInformation");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("LocationDependentMbsf1uInformation");
            e
        })
    }
}
// LocationDependentMbsf1uInformationItem
#[derive(Clone, Debug)]
pub struct LocationDependentMbsf1uInformationItem {
    pub mbs_area_session_id: MbsAreaSessionId,
    pub mbs_f1u_info_at_cu: UpTransportLayerInformation,
    pub f1u_tunnel_not_established: Option<F1uTunnelNotEstablished>,
}

impl LocationDependentMbsf1uInformationItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let mbs_area_session_id = MbsAreaSessionId::decode(data)?;
        let mbs_f1u_info_at_cu = UpTransportLayerInformation::decode(data)?;

        // Process the extension container
        let mut f1u_tunnel_not_established: Option<F1uTunnelNotEstablished> = None;

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    771 => {
                        f1u_tunnel_not_established = Some(F1uTunnelNotEstablished::decode(data)?)
                    }
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            mbs_area_session_id,
            mbs_f1u_info_at_cu,
            f1u_tunnel_not_established,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();
        if let Some(x) = &self.f1u_tunnel_not_established {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 771, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        let mut optionals = BitString::new();
        optionals.push(num_ies != 0);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.mbs_area_session_id.encode(data)?;
        self.mbs_f1u_info_at_cu.encode(data)?;
        if num_ies != 0 {
            encode::encode_length_determinent(data, Some(1), Some(65535), false, num_ies)?;
            data.append_aligned(ies);
        }
        Ok(())
    }
}

impl PerCodec for LocationDependentMbsf1uInformationItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        LocationDependentMbsf1uInformationItem::decode_inner(data).map_err(
            |mut e: PerCodecError| {
                e.push_context("LocationDependentMbsf1uInformationItem");
                e
            },
        )
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("LocationDependentMbsf1uInformationItem");
            e
        })
    }
}
// LocationMeasurementInformation
#[derive(Clone, Debug)]
pub struct LocationMeasurementInformation(pub Vec<u8>);

impl LocationMeasurementInformation {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(decode::decode_octetstring(data, None, None, false)?))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_octetstring(data, None, None, false, &self.0, false)
    }
}

impl PerCodec for LocationMeasurementInformation {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        LocationMeasurementInformation::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("LocationMeasurementInformation");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("LocationMeasurementInformation");
            e
        })
    }
}
// LocationUncertainty
#[derive(Clone, Debug)]
pub struct LocationUncertainty {
    pub horizontal_uncertainty: u8,
    pub horizontal_confidence: u8,
    pub vertical_uncertainty: u8,
    pub vertical_confidence: u8,
}

impl LocationUncertainty {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, false, 1)?;
        let horizontal_uncertainty =
            decode::decode_integer(data, Some(0), Some(255), false)?.0 as u8;
        let horizontal_confidence =
            decode::decode_integer(data, Some(0), Some(100), false)?.0 as u8;
        let vertical_uncertainty = decode::decode_integer(data, Some(0), Some(255), false)?.0 as u8;
        let vertical_confidence = decode::decode_integer(data, Some(0), Some(100), false)?.0 as u8;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            horizontal_uncertainty,
            horizontal_confidence,
            vertical_uncertainty,
            vertical_confidence,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, false, &optionals, false)?;
        encode::encode_integer(
            data,
            Some(0),
            Some(255),
            false,
            self.horizontal_uncertainty as i128,
            false,
        )?;
        encode::encode_integer(
            data,
            Some(0),
            Some(100),
            false,
            self.horizontal_confidence as i128,
            false,
        )?;
        encode::encode_integer(
            data,
            Some(0),
            Some(255),
            false,
            self.vertical_uncertainty as i128,
            false,
        )?;
        encode::encode_integer(
            data,
            Some(0),
            Some(100),
            false,
            self.vertical_confidence as i128,
            false,
        )?;

        Ok(())
    }
}

impl PerCodec for LocationUncertainty {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        LocationUncertainty::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("LocationUncertainty");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("LocationUncertainty");
            e
        })
    }
}
// LongDrxCycleLength
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum LongDrxCycleLength {
    Ms10,
    Ms20,
    Ms32,
    Ms40,
    Ms60,
    Ms64,
    Ms70,
    Ms80,
    Ms128,
    Ms160,
    Ms256,
    Ms320,
    Ms512,
    Ms640,
    Ms1024,
    Ms1280,
    Ms2048,
    Ms2560,
    Ms5120,
    Ms10240,
}

impl LongDrxCycleLength {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(19), true)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(19),
            true,
            *self as i128,
            (*self as u32) >= 20,
        )
    }
}

impl PerCodec for LongDrxCycleLength {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        LongDrxCycleLength::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("LongDrxCycleLength");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("LongDrxCycleLength");
            e
        })
    }
}
// LongNonIntegerDrxCycleLength
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum LongNonIntegerDrxCycleLength {
    Ms1001over240,
    Ms25over6,
    Ms25over3,
    Ms1001over120,
    Ms100over9,
    Ms25over2,
    Ms40over3,
    Ms125over9,
    Ms50over3,
    Ms1001over60,
    Ms125over6,
    Ms200over9,
    Ms250over9,
    Ms100over3,
    Ms1001over30,
    Ms75over2,
    Ms125over3,
    Ms1001over24,
    Ms200over3,
    Ms1001over15,
    Ms250over3,
    Ms1001over12,
    Ms400over3,
}

impl LongNonIntegerDrxCycleLength {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(22), true)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(22),
            true,
            *self as i128,
            (*self as u32) >= 23,
        )
    }
}

impl PerCodec for LongNonIntegerDrxCycleLength {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        LongNonIntegerDrxCycleLength::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("LongNonIntegerDrxCycleLength");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("LongNonIntegerDrxCycleLength");
            e
        })
    }
}
// LowerLayerPresenceStatusChange
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum LowerLayerPresenceStatusChange {
    SuspendLowerLayers,
    ResumeLowerLayers,
}

impl LowerLayerPresenceStatusChange {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(1), true)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(1),
            true,
            *self as i128,
            (*self as u32) >= 2,
        )
    }
}

impl PerCodec for LowerLayerPresenceStatusChange {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        LowerLayerPresenceStatusChange::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("LowerLayerPresenceStatusChange");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("LowerLayerPresenceStatusChange");
            e
        })
    }
}
// LoSNLoSIndicatorHard
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum LoSNLoSIndicatorHard {
    NLoS,
    LoS,
}

impl LoSNLoSIndicatorHard {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(1), false)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(1),
            false,
            *self as i128,
            (*self as u32) >= 2,
        )
    }
}

impl PerCodec for LoSNLoSIndicatorHard {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        LoSNLoSIndicatorHard::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("LoSNLoSIndicatorHard");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("LoSNLoSIndicatorHard");
            e
        })
    }
}
// LoSNLoSIndicatorSoft
#[derive(Clone, Copy, Debug)]
pub struct LoSNLoSIndicatorSoft(pub u8);

impl LoSNLoSIndicatorSoft {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(
            decode::decode_integer(data, Some(0), Some(10), false)?.0 as u8,
        ))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_integer(data, Some(0), Some(10), false, self.0 as i128, false)
    }
}

impl PerCodec for LoSNLoSIndicatorSoft {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        LoSNLoSIndicatorSoft::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("LoSNLoSIndicatorSoft");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("LoSNLoSIndicatorSoft");
            e
        })
    }
}
// LoSNLoSInformation
#[derive(Clone, Debug)]
pub enum LoSNLoSInformation {
    LoSNLoSIndicatorSoft(LoSNLoSIndicatorSoft),
    LoSNLoSIndicatorHard(LoSNLoSIndicatorHard),
}

impl LoSNLoSInformation {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_choice_idx(data, 0, 2, false)?;
        if extended {
            return Err(per_codec_error_new("CHOICE additions not implemented"));
        }
        match idx {
            0 => Ok(Self::LoSNLoSIndicatorSoft(LoSNLoSIndicatorSoft::decode(
                data,
            )?)),
            1 => Ok(Self::LoSNLoSIndicatorHard(LoSNLoSIndicatorHard::decode(
                data,
            )?)),
            2 => {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _ = Criticality::decode(data)?;
                let _ = decode::decode_length_determinent(data, None, None, false)?;
                let result = match id {
                    x => Err(per_codec_error_new(format!("Unrecognised IE type {}", x))),
                };
                data.decode_align()?;
                result
            }
            _ => Err(per_codec_error_new("Unknown choice idx")),
        }
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        match self {
            Self::LoSNLoSIndicatorSoft(x) => {
                encode::encode_choice_idx(data, 0, 2, false, 0, false)?;
                x.encode(data)
            }
            Self::LoSNLoSIndicatorHard(x) => {
                encode::encode_choice_idx(data, 0, 2, false, 1, false)?;
                x.encode(data)
            }
        }
    }
}

impl PerCodec for LoSNLoSInformation {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        LoSNLoSInformation::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("LoSNLoSInformation");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("LoSNLoSInformation");
            e
        })
    }
}
// LteUeSidelinkAggregateMaximumBitrate
#[derive(Clone, Debug)]
pub struct LteUeSidelinkAggregateMaximumBitrate {
    pub ue_lte_sidelink_aggregate_maximum_bitrate: BitRate,
}

impl LteUeSidelinkAggregateMaximumBitrate {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, false, 1)?;
        let ue_lte_sidelink_aggregate_maximum_bitrate = BitRate::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            ue_lte_sidelink_aggregate_maximum_bitrate,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, false, &optionals, false)?;
        self.ue_lte_sidelink_aggregate_maximum_bitrate
            .encode(data)?;

        Ok(())
    }
}

impl PerCodec for LteUeSidelinkAggregateMaximumBitrate {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        LteUeSidelinkAggregateMaximumBitrate::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("LteUeSidelinkAggregateMaximumBitrate");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("LteUeSidelinkAggregateMaximumBitrate");
            e
        })
    }
}
// Ltev2xServicesAuthorized
#[derive(Clone, Debug)]
pub struct Ltev2xServicesAuthorized {
    pub vehicle_ue: Option<VehicleUe>,
    pub pedestrian_ue: Option<PedestrianUe>,
}

impl Ltev2xServicesAuthorized {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, false, 3)?;
        let vehicle_ue = if optionals[0] {
            Some(VehicleUe::decode(data)?)
        } else {
            None
        };
        let pedestrian_ue = if optionals[1] {
            Some(PedestrianUe::decode(data)?)
        } else {
            None
        };

        // Process the extension container

        if optionals[2] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            vehicle_ue,
            pedestrian_ue,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.vehicle_ue.is_some());
        optionals.push(self.pedestrian_ue.is_some());
        optionals.push(false);

        encode::encode_sequence_header(data, false, &optionals, false)?;
        if let Some(x) = &self.vehicle_ue {
            x.encode(data)?;
        }
        if let Some(x) = &self.pedestrian_ue {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl PerCodec for Ltev2xServicesAuthorized {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ltev2xServicesAuthorized::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("Ltev2xServicesAuthorized");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("Ltev2xServicesAuthorized");
            e
        })
    }
}
// LtmCellsToBeReleasedList
#[derive(Clone, Debug)]
pub struct LtmCellsToBeReleasedList(pub NonEmpty<LtmCellsToBeReleasedItem>);

impl LtmCellsToBeReleasedList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(8), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(LtmCellsToBeReleasedItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(8), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for LtmCellsToBeReleasedList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        LtmCellsToBeReleasedList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("LtmCellsToBeReleasedList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("LtmCellsToBeReleasedList");
            e
        })
    }
}
// LtmCellsToBeReleasedItem
#[derive(Clone, Debug)]
pub struct LtmCellsToBeReleasedItem {
    pub nr_cgi: NrCgi,
}

impl LtmCellsToBeReleasedItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let nr_cgi = NrCgi::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self { nr_cgi })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.nr_cgi.encode(data)?;

        Ok(())
    }
}

impl PerCodec for LtmCellsToBeReleasedItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        LtmCellsToBeReleasedItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("LtmCellsToBeReleasedItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("LtmCellsToBeReleasedItem");
            e
        })
    }
}
// LtmInformationSetup
#[derive(Clone, Debug)]
pub struct LtmInformationSetup {
    pub ltm_indicator: LtmIndicator,
    pub reference_configuration: Option<ReferenceConfiguration>,
    pub csi_resource_configuration: Option<CsiResourceConfiguration>,
}

impl LtmInformationSetup {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 3)?;
        let ltm_indicator = LtmIndicator::decode(data)?;
        let reference_configuration = if optionals[0] {
            Some(ReferenceConfiguration::decode(data)?)
        } else {
            None
        };
        let csi_resource_configuration = if optionals[1] {
            Some(CsiResourceConfiguration::decode(data)?)
        } else {
            None
        };

        // Process the extension container

        if optionals[2] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            ltm_indicator,
            reference_configuration,
            csi_resource_configuration,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.reference_configuration.is_some());
        optionals.push(self.csi_resource_configuration.is_some());
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.ltm_indicator.encode(data)?;
        if let Some(x) = &self.reference_configuration {
            x.encode(data)?;
        }
        if let Some(x) = &self.csi_resource_configuration {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl PerCodec for LtmInformationSetup {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        LtmInformationSetup::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("LtmInformationSetup");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("LtmInformationSetup");
            e
        })
    }
}
// LtmConfigurationIdMappingList
#[derive(Clone, Debug)]
pub struct LtmConfigurationIdMappingList(pub NonEmpty<LtmConfigurationIdMappingItem>);

impl LtmConfigurationIdMappingList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(8), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(LtmConfigurationIdMappingItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(8), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for LtmConfigurationIdMappingList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        LtmConfigurationIdMappingList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("LtmConfigurationIdMappingList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("LtmConfigurationIdMappingList");
            e
        })
    }
}
// LtmConfigurationIdMappingItem
#[derive(Clone, Debug)]
pub struct LtmConfigurationIdMappingItem {
    pub ltm_cell_id: NrCgi,
    pub ltm_configuration_id: LtmConfigurationId,
}

impl LtmConfigurationIdMappingItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, false, 1)?;
        let ltm_cell_id = NrCgi::decode(data)?;
        let ltm_configuration_id = LtmConfigurationId::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            ltm_cell_id,
            ltm_configuration_id,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, false, &optionals, false)?;
        self.ltm_cell_id.encode(data)?;
        self.ltm_configuration_id.encode(data)?;

        Ok(())
    }
}

impl PerCodec for LtmConfigurationIdMappingItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        LtmConfigurationIdMappingItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("LtmConfigurationIdMappingItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("LtmConfigurationIdMappingItem");
            e
        })
    }
}
// LtmInformationModify
#[derive(Clone, Debug)]
pub struct LtmInformationModify {
    pub ltm_indicator: LtmIndicator,
    pub reference_configuration: Option<ReferenceConfiguration>,
    pub csi_resource_configuration: Option<CsiResourceConfiguration>,
}

impl LtmInformationModify {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 3)?;
        let ltm_indicator = LtmIndicator::decode(data)?;
        let reference_configuration = if optionals[0] {
            Some(ReferenceConfiguration::decode(data)?)
        } else {
            None
        };
        let csi_resource_configuration = if optionals[1] {
            Some(CsiResourceConfiguration::decode(data)?)
        } else {
            None
        };

        // Process the extension container

        if optionals[2] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            ltm_indicator,
            reference_configuration,
            csi_resource_configuration,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.reference_configuration.is_some());
        optionals.push(self.csi_resource_configuration.is_some());
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.ltm_indicator.encode(data)?;
        if let Some(x) = &self.reference_configuration {
            x.encode(data)?;
        }
        if let Some(x) = &self.csi_resource_configuration {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl PerCodec for LtmInformationModify {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        LtmInformationModify::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("LtmInformationModify");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("LtmInformationModify");
            e
        })
    }
}
// LtmIndicator
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum LtmIndicator {
    True,
}

impl LtmIndicator {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(0), true)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(0),
            true,
            *self as i128,
            (*self as u32) >= 1,
        )
    }
}

impl PerCodec for LtmIndicator {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        LtmIndicator::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("LtmIndicator");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("LtmIndicator");
            e
        })
    }
}
// CompleteCandidateConfigurationIndicator
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum CompleteCandidateConfigurationIndicator {
    Complete,
}

impl CompleteCandidateConfigurationIndicator {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(0), true)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(0),
            true,
            *self as i128,
            (*self as u32) >= 1,
        )
    }
}

impl PerCodec for CompleteCandidateConfigurationIndicator {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        CompleteCandidateConfigurationIndicator::decode_inner(data).map_err(
            |mut e: PerCodecError| {
                e.push_context("CompleteCandidateConfigurationIndicator");
                e
            },
        )
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CompleteCandidateConfigurationIndicator");
            e
        })
    }
}
// LtmConfigurationId
#[derive(Clone, Copy, Debug)]
pub struct LtmConfigurationId(pub u8);

impl LtmConfigurationId {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(
            decode::decode_integer(data, Some(1), Some(8), false)?.0 as u8,
        ))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_integer(data, Some(1), Some(8), false, self.0 as i128, false)
    }
}

impl PerCodec for LtmConfigurationId {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        LtmConfigurationId::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("LtmConfigurationId");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("LtmConfigurationId");
            e
        })
    }
}
// ReferenceConfigurationInformation
#[derive(Clone, Debug)]
pub struct ReferenceConfigurationInformation(pub Vec<u8>);

impl ReferenceConfigurationInformation {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(decode::decode_octetstring(data, None, None, false)?))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_octetstring(data, None, None, false, &self.0, false)
    }
}

impl PerCodec for ReferenceConfigurationInformation {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        ReferenceConfigurationInformation::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ReferenceConfigurationInformation");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ReferenceConfigurationInformation");
            e
        })
    }
}
// LtmConfiguration
#[derive(Clone, Debug)]
pub struct LtmConfiguration {
    pub ssb_information: SsbInformation,
    pub reference_configuration_information: Option<ReferenceConfigurationInformation>,
    pub complete_candidate_configuration_indicator: Option<CompleteCandidateConfigurationIndicator>,
    pub ltmcfra_resource_config: Option<LtmcfraResourceConfig>,
    pub ltmcfra_resource_config_sul: Option<LtmcfraResourceConfig>,
}

impl LtmConfiguration {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 5)?;
        let ssb_information = SsbInformation::decode(data)?;
        let reference_configuration_information = if optionals[0] {
            Some(ReferenceConfigurationInformation::decode(data)?)
        } else {
            None
        };
        let complete_candidate_configuration_indicator = if optionals[1] {
            Some(CompleteCandidateConfigurationIndicator::decode(data)?)
        } else {
            None
        };
        let ltmcfra_resource_config = if optionals[2] {
            Some(LtmcfraResourceConfig::decode(data)?)
        } else {
            None
        };
        let ltmcfra_resource_config_sul = if optionals[3] {
            Some(LtmcfraResourceConfig::decode(data)?)
        } else {
            None
        };

        // Process the extension container

        if optionals[4] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            ssb_information,
            reference_configuration_information,
            complete_candidate_configuration_indicator,
            ltmcfra_resource_config,
            ltmcfra_resource_config_sul,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.reference_configuration_information.is_some());
        optionals.push(self.complete_candidate_configuration_indicator.is_some());
        optionals.push(self.ltmcfra_resource_config.is_some());
        optionals.push(self.ltmcfra_resource_config_sul.is_some());
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.ssb_information.encode(data)?;
        if let Some(x) = &self.reference_configuration_information {
            x.encode(data)?;
        }
        if let Some(x) = &self.complete_candidate_configuration_indicator {
            x.encode(data)?;
        }
        if let Some(x) = &self.ltmcfra_resource_config {
            x.encode(data)?;
        }
        if let Some(x) = &self.ltmcfra_resource_config_sul {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl PerCodec for LtmConfiguration {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        LtmConfiguration::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("LtmConfiguration");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("LtmConfiguration");
            e
        })
    }
}
// LtmCellSwitchInformation
#[derive(Clone, Debug)]
pub struct LtmCellSwitchInformation {
    pub jointor_dl_tci_state_id: JointorDlTciStateId,
    pub ultci_state_id: Option<UltciStateId>,
}

impl LtmCellSwitchInformation {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 2)?;
        let jointor_dl_tci_state_id = JointorDlTciStateId::decode(data)?;
        let ultci_state_id = if optionals[0] {
            Some(UltciStateId::decode(data)?)
        } else {
            None
        };

        // Process the extension container

        if optionals[1] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            jointor_dl_tci_state_id,
            ultci_state_id,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.ultci_state_id.is_some());
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.jointor_dl_tci_state_id.encode(data)?;
        if let Some(x) = &self.ultci_state_id {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl PerCodec for LtmCellSwitchInformation {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        LtmCellSwitchInformation::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("LtmCellSwitchInformation");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("LtmCellSwitchInformation");
            e
        })
    }
}
// LtmGnbDuIDsList
#[derive(Clone, Debug)]
pub struct LtmGnbDuIDsList(pub NonEmpty<LtmGnbDuIDsItem>);

impl LtmGnbDuIDsList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(8), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(LtmGnbDuIDsItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(8), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for LtmGnbDuIDsList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        LtmGnbDuIDsList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("LtmGnbDuIDsList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("LtmGnbDuIDsList");
            e
        })
    }
}
// LtmGnbDuIDsItem
#[derive(Clone, Debug)]
pub struct LtmGnbDuIDsItem {
    pub ltm_gnb_du_id: GnbDuId,
}

impl LtmGnbDuIDsItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, false, 1)?;
        let ltm_gnb_du_id = GnbDuId::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self { ltm_gnb_du_id })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, false, &optionals, false)?;
        self.ltm_gnb_du_id.encode(data)?;

        Ok(())
    }
}

impl PerCodec for LtmGnbDuIDsItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        LtmGnbDuIDsItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("LtmGnbDuIDsItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("LtmGnbDuIDsItem");
            e
        })
    }
}
// LtmGnbDuIDsPreambleIndexList
#[derive(Clone, Debug)]
pub struct LtmGnbDuIDsPreambleIndexList(pub NonEmpty<LtmGnbDuIDsPreambleIndexItem>);

impl LtmGnbDuIDsPreambleIndexList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(8), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(LtmGnbDuIDsPreambleIndexItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(8), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for LtmGnbDuIDsPreambleIndexList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        LtmGnbDuIDsPreambleIndexList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("LtmGnbDuIDsPreambleIndexList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("LtmGnbDuIDsPreambleIndexList");
            e
        })
    }
}
// LtmGnbDuIDsPreambleIndexItem
#[derive(Clone, Debug)]
pub struct LtmGnbDuIDsPreambleIndexItem {
    pub ltm_gnb_du_id: GnbDuId,
    pub preamble_index_list: Option<PreambleIndexList>,
}

impl LtmGnbDuIDsPreambleIndexItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, false, 2)?;
        let ltm_gnb_du_id = GnbDuId::decode(data)?;
        let preamble_index_list = if optionals[0] {
            Some(PreambleIndexList::decode(data)?)
        } else {
            None
        };

        // Process the extension container

        if optionals[1] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            ltm_gnb_du_id,
            preamble_index_list,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.preamble_index_list.is_some());
        optionals.push(false);

        encode::encode_sequence_header(data, false, &optionals, false)?;
        self.ltm_gnb_du_id.encode(data)?;
        if let Some(x) = &self.preamble_index_list {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl PerCodec for LtmGnbDuIDsPreambleIndexItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        LtmGnbDuIDsPreambleIndexItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("LtmGnbDuIDsPreambleIndexItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("LtmGnbDuIDsPreambleIndexItem");
            e
        })
    }
}
// LtmcfraResourceConfigList
#[derive(Clone, Debug)]
pub struct LtmcfraResourceConfigList(pub NonEmpty<LtmcfraResourceConfigItem>);

impl LtmcfraResourceConfigList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(8), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(LtmcfraResourceConfigItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(8), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for LtmcfraResourceConfigList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        LtmcfraResourceConfigList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("LtmcfraResourceConfigList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("LtmcfraResourceConfigList");
            e
        })
    }
}
// LtmcfraResourceConfigItem
#[derive(Clone, Debug)]
pub struct LtmcfraResourceConfigItem {
    pub nr_cgi: NrCgi,
    pub ltmcfra_resource_config: Option<LtmcfraResourceConfig>,
    pub ltmcfra_resource_config_sul: Option<LtmcfraResourceConfig>,
}

impl LtmcfraResourceConfigItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 3)?;
        let nr_cgi = NrCgi::decode(data)?;
        let ltmcfra_resource_config = if optionals[0] {
            Some(LtmcfraResourceConfig::decode(data)?)
        } else {
            None
        };
        let ltmcfra_resource_config_sul = if optionals[1] {
            Some(LtmcfraResourceConfig::decode(data)?)
        } else {
            None
        };

        // Process the extension container

        if optionals[2] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            nr_cgi,
            ltmcfra_resource_config,
            ltmcfra_resource_config_sul,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.ltmcfra_resource_config.is_some());
        optionals.push(self.ltmcfra_resource_config_sul.is_some());
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.nr_cgi.encode(data)?;
        if let Some(x) = &self.ltmcfra_resource_config {
            x.encode(data)?;
        }
        if let Some(x) = &self.ltmcfra_resource_config_sul {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl PerCodec for LtmcfraResourceConfigItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        LtmcfraResourceConfigItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("LtmcfraResourceConfigItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("LtmcfraResourceConfigItem");
            e
        })
    }
}
// LtmcfraResourceConfig
#[derive(Clone, Debug)]
pub struct LtmcfraResourceConfig(pub Vec<u8>);

impl LtmcfraResourceConfig {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(decode::decode_octetstring(data, None, None, false)?))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_octetstring(data, None, None, false, &self.0, false)
    }
}

impl PerCodec for LtmcfraResourceConfig {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        LtmcfraResourceConfig::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("LtmcfraResourceConfig");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("LtmcfraResourceConfig");
            e
        })
    }
}
// MappingInformationIndex
#[derive(Clone, Debug)]
pub struct MappingInformationIndex(pub BitString);

impl MappingInformationIndex {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(decode::decode_bitstring(
            data,
            Some(26),
            Some(26),
            false,
        )?))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_bitstring(data, Some(26), Some(26), false, &self.0, false)
    }
}

impl PerCodec for MappingInformationIndex {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        MappingInformationIndex::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MappingInformationIndex");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MappingInformationIndex");
            e
        })
    }
}
// MappingInformationtoRemove
#[derive(Clone, Debug)]
pub struct MappingInformationtoRemove(pub NonEmpty<MappingInformationIndex>);

impl MappingInformationtoRemove {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(67108864), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(MappingInformationIndex::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(67108864), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for MappingInformationtoRemove {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        MappingInformationtoRemove::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MappingInformationtoRemove");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MappingInformationtoRemove");
            e
        })
    }
}
// MaskedImeisv
#[derive(Clone, Debug)]
pub struct MaskedImeisv(pub BitString);

impl MaskedImeisv {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(decode::decode_bitstring(
            data,
            Some(64),
            Some(64),
            false,
        )?))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_bitstring(data, Some(64), Some(64), false, &self.0, false)
    }
}

impl PerCodec for MaskedImeisv {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        MaskedImeisv::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MaskedImeisv");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MaskedImeisv");
            e
        })
    }
}
// MaxDataBurstVolume
#[derive(Clone, Copy, Debug)]
pub struct MaxDataBurstVolume(pub i128);

impl MaxDataBurstVolume {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(
            decode::decode_integer(data, Some(0), Some(4095), true)?.0,
        ))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_integer(data, Some(0), Some(4095), true, self.0, false)
    }
}

impl PerCodec for MaxDataBurstVolume {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        MaxDataBurstVolume::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MaxDataBurstVolume");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MaxDataBurstVolume");
            e
        })
    }
}
// MaxPacketLossRate
#[derive(Clone, Copy, Debug)]
pub struct MaxPacketLossRate(pub u16);

impl MaxPacketLossRate {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(
            decode::decode_integer(data, Some(0), Some(1000), false)?.0 as u16,
        ))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_integer(data, Some(0), Some(1000), false, self.0 as i128, false)
    }
}

impl PerCodec for MaxPacketLossRate {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        MaxPacketLossRate::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MaxPacketLossRate");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MaxPacketLossRate");
            e
        })
    }
}
// MbsBroadcastNeighbourCellList
#[derive(Clone, Debug)]
pub struct MbsBroadcastNeighbourCellList(pub Vec<u8>);

impl MbsBroadcastNeighbourCellList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(decode::decode_octetstring(data, None, None, false)?))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_octetstring(data, None, None, false, &self.0, false)
    }
}

impl PerCodec for MbsBroadcastNeighbourCellList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        MbsBroadcastNeighbourCellList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MbsBroadcastNeighbourCellList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MbsBroadcastNeighbourCellList");
            e
        })
    }
}
// MbsFlowsMappedToMrbList
#[derive(Clone, Debug)]
pub struct MbsFlowsMappedToMrbList(pub NonEmpty<MbsFlowsMappedToMrbItem>);

impl MbsFlowsMappedToMrbList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(64), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(MbsFlowsMappedToMrbItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(64), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for MbsFlowsMappedToMrbList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        MbsFlowsMappedToMrbList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MbsFlowsMappedToMrbList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MbsFlowsMappedToMrbList");
            e
        })
    }
}
// MbsFlowsMappedToMrbItem
#[derive(Clone, Debug)]
pub struct MbsFlowsMappedToMrbItem {
    pub mbs_qos_flow_identifier: QosFlowIdentifier,
    pub mbs_qos_flow_level_qos_parameters: QosFlowLevelQosParameters,
}

impl MbsFlowsMappedToMrbItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, false, 1)?;
        let mbs_qos_flow_identifier = QosFlowIdentifier::decode(data)?;
        let mbs_qos_flow_level_qos_parameters = QosFlowLevelQosParameters::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            mbs_qos_flow_identifier,
            mbs_qos_flow_level_qos_parameters,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, false, &optionals, false)?;
        self.mbs_qos_flow_identifier.encode(data)?;
        self.mbs_qos_flow_level_qos_parameters.encode(data)?;

        Ok(())
    }
}

impl PerCodec for MbsFlowsMappedToMrbItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        MbsFlowsMappedToMrbItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MbsFlowsMappedToMrbItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MbsFlowsMappedToMrbItem");
            e
        })
    }
}
// Mbsf1uInformation
#[derive(Clone, Debug)]
pub struct Mbsf1uInformation {
    pub mbs_f1u_info: UpTransportLayerInformation,
    pub f1u_tunnel_not_established: Option<F1uTunnelNotEstablished>,
}

impl Mbsf1uInformation {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let mbs_f1u_info = UpTransportLayerInformation::decode(data)?;

        // Process the extension container
        let mut f1u_tunnel_not_established: Option<F1uTunnelNotEstablished> = None;

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    771 => {
                        f1u_tunnel_not_established = Some(F1uTunnelNotEstablished::decode(data)?)
                    }
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            mbs_f1u_info,
            f1u_tunnel_not_established,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();
        if let Some(x) = &self.f1u_tunnel_not_established {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 771, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        let mut optionals = BitString::new();
        optionals.push(num_ies != 0);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.mbs_f1u_info.encode(data)?;
        if num_ies != 0 {
            encode::encode_length_determinent(data, Some(1), Some(65535), false, num_ies)?;
            data.append_aligned(ies);
        }
        Ok(())
    }
}

impl PerCodec for Mbsf1uInformation {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Mbsf1uInformation::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("Mbsf1uInformation");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("Mbsf1uInformation");
            e
        })
    }
}
// MbsInterestIndication
#[derive(Clone, Debug)]
pub struct MbsInterestIndication(pub Vec<u8>);

impl MbsInterestIndication {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(decode::decode_octetstring(data, None, None, false)?))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_octetstring(data, None, None, false, &self.0, false)
    }
}

impl PerCodec for MbsInterestIndication {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        MbsInterestIndication::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MbsInterestIndication");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MbsInterestIndication");
            e
        })
    }
}
// MbsSessionId
#[derive(Clone, Debug)]
pub struct MbsSessionId {
    pub tmgi: Tmgi,
    pub nid: Option<Nid>,
}

impl MbsSessionId {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 2)?;
        let tmgi = Tmgi::decode(data)?;
        let nid = if optionals[0] {
            Some(Nid::decode(data)?)
        } else {
            None
        };

        // Process the extension container

        if optionals[1] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self { tmgi, nid })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.nid.is_some());
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.tmgi.encode(data)?;
        if let Some(x) = &self.nid {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl PerCodec for MbsSessionId {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        MbsSessionId::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MbsSessionId");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MbsSessionId");
            e
        })
    }
}
// MbsAreaSessionId
#[derive(Clone, Copy, Debug)]
pub struct MbsAreaSessionId(pub u16);

impl MbsAreaSessionId {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(
            decode::decode_integer(data, Some(0), Some(65535), true)?.0 as u16,
        ))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_integer(data, Some(0), Some(65535), true, self.0 as i128, false)
    }
}

impl PerCodec for MbsAreaSessionId {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        MbsAreaSessionId::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MbsAreaSessionId");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MbsAreaSessionId");
            e
        })
    }
}
// MbsCuToDuRrcInformation
#[derive(Clone, Debug)]
pub struct MbsCuToDuRrcInformation {
    pub mbs_broadcast_cell_list: MbsBroadcastCellList,
    pub mbs_broadcast_mrb_list: MbsBroadcastMrbList,
}

impl MbsCuToDuRrcInformation {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let mbs_broadcast_cell_list = MbsBroadcastCellList::decode(data)?;
        let mbs_broadcast_mrb_list = MbsBroadcastMrbList::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            mbs_broadcast_cell_list,
            mbs_broadcast_mrb_list,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.mbs_broadcast_cell_list.encode(data)?;
        self.mbs_broadcast_mrb_list.encode(data)?;

        Ok(())
    }
}

impl PerCodec for MbsCuToDuRrcInformation {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        MbsCuToDuRrcInformation::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MbsCuToDuRrcInformation");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MbsCuToDuRrcInformation");
            e
        })
    }
}
// MbsBroadcastCellList
#[derive(Clone, Debug)]
pub struct MbsBroadcastCellList(pub NonEmpty<MbsBroadcastCellItem>);

impl MbsBroadcastCellList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(512), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(MbsBroadcastCellItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(512), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for MbsBroadcastCellList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        MbsBroadcastCellList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MbsBroadcastCellList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MbsBroadcastCellList");
            e
        })
    }
}
// MbsBroadcastCellItem
#[derive(Clone, Debug)]
pub struct MbsBroadcastCellItem {
    pub nr_cgi: NrCgi,
    pub mtch_neighbour_cell: Option<Vec<u8>>,
}

impl MbsBroadcastCellItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 2)?;
        let nr_cgi = NrCgi::decode(data)?;
        let mtch_neighbour_cell = if optionals[0] {
            Some(decode::decode_octetstring(data, None, None, false)?)
        } else {
            None
        };

        // Process the extension container

        if optionals[1] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            nr_cgi,
            mtch_neighbour_cell,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.mtch_neighbour_cell.is_some());
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.nr_cgi.encode(data)?;
        if let Some(x) = &self.mtch_neighbour_cell {
            encode::encode_octetstring(data, None, None, false, &x, false)?;
        }

        Ok(())
    }
}

impl PerCodec for MbsBroadcastCellItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        MbsBroadcastCellItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MbsBroadcastCellItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MbsBroadcastCellItem");
            e
        })
    }
}
// MbsBroadcastMrbList
#[derive(Clone, Debug)]
pub struct MbsBroadcastMrbList(pub NonEmpty<MbsBroadcastMrbItem>);

impl MbsBroadcastMrbList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(32), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(MbsBroadcastMrbItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(32), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for MbsBroadcastMrbList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        MbsBroadcastMrbList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MbsBroadcastMrbList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MbsBroadcastMrbList");
            e
        })
    }
}
// MbsBroadcastMrbItem
#[derive(Clone, Debug)]
pub struct MbsBroadcastMrbItem {
    pub mrb_id: MrbId,
    pub mrb_pdcp_config_broadcast: Vec<u8>,
}

impl MbsBroadcastMrbItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let mrb_id = MrbId::decode(data)?;
        let mrb_pdcp_config_broadcast = decode::decode_octetstring(data, None, None, false)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            mrb_id,
            mrb_pdcp_config_broadcast,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.mrb_id.encode(data)?;
        encode::encode_octetstring(
            data,
            None,
            None,
            false,
            &self.mrb_pdcp_config_broadcast,
            false,
        )?;

        Ok(())
    }
}

impl PerCodec for MbsBroadcastMrbItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        MbsBroadcastMrbItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MbsBroadcastMrbItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MbsBroadcastMrbItem");
            e
        })
    }
}
// MbsMulticastF1uContextDescriptor
#[derive(Clone, Debug)]
pub struct MbsMulticastF1uContextDescriptor {
    pub multicast_f1u_context_reference_f1: MulticastF1uContextReferenceF1,
    pub mc_f1u_ctxtusage: McF1uCtxtusage,
    pub mbs_area_session: Option<MbsAreaSessionId>,
}

impl MbsMulticastF1uContextDescriptor {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 2)?;
        let multicast_f1u_context_reference_f1 = MulticastF1uContextReferenceF1::decode(data)?;
        let mc_f1u_ctxtusage = McF1uCtxtusage::decode(data)?;
        let mbs_area_session = if optionals[0] {
            Some(MbsAreaSessionId::decode(data)?)
        } else {
            None
        };

        // Process the extension container

        if optionals[1] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            multicast_f1u_context_reference_f1,
            mc_f1u_ctxtusage,
            mbs_area_session,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.mbs_area_session.is_some());
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.multicast_f1u_context_reference_f1.encode(data)?;
        self.mc_f1u_ctxtusage.encode(data)?;
        if let Some(x) = &self.mbs_area_session {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl PerCodec for MbsMulticastF1uContextDescriptor {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        MbsMulticastF1uContextDescriptor::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MbsMulticastF1uContextDescriptor");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MbsMulticastF1uContextDescriptor");
            e
        })
    }
}
// MtSdtInformation
#[derive(Clone, Debug)]
pub struct MtSdtInformation {
    pub mt_sdt_indicator: MtSdtIndicator,
}

impl MtSdtInformation {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let mt_sdt_indicator = MtSdtIndicator::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self { mt_sdt_indicator })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.mt_sdt_indicator.encode(data)?;

        Ok(())
    }
}

impl PerCodec for MtSdtInformation {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        MtSdtInformation::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MtSdtInformation");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MtSdtInformation");
            e
        })
    }
}
// MtSdtIndicator
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum MtSdtIndicator {
    True,
}

impl MtSdtIndicator {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(0), true)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(0),
            true,
            *self as i128,
            (*self as u32) >= 1,
        )
    }
}

impl PerCodec for MtSdtIndicator {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        MtSdtIndicator::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MtSdtIndicator");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MtSdtIndicator");
            e
        })
    }
}
// MbsMulticastSessionReceptionState
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum MbsMulticastSessionReceptionState {
    StartMonitoringGRnti,
    StopMonitoringGRnti,
}

impl MbsMulticastSessionReceptionState {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(1), true)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(1),
            true,
            *self as i128,
            (*self as u32) >= 2,
        )
    }
}

impl PerCodec for MbsMulticastSessionReceptionState {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        MbsMulticastSessionReceptionState::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MbsMulticastSessionReceptionState");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MbsMulticastSessionReceptionState");
            e
        })
    }
}
// MulticastCu2DuRrcInfo
#[derive(Clone, Debug)]
pub struct MulticastCu2DuRrcInfo {
    pub mbs_multicast_cu_2_du_cell_list: Option<MbsMulticastCu2DuCellList>,
    pub mbs_multicast_mrb_list: Option<MbsMulticastMrbList>,
}

impl MulticastCu2DuRrcInfo {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 3)?;
        let mbs_multicast_cu_2_du_cell_list = if optionals[0] {
            Some(MbsMulticastCu2DuCellList::decode(data)?)
        } else {
            None
        };
        let mbs_multicast_mrb_list = if optionals[1] {
            Some(MbsMulticastMrbList::decode(data)?)
        } else {
            None
        };

        // Process the extension container

        if optionals[2] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            mbs_multicast_cu_2_du_cell_list,
            mbs_multicast_mrb_list,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.mbs_multicast_cu_2_du_cell_list.is_some());
        optionals.push(self.mbs_multicast_mrb_list.is_some());
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        if let Some(x) = &self.mbs_multicast_cu_2_du_cell_list {
            x.encode(data)?;
        }
        if let Some(x) = &self.mbs_multicast_mrb_list {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl PerCodec for MulticastCu2DuRrcInfo {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        MulticastCu2DuRrcInfo::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MulticastCu2DuRrcInfo");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MulticastCu2DuRrcInfo");
            e
        })
    }
}
// MbsMulticastCu2DuCellList
#[derive(Clone, Debug)]
pub struct MbsMulticastCu2DuCellList(pub NonEmpty<MbsMulticastCu2DuCellItem>);

impl MbsMulticastCu2DuCellList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(512), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(MbsMulticastCu2DuCellItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(512), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for MbsMulticastCu2DuCellList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        MbsMulticastCu2DuCellList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MbsMulticastCu2DuCellList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MbsMulticastCu2DuCellList");
            e
        })
    }
}
// MbsMulticastCu2DuCellItem
#[derive(Clone, Debug)]
pub struct MbsMulticastCu2DuCellItem {
    pub nr_cgi: NrCgi,
    pub mbs_multicast_rrc_inactive_reception_mode: Option<MbsMulticastRrcInactiveReceptionMode>,
    pub mbs_multicast_configuration_request: Option<MbsMulticastConfigurationRequest>,
}

impl MbsMulticastCu2DuCellItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 3)?;
        let nr_cgi = NrCgi::decode(data)?;
        let mbs_multicast_rrc_inactive_reception_mode = if optionals[0] {
            Some(MbsMulticastRrcInactiveReceptionMode::decode(data)?)
        } else {
            None
        };
        let mbs_multicast_configuration_request = if optionals[1] {
            Some(MbsMulticastConfigurationRequest::decode(data)?)
        } else {
            None
        };

        // Process the extension container

        if optionals[2] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            nr_cgi,
            mbs_multicast_rrc_inactive_reception_mode,
            mbs_multicast_configuration_request,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.mbs_multicast_rrc_inactive_reception_mode.is_some());
        optionals.push(self.mbs_multicast_configuration_request.is_some());
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.nr_cgi.encode(data)?;
        if let Some(x) = &self.mbs_multicast_rrc_inactive_reception_mode {
            x.encode(data)?;
        }
        if let Some(x) = &self.mbs_multicast_configuration_request {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl PerCodec for MbsMulticastCu2DuCellItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        MbsMulticastCu2DuCellItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MbsMulticastCu2DuCellItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MbsMulticastCu2DuCellItem");
            e
        })
    }
}
// MbsMulticastRrcInactiveReceptionMode
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum MbsMulticastRrcInactiveReceptionMode {
    Activated,
    Deactivated,
}

impl MbsMulticastRrcInactiveReceptionMode {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(1), true)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(1),
            true,
            *self as i128,
            (*self as u32) >= 2,
        )
    }
}

impl PerCodec for MbsMulticastRrcInactiveReceptionMode {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        MbsMulticastRrcInactiveReceptionMode::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MbsMulticastRrcInactiveReceptionMode");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MbsMulticastRrcInactiveReceptionMode");
            e
        })
    }
}
// MbsMulticastMrbList
#[derive(Clone, Debug)]
pub struct MbsMulticastMrbList(pub NonEmpty<MbsMulticastMrbItem>);

impl MbsMulticastMrbList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(32), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(MbsMulticastMrbItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(32), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for MbsMulticastMrbList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        MbsMulticastMrbList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MbsMulticastMrbList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MbsMulticastMrbList");
            e
        })
    }
}
// MbsMulticastMrbItem
#[derive(Clone, Debug)]
pub struct MbsMulticastMrbItem {
    pub mrb_id: MrbId,
    pub mrb_pdcp_config_broadcast: Vec<u8>,
}

impl MbsMulticastMrbItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let mrb_id = MrbId::decode(data)?;
        let mrb_pdcp_config_broadcast = decode::decode_octetstring(data, None, None, false)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            mrb_id,
            mrb_pdcp_config_broadcast,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.mrb_id.encode(data)?;
        encode::encode_octetstring(
            data,
            None,
            None,
            false,
            &self.mrb_pdcp_config_broadcast,
            false,
        )?;

        Ok(())
    }
}

impl PerCodec for MbsMulticastMrbItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        MbsMulticastMrbItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MbsMulticastMrbItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MbsMulticastMrbItem");
            e
        })
    }
}
// MulticastCu2DuCommonRrcInfo
#[derive(Clone, Debug)]
pub struct MulticastCu2DuCommonRrcInfo {
    pub multicast_common_cu_2_du_cell_list: Option<MulticastCommonCu2DuCellList>,
}

impl MulticastCu2DuCommonRrcInfo {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 2)?;
        let multicast_common_cu_2_du_cell_list = if optionals[0] {
            Some(MulticastCommonCu2DuCellList::decode(data)?)
        } else {
            None
        };

        // Process the extension container

        if optionals[1] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            multicast_common_cu_2_du_cell_list,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.multicast_common_cu_2_du_cell_list.is_some());
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        if let Some(x) = &self.multicast_common_cu_2_du_cell_list {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl PerCodec for MulticastCu2DuCommonRrcInfo {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        MulticastCu2DuCommonRrcInfo::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MulticastCu2DuCommonRrcInfo");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MulticastCu2DuCommonRrcInfo");
            e
        })
    }
}
// MulticastCommonCu2DuCellList
#[derive(Clone, Debug)]
pub struct MulticastCommonCu2DuCellList(pub NonEmpty<MulticastCommonCu2DuCellItem>);

impl MulticastCommonCu2DuCellList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(512), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(MulticastCommonCu2DuCellItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(512), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for MulticastCommonCu2DuCellList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        MulticastCommonCu2DuCellList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MulticastCommonCu2DuCellList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MulticastCommonCu2DuCellList");
            e
        })
    }
}
// MulticastCommonCu2DuCellItem
#[derive(Clone, Debug)]
pub struct MulticastCommonCu2DuCellItem {
    pub nr_cgi: NrCgi,
    pub multicast_common_cu_2_du_cell_information: MulticastCommonCu2DuCellInformation,
}

impl MulticastCommonCu2DuCellItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let nr_cgi = NrCgi::decode(data)?;
        let multicast_common_cu_2_du_cell_information =
            MulticastCommonCu2DuCellInformation::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            nr_cgi,
            multicast_common_cu_2_du_cell_information,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.nr_cgi.encode(data)?;
        self.multicast_common_cu_2_du_cell_information
            .encode(data)?;

        Ok(())
    }
}

impl PerCodec for MulticastCommonCu2DuCellItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        MulticastCommonCu2DuCellItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MulticastCommonCu2DuCellItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MulticastCommonCu2DuCellItem");
            e
        })
    }
}
// MulticastCommonCu2DuCellInformation
#[derive(Clone, Debug)]
pub struct MulticastCommonCu2DuCellInformation {
    pub mbs_multicast_neighbour_cell_list_item: Option<MbsMulticastNeighbourCellListItem>,
    pub threshold_mbs_list_item: Option<ThresholdMbsListItem>,
}

impl MulticastCommonCu2DuCellInformation {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 3)?;
        let mbs_multicast_neighbour_cell_list_item = if optionals[0] {
            Some(MbsMulticastNeighbourCellListItem::decode(data)?)
        } else {
            None
        };
        let threshold_mbs_list_item = if optionals[1] {
            Some(ThresholdMbsListItem::decode(data)?)
        } else {
            None
        };

        // Process the extension container

        if optionals[2] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            mbs_multicast_neighbour_cell_list_item,
            threshold_mbs_list_item,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.mbs_multicast_neighbour_cell_list_item.is_some());
        optionals.push(self.threshold_mbs_list_item.is_some());
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        if let Some(x) = &self.mbs_multicast_neighbour_cell_list_item {
            x.encode(data)?;
        }
        if let Some(x) = &self.threshold_mbs_list_item {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl PerCodec for MulticastCommonCu2DuCellInformation {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        MulticastCommonCu2DuCellInformation::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MulticastCommonCu2DuCellInformation");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MulticastCommonCu2DuCellInformation");
            e
        })
    }
}
// MbsMulticastNeighbourCellListItem
#[derive(Clone, Debug)]
pub enum MbsMulticastNeighbourCellListItem {
    MbsMulticastNeighbourCellListInformationprovided(
        UpdateMbsMulticastNeighbourCellListInformation,
    ),
    NombsMulticastNeighbourCellListInformationprovided,
}

impl MbsMulticastNeighbourCellListItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_choice_idx(data, 0, 2, false)?;
        if extended {
            return Err(per_codec_error_new("CHOICE additions not implemented"));
        }
        match idx {
            0 => Ok(Self::MbsMulticastNeighbourCellListInformationprovided(
                UpdateMbsMulticastNeighbourCellListInformation::decode(data)?,
            )),
            1 => Ok(Self::NombsMulticastNeighbourCellListInformationprovided),
            2 => {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _ = Criticality::decode(data)?;
                let _ = decode::decode_length_determinent(data, None, None, false)?;
                let result = match id {
                    x => Err(per_codec_error_new(format!("Unrecognised IE type {}", x))),
                };
                data.decode_align()?;
                result
            }
            _ => Err(per_codec_error_new("Unknown choice idx")),
        }
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        match self {
            Self::MbsMulticastNeighbourCellListInformationprovided(x) => {
                encode::encode_choice_idx(data, 0, 2, false, 0, false)?;
                x.encode(data)
            }
            Self::NombsMulticastNeighbourCellListInformationprovided => {
                encode::encode_choice_idx(data, 0, 2, false, 1, false)?;
                Ok(())
            }
        }
    }
}

impl PerCodec for MbsMulticastNeighbourCellListItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        MbsMulticastNeighbourCellListItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MbsMulticastNeighbourCellListItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MbsMulticastNeighbourCellListItem");
            e
        })
    }
}
// ThresholdMbsListItem
#[derive(Clone, Debug)]
pub enum ThresholdMbsListItem {
    ThresholdMbsListInformationprovided(UpdateThresholdMbsListInformation),
    NothresholdMbsListInformationprovided,
}

impl ThresholdMbsListItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_choice_idx(data, 0, 2, false)?;
        if extended {
            return Err(per_codec_error_new("CHOICE additions not implemented"));
        }
        match idx {
            0 => Ok(Self::ThresholdMbsListInformationprovided(
                UpdateThresholdMbsListInformation::decode(data)?,
            )),
            1 => Ok(Self::NothresholdMbsListInformationprovided),
            2 => {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _ = Criticality::decode(data)?;
                let _ = decode::decode_length_determinent(data, None, None, false)?;
                let result = match id {
                    x => Err(per_codec_error_new(format!("Unrecognised IE type {}", x))),
                };
                data.decode_align()?;
                result
            }
            _ => Err(per_codec_error_new("Unknown choice idx")),
        }
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        match self {
            Self::ThresholdMbsListInformationprovided(x) => {
                encode::encode_choice_idx(data, 0, 2, false, 0, false)?;
                x.encode(data)
            }
            Self::NothresholdMbsListInformationprovided => {
                encode::encode_choice_idx(data, 0, 2, false, 1, false)?;
                Ok(())
            }
        }
    }
}

impl PerCodec for ThresholdMbsListItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        ThresholdMbsListItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ThresholdMbsListItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ThresholdMbsListItem");
            e
        })
    }
}
// UpdateMbsMulticastNeighbourCellListInformation
#[derive(Clone, Debug)]
pub struct UpdateMbsMulticastNeighbourCellListInformation {
    pub mbs_neighbour_cell_list: Option<Vec<u8>>,
    pub mbs_multicast_session_list: Option<MtchNeighbourCellSessionList>,
}

impl UpdateMbsMulticastNeighbourCellListInformation {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 3)?;
        let mbs_neighbour_cell_list = if optionals[0] {
            Some(decode::decode_octetstring(data, None, None, false)?)
        } else {
            None
        };
        let mbs_multicast_session_list = if optionals[1] {
            Some(MtchNeighbourCellSessionList::decode(data)?)
        } else {
            None
        };

        // Process the extension container

        if optionals[2] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            mbs_neighbour_cell_list,
            mbs_multicast_session_list,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.mbs_neighbour_cell_list.is_some());
        optionals.push(self.mbs_multicast_session_list.is_some());
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        if let Some(x) = &self.mbs_neighbour_cell_list {
            encode::encode_octetstring(data, None, None, false, &x, false)?;
        }
        if let Some(x) = &self.mbs_multicast_session_list {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl PerCodec for UpdateMbsMulticastNeighbourCellListInformation {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        UpdateMbsMulticastNeighbourCellListInformation::decode_inner(data).map_err(
            |mut e: PerCodecError| {
                e.push_context("UpdateMbsMulticastNeighbourCellListInformation");
                e
            },
        )
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UpdateMbsMulticastNeighbourCellListInformation");
            e
        })
    }
}
// MtchNeighbourCellSessionList
#[derive(Clone, Debug)]
pub struct MtchNeighbourCellSessionList(pub NonEmpty<MtchNeighbourCellSessionItem>);

impl MtchNeighbourCellSessionList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(1024), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(MtchNeighbourCellSessionItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(1024), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for MtchNeighbourCellSessionList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        MtchNeighbourCellSessionList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MtchNeighbourCellSessionList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MtchNeighbourCellSessionList");
            e
        })
    }
}
// MtchNeighbourCellSessionItem
#[derive(Clone, Debug)]
pub struct MtchNeighbourCellSessionItem {
    pub mbs_session_id: MbsSessionId,
    pub mtch_neighbour_cell_information: MtchNeighbourCellInformation,
}

impl MtchNeighbourCellSessionItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let mbs_session_id = MbsSessionId::decode(data)?;
        let mtch_neighbour_cell_information = MtchNeighbourCellInformation::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            mbs_session_id,
            mtch_neighbour_cell_information,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.mbs_session_id.encode(data)?;
        self.mtch_neighbour_cell_information.encode(data)?;

        Ok(())
    }
}

impl PerCodec for MtchNeighbourCellSessionItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        MtchNeighbourCellSessionItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MtchNeighbourCellSessionItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MtchNeighbourCellSessionItem");
            e
        })
    }
}
// MtchNeighbourCellInformation
#[derive(Clone, Debug)]
pub enum MtchNeighbourCellInformation {
    MtchNeighbourCellprovided(Vec<u8>),
    MtchNeighbourCellnotprovided,
}

impl MtchNeighbourCellInformation {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_choice_idx(data, 0, 2, false)?;
        if extended {
            return Err(per_codec_error_new("CHOICE additions not implemented"));
        }
        match idx {
            0 => Ok(Self::MtchNeighbourCellprovided(decode::decode_octetstring(
                data, None, None, false,
            )?)),
            1 => Ok(Self::MtchNeighbourCellnotprovided),
            2 => {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _ = Criticality::decode(data)?;
                let _ = decode::decode_length_determinent(data, None, None, false)?;
                let result = match id {
                    x => Err(per_codec_error_new(format!("Unrecognised IE type {}", x))),
                };
                data.decode_align()?;
                result
            }
            _ => Err(per_codec_error_new("Unknown choice idx")),
        }
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        match self {
            Self::MtchNeighbourCellprovided(x) => {
                encode::encode_choice_idx(data, 0, 2, false, 0, false)?;
                encode::encode_octetstring(data, None, None, false, &x, false)
            }
            Self::MtchNeighbourCellnotprovided => {
                encode::encode_choice_idx(data, 0, 2, false, 1, false)?;
                Ok(())
            }
        }
    }
}

impl PerCodec for MtchNeighbourCellInformation {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        MtchNeighbourCellInformation::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MtchNeighbourCellInformation");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MtchNeighbourCellInformation");
            e
        })
    }
}
// UpdateThresholdMbsListInformation
#[derive(Clone, Debug)]
pub struct UpdateThresholdMbsListInformation {
    pub threshold_mbs_list: Option<Vec<u8>>,
    pub threshold_index_session_list: Option<ThresholdIndexSessionList>,
}

impl UpdateThresholdMbsListInformation {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 3)?;
        let threshold_mbs_list = if optionals[0] {
            Some(decode::decode_octetstring(data, None, None, false)?)
        } else {
            None
        };
        let threshold_index_session_list = if optionals[1] {
            Some(ThresholdIndexSessionList::decode(data)?)
        } else {
            None
        };

        // Process the extension container

        if optionals[2] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            threshold_mbs_list,
            threshold_index_session_list,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.threshold_mbs_list.is_some());
        optionals.push(self.threshold_index_session_list.is_some());
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        if let Some(x) = &self.threshold_mbs_list {
            encode::encode_octetstring(data, None, None, false, &x, false)?;
        }
        if let Some(x) = &self.threshold_index_session_list {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl PerCodec for UpdateThresholdMbsListInformation {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        UpdateThresholdMbsListInformation::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UpdateThresholdMbsListInformation");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UpdateThresholdMbsListInformation");
            e
        })
    }
}
// ThresholdIndexSessionList
#[derive(Clone, Debug)]
pub struct ThresholdIndexSessionList(pub NonEmpty<ThresholdIndexSessionItem>);

impl ThresholdIndexSessionList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(1024), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(ThresholdIndexSessionItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(1024), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for ThresholdIndexSessionList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        ThresholdIndexSessionList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ThresholdIndexSessionList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ThresholdIndexSessionList");
            e
        })
    }
}
// ThresholdIndexSessionItem
#[derive(Clone, Debug)]
pub struct ThresholdIndexSessionItem {
    pub mbs_session_id: MbsSessionId,
    pub threshold_index_information: ThresholdIndexInformation,
}

impl ThresholdIndexSessionItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let mbs_session_id = MbsSessionId::decode(data)?;
        let threshold_index_information = ThresholdIndexInformation::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            mbs_session_id,
            threshold_index_information,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.mbs_session_id.encode(data)?;
        self.threshold_index_information.encode(data)?;

        Ok(())
    }
}

impl PerCodec for ThresholdIndexSessionItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        ThresholdIndexSessionItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ThresholdIndexSessionItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ThresholdIndexSessionItem");
            e
        })
    }
}
// ThresholdIndexInformation
#[derive(Clone, Debug)]
pub enum ThresholdIndexInformation {
    ThresholdIndexprovided(ThresholdIndex),
    ThresholdIndexnotprovided,
}

impl ThresholdIndexInformation {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_choice_idx(data, 0, 2, false)?;
        if extended {
            return Err(per_codec_error_new("CHOICE additions not implemented"));
        }
        match idx {
            0 => Ok(Self::ThresholdIndexprovided(ThresholdIndex::decode(data)?)),
            1 => Ok(Self::ThresholdIndexnotprovided),
            2 => {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _ = Criticality::decode(data)?;
                let _ = decode::decode_length_determinent(data, None, None, false)?;
                let result = match id {
                    x => Err(per_codec_error_new(format!("Unrecognised IE type {}", x))),
                };
                data.decode_align()?;
                result
            }
            _ => Err(per_codec_error_new("Unknown choice idx")),
        }
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        match self {
            Self::ThresholdIndexprovided(x) => {
                encode::encode_choice_idx(data, 0, 2, false, 0, false)?;
                x.encode(data)
            }
            Self::ThresholdIndexnotprovided => {
                encode::encode_choice_idx(data, 0, 2, false, 1, false)?;
                Ok(())
            }
        }
    }
}

impl PerCodec for ThresholdIndexInformation {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        ThresholdIndexInformation::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ThresholdIndexInformation");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ThresholdIndexInformation");
            e
        })
    }
}
// ThresholdIndex
#[derive(Clone, Copy, Debug)]
pub struct ThresholdIndex(pub u8);

impl ThresholdIndex {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(
            decode::decode_integer(data, Some(0), Some(7), false)?.0 as u8,
        ))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_integer(data, Some(0), Some(7), false, self.0 as i128, false)
    }
}

impl PerCodec for ThresholdIndex {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        ThresholdIndex::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ThresholdIndex");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ThresholdIndex");
            e
        })
    }
}
// MulticastDu2CuRrcInfo
#[derive(Clone, Debug)]
pub struct MulticastDu2CuRrcInfo {
    pub mbs_multicast_du_2_cu_cell_list: Option<MbsMulticastDu2CuCellList>,
}

impl MulticastDu2CuRrcInfo {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 2)?;
        let mbs_multicast_du_2_cu_cell_list = if optionals[0] {
            Some(MbsMulticastDu2CuCellList::decode(data)?)
        } else {
            None
        };

        // Process the extension container

        if optionals[1] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            mbs_multicast_du_2_cu_cell_list,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.mbs_multicast_du_2_cu_cell_list.is_some());
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        if let Some(x) = &self.mbs_multicast_du_2_cu_cell_list {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl PerCodec for MulticastDu2CuRrcInfo {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        MulticastDu2CuRrcInfo::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MulticastDu2CuRrcInfo");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MulticastDu2CuRrcInfo");
            e
        })
    }
}
// MbsMulticastDu2CuCellList
#[derive(Clone, Debug)]
pub struct MbsMulticastDu2CuCellList(pub NonEmpty<MbsMulticastDu2CuCellItem>);

impl MbsMulticastDu2CuCellList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(512), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(MbsMulticastDu2CuCellItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(512), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for MbsMulticastDu2CuCellList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        MbsMulticastDu2CuCellList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MbsMulticastDu2CuCellList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MbsMulticastDu2CuCellList");
            e
        })
    }
}
// MbsMulticastDu2CuCellItem
#[derive(Clone, Debug)]
pub struct MbsMulticastDu2CuCellItem {
    pub nr_cgi: NrCgi,
    pub mbs_multicast_configuration_response_info: Option<MbsMulticastConfigurationResponseInfo>,
    pub mbs_multicast_configuration_notification: Option<MbsMulticastConfigurationNotification>,
}

impl MbsMulticastDu2CuCellItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 3)?;
        let nr_cgi = NrCgi::decode(data)?;
        let mbs_multicast_configuration_response_info = if optionals[0] {
            Some(MbsMulticastConfigurationResponseInfo::decode(data)?)
        } else {
            None
        };
        let mbs_multicast_configuration_notification = if optionals[1] {
            Some(MbsMulticastConfigurationNotification::decode(data)?)
        } else {
            None
        };

        // Process the extension container

        if optionals[2] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            nr_cgi,
            mbs_multicast_configuration_response_info,
            mbs_multicast_configuration_notification,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.mbs_multicast_configuration_response_info.is_some());
        optionals.push(self.mbs_multicast_configuration_notification.is_some());
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.nr_cgi.encode(data)?;
        if let Some(x) = &self.mbs_multicast_configuration_response_info {
            x.encode(data)?;
        }
        if let Some(x) = &self.mbs_multicast_configuration_notification {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl PerCodec for MbsMulticastDu2CuCellItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        MbsMulticastDu2CuCellItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MbsMulticastDu2CuCellItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MbsMulticastDu2CuCellItem");
            e
        })
    }
}
// MbsMulticastConfigurationResponseInfo
#[derive(Clone, Debug)]
pub enum MbsMulticastConfigurationResponseInfo {
    MbsMulticastConfigurationAvailable(MbsMulticastConfigurationAvailable),
    MbsMulticastConfigurationNotavailable(MbsMulticastConfigurationNotavailable),
}

impl MbsMulticastConfigurationResponseInfo {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_choice_idx(data, 0, 2, false)?;
        if extended {
            return Err(per_codec_error_new("CHOICE additions not implemented"));
        }
        match idx {
            0 => Ok(Self::MbsMulticastConfigurationAvailable(
                MbsMulticastConfigurationAvailable::decode(data)?,
            )),
            1 => Ok(Self::MbsMulticastConfigurationNotavailable(
                MbsMulticastConfigurationNotavailable::decode(data)?,
            )),
            2 => {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _ = Criticality::decode(data)?;
                let _ = decode::decode_length_determinent(data, None, None, false)?;
                let result = match id {
                    x => Err(per_codec_error_new(format!("Unrecognised IE type {}", x))),
                };
                data.decode_align()?;
                result
            }
            _ => Err(per_codec_error_new("Unknown choice idx")),
        }
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        match self {
            Self::MbsMulticastConfigurationAvailable(x) => {
                encode::encode_choice_idx(data, 0, 2, false, 0, false)?;
                x.encode(data)
            }
            Self::MbsMulticastConfigurationNotavailable(x) => {
                encode::encode_choice_idx(data, 0, 2, false, 1, false)?;
                x.encode(data)
            }
        }
    }
}

impl PerCodec for MbsMulticastConfigurationResponseInfo {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        MbsMulticastConfigurationResponseInfo::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MbsMulticastConfigurationResponseInfo");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MbsMulticastConfigurationResponseInfo");
            e
        })
    }
}
// MbsMulticastConfigurationAvailable
#[derive(Clone, Debug)]
pub struct MbsMulticastConfigurationAvailable {
    pub mbs_multicast_configuration: Vec<u8>,
}

impl MbsMulticastConfigurationAvailable {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let mbs_multicast_configuration = decode::decode_octetstring(data, None, None, false)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            mbs_multicast_configuration,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        encode::encode_octetstring(
            data,
            None,
            None,
            false,
            &self.mbs_multicast_configuration,
            false,
        )?;

        Ok(())
    }
}

impl PerCodec for MbsMulticastConfigurationAvailable {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        MbsMulticastConfigurationAvailable::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MbsMulticastConfigurationAvailable");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MbsMulticastConfigurationAvailable");
            e
        })
    }
}
// MbsMulticastConfigurationNotavailable
#[derive(Clone, Debug)]
pub struct MbsMulticastConfigurationNotavailable {
    pub mbs_multicast_configuration_notavailable: MbsMulticastConfigurationNotavailable1,
}

impl MbsMulticastConfigurationNotavailable {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let mbs_multicast_configuration_notavailable =
            MbsMulticastConfigurationNotavailable1::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            mbs_multicast_configuration_notavailable,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.mbs_multicast_configuration_notavailable.encode(data)?;

        Ok(())
    }
}

impl PerCodec for MbsMulticastConfigurationNotavailable {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        MbsMulticastConfigurationNotavailable::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MbsMulticastConfigurationNotavailable");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MbsMulticastConfigurationNotavailable");
            e
        })
    }
}
// MbsMulticastConfigurationNotification
#[derive(Clone, Debug)]
pub struct MbsMulticastConfigurationNotification {
    pub mbs_multicast_configuration_notification_info:
        Option<MbsMulticastConfigurationNotificationInfo>,
}

impl MbsMulticastConfigurationNotification {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 2)?;
        let mbs_multicast_configuration_notification_info = if optionals[0] {
            Some(MbsMulticastConfigurationNotificationInfo::decode(data)?)
        } else {
            None
        };

        // Process the extension container

        if optionals[1] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            mbs_multicast_configuration_notification_info,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.mbs_multicast_configuration_notification_info.is_some());
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        if let Some(x) = &self.mbs_multicast_configuration_notification_info {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl PerCodec for MbsMulticastConfigurationNotification {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        MbsMulticastConfigurationNotification::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MbsMulticastConfigurationNotification");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MbsMulticastConfigurationNotification");
            e
        })
    }
}
// MbsMulticastConfigurationNotificationInfo
#[derive(Clone, Debug)]
pub enum MbsMulticastConfigurationNotificationInfo {
    MbsMulticastConfigurationChanged(Vec<u8>),
    MbsMulticastConfigurationRemoved,
}

impl MbsMulticastConfigurationNotificationInfo {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_choice_idx(data, 0, 2, false)?;
        if extended {
            return Err(per_codec_error_new("CHOICE additions not implemented"));
        }
        match idx {
            0 => Ok(Self::MbsMulticastConfigurationChanged(
                decode::decode_octetstring(data, None, None, false)?,
            )),
            1 => Ok(Self::MbsMulticastConfigurationRemoved),
            2 => {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _ = Criticality::decode(data)?;
                let _ = decode::decode_length_determinent(data, None, None, false)?;
                let result = match id {
                    x => Err(per_codec_error_new(format!("Unrecognised IE type {}", x))),
                };
                data.decode_align()?;
                result
            }
            _ => Err(per_codec_error_new("Unknown choice idx")),
        }
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        match self {
            Self::MbsMulticastConfigurationChanged(x) => {
                encode::encode_choice_idx(data, 0, 2, false, 0, false)?;
                encode::encode_octetstring(data, None, None, false, &x, false)
            }
            Self::MbsMulticastConfigurationRemoved => {
                encode::encode_choice_idx(data, 0, 2, false, 1, false)?;
                Ok(())
            }
        }
    }
}

impl PerCodec for MbsMulticastConfigurationNotificationInfo {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        MbsMulticastConfigurationNotificationInfo::decode_inner(data).map_err(
            |mut e: PerCodecError| {
                e.push_context("MbsMulticastConfigurationNotificationInfo");
                e
            },
        )
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MbsMulticastConfigurationNotificationInfo");
            e
        })
    }
}
// MulticastF1uContextToBeSetupItem
#[derive(Clone, Debug)]
pub struct MulticastF1uContextToBeSetupItem {
    pub mrb_id: MrbId,
    pub mbs_f1u_info_at_du: UpTransportLayerInformation,
    pub mbs_progress_information: Option<MrbProgressInformation>,
}

impl MulticastF1uContextToBeSetupItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 2)?;
        let mrb_id = MrbId::decode(data)?;
        let mbs_f1u_info_at_du = UpTransportLayerInformation::decode(data)?;
        let mbs_progress_information = if optionals[0] {
            Some(MrbProgressInformation::decode(data)?)
        } else {
            None
        };

        // Process the extension container

        if optionals[1] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            mrb_id,
            mbs_f1u_info_at_du,
            mbs_progress_information,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.mbs_progress_information.is_some());
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.mrb_id.encode(data)?;
        self.mbs_f1u_info_at_du.encode(data)?;
        if let Some(x) = &self.mbs_progress_information {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl PerCodec for MulticastF1uContextToBeSetupItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        MulticastF1uContextToBeSetupItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MulticastF1uContextToBeSetupItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MulticastF1uContextToBeSetupItem");
            e
        })
    }
}
// MulticastF1uContextSetupItem
#[derive(Clone, Debug)]
pub struct MulticastF1uContextSetupItem {
    pub mrb_id: MrbId,
    pub mbs_f1u_info_at_cu: UpTransportLayerInformation,
}

impl MulticastF1uContextSetupItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let mrb_id = MrbId::decode(data)?;
        let mbs_f1u_info_at_cu = UpTransportLayerInformation::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            mrb_id,
            mbs_f1u_info_at_cu,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.mrb_id.encode(data)?;
        self.mbs_f1u_info_at_cu.encode(data)?;

        Ok(())
    }
}

impl PerCodec for MulticastF1uContextSetupItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        MulticastF1uContextSetupItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MulticastF1uContextSetupItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MulticastF1uContextSetupItem");
            e
        })
    }
}
// MulticastF1uContextFailedToBeSetupItem
#[derive(Clone, Debug)]
pub struct MulticastF1uContextFailedToBeSetupItem {
    pub mrb_id: MrbId,
    pub cause: Option<Cause>,
}

impl MulticastF1uContextFailedToBeSetupItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 2)?;
        let mrb_id = MrbId::decode(data)?;
        let cause = if optionals[0] {
            Some(Cause::decode(data)?)
        } else {
            None
        };

        // Process the extension container

        if optionals[1] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self { mrb_id, cause })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.cause.is_some());
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.mrb_id.encode(data)?;
        if let Some(x) = &self.cause {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl PerCodec for MulticastF1uContextFailedToBeSetupItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        MulticastF1uContextFailedToBeSetupItem::decode_inner(data).map_err(
            |mut e: PerCodecError| {
                e.push_context("MulticastF1uContextFailedToBeSetupItem");
                e
            },
        )
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MulticastF1uContextFailedToBeSetupItem");
            e
        })
    }
}
// MbsptpRetransmissionTunnelRequired
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum MbsptpRetransmissionTunnelRequired {
    True,
}

impl MbsptpRetransmissionTunnelRequired {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(0), true)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(0),
            true,
            *self as i128,
            (*self as u32) >= 1,
        )
    }
}

impl PerCodec for MbsptpRetransmissionTunnelRequired {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        MbsptpRetransmissionTunnelRequired::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MbsptpRetransmissionTunnelRequired");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MbsptpRetransmissionTunnelRequired");
            e
        })
    }
}
// MbsServiceArea
#[derive(Clone, Debug)]
pub enum MbsServiceArea {
    Locationindependent(MbsServiceAreaInformation),
    Locationdependent(MbsServiceAreaInformationList),
}

impl MbsServiceArea {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_choice_idx(data, 0, 2, false)?;
        if extended {
            return Err(per_codec_error_new("CHOICE additions not implemented"));
        }
        match idx {
            0 => Ok(Self::Locationindependent(
                MbsServiceAreaInformation::decode(data)?,
            )),
            1 => Ok(Self::Locationdependent(
                MbsServiceAreaInformationList::decode(data)?,
            )),
            2 => {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _ = Criticality::decode(data)?;
                let _ = decode::decode_length_determinent(data, None, None, false)?;
                let result = match id {
                    x => Err(per_codec_error_new(format!("Unrecognised IE type {}", x))),
                };
                data.decode_align()?;
                result
            }
            _ => Err(per_codec_error_new("Unknown choice idx")),
        }
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        match self {
            Self::Locationindependent(x) => {
                encode::encode_choice_idx(data, 0, 2, false, 0, false)?;
                x.encode(data)
            }
            Self::Locationdependent(x) => {
                encode::encode_choice_idx(data, 0, 2, false, 1, false)?;
                x.encode(data)
            }
        }
    }
}

impl PerCodec for MbsServiceArea {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        MbsServiceArea::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MbsServiceArea");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MbsServiceArea");
            e
        })
    }
}
// MbsServiceAreaInformation
#[derive(Clone, Debug)]
pub struct MbsServiceAreaInformation {
    pub mbs_service_area_cell_list: Option<MbsServiceAreaCellList>,
    pub mbs_service_area_tai_list: Option<MbsServiceAreaTaiList>,
}

impl MbsServiceAreaInformation {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 3)?;
        let mbs_service_area_cell_list = if optionals[0] {
            Some(MbsServiceAreaCellList::decode(data)?)
        } else {
            None
        };
        let mbs_service_area_tai_list = if optionals[1] {
            Some(MbsServiceAreaTaiList::decode(data)?)
        } else {
            None
        };

        // Process the extension container

        if optionals[2] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            mbs_service_area_cell_list,
            mbs_service_area_tai_list,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.mbs_service_area_cell_list.is_some());
        optionals.push(self.mbs_service_area_tai_list.is_some());
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        if let Some(x) = &self.mbs_service_area_cell_list {
            x.encode(data)?;
        }
        if let Some(x) = &self.mbs_service_area_tai_list {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl PerCodec for MbsServiceAreaInformation {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        MbsServiceAreaInformation::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MbsServiceAreaInformation");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MbsServiceAreaInformation");
            e
        })
    }
}
// MbsServiceAreaCellList
#[derive(Clone, Debug)]
pub struct MbsServiceAreaCellList(pub NonEmpty<NrCgi>);

impl MbsServiceAreaCellList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(512), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(NrCgi::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(512), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for MbsServiceAreaCellList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        MbsServiceAreaCellList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MbsServiceAreaCellList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MbsServiceAreaCellList");
            e
        })
    }
}
// MbsServiceAreaTaiList
#[derive(Clone, Debug)]
pub struct MbsServiceAreaTaiList(pub NonEmpty<MbsServiceAreaTaiListItem>);

impl MbsServiceAreaTaiList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(512), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(MbsServiceAreaTaiListItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(512), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for MbsServiceAreaTaiList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        MbsServiceAreaTaiList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MbsServiceAreaTaiList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MbsServiceAreaTaiList");
            e
        })
    }
}
// MbsServiceAreaTaiListItem
#[derive(Clone, Debug)]
pub struct MbsServiceAreaTaiListItem {
    pub plmn_id: PlmnIdentity,
    pub five_gs_tac: FiveGsTac,
}

impl MbsServiceAreaTaiListItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let plmn_id = PlmnIdentity::decode(data)?;
        let five_gs_tac = FiveGsTac::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            plmn_id,
            five_gs_tac,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.plmn_id.encode(data)?;
        self.five_gs_tac.encode(data)?;

        Ok(())
    }
}

impl PerCodec for MbsServiceAreaTaiListItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        MbsServiceAreaTaiListItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MbsServiceAreaTaiListItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MbsServiceAreaTaiListItem");
            e
        })
    }
}
// MbsServiceAreaInformationList
#[derive(Clone, Debug)]
pub struct MbsServiceAreaInformationList(pub NonEmpty<MbsServiceAreaInformationItem>);

impl MbsServiceAreaInformationList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(256), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(MbsServiceAreaInformationItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(256), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for MbsServiceAreaInformationList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        MbsServiceAreaInformationList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MbsServiceAreaInformationList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MbsServiceAreaInformationList");
            e
        })
    }
}
// MbsServiceAreaInformationItem
#[derive(Clone, Debug)]
pub struct MbsServiceAreaInformationItem {
    pub mbs_area_session_id: MbsAreaSessionId,
    pub mbs_service_area_information: MbsServiceAreaInformation,
}

impl MbsServiceAreaInformationItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let mbs_area_session_id = MbsAreaSessionId::decode(data)?;
        let mbs_service_area_information = MbsServiceAreaInformation::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            mbs_area_session_id,
            mbs_service_area_information,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.mbs_area_session_id.encode(data)?;
        self.mbs_service_area_information.encode(data)?;

        Ok(())
    }
}

impl PerCodec for MbsServiceAreaInformationItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        MbsServiceAreaInformationItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MbsServiceAreaInformationItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MbsServiceAreaInformationItem");
            e
        })
    }
}
// McPagingCellItem
#[derive(Clone, Debug)]
pub struct McPagingCellItem {
    pub nr_cgi: NrCgi,
}

impl McPagingCellItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, false, 1)?;
        let nr_cgi = NrCgi::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self { nr_cgi })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, false, &optionals, false)?;
        self.nr_cgi.encode(data)?;

        Ok(())
    }
}

impl PerCodec for McPagingCellItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        McPagingCellItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("McPagingCellItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("McPagingCellItem");
            e
        })
    }
}
// MibMessage
#[derive(Clone, Debug)]
pub struct MibMessage(pub Vec<u8>);

impl MibMessage {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(decode::decode_octetstring(data, None, None, false)?))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_octetstring(data, None, None, false, &self.0, false)
    }
}

impl PerCodec for MibMessage {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        MibMessage::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MibMessage");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MibMessage");
            e
        })
    }
}
// MeasConfig
#[derive(Clone, Debug)]
pub struct MeasConfig(pub Vec<u8>);

impl MeasConfig {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(decode::decode_octetstring(data, None, None, false)?))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_octetstring(data, None, None, false, &self.0, false)
    }
}

impl PerCodec for MeasConfig {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        MeasConfig::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MeasConfig");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MeasConfig");
            e
        })
    }
}
// MeasGapConfig
#[derive(Clone, Debug)]
pub struct MeasGapConfig(pub Vec<u8>);

impl MeasGapConfig {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(decode::decode_octetstring(data, None, None, false)?))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_octetstring(data, None, None, false, &self.0, false)
    }
}

impl PerCodec for MeasGapConfig {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        MeasGapConfig::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MeasGapConfig");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MeasGapConfig");
            e
        })
    }
}
// MeasGapSharingConfig
#[derive(Clone, Debug)]
pub struct MeasGapSharingConfig(pub Vec<u8>);

impl MeasGapSharingConfig {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(decode::decode_octetstring(data, None, None, false)?))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_octetstring(data, None, None, false, &self.0, false)
    }
}

impl PerCodec for MeasGapSharingConfig {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        MeasGapSharingConfig::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MeasGapSharingConfig");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MeasGapSharingConfig");
            e
        })
    }
}
// PosMeasurementAmount
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum PosMeasurementAmount {
    Ma0,
    Ma1,
    Ma2,
    Ma4,
    Ma8,
    Ma16,
    Ma32,
    Ma64,
}

impl PosMeasurementAmount {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(7), false)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(7),
            false,
            *self as i128,
            (*self as u32) >= 8,
        )
    }
}

impl PerCodec for PosMeasurementAmount {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PosMeasurementAmount::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PosMeasurementAmount");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PosMeasurementAmount");
            e
        })
    }
}
// MeasurementBeamInfoRequest
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum MeasurementBeamInfoRequest {
    True,
}

impl MeasurementBeamInfoRequest {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(0), true)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(0),
            true,
            *self as i128,
            (*self as u32) >= 1,
        )
    }
}

impl PerCodec for MeasurementBeamInfoRequest {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        MeasurementBeamInfoRequest::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MeasurementBeamInfoRequest");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MeasurementBeamInfoRequest");
            e
        })
    }
}
// MeasurementBeamInfo
#[derive(Clone, Debug)]
pub struct MeasurementBeamInfo {
    pub prs_resource_id: Option<PrsResourceId>,
    pub prs_resource_set_id: Option<PrsResourceSetId>,
    pub ssb_index: Option<SsbIndex>,
}

impl MeasurementBeamInfo {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, false, 4)?;
        let prs_resource_id = if optionals[0] {
            Some(PrsResourceId::decode(data)?)
        } else {
            None
        };
        let prs_resource_set_id = if optionals[1] {
            Some(PrsResourceSetId::decode(data)?)
        } else {
            None
        };
        let ssb_index = if optionals[2] {
            Some(SsbIndex::decode(data)?)
        } else {
            None
        };

        // Process the extension container

        if optionals[3] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            prs_resource_id,
            prs_resource_set_id,
            ssb_index,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.prs_resource_id.is_some());
        optionals.push(self.prs_resource_set_id.is_some());
        optionals.push(self.ssb_index.is_some());
        optionals.push(false);

        encode::encode_sequence_header(data, false, &optionals, false)?;
        if let Some(x) = &self.prs_resource_id {
            x.encode(data)?;
        }
        if let Some(x) = &self.prs_resource_set_id {
            x.encode(data)?;
        }
        if let Some(x) = &self.ssb_index {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl PerCodec for MeasurementBeamInfo {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        MeasurementBeamInfo::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MeasurementBeamInfo");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MeasurementBeamInfo");
            e
        })
    }
}
// MeasurementTimingConfiguration
#[derive(Clone, Debug)]
pub struct MeasurementTimingConfiguration(pub Vec<u8>);

impl MeasurementTimingConfiguration {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(decode::decode_octetstring(data, None, None, false)?))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_octetstring(data, None, None, false, &self.0, false)
    }
}

impl PerCodec for MeasurementTimingConfiguration {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        MeasurementTimingConfiguration::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MeasurementTimingConfiguration");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MeasurementTimingConfiguration");
            e
        })
    }
}
// MessageIdentifier
#[derive(Clone, Debug)]
pub struct MessageIdentifier(pub BitString);

impl MessageIdentifier {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(decode::decode_bitstring(
            data,
            Some(16),
            Some(16),
            false,
        )?))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_bitstring(data, Some(16), Some(16), false, &self.0, false)
    }
}

impl PerCodec for MessageIdentifier {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        MessageIdentifier::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MessageIdentifier");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MessageIdentifier");
            e
        })
    }
}
// MeasurementTimeOccasion
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum MeasurementTimeOccasion {
    O1,
    O4,
}

impl MeasurementTimeOccasion {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(1), true)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(1),
            true,
            *self as i128,
            (*self as u32) >= 2,
        )
    }
}

impl PerCodec for MeasurementTimeOccasion {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        MeasurementTimeOccasion::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MeasurementTimeOccasion");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MeasurementTimeOccasion");
            e
        })
    }
}
// MeasurementCharacteristicsRequestIndicator
#[derive(Clone, Debug)]
pub struct MeasurementCharacteristicsRequestIndicator(pub BitString);

impl MeasurementCharacteristicsRequestIndicator {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(decode::decode_bitstring(
            data,
            Some(16),
            Some(16),
            false,
        )?))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_bitstring(data, Some(16), Some(16), false, &self.0, false)
    }
}

impl PerCodec for MeasurementCharacteristicsRequestIndicator {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        MeasurementCharacteristicsRequestIndicator::decode_inner(data).map_err(
            |mut e: PerCodecError| {
                e.push_context("MeasurementCharacteristicsRequestIndicator");
                e
            },
        )
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MeasurementCharacteristicsRequestIndicator");
            e
        })
    }
}
// MrbProgressInformation
#[derive(Clone, Debug)]
pub enum MrbProgressInformation {
    PdcpSn12(u16),
    PdcpSn18(u32),
}

impl MrbProgressInformation {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_choice_idx(data, 0, 2, false)?;
        if extended {
            return Err(per_codec_error_new("CHOICE additions not implemented"));
        }
        match idx {
            0 => Ok(Self::PdcpSn12(
                decode::decode_integer(data, Some(0), Some(4095), false)?.0 as u16,
            )),
            1 => Ok(Self::PdcpSn18(
                decode::decode_integer(data, Some(0), Some(262143), false)?.0 as u32,
            )),
            2 => {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _ = Criticality::decode(data)?;
                let _ = decode::decode_length_determinent(data, None, None, false)?;
                let result = match id {
                    x => Err(per_codec_error_new(format!("Unrecognised IE type {}", x))),
                };
                data.decode_align()?;
                result
            }
            _ => Err(per_codec_error_new("Unknown choice idx")),
        }
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        match self {
            Self::PdcpSn12(x) => {
                encode::encode_choice_idx(data, 0, 2, false, 0, false)?;
                encode::encode_integer(data, Some(0), Some(4095), false, *x as i128, false)
            }
            Self::PdcpSn18(x) => {
                encode::encode_choice_idx(data, 0, 2, false, 1, false)?;
                encode::encode_integer(data, Some(0), Some(262143), false, *x as i128, false)
            }
        }
    }
}

impl PerCodec for MrbProgressInformation {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        MrbProgressInformation::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MrbProgressInformation");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MrbProgressInformation");
            e
        })
    }
}
// MulticastF1uContextReferenceF1
#[derive(Clone, Debug)]
pub struct MulticastF1uContextReferenceF1(pub [u8; 4]);

impl MulticastF1uContextReferenceF1 {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(
            decode::decode_octetstring(data, Some(4), Some(4), false)?
                .try_into()
                .unwrap(),
        ))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_octetstring(data, Some(4), Some(4), false, &(self.0).into(), false)
    }
}

impl PerCodec for MulticastF1uContextReferenceF1 {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        MulticastF1uContextReferenceF1::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MulticastF1uContextReferenceF1");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MulticastF1uContextReferenceF1");
            e
        })
    }
}
// MulticastF1uContextReferenceCu
#[derive(Clone, Debug)]
pub struct MulticastF1uContextReferenceCu(pub [u8; 4]);

impl MulticastF1uContextReferenceCu {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(
            decode::decode_octetstring(data, Some(4), Some(4), false)?
                .try_into()
                .unwrap(),
        ))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_octetstring(data, Some(4), Some(4), false, &(self.0).into(), false)
    }
}

impl PerCodec for MulticastF1uContextReferenceCu {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        MulticastF1uContextReferenceCu::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MulticastF1uContextReferenceCu");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MulticastF1uContextReferenceCu");
            e
        })
    }
}
// MultipleUlAoA
#[derive(Clone, Debug)]
pub struct MultipleUlAoA {
    pub multiple_ul_ao_a: MultipleUlAoAList,
}

impl MultipleUlAoA {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let multiple_ul_ao_a = MultipleUlAoAList::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self { multiple_ul_ao_a })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.multiple_ul_ao_a.encode(data)?;

        Ok(())
    }
}

impl PerCodec for MultipleUlAoA {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        MultipleUlAoA::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MultipleUlAoA");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MultipleUlAoA");
            e
        })
    }
}
// MultipleUlAoAList
#[derive(Clone, Debug)]
pub struct MultipleUlAoAList(pub NonEmpty<MultipleUlAoAItem>);

impl MultipleUlAoAList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(8), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(MultipleUlAoAItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(8), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for MultipleUlAoAList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        MultipleUlAoAList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MultipleUlAoAList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MultipleUlAoAList");
            e
        })
    }
}
// MultipleUlAoAItem
#[derive(Clone, Debug)]
pub enum MultipleUlAoAItem {
    UlAoA(UlAoA),
    UlZoA(ZoAInformation),
}

impl MultipleUlAoAItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_choice_idx(data, 0, 2, false)?;
        if extended {
            return Err(per_codec_error_new("CHOICE additions not implemented"));
        }
        match idx {
            0 => Ok(Self::UlAoA(UlAoA::decode(data)?)),
            1 => Ok(Self::UlZoA(ZoAInformation::decode(data)?)),
            2 => {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _ = Criticality::decode(data)?;
                let _ = decode::decode_length_determinent(data, None, None, false)?;
                let result = match id {
                    x => Err(per_codec_error_new(format!("Unrecognised IE type {}", x))),
                };
                data.decode_align()?;
                result
            }
            _ => Err(per_codec_error_new("Unknown choice idx")),
        }
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        match self {
            Self::UlAoA(x) => {
                encode::encode_choice_idx(data, 0, 2, false, 0, false)?;
                x.encode(data)
            }
            Self::UlZoA(x) => {
                encode::encode_choice_idx(data, 0, 2, false, 1, false)?;
                x.encode(data)
            }
        }
    }
}

impl PerCodec for MultipleUlAoAItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        MultipleUlAoAItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MultipleUlAoAItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MultipleUlAoAItem");
            e
        })
    }
}
// MdtPollutedMeasurementIndicator
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum MdtPollutedMeasurementIndicator {
    Idc,
    NoIdc,
}

impl MdtPollutedMeasurementIndicator {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(1), true)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(1),
            true,
            *self as i128,
            (*self as u32) >= 2,
        )
    }
}

impl PerCodec for MdtPollutedMeasurementIndicator {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        MdtPollutedMeasurementIndicator::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MdtPollutedMeasurementIndicator");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MdtPollutedMeasurementIndicator");
            e
        })
    }
}
// MrbId
#[derive(Clone, Copy, Debug)]
pub struct MrbId(pub u16);

impl MrbId {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(
            decode::decode_integer(data, Some(1), Some(512), true)?.0 as u16,
        ))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_integer(data, Some(1), Some(512), true, self.0 as i128, false)
    }
}

impl PerCodec for MrbId {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        MrbId::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MrbId");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MrbId");
            e
        })
    }
}
// MulticastMbsSessionList
#[derive(Clone, Debug)]
pub struct MulticastMbsSessionList(pub NonEmpty<MulticastMbsSessionListItem>);

impl MulticastMbsSessionList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(256), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(MulticastMbsSessionListItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(256), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for MulticastMbsSessionList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        MulticastMbsSessionList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MulticastMbsSessionList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MulticastMbsSessionList");
            e
        })
    }
}
// MulticastMbsSessionListItem
#[derive(Clone, Debug)]
pub struct MulticastMbsSessionListItem {
    pub mbs_session_id: MbsSessionId,
}

impl MulticastMbsSessionListItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let mbs_session_id = MbsSessionId::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self { mbs_session_id })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.mbs_session_id.encode(data)?;

        Ok(())
    }
}

impl PerCodec for MulticastMbsSessionListItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        MulticastMbsSessionListItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MulticastMbsSessionListItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MulticastMbsSessionListItem");
            e
        })
    }
}
// MulticastMrBsFailedToBeModifiedItem
#[derive(Clone, Debug)]
pub struct MulticastMrBsFailedToBeModifiedItem {
    pub mrb_id: MrbId,
    pub cause: Option<Cause>,
}

impl MulticastMrBsFailedToBeModifiedItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 2)?;
        let mrb_id = MrbId::decode(data)?;
        let cause = if optionals[0] {
            Some(Cause::decode(data)?)
        } else {
            None
        };

        // Process the extension container

        if optionals[1] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self { mrb_id, cause })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.cause.is_some());
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.mrb_id.encode(data)?;
        if let Some(x) = &self.cause {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl PerCodec for MulticastMrBsFailedToBeModifiedItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        MulticastMrBsFailedToBeModifiedItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MulticastMrBsFailedToBeModifiedItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MulticastMrBsFailedToBeModifiedItem");
            e
        })
    }
}
// MulticastMrBsFailedToBeSetupItem
#[derive(Clone, Debug)]
pub struct MulticastMrBsFailedToBeSetupItem {
    pub mrb_id: MrbId,
    pub cause: Option<Cause>,
}

impl MulticastMrBsFailedToBeSetupItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 2)?;
        let mrb_id = MrbId::decode(data)?;
        let cause = if optionals[0] {
            Some(Cause::decode(data)?)
        } else {
            None
        };

        // Process the extension container

        if optionals[1] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self { mrb_id, cause })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.cause.is_some());
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.mrb_id.encode(data)?;
        if let Some(x) = &self.cause {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl PerCodec for MulticastMrBsFailedToBeSetupItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        MulticastMrBsFailedToBeSetupItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MulticastMrBsFailedToBeSetupItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MulticastMrBsFailedToBeSetupItem");
            e
        })
    }
}
// MulticastMrBsFailedToBeSetupModItem
#[derive(Clone, Debug)]
pub struct MulticastMrBsFailedToBeSetupModItem {
    pub mrb_id: MrbId,
    pub cause: Option<Cause>,
}

impl MulticastMrBsFailedToBeSetupModItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 2)?;
        let mrb_id = MrbId::decode(data)?;
        let cause = if optionals[0] {
            Some(Cause::decode(data)?)
        } else {
            None
        };

        // Process the extension container

        if optionals[1] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self { mrb_id, cause })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.cause.is_some());
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.mrb_id.encode(data)?;
        if let Some(x) = &self.cause {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl PerCodec for MulticastMrBsFailedToBeSetupModItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        MulticastMrBsFailedToBeSetupModItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MulticastMrBsFailedToBeSetupModItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MulticastMrBsFailedToBeSetupModItem");
            e
        })
    }
}
// MulticastMrBsModifiedItem
#[derive(Clone, Debug)]
pub struct MulticastMrBsModifiedItem {
    pub mrb_id: MrbId,
}

impl MulticastMrBsModifiedItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let mrb_id = MrbId::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self { mrb_id })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.mrb_id.encode(data)?;

        Ok(())
    }
}

impl PerCodec for MulticastMrBsModifiedItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        MulticastMrBsModifiedItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MulticastMrBsModifiedItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MulticastMrBsModifiedItem");
            e
        })
    }
}
// MulticastMrBsSetupItem
#[derive(Clone, Debug)]
pub struct MulticastMrBsSetupItem {
    pub mrb_id: MrbId,
}

impl MulticastMrBsSetupItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let mrb_id = MrbId::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self { mrb_id })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.mrb_id.encode(data)?;

        Ok(())
    }
}

impl PerCodec for MulticastMrBsSetupItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        MulticastMrBsSetupItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MulticastMrBsSetupItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MulticastMrBsSetupItem");
            e
        })
    }
}
// MulticastMrBsSetupModItem
#[derive(Clone, Debug)]
pub struct MulticastMrBsSetupModItem {
    pub mrb_id: MrbId,
}

impl MulticastMrBsSetupModItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let mrb_id = MrbId::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self { mrb_id })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.mrb_id.encode(data)?;

        Ok(())
    }
}

impl PerCodec for MulticastMrBsSetupModItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        MulticastMrBsSetupModItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MulticastMrBsSetupModItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MulticastMrBsSetupModItem");
            e
        })
    }
}
// MulticastMrBsToBeModifiedItem
#[derive(Clone, Debug)]
pub struct MulticastMrBsToBeModifiedItem {
    pub mrb_id: MrbId,
    pub mrb_qos_information: Option<QosFlowLevelQosParameters>,
    pub mbs_flows_mapped_to_mrb_list: Option<MbsFlowsMappedToMrbList>,
    pub mbs_dl_pdcp_sn_length: Option<PdcpsnLength>,
}

impl MulticastMrBsToBeModifiedItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 4)?;
        let mrb_id = MrbId::decode(data)?;
        let mrb_qos_information = if optionals[0] {
            Some(QosFlowLevelQosParameters::decode(data)?)
        } else {
            None
        };
        let mbs_flows_mapped_to_mrb_list = if optionals[1] {
            Some(MbsFlowsMappedToMrbList::decode(data)?)
        } else {
            None
        };
        let mbs_dl_pdcp_sn_length = if optionals[2] {
            Some(PdcpsnLength::decode(data)?)
        } else {
            None
        };

        // Process the extension container

        if optionals[3] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            mrb_id,
            mrb_qos_information,
            mbs_flows_mapped_to_mrb_list,
            mbs_dl_pdcp_sn_length,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.mrb_qos_information.is_some());
        optionals.push(self.mbs_flows_mapped_to_mrb_list.is_some());
        optionals.push(self.mbs_dl_pdcp_sn_length.is_some());
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.mrb_id.encode(data)?;
        if let Some(x) = &self.mrb_qos_information {
            x.encode(data)?;
        }
        if let Some(x) = &self.mbs_flows_mapped_to_mrb_list {
            x.encode(data)?;
        }
        if let Some(x) = &self.mbs_dl_pdcp_sn_length {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl PerCodec for MulticastMrBsToBeModifiedItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        MulticastMrBsToBeModifiedItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MulticastMrBsToBeModifiedItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MulticastMrBsToBeModifiedItem");
            e
        })
    }
}
// MulticastMrBsToBeReleasedItem
#[derive(Clone, Debug)]
pub struct MulticastMrBsToBeReleasedItem {
    pub mrb_id: MrbId,
}

impl MulticastMrBsToBeReleasedItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let mrb_id = MrbId::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self { mrb_id })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.mrb_id.encode(data)?;

        Ok(())
    }
}

impl PerCodec for MulticastMrBsToBeReleasedItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        MulticastMrBsToBeReleasedItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MulticastMrBsToBeReleasedItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MulticastMrBsToBeReleasedItem");
            e
        })
    }
}
// MulticastMrBsToBeSetupItem
#[derive(Clone, Debug)]
pub struct MulticastMrBsToBeSetupItem {
    pub mrb_id: MrbId,
    pub mrb_qos_information: QosFlowLevelQosParameters,
    pub mbs_flows_mapped_to_mrb_list: MbsFlowsMappedToMrbList,
    pub mbs_dl_pdcp_sn_length: PdcpsnLength,
}

impl MulticastMrBsToBeSetupItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let mrb_id = MrbId::decode(data)?;
        let mrb_qos_information = QosFlowLevelQosParameters::decode(data)?;
        let mbs_flows_mapped_to_mrb_list = MbsFlowsMappedToMrbList::decode(data)?;
        let mbs_dl_pdcp_sn_length = PdcpsnLength::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            mrb_id,
            mrb_qos_information,
            mbs_flows_mapped_to_mrb_list,
            mbs_dl_pdcp_sn_length,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.mrb_id.encode(data)?;
        self.mrb_qos_information.encode(data)?;
        self.mbs_flows_mapped_to_mrb_list.encode(data)?;
        self.mbs_dl_pdcp_sn_length.encode(data)?;

        Ok(())
    }
}

impl PerCodec for MulticastMrBsToBeSetupItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        MulticastMrBsToBeSetupItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MulticastMrBsToBeSetupItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MulticastMrBsToBeSetupItem");
            e
        })
    }
}
// MulticastMrBsToBeSetupModItem
#[derive(Clone, Debug)]
pub struct MulticastMrBsToBeSetupModItem {
    pub mrb_id: MrbId,
    pub mrb_qos_information: QosFlowLevelQosParameters,
    pub mbs_flows_mapped_to_mrb_list: MbsFlowsMappedToMrbList,
    pub mbs_dl_pdcp_sn_length: PdcpsnLength,
}

impl MulticastMrBsToBeSetupModItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let mrb_id = MrbId::decode(data)?;
        let mrb_qos_information = QosFlowLevelQosParameters::decode(data)?;
        let mbs_flows_mapped_to_mrb_list = MbsFlowsMappedToMrbList::decode(data)?;
        let mbs_dl_pdcp_sn_length = PdcpsnLength::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            mrb_id,
            mrb_qos_information,
            mbs_flows_mapped_to_mrb_list,
            mbs_dl_pdcp_sn_length,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.mrb_id.encode(data)?;
        self.mrb_qos_information.encode(data)?;
        self.mbs_flows_mapped_to_mrb_list.encode(data)?;
        self.mbs_dl_pdcp_sn_length.encode(data)?;

        Ok(())
    }
}

impl PerCodec for MulticastMrBsToBeSetupModItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        MulticastMrBsToBeSetupModItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MulticastMrBsToBeSetupModItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MulticastMrBsToBeSetupModItem");
            e
        })
    }
}
// MultiplexingInfo
#[derive(Clone, Debug)]
pub struct MultiplexingInfo {
    pub iab_mt_cell_list: IabMtCellList,
}

impl MultiplexingInfo {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, false, 1)?;
        let iab_mt_cell_list = IabMtCellList::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self { iab_mt_cell_list })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, false, &optionals, false)?;
        self.iab_mt_cell_list.encode(data)?;

        Ok(())
    }
}

impl PerCodec for MultiplexingInfo {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        MultiplexingInfo::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MultiplexingInfo");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MultiplexingInfo");
            e
        })
    }
}
// MusimCapabilityRestrictionIndication
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum MusimCapabilityRestrictionIndication {
    True,
}

impl MusimCapabilityRestrictionIndication {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(0), true)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(0),
            true,
            *self as i128,
            (*self as u32) >= 1,
        )
    }
}

impl PerCodec for MusimCapabilityRestrictionIndication {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        MusimCapabilityRestrictionIndication::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MusimCapabilityRestrictionIndication");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MusimCapabilityRestrictionIndication");
            e
        })
    }
}
// MusimCandidateBandList
#[derive(Clone, Debug)]
pub struct MusimCandidateBandList(pub Vec<u8>);

impl MusimCandidateBandList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(decode::decode_octetstring(data, None, None, false)?))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_octetstring(data, None, None, false, &self.0, false)
    }
}

impl PerCodec for MusimCandidateBandList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        MusimCandidateBandList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MusimCandidateBandList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MusimCandidateBandList");
            e
        })
    }
}
// M2Configuration
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum M2Configuration {
    True,
}

impl M2Configuration {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(0), true)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(0),
            true,
            *self as i128,
            (*self as u32) >= 1,
        )
    }
}

impl PerCodec for M2Configuration {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        M2Configuration::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("M2Configuration");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("M2Configuration");
            e
        })
    }
}
// M5Configuration
#[derive(Clone, Debug)]
pub struct M5Configuration {
    pub m5period: M5period,
    pub m5_links_to_log: M5LinksToLog,
    pub m5_report_amount: Option<M5ReportAmount>,
}

impl M5Configuration {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let m5period = M5period::decode(data)?;
        let m5_links_to_log = M5LinksToLog::decode(data)?;

        // Process the extension container
        let mut m5_report_amount: Option<M5ReportAmount> = None;

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    537 => m5_report_amount = Some(M5ReportAmount::decode(data)?),
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            m5period,
            m5_links_to_log,
            m5_report_amount,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();
        if let Some(x) = &self.m5_report_amount {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 537, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        let mut optionals = BitString::new();
        optionals.push(num_ies != 0);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.m5period.encode(data)?;
        self.m5_links_to_log.encode(data)?;
        if num_ies != 0 {
            encode::encode_length_determinent(data, Some(1), Some(65535), false, num_ies)?;
            data.append_aligned(ies);
        }
        Ok(())
    }
}

impl PerCodec for M5Configuration {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        M5Configuration::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("M5Configuration");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("M5Configuration");
            e
        })
    }
}
// M5period
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum M5period {
    Ms1024,
    Ms2048,
    Ms5120,
    Ms10240,
    Min1,
}

impl M5period {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(4), true)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(4),
            true,
            *self as i128,
            (*self as u32) >= 5,
        )
    }
}

impl PerCodec for M5period {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        M5period::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("M5period");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("M5period");
            e
        })
    }
}
// M5ReportAmount
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum M5ReportAmount {
    R1,
    R2,
    R4,
    R8,
    R16,
    R32,
    R64,
    Infinity,
}

impl M5ReportAmount {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(7), true)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(7),
            true,
            *self as i128,
            (*self as u32) >= 8,
        )
    }
}

impl PerCodec for M5ReportAmount {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        M5ReportAmount::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("M5ReportAmount");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("M5ReportAmount");
            e
        })
    }
}
// M5LinksToLog
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum M5LinksToLog {
    Uplink,
    Downlink,
    BothUplinkAndDownlink,
}

impl M5LinksToLog {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(2), true)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(2),
            true,
            *self as i128,
            (*self as u32) >= 3,
        )
    }
}

impl PerCodec for M5LinksToLog {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        M5LinksToLog::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("M5LinksToLog");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("M5LinksToLog");
            e
        })
    }
}
// M6Configuration
#[derive(Clone, Debug)]
pub struct M6Configuration {
    pub m6report_interval: M6reportInterval,
    pub m6_links_to_log: M6LinksToLog,
    pub m6_report_amount: Option<M6ReportAmount>,
}

impl M6Configuration {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let m6report_interval = M6reportInterval::decode(data)?;
        let m6_links_to_log = M6LinksToLog::decode(data)?;

        // Process the extension container
        let mut m6_report_amount: Option<M6ReportAmount> = None;

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    538 => m6_report_amount = Some(M6ReportAmount::decode(data)?),
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            m6report_interval,
            m6_links_to_log,
            m6_report_amount,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();
        if let Some(x) = &self.m6_report_amount {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 538, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        let mut optionals = BitString::new();
        optionals.push(num_ies != 0);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.m6report_interval.encode(data)?;
        self.m6_links_to_log.encode(data)?;
        if num_ies != 0 {
            encode::encode_length_determinent(data, Some(1), Some(65535), false, num_ies)?;
            data.append_aligned(ies);
        }
        Ok(())
    }
}

impl PerCodec for M6Configuration {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        M6Configuration::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("M6Configuration");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("M6Configuration");
            e
        })
    }
}
// M6reportInterval
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum M6reportInterval {
    Ms120,
    Ms240,
    Ms640,
    Ms1024,
    Ms2048,
    Ms5120,
    Ms10240,
    Ms20480,
    Ms40960,
    Min1,
    Min6,
    Min12,
    Min30,
    Ms480,
}

impl M6reportInterval {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(12), true)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(12),
            true,
            *self as i128,
            (*self as u32) >= 13,
        )
    }
}

impl PerCodec for M6reportInterval {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        M6reportInterval::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("M6reportInterval");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("M6reportInterval");
            e
        })
    }
}
// M6ReportAmount
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum M6ReportAmount {
    R1,
    R2,
    R4,
    R8,
    R16,
    R32,
    R64,
    Infinity,
}

impl M6ReportAmount {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(7), true)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(7),
            true,
            *self as i128,
            (*self as u32) >= 8,
        )
    }
}

impl PerCodec for M6ReportAmount {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        M6ReportAmount::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("M6ReportAmount");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("M6ReportAmount");
            e
        })
    }
}
// M6LinksToLog
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum M6LinksToLog {
    Uplink,
    Downlink,
    BothUplinkAndDownlink,
}

impl M6LinksToLog {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(2), true)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(2),
            true,
            *self as i128,
            (*self as u32) >= 3,
        )
    }
}

impl PerCodec for M6LinksToLog {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        M6LinksToLog::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("M6LinksToLog");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("M6LinksToLog");
            e
        })
    }
}
// M7Configuration
#[derive(Clone, Debug)]
pub struct M7Configuration {
    pub m7period: M7period,
    pub m7_links_to_log: M7LinksToLog,
    pub m7_report_amount: Option<M7ReportAmount>,
}

impl M7Configuration {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let m7period = M7period::decode(data)?;
        let m7_links_to_log = M7LinksToLog::decode(data)?;

        // Process the extension container
        let mut m7_report_amount: Option<M7ReportAmount> = None;

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    539 => m7_report_amount = Some(M7ReportAmount::decode(data)?),
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            m7period,
            m7_links_to_log,
            m7_report_amount,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();
        if let Some(x) = &self.m7_report_amount {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 539, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        let mut optionals = BitString::new();
        optionals.push(num_ies != 0);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.m7period.encode(data)?;
        self.m7_links_to_log.encode(data)?;
        if num_ies != 0 {
            encode::encode_length_determinent(data, Some(1), Some(65535), false, num_ies)?;
            data.append_aligned(ies);
        }
        Ok(())
    }
}

impl PerCodec for M7Configuration {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        M7Configuration::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("M7Configuration");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("M7Configuration");
            e
        })
    }
}
// M7period
#[derive(Clone, Copy, Debug)]
pub struct M7period(pub u8);

impl M7period {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(
            decode::decode_integer(data, Some(1), Some(60), true)?.0 as u8,
        ))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_integer(data, Some(1), Some(60), true, self.0 as i128, false)
    }
}

impl PerCodec for M7period {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        M7period::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("M7period");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("M7period");
            e
        })
    }
}
// M7ReportAmount
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum M7ReportAmount {
    R1,
    R2,
    R4,
    R8,
    R16,
    R32,
    R64,
    Infinity,
}

impl M7ReportAmount {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(7), true)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(7),
            true,
            *self as i128,
            (*self as u32) >= 8,
        )
    }
}

impl PerCodec for M7ReportAmount {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        M7ReportAmount::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("M7ReportAmount");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("M7ReportAmount");
            e
        })
    }
}
// M7LinksToLog
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum M7LinksToLog {
    Downlink,
}

impl M7LinksToLog {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(0), true)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(0),
            true,
            *self as i128,
            (*self as u32) >= 1,
        )
    }
}

impl PerCodec for M7LinksToLog {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        M7LinksToLog::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("M7LinksToLog");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("M7LinksToLog");
            e
        })
    }
}
// MdtActivation
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum MdtActivation {
    ImmediateMdtOnly,
    ImmediateMdtAndTrace,
}

impl MdtActivation {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(1), true)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(1),
            true,
            *self as i128,
            (*self as u32) >= 2,
        )
    }
}

impl PerCodec for MdtActivation {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        MdtActivation::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MdtActivation");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MdtActivation");
            e
        })
    }
}
// MdtConfiguration
#[derive(Clone, Debug)]
pub struct MdtConfiguration {
    pub mdt_activation: MdtActivation,
    pub measurements_to_activate: MeasurementsToActivate,
    pub m2_configuration: Option<M2Configuration>,
    pub m5_configuration: Option<M5Configuration>,
    pub m6_configuration: Option<M6Configuration>,
    pub m7_configuration: Option<M7Configuration>,
}

impl MdtConfiguration {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 5)?;
        let mdt_activation = MdtActivation::decode(data)?;
        let measurements_to_activate = MeasurementsToActivate::decode(data)?;
        let m2_configuration = if optionals[0] {
            Some(M2Configuration::decode(data)?)
        } else {
            None
        };
        let m5_configuration = if optionals[1] {
            Some(M5Configuration::decode(data)?)
        } else {
            None
        };
        let m6_configuration = if optionals[2] {
            Some(M6Configuration::decode(data)?)
        } else {
            None
        };
        let m7_configuration = if optionals[3] {
            Some(M7Configuration::decode(data)?)
        } else {
            None
        };

        // Process the extension container

        if optionals[4] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            mdt_activation,
            measurements_to_activate,
            m2_configuration,
            m5_configuration,
            m6_configuration,
            m7_configuration,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.m2_configuration.is_some());
        optionals.push(self.m5_configuration.is_some());
        optionals.push(self.m6_configuration.is_some());
        optionals.push(self.m7_configuration.is_some());
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.mdt_activation.encode(data)?;
        self.measurements_to_activate.encode(data)?;
        if let Some(x) = &self.m2_configuration {
            x.encode(data)?;
        }
        if let Some(x) = &self.m5_configuration {
            x.encode(data)?;
        }
        if let Some(x) = &self.m6_configuration {
            x.encode(data)?;
        }
        if let Some(x) = &self.m7_configuration {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl PerCodec for MdtConfiguration {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        MdtConfiguration::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MdtConfiguration");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MdtConfiguration");
            e
        })
    }
}
// MdtPlmnList
#[derive(Clone, Debug)]
pub struct MdtPlmnList(pub NonEmpty<PlmnIdentity>);

impl MdtPlmnList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(16), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(PlmnIdentity::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(16), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for MdtPlmnList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        MdtPlmnList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MdtPlmnList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MdtPlmnList");
            e
        })
    }
}
// MdtPlmnModificationList
#[derive(Clone, Debug)]
pub struct MdtPlmnModificationList(pub Vec<PlmnIdentity>);

impl MdtPlmnModificationList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(0), Some(16), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(PlmnIdentity::decode(data)?);
            }
            items
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(0), Some(16), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for MdtPlmnModificationList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        MdtPlmnModificationList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MdtPlmnModificationList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MdtPlmnModificationList");
            e
        })
    }
}
// MeasuredFrequencyHops
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum MeasuredFrequencyHops {
    SingleHop,
    MultiHop,
}

impl MeasuredFrequencyHops {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(1), true)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(1),
            true,
            *self as i128,
            (*self as u32) >= 2,
        )
    }
}

impl PerCodec for MeasuredFrequencyHops {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        MeasuredFrequencyHops::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MeasuredFrequencyHops");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MeasuredFrequencyHops");
            e
        })
    }
}
// MeasuredResultsValue
#[derive(Clone, Debug)]
pub enum MeasuredResultsValue {
    UlAngleOfArrival(UlAoA),
    UlSrsRsrp(UlSrsRsrp),
    UlRtoa(UlRtoaMeasurement),
    GnbRxTxTimeDiff(GnbRxTxTimeDiff),
    ZoAInformation(ZoAInformation),
    MultipleUlAoA(MultipleUlAoA),
    UlSrsRsrpp(UlSrsRsrpp),
    UlRscp(UlRscp),
}

impl MeasuredResultsValue {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_choice_idx(data, 0, 4, false)?;
        if extended {
            return Err(per_codec_error_new("CHOICE additions not implemented"));
        }
        match idx {
            0 => Ok(Self::UlAngleOfArrival(UlAoA::decode(data)?)),
            1 => Ok(Self::UlSrsRsrp(UlSrsRsrp::decode(data)?)),
            2 => Ok(Self::UlRtoa(UlRtoaMeasurement::decode(data)?)),
            3 => Ok(Self::GnbRxTxTimeDiff(GnbRxTxTimeDiff::decode(data)?)),
            4 => {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _ = Criticality::decode(data)?;
                let _ = decode::decode_length_determinent(data, None, None, false)?;
                let result = match id {
                    554 => Ok(Self::ZoAInformation(ZoAInformation::decode(data)?)),
                    558 => Ok(Self::MultipleUlAoA(MultipleUlAoA::decode(data)?)),
                    559 => Ok(Self::UlSrsRsrpp(UlSrsRsrpp::decode(data)?)),
                    804 => Ok(Self::UlRscp(UlRscp::decode(data)?)),
                    x => Err(per_codec_error_new(format!("Unrecognised IE type {}", x))),
                };
                data.decode_align()?;
                result
            }
            _ => Err(per_codec_error_new("Unknown choice idx")),
        }
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        match self {
            Self::UlAngleOfArrival(x) => {
                encode::encode_choice_idx(data, 0, 4, false, 0, false)?;
                x.encode(data)
            }
            Self::UlSrsRsrp(x) => {
                encode::encode_choice_idx(data, 0, 4, false, 1, false)?;
                x.encode(data)
            }
            Self::UlRtoa(x) => {
                encode::encode_choice_idx(data, 0, 4, false, 2, false)?;
                x.encode(data)
            }
            Self::GnbRxTxTimeDiff(x) => {
                encode::encode_choice_idx(data, 0, 4, false, 3, false)?;
                x.encode(data)
            }
            Self::ZoAInformation(x) => {
                encode::encode_choice_idx(data, 0, 4, false, 4, false)?;
                encode::encode_integer(data, Some(0), Some(65535), false, 554, false)?;
                Criticality::Reject.encode(data)?;
                let ie = &mut Allocator::new_codec_data();
                x.encode(ie)?;
                encode::encode_length_determinent(data, None, None, false, ie.length_in_bytes())?;
                Ok(data.append_aligned(ie))
            }
            Self::MultipleUlAoA(x) => {
                encode::encode_choice_idx(data, 0, 4, false, 4, false)?;
                encode::encode_integer(data, Some(0), Some(65535), false, 558, false)?;
                Criticality::Reject.encode(data)?;
                let ie = &mut Allocator::new_codec_data();
                x.encode(ie)?;
                encode::encode_length_determinent(data, None, None, false, ie.length_in_bytes())?;
                Ok(data.append_aligned(ie))
            }
            Self::UlSrsRsrpp(x) => {
                encode::encode_choice_idx(data, 0, 4, false, 4, false)?;
                encode::encode_integer(data, Some(0), Some(65535), false, 559, false)?;
                Criticality::Reject.encode(data)?;
                let ie = &mut Allocator::new_codec_data();
                x.encode(ie)?;
                encode::encode_length_determinent(data, None, None, false, ie.length_in_bytes())?;
                Ok(data.append_aligned(ie))
            }
            Self::UlRscp(x) => {
                encode::encode_choice_idx(data, 0, 4, false, 4, false)?;
                encode::encode_integer(data, Some(0), Some(65535), false, 804, false)?;
                Criticality::Reject.encode(data)?;
                let ie = &mut Allocator::new_codec_data();
                x.encode(ie)?;
                encode::encode_length_determinent(data, None, None, false, ie.length_in_bytes())?;
                Ok(data.append_aligned(ie))
            }
        }
    }
}

impl PerCodec for MeasuredResultsValue {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        MeasuredResultsValue::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MeasuredResultsValue");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MeasuredResultsValue");
            e
        })
    }
}
// MeasurementsToActivate
#[derive(Clone, Debug)]
pub struct MeasurementsToActivate(pub BitString);

impl MeasurementsToActivate {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(decode::decode_bitstring(
            data,
            Some(8),
            Some(8),
            false,
        )?))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_bitstring(data, Some(8), Some(8), false, &self.0, false)
    }
}

impl PerCodec for MeasurementsToActivate {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        MeasurementsToActivate::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MeasurementsToActivate");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MeasurementsToActivate");
            e
        })
    }
}
// MobileTrpLocationInformation
#[derive(Clone, Debug)]
pub struct MobileTrpLocationInformation {
    pub location_information: Vec<u8>,
    pub velocity_information: Option<Vec<u8>>,
    pub location_time_stamp: Option<TimeStamp>,
}

impl MobileTrpLocationInformation {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 3)?;
        let location_information = decode::decode_octetstring(data, None, None, false)?;
        let velocity_information = if optionals[0] {
            Some(decode::decode_octetstring(data, None, None, false)?)
        } else {
            None
        };
        let location_time_stamp = if optionals[1] {
            Some(TimeStamp::decode(data)?)
        } else {
            None
        };

        // Process the extension container

        if optionals[2] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            location_information,
            velocity_information,
            location_time_stamp,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.velocity_information.is_some());
        optionals.push(self.location_time_stamp.is_some());
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        encode::encode_octetstring(data, None, None, false, &self.location_information, false)?;
        if let Some(x) = &self.velocity_information {
            encode::encode_octetstring(data, None, None, false, &x, false)?;
        }
        if let Some(x) = &self.location_time_stamp {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl PerCodec for MobileTrpLocationInformation {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        MobileTrpLocationInformation::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MobileTrpLocationInformation");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MobileTrpLocationInformation");
            e
        })
    }
}
// MobileIabMtUeId
#[derive(Clone, Debug)]
pub struct MobileIabMtUeId(pub Vec<u8>);

impl MobileIabMtUeId {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(decode::decode_octetstring(data, None, None, false)?))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_octetstring(data, None, None, false, &self.0, false)
    }
}

impl PerCodec for MobileIabMtUeId {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        MobileIabMtUeId::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MobileIabMtUeId");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MobileIabMtUeId");
            e
        })
    }
}
// MusimGapConfig
#[derive(Clone, Debug)]
pub struct MusimGapConfig(pub Vec<u8>);

impl MusimGapConfig {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(decode::decode_octetstring(data, None, None, false)?))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_octetstring(data, None, None, false, &self.0, false)
    }
}

impl PerCodec for MusimGapConfig {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        MusimGapConfig::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MusimGapConfig");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MusimGapConfig");
            e
        })
    }
}
// MobileIabBarred
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum MobileIabBarred {
    Barred,
    NotBarred,
}

impl MobileIabBarred {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(1), true)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(1),
            true,
            *self as i128,
            (*self as u32) >= 2,
        )
    }
}

impl PerCodec for MobileIabBarred {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        MobileIabBarred::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MobileIabBarred");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MobileIabBarred");
            e
        })
    }
}
// MeasBasedOnAggregatedResources
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum MeasBasedOnAggregatedResources {
    True,
}

impl MeasBasedOnAggregatedResources {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(0), true)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(0),
            true,
            *self as i128,
            (*self as u32) >= 1,
        )
    }
}

impl PerCodec for MeasBasedOnAggregatedResources {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        MeasBasedOnAggregatedResources::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MeasBasedOnAggregatedResources");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MeasBasedOnAggregatedResources");
            e
        })
    }
}
// NrA2xServicesAuthorized
#[derive(Clone, Debug)]
pub struct NrA2xServicesAuthorized {
    pub aerial_ue: Option<AerialUe>,
    pub controller_ue: Option<ControllerUe>,
}

impl NrA2xServicesAuthorized {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, false, 3)?;
        let aerial_ue = if optionals[0] {
            Some(AerialUe::decode(data)?)
        } else {
            None
        };
        let controller_ue = if optionals[1] {
            Some(ControllerUe::decode(data)?)
        } else {
            None
        };

        // Process the extension container

        if optionals[2] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            aerial_ue,
            controller_ue,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.aerial_ue.is_some());
        optionals.push(self.controller_ue.is_some());
        optionals.push(false);

        encode::encode_sequence_header(data, false, &optionals, false)?;
        if let Some(x) = &self.aerial_ue {
            x.encode(data)?;
        }
        if let Some(x) = &self.controller_ue {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl PerCodec for NrA2xServicesAuthorized {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        NrA2xServicesAuthorized::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NrA2xServicesAuthorized");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NrA2xServicesAuthorized");
            e
        })
    }
}
// AerialUe
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum AerialUe {
    Authorized,
    NotAuthorized,
}

impl AerialUe {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(1), true)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(1),
            true,
            *self as i128,
            (*self as u32) >= 2,
        )
    }
}

impl PerCodec for AerialUe {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        AerialUe::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("AerialUe");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("AerialUe");
            e
        })
    }
}
// ControllerUe
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum ControllerUe {
    Authorized,
    NotAuthorized,
}

impl ControllerUe {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(1), true)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(1),
            true,
            *self as i128,
            (*self as u32) >= 2,
        )
    }
}

impl PerCodec for ControllerUe {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        ControllerUe::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ControllerUe");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ControllerUe");
            e
        })
    }
}
// N3cIndirectPathAddition
#[derive(Clone, Debug)]
pub struct N3cIndirectPathAddition {
    pub target_relay_ue_id: GnbDuUeF1apId,
}

impl N3cIndirectPathAddition {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let target_relay_ue_id = GnbDuUeF1apId::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self { target_relay_ue_id })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.target_relay_ue_id.encode(data)?;

        Ok(())
    }
}

impl PerCodec for N3cIndirectPathAddition {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        N3cIndirectPathAddition::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("N3cIndirectPathAddition");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("N3cIndirectPathAddition");
            e
        })
    }
}
// NaResourceConfigurationList
#[derive(Clone, Debug)]
pub struct NaResourceConfigurationList(pub NonEmpty<NaResourceConfigurationItem>);

impl NaResourceConfigurationList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(5120), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(NaResourceConfigurationItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(5120), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for NaResourceConfigurationList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        NaResourceConfigurationList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NaResourceConfigurationList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NaResourceConfigurationList");
            e
        })
    }
}
// NaResourceConfigurationItem
#[derive(Clone, Debug)]
pub struct NaResourceConfigurationItem {
    pub na_downlink: Option<NaDownlink>,
    pub na_uplink: Option<NaUplink>,
    pub na_flexible: Option<NaFlexible>,
}

impl NaResourceConfigurationItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, false, 4)?;
        let na_downlink = if optionals[0] {
            Some(NaDownlink::decode(data)?)
        } else {
            None
        };
        let na_uplink = if optionals[1] {
            Some(NaUplink::decode(data)?)
        } else {
            None
        };
        let na_flexible = if optionals[2] {
            Some(NaFlexible::decode(data)?)
        } else {
            None
        };

        // Process the extension container

        if optionals[3] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            na_downlink,
            na_uplink,
            na_flexible,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.na_downlink.is_some());
        optionals.push(self.na_uplink.is_some());
        optionals.push(self.na_flexible.is_some());
        optionals.push(false);

        encode::encode_sequence_header(data, false, &optionals, false)?;
        if let Some(x) = &self.na_downlink {
            x.encode(data)?;
        }
        if let Some(x) = &self.na_uplink {
            x.encode(data)?;
        }
        if let Some(x) = &self.na_flexible {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl PerCodec for NaResourceConfigurationItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        NaResourceConfigurationItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NaResourceConfigurationItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NaResourceConfigurationItem");
            e
        })
    }
}
// NaDownlink
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum NaDownlink {
    True,
    False,
}

impl NaDownlink {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(1), true)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(1),
            true,
            *self as i128,
            (*self as u32) >= 2,
        )
    }
}

impl PerCodec for NaDownlink {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        NaDownlink::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NaDownlink");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NaDownlink");
            e
        })
    }
}
// NaFlexible
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum NaFlexible {
    True,
    False,
}

impl NaFlexible {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(1), true)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(1),
            true,
            *self as i128,
            (*self as u32) >= 2,
        )
    }
}

impl PerCodec for NaFlexible {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        NaFlexible::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NaFlexible");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NaFlexible");
            e
        })
    }
}
// NaUplink
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum NaUplink {
    True,
    False,
}

impl NaUplink {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(1), true)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(1),
            true,
            *self as i128,
            (*self as u32) >= 2,
        )
    }
}

impl PerCodec for NaUplink {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        NaUplink::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NaUplink");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NaUplink");
            e
        })
    }
}
// NcdSsbRedCapInitialBwpSdt
#[derive(Clone, Debug)]
pub struct NcdSsbRedCapInitialBwpSdt(pub Vec<u8>);

impl NcdSsbRedCapInitialBwpSdt {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(decode::decode_octetstring(data, None, None, false)?))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_octetstring(data, None, None, false, &self.0, false)
    }
}

impl PerCodec for NcdSsbRedCapInitialBwpSdt {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        NcdSsbRedCapInitialBwpSdt::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NcdSsbRedCapInitialBwpSdt");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NcdSsbRedCapInitialBwpSdt");
            e
        })
    }
}
// NetworkControlledRepeaterAuthorized
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum NetworkControlledRepeaterAuthorized {
    Authorized,
    NotAuthorized,
}

impl NetworkControlledRepeaterAuthorized {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(1), true)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(1),
            true,
            *self as i128,
            (*self as u32) >= 2,
        )
    }
}

impl PerCodec for NetworkControlledRepeaterAuthorized {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        NetworkControlledRepeaterAuthorized::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NetworkControlledRepeaterAuthorized");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NetworkControlledRepeaterAuthorized");
            e
        })
    }
}
// NcgiToBeUpdatedListItem
#[derive(Clone, Debug)]
pub struct NcgiToBeUpdatedListItem {
    pub oldncgi: NrCgi,
    pub newncgi: NrCgi,
}

impl NcgiToBeUpdatedListItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let oldncgi = NrCgi::decode(data)?;
        let newncgi = NrCgi::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self { oldncgi, newncgi })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.oldncgi.encode(data)?;
        self.newncgi.encode(data)?;

        Ok(())
    }
}

impl PerCodec for NcgiToBeUpdatedListItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        NcgiToBeUpdatedListItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NcgiToBeUpdatedListItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NcgiToBeUpdatedListItem");
            e
        })
    }
}
// NeighbourNodeCellsList
#[derive(Clone, Debug)]
pub struct NeighbourNodeCellsList(pub NonEmpty<NeighbourNodeCellsListItem>);

impl NeighbourNodeCellsList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(1024), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(NeighbourNodeCellsListItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(1024), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for NeighbourNodeCellsList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        NeighbourNodeCellsList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NeighbourNodeCellsList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NeighbourNodeCellsList");
            e
        })
    }
}
// NeighbourNodeCellsListItem
#[derive(Clone, Debug)]
pub struct NeighbourNodeCellsListItem {
    pub nr_cgi: NrCgi,
    pub gnb_cu_ue_f1ap_id: Option<GnbCuUeF1apId>,
    pub gnb_du_ue_f1ap_id: Option<GnbDuUeF1apId>,
    pub peer_parent_node_indicator: Option<PeerParentNodeIndicator>,
    pub iab_du_cell_resource_configuration_mode_info:
        Option<IabDuCellResourceConfigurationModeInfo>,
    pub iab_stc_info: Option<IabStcInfo>,
    pub rach_config_common: Option<RachConfigCommon>,
    pub rach_config_common_iab: Option<RachConfigCommonIab>,
    pub csi_rs_configuration: Option<Vec<u8>>,
    pub sr_configuration: Option<Vec<u8>>,
    pub pdcch_config_sib_1: Option<Vec<u8>>,
    pub scs_common: Option<Vec<u8>>,
}

impl NeighbourNodeCellsListItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, false, 12)?;
        let nr_cgi = NrCgi::decode(data)?;
        let gnb_cu_ue_f1ap_id = if optionals[0] {
            Some(GnbCuUeF1apId::decode(data)?)
        } else {
            None
        };
        let gnb_du_ue_f1ap_id = if optionals[1] {
            Some(GnbDuUeF1apId::decode(data)?)
        } else {
            None
        };
        let peer_parent_node_indicator = if optionals[2] {
            Some(PeerParentNodeIndicator::decode(data)?)
        } else {
            None
        };
        let iab_du_cell_resource_configuration_mode_info = if optionals[3] {
            Some(IabDuCellResourceConfigurationModeInfo::decode(data)?)
        } else {
            None
        };
        let iab_stc_info = if optionals[4] {
            Some(IabStcInfo::decode(data)?)
        } else {
            None
        };
        let rach_config_common = if optionals[5] {
            Some(RachConfigCommon::decode(data)?)
        } else {
            None
        };
        let rach_config_common_iab = if optionals[6] {
            Some(RachConfigCommonIab::decode(data)?)
        } else {
            None
        };
        let csi_rs_configuration = if optionals[7] {
            Some(decode::decode_octetstring(data, None, None, false)?)
        } else {
            None
        };
        let sr_configuration = if optionals[8] {
            Some(decode::decode_octetstring(data, None, None, false)?)
        } else {
            None
        };
        let pdcch_config_sib_1 = if optionals[9] {
            Some(decode::decode_octetstring(data, None, None, false)?)
        } else {
            None
        };
        let scs_common = if optionals[10] {
            Some(decode::decode_octetstring(data, None, None, false)?)
        } else {
            None
        };

        // Process the extension container

        if optionals[11] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            nr_cgi,
            gnb_cu_ue_f1ap_id,
            gnb_du_ue_f1ap_id,
            peer_parent_node_indicator,
            iab_du_cell_resource_configuration_mode_info,
            iab_stc_info,
            rach_config_common,
            rach_config_common_iab,
            csi_rs_configuration,
            sr_configuration,
            pdcch_config_sib_1,
            scs_common,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.gnb_cu_ue_f1ap_id.is_some());
        optionals.push(self.gnb_du_ue_f1ap_id.is_some());
        optionals.push(self.peer_parent_node_indicator.is_some());
        optionals.push(self.iab_du_cell_resource_configuration_mode_info.is_some());
        optionals.push(self.iab_stc_info.is_some());
        optionals.push(self.rach_config_common.is_some());
        optionals.push(self.rach_config_common_iab.is_some());
        optionals.push(self.csi_rs_configuration.is_some());
        optionals.push(self.sr_configuration.is_some());
        optionals.push(self.pdcch_config_sib_1.is_some());
        optionals.push(self.scs_common.is_some());
        optionals.push(false);

        encode::encode_sequence_header(data, false, &optionals, false)?;
        self.nr_cgi.encode(data)?;
        if let Some(x) = &self.gnb_cu_ue_f1ap_id {
            x.encode(data)?;
        }
        if let Some(x) = &self.gnb_du_ue_f1ap_id {
            x.encode(data)?;
        }
        if let Some(x) = &self.peer_parent_node_indicator {
            x.encode(data)?;
        }
        if let Some(x) = &self.iab_du_cell_resource_configuration_mode_info {
            x.encode(data)?;
        }
        if let Some(x) = &self.iab_stc_info {
            x.encode(data)?;
        }
        if let Some(x) = &self.rach_config_common {
            x.encode(data)?;
        }
        if let Some(x) = &self.rach_config_common_iab {
            x.encode(data)?;
        }
        if let Some(x) = &self.csi_rs_configuration {
            encode::encode_octetstring(data, None, None, false, &x, false)?;
        }
        if let Some(x) = &self.sr_configuration {
            encode::encode_octetstring(data, None, None, false, &x, false)?;
        }
        if let Some(x) = &self.pdcch_config_sib_1 {
            encode::encode_octetstring(data, None, None, false, &x, false)?;
        }
        if let Some(x) = &self.scs_common {
            encode::encode_octetstring(data, None, None, false, &x, false)?;
        }

        Ok(())
    }
}

impl PerCodec for NeighbourNodeCellsListItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        NeighbourNodeCellsListItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NeighbourNodeCellsListItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NeighbourNodeCellsListItem");
            e
        })
    }
}
// NeedforGap
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum NeedforGap {
    True,
}

impl NeedforGap {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(0), true)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(0),
            true,
            *self as i128,
            (*self as u32) >= 1,
        )
    }
}

impl PerCodec for NeedforGap {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        NeedforGap::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NeedforGap");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NeedforGap");
            e
        })
    }
}
// NeedForGapsInfoNr
#[derive(Clone, Debug)]
pub struct NeedForGapsInfoNr(pub Vec<u8>);

impl NeedForGapsInfoNr {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(decode::decode_octetstring(data, None, None, false)?))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_octetstring(data, None, None, false, &self.0, false)
    }
}

impl PerCodec for NeedForGapsInfoNr {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        NeedForGapsInfoNr::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NeedForGapsInfoNr");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NeedForGapsInfoNr");
            e
        })
    }
}
// NeedForGapNcsgInfoNr
#[derive(Clone, Debug)]
pub struct NeedForGapNcsgInfoNr(pub Vec<u8>);

impl NeedForGapNcsgInfoNr {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(decode::decode_octetstring(data, None, None, false)?))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_octetstring(data, None, None, false, &self.0, false)
    }
}

impl PerCodec for NeedForGapNcsgInfoNr {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        NeedForGapNcsgInfoNr::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NeedForGapNcsgInfoNr");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NeedForGapNcsgInfoNr");
            e
        })
    }
}
// NeedForGapNcsgInfoEutra
#[derive(Clone, Debug)]
pub struct NeedForGapNcsgInfoEutra(pub Vec<u8>);

impl NeedForGapNcsgInfoEutra {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(decode::decode_octetstring(data, None, None, false)?))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_octetstring(data, None, None, false, &self.0, false)
    }
}

impl PerCodec for NeedForGapNcsgInfoEutra {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        NeedForGapNcsgInfoEutra::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NeedForGapNcsgInfoEutra");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NeedForGapNcsgInfoEutra");
            e
        })
    }
}
// NeedForInterruptionInfoNr
#[derive(Clone, Debug)]
pub struct NeedForInterruptionInfoNr(pub Vec<u8>);

impl NeedForInterruptionInfoNr {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(decode::decode_octetstring(data, None, None, false)?))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_octetstring(data, None, None, false, &self.0, false)
    }
}

impl PerCodec for NeedForInterruptionInfoNr {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        NeedForInterruptionInfoNr::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NeedForInterruptionInfoNr");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NeedForInterruptionInfoNr");
            e
        })
    }
}
// NeighbourCellInformationItem
#[derive(Clone, Debug)]
pub struct NeighbourCellInformationItem {
    pub nr_cgi: NrCgi,
    pub intended_tdd_dl_ul_config: Option<IntendedTddDlUlConfig>,
}

impl NeighbourCellInformationItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, false, 2)?;
        let nr_cgi = NrCgi::decode(data)?;
        let intended_tdd_dl_ul_config = if optionals[0] {
            Some(IntendedTddDlUlConfig::decode(data)?)
        } else {
            None
        };

        // Process the extension container

        if optionals[1] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            nr_cgi,
            intended_tdd_dl_ul_config,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.intended_tdd_dl_ul_config.is_some());
        optionals.push(false);

        encode::encode_sequence_header(data, false, &optionals, false)?;
        self.nr_cgi.encode(data)?;
        if let Some(x) = &self.intended_tdd_dl_ul_config {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl PerCodec for NeighbourCellInformationItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        NeighbourCellInformationItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NeighbourCellInformationItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NeighbourCellInformationItem");
            e
        })
    }
}
// NeighbourNrCellsForSonList
#[derive(Clone, Debug)]
pub struct NeighbourNrCellsForSonList(pub NonEmpty<NeighbourNrCellsForSonItem>);

impl NeighbourNrCellsForSonList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(32), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(NeighbourNrCellsForSonItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(32), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for NeighbourNrCellsForSonList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        NeighbourNrCellsForSonList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NeighbourNrCellsForSonList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NeighbourNrCellsForSonList");
            e
        })
    }
}
// NeighbourNrCellsForSonItem
#[derive(Clone, Debug)]
pub struct NeighbourNrCellsForSonItem {
    pub nr_cgi: NrCgi,
    pub nr_mode_info_rel_16: Option<NrModeInfoRel16>,
    pub ssb_positions_in_burst: Option<SsbPositionsInBurst>,
    pub nr_prach_config: Option<NrPrachConfig>,
}

impl NeighbourNrCellsForSonItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 4)?;
        let nr_cgi = NrCgi::decode(data)?;
        let nr_mode_info_rel_16 = if optionals[0] {
            Some(NrModeInfoRel16::decode(data)?)
        } else {
            None
        };
        let ssb_positions_in_burst = if optionals[1] {
            Some(SsbPositionsInBurst::decode(data)?)
        } else {
            None
        };
        let nr_prach_config = if optionals[2] {
            Some(NrPrachConfig::decode(data)?)
        } else {
            None
        };

        // Process the extension container

        if optionals[3] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            nr_cgi,
            nr_mode_info_rel_16,
            ssb_positions_in_burst,
            nr_prach_config,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.nr_mode_info_rel_16.is_some());
        optionals.push(self.ssb_positions_in_burst.is_some());
        optionals.push(self.nr_prach_config.is_some());
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.nr_cgi.encode(data)?;
        if let Some(x) = &self.nr_mode_info_rel_16 {
            x.encode(data)?;
        }
        if let Some(x) = &self.ssb_positions_in_burst {
            x.encode(data)?;
        }
        if let Some(x) = &self.nr_prach_config {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl PerCodec for NeighbourNrCellsForSonItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        NeighbourNrCellsForSonItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NeighbourNrCellsForSonItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NeighbourNrCellsForSonItem");
            e
        })
    }
}
// NgranAllocationAndRetentionPriority
#[derive(Clone, Debug)]
pub struct NgranAllocationAndRetentionPriority {
    pub priority_level: PriorityLevel,
    pub pre_emption_capability: PreEmptionCapability,
    pub pre_emption_vulnerability: PreEmptionVulnerability,
}

impl NgranAllocationAndRetentionPriority {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, false, 1)?;
        let priority_level = PriorityLevel::decode(data)?;
        let pre_emption_capability = PreEmptionCapability::decode(data)?;
        let pre_emption_vulnerability = PreEmptionVulnerability::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            priority_level,
            pre_emption_capability,
            pre_emption_vulnerability,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, false, &optionals, false)?;
        self.priority_level.encode(data)?;
        self.pre_emption_capability.encode(data)?;
        self.pre_emption_vulnerability.encode(data)?;

        Ok(())
    }
}

impl PerCodec for NgranAllocationAndRetentionPriority {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        NgranAllocationAndRetentionPriority::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NgranAllocationAndRetentionPriority");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NgranAllocationAndRetentionPriority");
            e
        })
    }
}
// NgranHighAccuracyAccessPointPosition
#[derive(Clone, Debug)]
pub struct NgranHighAccuracyAccessPointPosition {
    pub latitude: i32,
    pub longitude: i32,
    pub altitude: i32,
    pub uncertainty_semi_major: u8,
    pub uncertainty_semi_minor: u8,
    pub orientation_of_major_axis: u8,
    pub horizontal_confidence: u8,
    pub uncertainty_altitude: u8,
    pub vertical_confidence: u8,
}

impl NgranHighAccuracyAccessPointPosition {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, false, 1)?;
        let latitude =
            decode::decode_integer(data, Some(-2147483648), Some(2147483647), false)?.0 as i32;
        let longitude =
            decode::decode_integer(data, Some(-2147483648), Some(2147483647), false)?.0 as i32;
        let altitude = decode::decode_integer(data, Some(-64000), Some(1280000), false)?.0 as i32;
        let uncertainty_semi_major =
            decode::decode_integer(data, Some(0), Some(255), false)?.0 as u8;
        let uncertainty_semi_minor =
            decode::decode_integer(data, Some(0), Some(255), false)?.0 as u8;
        let orientation_of_major_axis =
            decode::decode_integer(data, Some(0), Some(179), false)?.0 as u8;
        let horizontal_confidence =
            decode::decode_integer(data, Some(0), Some(100), false)?.0 as u8;
        let uncertainty_altitude = decode::decode_integer(data, Some(0), Some(255), false)?.0 as u8;
        let vertical_confidence = decode::decode_integer(data, Some(0), Some(100), false)?.0 as u8;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            latitude,
            longitude,
            altitude,
            uncertainty_semi_major,
            uncertainty_semi_minor,
            orientation_of_major_axis,
            horizontal_confidence,
            uncertainty_altitude,
            vertical_confidence,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, false, &optionals, false)?;
        encode::encode_integer(
            data,
            Some(-2147483648),
            Some(2147483647),
            false,
            self.latitude as i128,
            false,
        )?;
        encode::encode_integer(
            data,
            Some(-2147483648),
            Some(2147483647),
            false,
            self.longitude as i128,
            false,
        )?;
        encode::encode_integer(
            data,
            Some(-64000),
            Some(1280000),
            false,
            self.altitude as i128,
            false,
        )?;
        encode::encode_integer(
            data,
            Some(0),
            Some(255),
            false,
            self.uncertainty_semi_major as i128,
            false,
        )?;
        encode::encode_integer(
            data,
            Some(0),
            Some(255),
            false,
            self.uncertainty_semi_minor as i128,
            false,
        )?;
        encode::encode_integer(
            data,
            Some(0),
            Some(179),
            false,
            self.orientation_of_major_axis as i128,
            false,
        )?;
        encode::encode_integer(
            data,
            Some(0),
            Some(100),
            false,
            self.horizontal_confidence as i128,
            false,
        )?;
        encode::encode_integer(
            data,
            Some(0),
            Some(255),
            false,
            self.uncertainty_altitude as i128,
            false,
        )?;
        encode::encode_integer(
            data,
            Some(0),
            Some(100),
            false,
            self.vertical_confidence as i128,
            false,
        )?;

        Ok(())
    }
}

impl PerCodec for NgranHighAccuracyAccessPointPosition {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        NgranHighAccuracyAccessPointPosition::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NgranHighAccuracyAccessPointPosition");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NgranHighAccuracyAccessPointPosition");
            e
        })
    }
}
// Nid
#[derive(Clone, Debug)]
pub struct Nid(pub BitString);

impl Nid {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(decode::decode_bitstring(
            data,
            Some(44),
            Some(44),
            false,
        )?))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_bitstring(data, Some(44), Some(44), false, &self.0, false)
    }
}

impl PerCodec for Nid {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Nid::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("Nid");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("Nid");
            e
        })
    }
}
// NonF1terminatingTopologyIndicator
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum NonF1terminatingTopologyIndicator {
    True,
}

impl NonF1terminatingTopologyIndicator {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(0), true)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(0),
            true,
            *self as i128,
            (*self as u32) >= 1,
        )
    }
}

impl PerCodec for NonF1terminatingTopologyIndicator {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        NonF1terminatingTopologyIndicator::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NonF1terminatingTopologyIndicator");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NonF1terminatingTopologyIndicator");
            e
        })
    }
}
// NrCgiListForRestartItem
#[derive(Clone, Debug)]
pub struct NrCgiListForRestartItem {
    pub nr_cgi: NrCgi,
}

impl NrCgiListForRestartItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let nr_cgi = NrCgi::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self { nr_cgi })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.nr_cgi.encode(data)?;

        Ok(())
    }
}

impl PerCodec for NrCgiListForRestartItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        NrCgiListForRestartItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NrCgiListForRestartItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NrCgiListForRestartItem");
            e
        })
    }
}
// NrofSymbolsExtended
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum NrofSymbolsExtended {
    N8,
    N10,
    N12,
    N14,
}

impl NrofSymbolsExtended {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(3), true)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(3),
            true,
            *self as i128,
            (*self as u32) >= 4,
        )
    }
}

impl PerCodec for NrofSymbolsExtended {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        NrofSymbolsExtended::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NrofSymbolsExtended");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NrofSymbolsExtended");
            e
        })
    }
}
// NrPrsBeamInformation
#[derive(Clone, Debug)]
pub struct NrPrsBeamInformation {
    pub nr_prs_beam_information_list: NrPrsBeamInformationList,
    pub lc_sto_gcs_translation_list: Option<LcStoGcsTranslationList>,
}

impl NrPrsBeamInformation {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, false, 2)?;
        let nr_prs_beam_information_list = NrPrsBeamInformationList::decode(data)?;
        let lc_sto_gcs_translation_list = if optionals[0] {
            Some(LcStoGcsTranslationList::decode(data)?)
        } else {
            None
        };

        // Process the extension container

        if optionals[1] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            nr_prs_beam_information_list,
            lc_sto_gcs_translation_list,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.lc_sto_gcs_translation_list.is_some());
        optionals.push(false);

        encode::encode_sequence_header(data, false, &optionals, false)?;
        self.nr_prs_beam_information_list.encode(data)?;
        if let Some(x) = &self.lc_sto_gcs_translation_list {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl PerCodec for NrPrsBeamInformation {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        NrPrsBeamInformation::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NrPrsBeamInformation");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NrPrsBeamInformation");
            e
        })
    }
}
// NrPrsBeamInformationList
#[derive(Clone, Debug)]
pub struct NrPrsBeamInformationList(pub NonEmpty<NrPrsBeamInformationItem>);

impl NrPrsBeamInformationList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(2), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(NrPrsBeamInformationItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(2), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for NrPrsBeamInformationList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        NrPrsBeamInformationList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NrPrsBeamInformationList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NrPrsBeamInformationList");
            e
        })
    }
}
// NrPrsBeamInformationItem
#[derive(Clone, Debug)]
pub struct NrPrsBeamInformationItem {
    pub prs_resource_set_id: PrsResourceSetId,
    pub prs_angle_list: PrsAngleList,
}

impl NrPrsBeamInformationItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, false, 1)?;
        let prs_resource_set_id = PrsResourceSetId::decode(data)?;
        let prs_angle_list = PrsAngleList::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            prs_resource_set_id,
            prs_angle_list,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, false, &optionals, false)?;
        self.prs_resource_set_id.encode(data)?;
        self.prs_angle_list.encode(data)?;

        Ok(())
    }
}

impl PerCodec for NrPrsBeamInformationItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        NrPrsBeamInformationItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NrPrsBeamInformationItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NrPrsBeamInformationItem");
            e
        })
    }
}
// NrTadv
#[derive(Clone, Copy, Debug)]
pub struct NrTadv(pub u16);

impl NrTadv {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(
            decode::decode_integer(data, Some(0), Some(7690), false)?.0 as u16,
        ))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_integer(data, Some(0), Some(7690), false, self.0 as i128, false)
    }
}

impl PerCodec for NrTadv {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        NrTadv::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NrTadv");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NrTadv");
            e
        })
    }
}
// NrERedCapUeIndication
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum NrERedCapUeIndication {
    True,
}

impl NrERedCapUeIndication {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(0), true)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(0),
            true,
            *self as i128,
            (*self as u32) >= 1,
        )
    }
}

impl PerCodec for NrERedCapUeIndication {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        NrERedCapUeIndication::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NrERedCapUeIndication");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NrERedCapUeIndication");
            e
        })
    }
}
// ERedcapBcastInformation
#[derive(Clone, Debug)]
pub struct ERedcapBcastInformation(pub BitString);

impl ERedcapBcastInformation {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(decode::decode_bitstring(
            data,
            Some(8),
            Some(8),
            false,
        )?))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_bitstring(data, Some(8), Some(8), false, &self.0, false)
    }
}

impl PerCodec for ERedcapBcastInformation {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        ERedcapBcastInformation::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ERedcapBcastInformation");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ERedcapBcastInformation");
            e
        })
    }
}
// NrRedCapUeIndication
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum NrRedCapUeIndication {
    True,
}

impl NrRedCapUeIndication {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(0), true)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(0),
            true,
            *self as i128,
            (*self as u32) >= 1,
        )
    }
}

impl PerCodec for NrRedCapUeIndication {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        NrRedCapUeIndication::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NrRedCapUeIndication");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NrRedCapUeIndication");
            e
        })
    }
}
// NrPagingeDrxInformation
#[derive(Clone, Debug)]
pub struct NrPagingeDrxInformation {
    pub nrpaging_e_drx_cycle_idle: NrPagingEDrxCycleIdle,
    pub nrpaging_time_window: Option<NrPagingTimeWindow>,
}

impl NrPagingeDrxInformation {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 2)?;
        let nrpaging_e_drx_cycle_idle = NrPagingEDrxCycleIdle::decode(data)?;
        let nrpaging_time_window = if optionals[0] {
            Some(NrPagingTimeWindow::decode(data)?)
        } else {
            None
        };

        // Process the extension container

        if optionals[1] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            nrpaging_e_drx_cycle_idle,
            nrpaging_time_window,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.nrpaging_time_window.is_some());
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.nrpaging_e_drx_cycle_idle.encode(data)?;
        if let Some(x) = &self.nrpaging_time_window {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl PerCodec for NrPagingeDrxInformation {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        NrPagingeDrxInformation::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NrPagingeDrxInformation");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NrPagingeDrxInformation");
            e
        })
    }
}
// NrPagingEDrxCycleIdle
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum NrPagingEDrxCycleIdle {
    Hfquarter,
    Hfhalf,
    Hf1,
    Hf2,
    Hf4,
    Hf8,
    Hf16,
    Hf32,
    Hf64,
    Hf128,
    Hf256,
    Hf512,
    Hf1024,
}

impl NrPagingEDrxCycleIdle {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(12), true)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(12),
            true,
            *self as i128,
            (*self as u32) >= 13,
        )
    }
}

impl PerCodec for NrPagingEDrxCycleIdle {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        NrPagingEDrxCycleIdle::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NrPagingEDrxCycleIdle");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NrPagingEDrxCycleIdle");
            e
        })
    }
}
// NrPagingTimeWindow
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum NrPagingTimeWindow {
    S1,
    S2,
    S3,
    S4,
    S5,
    S6,
    S7,
    S8,
    S9,
    S10,
    S11,
    S12,
    S13,
    S14,
    S15,
    S16,
    S17,
    S18,
    S19,
    S20,
    S21,
    S22,
    S23,
    S24,
    S25,
    S26,
    S27,
    S28,
    S29,
    S30,
    S31,
    S32,
}

impl NrPagingTimeWindow {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(15), true)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(15),
            true,
            *self as i128,
            (*self as u32) >= 16,
        )
    }
}

impl PerCodec for NrPagingTimeWindow {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        NrPagingTimeWindow::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NrPagingTimeWindow");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NrPagingTimeWindow");
            e
        })
    }
}
// NrPagingeDrxInformationforRrcInactive
#[derive(Clone, Debug)]
pub struct NrPagingeDrxInformationforRrcInactive {
    pub nrpaging_e_drx_cycle_inactive: NrPagingEDrxCycleInactive,
}

impl NrPagingeDrxInformationforRrcInactive {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let nrpaging_e_drx_cycle_inactive = NrPagingEDrxCycleInactive::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            nrpaging_e_drx_cycle_inactive,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.nrpaging_e_drx_cycle_inactive.encode(data)?;

        Ok(())
    }
}

impl PerCodec for NrPagingeDrxInformationforRrcInactive {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        NrPagingeDrxInformationforRrcInactive::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NrPagingeDrxInformationforRrcInactive");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NrPagingeDrxInformationforRrcInactive");
            e
        })
    }
}
// NrPagingEDrxCycleInactive
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum NrPagingEDrxCycleInactive {
    Hfquarter,
    Hfhalf,
    Hf1,
}

impl NrPagingEDrxCycleInactive {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(2), true)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(2),
            true,
            *self as i128,
            (*self as u32) >= 3,
        )
    }
}

impl PerCodec for NrPagingEDrxCycleInactive {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        NrPagingEDrxCycleInactive::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NrPagingEDrxCycleInactive");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NrPagingEDrxCycleInactive");
            e
        })
    }
}
// NrPaginglongeDrxInformationforRrcInactive
#[derive(Clone, Debug)]
pub struct NrPaginglongeDrxInformationforRrcInactive {
    pub nr_paging_long_e_drx_cycle_inactive: NrPagingLongEDrxCycleInactive,
    pub nr_paging_time_window_inactive: NrPagingTimeWindowInactive,
}

impl NrPaginglongeDrxInformationforRrcInactive {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let nr_paging_long_e_drx_cycle_inactive = NrPagingLongEDrxCycleInactive::decode(data)?;
        let nr_paging_time_window_inactive = NrPagingTimeWindowInactive::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            nr_paging_long_e_drx_cycle_inactive,
            nr_paging_time_window_inactive,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.nr_paging_long_e_drx_cycle_inactive.encode(data)?;
        self.nr_paging_time_window_inactive.encode(data)?;

        Ok(())
    }
}

impl PerCodec for NrPaginglongeDrxInformationforRrcInactive {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        NrPaginglongeDrxInformationforRrcInactive::decode_inner(data).map_err(
            |mut e: PerCodecError| {
                e.push_context("NrPaginglongeDrxInformationforRrcInactive");
                e
            },
        )
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NrPaginglongeDrxInformationforRrcInactive");
            e
        })
    }
}
// NrPagingLongEDrxCycleInactive
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum NrPagingLongEDrxCycleInactive {
    Hf2,
    Hf4,
    Hf8,
    Hf16,
    Hf32,
    Hf64,
    Hf128,
    Hf256,
    Hf512,
    Hf1024,
}

impl NrPagingLongEDrxCycleInactive {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(9), true)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(9),
            true,
            *self as i128,
            (*self as u32) >= 10,
        )
    }
}

impl PerCodec for NrPagingLongEDrxCycleInactive {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        NrPagingLongEDrxCycleInactive::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NrPagingLongEDrxCycleInactive");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NrPagingLongEDrxCycleInactive");
            e
        })
    }
}
// NrPagingTimeWindowInactive
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum NrPagingTimeWindowInactive {
    S1,
    S2,
    S3,
    S4,
    S5,
    S6,
    S7,
    S8,
    S9,
    S10,
    S11,
    S12,
    S13,
    S14,
    S15,
    S16,
    S17,
    S18,
    S19,
    S20,
    S21,
    S22,
    S23,
    S24,
    S25,
    S26,
    S27,
    S28,
    S29,
    S30,
    S31,
    S32,
}

impl NrPagingTimeWindowInactive {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(31), true)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(31),
            true,
            *self as i128,
            (*self as u32) >= 32,
        )
    }
}

impl PerCodec for NrPagingTimeWindowInactive {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        NrPagingTimeWindowInactive::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NrPagingTimeWindowInactive");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NrPagingTimeWindowInactive");
            e
        })
    }
}
// NonDynamic5qiDescriptor
#[derive(Clone, Debug)]
pub struct NonDynamic5qiDescriptor {
    pub five_qi: u8,
    pub qos_priority_level: Option<u8>,
    pub averaging_window: Option<AveragingWindow>,
    pub max_data_burst_volume: Option<MaxDataBurstVolume>,
    pub cn_packet_delay_budget_downlink: Option<ExtendedPacketDelayBudget>,
    pub cn_packet_delay_budget_uplink: Option<ExtendedPacketDelayBudget>,
}

impl NonDynamic5qiDescriptor {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, false, 4)?;
        let five_qi = decode::decode_integer(data, Some(0), Some(255), true)?.0 as u8;
        let qos_priority_level = if optionals[0] {
            Some(decode::decode_integer(data, Some(1), Some(127), false)?.0 as u8)
        } else {
            None
        };
        let averaging_window = if optionals[1] {
            Some(AveragingWindow::decode(data)?)
        } else {
            None
        };
        let max_data_burst_volume = if optionals[2] {
            Some(MaxDataBurstVolume::decode(data)?)
        } else {
            None
        };

        // Process the extension container
        let mut cn_packet_delay_budget_downlink: Option<ExtendedPacketDelayBudget> = None;
        let mut cn_packet_delay_budget_uplink: Option<ExtendedPacketDelayBudget> = None;

        if optionals[3] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    362 => {
                        cn_packet_delay_budget_downlink =
                            Some(ExtendedPacketDelayBudget::decode(data)?)
                    }
                    369 => {
                        cn_packet_delay_budget_uplink =
                            Some(ExtendedPacketDelayBudget::decode(data)?)
                    }
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            five_qi,
            qos_priority_level,
            averaging_window,
            max_data_burst_volume,
            cn_packet_delay_budget_downlink,
            cn_packet_delay_budget_uplink,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();
        if let Some(x) = &self.cn_packet_delay_budget_downlink {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 362, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.cn_packet_delay_budget_uplink {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 369, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        let mut optionals = BitString::new();
        optionals.push(self.qos_priority_level.is_some());
        optionals.push(self.averaging_window.is_some());
        optionals.push(self.max_data_burst_volume.is_some());
        optionals.push(num_ies != 0);

        encode::encode_sequence_header(data, false, &optionals, false)?;
        encode::encode_integer(data, Some(0), Some(255), true, self.five_qi as i128, false)?;
        if let Some(x) = &self.qos_priority_level {
            encode::encode_integer(data, Some(1), Some(127), false, *x as i128, false)?;
        }
        if let Some(x) = &self.averaging_window {
            x.encode(data)?;
        }
        if let Some(x) = &self.max_data_burst_volume {
            x.encode(data)?;
        }
        if num_ies != 0 {
            encode::encode_length_determinent(data, Some(1), Some(65535), false, num_ies)?;
            data.append_aligned(ies);
        }
        Ok(())
    }
}

impl PerCodec for NonDynamic5qiDescriptor {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        NonDynamic5qiDescriptor::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NonDynamic5qiDescriptor");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NonDynamic5qiDescriptor");
            e
        })
    }
}
// NonDynamicPqiDescriptor
#[derive(Clone, Debug)]
pub struct NonDynamicPqiDescriptor {
    pub five_qi: u8,
    pub qos_priority_level: Option<u8>,
    pub averaging_window: Option<AveragingWindow>,
    pub max_data_burst_volume: Option<MaxDataBurstVolume>,
}

impl NonDynamicPqiDescriptor {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, false, 4)?;
        let five_qi = decode::decode_integer(data, Some(0), Some(255), true)?.0 as u8;
        let qos_priority_level = if optionals[0] {
            Some(decode::decode_integer(data, Some(1), Some(8), true)?.0 as u8)
        } else {
            None
        };
        let averaging_window = if optionals[1] {
            Some(AveragingWindow::decode(data)?)
        } else {
            None
        };
        let max_data_burst_volume = if optionals[2] {
            Some(MaxDataBurstVolume::decode(data)?)
        } else {
            None
        };

        // Process the extension container

        if optionals[3] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            five_qi,
            qos_priority_level,
            averaging_window,
            max_data_burst_volume,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.qos_priority_level.is_some());
        optionals.push(self.averaging_window.is_some());
        optionals.push(self.max_data_burst_volume.is_some());
        optionals.push(false);

        encode::encode_sequence_header(data, false, &optionals, false)?;
        encode::encode_integer(data, Some(0), Some(255), true, self.five_qi as i128, false)?;
        if let Some(x) = &self.qos_priority_level {
            encode::encode_integer(data, Some(1), Some(8), true, *x as i128, false)?;
        }
        if let Some(x) = &self.averaging_window {
            x.encode(data)?;
        }
        if let Some(x) = &self.max_data_burst_volume {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl PerCodec for NonDynamicPqiDescriptor {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        NonDynamicPqiDescriptor::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NonDynamicPqiDescriptor");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NonDynamicPqiDescriptor");
            e
        })
    }
}
// NonUpTrafficType
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum NonUpTrafficType {
    UeAssociated,
    NonUeAssociated,
    NonF1,
    BapControlPdu,
}

impl NonUpTrafficType {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(3), true)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(3),
            true,
            *self as i128,
            (*self as u32) >= 4,
        )
    }
}

impl PerCodec for NonUpTrafficType {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        NonUpTrafficType::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NonUpTrafficType");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NonUpTrafficType");
            e
        })
    }
}
// NoofDownlinkSymbols
#[derive(Clone, Copy, Debug)]
pub struct NoofDownlinkSymbols(pub u8);

impl NoofDownlinkSymbols {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(
            decode::decode_integer(data, Some(0), Some(14), false)?.0 as u8,
        ))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_integer(data, Some(0), Some(14), false, self.0 as i128, false)
    }
}

impl PerCodec for NoofDownlinkSymbols {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        NoofDownlinkSymbols::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NoofDownlinkSymbols");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NoofDownlinkSymbols");
            e
        })
    }
}
// NoofUplinkSymbols
#[derive(Clone, Copy, Debug)]
pub struct NoofUplinkSymbols(pub u8);

impl NoofUplinkSymbols {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(
            decode::decode_integer(data, Some(0), Some(14), false)?.0 as u8,
        ))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_integer(data, Some(0), Some(14), false, self.0 as i128, false)
    }
}

impl PerCodec for NoofUplinkSymbols {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        NoofUplinkSymbols::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NoofUplinkSymbols");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NoofUplinkSymbols");
            e
        })
    }
}
// NotificationCause
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum NotificationCause {
    Fulfilled,
    NotFulfilled,
}

impl NotificationCause {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(1), true)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(1),
            true,
            *self as i128,
            (*self as u32) >= 2,
        )
    }
}

impl PerCodec for NotificationCause {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        NotificationCause::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NotificationCause");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NotificationCause");
            e
        })
    }
}
// NotificationControl
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum NotificationControl {
    Active,
    NotActive,
}

impl NotificationControl {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(1), true)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(1),
            true,
            *self as i128,
            (*self as u32) >= 2,
        )
    }
}

impl PerCodec for NotificationControl {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        NotificationControl::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NotificationControl");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NotificationControl");
            e
        })
    }
}
// NotificationInformation
#[derive(Clone, Debug)]
pub struct NotificationInformation {
    pub message_identifier: MessageIdentifier,
    pub serial_number: SerialNumber,
}

impl NotificationInformation {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let message_identifier = MessageIdentifier::decode(data)?;
        let serial_number = SerialNumber::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            message_identifier,
            serial_number,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.message_identifier.encode(data)?;
        self.serial_number.encode(data)?;

        Ok(())
    }
}

impl PerCodec for NotificationInformation {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        NotificationInformation::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NotificationInformation");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NotificationInformation");
            e
        })
    }
}
// NpnBroadcastInformation
#[derive(Clone, Debug)]
pub enum NpnBroadcastInformation {
    SnpnBroadcastInformation(NpnBroadcastInformationSnpn),
    PniNpnBroadcastInformation(NpnBroadcastInformationPniNpn),
}

impl NpnBroadcastInformation {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_choice_idx(data, 0, 2, false)?;
        if extended {
            return Err(per_codec_error_new("CHOICE additions not implemented"));
        }
        match idx {
            0 => Ok(Self::SnpnBroadcastInformation(
                NpnBroadcastInformationSnpn::decode(data)?,
            )),
            1 => Ok(Self::PniNpnBroadcastInformation(
                NpnBroadcastInformationPniNpn::decode(data)?,
            )),
            2 => {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _ = Criticality::decode(data)?;
                let _ = decode::decode_length_determinent(data, None, None, false)?;
                let result = match id {
                    x => Err(per_codec_error_new(format!("Unrecognised IE type {}", x))),
                };
                data.decode_align()?;
                result
            }
            _ => Err(per_codec_error_new("Unknown choice idx")),
        }
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        match self {
            Self::SnpnBroadcastInformation(x) => {
                encode::encode_choice_idx(data, 0, 2, false, 0, false)?;
                x.encode(data)
            }
            Self::PniNpnBroadcastInformation(x) => {
                encode::encode_choice_idx(data, 0, 2, false, 1, false)?;
                x.encode(data)
            }
        }
    }
}

impl PerCodec for NpnBroadcastInformation {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        NpnBroadcastInformation::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NpnBroadcastInformation");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NpnBroadcastInformation");
            e
        })
    }
}
// NpnBroadcastInformationSnpn
#[derive(Clone, Debug)]
pub struct NpnBroadcastInformationSnpn {
    pub broadcast_snpnid_list: BroadcastSnpnIdList,
}

impl NpnBroadcastInformationSnpn {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let broadcast_snpnid_list = BroadcastSnpnIdList::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            broadcast_snpnid_list,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.broadcast_snpnid_list.encode(data)?;

        Ok(())
    }
}

impl PerCodec for NpnBroadcastInformationSnpn {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        NpnBroadcastInformationSnpn::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NpnBroadcastInformationSnpn");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NpnBroadcastInformationSnpn");
            e
        })
    }
}
// NpnBroadcastInformationPniNpn
#[derive(Clone, Debug)]
pub struct NpnBroadcastInformationPniNpn {
    pub broadcast_pni_npn_id_information: BroadcastPniNpnIdList,
}

impl NpnBroadcastInformationPniNpn {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let broadcast_pni_npn_id_information = BroadcastPniNpnIdList::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            broadcast_pni_npn_id_information,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.broadcast_pni_npn_id_information.encode(data)?;

        Ok(())
    }
}

impl PerCodec for NpnBroadcastInformationPniNpn {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        NpnBroadcastInformationPniNpn::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NpnBroadcastInformationPniNpn");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NpnBroadcastInformationPniNpn");
            e
        })
    }
}
// NpnSupportInfo
#[derive(Clone, Debug)]
pub enum NpnSupportInfo {
    SnpnInformation(Nid),
}

impl NpnSupportInfo {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_choice_idx(data, 0, 1, false)?;
        if extended {
            return Err(per_codec_error_new("CHOICE additions not implemented"));
        }
        match idx {
            0 => Ok(Self::SnpnInformation(Nid::decode(data)?)),
            1 => {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _ = Criticality::decode(data)?;
                let _ = decode::decode_length_determinent(data, None, None, false)?;
                let result = match id {
                    x => Err(per_codec_error_new(format!("Unrecognised IE type {}", x))),
                };
                data.decode_align()?;
                result
            }
            _ => Err(per_codec_error_new("Unknown choice idx")),
        }
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        match self {
            Self::SnpnInformation(x) => {
                encode::encode_choice_idx(data, 0, 1, false, 0, false)?;
                x.encode(data)
            }
        }
    }
}

impl PerCodec for NpnSupportInfo {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        NpnSupportInfo::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NpnSupportInfo");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NpnSupportInfo");
            e
        })
    }
}
// NrCarrierList
#[derive(Clone, Debug)]
pub struct NrCarrierList(pub NonEmpty<NrCarrierItem>);

impl NrCarrierList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(5), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(NrCarrierItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(5), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for NrCarrierList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        NrCarrierList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NrCarrierList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NrCarrierList");
            e
        })
    }
}
// NrCarrierItem
#[derive(Clone, Debug)]
pub struct NrCarrierItem {
    pub carrier_scs: NrScs,
    pub offset_to_carrier: u16,
    pub carrier_bandwidth: u16,
}

impl NrCarrierItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let carrier_scs = NrScs::decode(data)?;
        let offset_to_carrier = decode::decode_integer(data, Some(0), Some(2199), true)?.0 as u16;
        let carrier_bandwidth = decode::decode_integer(data, Some(0), Some(275), true)?.0 as u16;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            carrier_scs,
            offset_to_carrier,
            carrier_bandwidth,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.carrier_scs.encode(data)?;
        encode::encode_integer(
            data,
            Some(0),
            Some(2199),
            true,
            self.offset_to_carrier as i128,
            false,
        )?;
        encode::encode_integer(
            data,
            Some(0),
            Some(275),
            true,
            self.carrier_bandwidth as i128,
            false,
        )?;

        Ok(())
    }
}

impl PerCodec for NrCarrierItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        NrCarrierItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NrCarrierItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NrCarrierItem");
            e
        })
    }
}
// NrFreqInfo
#[derive(Clone, Debug)]
pub struct NrFreqInfo {
    pub nr_arfcn: u32,
    pub sul_information: Option<SulInformation>,
    pub freq_band_list_nr: NonEmpty<FreqBandNrItem>,
    pub frequency_shift7p5khz: Option<FrequencyShift7p5khz>,
}

impl NrFreqInfo {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 2)?;
        let nr_arfcn = decode::decode_integer(data, Some(0), Some(3279165), false)?.0 as u32;
        let sul_information = if optionals[0] {
            Some(SulInformation::decode(data)?)
        } else {
            None
        };
        let freq_band_list_nr = {
            let length = decode::decode_length_determinent(data, Some(1), Some(32), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(FreqBandNrItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        };

        // Process the extension container
        let mut frequency_shift7p5khz: Option<FrequencyShift7p5khz> = None;

        if optionals[1] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    356 => frequency_shift7p5khz = Some(FrequencyShift7p5khz::decode(data)?),
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            nr_arfcn,
            sul_information,
            freq_band_list_nr,
            frequency_shift7p5khz,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();
        if let Some(x) = &self.frequency_shift7p5khz {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 356, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        let mut optionals = BitString::new();
        optionals.push(self.sul_information.is_some());
        optionals.push(num_ies != 0);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        encode::encode_integer(
            data,
            Some(0),
            Some(3279165),
            false,
            self.nr_arfcn as i128,
            false,
        )?;
        if let Some(x) = &self.sul_information {
            x.encode(data)?;
        }
        encode::encode_length_determinent(
            data,
            Some(1),
            Some(32),
            false,
            self.freq_band_list_nr.len(),
        )?;
        for x in &self.freq_band_list_nr {
            x.encode(data)?;
        }
        Ok(())?;
        if num_ies != 0 {
            encode::encode_length_determinent(data, Some(1), Some(65535), false, num_ies)?;
            data.append_aligned(ies);
        }
        Ok(())
    }
}

impl PerCodec for NrFreqInfo {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        NrFreqInfo::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NrFreqInfo");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NrFreqInfo");
            e
        })
    }
}
// NrCgi
#[derive(Clone, Debug)]
pub struct NrCgi {
    pub plmn_identity: PlmnIdentity,
    pub nr_cell_identity: NrCellIdentity,
}

impl NrCgi {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let plmn_identity = PlmnIdentity::decode(data)?;
        let nr_cell_identity = NrCellIdentity::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            plmn_identity,
            nr_cell_identity,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.plmn_identity.encode(data)?;
        self.nr_cell_identity.encode(data)?;

        Ok(())
    }
}

impl PerCodec for NrCgi {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        NrCgi::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NrCgi");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NrCgi");
            e
        })
    }
}
// NrModeInfo
#[derive(Clone, Debug)]
pub enum NrModeInfo {
    Fdd(FddInfo),
    Tdd(TddInfo),
    NrUChannelInfoList(NrUChannelInfoList),
}

impl NrModeInfo {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_choice_idx(data, 0, 2, false)?;
        if extended {
            return Err(per_codec_error_new("CHOICE additions not implemented"));
        }
        match idx {
            0 => Ok(Self::Fdd(FddInfo::decode(data)?)),
            1 => Ok(Self::Tdd(TddInfo::decode(data)?)),
            2 => {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _ = Criticality::decode(data)?;
                let _ = decode::decode_length_determinent(data, None, None, false)?;
                let result = match id {
                    445 => Ok(Self::NrUChannelInfoList(NrUChannelInfoList::decode(data)?)),
                    x => Err(per_codec_error_new(format!("Unrecognised IE type {}", x))),
                };
                data.decode_align()?;
                result
            }
            _ => Err(per_codec_error_new("Unknown choice idx")),
        }
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        match self {
            Self::Fdd(x) => {
                encode::encode_choice_idx(data, 0, 2, false, 0, false)?;
                x.encode(data)
            }
            Self::Tdd(x) => {
                encode::encode_choice_idx(data, 0, 2, false, 1, false)?;
                x.encode(data)
            }
            Self::NrUChannelInfoList(x) => {
                encode::encode_choice_idx(data, 0, 2, false, 2, false)?;
                encode::encode_integer(data, Some(0), Some(65535), false, 445, false)?;
                Criticality::Ignore.encode(data)?;
                let ie = &mut Allocator::new_codec_data();
                x.encode(ie)?;
                encode::encode_length_determinent(data, None, None, false, ie.length_in_bytes())?;
                Ok(data.append_aligned(ie))
            }
        }
    }
}

impl PerCodec for NrModeInfo {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        NrModeInfo::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NrModeInfo");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NrModeInfo");
            e
        })
    }
}
// NrModeInfoRel16
#[derive(Clone, Debug)]
pub enum NrModeInfoRel16 {
    Fdd(FddInfoRel16),
    Tdd(TddInfoRel16),
}

impl NrModeInfoRel16 {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_choice_idx(data, 0, 2, false)?;
        if extended {
            return Err(per_codec_error_new("CHOICE additions not implemented"));
        }
        match idx {
            0 => Ok(Self::Fdd(FddInfoRel16::decode(data)?)),
            1 => Ok(Self::Tdd(TddInfoRel16::decode(data)?)),
            2 => {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _ = Criticality::decode(data)?;
                let _ = decode::decode_length_determinent(data, None, None, false)?;
                let result = match id {
                    x => Err(per_codec_error_new(format!("Unrecognised IE type {}", x))),
                };
                data.decode_align()?;
                result
            }
            _ => Err(per_codec_error_new("Unknown choice idx")),
        }
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        match self {
            Self::Fdd(x) => {
                encode::encode_choice_idx(data, 0, 2, false, 0, false)?;
                x.encode(data)
            }
            Self::Tdd(x) => {
                encode::encode_choice_idx(data, 0, 2, false, 1, false)?;
                x.encode(data)
            }
        }
    }
}

impl PerCodec for NrModeInfoRel16 {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        NrModeInfoRel16::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NrModeInfoRel16");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NrModeInfoRel16");
            e
        })
    }
}
// NrPrachConfig
#[derive(Clone, Debug)]
pub struct NrPrachConfig {
    pub ul_prach_config_list: Option<NrPrachConfigList>,
    pub sul_prach_config_list: Option<NrPrachConfigList>,
}

impl NrPrachConfig {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 3)?;
        let ul_prach_config_list = if optionals[0] {
            Some(NrPrachConfigList::decode(data)?)
        } else {
            None
        };
        let sul_prach_config_list = if optionals[1] {
            Some(NrPrachConfigList::decode(data)?)
        } else {
            None
        };

        // Process the extension container

        if optionals[2] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            ul_prach_config_list,
            sul_prach_config_list,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.ul_prach_config_list.is_some());
        optionals.push(self.sul_prach_config_list.is_some());
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        if let Some(x) = &self.ul_prach_config_list {
            x.encode(data)?;
        }
        if let Some(x) = &self.sul_prach_config_list {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl PerCodec for NrPrachConfig {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        NrPrachConfig::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NrPrachConfig");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NrPrachConfig");
            e
        })
    }
}
// NrCellIdentity
#[derive(Clone, Debug)]
pub struct NrCellIdentity(pub BitString);

impl NrCellIdentity {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(decode::decode_bitstring(
            data,
            Some(36),
            Some(36),
            false,
        )?))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_bitstring(data, Some(36), Some(36), false, &self.0, false)
    }
}

impl PerCodec for NrCellIdentity {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        NrCellIdentity::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NrCellIdentity");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NrCellIdentity");
            e
        })
    }
}
// NrNrB
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum NrNrB {
    Nrb11,
    Nrb18,
    Nrb24,
    Nrb25,
    Nrb31,
    Nrb32,
    Nrb38,
    Nrb51,
    Nrb52,
    Nrb65,
    Nrb66,
    Nrb78,
    Nrb79,
    Nrb93,
    Nrb106,
    Nrb107,
    Nrb121,
    Nrb132,
    Nrb133,
    Nrb135,
    Nrb160,
    Nrb162,
    Nrb189,
    Nrb216,
    Nrb217,
    Nrb245,
    Nrb264,
    Nrb270,
    Nrb273,
    Nrb33,
    Nrb62,
    Nrb124,
    Nrb148,
    Nrb248,
    Nrb44,
    Nrb58,
    Nrb92,
    Nrb119,
    Nrb188,
    Nrb242,
    Nrb15,
}

impl NrNrB {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(28), true)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(28),
            true,
            *self as i128,
            (*self as u32) >= 29,
        )
    }
}

impl PerCodec for NrNrB {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        NrNrB::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NrNrB");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NrNrB");
            e
        })
    }
}
// NrPci
#[derive(Clone, Copy, Debug)]
pub struct NrPci(pub u16);

impl NrPci {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(
            decode::decode_integer(data, Some(0), Some(1007), false)?.0 as u16,
        ))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_integer(data, Some(0), Some(1007), false, self.0 as i128, false)
    }
}

impl PerCodec for NrPci {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        NrPci::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NrPci");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NrPci");
            e
        })
    }
}
// NrPrachConfigList
#[derive(Clone, Debug)]
pub struct NrPrachConfigList(pub Vec<NrPrachConfigItem>);

impl NrPrachConfigList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(0), Some(16), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(NrPrachConfigItem::decode(data)?);
            }
            items
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(0), Some(16), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for NrPrachConfigList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        NrPrachConfigList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NrPrachConfigList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NrPrachConfigList");
            e
        })
    }
}
// NrPrachConfigItem
#[derive(Clone, Debug)]
pub struct NrPrachConfigItem {
    pub nr_scs: NrScs,
    pub prach_freq_startfrom_carrier: u16,
    pub prach_fdm: PrachFdm,
    pub prach_config_index: i128,
    pub ssb_per_rach_occasion: SsbPerRachOccasion,
    pub freq_domain_length: FreqDomainLength,
    pub zero_correl_zone_config: u8,
}

impl NrPrachConfigItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let nr_scs = NrScs::decode(data)?;
        let prach_freq_startfrom_carrier =
            decode::decode_integer(data, Some(0), Some(274), true)?.0 as u16;
        let prach_fdm = PrachFdm::decode(data)?;
        let prach_config_index = decode::decode_integer(data, Some(0), Some(255), true)?.0;
        let ssb_per_rach_occasion = SsbPerRachOccasion::decode(data)?;
        let freq_domain_length = FreqDomainLength::decode(data)?;
        let zero_correl_zone_config =
            decode::decode_integer(data, Some(0), Some(15), false)?.0 as u8;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            nr_scs,
            prach_freq_startfrom_carrier,
            prach_fdm,
            prach_config_index,
            ssb_per_rach_occasion,
            freq_domain_length,
            zero_correl_zone_config,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.nr_scs.encode(data)?;
        encode::encode_integer(
            data,
            Some(0),
            Some(274),
            true,
            self.prach_freq_startfrom_carrier as i128,
            false,
        )?;
        self.prach_fdm.encode(data)?;
        encode::encode_integer(
            data,
            Some(0),
            Some(255),
            true,
            self.prach_config_index,
            false,
        )?;
        self.ssb_per_rach_occasion.encode(data)?;
        self.freq_domain_length.encode(data)?;
        encode::encode_integer(
            data,
            Some(0),
            Some(15),
            false,
            self.zero_correl_zone_config as i128,
            false,
        )?;

        Ok(())
    }
}

impl PerCodec for NrPrachConfigItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        NrPrachConfigItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NrPrachConfigItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NrPrachConfigItem");
            e
        })
    }
}
// NrScs
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum NrScs {
    Scs15,
    Scs30,
    Scs60,
    Scs120,
    Scs480,
    Scs960,
}

impl NrScs {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(3), true)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(3),
            true,
            *self as i128,
            (*self as u32) >= 4,
        )
    }
}

impl PerCodec for NrScs {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        NrScs::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NrScs");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NrScs");
            e
        })
    }
}
// NrUeRlfReportContainer
#[derive(Clone, Debug)]
pub struct NrUeRlfReportContainer(pub Vec<u8>);

impl NrUeRlfReportContainer {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(decode::decode_octetstring(data, None, None, false)?))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_octetstring(data, None, None, false, &self.0, false)
    }
}

impl PerCodec for NrUeRlfReportContainer {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        NrUeRlfReportContainer::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NrUeRlfReportContainer");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NrUeRlfReportContainer");
            e
        })
    }
}
// NrUChannelInfoList
#[derive(Clone, Debug)]
pub struct NrUChannelInfoList(pub NonEmpty<NrUChannelInfoItem>);

impl NrUChannelInfoList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(16), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(NrUChannelInfoItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(16), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for NrUChannelInfoList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        NrUChannelInfoList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NrUChannelInfoList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NrUChannelInfoList");
            e
        })
    }
}
// NrUChannelInfoItem
#[derive(Clone, Debug)]
pub struct NrUChannelInfoItem {
    pub nr_u_channel_id: u8,
    pub nr_arfcn: u32,
    pub bandwidth: Bandwidth,
}

impl NrUChannelInfoItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let nr_u_channel_id = decode::decode_integer(data, Some(1), Some(16), true)?.0 as u8;
        let nr_arfcn = decode::decode_integer(data, Some(0), Some(3279165), false)?.0 as u32;
        let bandwidth = Bandwidth::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            nr_u_channel_id,
            nr_arfcn,
            bandwidth,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        encode::encode_integer(
            data,
            Some(1),
            Some(16),
            true,
            self.nr_u_channel_id as i128,
            false,
        )?;
        encode::encode_integer(
            data,
            Some(0),
            Some(3279165),
            false,
            self.nr_arfcn as i128,
            false,
        )?;
        self.bandwidth.encode(data)?;

        Ok(())
    }
}

impl PerCodec for NrUChannelInfoItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        NrUChannelInfoItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NrUChannelInfoItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NrUChannelInfoItem");
            e
        })
    }
}
// NrUChannelList
#[derive(Clone, Debug)]
pub struct NrUChannelList(pub NonEmpty<NrUChannelItem>);

impl NrUChannelList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(16), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(NrUChannelItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(16), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for NrUChannelList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        NrUChannelList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NrUChannelList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NrUChannelList");
            e
        })
    }
}
// NrUChannelItem
#[derive(Clone, Debug)]
pub struct NrUChannelItem {
    pub nr_u_channel_id: u8,
    pub channel_occupancy_time_percentage_dl: ChannelOccupancyTimePercentage,
    pub energy_detection_threshold: EnergyDetectionThreshold,
    pub channel_occupancy_time_percentage_ul: Option<ChannelOccupancyTimePercentage>,
    pub radio_resource_status_nr_u: Option<RadioResourceStatusNrU>,
}

impl NrUChannelItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let nr_u_channel_id = decode::decode_integer(data, Some(1), Some(16), false)?.0 as u8;
        let channel_occupancy_time_percentage_dl = ChannelOccupancyTimePercentage::decode(data)?;
        let energy_detection_threshold = EnergyDetectionThreshold::decode(data)?;

        // Process the extension container
        let mut channel_occupancy_time_percentage_ul: Option<ChannelOccupancyTimePercentage> = None;
        let mut radio_resource_status_nr_u: Option<RadioResourceStatusNrU> = None;

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    735 => {
                        channel_occupancy_time_percentage_ul =
                            Some(ChannelOccupancyTimePercentage::decode(data)?)
                    }
                    737 => radio_resource_status_nr_u = Some(RadioResourceStatusNrU::decode(data)?),
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            nr_u_channel_id,
            channel_occupancy_time_percentage_dl,
            energy_detection_threshold,
            channel_occupancy_time_percentage_ul,
            radio_resource_status_nr_u,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();
        if let Some(x) = &self.channel_occupancy_time_percentage_ul {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 735, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.radio_resource_status_nr_u {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 737, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        let mut optionals = BitString::new();
        optionals.push(num_ies != 0);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        encode::encode_integer(
            data,
            Some(1),
            Some(16),
            false,
            self.nr_u_channel_id as i128,
            false,
        )?;
        self.channel_occupancy_time_percentage_dl.encode(data)?;
        self.energy_detection_threshold.encode(data)?;
        if num_ies != 0 {
            encode::encode_length_determinent(data, Some(1), Some(65535), false, num_ies)?;
            data.append_aligned(ies);
        }
        Ok(())
    }
}

impl PerCodec for NrUChannelItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        NrUChannelItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NrUChannelItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NrUChannelItem");
            e
        })
    }
}
// NumberofActiveUes
#[derive(Clone, Copy, Debug)]
pub struct NumberofActiveUes(pub u32);

impl NumberofActiveUes {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(
            decode::decode_integer(data, Some(0), Some(16777215), true)?.0 as u32,
        ))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_integer(data, Some(0), Some(16777215), true, self.0 as i128, false)
    }
}

impl PerCodec for NumberofActiveUes {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        NumberofActiveUes::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NumberofActiveUes");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NumberofActiveUes");
            e
        })
    }
}
// NumberOfBroadcasts
#[derive(Clone, Copy, Debug)]
pub struct NumberOfBroadcasts(pub u16);

impl NumberOfBroadcasts {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(
            decode::decode_integer(data, Some(0), Some(65535), false)?.0 as u16,
        ))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_integer(data, Some(0), Some(65535), false, self.0 as i128, false)
    }
}

impl PerCodec for NumberOfBroadcasts {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        NumberOfBroadcasts::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NumberOfBroadcasts");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NumberOfBroadcasts");
            e
        })
    }
}
// NumberofBroadcastRequest
#[derive(Clone, Copy, Debug)]
pub struct NumberofBroadcastRequest(pub u16);

impl NumberofBroadcastRequest {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(
            decode::decode_integer(data, Some(0), Some(65535), false)?.0 as u16,
        ))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_integer(data, Some(0), Some(65535), false, self.0 as i128, false)
    }
}

impl PerCodec for NumberofBroadcastRequest {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        NumberofBroadcastRequest::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NumberofBroadcastRequest");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NumberofBroadcastRequest");
            e
        })
    }
}
// NumberOfTrpRxTeg
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum NumberOfTrpRxTeg {
    Two,
    Three,
    Four,
    Six,
    Eight,
}

impl NumberOfTrpRxTeg {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(4), true)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(4),
            true,
            *self as i128,
            (*self as u32) >= 5,
        )
    }
}

impl PerCodec for NumberOfTrpRxTeg {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        NumberOfTrpRxTeg::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NumberOfTrpRxTeg");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NumberOfTrpRxTeg");
            e
        })
    }
}
// NumberOfTrpRxTxTeg
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum NumberOfTrpRxTxTeg {
    Wo,
    Three,
    Four,
    Six,
    Eight,
}

impl NumberOfTrpRxTxTeg {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(4), true)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(4),
            true,
            *self as i128,
            (*self as u32) >= 5,
        )
    }
}

impl PerCodec for NumberOfTrpRxTxTeg {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        NumberOfTrpRxTxTeg::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NumberOfTrpRxTxTeg");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NumberOfTrpRxTxTeg");
            e
        })
    }
}
// NumDlUlSymbols
#[derive(Clone, Debug)]
pub struct NumDlUlSymbols {
    pub num_dl_symbols: u8,
    pub num_ul_symbols: u8,
    pub permutation: Option<Permutation>,
}

impl NumDlUlSymbols {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, false, 1)?;
        let num_dl_symbols = decode::decode_integer(data, Some(0), Some(13), true)?.0 as u8;
        let num_ul_symbols = decode::decode_integer(data, Some(0), Some(13), true)?.0 as u8;

        // Process the extension container
        let mut permutation: Option<Permutation> = None;

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    535 => permutation = Some(Permutation::decode(data)?),
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            num_dl_symbols,
            num_ul_symbols,
            permutation,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();
        if let Some(x) = &self.permutation {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 535, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        let mut optionals = BitString::new();
        optionals.push(num_ies != 0);

        encode::encode_sequence_header(data, false, &optionals, false)?;
        encode::encode_integer(
            data,
            Some(0),
            Some(13),
            true,
            self.num_dl_symbols as i128,
            false,
        )?;
        encode::encode_integer(
            data,
            Some(0),
            Some(13),
            true,
            self.num_ul_symbols as i128,
            false,
        )?;
        if num_ies != 0 {
            encode::encode_length_determinent(data, Some(1), Some(65535), false, num_ies)?;
            data.append_aligned(ies);
        }
        Ok(())
    }
}

impl PerCodec for NumDlUlSymbols {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        NumDlUlSymbols::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NumDlUlSymbols");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NumDlUlSymbols");
            e
        })
    }
}
// NrV2xServicesAuthorized
#[derive(Clone, Debug)]
pub struct NrV2xServicesAuthorized {
    pub vehicle_ue: Option<VehicleUe>,
    pub pedestrian_ue: Option<PedestrianUe>,
}

impl NrV2xServicesAuthorized {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, false, 3)?;
        let vehicle_ue = if optionals[0] {
            Some(VehicleUe::decode(data)?)
        } else {
            None
        };
        let pedestrian_ue = if optionals[1] {
            Some(PedestrianUe::decode(data)?)
        } else {
            None
        };

        // Process the extension container

        if optionals[2] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            vehicle_ue,
            pedestrian_ue,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.vehicle_ue.is_some());
        optionals.push(self.pedestrian_ue.is_some());
        optionals.push(false);

        encode::encode_sequence_header(data, false, &optionals, false)?;
        if let Some(x) = &self.vehicle_ue {
            x.encode(data)?;
        }
        if let Some(x) = &self.pedestrian_ue {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl PerCodec for NrV2xServicesAuthorized {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        NrV2xServicesAuthorized::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NrV2xServicesAuthorized");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NrV2xServicesAuthorized");
            e
        })
    }
}
// NrUeSidelinkAggregateMaximumBitrate
#[derive(Clone, Debug)]
pub struct NrUeSidelinkAggregateMaximumBitrate {
    pub ue_nr_sidelink_aggregate_maximum_bitrate: BitRate,
}

impl NrUeSidelinkAggregateMaximumBitrate {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, false, 1)?;
        let ue_nr_sidelink_aggregate_maximum_bitrate = BitRate::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            ue_nr_sidelink_aggregate_maximum_bitrate,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, false, &optionals, false)?;
        self.ue_nr_sidelink_aggregate_maximum_bitrate.encode(data)?;

        Ok(())
    }
}

impl PerCodec for NrUeSidelinkAggregateMaximumBitrate {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        NrUeSidelinkAggregateMaximumBitrate::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NrUeSidelinkAggregateMaximumBitrate");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NrUeSidelinkAggregateMaximumBitrate");
            e
        })
    }
}
// NzpCsiRsResourceId
#[derive(Clone, Copy, Debug)]
pub struct NzpCsiRsResourceId(pub u8);

impl NzpCsiRsResourceId {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(
            decode::decode_integer(data, Some(0), Some(191), false)?.0 as u8,
        ))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_integer(data, Some(0), Some(191), false, self.0 as i128, false)
    }
}

impl PerCodec for NzpCsiRsResourceId {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        NzpCsiRsResourceId::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NzpCsiRsResourceId");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NzpCsiRsResourceId");
            e
        })
    }
}
// N6JitterInformation
#[derive(Clone, Debug)]
pub struct N6JitterInformation {
    pub n6_jitter_lower_bound: i8,
    pub n6_jitter_upper_bound: i8,
}

impl N6JitterInformation {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let n6_jitter_lower_bound =
            decode::decode_integer(data, Some(-127), Some(127), false)?.0 as i8;
        let n6_jitter_upper_bound =
            decode::decode_integer(data, Some(-127), Some(127), false)?.0 as i8;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            n6_jitter_lower_bound,
            n6_jitter_upper_bound,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        encode::encode_integer(
            data,
            Some(-127),
            Some(127),
            false,
            self.n6_jitter_lower_bound as i128,
            false,
        )?;
        encode::encode_integer(
            data,
            Some(-127),
            Some(127),
            false,
            self.n6_jitter_upper_bound as i128,
            false,
        )?;

        Ok(())
    }
}

impl PerCodec for N6JitterInformation {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        N6JitterInformation::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("N6JitterInformation");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("N6JitterInformation");
            e
        })
    }
}
// OffsetToPointA
#[derive(Clone, Copy, Debug)]
pub struct OffsetToPointA(pub u16);

impl OffsetToPointA {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(
            decode::decode_integer(data, Some(0), Some(2199), true)?.0 as u16,
        ))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_integer(data, Some(0), Some(2199), true, self.0 as i128, false)
    }
}

impl PerCodec for OffsetToPointA {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        OffsetToPointA::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("OffsetToPointA");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("OffsetToPointA");
            e
        })
    }
}
// OnDemandPrsInfo
#[derive(Clone, Debug)]
pub struct OnDemandPrsInfo {
    pub on_demand_prs_request_allowed: BitString,
    pub allowed_resource_set_periodicity_values: Option<BitString>,
    pub allowed_prs_bandwidth_values: Option<BitString>,
    pub allowed_resource_repetition_factor_values: Option<BitString>,
    pub allowed_resource_number_of_symbols_values: Option<BitString>,
    pub allowed_comb_size_values: Option<BitString>,
}

impl OnDemandPrsInfo {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 6)?;
        let on_demand_prs_request_allowed =
            decode::decode_bitstring(data, Some(16), Some(16), false)?;
        let allowed_resource_set_periodicity_values = if optionals[0] {
            Some(decode::decode_bitstring(data, Some(24), Some(24), false)?)
        } else {
            None
        };
        let allowed_prs_bandwidth_values = if optionals[1] {
            Some(decode::decode_bitstring(data, Some(64), Some(64), false)?)
        } else {
            None
        };
        let allowed_resource_repetition_factor_values = if optionals[2] {
            Some(decode::decode_bitstring(data, Some(8), Some(8), false)?)
        } else {
            None
        };
        let allowed_resource_number_of_symbols_values = if optionals[3] {
            Some(decode::decode_bitstring(data, Some(8), Some(8), false)?)
        } else {
            None
        };
        let allowed_comb_size_values = if optionals[4] {
            Some(decode::decode_bitstring(data, Some(8), Some(8), false)?)
        } else {
            None
        };

        // Process the extension container

        if optionals[5] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            on_demand_prs_request_allowed,
            allowed_resource_set_periodicity_values,
            allowed_prs_bandwidth_values,
            allowed_resource_repetition_factor_values,
            allowed_resource_number_of_symbols_values,
            allowed_comb_size_values,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.allowed_resource_set_periodicity_values.is_some());
        optionals.push(self.allowed_prs_bandwidth_values.is_some());
        optionals.push(self.allowed_resource_repetition_factor_values.is_some());
        optionals.push(self.allowed_resource_number_of_symbols_values.is_some());
        optionals.push(self.allowed_comb_size_values.is_some());
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        encode::encode_bitstring(
            data,
            Some(16),
            Some(16),
            false,
            &self.on_demand_prs_request_allowed,
            false,
        )?;
        if let Some(x) = &self.allowed_resource_set_periodicity_values {
            encode::encode_bitstring(data, Some(24), Some(24), false, &x, false)?;
        }
        if let Some(x) = &self.allowed_prs_bandwidth_values {
            encode::encode_bitstring(data, Some(64), Some(64), false, &x, false)?;
        }
        if let Some(x) = &self.allowed_resource_repetition_factor_values {
            encode::encode_bitstring(data, Some(8), Some(8), false, &x, false)?;
        }
        if let Some(x) = &self.allowed_resource_number_of_symbols_values {
            encode::encode_bitstring(data, Some(8), Some(8), false, &x, false)?;
        }
        if let Some(x) = &self.allowed_comb_size_values {
            encode::encode_bitstring(data, Some(8), Some(8), false, &x, false)?;
        }

        Ok(())
    }
}

impl PerCodec for OnDemandPrsInfo {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        OnDemandPrsInfo::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("OnDemandPrsInfo");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("OnDemandPrsInfo");
            e
        })
    }
}
// PacketDelayBudget
#[derive(Clone, Copy, Debug)]
pub struct PacketDelayBudget(pub u16);

impl PacketDelayBudget {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(
            decode::decode_integer(data, Some(0), Some(1023), true)?.0 as u16,
        ))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_integer(data, Some(0), Some(1023), true, self.0 as i128, false)
    }
}

impl PerCodec for PacketDelayBudget {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PacketDelayBudget::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PacketDelayBudget");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PacketDelayBudget");
            e
        })
    }
}
// PacketErrorRate
#[derive(Clone, Debug)]
pub struct PacketErrorRate {
    pub per_scalar: PerScalar,
    pub per_exponent: PerExponent,
}

impl PacketErrorRate {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let per_scalar = PerScalar::decode(data)?;
        let per_exponent = PerExponent::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            per_scalar,
            per_exponent,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.per_scalar.encode(data)?;
        self.per_exponent.encode(data)?;

        Ok(())
    }
}

impl PerCodec for PacketErrorRate {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PacketErrorRate::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PacketErrorRate");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PacketErrorRate");
            e
        })
    }
}
// PathAdditionInformation
#[derive(Clone, Debug)]
pub enum PathAdditionInformation {
    IndirectPathAddition(IndirectPathAddition),
    DirectPathAddition,
    N3cIndirectPathAddition(N3cIndirectPathAddition),
}

impl PathAdditionInformation {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_choice_idx(data, 0, 3, false)?;
        if extended {
            return Err(per_codec_error_new("CHOICE additions not implemented"));
        }
        match idx {
            0 => Ok(Self::IndirectPathAddition(IndirectPathAddition::decode(
                data,
            )?)),
            1 => Ok(Self::DirectPathAddition),
            2 => Ok(Self::N3cIndirectPathAddition(
                N3cIndirectPathAddition::decode(data)?,
            )),
            3 => {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _ = Criticality::decode(data)?;
                let _ = decode::decode_length_determinent(data, None, None, false)?;
                let result = match id {
                    x => Err(per_codec_error_new(format!("Unrecognised IE type {}", x))),
                };
                data.decode_align()?;
                result
            }
            _ => Err(per_codec_error_new("Unknown choice idx")),
        }
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        match self {
            Self::IndirectPathAddition(x) => {
                encode::encode_choice_idx(data, 0, 3, false, 0, false)?;
                x.encode(data)
            }
            Self::DirectPathAddition => {
                encode::encode_choice_idx(data, 0, 3, false, 1, false)?;
                Ok(())
            }
            Self::N3cIndirectPathAddition(x) => {
                encode::encode_choice_idx(data, 0, 3, false, 2, false)?;
                x.encode(data)
            }
        }
    }
}

impl PerCodec for PathAdditionInformation {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PathAdditionInformation::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PathAdditionInformation");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PathAdditionInformation");
            e
        })
    }
}
// PerScalar
#[derive(Clone, Copy, Debug)]
pub struct PerScalar(pub u8);

impl PerScalar {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(
            decode::decode_integer(data, Some(0), Some(9), true)?.0 as u8,
        ))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_integer(data, Some(0), Some(9), true, self.0 as i128, false)
    }
}

impl PerCodec for PerScalar {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PerScalar::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PerScalar");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PerScalar");
            e
        })
    }
}
// PerExponent
#[derive(Clone, Copy, Debug)]
pub struct PerExponent(pub u8);

impl PerExponent {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(
            decode::decode_integer(data, Some(0), Some(9), true)?.0 as u8,
        ))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_integer(data, Some(0), Some(9), true, self.0 as i128, false)
    }
}

impl PerCodec for PerExponent {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PerExponent::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PerExponent");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PerExponent");
            e
        })
    }
}
// PagingCellItem
#[derive(Clone, Debug)]
pub struct PagingCellItem {
    pub nr_cgi: NrCgi,
    pub last_used_cell_indication: Option<LastUsedCellIndication>,
    pub pei_subgrouping_support_indication: Option<PeiSubgroupingSupportIndication>,
    pub recommended_ss_bs_list: Option<RecommendedSsBsList>,
}

impl PagingCellItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, false, 1)?;
        let nr_cgi = NrCgi::decode(data)?;

        // Process the extension container
        let mut last_used_cell_indication: Option<LastUsedCellIndication> = None;
        let mut pei_subgrouping_support_indication: Option<PeiSubgroupingSupportIndication> = None;
        let mut recommended_ss_bs_list: Option<RecommendedSsBsList> = None;

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    624 => last_used_cell_indication = Some(LastUsedCellIndication::decode(data)?),
                    664 => {
                        pei_subgrouping_support_indication =
                            Some(PeiSubgroupingSupportIndication::decode(data)?)
                    }
                    742 => recommended_ss_bs_list = Some(RecommendedSsBsList::decode(data)?),
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            nr_cgi,
            last_used_cell_indication,
            pei_subgrouping_support_indication,
            recommended_ss_bs_list,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();
        if let Some(x) = &self.last_used_cell_indication {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 624, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.pei_subgrouping_support_indication {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 664, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.recommended_ss_bs_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 742, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        let mut optionals = BitString::new();
        optionals.push(num_ies != 0);

        encode::encode_sequence_header(data, false, &optionals, false)?;
        self.nr_cgi.encode(data)?;
        if num_ies != 0 {
            encode::encode_length_determinent(data, Some(1), Some(65535), false, num_ies)?;
            data.append_aligned(ies);
        }
        Ok(())
    }
}

impl PerCodec for PagingCellItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PagingCellItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PagingCellItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PagingCellItem");
            e
        })
    }
}
// RecommendedSsBsList
#[derive(Clone, Debug)]
pub struct RecommendedSsBsList(pub NonEmpty<RecommendedSsbItemListItem>);

impl RecommendedSsBsList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(64), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(RecommendedSsbItemListItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(64), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for RecommendedSsBsList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        RecommendedSsBsList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("RecommendedSsBsList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("RecommendedSsBsList");
            e
        })
    }
}
// RecommendedSsbItemListItem
#[derive(Clone, Debug)]
pub struct RecommendedSsbItemListItem {
    pub ssb_index: SsbIndex,
}

impl RecommendedSsbItemListItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, false, 1)?;
        let ssb_index = SsbIndex::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self { ssb_index })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, false, &optionals, false)?;
        self.ssb_index.encode(data)?;

        Ok(())
    }
}

impl PerCodec for RecommendedSsbItemListItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        RecommendedSsbItemListItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("RecommendedSsbItemListItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("RecommendedSsbItemListItem");
            e
        })
    }
}
// PagingDrx
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum PagingDrx {
    V32,
    V64,
    V128,
    V256,
}

impl PagingDrx {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(3), true)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(3),
            true,
            *self as i128,
            (*self as u32) >= 4,
        )
    }
}

impl PerCodec for PagingDrx {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PagingDrx::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PagingDrx");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PagingDrx");
            e
        })
    }
}
// PagingIdentity
#[derive(Clone, Debug)]
pub enum PagingIdentity {
    RanUePagingIdentity(RanUePagingIdentity),
    CnUePagingIdentity(CnUePagingIdentity),
}

impl PagingIdentity {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_choice_idx(data, 0, 2, false)?;
        if extended {
            return Err(per_codec_error_new("CHOICE additions not implemented"));
        }
        match idx {
            0 => Ok(Self::RanUePagingIdentity(RanUePagingIdentity::decode(
                data,
            )?)),
            1 => Ok(Self::CnUePagingIdentity(CnUePagingIdentity::decode(data)?)),
            2 => {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _ = Criticality::decode(data)?;
                let _ = decode::decode_length_determinent(data, None, None, false)?;
                let result = match id {
                    x => Err(per_codec_error_new(format!("Unrecognised IE type {}", x))),
                };
                data.decode_align()?;
                result
            }
            _ => Err(per_codec_error_new("Unknown choice idx")),
        }
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        match self {
            Self::RanUePagingIdentity(x) => {
                encode::encode_choice_idx(data, 0, 2, false, 0, false)?;
                x.encode(data)
            }
            Self::CnUePagingIdentity(x) => {
                encode::encode_choice_idx(data, 0, 2, false, 1, false)?;
                x.encode(data)
            }
        }
    }
}

impl PerCodec for PagingIdentity {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PagingIdentity::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PagingIdentity");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PagingIdentity");
            e
        })
    }
}
// PagingCause
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum PagingCause {
    Voice,
}

impl PagingCause {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(0), true)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(0),
            true,
            *self as i128,
            (*self as u32) >= 1,
        )
    }
}

impl PerCodec for PagingCause {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PagingCause::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PagingCause");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PagingCause");
            e
        })
    }
}
// PagingOrigin
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum PagingOrigin {
    Non3gpp,
}

impl PagingOrigin {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(0), true)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(0),
            true,
            *self as i128,
            (*self as u32) >= 1,
        )
    }
}

impl PerCodec for PagingOrigin {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PagingOrigin::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PagingOrigin");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PagingOrigin");
            e
        })
    }
}
// PagingPriority
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum PagingPriority {
    Priolevel1,
    Priolevel2,
    Priolevel3,
    Priolevel4,
    Priolevel5,
    Priolevel6,
    Priolevel7,
    Priolevel8,
}

impl PagingPriority {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(7), true)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(7),
            true,
            *self as i128,
            (*self as u32) >= 8,
        )
    }
}

impl PerCodec for PagingPriority {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PagingPriority::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PagingPriority");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PagingPriority");
            e
        })
    }
}
// ParentTImeSource
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum ParentTImeSource {
    Synce,
    Ptp,
    Gnss,
    Atomicclock,
    Terrestrialradio,
    Serialtimecode,
    Ntp,
    Handset,
    Other,
}

impl ParentTImeSource {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(8), true)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(8),
            true,
            *self as i128,
            (*self as u32) >= 9,
        )
    }
}

impl PerCodec for ParentTImeSource {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        ParentTImeSource::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ParentTImeSource");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ParentTImeSource");
            e
        })
    }
}
// PeipsAssistanceInfo
#[derive(Clone, Debug)]
pub struct PeipsAssistanceInfo {
    pub cn_subgroup_id: CnSubgroupId,
}

impl PeipsAssistanceInfo {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, false, 1)?;
        let cn_subgroup_id = CnSubgroupId::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self { cn_subgroup_id })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, false, &optionals, false)?;
        self.cn_subgroup_id.encode(data)?;

        Ok(())
    }
}

impl PerCodec for PeipsAssistanceInfo {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PeipsAssistanceInfo::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PeipsAssistanceInfo");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PeipsAssistanceInfo");
            e
        })
    }
}
// RelativePathDelay
#[derive(Clone, Debug)]
pub enum RelativePathDelay {
    K0(u16),
    K1(u16),
    K2(u16),
    K3(u16),
    K4(u16),
    K5(u16),
    ReportingGranularitykminus1AdditionalPath(ReportingGranularitykminus1AdditionalPath),
    ReportingGranularitykminus2AdditionalPath(ReportingGranularitykminus2AdditionalPath),
    ReportingGranularitykminus3AdditionalPath(ReportingGranularitykminus3AdditionalPath),
    ReportingGranularitykminus4AdditionalPath(ReportingGranularitykminus4AdditionalPath),
    ReportingGranularitykminus5AdditionalPath(ReportingGranularitykminus5AdditionalPath),
    ReportingGranularitykminus6AdditionalPath(ReportingGranularitykminus6AdditionalPath),
}

impl RelativePathDelay {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_choice_idx(data, 0, 6, false)?;
        if extended {
            return Err(per_codec_error_new("CHOICE additions not implemented"));
        }
        match idx {
            0 => Ok(Self::K0(
                decode::decode_integer(data, Some(0), Some(16351), false)?.0 as u16,
            )),
            1 => Ok(Self::K1(
                decode::decode_integer(data, Some(0), Some(8176), false)?.0 as u16,
            )),
            2 => Ok(Self::K2(
                decode::decode_integer(data, Some(0), Some(4088), false)?.0 as u16,
            )),
            3 => Ok(Self::K3(
                decode::decode_integer(data, Some(0), Some(2044), false)?.0 as u16,
            )),
            4 => Ok(Self::K4(
                decode::decode_integer(data, Some(0), Some(1022), false)?.0 as u16,
            )),
            5 => Ok(Self::K5(
                decode::decode_integer(data, Some(0), Some(511), false)?.0 as u16,
            )),
            6 => {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _ = Criticality::decode(data)?;
                let _ = decode::decode_length_determinent(data, None, None, false)?;
                let result = match id {
                    808 => Ok(Self::ReportingGranularitykminus1AdditionalPath(
                        ReportingGranularitykminus1AdditionalPath::decode(data)?,
                    )),
                    809 => Ok(Self::ReportingGranularitykminus2AdditionalPath(
                        ReportingGranularitykminus2AdditionalPath::decode(data)?,
                    )),
                    825 => Ok(Self::ReportingGranularitykminus3AdditionalPath(
                        ReportingGranularitykminus3AdditionalPath::decode(data)?,
                    )),
                    826 => Ok(Self::ReportingGranularitykminus4AdditionalPath(
                        ReportingGranularitykminus4AdditionalPath::decode(data)?,
                    )),
                    827 => Ok(Self::ReportingGranularitykminus5AdditionalPath(
                        ReportingGranularitykminus5AdditionalPath::decode(data)?,
                    )),
                    828 => Ok(Self::ReportingGranularitykminus6AdditionalPath(
                        ReportingGranularitykminus6AdditionalPath::decode(data)?,
                    )),
                    x => Err(per_codec_error_new(format!("Unrecognised IE type {}", x))),
                };
                data.decode_align()?;
                result
            }
            _ => Err(per_codec_error_new("Unknown choice idx")),
        }
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        match self {
            Self::K0(x) => {
                encode::encode_choice_idx(data, 0, 6, false, 0, false)?;
                encode::encode_integer(data, Some(0), Some(16351), false, *x as i128, false)
            }
            Self::K1(x) => {
                encode::encode_choice_idx(data, 0, 6, false, 1, false)?;
                encode::encode_integer(data, Some(0), Some(8176), false, *x as i128, false)
            }
            Self::K2(x) => {
                encode::encode_choice_idx(data, 0, 6, false, 2, false)?;
                encode::encode_integer(data, Some(0), Some(4088), false, *x as i128, false)
            }
            Self::K3(x) => {
                encode::encode_choice_idx(data, 0, 6, false, 3, false)?;
                encode::encode_integer(data, Some(0), Some(2044), false, *x as i128, false)
            }
            Self::K4(x) => {
                encode::encode_choice_idx(data, 0, 6, false, 4, false)?;
                encode::encode_integer(data, Some(0), Some(1022), false, *x as i128, false)
            }
            Self::K5(x) => {
                encode::encode_choice_idx(data, 0, 6, false, 5, false)?;
                encode::encode_integer(data, Some(0), Some(511), false, *x as i128, false)
            }
            Self::ReportingGranularitykminus1AdditionalPath(x) => {
                encode::encode_choice_idx(data, 0, 6, false, 6, false)?;
                encode::encode_integer(data, Some(0), Some(65535), false, 808, false)?;
                Criticality::Ignore.encode(data)?;
                let ie = &mut Allocator::new_codec_data();
                x.encode(ie)?;
                encode::encode_length_determinent(data, None, None, false, ie.length_in_bytes())?;
                Ok(data.append_aligned(ie))
            }
            Self::ReportingGranularitykminus2AdditionalPath(x) => {
                encode::encode_choice_idx(data, 0, 6, false, 6, false)?;
                encode::encode_integer(data, Some(0), Some(65535), false, 809, false)?;
                Criticality::Ignore.encode(data)?;
                let ie = &mut Allocator::new_codec_data();
                x.encode(ie)?;
                encode::encode_length_determinent(data, None, None, false, ie.length_in_bytes())?;
                Ok(data.append_aligned(ie))
            }
            Self::ReportingGranularitykminus3AdditionalPath(x) => {
                encode::encode_choice_idx(data, 0, 6, false, 6, false)?;
                encode::encode_integer(data, Some(0), Some(65535), false, 825, false)?;
                Criticality::Ignore.encode(data)?;
                let ie = &mut Allocator::new_codec_data();
                x.encode(ie)?;
                encode::encode_length_determinent(data, None, None, false, ie.length_in_bytes())?;
                Ok(data.append_aligned(ie))
            }
            Self::ReportingGranularitykminus4AdditionalPath(x) => {
                encode::encode_choice_idx(data, 0, 6, false, 6, false)?;
                encode::encode_integer(data, Some(0), Some(65535), false, 826, false)?;
                Criticality::Ignore.encode(data)?;
                let ie = &mut Allocator::new_codec_data();
                x.encode(ie)?;
                encode::encode_length_determinent(data, None, None, false, ie.length_in_bytes())?;
                Ok(data.append_aligned(ie))
            }
            Self::ReportingGranularitykminus5AdditionalPath(x) => {
                encode::encode_choice_idx(data, 0, 6, false, 6, false)?;
                encode::encode_integer(data, Some(0), Some(65535), false, 827, false)?;
                Criticality::Ignore.encode(data)?;
                let ie = &mut Allocator::new_codec_data();
                x.encode(ie)?;
                encode::encode_length_determinent(data, None, None, false, ie.length_in_bytes())?;
                Ok(data.append_aligned(ie))
            }
            Self::ReportingGranularitykminus6AdditionalPath(x) => {
                encode::encode_choice_idx(data, 0, 6, false, 6, false)?;
                encode::encode_integer(data, Some(0), Some(65535), false, 828, false)?;
                Criticality::Ignore.encode(data)?;
                let ie = &mut Allocator::new_codec_data();
                x.encode(ie)?;
                encode::encode_length_determinent(data, None, None, false, ie.length_in_bytes())?;
                Ok(data.append_aligned(ie))
            }
        }
    }
}

impl PerCodec for RelativePathDelay {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        RelativePathDelay::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("RelativePathDelay");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("RelativePathDelay");
            e
        })
    }
}
// ParentIabNodesNaResourceConfigurationList
#[derive(Clone, Debug)]
pub struct ParentIabNodesNaResourceConfigurationList(
    pub NonEmpty<ParentIabNodesNaResourceConfigurationItem>,
);

impl ParentIabNodesNaResourceConfigurationList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(5120), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(ParentIabNodesNaResourceConfigurationItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(5120), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for ParentIabNodesNaResourceConfigurationList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        ParentIabNodesNaResourceConfigurationList::decode_inner(data).map_err(
            |mut e: PerCodecError| {
                e.push_context("ParentIabNodesNaResourceConfigurationList");
                e
            },
        )
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ParentIabNodesNaResourceConfigurationList");
            e
        })
    }
}
// ParentIabNodesNaResourceConfigurationItem
#[derive(Clone, Debug)]
pub struct ParentIabNodesNaResourceConfigurationItem {
    pub na_downlink: Option<NaDownlink>,
    pub na_uplink: Option<NaUplink>,
    pub na_flexible: Option<NaFlexible>,
}

impl ParentIabNodesNaResourceConfigurationItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, false, 4)?;
        let na_downlink = if optionals[0] {
            Some(NaDownlink::decode(data)?)
        } else {
            None
        };
        let na_uplink = if optionals[1] {
            Some(NaUplink::decode(data)?)
        } else {
            None
        };
        let na_flexible = if optionals[2] {
            Some(NaFlexible::decode(data)?)
        } else {
            None
        };

        // Process the extension container

        if optionals[3] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            na_downlink,
            na_uplink,
            na_flexible,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.na_downlink.is_some());
        optionals.push(self.na_uplink.is_some());
        optionals.push(self.na_flexible.is_some());
        optionals.push(false);

        encode::encode_sequence_header(data, false, &optionals, false)?;
        if let Some(x) = &self.na_downlink {
            x.encode(data)?;
        }
        if let Some(x) = &self.na_uplink {
            x.encode(data)?;
        }
        if let Some(x) = &self.na_flexible {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl PerCodec for ParentIabNodesNaResourceConfigurationItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        ParentIabNodesNaResourceConfigurationItem::decode_inner(data).map_err(
            |mut e: PerCodecError| {
                e.push_context("ParentIabNodesNaResourceConfigurationItem");
                e
            },
        )
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ParentIabNodesNaResourceConfigurationItem");
            e
        })
    }
}
// PartialSuccessCell
#[derive(Clone, Debug)]
pub struct PartialSuccessCell {
    pub broadcast_cell_list: BroadcastCellList,
}

impl PartialSuccessCell {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let broadcast_cell_list = BroadcastCellList::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            broadcast_cell_list,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.broadcast_cell_list.encode(data)?;

        Ok(())
    }
}

impl PerCodec for PartialSuccessCell {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PartialSuccessCell::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PartialSuccessCell");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PartialSuccessCell");
            e
        })
    }
}
// PathlossReferenceInfo
#[derive(Clone, Debug)]
pub struct PathlossReferenceInfo {
    pub pathloss_reference_signal: PathlossReferenceSignal,
}

impl PathlossReferenceInfo {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, false, 1)?;
        let pathloss_reference_signal = PathlossReferenceSignal::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            pathloss_reference_signal,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, false, &optionals, false)?;
        self.pathloss_reference_signal.encode(data)?;

        Ok(())
    }
}

impl PerCodec for PathlossReferenceInfo {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PathlossReferenceInfo::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PathlossReferenceInfo");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PathlossReferenceInfo");
            e
        })
    }
}
// PathlossReferenceSignal
#[derive(Clone, Debug)]
pub enum PathlossReferenceSignal {
    Ssb(Ssb),
    DlPrs(DlPrs),
}

impl PathlossReferenceSignal {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_choice_idx(data, 0, 2, false)?;
        if extended {
            return Err(per_codec_error_new("CHOICE additions not implemented"));
        }
        match idx {
            0 => Ok(Self::Ssb(Ssb::decode(data)?)),
            1 => Ok(Self::DlPrs(DlPrs::decode(data)?)),
            2 => {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _ = Criticality::decode(data)?;
                let _ = decode::decode_length_determinent(data, None, None, false)?;
                let result = match id {
                    x => Err(per_codec_error_new(format!("Unrecognised IE type {}", x))),
                };
                data.decode_align()?;
                result
            }
            _ => Err(per_codec_error_new("Unknown choice idx")),
        }
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        match self {
            Self::Ssb(x) => {
                encode::encode_choice_idx(data, 0, 2, false, 0, false)?;
                x.encode(data)
            }
            Self::DlPrs(x) => {
                encode::encode_choice_idx(data, 0, 2, false, 1, false)?;
                x.encode(data)
            }
        }
    }
}

impl PerCodec for PathlossReferenceSignal {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PathlossReferenceSignal::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PathlossReferenceSignal");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PathlossReferenceSignal");
            e
        })
    }
}
// PathSwitchConfiguration
#[derive(Clone, Debug)]
pub struct PathSwitchConfiguration {
    pub target_relay_ue_id: BitString,
    pub remote_ue_local_id: RemoteUeLocalId,
    pub t420: T420,
}

impl PathSwitchConfiguration {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let target_relay_ue_id = decode::decode_bitstring(data, Some(24), Some(24), false)?;
        let remote_ue_local_id = RemoteUeLocalId::decode(data)?;
        let t420 = T420::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            target_relay_ue_id,
            remote_ue_local_id,
            t420,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        encode::encode_bitstring(
            data,
            Some(24),
            Some(24),
            false,
            &self.target_relay_ue_id,
            false,
        )?;
        self.remote_ue_local_id.encode(data)?;
        self.t420.encode(data)?;

        Ok(())
    }
}

impl PerCodec for PathSwitchConfiguration {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PathSwitchConfiguration::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PathSwitchConfiguration");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PathSwitchConfiguration");
            e
        })
    }
}
// Pc5QosFlowIdentifier
#[derive(Clone, Copy, Debug)]
pub struct Pc5QosFlowIdentifier(pub u16);

impl Pc5QosFlowIdentifier {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(
            decode::decode_integer(data, Some(1), Some(2048), false)?.0 as u16,
        ))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_integer(data, Some(1), Some(2048), false, self.0 as i128, false)
    }
}

impl PerCodec for Pc5QosFlowIdentifier {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Pc5QosFlowIdentifier::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("Pc5QosFlowIdentifier");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("Pc5QosFlowIdentifier");
            e
        })
    }
}
// Pc5QosCharacteristics
#[derive(Clone, Debug)]
pub enum Pc5QosCharacteristics {
    NonDynamicPqi(NonDynamicPqiDescriptor),
    DynamicPqi(DynamicPqiDescriptor),
}

impl Pc5QosCharacteristics {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_choice_idx(data, 0, 2, false)?;
        if extended {
            return Err(per_codec_error_new("CHOICE additions not implemented"));
        }
        match idx {
            0 => Ok(Self::NonDynamicPqi(NonDynamicPqiDescriptor::decode(data)?)),
            1 => Ok(Self::DynamicPqi(DynamicPqiDescriptor::decode(data)?)),
            2 => {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _ = Criticality::decode(data)?;
                let _ = decode::decode_length_determinent(data, None, None, false)?;
                let result = match id {
                    x => Err(per_codec_error_new(format!("Unrecognised IE type {}", x))),
                };
                data.decode_align()?;
                result
            }
            _ => Err(per_codec_error_new("Unknown choice idx")),
        }
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        match self {
            Self::NonDynamicPqi(x) => {
                encode::encode_choice_idx(data, 0, 2, false, 0, false)?;
                x.encode(data)
            }
            Self::DynamicPqi(x) => {
                encode::encode_choice_idx(data, 0, 2, false, 1, false)?;
                x.encode(data)
            }
        }
    }
}

impl PerCodec for Pc5QosCharacteristics {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Pc5QosCharacteristics::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("Pc5QosCharacteristics");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("Pc5QosCharacteristics");
            e
        })
    }
}
// Pc5QosParameters
#[derive(Clone, Debug)]
pub struct Pc5QosParameters {
    pub pc5_qos_characteristics: Pc5QosCharacteristics,
    pub pc5_qos_flow_bit_rates: Option<Pc5FlowBitRates>,
}

impl Pc5QosParameters {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 2)?;
        let pc5_qos_characteristics = Pc5QosCharacteristics::decode(data)?;
        let pc5_qos_flow_bit_rates = if optionals[0] {
            Some(Pc5FlowBitRates::decode(data)?)
        } else {
            None
        };

        // Process the extension container

        if optionals[1] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            pc5_qos_characteristics,
            pc5_qos_flow_bit_rates,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.pc5_qos_flow_bit_rates.is_some());
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.pc5_qos_characteristics.encode(data)?;
        if let Some(x) = &self.pc5_qos_flow_bit_rates {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl PerCodec for Pc5QosParameters {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Pc5QosParameters::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("Pc5QosParameters");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("Pc5QosParameters");
            e
        })
    }
}
// Pc5FlowBitRates
#[derive(Clone, Debug)]
pub struct Pc5FlowBitRates {
    pub guaranteed_flow_bit_rate: BitRate,
    pub maximum_flow_bit_rate: BitRate,
}

impl Pc5FlowBitRates {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let guaranteed_flow_bit_rate = BitRate::decode(data)?;
        let maximum_flow_bit_rate = BitRate::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            guaranteed_flow_bit_rate,
            maximum_flow_bit_rate,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.guaranteed_flow_bit_rate.encode(data)?;
        self.maximum_flow_bit_rate.encode(data)?;

        Ok(())
    }
}

impl PerCodec for Pc5FlowBitRates {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Pc5FlowBitRates::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("Pc5FlowBitRates");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("Pc5FlowBitRates");
            e
        })
    }
}
// Pc5rlcChannelId
#[derive(Clone, Copy, Debug)]
pub struct Pc5rlcChannelId(pub u16);

impl Pc5rlcChannelId {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(
            decode::decode_integer(data, Some(1), Some(512), true)?.0 as u16,
        ))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_integer(data, Some(1), Some(512), true, self.0 as i128, false)
    }
}

impl PerCodec for Pc5rlcChannelId {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Pc5rlcChannelId::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("Pc5rlcChannelId");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("Pc5rlcChannelId");
            e
        })
    }
}
// Pc5rlcChannelQosInformation
#[derive(Clone, Debug)]
pub enum Pc5rlcChannelQosInformation {
    Pc5rlcChannelQos(QosFlowLevelQosParameters),
    Pc5ControlPlaneTrafficType(Pc5ControlPlaneTrafficType),
    Pc5QosParameters(Pc5QosParameters),
}

impl Pc5rlcChannelQosInformation {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_choice_idx(data, 0, 2, false)?;
        if extended {
            return Err(per_codec_error_new("CHOICE additions not implemented"));
        }
        match idx {
            0 => Ok(Self::Pc5rlcChannelQos(QosFlowLevelQosParameters::decode(
                data,
            )?)),
            1 => Ok(Self::Pc5ControlPlaneTrafficType(
                Pc5ControlPlaneTrafficType::decode(data)?,
            )),
            2 => {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _ = Criticality::decode(data)?;
                let _ = decode::decode_length_determinent(data, None, None, false)?;
                let result = match id {
                    799 => Ok(Self::Pc5QosParameters(Pc5QosParameters::decode(data)?)),
                    x => Err(per_codec_error_new(format!("Unrecognised IE type {}", x))),
                };
                data.decode_align()?;
                result
            }
            _ => Err(per_codec_error_new("Unknown choice idx")),
        }
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        match self {
            Self::Pc5rlcChannelQos(x) => {
                encode::encode_choice_idx(data, 0, 2, false, 0, false)?;
                x.encode(data)
            }
            Self::Pc5ControlPlaneTrafficType(x) => {
                encode::encode_choice_idx(data, 0, 2, false, 1, false)?;
                x.encode(data)
            }
            Self::Pc5QosParameters(x) => {
                encode::encode_choice_idx(data, 0, 2, false, 2, false)?;
                encode::encode_integer(data, Some(0), Some(65535), false, 799, false)?;
                Criticality::Reject.encode(data)?;
                let ie = &mut Allocator::new_codec_data();
                x.encode(ie)?;
                encode::encode_length_determinent(data, None, None, false, ie.length_in_bytes())?;
                Ok(data.append_aligned(ie))
            }
        }
    }
}

impl PerCodec for Pc5rlcChannelQosInformation {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Pc5rlcChannelQosInformation::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("Pc5rlcChannelQosInformation");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("Pc5rlcChannelQosInformation");
            e
        })
    }
}
// Pc5rlcChannelToBeSetupList
#[derive(Clone, Debug)]
pub struct Pc5rlcChannelToBeSetupList(pub NonEmpty<Pc5rlcChannelToBeSetupItem>);

impl Pc5rlcChannelToBeSetupList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(512), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(Pc5rlcChannelToBeSetupItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(512), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for Pc5rlcChannelToBeSetupList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Pc5rlcChannelToBeSetupList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("Pc5rlcChannelToBeSetupList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("Pc5rlcChannelToBeSetupList");
            e
        })
    }
}
// Pc5rlcChannelToBeSetupItem
#[derive(Clone, Debug)]
pub struct Pc5rlcChannelToBeSetupItem {
    pub pc5rlc_channel_id: Pc5rlcChannelId,
    pub remote_ue_local_id: Option<RemoteUeLocalId>,
    pub pc5rlc_channel_qos_information: Pc5rlcChannelQosInformation,
    pub rlc_mode: RlcMode,
    pub peer_ue_id: Option<BitString>,
}

impl Pc5rlcChannelToBeSetupItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 2)?;
        let pc5rlc_channel_id = Pc5rlcChannelId::decode(data)?;
        let remote_ue_local_id = if optionals[0] {
            Some(RemoteUeLocalId::decode(data)?)
        } else {
            None
        };
        let pc5rlc_channel_qos_information = Pc5rlcChannelQosInformation::decode(data)?;
        let rlc_mode = RlcMode::decode(data)?;

        // Process the extension container
        let mut peer_ue_id: Option<BitString> = None;

        if optionals[1] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    842 => {
                        peer_ue_id =
                            Some(decode::decode_bitstring(data, Some(24), Some(24), false)?)
                    }
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            pc5rlc_channel_id,
            remote_ue_local_id,
            pc5rlc_channel_qos_information,
            rlc_mode,
            peer_ue_id,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();
        if let Some(x) = &self.peer_ue_id {
            let ie = &mut Allocator::new_codec_data();
            encode::encode_bitstring(ie, Some(24), Some(24), false, &x, false)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 842, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        let mut optionals = BitString::new();
        optionals.push(self.remote_ue_local_id.is_some());
        optionals.push(num_ies != 0);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.pc5rlc_channel_id.encode(data)?;
        if let Some(x) = &self.remote_ue_local_id {
            x.encode(data)?;
        }
        self.pc5rlc_channel_qos_information.encode(data)?;
        self.rlc_mode.encode(data)?;
        if num_ies != 0 {
            encode::encode_length_determinent(data, Some(1), Some(65535), false, num_ies)?;
            data.append_aligned(ies);
        }
        Ok(())
    }
}

impl PerCodec for Pc5rlcChannelToBeSetupItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Pc5rlcChannelToBeSetupItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("Pc5rlcChannelToBeSetupItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("Pc5rlcChannelToBeSetupItem");
            e
        })
    }
}
// Pc5rlcChannelToBeModifiedList
#[derive(Clone, Debug)]
pub struct Pc5rlcChannelToBeModifiedList(pub NonEmpty<Pc5rlcChannelToBeModifiedItem>);

impl Pc5rlcChannelToBeModifiedList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(512), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(Pc5rlcChannelToBeModifiedItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(512), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for Pc5rlcChannelToBeModifiedList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Pc5rlcChannelToBeModifiedList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("Pc5rlcChannelToBeModifiedList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("Pc5rlcChannelToBeModifiedList");
            e
        })
    }
}
// Pc5rlcChannelToBeModifiedItem
#[derive(Clone, Debug)]
pub struct Pc5rlcChannelToBeModifiedItem {
    pub pc5rlc_channel_id: Pc5rlcChannelId,
    pub remote_ue_local_id: Option<RemoteUeLocalId>,
    pub pc5rlc_channel_qos_information: Option<Pc5rlcChannelQosInformation>,
    pub rlc_mode: Option<RlcMode>,
}

impl Pc5rlcChannelToBeModifiedItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 4)?;
        let pc5rlc_channel_id = Pc5rlcChannelId::decode(data)?;
        let remote_ue_local_id = if optionals[0] {
            Some(RemoteUeLocalId::decode(data)?)
        } else {
            None
        };
        let pc5rlc_channel_qos_information = if optionals[1] {
            Some(Pc5rlcChannelQosInformation::decode(data)?)
        } else {
            None
        };
        let rlc_mode = if optionals[2] {
            Some(RlcMode::decode(data)?)
        } else {
            None
        };

        // Process the extension container

        if optionals[3] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            pc5rlc_channel_id,
            remote_ue_local_id,
            pc5rlc_channel_qos_information,
            rlc_mode,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.remote_ue_local_id.is_some());
        optionals.push(self.pc5rlc_channel_qos_information.is_some());
        optionals.push(self.rlc_mode.is_some());
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.pc5rlc_channel_id.encode(data)?;
        if let Some(x) = &self.remote_ue_local_id {
            x.encode(data)?;
        }
        if let Some(x) = &self.pc5rlc_channel_qos_information {
            x.encode(data)?;
        }
        if let Some(x) = &self.rlc_mode {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl PerCodec for Pc5rlcChannelToBeModifiedItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Pc5rlcChannelToBeModifiedItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("Pc5rlcChannelToBeModifiedItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("Pc5rlcChannelToBeModifiedItem");
            e
        })
    }
}
// Pc5rlcChannelToBeReleasedList
#[derive(Clone, Debug)]
pub struct Pc5rlcChannelToBeReleasedList(pub NonEmpty<Pc5rlcChannelToBeReleasedItem>);

impl Pc5rlcChannelToBeReleasedList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(512), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(Pc5rlcChannelToBeReleasedItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(512), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for Pc5rlcChannelToBeReleasedList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Pc5rlcChannelToBeReleasedList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("Pc5rlcChannelToBeReleasedList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("Pc5rlcChannelToBeReleasedList");
            e
        })
    }
}
// Pc5rlcChannelToBeReleasedItem
#[derive(Clone, Debug)]
pub struct Pc5rlcChannelToBeReleasedItem {
    pub pc5rlc_channel_id: Pc5rlcChannelId,
    pub remote_ue_local_id: Option<RemoteUeLocalId>,
}

impl Pc5rlcChannelToBeReleasedItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 2)?;
        let pc5rlc_channel_id = Pc5rlcChannelId::decode(data)?;
        let remote_ue_local_id = if optionals[0] {
            Some(RemoteUeLocalId::decode(data)?)
        } else {
            None
        };

        // Process the extension container

        if optionals[1] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            pc5rlc_channel_id,
            remote_ue_local_id,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.remote_ue_local_id.is_some());
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.pc5rlc_channel_id.encode(data)?;
        if let Some(x) = &self.remote_ue_local_id {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl PerCodec for Pc5rlcChannelToBeReleasedItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Pc5rlcChannelToBeReleasedItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("Pc5rlcChannelToBeReleasedItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("Pc5rlcChannelToBeReleasedItem");
            e
        })
    }
}
// Pc5rlcChannelSetupList
#[derive(Clone, Debug)]
pub struct Pc5rlcChannelSetupList(pub NonEmpty<Pc5rlcChannelSetupItem>);

impl Pc5rlcChannelSetupList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(512), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(Pc5rlcChannelSetupItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(512), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for Pc5rlcChannelSetupList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Pc5rlcChannelSetupList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("Pc5rlcChannelSetupList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("Pc5rlcChannelSetupList");
            e
        })
    }
}
// Pc5rlcChannelSetupItem
#[derive(Clone, Debug)]
pub struct Pc5rlcChannelSetupItem {
    pub pc5rlc_channel_id: Pc5rlcChannelId,
    pub remote_ue_local_id: Option<RemoteUeLocalId>,
}

impl Pc5rlcChannelSetupItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 2)?;
        let pc5rlc_channel_id = Pc5rlcChannelId::decode(data)?;
        let remote_ue_local_id = if optionals[0] {
            Some(RemoteUeLocalId::decode(data)?)
        } else {
            None
        };

        // Process the extension container

        if optionals[1] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            pc5rlc_channel_id,
            remote_ue_local_id,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.remote_ue_local_id.is_some());
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.pc5rlc_channel_id.encode(data)?;
        if let Some(x) = &self.remote_ue_local_id {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl PerCodec for Pc5rlcChannelSetupItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Pc5rlcChannelSetupItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("Pc5rlcChannelSetupItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("Pc5rlcChannelSetupItem");
            e
        })
    }
}
// Pc5rlcChannelFailedToBeSetupList
#[derive(Clone, Debug)]
pub struct Pc5rlcChannelFailedToBeSetupList(pub NonEmpty<Pc5rlcChannelFailedToBeSetupItem>);

impl Pc5rlcChannelFailedToBeSetupList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(512), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(Pc5rlcChannelFailedToBeSetupItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(512), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for Pc5rlcChannelFailedToBeSetupList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Pc5rlcChannelFailedToBeSetupList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("Pc5rlcChannelFailedToBeSetupList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("Pc5rlcChannelFailedToBeSetupList");
            e
        })
    }
}
// Pc5rlcChannelFailedToBeSetupItem
#[derive(Clone, Debug)]
pub struct Pc5rlcChannelFailedToBeSetupItem {
    pub pc5rlc_channel_id: Pc5rlcChannelId,
    pub remote_ue_local_id: Option<RemoteUeLocalId>,
    pub cause: Option<Cause>,
}

impl Pc5rlcChannelFailedToBeSetupItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 3)?;
        let pc5rlc_channel_id = Pc5rlcChannelId::decode(data)?;
        let remote_ue_local_id = if optionals[0] {
            Some(RemoteUeLocalId::decode(data)?)
        } else {
            None
        };
        let cause = if optionals[1] {
            Some(Cause::decode(data)?)
        } else {
            None
        };

        // Process the extension container

        if optionals[2] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            pc5rlc_channel_id,
            remote_ue_local_id,
            cause,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.remote_ue_local_id.is_some());
        optionals.push(self.cause.is_some());
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.pc5rlc_channel_id.encode(data)?;
        if let Some(x) = &self.remote_ue_local_id {
            x.encode(data)?;
        }
        if let Some(x) = &self.cause {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl PerCodec for Pc5rlcChannelFailedToBeSetupItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Pc5rlcChannelFailedToBeSetupItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("Pc5rlcChannelFailedToBeSetupItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("Pc5rlcChannelFailedToBeSetupItem");
            e
        })
    }
}
// Pc5rlcChannelModifiedList
#[derive(Clone, Debug)]
pub struct Pc5rlcChannelModifiedList(pub NonEmpty<Pc5rlcChannelModifiedItem>);

impl Pc5rlcChannelModifiedList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(512), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(Pc5rlcChannelModifiedItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(512), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for Pc5rlcChannelModifiedList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Pc5rlcChannelModifiedList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("Pc5rlcChannelModifiedList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("Pc5rlcChannelModifiedList");
            e
        })
    }
}
// Pc5rlcChannelModifiedItem
#[derive(Clone, Debug)]
pub struct Pc5rlcChannelModifiedItem {
    pub pc5rlc_channel_id: Pc5rlcChannelId,
    pub remote_ue_local_id: Option<RemoteUeLocalId>,
}

impl Pc5rlcChannelModifiedItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 2)?;
        let pc5rlc_channel_id = Pc5rlcChannelId::decode(data)?;
        let remote_ue_local_id = if optionals[0] {
            Some(RemoteUeLocalId::decode(data)?)
        } else {
            None
        };

        // Process the extension container

        if optionals[1] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            pc5rlc_channel_id,
            remote_ue_local_id,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.remote_ue_local_id.is_some());
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.pc5rlc_channel_id.encode(data)?;
        if let Some(x) = &self.remote_ue_local_id {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl PerCodec for Pc5rlcChannelModifiedItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Pc5rlcChannelModifiedItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("Pc5rlcChannelModifiedItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("Pc5rlcChannelModifiedItem");
            e
        })
    }
}
// Pc5rlcChannelFailedToBeModifiedList
#[derive(Clone, Debug)]
pub struct Pc5rlcChannelFailedToBeModifiedList(pub NonEmpty<Pc5rlcChannelFailedToBeModifiedItem>);

impl Pc5rlcChannelFailedToBeModifiedList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(512), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(Pc5rlcChannelFailedToBeModifiedItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(512), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for Pc5rlcChannelFailedToBeModifiedList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Pc5rlcChannelFailedToBeModifiedList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("Pc5rlcChannelFailedToBeModifiedList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("Pc5rlcChannelFailedToBeModifiedList");
            e
        })
    }
}
// Pc5rlcChannelFailedToBeModifiedItem
#[derive(Clone, Debug)]
pub struct Pc5rlcChannelFailedToBeModifiedItem {
    pub pc5rlc_channel_id: Pc5rlcChannelId,
    pub remote_ue_local_id: Option<RemoteUeLocalId>,
    pub cause: Option<Cause>,
}

impl Pc5rlcChannelFailedToBeModifiedItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 3)?;
        let pc5rlc_channel_id = Pc5rlcChannelId::decode(data)?;
        let remote_ue_local_id = if optionals[0] {
            Some(RemoteUeLocalId::decode(data)?)
        } else {
            None
        };
        let cause = if optionals[1] {
            Some(Cause::decode(data)?)
        } else {
            None
        };

        // Process the extension container

        if optionals[2] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            pc5rlc_channel_id,
            remote_ue_local_id,
            cause,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.remote_ue_local_id.is_some());
        optionals.push(self.cause.is_some());
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.pc5rlc_channel_id.encode(data)?;
        if let Some(x) = &self.remote_ue_local_id {
            x.encode(data)?;
        }
        if let Some(x) = &self.cause {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl PerCodec for Pc5rlcChannelFailedToBeModifiedItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Pc5rlcChannelFailedToBeModifiedItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("Pc5rlcChannelFailedToBeModifiedItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("Pc5rlcChannelFailedToBeModifiedItem");
            e
        })
    }
}
// Pc5rlcChannelRequiredToBeModifiedList
#[derive(Clone, Debug)]
pub struct Pc5rlcChannelRequiredToBeModifiedList(
    pub NonEmpty<Pc5rlcChannelRequiredToBeModifiedItem>,
);

impl Pc5rlcChannelRequiredToBeModifiedList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(512), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(Pc5rlcChannelRequiredToBeModifiedItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(512), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for Pc5rlcChannelRequiredToBeModifiedList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Pc5rlcChannelRequiredToBeModifiedList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("Pc5rlcChannelRequiredToBeModifiedList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("Pc5rlcChannelRequiredToBeModifiedList");
            e
        })
    }
}
// Pc5rlcChannelRequiredToBeModifiedItem
#[derive(Clone, Debug)]
pub struct Pc5rlcChannelRequiredToBeModifiedItem {
    pub pc5rlc_channel_id: Pc5rlcChannelId,
    pub remote_ue_local_id: Option<RemoteUeLocalId>,
}

impl Pc5rlcChannelRequiredToBeModifiedItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 2)?;
        let pc5rlc_channel_id = Pc5rlcChannelId::decode(data)?;
        let remote_ue_local_id = if optionals[0] {
            Some(RemoteUeLocalId::decode(data)?)
        } else {
            None
        };

        // Process the extension container

        if optionals[1] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            pc5rlc_channel_id,
            remote_ue_local_id,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.remote_ue_local_id.is_some());
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.pc5rlc_channel_id.encode(data)?;
        if let Some(x) = &self.remote_ue_local_id {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl PerCodec for Pc5rlcChannelRequiredToBeModifiedItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Pc5rlcChannelRequiredToBeModifiedItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("Pc5rlcChannelRequiredToBeModifiedItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("Pc5rlcChannelRequiredToBeModifiedItem");
            e
        })
    }
}
// Pc5rlcChannelRequiredToBeReleasedList
#[derive(Clone, Debug)]
pub struct Pc5rlcChannelRequiredToBeReleasedList(
    pub NonEmpty<Pc5rlcChannelRequiredToBeReleasedItem>,
);

impl Pc5rlcChannelRequiredToBeReleasedList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(512), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(Pc5rlcChannelRequiredToBeReleasedItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(512), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for Pc5rlcChannelRequiredToBeReleasedList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Pc5rlcChannelRequiredToBeReleasedList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("Pc5rlcChannelRequiredToBeReleasedList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("Pc5rlcChannelRequiredToBeReleasedList");
            e
        })
    }
}
// Pc5rlcChannelRequiredToBeReleasedItem
#[derive(Clone, Debug)]
pub struct Pc5rlcChannelRequiredToBeReleasedItem {
    pub pc5rlc_channel_id: Pc5rlcChannelId,
    pub remote_ue_local_id: Option<RemoteUeLocalId>,
}

impl Pc5rlcChannelRequiredToBeReleasedItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 2)?;
        let pc5rlc_channel_id = Pc5rlcChannelId::decode(data)?;
        let remote_ue_local_id = if optionals[0] {
            Some(RemoteUeLocalId::decode(data)?)
        } else {
            None
        };

        // Process the extension container

        if optionals[1] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            pc5rlc_channel_id,
            remote_ue_local_id,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.remote_ue_local_id.is_some());
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.pc5rlc_channel_id.encode(data)?;
        if let Some(x) = &self.remote_ue_local_id {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl PerCodec for Pc5rlcChannelRequiredToBeReleasedItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Pc5rlcChannelRequiredToBeReleasedItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("Pc5rlcChannelRequiredToBeReleasedItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("Pc5rlcChannelRequiredToBeReleasedItem");
            e
        })
    }
}
// PdcchBlindDetectionScg
#[derive(Clone, Debug)]
pub struct PdcchBlindDetectionScg(pub Vec<u8>);

impl PdcchBlindDetectionScg {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(decode::decode_octetstring(data, None, None, false)?))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_octetstring(data, None, None, false, &self.0, false)
    }
}

impl PerCodec for PdcchBlindDetectionScg {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PdcchBlindDetectionScg::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PdcchBlindDetectionScg");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PdcchBlindDetectionScg");
            e
        })
    }
}
// PdcMeasurementPeriodicity
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum PdcMeasurementPeriodicity {
    Ms80,
    Ms120,
    Ms160,
    Ms240,
    Ms320,
    Ms480,
    Ms640,
    Ms1024,
    Ms1280,
    Ms2048,
    Ms2560,
    Ms5120,
}

impl PdcMeasurementPeriodicity {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(11), true)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(11),
            true,
            *self as i128,
            (*self as u32) >= 12,
        )
    }
}

impl PerCodec for PdcMeasurementPeriodicity {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PdcMeasurementPeriodicity::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PdcMeasurementPeriodicity");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PdcMeasurementPeriodicity");
            e
        })
    }
}
// PdcMeasurementQuantities
#[derive(Clone, Debug)]
pub struct PdcMeasurementQuantities(pub NonEmpty<PdcMeasurementQuantitiesItem>);

impl PdcMeasurementQuantities {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(16), false)?;
            let mut items = vec![];
            for _ in 0..length {
                let _ = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _ = Criticality::decode(data)?;
                let _ = decode::decode_length_determinent(data, None, None, false)?;
                items.push(PdcMeasurementQuantitiesItem::decode(data)?);
                data.decode_align()?;
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(16), false, self.0.len())?;
        for x in &self.0 {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(data, Some(0), Some(65535), false, 543, false)?;
            Criticality::Reject.encode(data)?;
            encode::encode_length_determinent(data, None, None, false, ie.length_in_bytes())?;
            data.append_aligned(ie);
        }
        Ok(())
    }
}

impl PerCodec for PdcMeasurementQuantities {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PdcMeasurementQuantities::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PdcMeasurementQuantities");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PdcMeasurementQuantities");
            e
        })
    }
}
// PdcMeasurementQuantitiesItem
#[derive(Clone, Debug)]
pub struct PdcMeasurementQuantitiesItem {
    pub pd_cmeasurement_quantities_value: PdcMeasurementQuantitiesValue,
}

impl PdcMeasurementQuantitiesItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, false, 1)?;
        let pd_cmeasurement_quantities_value = PdcMeasurementQuantitiesValue::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            pd_cmeasurement_quantities_value,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, false, &optionals, false)?;
        self.pd_cmeasurement_quantities_value.encode(data)?;

        Ok(())
    }
}

impl PerCodec for PdcMeasurementQuantitiesItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PdcMeasurementQuantitiesItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PdcMeasurementQuantitiesItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PdcMeasurementQuantitiesItem");
            e
        })
    }
}
// PdcMeasurementQuantitiesValue
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum PdcMeasurementQuantitiesValue {
    NrPdcTadv,
    GnbRxTx,
}

impl PdcMeasurementQuantitiesValue {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(1), true)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(1),
            true,
            *self as i128,
            (*self as u32) >= 2,
        )
    }
}

impl PerCodec for PdcMeasurementQuantitiesValue {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PdcMeasurementQuantitiesValue::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PdcMeasurementQuantitiesValue");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PdcMeasurementQuantitiesValue");
            e
        })
    }
}
// PdcMeasurementResult
#[derive(Clone, Debug)]
pub struct PdcMeasurementResult {
    pub pdc_measured_results_list: PdcMeasuredResultsList,
}

impl PdcMeasurementResult {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, false, 1)?;
        let pdc_measured_results_list = PdcMeasuredResultsList::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            pdc_measured_results_list,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, false, &optionals, false)?;
        self.pdc_measured_results_list.encode(data)?;

        Ok(())
    }
}

impl PerCodec for PdcMeasurementResult {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PdcMeasurementResult::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PdcMeasurementResult");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PdcMeasurementResult");
            e
        })
    }
}
// PdcMeasuredResultsList
#[derive(Clone, Debug)]
pub struct PdcMeasuredResultsList(pub NonEmpty<PdcMeasuredResultsItem>);

impl PdcMeasuredResultsList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(16), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(PdcMeasuredResultsItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(16), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for PdcMeasuredResultsList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PdcMeasuredResultsList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PdcMeasuredResultsList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PdcMeasuredResultsList");
            e
        })
    }
}
// PdcMeasuredResultsItem
#[derive(Clone, Debug)]
pub struct PdcMeasuredResultsItem {
    pub pdc_measured_results_value: PdcMeasuredResultsValue,
}

impl PdcMeasuredResultsItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, false, 1)?;
        let pdc_measured_results_value = PdcMeasuredResultsValue::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            pdc_measured_results_value,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, false, &optionals, false)?;
        self.pdc_measured_results_value.encode(data)?;

        Ok(())
    }
}

impl PerCodec for PdcMeasuredResultsItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PdcMeasuredResultsItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PdcMeasuredResultsItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PdcMeasuredResultsItem");
            e
        })
    }
}
// PdcMeasuredResultsValue
#[derive(Clone, Debug)]
pub enum PdcMeasuredResultsValue {
    PdcTadvNr(PdcTadvNr),
    PdcRxTxTimeDiff(PdcRxTxTimeDiff),
}

impl PdcMeasuredResultsValue {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_choice_idx(data, 0, 2, false)?;
        if extended {
            return Err(per_codec_error_new("CHOICE additions not implemented"));
        }
        match idx {
            0 => Ok(Self::PdcTadvNr(PdcTadvNr::decode(data)?)),
            1 => Ok(Self::PdcRxTxTimeDiff(PdcRxTxTimeDiff::decode(data)?)),
            2 => {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _ = Criticality::decode(data)?;
                let _ = decode::decode_length_determinent(data, None, None, false)?;
                let result = match id {
                    x => Err(per_codec_error_new(format!("Unrecognised IE type {}", x))),
                };
                data.decode_align()?;
                result
            }
            _ => Err(per_codec_error_new("Unknown choice idx")),
        }
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        match self {
            Self::PdcTadvNr(x) => {
                encode::encode_choice_idx(data, 0, 2, false, 0, false)?;
                x.encode(data)
            }
            Self::PdcRxTxTimeDiff(x) => {
                encode::encode_choice_idx(data, 0, 2, false, 1, false)?;
                x.encode(data)
            }
        }
    }
}

impl PerCodec for PdcMeasuredResultsValue {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PdcMeasuredResultsValue::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PdcMeasuredResultsValue");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PdcMeasuredResultsValue");
            e
        })
    }
}
// PdcReportType
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum PdcReportType {
    OnDemand,
    Periodic,
}

impl PdcReportType {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(1), true)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(1),
            true,
            *self as i128,
            (*self as u32) >= 2,
        )
    }
}

impl PerCodec for PdcReportType {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PdcReportType::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PdcReportType");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PdcReportType");
            e
        })
    }
}
// PdcRxTxTimeDiff
#[derive(Clone, Copy, Debug)]
pub struct PdcRxTxTimeDiff(pub u16);

impl PdcRxTxTimeDiff {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(
            decode::decode_integer(data, Some(0), Some(61565), true)?.0 as u16,
        ))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_integer(data, Some(0), Some(61565), true, self.0 as i128, false)
    }
}

impl PerCodec for PdcRxTxTimeDiff {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PdcRxTxTimeDiff::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PdcRxTxTimeDiff");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PdcRxTxTimeDiff");
            e
        })
    }
}
// PdcTadvNr
#[derive(Clone, Copy, Debug)]
pub struct PdcTadvNr(pub u16);

impl PdcTadvNr {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(
            decode::decode_integer(data, Some(0), Some(62500), true)?.0 as u16,
        ))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_integer(data, Some(0), Some(62500), true, self.0 as i128, false)
    }
}

impl PerCodec for PdcTadvNr {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PdcTadvNr::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PdcTadvNr");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PdcTadvNr");
            e
        })
    }
}
// PdcpSn
#[derive(Clone, Copy, Debug)]
pub struct PdcpSn(pub u16);

impl PdcpSn {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(
            decode::decode_integer(data, Some(0), Some(4095), false)?.0 as u16,
        ))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_integer(data, Some(0), Some(4095), false, self.0 as i128, false)
    }
}

impl PerCodec for PdcpSn {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PdcpSn::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PdcpSn");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PdcpSn");
            e
        })
    }
}
// PdcpsnLength
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum PdcpsnLength {
    TwelveBits,
    EighteenBits,
}

impl PdcpsnLength {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(1), true)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(1),
            true,
            *self as i128,
            (*self as u32) >= 2,
        )
    }
}

impl PerCodec for PdcpsnLength {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PdcpsnLength::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PdcpsnLength");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PdcpsnLength");
            e
        })
    }
}
// PeiSubgroupingSupportIndication
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum PeiSubgroupingSupportIndication {
    True,
}

impl PeiSubgroupingSupportIndication {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(0), true)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(0),
            true,
            *self as i128,
            (*self as u32) >= 1,
        )
    }
}

impl PerCodec for PeiSubgroupingSupportIndication {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PeiSubgroupingSupportIndication::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PeiSubgroupingSupportIndication");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PeiSubgroupingSupportIndication");
            e
        })
    }
}
// ReportingPeriodicityValue
#[derive(Clone, Copy, Debug)]
pub struct ReportingPeriodicityValue(pub u16);

impl ReportingPeriodicityValue {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(
            decode::decode_integer(data, Some(0), Some(512), true)?.0 as u16,
        ))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_integer(data, Some(0), Some(512), true, self.0 as i128, false)
    }
}

impl PerCodec for ReportingPeriodicityValue {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        ReportingPeriodicityValue::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ReportingPeriodicityValue");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ReportingPeriodicityValue");
            e
        })
    }
}
// Periodicity
#[derive(Clone, Copy, Debug)]
pub struct Periodicity(pub u32);

impl Periodicity {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(
            decode::decode_integer(data, Some(0), Some(640000), true)?.0 as u32,
        ))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_integer(data, Some(0), Some(640000), true, self.0 as i128, false)
    }
}

impl PerCodec for Periodicity {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Periodicity::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("Periodicity");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("Periodicity");
            e
        })
    }
}
// PeriodicitySrs
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum PeriodicitySrs {
    Ms0p125,
    Ms0p25,
    Ms0p5,
    Ms0p625,
    Ms1,
    Ms1p25,
    Ms2,
    Ms2p5,
    Ms4,
    Ms5,
    Ms8,
    Ms10,
    Ms16,
    Ms20,
    Ms32,
    Ms40,
    Ms64,
    Ms80,
    Ms160,
    Ms320,
    Ms640,
    Ms1280,
    Ms2560,
    Ms5120,
    Ms10240,
}

impl PeriodicitySrs {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(24), true)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(24),
            true,
            *self as i128,
            (*self as u32) >= 25,
        )
    }
}

impl PerCodec for PeriodicitySrs {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PeriodicitySrs::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PeriodicitySrs");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PeriodicitySrs");
            e
        })
    }
}
// PeriodicityList
#[derive(Clone, Debug)]
pub struct PeriodicityList(pub NonEmpty<PeriodicityListItem>);

impl PeriodicityList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(16), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(PeriodicityListItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(16), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for PeriodicityList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PeriodicityList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PeriodicityList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PeriodicityList");
            e
        })
    }
}
// PeriodicityListItem
#[derive(Clone, Debug)]
pub struct PeriodicityListItem {
    pub periodicity_srs: PeriodicitySrs,
}

impl PeriodicityListItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, false, 1)?;
        let periodicity_srs = PeriodicitySrs::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self { periodicity_srs })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, false, &optionals, false)?;
        self.periodicity_srs.encode(data)?;

        Ok(())
    }
}

impl PerCodec for PeriodicityListItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PeriodicityListItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PeriodicityListItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PeriodicityListItem");
            e
        })
    }
}
// PeriodicityBound
#[derive(Clone, Debug)]
pub struct PeriodicityBound {
    pub periodicity_lower_bound: Periodicity,
    pub periodicity_upper_bound: Periodicity,
}

impl PeriodicityBound {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let periodicity_lower_bound = Periodicity::decode(data)?;
        let periodicity_upper_bound = Periodicity::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            periodicity_lower_bound,
            periodicity_upper_bound,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.periodicity_lower_bound.encode(data)?;
        self.periodicity_upper_bound.encode(data)?;

        Ok(())
    }
}

impl PerCodec for PeriodicityBound {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PeriodicityBound::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PeriodicityBound");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PeriodicityBound");
            e
        })
    }
}
// AllowedPeriodicityList
#[derive(Clone, Debug)]
pub struct AllowedPeriodicityList(pub NonEmpty<Periodicity>);

impl AllowedPeriodicityList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(8), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(Periodicity::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(8), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for AllowedPeriodicityList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        AllowedPeriodicityList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("AllowedPeriodicityList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("AllowedPeriodicityList");
            e
        })
    }
}
// PeriodicityRange
#[derive(Clone, Debug)]
pub enum PeriodicityRange {
    PeriodicityBound(PeriodicityBound),
    PeriodicityList(AllowedPeriodicityList),
}

impl PeriodicityRange {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_choice_idx(data, 0, 2, false)?;
        if extended {
            return Err(per_codec_error_new("CHOICE additions not implemented"));
        }
        match idx {
            0 => Ok(Self::PeriodicityBound(PeriodicityBound::decode(data)?)),
            1 => Ok(Self::PeriodicityList(AllowedPeriodicityList::decode(data)?)),
            2 => {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _ = Criticality::decode(data)?;
                let _ = decode::decode_length_determinent(data, None, None, false)?;
                let result = match id {
                    x => Err(per_codec_error_new(format!("Unrecognised IE type {}", x))),
                };
                data.decode_align()?;
                result
            }
            _ => Err(per_codec_error_new("Unknown choice idx")),
        }
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        match self {
            Self::PeriodicityBound(x) => {
                encode::encode_choice_idx(data, 0, 2, false, 0, false)?;
                x.encode(data)
            }
            Self::PeriodicityList(x) => {
                encode::encode_choice_idx(data, 0, 2, false, 1, false)?;
                x.encode(data)
            }
        }
    }
}

impl PerCodec for PeriodicityRange {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PeriodicityRange::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PeriodicityRange");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PeriodicityRange");
            e
        })
    }
}
// Permutation
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum Permutation {
    Dfu,
    Ufd,
}

impl Permutation {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(1), true)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(1),
            true,
            *self as i128,
            (*self as u32) >= 2,
        )
    }
}

impl PerCodec for Permutation {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Permutation::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("Permutation");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("Permutation");
            e
        })
    }
}
// PhInfoMcg
#[derive(Clone, Debug)]
pub struct PhInfoMcg(pub Vec<u8>);

impl PhInfoMcg {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(decode::decode_octetstring(data, None, None, false)?))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_octetstring(data, None, None, false, &self.0, false)
    }
}

impl PerCodec for PhInfoMcg {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PhInfoMcg::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PhInfoMcg");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PhInfoMcg");
            e
        })
    }
}
// PhInfoScg
#[derive(Clone, Debug)]
pub struct PhInfoScg(pub Vec<u8>);

impl PhInfoScg {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(decode::decode_octetstring(data, None, None, false)?))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_octetstring(data, None, None, false, &self.0, false)
    }
}

impl PerCodec for PhInfoScg {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PhInfoScg::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PhInfoScg");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PhInfoScg");
            e
        })
    }
}
// PlmnIdentity
#[derive(Clone, Debug)]
pub struct PlmnIdentity(pub [u8; 3]);

impl PlmnIdentity {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(
            decode::decode_octetstring(data, Some(3), Some(3), false)?
                .try_into()
                .unwrap(),
        ))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_octetstring(data, Some(3), Some(3), false, &(self.0).into(), false)
    }
}

impl PerCodec for PlmnIdentity {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PlmnIdentity::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PlmnIdentity");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PlmnIdentity");
            e
        })
    }
}
// PlayoutDelayForMediaStartup
#[derive(Clone, Debug)]
pub struct PlayoutDelayForMediaStartup(pub Vec<u8>);

impl PlayoutDelayForMediaStartup {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(decode::decode_octetstring(data, None, None, false)?))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_octetstring(data, None, None, false, &self.0, false)
    }
}

impl PerCodec for PlayoutDelayForMediaStartup {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PlayoutDelayForMediaStartup::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PlayoutDelayForMediaStartup");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PlayoutDelayForMediaStartup");
            e
        })
    }
}
// PortNumber
#[derive(Clone, Debug)]
pub struct PortNumber(pub BitString);

impl PortNumber {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(decode::decode_bitstring(
            data,
            Some(16),
            Some(16),
            false,
        )?))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_bitstring(data, Some(16), Some(16), false, &self.0, false)
    }
}

impl PerCodec for PortNumber {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PortNumber::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PortNumber");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PortNumber");
            e
        })
    }
}
// PosAssistanceInformation
#[derive(Clone, Debug)]
pub struct PosAssistanceInformation(pub Vec<u8>);

impl PosAssistanceInformation {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(decode::decode_octetstring(data, None, None, false)?))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_octetstring(data, None, None, false, &self.0, false)
    }
}

impl PerCodec for PosAssistanceInformation {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PosAssistanceInformation::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PosAssistanceInformation");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PosAssistanceInformation");
            e
        })
    }
}
// PosAssistanceInformationFailureList
#[derive(Clone, Debug)]
pub struct PosAssistanceInformationFailureList(pub Vec<u8>);

impl PosAssistanceInformationFailureList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(decode::decode_octetstring(data, None, None, false)?))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_octetstring(data, None, None, false, &self.0, false)
    }
}

impl PerCodec for PosAssistanceInformationFailureList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PosAssistanceInformationFailureList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PosAssistanceInformationFailureList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PosAssistanceInformationFailureList");
            e
        })
    }
}
// PosBroadcast
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum PosBroadcast {
    Start,
    Stop,
}

impl PosBroadcast {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(1), true)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(1),
            true,
            *self as i128,
            (*self as u32) >= 2,
        )
    }
}

impl PerCodec for PosBroadcast {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PosBroadcast::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PosBroadcast");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PosBroadcast");
            e
        })
    }
}
// PosContextRevIndication
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum PosContextRevIndication {
    True,
}

impl PosContextRevIndication {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(0), true)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(0),
            true,
            *self as i128,
            (*self as u32) >= 1,
        )
    }
}

impl PerCodec for PosContextRevIndication {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PosContextRevIndication::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PosContextRevIndication");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PosContextRevIndication");
            e
        })
    }
}
// PositioningBroadcastCells
#[derive(Clone, Debug)]
pub struct PositioningBroadcastCells(pub NonEmpty<NrCgi>);

impl PositioningBroadcastCells {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(16384), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(NrCgi::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(16384), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for PositioningBroadcastCells {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PositioningBroadcastCells::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PositioningBroadcastCells");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PositioningBroadcastCells");
            e
        })
    }
}
// PosMeasGapPreConfigList
#[derive(Clone, Debug)]
pub struct PosMeasGapPreConfigList {
    pub pos_meas_gap_pre_config_to_add_mod_list: Option<Vec<u8>>,
    pub pos_meas_gap_pre_config_to_release_list: Option<Vec<u8>>,
}

impl PosMeasGapPreConfigList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, false, 3)?;
        let pos_meas_gap_pre_config_to_add_mod_list = if optionals[0] {
            Some(decode::decode_octetstring(data, None, None, false)?)
        } else {
            None
        };
        let pos_meas_gap_pre_config_to_release_list = if optionals[1] {
            Some(decode::decode_octetstring(data, None, None, false)?)
        } else {
            None
        };

        // Process the extension container

        if optionals[2] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            pos_meas_gap_pre_config_to_add_mod_list,
            pos_meas_gap_pre_config_to_release_list,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.pos_meas_gap_pre_config_to_add_mod_list.is_some());
        optionals.push(self.pos_meas_gap_pre_config_to_release_list.is_some());
        optionals.push(false);

        encode::encode_sequence_header(data, false, &optionals, false)?;
        if let Some(x) = &self.pos_meas_gap_pre_config_to_add_mod_list {
            encode::encode_octetstring(data, None, None, false, &x, false)?;
        }
        if let Some(x) = &self.pos_meas_gap_pre_config_to_release_list {
            encode::encode_octetstring(data, None, None, false, &x, false)?;
        }

        Ok(())
    }
}

impl PerCodec for PosMeasGapPreConfigList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PosMeasGapPreConfigList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PosMeasGapPreConfigList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PosMeasGapPreConfigList");
            e
        })
    }
}
// MeasurementPeriodicity
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum MeasurementPeriodicity {
    Ms120,
    Ms240,
    Ms480,
    Ms640,
    Ms1024,
    Ms2048,
    Ms5120,
    Ms10240,
    Min1,
    Min6,
    Min12,
    Min30,
    Ms20480,
    Ms40960,
    Extended,
}

impl MeasurementPeriodicity {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(11), true)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(11),
            true,
            *self as i128,
            (*self as u32) >= 12,
        )
    }
}

impl PerCodec for MeasurementPeriodicity {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        MeasurementPeriodicity::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MeasurementPeriodicity");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MeasurementPeriodicity");
            e
        })
    }
}
// MeasurementPeriodicityExtended
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum MeasurementPeriodicityExtended {
    Ms160,
    Ms320,
    Ms1280,
    Ms2560,
    Ms61440,
    Ms81920,
    Ms368640,
    Ms737280,
    Ms1843200,
}

impl MeasurementPeriodicityExtended {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(8), true)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(8),
            true,
            *self as i128,
            (*self as u32) >= 9,
        )
    }
}

impl PerCodec for MeasurementPeriodicityExtended {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        MeasurementPeriodicityExtended::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MeasurementPeriodicityExtended");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MeasurementPeriodicityExtended");
            e
        })
    }
}
// PosMeasurementPeriodicityNrAoA
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum PosMeasurementPeriodicityNrAoA {
    Ms160,
    Ms320,
    Ms640,
    Ms1280,
    Ms2560,
    Ms5120,
    Ms10240,
    Ms20480,
    Ms40960,
    Ms61440,
    Ms81920,
    Ms368640,
    Ms737280,
    Ms1843200,
}

impl PosMeasurementPeriodicityNrAoA {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(13), true)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(13),
            true,
            *self as i128,
            (*self as u32) >= 14,
        )
    }
}

impl PerCodec for PosMeasurementPeriodicityNrAoA {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PosMeasurementPeriodicityNrAoA::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PosMeasurementPeriodicityNrAoA");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PosMeasurementPeriodicityNrAoA");
            e
        })
    }
}
// PosMeasurementQuantities
#[derive(Clone, Debug)]
pub struct PosMeasurementQuantities(pub NonEmpty<PosMeasurementQuantitiesItem>);

impl PosMeasurementQuantities {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(16384), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(PosMeasurementQuantitiesItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(16384), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for PosMeasurementQuantities {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PosMeasurementQuantities::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PosMeasurementQuantities");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PosMeasurementQuantities");
            e
        })
    }
}
// PosMeasurementQuantitiesItem
#[derive(Clone, Debug)]
pub struct PosMeasurementQuantitiesItem {
    pub pos_measurement_type: PosMeasurementType,
    pub timing_reporting_granularity_factor: Option<u8>,
    pub timing_reporting_granularity_factor_extended:
        Option<TimingReportingGranularityFactorExtended>,
}

impl PosMeasurementQuantitiesItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, false, 2)?;
        let pos_measurement_type = PosMeasurementType::decode(data)?;
        let timing_reporting_granularity_factor = if optionals[0] {
            Some(decode::decode_integer(data, Some(0), Some(5), false)?.0 as u8)
        } else {
            None
        };

        // Process the extension container
        let mut timing_reporting_granularity_factor_extended: Option<
            TimingReportingGranularityFactorExtended,
        > = None;

        if optionals[1] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    810 => {
                        timing_reporting_granularity_factor_extended =
                            Some(TimingReportingGranularityFactorExtended::decode(data)?)
                    }
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            pos_measurement_type,
            timing_reporting_granularity_factor,
            timing_reporting_granularity_factor_extended,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();
        if let Some(x) = &self.timing_reporting_granularity_factor_extended {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 810, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        let mut optionals = BitString::new();
        optionals.push(self.timing_reporting_granularity_factor.is_some());
        optionals.push(num_ies != 0);

        encode::encode_sequence_header(data, false, &optionals, false)?;
        self.pos_measurement_type.encode(data)?;
        if let Some(x) = &self.timing_reporting_granularity_factor {
            encode::encode_integer(data, Some(0), Some(5), false, *x as i128, false)?;
        }
        if num_ies != 0 {
            encode::encode_length_determinent(data, Some(1), Some(65535), false, num_ies)?;
            data.append_aligned(ies);
        }
        Ok(())
    }
}

impl PerCodec for PosMeasurementQuantitiesItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PosMeasurementQuantitiesItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PosMeasurementQuantitiesItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PosMeasurementQuantitiesItem");
            e
        })
    }
}
// PosMeasurementResult
#[derive(Clone, Debug)]
pub struct PosMeasurementResult(pub NonEmpty<PosMeasurementResultItem>);

impl PosMeasurementResult {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(16384), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(PosMeasurementResultItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(16384), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for PosMeasurementResult {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PosMeasurementResult::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PosMeasurementResult");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PosMeasurementResult");
            e
        })
    }
}
// PosMeasurementResultItem
#[derive(Clone, Debug)]
pub struct PosMeasurementResultItem {
    pub measured_results_value: MeasuredResultsValue,
    pub time_stamp: TimeStamp,
    pub measurement_quality: Option<TrpMeasurementQuality>,
    pub measurement_beam_info: Option<MeasurementBeamInfo>,
    pub arp_id: Option<ArpId>,
    pub srs_resource_type: Option<SrsResourceType>,
    pub lo_s_n_lo_s_information: Option<LoSNLoSInformation>,
    pub mobile_trp_location_information: Option<MobileTrpLocationInformation>,
    pub aggregated_pos_srs_resource_id_list: Option<AggregatedPosSrsResourceIdList>,
    pub measured_frequency_hops: Option<MeasuredFrequencyHops>,
    pub meas_based_on_aggregated_resources: Option<MeasBasedOnAggregatedResources>,
}

impl PosMeasurementResultItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, false, 3)?;
        let measured_results_value = MeasuredResultsValue::decode(data)?;
        let time_stamp = TimeStamp::decode(data)?;
        let measurement_quality = if optionals[0] {
            Some(TrpMeasurementQuality::decode(data)?)
        } else {
            None
        };
        let measurement_beam_info = if optionals[1] {
            Some(MeasurementBeamInfo::decode(data)?)
        } else {
            None
        };

        // Process the extension container
        let mut arp_id: Option<ArpId> = None;
        let mut srs_resource_type: Option<SrsResourceType> = None;
        let mut lo_s_n_lo_s_information: Option<LoSNLoSInformation> = None;
        let mut mobile_trp_location_information: Option<MobileTrpLocationInformation> = None;
        let mut aggregated_pos_srs_resource_id_list: Option<AggregatedPosSrsResourceIdList> = None;
        let mut measured_frequency_hops: Option<MeasuredFrequencyHops> = None;
        let mut meas_based_on_aggregated_resources: Option<MeasBasedOnAggregatedResources> = None;

        if optionals[2] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    557 => arp_id = Some(ArpId::decode(data)?),
                    560 => srs_resource_type = Some(SrsResourceType::decode(data)?),
                    562 => lo_s_n_lo_s_information = Some(LoSNLoSInformation::decode(data)?),
                    753 => {
                        mobile_trp_location_information =
                            Some(MobileTrpLocationInformation::decode(data)?)
                    }
                    816 => {
                        aggregated_pos_srs_resource_id_list =
                            Some(AggregatedPosSrsResourceIdList::decode(data)?)
                    }
                    819 => measured_frequency_hops = Some(MeasuredFrequencyHops::decode(data)?),
                    847 => {
                        meas_based_on_aggregated_resources =
                            Some(MeasBasedOnAggregatedResources::decode(data)?)
                    }
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            measured_results_value,
            time_stamp,
            measurement_quality,
            measurement_beam_info,
            arp_id,
            srs_resource_type,
            lo_s_n_lo_s_information,
            mobile_trp_location_information,
            aggregated_pos_srs_resource_id_list,
            measured_frequency_hops,
            meas_based_on_aggregated_resources,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();
        if let Some(x) = &self.arp_id {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 557, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.srs_resource_type {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 560, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.lo_s_n_lo_s_information {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 562, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.mobile_trp_location_information {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 753, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.aggregated_pos_srs_resource_id_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 816, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.measured_frequency_hops {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 819, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.meas_based_on_aggregated_resources {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 847, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        let mut optionals = BitString::new();
        optionals.push(self.measurement_quality.is_some());
        optionals.push(self.measurement_beam_info.is_some());
        optionals.push(num_ies != 0);

        encode::encode_sequence_header(data, false, &optionals, false)?;
        self.measured_results_value.encode(data)?;
        self.time_stamp.encode(data)?;
        if let Some(x) = &self.measurement_quality {
            x.encode(data)?;
        }
        if let Some(x) = &self.measurement_beam_info {
            x.encode(data)?;
        }
        if num_ies != 0 {
            encode::encode_length_determinent(data, Some(1), Some(65535), false, num_ies)?;
            data.append_aligned(ies);
        }
        Ok(())
    }
}

impl PerCodec for PosMeasurementResultItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PosMeasurementResultItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PosMeasurementResultItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PosMeasurementResultItem");
            e
        })
    }
}
// PosMeasurementResultList
#[derive(Clone, Debug)]
pub struct PosMeasurementResultList(pub NonEmpty<PosMeasurementResultListItem>);

impl PosMeasurementResultList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(64), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(PosMeasurementResultListItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(64), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for PosMeasurementResultList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PosMeasurementResultList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PosMeasurementResultList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PosMeasurementResultList");
            e
        })
    }
}
// PosMeasurementResultListItem
#[derive(Clone, Debug)]
pub struct PosMeasurementResultListItem {
    pub pos_measurement_result: PosMeasurementResult,
    pub trpid: Trpid,
    pub nr_cgi: Option<NrCgi>,
}

impl PosMeasurementResultListItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, false, 1)?;
        let pos_measurement_result = PosMeasurementResult::decode(data)?;
        let trpid = Trpid::decode(data)?;

        // Process the extension container
        let mut nr_cgi: Option<NrCgi> = None;

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    111 => nr_cgi = Some(NrCgi::decode(data)?),
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            pos_measurement_result,
            trpid,
            nr_cgi,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();
        if let Some(x) = &self.nr_cgi {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 111, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        let mut optionals = BitString::new();
        optionals.push(num_ies != 0);

        encode::encode_sequence_header(data, false, &optionals, false)?;
        self.pos_measurement_result.encode(data)?;
        self.trpid.encode(data)?;
        if num_ies != 0 {
            encode::encode_length_determinent(data, Some(1), Some(65535), false, num_ies)?;
            data.append_aligned(ies);
        }
        Ok(())
    }
}

impl PerCodec for PosMeasurementResultListItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PosMeasurementResultListItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PosMeasurementResultListItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PosMeasurementResultListItem");
            e
        })
    }
}
// PosMeasurementType
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum PosMeasurementType {
    GnbRxTx,
    UlSrsRsrp,
    UlAoa,
    UlRtoa,
    MultipleUlAoa,
    UlSrsRsrpp,
    UlRscp,
}

impl PosMeasurementType {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(3), true)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(3),
            true,
            *self as i128,
            (*self as u32) >= 4,
        )
    }
}

impl PerCodec for PosMeasurementType {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PosMeasurementType::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PosMeasurementType");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PosMeasurementType");
            e
        })
    }
}
// PosReportCharacteristics
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum PosReportCharacteristics {
    Ondemand,
    Periodic,
}

impl PosReportCharacteristics {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(1), true)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(1),
            true,
            *self as i128,
            (*self as u32) >= 2,
        )
    }
}

impl PerCodec for PosReportCharacteristics {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PosReportCharacteristics::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PosReportCharacteristics");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PosReportCharacteristics");
            e
        })
    }
}
// PosResourceSetType
#[derive(Clone, Debug)]
pub enum PosResourceSetType {
    Periodic(PosResourceSetTypePr),
    SemiPersistent(PosResourceSetTypeSp),
    Aperiodic(PosResourceSetTypeAp),
}

impl PosResourceSetType {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_choice_idx(data, 0, 3, false)?;
        if extended {
            return Err(per_codec_error_new("CHOICE additions not implemented"));
        }
        match idx {
            0 => Ok(Self::Periodic(PosResourceSetTypePr::decode(data)?)),
            1 => Ok(Self::SemiPersistent(PosResourceSetTypeSp::decode(data)?)),
            2 => Ok(Self::Aperiodic(PosResourceSetTypeAp::decode(data)?)),
            3 => {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _ = Criticality::decode(data)?;
                let _ = decode::decode_length_determinent(data, None, None, false)?;
                let result = match id {
                    x => Err(per_codec_error_new(format!("Unrecognised IE type {}", x))),
                };
                data.decode_align()?;
                result
            }
            _ => Err(per_codec_error_new("Unknown choice idx")),
        }
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        match self {
            Self::Periodic(x) => {
                encode::encode_choice_idx(data, 0, 3, false, 0, false)?;
                x.encode(data)
            }
            Self::SemiPersistent(x) => {
                encode::encode_choice_idx(data, 0, 3, false, 1, false)?;
                x.encode(data)
            }
            Self::Aperiodic(x) => {
                encode::encode_choice_idx(data, 0, 3, false, 2, false)?;
                x.encode(data)
            }
        }
    }
}

impl PerCodec for PosResourceSetType {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PosResourceSetType::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PosResourceSetType");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PosResourceSetType");
            e
        })
    }
}
// PosResourceSetTypePr
#[derive(Clone, Debug)]
pub struct PosResourceSetTypePr {
    pub posperiodic_set: PosperiodicSet,
}

impl PosResourceSetTypePr {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, false, 1)?;
        let posperiodic_set = PosperiodicSet::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self { posperiodic_set })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, false, &optionals, false)?;
        self.posperiodic_set.encode(data)?;

        Ok(())
    }
}

impl PerCodec for PosResourceSetTypePr {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PosResourceSetTypePr::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PosResourceSetTypePr");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PosResourceSetTypePr");
            e
        })
    }
}
// PosResourceSetTypeSp
#[derive(Clone, Debug)]
pub struct PosResourceSetTypeSp {
    pub possemi_persistent_set: PossemiPersistentSet,
}

impl PosResourceSetTypeSp {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, false, 1)?;
        let possemi_persistent_set = PossemiPersistentSet::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            possemi_persistent_set,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, false, &optionals, false)?;
        self.possemi_persistent_set.encode(data)?;

        Ok(())
    }
}

impl PerCodec for PosResourceSetTypeSp {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PosResourceSetTypeSp::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PosResourceSetTypeSp");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PosResourceSetTypeSp");
            e
        })
    }
}
// PosResourceSetTypeAp
#[derive(Clone, Debug)]
pub struct PosResourceSetTypeAp {
    pub srs_resource_trigger_list: u8,
}

impl PosResourceSetTypeAp {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, false, 1)?;
        let srs_resource_trigger_list =
            decode::decode_integer(data, Some(1), Some(3), false)?.0 as u8;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            srs_resource_trigger_list,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, false, &optionals, false)?;
        encode::encode_integer(
            data,
            Some(1),
            Some(3),
            false,
            self.srs_resource_trigger_list as i128,
            false,
        )?;

        Ok(())
    }
}

impl PerCodec for PosResourceSetTypeAp {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PosResourceSetTypeAp::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PosResourceSetTypeAp");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PosResourceSetTypeAp");
            e
        })
    }
}
// PosSiTypeList
#[derive(Clone, Debug)]
pub struct PosSiTypeList(pub NonEmpty<PosSiTypeItem>);

impl PosSiTypeList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(32), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(PosSiTypeItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(32), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for PosSiTypeList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PosSiTypeList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PosSiTypeList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PosSiTypeList");
            e
        })
    }
}
// PosSiTypeItem
#[derive(Clone, Debug)]
pub struct PosSiTypeItem {
    pub pos_i_type: PosSiType,
}

impl PosSiTypeItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, false, 1)?;
        let pos_i_type = PosSiType::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self { pos_i_type })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, false, &optionals, false)?;
        self.pos_i_type.encode(data)?;

        Ok(())
    }
}

impl PerCodec for PosSiTypeItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PosSiTypeItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PosSiTypeItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PosSiTypeItem");
            e
        })
    }
}
// PosSiType
#[derive(Clone, Copy, Debug)]
pub struct PosSiType(pub u8);

impl PosSiType {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(
            decode::decode_integer(data, Some(1), Some(32), true)?.0 as u8,
        ))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_integer(data, Some(1), Some(32), true, self.0 as i128, false)
    }
}

impl PerCodec for PosSiType {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PosSiType::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PosSiType");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PosSiType");
            e
        })
    }
}
// PosSrsResourceIdList
#[derive(Clone, Debug)]
pub struct PosSrsResourceIdList(pub NonEmpty<SrsPosResourceId>);

impl PosSrsResourceIdList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(16), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(SrsPosResourceId::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(16), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for PosSrsResourceIdList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PosSrsResourceIdList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PosSrsResourceIdList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PosSrsResourceIdList");
            e
        })
    }
}
// PosSrsResourceItem
#[derive(Clone, Debug)]
pub struct PosSrsResourceItem {
    pub srs_pos_resource_id: SrsPosResourceId,
    pub transmission_comb_pos: TransmissionCombPos,
    pub start_position: u8,
    pub nrof_symbols: NrofSymbols,
    pub freq_domain_shift: u16,
    pub c_srs: u8,
    pub group_or_sequence_hopping: GroupOrSequenceHopping,
    pub resource_type_pos: ResourceTypePos,
    pub sequence_id: u16,
    pub spatial_relation_pos: Option<SpatialRelationPos>,
    pub tx_hopping_configuration: Option<TxHoppingConfiguration>,
}

impl PosSrsResourceItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, false, 2)?;
        let srs_pos_resource_id = SrsPosResourceId::decode(data)?;
        let transmission_comb_pos = TransmissionCombPos::decode(data)?;
        let start_position = decode::decode_integer(data, Some(0), Some(13), false)?.0 as u8;
        let nrof_symbols = NrofSymbols::decode(data)?;
        let freq_domain_shift = decode::decode_integer(data, Some(0), Some(268), false)?.0 as u16;
        let c_srs = decode::decode_integer(data, Some(0), Some(63), false)?.0 as u8;
        let group_or_sequence_hopping = GroupOrSequenceHopping::decode(data)?;
        let resource_type_pos = ResourceTypePos::decode(data)?;
        let sequence_id = decode::decode_integer(data, Some(0), Some(65535), false)?.0 as u16;
        let spatial_relation_pos = if optionals[0] {
            Some(SpatialRelationPos::decode(data)?)
        } else {
            None
        };

        // Process the extension container
        let mut tx_hopping_configuration: Option<TxHoppingConfiguration> = None;

        if optionals[1] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    820 => tx_hopping_configuration = Some(TxHoppingConfiguration::decode(data)?),
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            srs_pos_resource_id,
            transmission_comb_pos,
            start_position,
            nrof_symbols,
            freq_domain_shift,
            c_srs,
            group_or_sequence_hopping,
            resource_type_pos,
            sequence_id,
            spatial_relation_pos,
            tx_hopping_configuration,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();
        if let Some(x) = &self.tx_hopping_configuration {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 820, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        let mut optionals = BitString::new();
        optionals.push(self.spatial_relation_pos.is_some());
        optionals.push(num_ies != 0);

        encode::encode_sequence_header(data, false, &optionals, false)?;
        self.srs_pos_resource_id.encode(data)?;
        self.transmission_comb_pos.encode(data)?;
        encode::encode_integer(
            data,
            Some(0),
            Some(13),
            false,
            self.start_position as i128,
            false,
        )?;
        self.nrof_symbols.encode(data)?;
        encode::encode_integer(
            data,
            Some(0),
            Some(268),
            false,
            self.freq_domain_shift as i128,
            false,
        )?;
        encode::encode_integer(data, Some(0), Some(63), false, self.c_srs as i128, false)?;
        self.group_or_sequence_hopping.encode(data)?;
        self.resource_type_pos.encode(data)?;
        encode::encode_integer(
            data,
            Some(0),
            Some(65535),
            false,
            self.sequence_id as i128,
            false,
        )?;
        if let Some(x) = &self.spatial_relation_pos {
            x.encode(data)?;
        }
        if num_ies != 0 {
            encode::encode_length_determinent(data, Some(1), Some(65535), false, num_ies)?;
            data.append_aligned(ies);
        }
        Ok(())
    }
}

impl PerCodec for PosSrsResourceItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PosSrsResourceItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PosSrsResourceItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PosSrsResourceItem");
            e
        })
    }
}
// PosSrsResourceList
#[derive(Clone, Debug)]
pub struct PosSrsResourceList(pub NonEmpty<PosSrsResourceItem>);

impl PosSrsResourceList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(64), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(PosSrsResourceItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(64), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for PosSrsResourceList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PosSrsResourceList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PosSrsResourceList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PosSrsResourceList");
            e
        })
    }
}
// PosSrsResourceSetItem
#[derive(Clone, Debug)]
pub struct PosSrsResourceSetItem {
    pub possrs_resource_set_id: u8,
    pub poss_rs_resource_id_list: PosSrsResourceIdList,
    pub posresource_set_type: PosResourceSetType,
}

impl PosSrsResourceSetItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, false, 1)?;
        let possrs_resource_set_id =
            decode::decode_integer(data, Some(0), Some(15), false)?.0 as u8;
        let poss_rs_resource_id_list = PosSrsResourceIdList::decode(data)?;
        let posresource_set_type = PosResourceSetType::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            possrs_resource_set_id,
            poss_rs_resource_id_list,
            posresource_set_type,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, false, &optionals, false)?;
        encode::encode_integer(
            data,
            Some(0),
            Some(15),
            false,
            self.possrs_resource_set_id as i128,
            false,
        )?;
        self.poss_rs_resource_id_list.encode(data)?;
        self.posresource_set_type.encode(data)?;

        Ok(())
    }
}

impl PerCodec for PosSrsResourceSetItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PosSrsResourceSetItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PosSrsResourceSetItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PosSrsResourceSetItem");
            e
        })
    }
}
// PosValidityAreaCellList
#[derive(Clone, Debug)]
pub struct PosValidityAreaCellList(pub NonEmpty<PosValidityAreaCellListItem>);

impl PosValidityAreaCellList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(32), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(PosValidityAreaCellListItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(32), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for PosValidityAreaCellList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PosValidityAreaCellList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PosValidityAreaCellList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PosValidityAreaCellList");
            e
        })
    }
}
// PosValidityAreaCellListItem
#[derive(Clone, Debug)]
pub struct PosValidityAreaCellListItem {
    pub nr_cgi: NrCgi,
    pub nr_pci: Option<u16>,
}

impl PosValidityAreaCellListItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, false, 2)?;
        let nr_cgi = NrCgi::decode(data)?;
        let nr_pci = if optionals[0] {
            Some(decode::decode_integer(data, Some(0), Some(1007), false)?.0 as u16)
        } else {
            None
        };

        // Process the extension container

        if optionals[1] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self { nr_cgi, nr_pci })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.nr_pci.is_some());
        optionals.push(false);

        encode::encode_sequence_header(data, false, &optionals, false)?;
        self.nr_cgi.encode(data)?;
        if let Some(x) = &self.nr_pci {
            encode::encode_integer(data, Some(0), Some(1007), false, *x as i128, false)?;
        }

        Ok(())
    }
}

impl PerCodec for PosValidityAreaCellListItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PosValidityAreaCellListItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PosValidityAreaCellListItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PosValidityAreaCellListItem");
            e
        })
    }
}
// PosSrsResourceSetList
#[derive(Clone, Debug)]
pub struct PosSrsResourceSetList(pub NonEmpty<PosSrsResourceSetItem>);

impl PosSrsResourceSetList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(16), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(PosSrsResourceSetItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(16), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for PosSrsResourceSetList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PosSrsResourceSetList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PosSrsResourceSetList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PosSrsResourceSetList");
            e
        })
    }
}
// PrimaryPathIndication
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum PrimaryPathIndication {
    True,
    False,
}

impl PrimaryPathIndication {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(1), true)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(1),
            true,
            *self as i128,
            (*self as u32) >= 2,
        )
    }
}

impl PerCodec for PrimaryPathIndication {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PrimaryPathIndication::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PrimaryPathIndication");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PrimaryPathIndication");
            e
        })
    }
}
// PreambleIndexList
#[derive(Clone, Debug)]
pub struct PreambleIndexList(pub NonEmpty<PreambleIndexListItem>);

impl PreambleIndexList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(8), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(PreambleIndexListItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(8), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for PreambleIndexList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PreambleIndexList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PreambleIndexList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PreambleIndexList");
            e
        })
    }
}
// PreambleIndexListItem
#[derive(Clone, Debug)]
pub struct PreambleIndexListItem {
    pub preamble_index: u8,
}

impl PreambleIndexListItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, false, 1)?;
        let preamble_index = decode::decode_integer(data, Some(0), Some(63), false)?.0 as u8;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self { preamble_index })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, false, &optionals, false)?;
        encode::encode_integer(
            data,
            Some(0),
            Some(63),
            false,
            self.preamble_index as i128,
            false,
        )?;

        Ok(())
    }
}

impl PerCodec for PreambleIndexListItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PreambleIndexListItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PreambleIndexListItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PreambleIndexListItem");
            e
        })
    }
}
// PreEmptionCapability
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum PreEmptionCapability {
    ShallNotTriggerPreEmption,
    MayTriggerPreEmption,
}

impl PreEmptionCapability {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(1), false)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(1),
            false,
            *self as i128,
            (*self as u32) >= 2,
        )
    }
}

impl PerCodec for PreEmptionCapability {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PreEmptionCapability::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PreEmptionCapability");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PreEmptionCapability");
            e
        })
    }
}
// PreEmptionVulnerability
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum PreEmptionVulnerability {
    NotPreEmptable,
    PreEmptable,
}

impl PreEmptionVulnerability {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(1), false)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(1),
            false,
            *self as i128,
            (*self as u32) >= 2,
        )
    }
}

impl PerCodec for PreEmptionVulnerability {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PreEmptionVulnerability::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PreEmptionVulnerability");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PreEmptionVulnerability");
            e
        })
    }
}
// PreconfiguredMeasurementGapRequest
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum PreconfiguredMeasurementGapRequest {
    True,
}

impl PreconfiguredMeasurementGapRequest {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(0), true)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(0),
            true,
            *self as i128,
            (*self as u32) >= 1,
        )
    }
}

impl PerCodec for PreconfiguredMeasurementGapRequest {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PreconfiguredMeasurementGapRequest::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PreconfiguredMeasurementGapRequest");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PreconfiguredMeasurementGapRequest");
            e
        })
    }
}
// PriorityLevel
#[derive(Clone, Copy, Debug)]
pub struct PriorityLevel(pub u8);

impl PriorityLevel {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(
            decode::decode_integer(data, Some(0), Some(15), false)?.0 as u8,
        ))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_integer(data, Some(0), Some(15), false, self.0 as i128, false)
    }
}

impl PerCodec for PriorityLevel {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PriorityLevel::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PriorityLevel");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PriorityLevel");
            e
        })
    }
}
// ProtectedEutraResourceIndication
#[derive(Clone, Debug)]
pub struct ProtectedEutraResourceIndication(pub Vec<u8>);

impl ProtectedEutraResourceIndication {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(decode::decode_octetstring(data, None, None, false)?))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_octetstring(data, None, None, false, &self.0, false)
    }
}

impl PerCodec for ProtectedEutraResourceIndication {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        ProtectedEutraResourceIndication::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ProtectedEutraResourceIndication");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ProtectedEutraResourceIndication");
            e
        })
    }
}
// ProtectedEutraResourcesItem
#[derive(Clone, Debug)]
pub struct ProtectedEutraResourcesItem {
    pub spectrum_sharing_group_id: SpectrumSharingGroupId,
    pub eutra_cells_list: EutraCellsList,
}

impl ProtectedEutraResourcesItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, false, 1)?;
        let spectrum_sharing_group_id = SpectrumSharingGroupId::decode(data)?;
        let eutra_cells_list = EutraCellsList::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            spectrum_sharing_group_id,
            eutra_cells_list,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, false, &optionals, false)?;
        self.spectrum_sharing_group_id.encode(data)?;
        self.eutra_cells_list.encode(data)?;

        Ok(())
    }
}

impl PerCodec for ProtectedEutraResourcesItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        ProtectedEutraResourcesItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ProtectedEutraResourcesItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ProtectedEutraResourcesItem");
            e
        })
    }
}
// PrsConfiguration
#[derive(Clone, Debug)]
pub struct PrsConfiguration {
    pub prs_resource_set_list: PrsResourceSetList,
    pub aggregated_prs_resource_set_list: Option<AggregatedPrsResourceSetList>,
}

impl PrsConfiguration {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, false, 1)?;
        let prs_resource_set_list = PrsResourceSetList::decode(data)?;

        // Process the extension container
        let mut aggregated_prs_resource_set_list: Option<AggregatedPrsResourceSetList> = None;

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    817 => {
                        aggregated_prs_resource_set_list =
                            Some(AggregatedPrsResourceSetList::decode(data)?)
                    }
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            prs_resource_set_list,
            aggregated_prs_resource_set_list,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();
        if let Some(x) = &self.aggregated_prs_resource_set_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 817, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        let mut optionals = BitString::new();
        optionals.push(num_ies != 0);

        encode::encode_sequence_header(data, false, &optionals, false)?;
        self.prs_resource_set_list.encode(data)?;
        if num_ies != 0 {
            encode::encode_length_determinent(data, Some(1), Some(65535), false, num_ies)?;
            data.append_aligned(ies);
        }
        Ok(())
    }
}

impl PerCodec for PrsConfiguration {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PrsConfiguration::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PrsConfiguration");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PrsConfiguration");
            e
        })
    }
}
// PrsInformationPos
#[derive(Clone, Debug)]
pub struct PrsInformationPos {
    pub prs_id_pos: u8,
    pub prs_resource_set_id_pos: u8,
    pub prs_resource_id_pos: Option<u8>,
}

impl PrsInformationPos {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, false, 2)?;
        let prs_id_pos = decode::decode_integer(data, Some(0), Some(255), false)?.0 as u8;
        let prs_resource_set_id_pos =
            decode::decode_integer(data, Some(0), Some(7), false)?.0 as u8;
        let prs_resource_id_pos = if optionals[0] {
            Some(decode::decode_integer(data, Some(0), Some(63), false)?.0 as u8)
        } else {
            None
        };

        // Process the extension container

        if optionals[1] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            prs_id_pos,
            prs_resource_set_id_pos,
            prs_resource_id_pos,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.prs_resource_id_pos.is_some());
        optionals.push(false);

        encode::encode_sequence_header(data, false, &optionals, false)?;
        encode::encode_integer(
            data,
            Some(0),
            Some(255),
            false,
            self.prs_id_pos as i128,
            false,
        )?;
        encode::encode_integer(
            data,
            Some(0),
            Some(7),
            false,
            self.prs_resource_set_id_pos as i128,
            false,
        )?;
        if let Some(x) = &self.prs_resource_id_pos {
            encode::encode_integer(data, Some(0), Some(63), false, *x as i128, false)?;
        }

        Ok(())
    }
}

impl PerCodec for PrsInformationPos {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PrsInformationPos::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PrsInformationPos");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PrsInformationPos");
            e
        })
    }
}
// PrsMeasurementInfoList
#[derive(Clone, Debug)]
pub struct PrsMeasurementInfoList(pub NonEmpty<PrsMeasurementInfoListItem>);

impl PrsMeasurementInfoList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(4), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(PrsMeasurementInfoListItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(4), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for PrsMeasurementInfoList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PrsMeasurementInfoList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PrsMeasurementInfoList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PrsMeasurementInfoList");
            e
        })
    }
}
// PrsMeasurementInfoListItem
#[derive(Clone, Debug)]
pub struct PrsMeasurementInfoListItem {
    pub point_a: u32,
    pub meas_prs_periodicity: MeasPrsPeriodicity,
    pub meas_prs_offset: u8,
    pub measurement_prs_length: MeasurementPrsLength,
}

impl PrsMeasurementInfoListItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let point_a = decode::decode_integer(data, Some(0), Some(3279165), false)?.0 as u32;
        let meas_prs_periodicity = MeasPrsPeriodicity::decode(data)?;
        let meas_prs_offset = decode::decode_integer(data, Some(0), Some(159), true)?.0 as u8;
        let measurement_prs_length = MeasurementPrsLength::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            point_a,
            meas_prs_periodicity,
            meas_prs_offset,
            measurement_prs_length,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        encode::encode_integer(
            data,
            Some(0),
            Some(3279165),
            false,
            self.point_a as i128,
            false,
        )?;
        self.meas_prs_periodicity.encode(data)?;
        encode::encode_integer(
            data,
            Some(0),
            Some(159),
            true,
            self.meas_prs_offset as i128,
            false,
        )?;
        self.measurement_prs_length.encode(data)?;

        Ok(())
    }
}

impl PerCodec for PrsMeasurementInfoListItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PrsMeasurementInfoListItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PrsMeasurementInfoListItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PrsMeasurementInfoListItem");
            e
        })
    }
}
// PotentialSpCellItem
#[derive(Clone, Debug)]
pub struct PotentialSpCellItem {
    pub potential_sp_cell_id: NrCgi,
}

impl PotentialSpCellItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let potential_sp_cell_id = NrCgi::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            potential_sp_cell_id,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.potential_sp_cell_id.encode(data)?;

        Ok(())
    }
}

impl PerCodec for PotentialSpCellItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PotentialSpCellItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PotentialSpCellItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PotentialSpCellItem");
            e
        })
    }
}
// PrsAngleList
#[derive(Clone, Debug)]
pub struct PrsAngleList(pub NonEmpty<PrsAngleItem>);

impl PrsAngleList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(64), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(PrsAngleItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(64), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for PrsAngleList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PrsAngleList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PrsAngleList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PrsAngleList");
            e
        })
    }
}
// PrsAngleItem
#[derive(Clone, Debug)]
pub struct PrsAngleItem {
    pub nr_prs_azimuth: u16,
    pub nr_prs_azimuth_fine: Option<u8>,
    pub nr_prs_elevation: Option<u8>,
    pub nr_prs_elevation_fine: Option<u8>,
    pub prs_resource_id: Option<PrsResourceId>,
}

impl PrsAngleItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, false, 4)?;
        let nr_prs_azimuth = decode::decode_integer(data, Some(0), Some(359), false)?.0 as u16;
        let nr_prs_azimuth_fine = if optionals[0] {
            Some(decode::decode_integer(data, Some(0), Some(9), false)?.0 as u8)
        } else {
            None
        };
        let nr_prs_elevation = if optionals[1] {
            Some(decode::decode_integer(data, Some(0), Some(180), false)?.0 as u8)
        } else {
            None
        };
        let nr_prs_elevation_fine = if optionals[2] {
            Some(decode::decode_integer(data, Some(0), Some(9), false)?.0 as u8)
        } else {
            None
        };

        // Process the extension container
        let mut prs_resource_id: Option<PrsResourceId> = None;

        if optionals[3] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    439 => prs_resource_id = Some(PrsResourceId::decode(data)?),
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            nr_prs_azimuth,
            nr_prs_azimuth_fine,
            nr_prs_elevation,
            nr_prs_elevation_fine,
            prs_resource_id,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();
        if let Some(x) = &self.prs_resource_id {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 439, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        let mut optionals = BitString::new();
        optionals.push(self.nr_prs_azimuth_fine.is_some());
        optionals.push(self.nr_prs_elevation.is_some());
        optionals.push(self.nr_prs_elevation_fine.is_some());
        optionals.push(num_ies != 0);

        encode::encode_sequence_header(data, false, &optionals, false)?;
        encode::encode_integer(
            data,
            Some(0),
            Some(359),
            false,
            self.nr_prs_azimuth as i128,
            false,
        )?;
        if let Some(x) = &self.nr_prs_azimuth_fine {
            encode::encode_integer(data, Some(0), Some(9), false, *x as i128, false)?;
        }
        if let Some(x) = &self.nr_prs_elevation {
            encode::encode_integer(data, Some(0), Some(180), false, *x as i128, false)?;
        }
        if let Some(x) = &self.nr_prs_elevation_fine {
            encode::encode_integer(data, Some(0), Some(9), false, *x as i128, false)?;
        }
        if num_ies != 0 {
            encode::encode_length_determinent(data, Some(1), Some(65535), false, num_ies)?;
            data.append_aligned(ies);
        }
        Ok(())
    }
}

impl PerCodec for PrsAngleItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PrsAngleItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PrsAngleItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PrsAngleItem");
            e
        })
    }
}
// PrsConfigRequestType
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum PrsConfigRequestType {
    Configure,
    Off,
}

impl PrsConfigRequestType {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(1), true)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(1),
            true,
            *self as i128,
            (*self as u32) >= 2,
        )
    }
}

impl PerCodec for PrsConfigRequestType {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PrsConfigRequestType::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PrsConfigRequestType");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PrsConfigRequestType");
            e
        })
    }
}
// PrsMuting
#[derive(Clone, Debug)]
pub struct PrsMuting {
    pub prs_muting_option_1: Option<PrsMutingOption1>,
    pub prs_muting_option_2: Option<PrsMutingOption2>,
}

impl PrsMuting {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, false, 3)?;
        let prs_muting_option_1 = if optionals[0] {
            Some(PrsMutingOption1::decode(data)?)
        } else {
            None
        };
        let prs_muting_option_2 = if optionals[1] {
            Some(PrsMutingOption2::decode(data)?)
        } else {
            None
        };

        // Process the extension container

        if optionals[2] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            prs_muting_option_1,
            prs_muting_option_2,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.prs_muting_option_1.is_some());
        optionals.push(self.prs_muting_option_2.is_some());
        optionals.push(false);

        encode::encode_sequence_header(data, false, &optionals, false)?;
        if let Some(x) = &self.prs_muting_option_1 {
            x.encode(data)?;
        }
        if let Some(x) = &self.prs_muting_option_2 {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl PerCodec for PrsMuting {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PrsMuting::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PrsMuting");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PrsMuting");
            e
        })
    }
}
// PrsMutingOption1
#[derive(Clone, Debug)]
pub struct PrsMutingOption1 {
    pub muting_pattern: DlPrsMutingPattern,
    pub muting_bit_repetition_factor: MutingBitRepetitionFactor,
}

impl PrsMutingOption1 {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, false, 1)?;
        let muting_pattern = DlPrsMutingPattern::decode(data)?;
        let muting_bit_repetition_factor = MutingBitRepetitionFactor::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            muting_pattern,
            muting_bit_repetition_factor,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, false, &optionals, false)?;
        self.muting_pattern.encode(data)?;
        self.muting_bit_repetition_factor.encode(data)?;

        Ok(())
    }
}

impl PerCodec for PrsMutingOption1 {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PrsMutingOption1::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PrsMutingOption1");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PrsMutingOption1");
            e
        })
    }
}
// PrsMutingOption2
#[derive(Clone, Debug)]
pub struct PrsMutingOption2 {
    pub muting_pattern: DlPrsMutingPattern,
}

impl PrsMutingOption2 {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, false, 1)?;
        let muting_pattern = DlPrsMutingPattern::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self { muting_pattern })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, false, &optionals, false)?;
        self.muting_pattern.encode(data)?;

        Ok(())
    }
}

impl PerCodec for PrsMutingOption2 {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PrsMutingOption2::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PrsMutingOption2");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PrsMutingOption2");
            e
        })
    }
}
// PrsResourceId
#[derive(Clone, Copy, Debug)]
pub struct PrsResourceId(pub u8);

impl PrsResourceId {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(
            decode::decode_integer(data, Some(0), Some(63), false)?.0 as u8,
        ))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_integer(data, Some(0), Some(63), false, self.0 as i128, false)
    }
}

impl PerCodec for PrsResourceId {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PrsResourceId::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PrsResourceId");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PrsResourceId");
            e
        })
    }
}
// PrsResourceList
#[derive(Clone, Debug)]
pub struct PrsResourceList(pub NonEmpty<PrsResourceItem>);

impl PrsResourceList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(64), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(PrsResourceItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(64), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for PrsResourceList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PrsResourceList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PrsResourceList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PrsResourceList");
            e
        })
    }
}
// PrsResourceItem
#[derive(Clone, Debug)]
pub struct PrsResourceItem {
    pub prs_resource_id: PrsResourceId,
    pub sequence_id: u16,
    pub re_offset: u8,
    pub resource_slot_offset: u16,
    pub resource_symbol_offset: u8,
    pub qcl_info: Option<PrsResourceQclInfo>,
    pub extended_resource_symbol_offset: Option<ExtendedResourceSymbolOffset>,
}

impl PrsResourceItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, false, 2)?;
        let prs_resource_id = PrsResourceId::decode(data)?;
        let sequence_id = decode::decode_integer(data, Some(0), Some(4095), false)?.0 as u16;
        let re_offset = decode::decode_integer(data, Some(0), Some(11), true)?.0 as u8;
        let resource_slot_offset =
            decode::decode_integer(data, Some(0), Some(511), false)?.0 as u16;
        let resource_symbol_offset =
            decode::decode_integer(data, Some(0), Some(12), false)?.0 as u8;
        let qcl_info = if optionals[0] {
            Some(PrsResourceQclInfo::decode(data)?)
        } else {
            None
        };

        // Process the extension container
        let mut extended_resource_symbol_offset: Option<ExtendedResourceSymbolOffset> = None;

        if optionals[1] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    714 => {
                        extended_resource_symbol_offset =
                            Some(ExtendedResourceSymbolOffset::decode(data)?)
                    }
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            prs_resource_id,
            sequence_id,
            re_offset,
            resource_slot_offset,
            resource_symbol_offset,
            qcl_info,
            extended_resource_symbol_offset,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();
        if let Some(x) = &self.extended_resource_symbol_offset {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 714, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        let mut optionals = BitString::new();
        optionals.push(self.qcl_info.is_some());
        optionals.push(num_ies != 0);

        encode::encode_sequence_header(data, false, &optionals, false)?;
        self.prs_resource_id.encode(data)?;
        encode::encode_integer(
            data,
            Some(0),
            Some(4095),
            false,
            self.sequence_id as i128,
            false,
        )?;
        encode::encode_integer(data, Some(0), Some(11), true, self.re_offset as i128, false)?;
        encode::encode_integer(
            data,
            Some(0),
            Some(511),
            false,
            self.resource_slot_offset as i128,
            false,
        )?;
        encode::encode_integer(
            data,
            Some(0),
            Some(12),
            false,
            self.resource_symbol_offset as i128,
            false,
        )?;
        if let Some(x) = &self.qcl_info {
            x.encode(data)?;
        }
        if num_ies != 0 {
            encode::encode_length_determinent(data, Some(1), Some(65535), false, num_ies)?;
            data.append_aligned(ies);
        }
        Ok(())
    }
}

impl PerCodec for PrsResourceItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PrsResourceItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PrsResourceItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PrsResourceItem");
            e
        })
    }
}
// PrsbwAggregationRequestInfoList
#[derive(Clone, Debug)]
pub struct PrsbwAggregationRequestInfoList(pub NonEmpty<PrsbwAggregationRequestInfoItem>);

impl PrsbwAggregationRequestInfoList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(2), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(PrsbwAggregationRequestInfoItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(2), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for PrsbwAggregationRequestInfoList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PrsbwAggregationRequestInfoList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PrsbwAggregationRequestInfoList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PrsbwAggregationRequestInfoList");
            e
        })
    }
}
// PrsbwAggregationRequestInfoItem
#[derive(Clone, Debug)]
pub struct PrsbwAggregationRequestInfoItem {
    pub dl_prsbw_aggregation_request_info_list: DlPrsbwAggregationRequestInfoList,
}

impl PrsbwAggregationRequestInfoItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let dl_prsbw_aggregation_request_info_list =
            DlPrsbwAggregationRequestInfoList::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            dl_prsbw_aggregation_request_info_list,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.dl_prsbw_aggregation_request_info_list.encode(data)?;

        Ok(())
    }
}

impl PerCodec for PrsbwAggregationRequestInfoItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PrsbwAggregationRequestInfoItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PrsbwAggregationRequestInfoItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PrsbwAggregationRequestInfoItem");
            e
        })
    }
}
// DlPrsbwAggregationRequestInfoList
#[derive(Clone, Debug)]
pub struct DlPrsbwAggregationRequestInfoList(pub NonEmpty<DlPrsbwAggregationRequestInfoItem>);

impl DlPrsbwAggregationRequestInfoList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(2), Some(3), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(DlPrsbwAggregationRequestInfoItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(2), Some(3), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for DlPrsbwAggregationRequestInfoList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        DlPrsbwAggregationRequestInfoList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DlPrsbwAggregationRequestInfoList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DlPrsbwAggregationRequestInfoList");
            e
        })
    }
}
// DlPrsbwAggregationRequestInfoItem
#[derive(Clone, Debug)]
pub struct DlPrsbwAggregationRequestInfoItem {
    pub dl_prs_resource_set_index: u8,
}

impl DlPrsbwAggregationRequestInfoItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let dl_prs_resource_set_index =
            decode::decode_integer(data, Some(1), Some(8), false)?.0 as u8;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            dl_prs_resource_set_index,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        encode::encode_integer(
            data,
            Some(1),
            Some(8),
            false,
            self.dl_prs_resource_set_index as i128,
            false,
        )?;

        Ok(())
    }
}

impl PerCodec for DlPrsbwAggregationRequestInfoItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        DlPrsbwAggregationRequestInfoItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DlPrsbwAggregationRequestInfoItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DlPrsbwAggregationRequestInfoItem");
            e
        })
    }
}
// ExtendedResourceSymbolOffset
#[derive(Clone, Copy, Debug)]
pub struct ExtendedResourceSymbolOffset(pub u8);

impl ExtendedResourceSymbolOffset {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(
            decode::decode_integer(data, Some(0), Some(13), true)?.0 as u8,
        ))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_integer(data, Some(0), Some(13), true, self.0 as i128, false)
    }
}

impl PerCodec for ExtendedResourceSymbolOffset {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        ExtendedResourceSymbolOffset::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ExtendedResourceSymbolOffset");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ExtendedResourceSymbolOffset");
            e
        })
    }
}
// PrsResourceQclInfo
#[derive(Clone, Debug)]
pub enum PrsResourceQclInfo {
    QclSourceSsb(PrsResourceQclSourceSsb),
    QclSourcePrs(PrsResourceQclSourcePrs),
}

impl PrsResourceQclInfo {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_choice_idx(data, 0, 2, false)?;
        if extended {
            return Err(per_codec_error_new("CHOICE additions not implemented"));
        }
        match idx {
            0 => Ok(Self::QclSourceSsb(PrsResourceQclSourceSsb::decode(data)?)),
            1 => Ok(Self::QclSourcePrs(PrsResourceQclSourcePrs::decode(data)?)),
            2 => {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _ = Criticality::decode(data)?;
                let _ = decode::decode_length_determinent(data, None, None, false)?;
                let result = match id {
                    x => Err(per_codec_error_new(format!("Unrecognised IE type {}", x))),
                };
                data.decode_align()?;
                result
            }
            _ => Err(per_codec_error_new("Unknown choice idx")),
        }
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        match self {
            Self::QclSourceSsb(x) => {
                encode::encode_choice_idx(data, 0, 2, false, 0, false)?;
                x.encode(data)
            }
            Self::QclSourcePrs(x) => {
                encode::encode_choice_idx(data, 0, 2, false, 1, false)?;
                x.encode(data)
            }
        }
    }
}

impl PerCodec for PrsResourceQclInfo {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PrsResourceQclInfo::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PrsResourceQclInfo");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PrsResourceQclInfo");
            e
        })
    }
}
// PrsResourceQclSourceSsb
#[derive(Clone, Debug)]
pub struct PrsResourceQclSourceSsb {
    pub pci_nr: u16,
    pub ssb_index: Option<SsbIndex>,
}

impl PrsResourceQclSourceSsb {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 2)?;
        let pci_nr = decode::decode_integer(data, Some(0), Some(1007), false)?.0 as u16;
        let ssb_index = if optionals[0] {
            Some(SsbIndex::decode(data)?)
        } else {
            None
        };

        // Process the extension container

        if optionals[1] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self { pci_nr, ssb_index })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.ssb_index.is_some());
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        encode::encode_integer(data, Some(0), Some(1007), false, self.pci_nr as i128, false)?;
        if let Some(x) = &self.ssb_index {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl PerCodec for PrsResourceQclSourceSsb {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PrsResourceQclSourceSsb::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PrsResourceQclSourceSsb");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PrsResourceQclSourceSsb");
            e
        })
    }
}
// PrsResourceQclSourcePrs
#[derive(Clone, Debug)]
pub struct PrsResourceQclSourcePrs {
    pub qcl_source_prs_resource_set_id: PrsResourceSetId,
    pub qcl_source_prs_resource_id: Option<PrsResourceId>,
}

impl PrsResourceQclSourcePrs {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, false, 2)?;
        let qcl_source_prs_resource_set_id = PrsResourceSetId::decode(data)?;
        let qcl_source_prs_resource_id = if optionals[0] {
            Some(PrsResourceId::decode(data)?)
        } else {
            None
        };

        // Process the extension container

        if optionals[1] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            qcl_source_prs_resource_set_id,
            qcl_source_prs_resource_id,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.qcl_source_prs_resource_id.is_some());
        optionals.push(false);

        encode::encode_sequence_header(data, false, &optionals, false)?;
        self.qcl_source_prs_resource_set_id.encode(data)?;
        if let Some(x) = &self.qcl_source_prs_resource_id {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl PerCodec for PrsResourceQclSourcePrs {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PrsResourceQclSourcePrs::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PrsResourceQclSourcePrs");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PrsResourceQclSourcePrs");
            e
        })
    }
}
// PrsResourceSetId
#[derive(Clone, Copy, Debug)]
pub struct PrsResourceSetId(pub u8);

impl PrsResourceSetId {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(
            decode::decode_integer(data, Some(0), Some(7), false)?.0 as u8,
        ))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_integer(data, Some(0), Some(7), false, self.0 as i128, false)
    }
}

impl PerCodec for PrsResourceSetId {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PrsResourceSetId::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PrsResourceSetId");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PrsResourceSetId");
            e
        })
    }
}
// PrsResourceSetList
#[derive(Clone, Debug)]
pub struct PrsResourceSetList(pub NonEmpty<PrsResourceSetItem>);

impl PrsResourceSetList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(8), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(PrsResourceSetItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(8), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for PrsResourceSetList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PrsResourceSetList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PrsResourceSetList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PrsResourceSetList");
            e
        })
    }
}
// PrsResourceSetItem
#[derive(Clone, Debug)]
pub struct PrsResourceSetItem {
    pub prs_resource_set_id: PrsResourceSetId,
    pub subcarrier_spacing: SubcarrierSpacing2,
    pub pr_sbandwidth: u8,
    pub start_prb: u16,
    pub point_a: u32,
    pub comb_size: CombSize,
    pub cp_type: CpType,
    pub resource_set_periodicity: ResourceSetPeriodicity,
    pub resource_set_slot_offset: u32,
    pub resource_repetition_factor: ResourceRepetitionFactor,
    pub resource_time_gap: ResourceTimeGap,
    pub resource_numberof_symbols: ResourceNumberofSymbols,
    pub prs_muting: Option<PrsMuting>,
    pub prs_resource_transmit_power: i8,
    pub prs_resource_list: PrsResourceList,
}

impl PrsResourceSetItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, false, 2)?;
        let prs_resource_set_id = PrsResourceSetId::decode(data)?;
        let subcarrier_spacing = SubcarrierSpacing2::decode(data)?;
        let pr_sbandwidth = decode::decode_integer(data, Some(1), Some(63), false)?.0 as u8;
        let start_prb = decode::decode_integer(data, Some(0), Some(2176), false)?.0 as u16;
        let point_a = decode::decode_integer(data, Some(0), Some(3279165), false)?.0 as u32;
        let comb_size = CombSize::decode(data)?;
        let cp_type = CpType::decode(data)?;
        let resource_set_periodicity = ResourceSetPeriodicity::decode(data)?;
        let resource_set_slot_offset =
            decode::decode_integer(data, Some(0), Some(81919), true)?.0 as u32;
        let resource_repetition_factor = ResourceRepetitionFactor::decode(data)?;
        let resource_time_gap = ResourceTimeGap::decode(data)?;
        let resource_numberof_symbols = ResourceNumberofSymbols::decode(data)?;
        let prs_muting = if optionals[0] {
            Some(PrsMuting::decode(data)?)
        } else {
            None
        };
        let prs_resource_transmit_power =
            decode::decode_integer(data, Some(-60), Some(50), false)?.0 as i8;
        let prs_resource_list = PrsResourceList::decode(data)?;

        // Process the extension container

        if optionals[1] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            prs_resource_set_id,
            subcarrier_spacing,
            pr_sbandwidth,
            start_prb,
            point_a,
            comb_size,
            cp_type,
            resource_set_periodicity,
            resource_set_slot_offset,
            resource_repetition_factor,
            resource_time_gap,
            resource_numberof_symbols,
            prs_muting,
            prs_resource_transmit_power,
            prs_resource_list,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.prs_muting.is_some());
        optionals.push(false);

        encode::encode_sequence_header(data, false, &optionals, false)?;
        self.prs_resource_set_id.encode(data)?;
        self.subcarrier_spacing.encode(data)?;
        encode::encode_integer(
            data,
            Some(1),
            Some(63),
            false,
            self.pr_sbandwidth as i128,
            false,
        )?;
        encode::encode_integer(
            data,
            Some(0),
            Some(2176),
            false,
            self.start_prb as i128,
            false,
        )?;
        encode::encode_integer(
            data,
            Some(0),
            Some(3279165),
            false,
            self.point_a as i128,
            false,
        )?;
        self.comb_size.encode(data)?;
        self.cp_type.encode(data)?;
        self.resource_set_periodicity.encode(data)?;
        encode::encode_integer(
            data,
            Some(0),
            Some(81919),
            true,
            self.resource_set_slot_offset as i128,
            false,
        )?;
        self.resource_repetition_factor.encode(data)?;
        self.resource_time_gap.encode(data)?;
        self.resource_numberof_symbols.encode(data)?;
        if let Some(x) = &self.prs_muting {
            x.encode(data)?;
        }
        encode::encode_integer(
            data,
            Some(-60),
            Some(50),
            false,
            self.prs_resource_transmit_power as i128,
            false,
        )?;
        self.prs_resource_list.encode(data)?;

        Ok(())
    }
}

impl PerCodec for PrsResourceSetItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PrsResourceSetItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PrsResourceSetItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PrsResourceSetItem");
            e
        })
    }
}
// PrsTransmissionOffIndication
#[derive(Clone, Debug)]
pub enum PrsTransmissionOffIndication {
    PrsTransmissionOffPerTrp,
    PrsTransmissionOffPerResourceSet(PrsTransmissionOffPerResourceSet),
    PrsTransmissionOffPerResource(PrsTransmissionOffPerResource),
}

impl PrsTransmissionOffIndication {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_choice_idx(data, 0, 3, false)?;
        if extended {
            return Err(per_codec_error_new("CHOICE additions not implemented"));
        }
        match idx {
            0 => Ok(Self::PrsTransmissionOffPerTrp),
            1 => Ok(Self::PrsTransmissionOffPerResourceSet(
                PrsTransmissionOffPerResourceSet::decode(data)?,
            )),
            2 => Ok(Self::PrsTransmissionOffPerResource(
                PrsTransmissionOffPerResource::decode(data)?,
            )),
            3 => {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _ = Criticality::decode(data)?;
                let _ = decode::decode_length_determinent(data, None, None, false)?;
                let result = match id {
                    x => Err(per_codec_error_new(format!("Unrecognised IE type {}", x))),
                };
                data.decode_align()?;
                result
            }
            _ => Err(per_codec_error_new("Unknown choice idx")),
        }
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        match self {
            Self::PrsTransmissionOffPerTrp => {
                encode::encode_choice_idx(data, 0, 3, false, 0, false)?;
                Ok(())
            }
            Self::PrsTransmissionOffPerResourceSet(x) => {
                encode::encode_choice_idx(data, 0, 3, false, 1, false)?;
                x.encode(data)
            }
            Self::PrsTransmissionOffPerResource(x) => {
                encode::encode_choice_idx(data, 0, 3, false, 2, false)?;
                x.encode(data)
            }
        }
    }
}

impl PerCodec for PrsTransmissionOffIndication {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PrsTransmissionOffIndication::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PrsTransmissionOffIndication");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PrsTransmissionOffIndication");
            e
        })
    }
}
// PrsTransmissionOffPerResource
#[derive(Clone, Debug)]
pub struct PrsTransmissionOffPerResource(pub NonEmpty<PrsTransmissionOffPerResourceItem>);

impl PrsTransmissionOffPerResource {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(8), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(PrsTransmissionOffPerResourceItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(8), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for PrsTransmissionOffPerResource {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PrsTransmissionOffPerResource::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PrsTransmissionOffPerResource");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PrsTransmissionOffPerResource");
            e
        })
    }
}
// PrsTransmissionOffPerResourceItem
#[derive(Clone, Debug)]
pub struct PrsTransmissionOffPerResourceItem {
    pub prs_resource_set_id: PrsResourceSetId,
    pub prs_transmission_off_indication_per_resource_list:
        NonEmpty<PrsTransmissionOffIndicationPerResourceItem>,
}

impl PrsTransmissionOffPerResourceItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let prs_resource_set_id = PrsResourceSetId::decode(data)?;
        let prs_transmission_off_indication_per_resource_list = {
            let length = decode::decode_length_determinent(data, Some(1), Some(64), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(PrsTransmissionOffIndicationPerResourceItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        };

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            prs_resource_set_id,
            prs_transmission_off_indication_per_resource_list,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.prs_resource_set_id.encode(data)?;
        encode::encode_length_determinent(
            data,
            Some(1),
            Some(64),
            false,
            self.prs_transmission_off_indication_per_resource_list.len(),
        )?;
        for x in &self.prs_transmission_off_indication_per_resource_list {
            x.encode(data)?;
        }
        Ok(())?;

        Ok(())
    }
}

impl PerCodec for PrsTransmissionOffPerResourceItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PrsTransmissionOffPerResourceItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PrsTransmissionOffPerResourceItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PrsTransmissionOffPerResourceItem");
            e
        })
    }
}
// PrsTransmissionOffIndicationPerResourceItem
#[derive(Clone, Debug)]
pub struct PrsTransmissionOffIndicationPerResourceItem {
    pub prs_resource_id: PrsResourceId,
}

impl PrsTransmissionOffIndicationPerResourceItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let prs_resource_id = PrsResourceId::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self { prs_resource_id })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.prs_resource_id.encode(data)?;

        Ok(())
    }
}

impl PerCodec for PrsTransmissionOffIndicationPerResourceItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PrsTransmissionOffIndicationPerResourceItem::decode_inner(data).map_err(
            |mut e: PerCodecError| {
                e.push_context("PrsTransmissionOffIndicationPerResourceItem");
                e
            },
        )
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PrsTransmissionOffIndicationPerResourceItem");
            e
        })
    }
}
// PrsTransmissionOffInformation
#[derive(Clone, Debug)]
pub struct PrsTransmissionOffInformation {
    pub prs_transmission_off_indication: PrsTransmissionOffIndication,
}

impl PrsTransmissionOffInformation {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let prs_transmission_off_indication = PrsTransmissionOffIndication::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            prs_transmission_off_indication,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.prs_transmission_off_indication.encode(data)?;

        Ok(())
    }
}

impl PerCodec for PrsTransmissionOffInformation {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PrsTransmissionOffInformation::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PrsTransmissionOffInformation");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PrsTransmissionOffInformation");
            e
        })
    }
}
// PrsTransmissionOffPerResourceSet
#[derive(Clone, Debug)]
pub struct PrsTransmissionOffPerResourceSet(pub NonEmpty<PrsTransmissionOffPerResourceSetItem>);

impl PrsTransmissionOffPerResourceSet {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(8), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(PrsTransmissionOffPerResourceSetItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(8), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for PrsTransmissionOffPerResourceSet {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PrsTransmissionOffPerResourceSet::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PrsTransmissionOffPerResourceSet");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PrsTransmissionOffPerResourceSet");
            e
        })
    }
}
// PrsTransmissionOffPerResourceSetItem
#[derive(Clone, Debug)]
pub struct PrsTransmissionOffPerResourceSetItem {
    pub prs_resource_set_id: PrsResourceSetId,
}

impl PrsTransmissionOffPerResourceSetItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let prs_resource_set_id = PrsResourceSetId::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            prs_resource_set_id,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.prs_resource_set_id.encode(data)?;

        Ok(())
    }
}

impl PerCodec for PrsTransmissionOffPerResourceSetItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PrsTransmissionOffPerResourceSetItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PrsTransmissionOffPerResourceSetItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PrsTransmissionOffPerResourceSetItem");
            e
        })
    }
}
// PwsFailedNrCgiItem
#[derive(Clone, Debug)]
pub struct PwsFailedNrCgiItem {
    pub nr_cgi: NrCgi,
    pub number_of_broadcasts: NumberOfBroadcasts,
}

impl PwsFailedNrCgiItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let nr_cgi = NrCgi::decode(data)?;
        let number_of_broadcasts = NumberOfBroadcasts::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            nr_cgi,
            number_of_broadcasts,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.nr_cgi.encode(data)?;
        self.number_of_broadcasts.encode(data)?;

        Ok(())
    }
}

impl PerCodec for PwsFailedNrCgiItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PwsFailedNrCgiItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PwsFailedNrCgiItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PwsFailedNrCgiItem");
            e
        })
    }
}
// PwsSystemInformation
#[derive(Clone, Debug)]
pub struct PwsSystemInformation {
    pub sib_type: SibTypePws,
    pub sib_message: Vec<u8>,
    pub notification_information: Option<NotificationInformation>,
    pub additional_sib_message_list: Option<AdditionalSibMessageList>,
}

impl PwsSystemInformation {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let sib_type = SibTypePws::decode(data)?;
        let sib_message = decode::decode_octetstring(data, None, None, false)?;

        // Process the extension container
        let mut notification_information: Option<NotificationInformation> = None;
        let mut additional_sib_message_list: Option<AdditionalSibMessageList> = None;

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    220 => notification_information = Some(NotificationInformation::decode(data)?),
                    231 => {
                        additional_sib_message_list = Some(AdditionalSibMessageList::decode(data)?)
                    }
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            sib_type,
            sib_message,
            notification_information,
            additional_sib_message_list,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();
        if let Some(x) = &self.notification_information {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 220, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.additional_sib_message_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 231, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        let mut optionals = BitString::new();
        optionals.push(num_ies != 0);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.sib_type.encode(data)?;
        encode::encode_octetstring(data, None, None, false, &self.sib_message, false)?;
        if num_ies != 0 {
            encode::encode_length_determinent(data, Some(1), Some(65535), false, num_ies)?;
            data.append_aligned(ies);
        }
        Ok(())
    }
}

impl PerCodec for PwsSystemInformation {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PwsSystemInformation::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PwsSystemInformation");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PwsSystemInformation");
            e
        })
    }
}
// PrivacyIndicator
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum PrivacyIndicator {
    ImmediateMdt,
    LoggedMdt,
}

impl PrivacyIndicator {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(1), true)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(1),
            true,
            *self as i128,
            (*self as u32) >= 2,
        )
    }
}

impl PerCodec for PrivacyIndicator {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PrivacyIndicator::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PrivacyIndicator");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PrivacyIndicator");
            e
        })
    }
}
// PrstrpList
#[derive(Clone, Debug)]
pub struct PrstrpList(pub NonEmpty<PrstrpItem>);

impl PrstrpList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(PrstrpItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(65535), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for PrstrpList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PrstrpList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PrstrpList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PrstrpList");
            e
        })
    }
}
// PrstrpItem
#[derive(Clone, Debug)]
pub struct PrstrpItem {
    pub trp_id: Trpid,
    pub requested_dl_prs_transmission_characteristics:
        Option<RequestedDlPrsTransmissionCharacteristics>,
    pub prs_transmission_off_information: Option<PrsTransmissionOffInformation>,
}

impl PrstrpItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 3)?;
        let trp_id = Trpid::decode(data)?;
        let requested_dl_prs_transmission_characteristics = if optionals[0] {
            Some(RequestedDlPrsTransmissionCharacteristics::decode(data)?)
        } else {
            None
        };
        let prs_transmission_off_information = if optionals[1] {
            Some(PrsTransmissionOffInformation::decode(data)?)
        } else {
            None
        };

        // Process the extension container

        if optionals[2] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            trp_id,
            requested_dl_prs_transmission_characteristics,
            prs_transmission_off_information,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.requested_dl_prs_transmission_characteristics.is_some());
        optionals.push(self.prs_transmission_off_information.is_some());
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.trp_id.encode(data)?;
        if let Some(x) = &self.requested_dl_prs_transmission_characteristics {
            x.encode(data)?;
        }
        if let Some(x) = &self.prs_transmission_off_information {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl PerCodec for PrstrpItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PrstrpItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PrstrpItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PrstrpItem");
            e
        })
    }
}
// RequestedDlPrsTransmissionCharacteristics
#[derive(Clone, Debug)]
pub struct RequestedDlPrsTransmissionCharacteristics {
    pub requested_dl_prs_resource_set_list: RequestedDlPrsResourceSetList,
    pub numberof_frequency_layers: Option<u8>,
    pub start_time_and_duration: Option<StartTimeAndDuration>,
    pub prsbw_aggregation_request_info_list: Option<PrsbwAggregationRequestInfoList>,
}

impl RequestedDlPrsTransmissionCharacteristics {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 3)?;
        let requested_dl_prs_resource_set_list = RequestedDlPrsResourceSetList::decode(data)?;
        let numberof_frequency_layers = if optionals[0] {
            Some(decode::decode_integer(data, Some(1), Some(4), false)?.0 as u8)
        } else {
            None
        };
        let start_time_and_duration = if optionals[1] {
            Some(StartTimeAndDuration::decode(data)?)
        } else {
            None
        };

        // Process the extension container
        let mut prsbw_aggregation_request_info_list: Option<PrsbwAggregationRequestInfoList> = None;

        if optionals[2] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    815 => {
                        prsbw_aggregation_request_info_list =
                            Some(PrsbwAggregationRequestInfoList::decode(data)?)
                    }
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            requested_dl_prs_resource_set_list,
            numberof_frequency_layers,
            start_time_and_duration,
            prsbw_aggregation_request_info_list,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();
        if let Some(x) = &self.prsbw_aggregation_request_info_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 815, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        let mut optionals = BitString::new();
        optionals.push(self.numberof_frequency_layers.is_some());
        optionals.push(self.start_time_and_duration.is_some());
        optionals.push(num_ies != 0);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.requested_dl_prs_resource_set_list.encode(data)?;
        if let Some(x) = &self.numberof_frequency_layers {
            encode::encode_integer(data, Some(1), Some(4), false, *x as i128, false)?;
        }
        if let Some(x) = &self.start_time_and_duration {
            x.encode(data)?;
        }
        if num_ies != 0 {
            encode::encode_length_determinent(data, Some(1), Some(65535), false, num_ies)?;
            data.append_aligned(ies);
        }
        Ok(())
    }
}

impl PerCodec for RequestedDlPrsTransmissionCharacteristics {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        RequestedDlPrsTransmissionCharacteristics::decode_inner(data).map_err(
            |mut e: PerCodecError| {
                e.push_context("RequestedDlPrsTransmissionCharacteristics");
                e
            },
        )
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("RequestedDlPrsTransmissionCharacteristics");
            e
        })
    }
}
// RequestedDlPrsResourceSetList
#[derive(Clone, Debug)]
pub struct RequestedDlPrsResourceSetList(pub NonEmpty<RequestedDlPrsResourceSetItem>);

impl RequestedDlPrsResourceSetList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(8), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(RequestedDlPrsResourceSetItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(8), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for RequestedDlPrsResourceSetList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        RequestedDlPrsResourceSetList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("RequestedDlPrsResourceSetList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("RequestedDlPrsResourceSetList");
            e
        })
    }
}
// RequestedDlPrsResourceSetItem
#[derive(Clone, Debug)]
pub struct RequestedDlPrsResourceSetItem {
    pub pr_sbandwidth: Option<u8>,
    pub comb_size: Option<CombSize1>,
    pub resource_set_periodicity: Option<ResourceSetPeriodicity1>,
    pub resource_repetition_factor: Option<ResourceRepetitionFactor1>,
    pub resource_numberof_symbols: Option<ResourceNumberofSymbols1>,
    pub requested_dl_prs_resource_list: Option<RequestedDlPrsResourceList>,
    pub resource_set_start_time_and_duration: Option<StartTimeAndDuration>,
}

impl RequestedDlPrsResourceSetItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 8)?;
        let pr_sbandwidth = if optionals[0] {
            Some(decode::decode_integer(data, Some(1), Some(63), false)?.0 as u8)
        } else {
            None
        };
        let comb_size = if optionals[1] {
            Some(CombSize1::decode(data)?)
        } else {
            None
        };
        let resource_set_periodicity = if optionals[2] {
            Some(ResourceSetPeriodicity1::decode(data)?)
        } else {
            None
        };
        let resource_repetition_factor = if optionals[3] {
            Some(ResourceRepetitionFactor1::decode(data)?)
        } else {
            None
        };
        let resource_numberof_symbols = if optionals[4] {
            Some(ResourceNumberofSymbols1::decode(data)?)
        } else {
            None
        };
        let requested_dl_prs_resource_list = if optionals[5] {
            Some(RequestedDlPrsResourceList::decode(data)?)
        } else {
            None
        };
        let resource_set_start_time_and_duration = if optionals[6] {
            Some(StartTimeAndDuration::decode(data)?)
        } else {
            None
        };

        // Process the extension container

        if optionals[7] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            pr_sbandwidth,
            comb_size,
            resource_set_periodicity,
            resource_repetition_factor,
            resource_numberof_symbols,
            requested_dl_prs_resource_list,
            resource_set_start_time_and_duration,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.pr_sbandwidth.is_some());
        optionals.push(self.comb_size.is_some());
        optionals.push(self.resource_set_periodicity.is_some());
        optionals.push(self.resource_repetition_factor.is_some());
        optionals.push(self.resource_numberof_symbols.is_some());
        optionals.push(self.requested_dl_prs_resource_list.is_some());
        optionals.push(self.resource_set_start_time_and_duration.is_some());
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        if let Some(x) = &self.pr_sbandwidth {
            encode::encode_integer(data, Some(1), Some(63), false, *x as i128, false)?;
        }
        if let Some(x) = &self.comb_size {
            x.encode(data)?;
        }
        if let Some(x) = &self.resource_set_periodicity {
            x.encode(data)?;
        }
        if let Some(x) = &self.resource_repetition_factor {
            x.encode(data)?;
        }
        if let Some(x) = &self.resource_numberof_symbols {
            x.encode(data)?;
        }
        if let Some(x) = &self.requested_dl_prs_resource_list {
            x.encode(data)?;
        }
        if let Some(x) = &self.resource_set_start_time_and_duration {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl PerCodec for RequestedDlPrsResourceSetItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        RequestedDlPrsResourceSetItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("RequestedDlPrsResourceSetItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("RequestedDlPrsResourceSetItem");
            e
        })
    }
}
// RequestedDlPrsResourceList
#[derive(Clone, Debug)]
pub struct RequestedDlPrsResourceList(pub NonEmpty<RequestedDlPrsResourceItem>);

impl RequestedDlPrsResourceList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(64), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(RequestedDlPrsResourceItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(64), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for RequestedDlPrsResourceList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        RequestedDlPrsResourceList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("RequestedDlPrsResourceList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("RequestedDlPrsResourceList");
            e
        })
    }
}
// RequestedDlPrsResourceItem
#[derive(Clone, Debug)]
pub struct RequestedDlPrsResourceItem {
    pub qcl_info: Option<PrsResourceQclInfo>,
}

impl RequestedDlPrsResourceItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 2)?;
        let qcl_info = if optionals[0] {
            Some(PrsResourceQclInfo::decode(data)?)
        } else {
            None
        };

        // Process the extension container

        if optionals[1] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self { qcl_info })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.qcl_info.is_some());
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        if let Some(x) = &self.qcl_info {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl PerCodec for RequestedDlPrsResourceItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        RequestedDlPrsResourceItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("RequestedDlPrsResourceItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("RequestedDlPrsResourceItem");
            e
        })
    }
}
// PrsTransmissionTrpList
#[derive(Clone, Debug)]
pub struct PrsTransmissionTrpList(pub NonEmpty<PrsTransmissionTrpItem>);

impl PrsTransmissionTrpList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(PrsTransmissionTrpItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(65535), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for PrsTransmissionTrpList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PrsTransmissionTrpList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PrsTransmissionTrpList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PrsTransmissionTrpList");
            e
        })
    }
}
// PrsTransmissionTrpItem
#[derive(Clone, Debug)]
pub struct PrsTransmissionTrpItem {
    pub trp_id: Trpid,
    pub prs_configuration: PrsConfiguration,
}

impl PrsTransmissionTrpItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let trp_id = Trpid::decode(data)?;
        let prs_configuration = PrsConfiguration::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            trp_id,
            prs_configuration,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.trp_id.encode(data)?;
        self.prs_configuration.encode(data)?;

        Ok(())
    }
}

impl PerCodec for PrsTransmissionTrpItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PrsTransmissionTrpItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PrsTransmissionTrpItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PrsTransmissionTrpItem");
            e
        })
    }
}
// PreambleIndex
#[derive(Clone, Copy, Debug)]
pub struct PreambleIndex(pub u8);

impl PreambleIndex {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(
            decode::decode_integer(data, Some(0), Some(63), false)?.0 as u8,
        ))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_integer(data, Some(0), Some(63), false, self.0 as i128, false)
    }
}

impl PerCodec for PreambleIndex {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PreambleIndex::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PreambleIndex");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PreambleIndex");
            e
        })
    }
}
// PduSetQosParameters
#[derive(Clone, Debug)]
pub struct PduSetQosParameters {
    pub ul_pdu_set_qos_information: Option<PduSetQosInformation>,
    pub dl_pdu_set_qos_information: Option<PduSetQosInformation>,
}

impl PduSetQosParameters {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, false, 3)?;
        let ul_pdu_set_qos_information = if optionals[0] {
            Some(PduSetQosInformation::decode(data)?)
        } else {
            None
        };
        let dl_pdu_set_qos_information = if optionals[1] {
            Some(PduSetQosInformation::decode(data)?)
        } else {
            None
        };

        // Process the extension container

        if optionals[2] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            ul_pdu_set_qos_information,
            dl_pdu_set_qos_information,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.ul_pdu_set_qos_information.is_some());
        optionals.push(self.dl_pdu_set_qos_information.is_some());
        optionals.push(false);

        encode::encode_sequence_header(data, false, &optionals, false)?;
        if let Some(x) = &self.ul_pdu_set_qos_information {
            x.encode(data)?;
        }
        if let Some(x) = &self.dl_pdu_set_qos_information {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl PerCodec for PduSetQosParameters {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PduSetQosParameters::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PduSetQosParameters");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PduSetQosParameters");
            e
        })
    }
}
// PduSetQosInformation
#[derive(Clone, Debug)]
pub struct PduSetQosInformation {
    pub pdu_set_delay_budget: Option<ExtendedPacketDelayBudget>,
    pub pdu_set_error_rate: Option<PacketErrorRate>,
    pub pdu_set_integrated_handling_information: Option<PduSetIntegratedHandlingInformation>,
}

impl PduSetQosInformation {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, false, 4)?;
        let pdu_set_delay_budget = if optionals[0] {
            Some(ExtendedPacketDelayBudget::decode(data)?)
        } else {
            None
        };
        let pdu_set_error_rate = if optionals[1] {
            Some(PacketErrorRate::decode(data)?)
        } else {
            None
        };
        let pdu_set_integrated_handling_information = if optionals[2] {
            Some(PduSetIntegratedHandlingInformation::decode(data)?)
        } else {
            None
        };

        // Process the extension container

        if optionals[3] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            pdu_set_delay_budget,
            pdu_set_error_rate,
            pdu_set_integrated_handling_information,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.pdu_set_delay_budget.is_some());
        optionals.push(self.pdu_set_error_rate.is_some());
        optionals.push(self.pdu_set_integrated_handling_information.is_some());
        optionals.push(false);

        encode::encode_sequence_header(data, false, &optionals, false)?;
        if let Some(x) = &self.pdu_set_delay_budget {
            x.encode(data)?;
        }
        if let Some(x) = &self.pdu_set_error_rate {
            x.encode(data)?;
        }
        if let Some(x) = &self.pdu_set_integrated_handling_information {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl PerCodec for PduSetQosInformation {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PduSetQosInformation::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PduSetQosInformation");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PduSetQosInformation");
            e
        })
    }
}
// PSibAsedSDuDiscardUl
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum PSibAsedSDuDiscardUl {
    Start,
    Stop,
}

impl PSibAsedSDuDiscardUl {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(1), true)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(1),
            true,
            *self as i128,
            (*self as u32) >= 2,
        )
    }
}

impl PerCodec for PSibAsedSDuDiscardUl {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PSibAsedSDuDiscardUl::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PSibAsedSDuDiscardUl");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PSibAsedSDuDiscardUl");
            e
        })
    }
}
// PointA
#[derive(Clone, Copy, Debug)]
pub struct PointA(pub u32);

impl PointA {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(
            decode::decode_integer(data, Some(0), Some(3279165), false)?.0 as u32,
        ))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_integer(data, Some(0), Some(3279165), false, self.0 as i128, false)
    }
}

impl PerCodec for PointA {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PointA::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PointA");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PointA");
            e
        })
    }
}
// Qci
#[derive(Clone, Copy, Debug)]
pub struct Qci(pub u8);

impl Qci {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(
            decode::decode_integer(data, Some(0), Some(255), false)?.0 as u8,
        ))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_integer(data, Some(0), Some(255), false, self.0 as i128, false)
    }
}

impl PerCodec for Qci {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Qci::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("Qci");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("Qci");
            e
        })
    }
}
// QoEInformation
#[derive(Clone, Debug)]
pub struct QoEInformation {
    pub qo_e_information_list: QoEInformationList,
}

impl QoEInformation {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, false, 1)?;
        let qo_e_information_list = QoEInformationList::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            qo_e_information_list,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, false, &optionals, false)?;
        self.qo_e_information_list.encode(data)?;

        Ok(())
    }
}

impl PerCodec for QoEInformation {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        QoEInformation::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("QoEInformation");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("QoEInformation");
            e
        })
    }
}
// QoEInformationList
#[derive(Clone, Debug)]
pub struct QoEInformationList(pub NonEmpty<QoEInformationListItem>);

impl QoEInformationList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(16), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(QoEInformationListItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(16), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for QoEInformationList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        QoEInformationList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("QoEInformationList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("QoEInformationList");
            e
        })
    }
}
// QoEInformationListItem
#[derive(Clone, Debug)]
pub struct QoEInformationListItem {
    pub qo_e_metrics: Option<QoEMetrics>,
    pub drb_list: Option<DrbList>,
}

impl QoEInformationListItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, false, 2)?;
        let qo_e_metrics = if optionals[0] {
            Some(QoEMetrics::decode(data)?)
        } else {
            None
        };

        // Process the extension container
        let mut drb_list: Option<DrbList> = None;

        if optionals[1] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    732 => drb_list = Some(DrbList::decode(data)?),
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            qo_e_metrics,
            drb_list,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();
        if let Some(x) = &self.drb_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 732, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        let mut optionals = BitString::new();
        optionals.push(self.qo_e_metrics.is_some());
        optionals.push(num_ies != 0);

        encode::encode_sequence_header(data, false, &optionals, false)?;
        if let Some(x) = &self.qo_e_metrics {
            x.encode(data)?;
        }
        if num_ies != 0 {
            encode::encode_length_determinent(data, Some(1), Some(65535), false, num_ies)?;
            data.append_aligned(ies);
        }
        Ok(())
    }
}

impl PerCodec for QoEInformationListItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        QoEInformationListItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("QoEInformationListItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("QoEInformationListItem");
            e
        })
    }
}
// QoEMetrics
#[derive(Clone, Debug)]
pub struct QoEMetrics {
    pub app_layer_buffer_level_list: Option<AppLayerBufferLevelList>,
    pub playout_delay_for_media_startup: Option<PlayoutDelayForMediaStartup>,
}

impl QoEMetrics {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 3)?;
        let app_layer_buffer_level_list = if optionals[0] {
            Some(AppLayerBufferLevelList::decode(data)?)
        } else {
            None
        };
        let playout_delay_for_media_startup = if optionals[1] {
            Some(PlayoutDelayForMediaStartup::decode(data)?)
        } else {
            None
        };

        // Process the extension container

        if optionals[2] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            app_layer_buffer_level_list,
            playout_delay_for_media_startup,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.app_layer_buffer_level_list.is_some());
        optionals.push(self.playout_delay_for_media_startup.is_some());
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        if let Some(x) = &self.app_layer_buffer_level_list {
            x.encode(data)?;
        }
        if let Some(x) = &self.playout_delay_for_media_startup {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl PerCodec for QoEMetrics {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        QoEMetrics::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("QoEMetrics");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("QoEMetrics");
            e
        })
    }
}
// QosCharacteristics
#[derive(Clone, Debug)]
pub enum QosCharacteristics {
    NonDynamic5qi(NonDynamic5qiDescriptor),
    Dynamic5qi(Dynamic5qiDescriptor),
}

impl QosCharacteristics {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_choice_idx(data, 0, 2, false)?;
        if extended {
            return Err(per_codec_error_new("CHOICE additions not implemented"));
        }
        match idx {
            0 => Ok(Self::NonDynamic5qi(NonDynamic5qiDescriptor::decode(data)?)),
            1 => Ok(Self::Dynamic5qi(Dynamic5qiDescriptor::decode(data)?)),
            2 => {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _ = Criticality::decode(data)?;
                let _ = decode::decode_length_determinent(data, None, None, false)?;
                let result = match id {
                    x => Err(per_codec_error_new(format!("Unrecognised IE type {}", x))),
                };
                data.decode_align()?;
                result
            }
            _ => Err(per_codec_error_new("Unknown choice idx")),
        }
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        match self {
            Self::NonDynamic5qi(x) => {
                encode::encode_choice_idx(data, 0, 2, false, 0, false)?;
                x.encode(data)
            }
            Self::Dynamic5qi(x) => {
                encode::encode_choice_idx(data, 0, 2, false, 1, false)?;
                x.encode(data)
            }
        }
    }
}

impl PerCodec for QosCharacteristics {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        QosCharacteristics::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("QosCharacteristics");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("QosCharacteristics");
            e
        })
    }
}
// QosFlowIdentifier
#[derive(Clone, Copy, Debug)]
pub struct QosFlowIdentifier(pub u8);

impl QosFlowIdentifier {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(
            decode::decode_integer(data, Some(0), Some(63), false)?.0 as u8,
        ))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_integer(data, Some(0), Some(63), false, self.0 as i128, false)
    }
}

impl PerCodec for QosFlowIdentifier {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        QosFlowIdentifier::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("QosFlowIdentifier");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("QosFlowIdentifier");
            e
        })
    }
}
// QosFlowLevelQosParameters
#[derive(Clone, Debug)]
pub struct QosFlowLevelQosParameters {
    pub qos_characteristics: QosCharacteristics,
    pub ngran_allocation_retention_priority: NgranAllocationAndRetentionPriority,
    pub gbr_qos_flow_information: Option<GbrQosFlowInformation>,
    pub reflective_qos_attribute: Option<ReflectiveQosAttribute>,
    pub pdu_session_id: Option<PduSessionId>,
    pub ulpdu_session_aggregate_maximum_bit_rate: Option<BitRate>,
    pub qos_monitoring_request: Option<QosMonitoringRequest>,
    pub pdcp_terminating_node_dl_tnl_addr_info: Option<TransportLayerAddress>,
    pub pdu_set_qos_parameters: Option<PduSetQosParameters>,
}

impl QosFlowLevelQosParameters {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, false, 3)?;
        let qos_characteristics = QosCharacteristics::decode(data)?;
        let ngran_allocation_retention_priority =
            NgranAllocationAndRetentionPriority::decode(data)?;
        let gbr_qos_flow_information = if optionals[0] {
            Some(GbrQosFlowInformation::decode(data)?)
        } else {
            None
        };
        let reflective_qos_attribute = if optionals[1] {
            Some(ReflectiveQosAttribute::decode(data)?)
        } else {
            None
        };

        // Process the extension container
        let mut pdu_session_id: Option<PduSessionId> = None;
        let mut ulpdu_session_aggregate_maximum_bit_rate: Option<BitRate> = None;
        let mut qos_monitoring_request: Option<QosMonitoringRequest> = None;
        let mut pdcp_terminating_node_dl_tnl_addr_info: Option<TransportLayerAddress> = None;
        let mut pdu_set_qos_parameters: Option<PduSetQosParameters> = None;

        if optionals[2] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    180 => pdu_session_id = Some(PduSessionId::decode(data)?),
                    181 => ulpdu_session_aggregate_maximum_bit_rate = Some(BitRate::decode(data)?),
                    257 => qos_monitoring_request = Some(QosMonitoringRequest::decode(data)?),
                    436 => {
                        pdcp_terminating_node_dl_tnl_addr_info =
                            Some(TransportLayerAddress::decode(data)?)
                    }
                    775 => pdu_set_qos_parameters = Some(PduSetQosParameters::decode(data)?),
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            qos_characteristics,
            ngran_allocation_retention_priority,
            gbr_qos_flow_information,
            reflective_qos_attribute,
            pdu_session_id,
            ulpdu_session_aggregate_maximum_bit_rate,
            qos_monitoring_request,
            pdcp_terminating_node_dl_tnl_addr_info,
            pdu_set_qos_parameters,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();
        if let Some(x) = &self.pdu_session_id {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 180, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.ulpdu_session_aggregate_maximum_bit_rate {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 181, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.qos_monitoring_request {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 257, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.pdcp_terminating_node_dl_tnl_addr_info {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 436, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.pdu_set_qos_parameters {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 775, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        let mut optionals = BitString::new();
        optionals.push(self.gbr_qos_flow_information.is_some());
        optionals.push(self.reflective_qos_attribute.is_some());
        optionals.push(num_ies != 0);

        encode::encode_sequence_header(data, false, &optionals, false)?;
        self.qos_characteristics.encode(data)?;
        self.ngran_allocation_retention_priority.encode(data)?;
        if let Some(x) = &self.gbr_qos_flow_information {
            x.encode(data)?;
        }
        if let Some(x) = &self.reflective_qos_attribute {
            x.encode(data)?;
        }
        if num_ies != 0 {
            encode::encode_length_determinent(data, Some(1), Some(65535), false, num_ies)?;
            data.append_aligned(ies);
        }
        Ok(())
    }
}

impl PerCodec for QosFlowLevelQosParameters {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        QosFlowLevelQosParameters::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("QosFlowLevelQosParameters");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("QosFlowLevelQosParameters");
            e
        })
    }
}
// QosFlowMappingIndication
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum QosFlowMappingIndication {
    Ul,
    Dl,
}

impl QosFlowMappingIndication {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(1), true)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(1),
            true,
            *self as i128,
            (*self as u32) >= 2,
        )
    }
}

impl PerCodec for QosFlowMappingIndication {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        QosFlowMappingIndication::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("QosFlowMappingIndication");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("QosFlowMappingIndication");
            e
        })
    }
}
// QosInformation
#[derive(Clone, Debug)]
pub enum QosInformation {
    EutranQos(EutranQos),
    DrbInformation(DrbInformation),
}

impl QosInformation {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_choice_idx(data, 0, 1, false)?;
        if extended {
            return Err(per_codec_error_new("CHOICE additions not implemented"));
        }
        match idx {
            0 => Ok(Self::EutranQos(EutranQos::decode(data)?)),
            1 => {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _ = Criticality::decode(data)?;
                let _ = decode::decode_length_determinent(data, None, None, false)?;
                let result = match id {
                    164 => Ok(Self::DrbInformation(DrbInformation::decode(data)?)),
                    x => Err(per_codec_error_new(format!("Unrecognised IE type {}", x))),
                };
                data.decode_align()?;
                result
            }
            _ => Err(per_codec_error_new("Unknown choice idx")),
        }
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        match self {
            Self::EutranQos(x) => {
                encode::encode_choice_idx(data, 0, 1, false, 0, false)?;
                x.encode(data)
            }
            Self::DrbInformation(x) => {
                encode::encode_choice_idx(data, 0, 1, false, 1, false)?;
                encode::encode_integer(data, Some(0), Some(65535), false, 164, false)?;
                Criticality::Ignore.encode(data)?;
                let ie = &mut Allocator::new_codec_data();
                x.encode(ie)?;
                encode::encode_length_determinent(data, None, None, false, ie.length_in_bytes())?;
                Ok(data.append_aligned(ie))
            }
        }
    }
}

impl PerCodec for QosInformation {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        QosInformation::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("QosInformation");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("QosInformation");
            e
        })
    }
}
// QosMonitoringRequest
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum QosMonitoringRequest {
    Ul,
    Dl,
    Both,
    Stop,
}

impl QosMonitoringRequest {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(2), true)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(2),
            true,
            *self as i128,
            (*self as u32) >= 3,
        )
    }
}

impl PerCodec for QosMonitoringRequest {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        QosMonitoringRequest::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("QosMonitoringRequest");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("QosMonitoringRequest");
            e
        })
    }
}
// QosParaSetIndex
#[derive(Clone, Copy, Debug)]
pub struct QosParaSetIndex(pub u8);

impl QosParaSetIndex {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(
            decode::decode_integer(data, Some(1), Some(8), true)?.0 as u8,
        ))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_integer(data, Some(1), Some(8), true, self.0 as i128, false)
    }
}

impl PerCodec for QosParaSetIndex {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        QosParaSetIndex::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("QosParaSetIndex");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("QosParaSetIndex");
            e
        })
    }
}
// QosParaSetNotifyIndex
#[derive(Clone, Copy, Debug)]
pub struct QosParaSetNotifyIndex(pub u8);

impl QosParaSetNotifyIndex {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(
            decode::decode_integer(data, Some(0), Some(8), true)?.0 as u8,
        ))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_integer(data, Some(0), Some(8), true, self.0 as i128, false)
    }
}

impl PerCodec for QosParaSetNotifyIndex {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        QosParaSetNotifyIndex::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("QosParaSetNotifyIndex");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("QosParaSetNotifyIndex");
            e
        })
    }
}
// RachConfigCommon
#[derive(Clone, Debug)]
pub struct RachConfigCommon(pub Vec<u8>);

impl RachConfigCommon {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(decode::decode_octetstring(data, None, None, false)?))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_octetstring(data, None, None, false, &self.0, false)
    }
}

impl PerCodec for RachConfigCommon {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        RachConfigCommon::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("RachConfigCommon");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("RachConfigCommon");
            e
        })
    }
}
// RachConfigCommonIab
#[derive(Clone, Debug)]
pub struct RachConfigCommonIab(pub Vec<u8>);

impl RachConfigCommonIab {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(decode::decode_octetstring(data, None, None, false)?))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_octetstring(data, None, None, false, &self.0, false)
    }
}

impl PerCodec for RachConfigCommonIab {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        RachConfigCommonIab::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("RachConfigCommonIab");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("RachConfigCommonIab");
            e
        })
    }
}
// Range
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum Range {
    M50,
    M80,
    M180,
    M200,
    M350,
    M400,
    M500,
    M700,
    M1000,
}

impl Range {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(8), true)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(8),
            true,
            *self as i128,
            (*self as u32) >= 9,
        )
    }
}

impl PerCodec for Range {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Range::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("Range");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("Range");
            e
        })
    }
}
// RaReportContainer
#[derive(Clone, Debug)]
pub struct RaReportContainer(pub Vec<u8>);

impl RaReportContainer {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(decode::decode_octetstring(data, None, None, false)?))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_octetstring(data, None, None, false, &self.0, false)
    }
}

impl PerCodec for RaReportContainer {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        RaReportContainer::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("RaReportContainer");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("RaReportContainer");
            e
        })
    }
}
// RaReportList
#[derive(Clone, Debug)]
pub struct RaReportList(pub NonEmpty<RaReportItem>);

impl RaReportList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(64), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(RaReportItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(64), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for RaReportList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        RaReportList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("RaReportList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("RaReportList");
            e
        })
    }
}
// RaReportItem
#[derive(Clone, Debug)]
pub struct RaReportItem {
    pub ra_report_container: RaReportContainer,
    pub ue_assitant_identifier: Option<GnbDuUeF1apId>,
}

impl RaReportItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 2)?;
        let ra_report_container = RaReportContainer::decode(data)?;
        let ue_assitant_identifier = if optionals[0] {
            Some(GnbDuUeF1apId::decode(data)?)
        } else {
            None
        };

        // Process the extension container

        if optionals[1] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            ra_report_container,
            ue_assitant_identifier,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.ue_assitant_identifier.is_some());
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.ra_report_container.encode(data)?;
        if let Some(x) = &self.ue_assitant_identifier {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl PerCodec for RaReportItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        RaReportItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("RaReportItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("RaReportItem");
            e
        })
    }
}
// RaReportIndicationList
#[derive(Clone, Debug)]
pub struct RaReportIndicationList(pub NonEmpty<RaReportIndicationListItem>);

impl RaReportIndicationList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(64), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(RaReportIndicationListItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(64), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for RaReportIndicationList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        RaReportIndicationList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("RaReportIndicationList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("RaReportIndicationList");
            e
        })
    }
}
// RaReportIndicationListItem
#[derive(Clone, Debug)]
pub struct RaReportIndicationListItem {
    pub gnb_cu_ue_f1ap_id: GnbCuUeF1apId,
}

impl RaReportIndicationListItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let gnb_cu_ue_f1ap_id = GnbCuUeF1apId::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self { gnb_cu_ue_f1ap_id })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.gnb_cu_ue_f1ap_id.encode(data)?;

        Ok(())
    }
}

impl PerCodec for RaReportIndicationListItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        RaReportIndicationListItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("RaReportIndicationListItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("RaReportIndicationListItem");
            e
        })
    }
}
// RadioResourceStatus
#[derive(Clone, Debug)]
pub struct RadioResourceStatus {
    pub ssb_area_radio_resource_status_list: SsbAreaRadioResourceStatusList,
    pub slice_radio_resource_status: Option<SliceRadioResourceStatus>,
    pub mimopr_busage_information: Option<MimoprBusageInformation>,
}

impl RadioResourceStatus {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, false, 1)?;
        let ssb_area_radio_resource_status_list = SsbAreaRadioResourceStatusList::decode(data)?;

        // Process the extension container
        let mut slice_radio_resource_status: Option<SliceRadioResourceStatus> = None;
        let mut mimopr_busage_information: Option<MimoprBusageInformation> = None;

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    441 => {
                        slice_radio_resource_status = Some(SliceRadioResourceStatus::decode(data)?)
                    }
                    450 => mimopr_busage_information = Some(MimoprBusageInformation::decode(data)?),
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            ssb_area_radio_resource_status_list,
            slice_radio_resource_status,
            mimopr_busage_information,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();
        if let Some(x) = &self.slice_radio_resource_status {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 441, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.mimopr_busage_information {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 450, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        let mut optionals = BitString::new();
        optionals.push(num_ies != 0);

        encode::encode_sequence_header(data, false, &optionals, false)?;
        self.ssb_area_radio_resource_status_list.encode(data)?;
        if num_ies != 0 {
            encode::encode_length_determinent(data, Some(1), Some(65535), false, num_ies)?;
            data.append_aligned(ies);
        }
        Ok(())
    }
}

impl PerCodec for RadioResourceStatus {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        RadioResourceStatus::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("RadioResourceStatus");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("RadioResourceStatus");
            e
        })
    }
}
// RadioResourceStatusNrU
#[derive(Clone, Debug)]
pub struct RadioResourceStatusNrU {
    pub dl_total_prb_usage: u8,
    pub ul_total_prb_usage: u8,
}

impl RadioResourceStatusNrU {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let dl_total_prb_usage = decode::decode_integer(data, Some(0), Some(100), false)?.0 as u8;
        let ul_total_prb_usage = decode::decode_integer(data, Some(0), Some(100), false)?.0 as u8;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            dl_total_prb_usage,
            ul_total_prb_usage,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        encode::encode_integer(
            data,
            Some(0),
            Some(100),
            false,
            self.dl_total_prb_usage as i128,
            false,
        )?;
        encode::encode_integer(
            data,
            Some(0),
            Some(100),
            false,
            self.ul_total_prb_usage as i128,
            false,
        )?;

        Ok(())
    }
}

impl PerCodec for RadioResourceStatusNrU {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        RadioResourceStatusNrU::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("RadioResourceStatusNrU");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("RadioResourceStatusNrU");
            e
        })
    }
}
// MimoprBusageInformation
#[derive(Clone, Debug)]
pub struct MimoprBusageInformation {
    pub dl_gbr_prb_usage_for_mimo: u8,
    pub ul_gbr_prb_usage_for_mimo: u8,
    pub dl_non_gbr_prb_usage_for_mimo: u8,
    pub ul_non_gbr_prb_usage_for_mimo: u8,
    pub dl_total_prb_usage_for_mimo: u8,
    pub ul_total_prb_usage_for_mimo: u8,
}

impl MimoprBusageInformation {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let dl_gbr_prb_usage_for_mimo =
            decode::decode_integer(data, Some(0), Some(100), false)?.0 as u8;
        let ul_gbr_prb_usage_for_mimo =
            decode::decode_integer(data, Some(0), Some(100), false)?.0 as u8;
        let dl_non_gbr_prb_usage_for_mimo =
            decode::decode_integer(data, Some(0), Some(100), false)?.0 as u8;
        let ul_non_gbr_prb_usage_for_mimo =
            decode::decode_integer(data, Some(0), Some(100), false)?.0 as u8;
        let dl_total_prb_usage_for_mimo =
            decode::decode_integer(data, Some(0), Some(100), false)?.0 as u8;
        let ul_total_prb_usage_for_mimo =
            decode::decode_integer(data, Some(0), Some(100), false)?.0 as u8;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            dl_gbr_prb_usage_for_mimo,
            ul_gbr_prb_usage_for_mimo,
            dl_non_gbr_prb_usage_for_mimo,
            ul_non_gbr_prb_usage_for_mimo,
            dl_total_prb_usage_for_mimo,
            ul_total_prb_usage_for_mimo,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        encode::encode_integer(
            data,
            Some(0),
            Some(100),
            false,
            self.dl_gbr_prb_usage_for_mimo as i128,
            false,
        )?;
        encode::encode_integer(
            data,
            Some(0),
            Some(100),
            false,
            self.ul_gbr_prb_usage_for_mimo as i128,
            false,
        )?;
        encode::encode_integer(
            data,
            Some(0),
            Some(100),
            false,
            self.dl_non_gbr_prb_usage_for_mimo as i128,
            false,
        )?;
        encode::encode_integer(
            data,
            Some(0),
            Some(100),
            false,
            self.ul_non_gbr_prb_usage_for_mimo as i128,
            false,
        )?;
        encode::encode_integer(
            data,
            Some(0),
            Some(100),
            false,
            self.dl_total_prb_usage_for_mimo as i128,
            false,
        )?;
        encode::encode_integer(
            data,
            Some(0),
            Some(100),
            false,
            self.ul_total_prb_usage_for_mimo as i128,
            false,
        )?;

        Ok(())
    }
}

impl PerCodec for MimoprBusageInformation {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        MimoprBusageInformation::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MimoprBusageInformation");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MimoprBusageInformation");
            e
        })
    }
}
// RaNfeedbackType
#[derive(Clone, Debug)]
pub enum RaNfeedbackType {
    Proactive(RaNfeedbackTypeProactive),
    Reactive(RaNfeedbackTypeReactive),
}

impl RaNfeedbackType {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_choice_idx(data, 0, 2, false)?;
        if extended {
            return Err(per_codec_error_new("CHOICE additions not implemented"));
        }
        match idx {
            0 => Ok(Self::Proactive(RaNfeedbackTypeProactive::decode(data)?)),
            1 => Ok(Self::Reactive(RaNfeedbackTypeReactive::decode(data)?)),
            2 => {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _ = Criticality::decode(data)?;
                let _ = decode::decode_length_determinent(data, None, None, false)?;
                let result = match id {
                    x => Err(per_codec_error_new(format!("Unrecognised IE type {}", x))),
                };
                data.decode_align()?;
                result
            }
            _ => Err(per_codec_error_new("Unknown choice idx")),
        }
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        match self {
            Self::Proactive(x) => {
                encode::encode_choice_idx(data, 0, 2, false, 0, false)?;
                x.encode(data)
            }
            Self::Reactive(x) => {
                encode::encode_choice_idx(data, 0, 2, false, 1, false)?;
                x.encode(data)
            }
        }
    }
}

impl PerCodec for RaNfeedbackType {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        RaNfeedbackType::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("RaNfeedbackType");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("RaNfeedbackType");
            e
        })
    }
}
// RaNfeedbackTypeProactive
#[derive(Clone, Debug)]
pub struct RaNfeedbackTypeProactive {
    pub burst_arrival_time_window: BurstArrivalTimeWindow,
    pub periodicity_range: Option<PeriodicityRange>,
}

impl RaNfeedbackTypeProactive {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 2)?;
        let burst_arrival_time_window = BurstArrivalTimeWindow::decode(data)?;
        let periodicity_range = if optionals[0] {
            Some(PeriodicityRange::decode(data)?)
        } else {
            None
        };

        // Process the extension container

        if optionals[1] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            burst_arrival_time_window,
            periodicity_range,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.periodicity_range.is_some());
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.burst_arrival_time_window.encode(data)?;
        if let Some(x) = &self.periodicity_range {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl PerCodec for RaNfeedbackTypeProactive {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        RaNfeedbackTypeProactive::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("RaNfeedbackTypeProactive");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("RaNfeedbackTypeProactive");
            e
        })
    }
}
// RaNfeedbackTypeReactive
#[derive(Clone, Debug)]
pub struct RaNfeedbackTypeReactive {
    pub capability_for_bat_adaptation: CapabilityForBatAdaptation,
}

impl RaNfeedbackTypeReactive {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let capability_for_bat_adaptation = CapabilityForBatAdaptation::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            capability_for_bat_adaptation,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.capability_for_bat_adaptation.encode(data)?;

        Ok(())
    }
}

impl PerCodec for RaNfeedbackTypeReactive {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        RaNfeedbackTypeReactive::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("RaNfeedbackTypeReactive");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("RaNfeedbackTypeReactive");
            e
        })
    }
}
// RanSharingAssistanceInformation
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum RanSharingAssistanceInformation {
    MbsSessionInNonSharedCellResources,
}

impl RanSharingAssistanceInformation {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(0), true)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(0),
            true,
            *self as i128,
            (*self as u32) >= 1,
        )
    }
}

impl PerCodec for RanSharingAssistanceInformation {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        RanSharingAssistanceInformation::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("RanSharingAssistanceInformation");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("RanSharingAssistanceInformation");
            e
        })
    }
}
// RantssRequestType
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum RantssRequestType {
    Start,
    Stop,
}

impl RantssRequestType {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(1), true)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(1),
            true,
            *self as i128,
            (*self as u32) >= 2,
        )
    }
}

impl PerCodec for RantssRequestType {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        RantssRequestType::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("RantssRequestType");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("RantssRequestType");
            e
        })
    }
}
// RanTimingSynchronisationStatusInfo
#[derive(Clone, Debug)]
pub struct RanTimingSynchronisationStatusInfo {
    pub synchronisationstate: Option<Synchronisationstate>,
    pub traceableto_utc: Option<TraceabletoUtc>,
    pub traceableto_gnss: Option<TraceabletoGnss>,
    pub clock_frequency_stability: Option<BitString>,
    pub clock_accuracy: Option<ClockAccuracy>,
    pub parent_time_source: Option<ParentTImeSource>,
}

impl RanTimingSynchronisationStatusInfo {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 7)?;
        let synchronisationstate = if optionals[0] {
            Some(Synchronisationstate::decode(data)?)
        } else {
            None
        };
        let traceableto_utc = if optionals[1] {
            Some(TraceabletoUtc::decode(data)?)
        } else {
            None
        };
        let traceableto_gnss = if optionals[2] {
            Some(TraceabletoGnss::decode(data)?)
        } else {
            None
        };
        let clock_frequency_stability = if optionals[3] {
            Some(decode::decode_bitstring(data, Some(16), Some(16), false)?)
        } else {
            None
        };
        let clock_accuracy = if optionals[4] {
            Some(ClockAccuracy::decode(data)?)
        } else {
            None
        };
        let parent_time_source = if optionals[5] {
            Some(ParentTImeSource::decode(data)?)
        } else {
            None
        };

        // Process the extension container

        if optionals[6] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            synchronisationstate,
            traceableto_utc,
            traceableto_gnss,
            clock_frequency_stability,
            clock_accuracy,
            parent_time_source,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.synchronisationstate.is_some());
        optionals.push(self.traceableto_utc.is_some());
        optionals.push(self.traceableto_gnss.is_some());
        optionals.push(self.clock_frequency_stability.is_some());
        optionals.push(self.clock_accuracy.is_some());
        optionals.push(self.parent_time_source.is_some());
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        if let Some(x) = &self.synchronisationstate {
            x.encode(data)?;
        }
        if let Some(x) = &self.traceableto_utc {
            x.encode(data)?;
        }
        if let Some(x) = &self.traceableto_gnss {
            x.encode(data)?;
        }
        if let Some(x) = &self.clock_frequency_stability {
            encode::encode_bitstring(data, Some(16), Some(16), false, &x, false)?;
        }
        if let Some(x) = &self.clock_accuracy {
            x.encode(data)?;
        }
        if let Some(x) = &self.parent_time_source {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl PerCodec for RanTimingSynchronisationStatusInfo {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        RanTimingSynchronisationStatusInfo::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("RanTimingSynchronisationStatusInfo");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("RanTimingSynchronisationStatusInfo");
            e
        })
    }
}
// ClockAccuracy
#[derive(Clone, Debug)]
pub enum ClockAccuracy {
    ClockAccuracyValue(u32),
    ClockAccuracyIndex(u8),
}

impl ClockAccuracy {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_choice_idx(data, 0, 2, false)?;
        if extended {
            return Err(per_codec_error_new("CHOICE additions not implemented"));
        }
        match idx {
            0 => Ok(Self::ClockAccuracyValue(
                decode::decode_integer(data, Some(1), Some(40000000), true)?.0 as u32,
            )),
            1 => Ok(Self::ClockAccuracyIndex(
                decode::decode_integer(data, Some(32), Some(47), true)?.0 as u8,
            )),
            2 => {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _ = Criticality::decode(data)?;
                let _ = decode::decode_length_determinent(data, None, None, false)?;
                let result = match id {
                    x => Err(per_codec_error_new(format!("Unrecognised IE type {}", x))),
                };
                data.decode_align()?;
                result
            }
            _ => Err(per_codec_error_new("Unknown choice idx")),
        }
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        match self {
            Self::ClockAccuracyValue(x) => {
                encode::encode_choice_idx(data, 0, 2, false, 0, false)?;
                encode::encode_integer(data, Some(1), Some(40000000), true, *x as i128, false)
            }
            Self::ClockAccuracyIndex(x) => {
                encode::encode_choice_idx(data, 0, 2, false, 1, false)?;
                encode::encode_integer(data, Some(32), Some(47), true, *x as i128, false)
            }
        }
    }
}

impl PerCodec for ClockAccuracy {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        ClockAccuracy::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ClockAccuracy");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ClockAccuracy");
            e
        })
    }
}
// Ranac
#[derive(Clone, Copy, Debug)]
pub struct Ranac(pub u8);

impl Ranac {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(
            decode::decode_integer(data, Some(0), Some(255), false)?.0 as u8,
        ))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_integer(data, Some(0), Some(255), false, self.0 as i128, false)
    }
}

impl PerCodec for Ranac {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ranac::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("Ranac");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("Ranac");
            e
        })
    }
}
// RanMeasurementId
#[derive(Clone, Copy, Debug)]
pub struct RanMeasurementId(pub u32);

impl RanMeasurementId {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(
            decode::decode_integer(data, Some(1), Some(65536), true)?.0 as u32,
        ))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_integer(data, Some(1), Some(65536), true, self.0 as i128, false)
    }
}

impl PerCodec for RanMeasurementId {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        RanMeasurementId::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("RanMeasurementId");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("RanMeasurementId");
            e
        })
    }
}
// RanUeMeasurementId
#[derive(Clone, Copy, Debug)]
pub struct RanUeMeasurementId(pub u16);

impl RanUeMeasurementId {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(
            decode::decode_integer(data, Some(1), Some(256), true)?.0 as u16,
        ))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_integer(data, Some(1), Some(256), true, self.0 as i128, false)
    }
}

impl PerCodec for RanUeMeasurementId {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        RanUeMeasurementId::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("RanUeMeasurementId");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("RanUeMeasurementId");
            e
        })
    }
}
// RanUePdcMeasId
#[derive(Clone, Copy, Debug)]
pub struct RanUePdcMeasId(pub u8);

impl RanUePdcMeasId {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(
            decode::decode_integer(data, Some(1), Some(16), true)?.0 as u8,
        ))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_integer(data, Some(1), Some(16), true, self.0 as i128, false)
    }
}

impl PerCodec for RanUePdcMeasId {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        RanUePdcMeasId::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("RanUePdcMeasId");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("RanUePdcMeasId");
            e
        })
    }
}
// RanUeId
#[derive(Clone, Debug)]
pub struct RanUeId(pub [u8; 8]);

impl RanUeId {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(
            decode::decode_octetstring(data, Some(8), Some(8), false)?
                .try_into()
                .unwrap(),
        ))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_octetstring(data, Some(8), Some(8), false, &(self.0).into(), false)
    }
}

impl PerCodec for RanUeId {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        RanUeId::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("RanUeId");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("RanUeId");
            e
        })
    }
}
// RanUePagingIdentity
#[derive(Clone, Debug)]
pub struct RanUePagingIdentity {
    pub irnti: BitString,
}

impl RanUePagingIdentity {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, false, 1)?;
        let irnti = decode::decode_bitstring(data, Some(40), Some(40), false)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self { irnti })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, false, &optionals, false)?;
        encode::encode_bitstring(data, Some(40), Some(40), false, &self.irnti, false)?;

        Ok(())
    }
}

impl PerCodec for RanUePagingIdentity {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        RanUePagingIdentity::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("RanUePagingIdentity");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("RanUePagingIdentity");
            e
        })
    }
}
// RatFrequencyPriorityInformation
#[derive(Clone, Debug)]
pub enum RatFrequencyPriorityInformation {
    Endc(SubscriberProfileIDforRfp),
    Ngran(RatFrequencySelectionPriority),
}

impl RatFrequencyPriorityInformation {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_choice_idx(data, 0, 2, false)?;
        if extended {
            return Err(per_codec_error_new("CHOICE additions not implemented"));
        }
        match idx {
            0 => Ok(Self::Endc(SubscriberProfileIDforRfp::decode(data)?)),
            1 => Ok(Self::Ngran(RatFrequencySelectionPriority::decode(data)?)),
            2 => {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _ = Criticality::decode(data)?;
                let _ = decode::decode_length_determinent(data, None, None, false)?;
                let result = match id {
                    x => Err(per_codec_error_new(format!("Unrecognised IE type {}", x))),
                };
                data.decode_align()?;
                result
            }
            _ => Err(per_codec_error_new("Unknown choice idx")),
        }
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        match self {
            Self::Endc(x) => {
                encode::encode_choice_idx(data, 0, 2, false, 0, false)?;
                x.encode(data)
            }
            Self::Ngran(x) => {
                encode::encode_choice_idx(data, 0, 2, false, 1, false)?;
                x.encode(data)
            }
        }
    }
}

impl PerCodec for RatFrequencyPriorityInformation {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        RatFrequencyPriorityInformation::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("RatFrequencyPriorityInformation");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("RatFrequencyPriorityInformation");
            e
        })
    }
}
// RatFrequencySelectionPriority
#[derive(Clone, Copy, Debug)]
pub struct RatFrequencySelectionPriority(pub u16);

impl RatFrequencySelectionPriority {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(
            decode::decode_integer(data, Some(1), Some(256), true)?.0 as u16,
        ))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_integer(data, Some(1), Some(256), true, self.0 as i128, false)
    }
}

impl PerCodec for RatFrequencySelectionPriority {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        RatFrequencySelectionPriority::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("RatFrequencySelectionPriority");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("RatFrequencySelectionPriority");
            e
        })
    }
}
// RbSetConfiguration
#[derive(Clone, Debug)]
pub struct RbSetConfiguration {
    pub subcarrier_spacing: SubcarrierSpacing,
    pub rb_set_size: RbSetSize,
    pub n_umber_r_bsets: u8,
}

impl RbSetConfiguration {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, false, 1)?;
        let subcarrier_spacing = SubcarrierSpacing::decode(data)?;
        let rb_set_size = RbSetSize::decode(data)?;
        let n_umber_r_bsets = decode::decode_integer(data, Some(1), Some(8), false)?.0 as u8;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            subcarrier_spacing,
            rb_set_size,
            n_umber_r_bsets,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, false, &optionals, false)?;
        self.subcarrier_spacing.encode(data)?;
        self.rb_set_size.encode(data)?;
        encode::encode_integer(
            data,
            Some(1),
            Some(8),
            false,
            self.n_umber_r_bsets as i128,
            false,
        )?;

        Ok(())
    }
}

impl PerCodec for RbSetConfiguration {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        RbSetConfiguration::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("RbSetConfiguration");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("RbSetConfiguration");
            e
        })
    }
}
// RbSetSize
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum RbSetSize {
    Rb2,
    Rb4,
    Rb8,
    Rb16,
    Rb32,
    Rb64,
}

impl RbSetSize {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(5), false)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(5),
            false,
            *self as i128,
            (*self as u32) >= 6,
        )
    }
}

impl PerCodec for RbSetSize {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        RbSetSize::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("RbSetSize");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("RbSetSize");
            e
        })
    }
}
// ReRoutingEnableIndicator
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum ReRoutingEnableIndicator {
    True,
    False,
}

impl ReRoutingEnableIndicator {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(1), true)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(1),
            true,
            *self as i128,
            (*self as u32) >= 2,
        )
    }
}

impl PerCodec for ReRoutingEnableIndicator {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        ReRoutingEnableIndicator::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ReRoutingEnableIndicator");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ReRoutingEnableIndicator");
            e
        })
    }
}
// RecommendedSsBsForPagingList
#[derive(Clone, Debug)]
pub struct RecommendedSsBsForPagingList(pub NonEmpty<RecommendedSsBsForPagingListItem>);

impl RecommendedSsBsForPagingList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(512), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(RecommendedSsBsForPagingListItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(512), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for RecommendedSsBsForPagingList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        RecommendedSsBsForPagingList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("RecommendedSsBsForPagingList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("RecommendedSsBsForPagingList");
            e
        })
    }
}
// RecommendedSsBsForPagingListItem
#[derive(Clone, Debug)]
pub struct RecommendedSsBsForPagingListItem {
    pub nr_cgi: NrCgi,
    pub ss_bs_for_paging_list: SsBsForPagingList,
}

impl RecommendedSsBsForPagingListItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, false, 1)?;
        let nr_cgi = NrCgi::decode(data)?;
        let ss_bs_for_paging_list = SsBsForPagingList::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            nr_cgi,
            ss_bs_for_paging_list,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, false, &optionals, false)?;
        self.nr_cgi.encode(data)?;
        self.ss_bs_for_paging_list.encode(data)?;

        Ok(())
    }
}

impl PerCodec for RecommendedSsBsForPagingListItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        RecommendedSsBsForPagingListItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("RecommendedSsBsForPagingListItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("RecommendedSsBsForPagingListItem");
            e
        })
    }
}
// RedcapBcastInformation
#[derive(Clone, Debug)]
pub struct RedcapBcastInformation(pub BitString);

impl RedcapBcastInformation {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(decode::decode_bitstring(
            data,
            Some(8),
            Some(8),
            false,
        )?))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_bitstring(data, Some(8), Some(8), false, &self.0, false)
    }
}

impl PerCodec for RedcapBcastInformation {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        RedcapBcastInformation::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("RedcapBcastInformation");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("RedcapBcastInformation");
            e
        })
    }
}
// RedCapIndication
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum RedCapIndication {
    True,
}

impl RedCapIndication {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(0), true)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(0),
            true,
            *self as i128,
            (*self as u32) >= 1,
        )
    }
}

impl PerCodec for RedCapIndication {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        RedCapIndication::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("RedCapIndication");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("RedCapIndication");
            e
        })
    }
}
// ReestablishmentIndication
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum ReestablishmentIndication {
    Reestablished,
}

impl ReestablishmentIndication {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(0), true)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(0),
            true,
            *self as i128,
            (*self as u32) >= 1,
        )
    }
}

impl PerCodec for ReestablishmentIndication {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        ReestablishmentIndication::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ReestablishmentIndication");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ReestablishmentIndication");
            e
        })
    }
}
// ReferencePoint
#[derive(Clone, Debug)]
pub enum ReferencePoint {
    CoordinateId(CoordinateId),
    ReferencePointCoordinate(AccessPointPosition),
    ReferencePointCoordinateHa(NgranHighAccuracyAccessPointPosition),
    LocalOrigin(LocalOrigin),
}

impl ReferencePoint {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_choice_idx(data, 0, 3, false)?;
        if extended {
            return Err(per_codec_error_new("CHOICE additions not implemented"));
        }
        match idx {
            0 => Ok(Self::CoordinateId(CoordinateId::decode(data)?)),
            1 => Ok(Self::ReferencePointCoordinate(AccessPointPosition::decode(
                data,
            )?)),
            2 => Ok(Self::ReferencePointCoordinateHa(
                NgranHighAccuracyAccessPointPosition::decode(data)?,
            )),
            3 => {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _ = Criticality::decode(data)?;
                let _ = decode::decode_length_determinent(data, None, None, false)?;
                let result = match id {
                    854 => Ok(Self::LocalOrigin(LocalOrigin::decode(data)?)),
                    x => Err(per_codec_error_new(format!("Unrecognised IE type {}", x))),
                };
                data.decode_align()?;
                result
            }
            _ => Err(per_codec_error_new("Unknown choice idx")),
        }
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        match self {
            Self::CoordinateId(x) => {
                encode::encode_choice_idx(data, 0, 3, false, 0, false)?;
                x.encode(data)
            }
            Self::ReferencePointCoordinate(x) => {
                encode::encode_choice_idx(data, 0, 3, false, 1, false)?;
                x.encode(data)
            }
            Self::ReferencePointCoordinateHa(x) => {
                encode::encode_choice_idx(data, 0, 3, false, 2, false)?;
                x.encode(data)
            }
            Self::LocalOrigin(x) => {
                encode::encode_choice_idx(data, 0, 3, false, 3, false)?;
                encode::encode_integer(data, Some(0), Some(65535), false, 854, false)?;
                Criticality::Ignore.encode(data)?;
                let ie = &mut Allocator::new_codec_data();
                x.encode(ie)?;
                encode::encode_length_determinent(data, None, None, false, ie.length_in_bytes())?;
                Ok(data.append_aligned(ie))
            }
        }
    }
}

impl PerCodec for ReferencePoint {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        ReferencePoint::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ReferencePoint");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ReferencePoint");
            e
        })
    }
}
// LocalOrigin
#[derive(Clone, Debug)]
pub struct LocalOrigin {
    pub relative_coordinate_id: CoordinateId,
    pub horizontal_axes_orientation: u16,
    pub reference_point_coordinate_ha: Option<NgranHighAccuracyAccessPointPosition>,
}

impl LocalOrigin {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 2)?;
        let relative_coordinate_id = CoordinateId::decode(data)?;
        let horizontal_axes_orientation =
            decode::decode_integer(data, Some(0), Some(3599), false)?.0 as u16;
        let reference_point_coordinate_ha = if optionals[0] {
            Some(NgranHighAccuracyAccessPointPosition::decode(data)?)
        } else {
            None
        };

        // Process the extension container

        if optionals[1] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            relative_coordinate_id,
            horizontal_axes_orientation,
            reference_point_coordinate_ha,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.reference_point_coordinate_ha.is_some());
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.relative_coordinate_id.encode(data)?;
        encode::encode_integer(
            data,
            Some(0),
            Some(3599),
            false,
            self.horizontal_axes_orientation as i128,
            false,
        )?;
        if let Some(x) = &self.reference_point_coordinate_ha {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl PerCodec for LocalOrigin {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        LocalOrigin::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("LocalOrigin");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("LocalOrigin");
            e
        })
    }
}
// ReferenceSfn
#[derive(Clone, Copy, Debug)]
pub struct ReferenceSfn(pub u16);

impl ReferenceSfn {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(
            decode::decode_integer(data, Some(0), Some(1023), false)?.0 as u16,
        ))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_integer(data, Some(0), Some(1023), false, self.0 as i128, false)
    }
}

impl PerCodec for ReferenceSfn {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        ReferenceSfn::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ReferenceSfn");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ReferenceSfn");
            e
        })
    }
}
// ReferenceSignal
#[derive(Clone, Debug)]
pub enum ReferenceSignal {
    NzpCsiRs(NzpCsiRsResourceId),
    Ssb(Ssb),
    Srs(SrsResourceId),
    PositioningSrs(SrsPosResourceId),
    DlPrs(DlPrs),
}

impl ReferenceSignal {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_choice_idx(data, 0, 5, false)?;
        if extended {
            return Err(per_codec_error_new("CHOICE additions not implemented"));
        }
        match idx {
            0 => Ok(Self::NzpCsiRs(NzpCsiRsResourceId::decode(data)?)),
            1 => Ok(Self::Ssb(Ssb::decode(data)?)),
            2 => Ok(Self::Srs(SrsResourceId::decode(data)?)),
            3 => Ok(Self::PositioningSrs(SrsPosResourceId::decode(data)?)),
            4 => Ok(Self::DlPrs(DlPrs::decode(data)?)),
            5 => {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _ = Criticality::decode(data)?;
                let _ = decode::decode_length_determinent(data, None, None, false)?;
                let result = match id {
                    x => Err(per_codec_error_new(format!("Unrecognised IE type {}", x))),
                };
                data.decode_align()?;
                result
            }
            _ => Err(per_codec_error_new("Unknown choice idx")),
        }
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        match self {
            Self::NzpCsiRs(x) => {
                encode::encode_choice_idx(data, 0, 5, false, 0, false)?;
                x.encode(data)
            }
            Self::Ssb(x) => {
                encode::encode_choice_idx(data, 0, 5, false, 1, false)?;
                x.encode(data)
            }
            Self::Srs(x) => {
                encode::encode_choice_idx(data, 0, 5, false, 2, false)?;
                x.encode(data)
            }
            Self::PositioningSrs(x) => {
                encode::encode_choice_idx(data, 0, 5, false, 3, false)?;
                x.encode(data)
            }
            Self::DlPrs(x) => {
                encode::encode_choice_idx(data, 0, 5, false, 4, false)?;
                x.encode(data)
            }
        }
    }
}

impl PerCodec for ReferenceSignal {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        ReferenceSignal::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ReferenceSignal");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ReferenceSignal");
            e
        })
    }
}
// RaRnti
#[derive(Clone, Copy, Debug)]
pub struct RaRnti(pub u16);

impl RaRnti {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(
            decode::decode_integer(data, Some(0), Some(65535), true)?.0 as u16,
        ))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_integer(data, Some(0), Some(65535), true, self.0 as i128, false)
    }
}

impl PerCodec for RaRnti {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        RaRnti::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("RaRnti");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("RaRnti");
            e
        })
    }
}
// ReferenceConfiguration
#[derive(Clone, Debug)]
pub enum ReferenceConfiguration {
    ReqUeSTforLowerLayerConfiguration(RequestforLowerLayerConfiguration),
    ReferenceConfiguration(ReferenceConfigurationInformation),
}

impl ReferenceConfiguration {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_choice_idx(data, 0, 2, false)?;
        if extended {
            return Err(per_codec_error_new("CHOICE additions not implemented"));
        }
        match idx {
            0 => Ok(Self::ReqUeSTforLowerLayerConfiguration(
                RequestforLowerLayerConfiguration::decode(data)?,
            )),
            1 => Ok(Self::ReferenceConfiguration(
                ReferenceConfigurationInformation::decode(data)?,
            )),
            2 => {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _ = Criticality::decode(data)?;
                let _ = decode::decode_length_determinent(data, None, None, false)?;
                let result = match id {
                    x => Err(per_codec_error_new(format!("Unrecognised IE type {}", x))),
                };
                data.decode_align()?;
                result
            }
            _ => Err(per_codec_error_new("Unknown choice idx")),
        }
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        match self {
            Self::ReqUeSTforLowerLayerConfiguration(x) => {
                encode::encode_choice_idx(data, 0, 2, false, 0, false)?;
                x.encode(data)
            }
            Self::ReferenceConfiguration(x) => {
                encode::encode_choice_idx(data, 0, 2, false, 1, false)?;
                x.encode(data)
            }
        }
    }
}

impl PerCodec for ReferenceConfiguration {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        ReferenceConfiguration::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ReferenceConfiguration");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ReferenceConfiguration");
            e
        })
    }
}
// RelativeCartesianLocation
#[derive(Clone, Debug)]
pub struct RelativeCartesianLocation {
    pub xy_zunit: XyZunit,
    pub xvalue: i32,
    pub yvalue: i32,
    pub zvalue: i16,
    pub location_uncertainty: LocationUncertainty,
}

impl RelativeCartesianLocation {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, false, 1)?;
        let xy_zunit = XyZunit::decode(data)?;
        let xvalue = decode::decode_integer(data, Some(-65536), Some(65535), false)?.0 as i32;
        let yvalue = decode::decode_integer(data, Some(-65536), Some(65535), false)?.0 as i32;
        let zvalue = decode::decode_integer(data, Some(-32768), Some(32767), false)?.0 as i16;
        let location_uncertainty = LocationUncertainty::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            xy_zunit,
            xvalue,
            yvalue,
            zvalue,
            location_uncertainty,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, false, &optionals, false)?;
        self.xy_zunit.encode(data)?;
        encode::encode_integer(
            data,
            Some(-65536),
            Some(65535),
            false,
            self.xvalue as i128,
            false,
        )?;
        encode::encode_integer(
            data,
            Some(-65536),
            Some(65535),
            false,
            self.yvalue as i128,
            false,
        )?;
        encode::encode_integer(
            data,
            Some(-32768),
            Some(32767),
            false,
            self.zvalue as i128,
            false,
        )?;
        self.location_uncertainty.encode(data)?;

        Ok(())
    }
}

impl PerCodec for RelativeCartesianLocation {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        RelativeCartesianLocation::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("RelativeCartesianLocation");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("RelativeCartesianLocation");
            e
        })
    }
}
// RelativeGeodeticLocation
#[derive(Clone, Debug)]
pub struct RelativeGeodeticLocation {
    pub milli_arc_second_units: MilliArcSecondUnits,
    pub height_units: HeightUnits,
    pub delta_latitude: i16,
    pub delta_longitude: i16,
    pub delta_height: i16,
    pub location_uncertainty: LocationUncertainty,
}

impl RelativeGeodeticLocation {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, false, 1)?;
        let milli_arc_second_units = MilliArcSecondUnits::decode(data)?;
        let height_units = HeightUnits::decode(data)?;
        let delta_latitude = decode::decode_integer(data, Some(-1024), Some(1023), false)?.0 as i16;
        let delta_longitude =
            decode::decode_integer(data, Some(-1024), Some(1023), false)?.0 as i16;
        let delta_height = decode::decode_integer(data, Some(-1024), Some(1023), false)?.0 as i16;
        let location_uncertainty = LocationUncertainty::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            milli_arc_second_units,
            height_units,
            delta_latitude,
            delta_longitude,
            delta_height,
            location_uncertainty,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, false, &optionals, false)?;
        self.milli_arc_second_units.encode(data)?;
        self.height_units.encode(data)?;
        encode::encode_integer(
            data,
            Some(-1024),
            Some(1023),
            false,
            self.delta_latitude as i128,
            false,
        )?;
        encode::encode_integer(
            data,
            Some(-1024),
            Some(1023),
            false,
            self.delta_longitude as i128,
            false,
        )?;
        encode::encode_integer(
            data,
            Some(-1024),
            Some(1023),
            false,
            self.delta_height as i128,
            false,
        )?;
        self.location_uncertainty.encode(data)?;

        Ok(())
    }
}

impl PerCodec for RelativeGeodeticLocation {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        RelativeGeodeticLocation::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("RelativeGeodeticLocation");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("RelativeGeodeticLocation");
            e
        })
    }
}
// RemoteUeLocalId
#[derive(Clone, Copy, Debug)]
pub struct RemoteUeLocalId(pub u8);

impl RemoteUeLocalId {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(
            decode::decode_integer(data, Some(0), Some(255), true)?.0 as u8,
        ))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_integer(data, Some(0), Some(255), true, self.0 as i128, false)
    }
}

impl PerCodec for RemoteUeLocalId {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        RemoteUeLocalId::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("RemoteUeLocalId");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("RemoteUeLocalId");
            e
        })
    }
}
// ReferenceTime
#[derive(Clone, Debug)]
pub struct ReferenceTime(pub Vec<u8>);

impl ReferenceTime {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(decode::decode_octetstring(data, None, None, false)?))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_octetstring(data, None, None, false, &self.0, false)
    }
}

impl PerCodec for ReferenceTime {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        ReferenceTime::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ReferenceTime");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ReferenceTime");
            e
        })
    }
}
// RegistrationRequest
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum RegistrationRequest {
    Start,
    Stop,
    Add,
}

impl RegistrationRequest {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(2), true)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(2),
            true,
            *self as i128,
            (*self as u32) >= 3,
        )
    }
}

impl PerCodec for RegistrationRequest {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        RegistrationRequest::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("RegistrationRequest");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("RegistrationRequest");
            e
        })
    }
}
// ReportCharacteristics
#[derive(Clone, Debug)]
pub struct ReportCharacteristics(pub BitString);

impl ReportCharacteristics {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(decode::decode_bitstring(
            data,
            Some(32),
            Some(32),
            false,
        )?))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_bitstring(data, Some(32), Some(32), false, &self.0, false)
    }
}

impl PerCodec for ReportCharacteristics {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        ReportCharacteristics::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ReportCharacteristics");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ReportCharacteristics");
            e
        })
    }
}
// ReportingGranularitykminus1
#[derive(Clone, Copy, Debug)]
pub struct ReportingGranularitykminus1(pub u32);

impl ReportingGranularitykminus1 {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(
            decode::decode_integer(data, Some(0), Some(3940097), false)?.0 as u32,
        ))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_integer(data, Some(0), Some(3940097), false, self.0 as i128, false)
    }
}

impl PerCodec for ReportingGranularitykminus1 {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        ReportingGranularitykminus1::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ReportingGranularitykminus1");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ReportingGranularitykminus1");
            e
        })
    }
}
// ReportingGranularitykminus2
#[derive(Clone, Copy, Debug)]
pub struct ReportingGranularitykminus2(pub u32);

impl ReportingGranularitykminus2 {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(
            decode::decode_integer(data, Some(0), Some(7880193), false)?.0 as u32,
        ))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_integer(data, Some(0), Some(7880193), false, self.0 as i128, false)
    }
}

impl PerCodec for ReportingGranularitykminus2 {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        ReportingGranularitykminus2::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ReportingGranularitykminus2");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ReportingGranularitykminus2");
            e
        })
    }
}
// ReportingGranularitykminus3
#[derive(Clone, Copy, Debug)]
pub struct ReportingGranularitykminus3(pub u32);

impl ReportingGranularitykminus3 {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(
            decode::decode_integer(data, Some(0), Some(15760385), false)?.0 as u32,
        ))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_integer(data, Some(0), Some(15760385), false, self.0 as i128, false)
    }
}

impl PerCodec for ReportingGranularitykminus3 {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        ReportingGranularitykminus3::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ReportingGranularitykminus3");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ReportingGranularitykminus3");
            e
        })
    }
}
// ReportingGranularitykminus4
#[derive(Clone, Copy, Debug)]
pub struct ReportingGranularitykminus4(pub u32);

impl ReportingGranularitykminus4 {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(
            decode::decode_integer(data, Some(0), Some(31520769), false)?.0 as u32,
        ))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_integer(data, Some(0), Some(31520769), false, self.0 as i128, false)
    }
}

impl PerCodec for ReportingGranularitykminus4 {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        ReportingGranularitykminus4::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ReportingGranularitykminus4");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ReportingGranularitykminus4");
            e
        })
    }
}
// ReportingGranularitykminus5
#[derive(Clone, Copy, Debug)]
pub struct ReportingGranularitykminus5(pub u32);

impl ReportingGranularitykminus5 {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(
            decode::decode_integer(data, Some(0), Some(63041537), false)?.0 as u32,
        ))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_integer(data, Some(0), Some(63041537), false, self.0 as i128, false)
    }
}

impl PerCodec for ReportingGranularitykminus5 {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        ReportingGranularitykminus5::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ReportingGranularitykminus5");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ReportingGranularitykminus5");
            e
        })
    }
}
// ReportingGranularitykminus6
#[derive(Clone, Copy, Debug)]
pub struct ReportingGranularitykminus6(pub u32);

impl ReportingGranularitykminus6 {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(
            decode::decode_integer(data, Some(0), Some(126083073), false)?.0 as u32,
        ))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_integer(data, Some(0), Some(126083073), false, self.0 as i128, false)
    }
}

impl PerCodec for ReportingGranularitykminus6 {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        ReportingGranularitykminus6::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ReportingGranularitykminus6");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ReportingGranularitykminus6");
            e
        })
    }
}
// ReportingGranularitykminus1AdditionalPath
#[derive(Clone, Copy, Debug)]
pub struct ReportingGranularitykminus1AdditionalPath(pub u16);

impl ReportingGranularitykminus1AdditionalPath {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(
            decode::decode_integer(data, Some(0), Some(32701), false)?.0 as u16,
        ))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_integer(data, Some(0), Some(32701), false, self.0 as i128, false)
    }
}

impl PerCodec for ReportingGranularitykminus1AdditionalPath {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        ReportingGranularitykminus1AdditionalPath::decode_inner(data).map_err(
            |mut e: PerCodecError| {
                e.push_context("ReportingGranularitykminus1AdditionalPath");
                e
            },
        )
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ReportingGranularitykminus1AdditionalPath");
            e
        })
    }
}
// ReportingGranularitykminus2AdditionalPath
#[derive(Clone, Copy, Debug)]
pub struct ReportingGranularitykminus2AdditionalPath(pub u16);

impl ReportingGranularitykminus2AdditionalPath {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(
            decode::decode_integer(data, Some(0), Some(65401), false)?.0 as u16,
        ))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_integer(data, Some(0), Some(65401), false, self.0 as i128, false)
    }
}

impl PerCodec for ReportingGranularitykminus2AdditionalPath {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        ReportingGranularitykminus2AdditionalPath::decode_inner(data).map_err(
            |mut e: PerCodecError| {
                e.push_context("ReportingGranularitykminus2AdditionalPath");
                e
            },
        )
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ReportingGranularitykminus2AdditionalPath");
            e
        })
    }
}
// ReportingGranularitykminus3AdditionalPath
#[derive(Clone, Copy, Debug)]
pub struct ReportingGranularitykminus3AdditionalPath(pub u32);

impl ReportingGranularitykminus3AdditionalPath {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(
            decode::decode_integer(data, Some(0), Some(130801), false)?.0 as u32,
        ))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_integer(data, Some(0), Some(130801), false, self.0 as i128, false)
    }
}

impl PerCodec for ReportingGranularitykminus3AdditionalPath {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        ReportingGranularitykminus3AdditionalPath::decode_inner(data).map_err(
            |mut e: PerCodecError| {
                e.push_context("ReportingGranularitykminus3AdditionalPath");
                e
            },
        )
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ReportingGranularitykminus3AdditionalPath");
            e
        })
    }
}
// ReportingGranularitykminus4AdditionalPath
#[derive(Clone, Copy, Debug)]
pub struct ReportingGranularitykminus4AdditionalPath(pub u32);

impl ReportingGranularitykminus4AdditionalPath {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(
            decode::decode_integer(data, Some(0), Some(261601), false)?.0 as u32,
        ))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_integer(data, Some(0), Some(261601), false, self.0 as i128, false)
    }
}

impl PerCodec for ReportingGranularitykminus4AdditionalPath {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        ReportingGranularitykminus4AdditionalPath::decode_inner(data).map_err(
            |mut e: PerCodecError| {
                e.push_context("ReportingGranularitykminus4AdditionalPath");
                e
            },
        )
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ReportingGranularitykminus4AdditionalPath");
            e
        })
    }
}
// ReportingGranularitykminus5AdditionalPath
#[derive(Clone, Copy, Debug)]
pub struct ReportingGranularitykminus5AdditionalPath(pub u32);

impl ReportingGranularitykminus5AdditionalPath {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(
            decode::decode_integer(data, Some(0), Some(523201), false)?.0 as u32,
        ))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_integer(data, Some(0), Some(523201), false, self.0 as i128, false)
    }
}

impl PerCodec for ReportingGranularitykminus5AdditionalPath {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        ReportingGranularitykminus5AdditionalPath::decode_inner(data).map_err(
            |mut e: PerCodecError| {
                e.push_context("ReportingGranularitykminus5AdditionalPath");
                e
            },
        )
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ReportingGranularitykminus5AdditionalPath");
            e
        })
    }
}
// ReportingGranularitykminus6AdditionalPath
#[derive(Clone, Copy, Debug)]
pub struct ReportingGranularitykminus6AdditionalPath(pub u32);

impl ReportingGranularitykminus6AdditionalPath {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(
            decode::decode_integer(data, Some(0), Some(1046401), false)?.0 as u32,
        ))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_integer(data, Some(0), Some(1046401), false, self.0 as i128, false)
    }
}

impl PerCodec for ReportingGranularitykminus6AdditionalPath {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        ReportingGranularitykminus6AdditionalPath::decode_inner(data).map_err(
            |mut e: PerCodecError| {
                e.push_context("ReportingGranularitykminus6AdditionalPath");
                e
            },
        )
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ReportingGranularitykminus6AdditionalPath");
            e
        })
    }
}
// ReportingPeriodicity
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum ReportingPeriodicity {
    Ms500,
    Ms1000,
    Ms2000,
    Ms5000,
    Ms10000,
}

impl ReportingPeriodicity {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(4), true)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(4),
            true,
            *self as i128,
            (*self as u32) >= 5,
        )
    }
}

impl PerCodec for ReportingPeriodicity {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        ReportingPeriodicity::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ReportingPeriodicity");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ReportingPeriodicity");
            e
        })
    }
}
// RequestedBandCombinationIndex
#[derive(Clone, Debug)]
pub struct RequestedBandCombinationIndex(pub Vec<u8>);

impl RequestedBandCombinationIndex {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(decode::decode_octetstring(data, None, None, false)?))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_octetstring(data, None, None, false, &self.0, false)
    }
}

impl PerCodec for RequestedBandCombinationIndex {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        RequestedBandCombinationIndex::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("RequestedBandCombinationIndex");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("RequestedBandCombinationIndex");
            e
        })
    }
}
// RequestedFeatureSetEntryIndex
#[derive(Clone, Debug)]
pub struct RequestedFeatureSetEntryIndex(pub Vec<u8>);

impl RequestedFeatureSetEntryIndex {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(decode::decode_octetstring(data, None, None, false)?))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_octetstring(data, None, None, false, &self.0, false)
    }
}

impl PerCodec for RequestedFeatureSetEntryIndex {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        RequestedFeatureSetEntryIndex::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("RequestedFeatureSetEntryIndex");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("RequestedFeatureSetEntryIndex");
            e
        })
    }
}
// RequestedPMaxFr2
#[derive(Clone, Debug)]
pub struct RequestedPMaxFr2(pub Vec<u8>);

impl RequestedPMaxFr2 {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(decode::decode_octetstring(data, None, None, false)?))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_octetstring(data, None, None, false, &self.0, false)
    }
}

impl PerCodec for RequestedPMaxFr2 {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        RequestedPMaxFr2::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("RequestedPMaxFr2");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("RequestedPMaxFr2");
            e
        })
    }
}
// RequestedPdcchBlindDetectionScg
#[derive(Clone, Debug)]
pub struct RequestedPdcchBlindDetectionScg(pub Vec<u8>);

impl RequestedPdcchBlindDetectionScg {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(decode::decode_octetstring(data, None, None, false)?))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_octetstring(data, None, None, false, &self.0, false)
    }
}

impl PerCodec for RequestedPdcchBlindDetectionScg {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        RequestedPdcchBlindDetectionScg::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("RequestedPdcchBlindDetectionScg");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("RequestedPdcchBlindDetectionScg");
            e
        })
    }
}
// RequestedSrsPreconfigurationCharacteristicsList
#[derive(Clone, Debug)]
pub struct RequestedSrsPreconfigurationCharacteristicsList(
    pub NonEmpty<RequestedSrsPreconfigurationCharacteristicsItem>,
);

impl RequestedSrsPreconfigurationCharacteristicsList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(16), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(RequestedSrsPreconfigurationCharacteristicsItem::decode(
                    data,
                )?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(16), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for RequestedSrsPreconfigurationCharacteristicsList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        RequestedSrsPreconfigurationCharacteristicsList::decode_inner(data).map_err(
            |mut e: PerCodecError| {
                e.push_context("RequestedSrsPreconfigurationCharacteristicsList");
                e
            },
        )
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("RequestedSrsPreconfigurationCharacteristicsList");
            e
        })
    }
}
// RequestedSrsPreconfigurationCharacteristicsItem
#[derive(Clone, Debug)]
pub struct RequestedSrsPreconfigurationCharacteristicsItem {
    pub requested_srs_transmission_characteristics: RequestedSrsTransmissionCharacteristics,
}

impl RequestedSrsPreconfigurationCharacteristicsItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let requested_srs_transmission_characteristics =
            RequestedSrsTransmissionCharacteristics::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            requested_srs_transmission_characteristics,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.requested_srs_transmission_characteristics
            .encode(data)?;

        Ok(())
    }
}

impl PerCodec for RequestedSrsPreconfigurationCharacteristicsItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        RequestedSrsPreconfigurationCharacteristicsItem::decode_inner(data).map_err(
            |mut e: PerCodecError| {
                e.push_context("RequestedSrsPreconfigurationCharacteristicsItem");
                e
            },
        )
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("RequestedSrsPreconfigurationCharacteristicsItem");
            e
        })
    }
}
// RequestedSrsTransmissionCharacteristics
#[derive(Clone, Debug)]
pub struct RequestedSrsTransmissionCharacteristics {
    pub number_of_transmissions: Option<u16>,
    pub resource_type: ResourceType2,
    pub bandwidth_srs: BandwidthSrs,
    pub srs_resource_set_list: Option<SrsResourceSetList>,
    pub ssb_information: Option<SsbInformation>,
    pub srs_frequency: Option<SrsFrequency>,
    pub bw_aggregation_request_indication: Option<BwAggregationRequestIndication>,
    pub pos_validity_area_cell_list: Option<PosValidityAreaCellList>,
    pub validity_area_specific_srs_information: Option<ValidityAreaSpecificSrsInformation>,
}

impl RequestedSrsTransmissionCharacteristics {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, false, 4)?;
        let number_of_transmissions = if optionals[0] {
            Some(decode::decode_integer(data, Some(0), Some(500), true)?.0 as u16)
        } else {
            None
        };
        let resource_type = ResourceType2::decode(data)?;
        let bandwidth_srs = BandwidthSrs::decode(data)?;
        let srs_resource_set_list = if optionals[1] {
            Some(SrsResourceSetList::decode(data)?)
        } else {
            None
        };
        let ssb_information = if optionals[2] {
            Some(SsbInformation::decode(data)?)
        } else {
            None
        };

        // Process the extension container
        let mut srs_frequency: Option<SrsFrequency> = None;
        let mut bw_aggregation_request_indication: Option<BwAggregationRequestIndication> = None;
        let mut pos_validity_area_cell_list: Option<PosValidityAreaCellList> = None;
        let mut validity_area_specific_srs_information: Option<ValidityAreaSpecificSrsInformation> =
            None;

        if optionals[3] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    431 => srs_frequency = Some(SrsFrequency::decode(data)?),
                    805 => {
                        bw_aggregation_request_indication =
                            Some(BwAggregationRequestIndication::decode(data)?)
                    }
                    812 => {
                        pos_validity_area_cell_list = Some(PosValidityAreaCellList::decode(data)?)
                    }
                    833 => {
                        validity_area_specific_srs_information =
                            Some(ValidityAreaSpecificSrsInformation::decode(data)?)
                    }
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            number_of_transmissions,
            resource_type,
            bandwidth_srs,
            srs_resource_set_list,
            ssb_information,
            srs_frequency,
            bw_aggregation_request_indication,
            pos_validity_area_cell_list,
            validity_area_specific_srs_information,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();
        if let Some(x) = &self.srs_frequency {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 431, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.bw_aggregation_request_indication {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 805, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.pos_validity_area_cell_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 812, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.validity_area_specific_srs_information {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 833, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        let mut optionals = BitString::new();
        optionals.push(self.number_of_transmissions.is_some());
        optionals.push(self.srs_resource_set_list.is_some());
        optionals.push(self.ssb_information.is_some());
        optionals.push(num_ies != 0);

        encode::encode_sequence_header(data, false, &optionals, false)?;
        if let Some(x) = &self.number_of_transmissions {
            encode::encode_integer(data, Some(0), Some(500), true, *x as i128, false)?;
        }
        self.resource_type.encode(data)?;
        self.bandwidth_srs.encode(data)?;
        if let Some(x) = &self.srs_resource_set_list {
            x.encode(data)?;
        }
        if let Some(x) = &self.ssb_information {
            x.encode(data)?;
        }
        if num_ies != 0 {
            encode::encode_length_determinent(data, Some(1), Some(65535), false, num_ies)?;
            data.append_aligned(ies);
        }
        Ok(())
    }
}

impl PerCodec for RequestedSrsTransmissionCharacteristics {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        RequestedSrsTransmissionCharacteristics::decode_inner(data).map_err(
            |mut e: PerCodecError| {
                e.push_context("RequestedSrsTransmissionCharacteristics");
                e
            },
        )
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("RequestedSrsTransmissionCharacteristics");
            e
        })
    }
}
// RequestType
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum RequestType {
    Offer,
    Execution,
}

impl RequestType {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(1), true)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(1),
            true,
            *self as i128,
            (*self as u32) >= 2,
        )
    }
}

impl PerCodec for RequestType {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        RequestType::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("RequestType");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("RequestType");
            e
        })
    }
}
// ResourceCoordinationEutraCellInfo
#[derive(Clone, Debug)]
pub struct ResourceCoordinationEutraCellInfo {
    pub eutra_mode_info: EutraCoexModeInfo,
    pub eutra_prach_configuration: EutraPrachConfiguration,
    pub ignore_prach_configuration: Option<IgnorePrachConfiguration>,
}

impl ResourceCoordinationEutraCellInfo {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let eutra_mode_info = EutraCoexModeInfo::decode(data)?;
        let eutra_prach_configuration = EutraPrachConfiguration::decode(data)?;

        // Process the extension container
        let mut ignore_prach_configuration: Option<IgnorePrachConfiguration> = None;

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    233 => {
                        ignore_prach_configuration = Some(IgnorePrachConfiguration::decode(data)?)
                    }
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            eutra_mode_info,
            eutra_prach_configuration,
            ignore_prach_configuration,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();
        if let Some(x) = &self.ignore_prach_configuration {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 233, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        let mut optionals = BitString::new();
        optionals.push(num_ies != 0);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.eutra_mode_info.encode(data)?;
        self.eutra_prach_configuration.encode(data)?;
        if num_ies != 0 {
            encode::encode_length_determinent(data, Some(1), Some(65535), false, num_ies)?;
            data.append_aligned(ies);
        }
        Ok(())
    }
}

impl PerCodec for ResourceCoordinationEutraCellInfo {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        ResourceCoordinationEutraCellInfo::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ResourceCoordinationEutraCellInfo");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ResourceCoordinationEutraCellInfo");
            e
        })
    }
}
// ResourceCoordinationTransferInformation
#[derive(Clone, Debug)]
pub struct ResourceCoordinationTransferInformation {
    pub m_enb_cell_id: EutraCellId,
    pub resource_coordination_eutra_cell_info: Option<ResourceCoordinationEutraCellInfo>,
}

impl ResourceCoordinationTransferInformation {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 2)?;
        let m_enb_cell_id = EutraCellId::decode(data)?;
        let resource_coordination_eutra_cell_info = if optionals[0] {
            Some(ResourceCoordinationEutraCellInfo::decode(data)?)
        } else {
            None
        };

        // Process the extension container

        if optionals[1] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            m_enb_cell_id,
            resource_coordination_eutra_cell_info,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.resource_coordination_eutra_cell_info.is_some());
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.m_enb_cell_id.encode(data)?;
        if let Some(x) = &self.resource_coordination_eutra_cell_info {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl PerCodec for ResourceCoordinationTransferInformation {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        ResourceCoordinationTransferInformation::decode_inner(data).map_err(
            |mut e: PerCodecError| {
                e.push_context("ResourceCoordinationTransferInformation");
                e
            },
        )
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ResourceCoordinationTransferInformation");
            e
        })
    }
}
// ResourceCoordinationTransferContainer
#[derive(Clone, Debug)]
pub struct ResourceCoordinationTransferContainer(pub Vec<u8>);

impl ResourceCoordinationTransferContainer {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(decode::decode_octetstring(data, None, None, false)?))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_octetstring(data, None, None, false, &self.0, false)
    }
}

impl PerCodec for ResourceCoordinationTransferContainer {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        ResourceCoordinationTransferContainer::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ResourceCoordinationTransferContainer");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ResourceCoordinationTransferContainer");
            e
        })
    }
}
// ResourceMapping
#[derive(Clone, Debug)]
pub struct ResourceMapping {
    pub start_position: u8,
    pub nrof_sumbols: NrofSumbols,
}

impl ResourceMapping {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let start_position = decode::decode_integer(data, Some(0), Some(13), false)?.0 as u8;
        let nrof_sumbols = NrofSumbols::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            start_position,
            nrof_sumbols,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        encode::encode_integer(
            data,
            Some(0),
            Some(13),
            false,
            self.start_position as i128,
            false,
        )?;
        self.nrof_sumbols.encode(data)?;

        Ok(())
    }
}

impl PerCodec for ResourceMapping {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        ResourceMapping::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ResourceMapping");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ResourceMapping");
            e
        })
    }
}
// ResourceSetType
#[derive(Clone, Debug)]
pub enum ResourceSetType {
    Periodic(ResourceSetTypePeriodic),
    SemiPersistent(ResourceSetTypeSemiPersistent),
    Aperiodic(ResourceSetTypeAperiodic),
}

impl ResourceSetType {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_choice_idx(data, 0, 3, false)?;
        if extended {
            return Err(per_codec_error_new("CHOICE additions not implemented"));
        }
        match idx {
            0 => Ok(Self::Periodic(ResourceSetTypePeriodic::decode(data)?)),
            1 => Ok(Self::SemiPersistent(ResourceSetTypeSemiPersistent::decode(
                data,
            )?)),
            2 => Ok(Self::Aperiodic(ResourceSetTypeAperiodic::decode(data)?)),
            3 => {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _ = Criticality::decode(data)?;
                let _ = decode::decode_length_determinent(data, None, None, false)?;
                let result = match id {
                    x => Err(per_codec_error_new(format!("Unrecognised IE type {}", x))),
                };
                data.decode_align()?;
                result
            }
            _ => Err(per_codec_error_new("Unknown choice idx")),
        }
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        match self {
            Self::Periodic(x) => {
                encode::encode_choice_idx(data, 0, 3, false, 0, false)?;
                x.encode(data)
            }
            Self::SemiPersistent(x) => {
                encode::encode_choice_idx(data, 0, 3, false, 1, false)?;
                x.encode(data)
            }
            Self::Aperiodic(x) => {
                encode::encode_choice_idx(data, 0, 3, false, 2, false)?;
                x.encode(data)
            }
        }
    }
}

impl PerCodec for ResourceSetType {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        ResourceSetType::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ResourceSetType");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ResourceSetType");
            e
        })
    }
}
// ResourceSetTypePeriodic
#[derive(Clone, Debug)]
pub struct ResourceSetTypePeriodic {
    pub periodic_set: PeriodicSet,
}

impl ResourceSetTypePeriodic {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, false, 1)?;
        let periodic_set = PeriodicSet::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self { periodic_set })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, false, &optionals, false)?;
        self.periodic_set.encode(data)?;

        Ok(())
    }
}

impl PerCodec for ResourceSetTypePeriodic {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        ResourceSetTypePeriodic::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ResourceSetTypePeriodic");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ResourceSetTypePeriodic");
            e
        })
    }
}
// ResourceSetTypeSemiPersistent
#[derive(Clone, Debug)]
pub struct ResourceSetTypeSemiPersistent {
    pub semi_persistent_set: SemiPersistentSet,
}

impl ResourceSetTypeSemiPersistent {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, false, 1)?;
        let semi_persistent_set = SemiPersistentSet::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            semi_persistent_set,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, false, &optionals, false)?;
        self.semi_persistent_set.encode(data)?;

        Ok(())
    }
}

impl PerCodec for ResourceSetTypeSemiPersistent {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        ResourceSetTypeSemiPersistent::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ResourceSetTypeSemiPersistent");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ResourceSetTypeSemiPersistent");
            e
        })
    }
}
// ResourceSetTypeAperiodic
#[derive(Clone, Debug)]
pub struct ResourceSetTypeAperiodic {
    pub srs_resource_trigger_list: u8,
    pub slotoffset: u8,
}

impl ResourceSetTypeAperiodic {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, false, 1)?;
        let srs_resource_trigger_list =
            decode::decode_integer(data, Some(1), Some(3), false)?.0 as u8;
        let slotoffset = decode::decode_integer(data, Some(0), Some(32), false)?.0 as u8;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            srs_resource_trigger_list,
            slotoffset,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, false, &optionals, false)?;
        encode::encode_integer(
            data,
            Some(1),
            Some(3),
            false,
            self.srs_resource_trigger_list as i128,
            false,
        )?;
        encode::encode_integer(
            data,
            Some(0),
            Some(32),
            false,
            self.slotoffset as i128,
            false,
        )?;

        Ok(())
    }
}

impl PerCodec for ResourceSetTypeAperiodic {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        ResourceSetTypeAperiodic::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ResourceSetTypeAperiodic");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ResourceSetTypeAperiodic");
            e
        })
    }
}
// RepetitionFactorExtended
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum RepetitionFactorExtended {
    N3,
    N5,
    N6,
    N7,
    N8,
    N10,
    N12,
    N14,
}

impl RepetitionFactorExtended {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(7), true)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(7),
            true,
            *self as i128,
            (*self as u32) >= 8,
        )
    }
}

impl PerCodec for RepetitionFactorExtended {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        RepetitionFactorExtended::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("RepetitionFactorExtended");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("RepetitionFactorExtended");
            e
        })
    }
}
// RepetitionPeriod
#[derive(Clone, Copy, Debug)]
pub struct RepetitionPeriod(pub u32);

impl RepetitionPeriod {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(
            decode::decode_integer(data, Some(0), Some(131071), true)?.0 as u32,
        ))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_integer(data, Some(0), Some(131071), true, self.0 as i128, false)
    }
}

impl PerCodec for RepetitionPeriod {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        RepetitionPeriod::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("RepetitionPeriod");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("RepetitionPeriod");
            e
        })
    }
}
// ReportingRequestType
#[derive(Clone, Debug)]
pub struct ReportingRequestType {
    pub event_type: EventType,
    pub reporting_periodicity_value: Option<ReportingPeriodicityValue>,
}

impl ReportingRequestType {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, false, 2)?;
        let event_type = EventType::decode(data)?;
        let reporting_periodicity_value = if optionals[0] {
            Some(ReportingPeriodicityValue::decode(data)?)
        } else {
            None
        };

        // Process the extension container

        if optionals[1] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            event_type,
            reporting_periodicity_value,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.reporting_periodicity_value.is_some());
        optionals.push(false);

        encode::encode_sequence_header(data, false, &optionals, false)?;
        self.event_type.encode(data)?;
        if let Some(x) = &self.reporting_periodicity_value {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl PerCodec for ReportingRequestType {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        ReportingRequestType::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ReportingRequestType");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ReportingRequestType");
            e
        })
    }
}
// ResourceType
#[derive(Clone, Debug)]
pub enum ResourceType {
    Periodic(ResourceTypePeriodic),
    SemiPersistent(ResourceTypeSemiPersistent),
    Aperiodic(ResourceTypeAperiodic),
}

impl ResourceType {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_choice_idx(data, 0, 3, false)?;
        if extended {
            return Err(per_codec_error_new("CHOICE additions not implemented"));
        }
        match idx {
            0 => Ok(Self::Periodic(ResourceTypePeriodic::decode(data)?)),
            1 => Ok(Self::SemiPersistent(ResourceTypeSemiPersistent::decode(
                data,
            )?)),
            2 => Ok(Self::Aperiodic(ResourceTypeAperiodic::decode(data)?)),
            3 => {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _ = Criticality::decode(data)?;
                let _ = decode::decode_length_determinent(data, None, None, false)?;
                let result = match id {
                    x => Err(per_codec_error_new(format!("Unrecognised IE type {}", x))),
                };
                data.decode_align()?;
                result
            }
            _ => Err(per_codec_error_new("Unknown choice idx")),
        }
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        match self {
            Self::Periodic(x) => {
                encode::encode_choice_idx(data, 0, 3, false, 0, false)?;
                x.encode(data)
            }
            Self::SemiPersistent(x) => {
                encode::encode_choice_idx(data, 0, 3, false, 1, false)?;
                x.encode(data)
            }
            Self::Aperiodic(x) => {
                encode::encode_choice_idx(data, 0, 3, false, 2, false)?;
                x.encode(data)
            }
        }
    }
}

impl PerCodec for ResourceType {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        ResourceType::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ResourceType");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ResourceType");
            e
        })
    }
}
// ResourceTypePeriodic
#[derive(Clone, Debug)]
pub struct ResourceTypePeriodic {
    pub periodicity: Periodicity1,
    pub offset: u16,
}

impl ResourceTypePeriodic {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, false, 1)?;
        let periodicity = Periodicity1::decode(data)?;
        let offset = decode::decode_integer(data, Some(0), Some(2559), true)?.0 as u16;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            periodicity,
            offset,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, false, &optionals, false)?;
        self.periodicity.encode(data)?;
        encode::encode_integer(data, Some(0), Some(2559), true, self.offset as i128, false)?;

        Ok(())
    }
}

impl PerCodec for ResourceTypePeriodic {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        ResourceTypePeriodic::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ResourceTypePeriodic");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ResourceTypePeriodic");
            e
        })
    }
}
// ResourceTypeSemiPersistent
#[derive(Clone, Debug)]
pub struct ResourceTypeSemiPersistent {
    pub periodicity: Periodicity2,
    pub offset: u16,
}

impl ResourceTypeSemiPersistent {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, false, 1)?;
        let periodicity = Periodicity2::decode(data)?;
        let offset = decode::decode_integer(data, Some(0), Some(2559), true)?.0 as u16;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            periodicity,
            offset,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, false, &optionals, false)?;
        self.periodicity.encode(data)?;
        encode::encode_integer(data, Some(0), Some(2559), true, self.offset as i128, false)?;

        Ok(())
    }
}

impl PerCodec for ResourceTypeSemiPersistent {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        ResourceTypeSemiPersistent::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ResourceTypeSemiPersistent");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ResourceTypeSemiPersistent");
            e
        })
    }
}
// ResourceTypeAperiodic
#[derive(Clone, Debug)]
pub struct ResourceTypeAperiodic {
    pub aperiodic_resource_type: AperiodicResourceType,
}

impl ResourceTypeAperiodic {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, false, 1)?;
        let aperiodic_resource_type = AperiodicResourceType::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            aperiodic_resource_type,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, false, &optionals, false)?;
        self.aperiodic_resource_type.encode(data)?;

        Ok(())
    }
}

impl PerCodec for ResourceTypeAperiodic {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        ResourceTypeAperiodic::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ResourceTypeAperiodic");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ResourceTypeAperiodic");
            e
        })
    }
}
// ResourceTypePos
#[derive(Clone, Debug)]
pub enum ResourceTypePos {
    Periodic(ResourceTypePeriodicPos),
    SemiPersistent(ResourceTypeSemiPersistentPos),
    Aperiodic(ResourceTypeAperiodicPos),
}

impl ResourceTypePos {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_choice_idx(data, 0, 3, false)?;
        if extended {
            return Err(per_codec_error_new("CHOICE additions not implemented"));
        }
        match idx {
            0 => Ok(Self::Periodic(ResourceTypePeriodicPos::decode(data)?)),
            1 => Ok(Self::SemiPersistent(ResourceTypeSemiPersistentPos::decode(
                data,
            )?)),
            2 => Ok(Self::Aperiodic(ResourceTypeAperiodicPos::decode(data)?)),
            3 => {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _ = Criticality::decode(data)?;
                let _ = decode::decode_length_determinent(data, None, None, false)?;
                let result = match id {
                    x => Err(per_codec_error_new(format!("Unrecognised IE type {}", x))),
                };
                data.decode_align()?;
                result
            }
            _ => Err(per_codec_error_new("Unknown choice idx")),
        }
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        match self {
            Self::Periodic(x) => {
                encode::encode_choice_idx(data, 0, 3, false, 0, false)?;
                x.encode(data)
            }
            Self::SemiPersistent(x) => {
                encode::encode_choice_idx(data, 0, 3, false, 1, false)?;
                x.encode(data)
            }
            Self::Aperiodic(x) => {
                encode::encode_choice_idx(data, 0, 3, false, 2, false)?;
                x.encode(data)
            }
        }
    }
}

impl PerCodec for ResourceTypePos {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        ResourceTypePos::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ResourceTypePos");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ResourceTypePos");
            e
        })
    }
}
// ResourceTypePeriodicPos
#[derive(Clone, Debug)]
pub struct ResourceTypePeriodicPos {
    pub periodicity: SrsPeriodicity,
    pub offset: u32,
    pub srs_pos_periodic_config_hyper_sfn_index: Option<SrsPosPeriodicConfigHyperSfnIndex>,
}

impl ResourceTypePeriodicPos {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, false, 1)?;
        let periodicity = SrsPeriodicity::decode(data)?;
        let offset = decode::decode_integer(data, Some(0), Some(81919), true)?.0 as u32;

        // Process the extension container
        let mut srs_pos_periodic_config_hyper_sfn_index: Option<SrsPosPeriodicConfigHyperSfnIndex> =
            None;

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    856 => {
                        srs_pos_periodic_config_hyper_sfn_index =
                            Some(SrsPosPeriodicConfigHyperSfnIndex::decode(data)?)
                    }
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            periodicity,
            offset,
            srs_pos_periodic_config_hyper_sfn_index,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();
        if let Some(x) = &self.srs_pos_periodic_config_hyper_sfn_index {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 856, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        let mut optionals = BitString::new();
        optionals.push(num_ies != 0);

        encode::encode_sequence_header(data, false, &optionals, false)?;
        self.periodicity.encode(data)?;
        encode::encode_integer(data, Some(0), Some(81919), true, self.offset as i128, false)?;
        if num_ies != 0 {
            encode::encode_length_determinent(data, Some(1), Some(65535), false, num_ies)?;
            data.append_aligned(ies);
        }
        Ok(())
    }
}

impl PerCodec for ResourceTypePeriodicPos {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        ResourceTypePeriodicPos::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ResourceTypePeriodicPos");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ResourceTypePeriodicPos");
            e
        })
    }
}
// ResourceTypeSemiPersistentPos
#[derive(Clone, Debug)]
pub struct ResourceTypeSemiPersistentPos {
    pub periodicity: SrsPeriodicity,
    pub offset: u32,
    pub srs_pos_periodic_config_hyper_sfn_index: Option<SrsPosPeriodicConfigHyperSfnIndex>,
}

impl ResourceTypeSemiPersistentPos {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, false, 1)?;
        let periodicity = SrsPeriodicity::decode(data)?;
        let offset = decode::decode_integer(data, Some(0), Some(81919), true)?.0 as u32;

        // Process the extension container
        let mut srs_pos_periodic_config_hyper_sfn_index: Option<SrsPosPeriodicConfigHyperSfnIndex> =
            None;

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    856 => {
                        srs_pos_periodic_config_hyper_sfn_index =
                            Some(SrsPosPeriodicConfigHyperSfnIndex::decode(data)?)
                    }
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            periodicity,
            offset,
            srs_pos_periodic_config_hyper_sfn_index,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();
        if let Some(x) = &self.srs_pos_periodic_config_hyper_sfn_index {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 856, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        let mut optionals = BitString::new();
        optionals.push(num_ies != 0);

        encode::encode_sequence_header(data, false, &optionals, false)?;
        self.periodicity.encode(data)?;
        encode::encode_integer(data, Some(0), Some(81919), true, self.offset as i128, false)?;
        if num_ies != 0 {
            encode::encode_length_determinent(data, Some(1), Some(65535), false, num_ies)?;
            data.append_aligned(ies);
        }
        Ok(())
    }
}

impl PerCodec for ResourceTypeSemiPersistentPos {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        ResourceTypeSemiPersistentPos::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ResourceTypeSemiPersistentPos");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ResourceTypeSemiPersistentPos");
            e
        })
    }
}
// ResourceTypeAperiodicPos
#[derive(Clone, Debug)]
pub struct ResourceTypeAperiodicPos {
    pub slot_offset: u8,
}

impl ResourceTypeAperiodicPos {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, false, 1)?;
        let slot_offset = decode::decode_integer(data, Some(0), Some(32), false)?.0 as u8;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self { slot_offset })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, false, &optionals, false)?;
        encode::encode_integer(
            data,
            Some(0),
            Some(32),
            false,
            self.slot_offset as i128,
            false,
        )?;

        Ok(())
    }
}

impl PerCodec for ResourceTypeAperiodicPos {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        ResourceTypeAperiodicPos::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ResourceTypeAperiodicPos");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ResourceTypeAperiodicPos");
            e
        })
    }
}
// RlcDuplicationInformation
#[derive(Clone, Debug)]
pub struct RlcDuplicationInformation {
    pub rlc_duplication_state_list: RlcDuplicationStateList,
    pub primary_path_indication: Option<PrimaryPathIndication>,
}

impl RlcDuplicationInformation {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, false, 2)?;
        let rlc_duplication_state_list = RlcDuplicationStateList::decode(data)?;
        let primary_path_indication = if optionals[0] {
            Some(PrimaryPathIndication::decode(data)?)
        } else {
            None
        };

        // Process the extension container

        if optionals[1] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            rlc_duplication_state_list,
            primary_path_indication,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.primary_path_indication.is_some());
        optionals.push(false);

        encode::encode_sequence_header(data, false, &optionals, false)?;
        self.rlc_duplication_state_list.encode(data)?;
        if let Some(x) = &self.primary_path_indication {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl PerCodec for RlcDuplicationInformation {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        RlcDuplicationInformation::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("RlcDuplicationInformation");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("RlcDuplicationInformation");
            e
        })
    }
}
// RlcDuplicationStateList
#[derive(Clone, Debug)]
pub struct RlcDuplicationStateList(pub NonEmpty<RlcDuplicationStateItem>);

impl RlcDuplicationStateList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(3), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(RlcDuplicationStateItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(3), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for RlcDuplicationStateList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        RlcDuplicationStateList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("RlcDuplicationStateList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("RlcDuplicationStateList");
            e
        })
    }
}
// RlcDuplicationStateItem
#[derive(Clone, Debug)]
pub struct RlcDuplicationStateItem {
    pub duplication_state: DuplicationState,
}

impl RlcDuplicationStateItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let duplication_state = DuplicationState::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self { duplication_state })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.duplication_state.encode(data)?;

        Ok(())
    }
}

impl PerCodec for RlcDuplicationStateItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        RlcDuplicationStateItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("RlcDuplicationStateItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("RlcDuplicationStateItem");
            e
        })
    }
}
// RlcFailureIndication
#[derive(Clone, Debug)]
pub struct RlcFailureIndication {
    pub assocated_lcid: Lcid,
}

impl RlcFailureIndication {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, false, 1)?;
        let assocated_lcid = Lcid::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self { assocated_lcid })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, false, &optionals, false)?;
        self.assocated_lcid.encode(data)?;

        Ok(())
    }
}

impl PerCodec for RlcFailureIndication {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        RlcFailureIndication::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("RlcFailureIndication");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("RlcFailureIndication");
            e
        })
    }
}
// RlcMode
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum RlcMode {
    RlcAm,
    RlcUmBidirectional,
    RlcUmUnidirectionalUl,
    RlcUmUnidirectionalDl,
}

impl RlcMode {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(3), true)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(3),
            true,
            *self as i128,
            (*self as u32) >= 4,
        )
    }
}

impl PerCodec for RlcMode {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        RlcMode::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("RlcMode");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("RlcMode");
            e
        })
    }
}
// RlcStatus
#[derive(Clone, Debug)]
pub struct RlcStatus {
    pub reestablishment_indication: ReestablishmentIndication,
}

impl RlcStatus {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let reestablishment_indication = ReestablishmentIndication::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            reestablishment_indication,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.reestablishment_indication.encode(data)?;

        Ok(())
    }
}

impl PerCodec for RlcStatus {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        RlcStatus::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("RlcStatus");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("RlcStatus");
            e
        })
    }
}
// RlfReportInformationList
#[derive(Clone, Debug)]
pub struct RlfReportInformationList(pub NonEmpty<RlfReportInformationItem>);

impl RlfReportInformationList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(64), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(RlfReportInformationItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(64), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for RlfReportInformationList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        RlfReportInformationList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("RlfReportInformationList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("RlfReportInformationList");
            e
        })
    }
}
// RlfReportInformationItem
#[derive(Clone, Debug)]
pub struct RlfReportInformationItem {
    pub nr_ue_rlf_report_container: NrUeRlfReportContainer,
    pub ue_assitant_identifier: Option<GnbDuUeF1apId>,
}

impl RlfReportInformationItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 2)?;
        let nr_ue_rlf_report_container = NrUeRlfReportContainer::decode(data)?;
        let ue_assitant_identifier = if optionals[0] {
            Some(GnbDuUeF1apId::decode(data)?)
        } else {
            None
        };

        // Process the extension container

        if optionals[1] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            nr_ue_rlf_report_container,
            ue_assitant_identifier,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.ue_assitant_identifier.is_some());
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.nr_ue_rlf_report_container.encode(data)?;
        if let Some(x) = &self.ue_assitant_identifier {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl PerCodec for RlfReportInformationItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        RlfReportInformationItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("RlfReportInformationItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("RlfReportInformationItem");
            e
        })
    }
}
// RimrsDetectionStatus
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum RimrsDetectionStatus {
    RsDetected,
    RsDisappeared,
}

impl RimrsDetectionStatus {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(1), true)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(1),
            true,
            *self as i128,
            (*self as u32) >= 2,
        )
    }
}

impl PerCodec for RimrsDetectionStatus {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        RimrsDetectionStatus::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("RimrsDetectionStatus");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("RimrsDetectionStatus");
            e
        })
    }
}
// RrcContainer
#[derive(Clone, Debug)]
pub struct RrcContainer(pub Vec<u8>);

impl RrcContainer {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(decode::decode_octetstring(data, None, None, false)?))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_octetstring(data, None, None, false, &self.0, false)
    }
}

impl PerCodec for RrcContainer {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        RrcContainer::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("RrcContainer");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("RrcContainer");
            e
        })
    }
}
// RrcContainerRrcSetupComplete
#[derive(Clone, Debug)]
pub struct RrcContainerRrcSetupComplete(pub Vec<u8>);

impl RrcContainerRrcSetupComplete {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(decode::decode_octetstring(data, None, None, false)?))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_octetstring(data, None, None, false, &self.0, false)
    }
}

impl PerCodec for RrcContainerRrcSetupComplete {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        RrcContainerRrcSetupComplete::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("RrcContainerRrcSetupComplete");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("RrcContainerRrcSetupComplete");
            e
        })
    }
}
// RrcDeliveryStatus
#[derive(Clone, Debug)]
pub struct RrcDeliveryStatus {
    pub delivery_status: PdcpSn,
    pub triggering_message: PdcpSn,
}

impl RrcDeliveryStatus {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, false, 1)?;
        let delivery_status = PdcpSn::decode(data)?;
        let triggering_message = PdcpSn::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            delivery_status,
            triggering_message,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, false, &optionals, false)?;
        self.delivery_status.encode(data)?;
        self.triggering_message.encode(data)?;

        Ok(())
    }
}

impl PerCodec for RrcDeliveryStatus {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        RrcDeliveryStatus::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("RrcDeliveryStatus");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("RrcDeliveryStatus");
            e
        })
    }
}
// RrcDeliveryStatusRequest
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum RrcDeliveryStatusRequest {
    True,
}

impl RrcDeliveryStatusRequest {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(0), true)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(0),
            true,
            *self as i128,
            (*self as u32) >= 1,
        )
    }
}

impl PerCodec for RrcDeliveryStatusRequest {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        RrcDeliveryStatusRequest::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("RrcDeliveryStatusRequest");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("RrcDeliveryStatusRequest");
            e
        })
    }
}
// RrcReconfigurationCompleteIndicator
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum RrcReconfigurationCompleteIndicator {
    True,
    Failure,
}

impl RrcReconfigurationCompleteIndicator {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(0), true)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(0),
            true,
            *self as i128,
            (*self as u32) >= 1,
        )
    }
}

impl PerCodec for RrcReconfigurationCompleteIndicator {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        RrcReconfigurationCompleteIndicator::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("RrcReconfigurationCompleteIndicator");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("RrcReconfigurationCompleteIndicator");
            e
        })
    }
}
// RrcTerminatingIabDonorRelatedInfo
#[derive(Clone, Debug)]
pub struct RrcTerminatingIabDonorRelatedInfo {
    pub rrc_terminating_iab_donor_gnb_id: GlobalGnbId,
    pub mobile_iab_mt_bap_address: BapAddress,
}

impl RrcTerminatingIabDonorRelatedInfo {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let rrc_terminating_iab_donor_gnb_id = GlobalGnbId::decode(data)?;
        let mobile_iab_mt_bap_address = BapAddress::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            rrc_terminating_iab_donor_gnb_id,
            mobile_iab_mt_bap_address,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.rrc_terminating_iab_donor_gnb_id.encode(data)?;
        self.mobile_iab_mt_bap_address.encode(data)?;

        Ok(())
    }
}

impl PerCodec for RrcTerminatingIabDonorRelatedInfo {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        RrcTerminatingIabDonorRelatedInfo::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("RrcTerminatingIabDonorRelatedInfo");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("RrcTerminatingIabDonorRelatedInfo");
            e
        })
    }
}
// RrcVersion
#[derive(Clone, Debug)]
pub struct RrcVersion {
    pub latest_rrc_version: BitString,
    pub latest_rrc_version_enhanced: Option<[u8; 3]>,
}

impl RrcVersion {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, false, 1)?;
        let latest_rrc_version = decode::decode_bitstring(data, Some(3), Some(3), false)?;

        // Process the extension container
        let mut latest_rrc_version_enhanced: Option<[u8; 3]> = None;

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    199 => {
                        latest_rrc_version_enhanced = Some(
                            decode::decode_octetstring(data, Some(3), Some(3), false)?
                                .try_into()
                                .unwrap(),
                        )
                    }
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            latest_rrc_version,
            latest_rrc_version_enhanced,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();
        if let Some(x) = &self.latest_rrc_version_enhanced {
            let ie = &mut Allocator::new_codec_data();
            encode::encode_octetstring(ie, Some(3), Some(3), false, &(*x).into(), false)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 199, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        let mut optionals = BitString::new();
        optionals.push(num_ies != 0);

        encode::encode_sequence_header(data, false, &optionals, false)?;
        encode::encode_bitstring(
            data,
            Some(3),
            Some(3),
            false,
            &self.latest_rrc_version,
            false,
        )?;
        if num_ies != 0 {
            encode::encode_length_determinent(data, Some(1), Some(65535), false, num_ies)?;
            data.append_aligned(ies);
        }
        Ok(())
    }
}

impl PerCodec for RrcVersion {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        RrcVersion::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("RrcVersion");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("RrcVersion");
            e
        })
    }
}
// RoutingId
#[derive(Clone, Debug)]
pub struct RoutingId(pub Vec<u8>);

impl RoutingId {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(decode::decode_octetstring(data, None, None, false)?))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_octetstring(data, None, None, false, &self.0, false)
    }
}

impl PerCodec for RoutingId {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        RoutingId::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("RoutingId");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("RoutingId");
            e
        })
    }
}
// ResponseTime
#[derive(Clone, Debug)]
pub struct ResponseTime {
    pub time: u8,
    pub time_unit: TimeUnit,
}

impl ResponseTime {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let time = decode::decode_integer(data, Some(1), Some(128), true)?.0 as u8;
        let time_unit = TimeUnit::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self { time, time_unit })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        encode::encode_integer(data, Some(1), Some(128), true, self.time as i128, false)?;
        self.time_unit.encode(data)?;

        Ok(())
    }
}

impl PerCodec for ResponseTime {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        ResponseTime::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ResponseTime");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ResponseTime");
            e
        })
    }
}
// RachConfiguration
#[derive(Clone, Debug)]
pub struct RachConfiguration(pub Vec<u8>);

impl RachConfiguration {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(decode::decode_octetstring(data, None, None, false)?))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_octetstring(data, None, None, false, &self.0, false)
    }
}

impl PerCodec for RachConfiguration {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        RachConfiguration::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("RachConfiguration");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("RachConfiguration");
            e
        })
    }
}
// RequestforRachConfiguration
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum RequestforRachConfiguration {
    True,
}

impl RequestforRachConfiguration {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(0), true)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(0),
            true,
            *self as i128,
            (*self as u32) >= 1,
        )
    }
}

impl PerCodec for RequestforRachConfiguration {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        RequestforRachConfiguration::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("RequestforRachConfiguration");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("RequestforRachConfiguration");
            e
        })
    }
}
// RequestforLowerLayerConfiguration
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum RequestforLowerLayerConfiguration {
    True,
}

impl RequestforLowerLayerConfiguration {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(0), true)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(0),
            true,
            *self as i128,
            (*self as u32) >= 1,
        )
    }
}

impl PerCodec for RequestforLowerLayerConfiguration {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        RequestforLowerLayerConfiguration::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("RequestforLowerLayerConfiguration");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("RequestforLowerLayerConfiguration");
            e
        })
    }
}
// RxTxTimingErrorMargin
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum RxTxTimingErrorMargin {
    Tc0dot5,
    Tc1,
    Tc2,
    Tc4,
    Tc8,
    Tc12,
    Tc16,
    Tc20,
    Tc24,
    Tc32,
    Tc40,
    Tc48,
    Tc64,
    Tc80,
    Tc96,
    Tc128,
}

impl RxTxTimingErrorMargin {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(15), true)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(15),
            true,
            *self as i128,
            (*self as u32) >= 16,
        )
    }
}

impl PerCodec for RxTxTimingErrorMargin {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        RxTxTimingErrorMargin::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("RxTxTimingErrorMargin");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("RxTxTimingErrorMargin");
            e
        })
    }
}
// ReportingIntervalIMs
#[derive(Clone, Copy, Debug)]
pub struct ReportingIntervalIMs(pub u16);

impl ReportingIntervalIMs {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(
            decode::decode_integer(data, Some(1), Some(999), false)?.0 as u16,
        ))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_integer(data, Some(1), Some(999), false, self.0 as i128, false)
    }
}

impl PerCodec for ReportingIntervalIMs {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        ReportingIntervalIMs::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ReportingIntervalIMs");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ReportingIntervalIMs");
            e
        })
    }
}
// SCellFailedtoSetupItem
#[derive(Clone, Debug)]
pub struct SCellFailedtoSetupItem {
    pub s_cell_id: NrCgi,
    pub cause: Option<Cause>,
}

impl SCellFailedtoSetupItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 2)?;
        let s_cell_id = NrCgi::decode(data)?;
        let cause = if optionals[0] {
            Some(Cause::decode(data)?)
        } else {
            None
        };

        // Process the extension container

        if optionals[1] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self { s_cell_id, cause })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.cause.is_some());
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.s_cell_id.encode(data)?;
        if let Some(x) = &self.cause {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl PerCodec for SCellFailedtoSetupItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        SCellFailedtoSetupItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SCellFailedtoSetupItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SCellFailedtoSetupItem");
            e
        })
    }
}
// SCellFailedtoSetupModItem
#[derive(Clone, Debug)]
pub struct SCellFailedtoSetupModItem {
    pub s_cell_id: NrCgi,
    pub cause: Option<Cause>,
}

impl SCellFailedtoSetupModItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 2)?;
        let s_cell_id = NrCgi::decode(data)?;
        let cause = if optionals[0] {
            Some(Cause::decode(data)?)
        } else {
            None
        };

        // Process the extension container

        if optionals[1] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self { s_cell_id, cause })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.cause.is_some());
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.s_cell_id.encode(data)?;
        if let Some(x) = &self.cause {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl PerCodec for SCellFailedtoSetupModItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        SCellFailedtoSetupModItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SCellFailedtoSetupModItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SCellFailedtoSetupModItem");
            e
        })
    }
}
// SCellToBeRemovedItem
#[derive(Clone, Debug)]
pub struct SCellToBeRemovedItem {
    pub s_cell_id: NrCgi,
}

impl SCellToBeRemovedItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let s_cell_id = NrCgi::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self { s_cell_id })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.s_cell_id.encode(data)?;

        Ok(())
    }
}

impl PerCodec for SCellToBeRemovedItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        SCellToBeRemovedItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SCellToBeRemovedItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SCellToBeRemovedItem");
            e
        })
    }
}
// SCellToBeSetupItem
#[derive(Clone, Debug)]
pub struct SCellToBeSetupItem {
    pub s_cell_id: NrCgi,
    pub s_cell_index: SCellIndex,
    pub s_cell_ul_configured: Option<CellUlConfigured>,
    pub serving_cell_mo: Option<ServingCellMo>,
}

impl SCellToBeSetupItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 2)?;
        let s_cell_id = NrCgi::decode(data)?;
        let s_cell_index = SCellIndex::decode(data)?;
        let s_cell_ul_configured = if optionals[0] {
            Some(CellUlConfigured::decode(data)?)
        } else {
            None
        };

        // Process the extension container
        let mut serving_cell_mo: Option<ServingCellMo> = None;

        if optionals[1] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    182 => serving_cell_mo = Some(ServingCellMo::decode(data)?),
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            s_cell_id,
            s_cell_index,
            s_cell_ul_configured,
            serving_cell_mo,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();
        if let Some(x) = &self.serving_cell_mo {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 182, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        let mut optionals = BitString::new();
        optionals.push(self.s_cell_ul_configured.is_some());
        optionals.push(num_ies != 0);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.s_cell_id.encode(data)?;
        self.s_cell_index.encode(data)?;
        if let Some(x) = &self.s_cell_ul_configured {
            x.encode(data)?;
        }
        if num_ies != 0 {
            encode::encode_length_determinent(data, Some(1), Some(65535), false, num_ies)?;
            data.append_aligned(ies);
        }
        Ok(())
    }
}

impl PerCodec for SCellToBeSetupItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        SCellToBeSetupItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SCellToBeSetupItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SCellToBeSetupItem");
            e
        })
    }
}
// SCellToBeSetupModItem
#[derive(Clone, Debug)]
pub struct SCellToBeSetupModItem {
    pub s_cell_id: NrCgi,
    pub s_cell_index: SCellIndex,
    pub s_cell_ul_configured: Option<CellUlConfigured>,
    pub serving_cell_mo: Option<ServingCellMo>,
}

impl SCellToBeSetupModItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 2)?;
        let s_cell_id = NrCgi::decode(data)?;
        let s_cell_index = SCellIndex::decode(data)?;
        let s_cell_ul_configured = if optionals[0] {
            Some(CellUlConfigured::decode(data)?)
        } else {
            None
        };

        // Process the extension container
        let mut serving_cell_mo: Option<ServingCellMo> = None;

        if optionals[1] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    182 => serving_cell_mo = Some(ServingCellMo::decode(data)?),
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            s_cell_id,
            s_cell_index,
            s_cell_ul_configured,
            serving_cell_mo,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();
        if let Some(x) = &self.serving_cell_mo {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 182, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        let mut optionals = BitString::new();
        optionals.push(self.s_cell_ul_configured.is_some());
        optionals.push(num_ies != 0);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.s_cell_id.encode(data)?;
        self.s_cell_index.encode(data)?;
        if let Some(x) = &self.s_cell_ul_configured {
            x.encode(data)?;
        }
        if num_ies != 0 {
            encode::encode_length_determinent(data, Some(1), Some(65535), false, num_ies)?;
            data.append_aligned(ies);
        }
        Ok(())
    }
}

impl PerCodec for SCellToBeSetupModItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        SCellToBeSetupModItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SCellToBeSetupModItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SCellToBeSetupModItem");
            e
        })
    }
}
// SCellIndex
#[derive(Clone, Copy, Debug)]
pub struct SCellIndex(pub u8);

impl SCellIndex {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(
            decode::decode_integer(data, Some(1), Some(31), true)?.0 as u8,
        ))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_integer(data, Some(1), Some(31), true, self.0 as i128, false)
    }
}

impl PerCodec for SCellIndex {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        SCellIndex::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SCellIndex");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SCellIndex");
            e
        })
    }
}
// ScgActivationRequest
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum ScgActivationRequest {
    ActivateScg,
    DeactivateScg,
}

impl ScgActivationRequest {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(1), true)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(1),
            true,
            *self as i128,
            (*self as u32) >= 2,
        )
    }
}

impl PerCodec for ScgActivationRequest {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        ScgActivationRequest::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ScgActivationRequest");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ScgActivationRequest");
            e
        })
    }
}
// ScgActivationStatus
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum ScgActivationStatus {
    ScgActivated,
    ScgDeactivated,
}

impl ScgActivationStatus {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(1), true)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(1),
            true,
            *self as i128,
            (*self as u32) >= 2,
        )
    }
}

impl PerCodec for ScgActivationStatus {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        ScgActivationStatus::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ScgActivationStatus");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ScgActivationStatus");
            e
        })
    }
}
// ScgIndicator
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum ScgIndicator {
    Released,
}

impl ScgIndicator {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(0), true)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(0),
            true,
            *self as i128,
            (*self as u32) >= 1,
        )
    }
}

impl PerCodec for ScgIndicator {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        ScgIndicator::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ScgIndicator");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ScgIndicator");
            e
        })
    }
}
// ScpacRequest
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum ScpacRequest {
    Initiation,
}

impl ScpacRequest {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(0), true)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(0),
            true,
            *self as i128,
            (*self as u32) >= 1,
        )
    }
}

impl PerCodec for ScpacRequest {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        ScpacRequest::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ScpacRequest");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ScpacRequest");
            e
        })
    }
}
// SCpacConfiguration
#[derive(Clone, Debug)]
pub struct SCpacConfiguration {
    pub reference_configuration_information: Option<ReferenceConfigurationInformation>,
    pub complete_candidate_configuration_indicator: Option<CompleteCandidateConfigurationIndicator>,
}

impl SCpacConfiguration {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 3)?;
        let reference_configuration_information = if optionals[0] {
            Some(ReferenceConfigurationInformation::decode(data)?)
        } else {
            None
        };
        let complete_candidate_configuration_indicator = if optionals[1] {
            Some(CompleteCandidateConfigurationIndicator::decode(data)?)
        } else {
            None
        };

        // Process the extension container

        if optionals[2] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            reference_configuration_information,
            complete_candidate_configuration_indicator,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.reference_configuration_information.is_some());
        optionals.push(self.complete_candidate_configuration_indicator.is_some());
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        if let Some(x) = &self.reference_configuration_information {
            x.encode(data)?;
        }
        if let Some(x) = &self.complete_candidate_configuration_indicator {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl PerCodec for SCpacConfiguration {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        SCpacConfiguration::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SCpacConfiguration");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SCpacConfiguration");
            e
        })
    }
}
// SCpacLowerLayerReferenceConfigRequest
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum SCpacLowerLayerReferenceConfigRequest {
    True,
}

impl SCpacLowerLayerReferenceConfigRequest {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(0), true)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(0),
            true,
            *self as i128,
            (*self as u32) >= 1,
        )
    }
}

impl PerCodec for SCpacLowerLayerReferenceConfigRequest {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        SCpacLowerLayerReferenceConfigRequest::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SCpacLowerLayerReferenceConfigRequest");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SCpacLowerLayerReferenceConfigRequest");
            e
        })
    }
}
// Scs480
#[derive(Clone, Copy, Debug)]
pub struct Scs480(pub u16);

impl Scs480 {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(
            decode::decode_integer(data, Some(0), Some(319), false)?.0 as u16,
        ))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_integer(data, Some(0), Some(319), false, self.0 as i128, false)
    }
}

impl PerCodec for Scs480 {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Scs480::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("Scs480");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("Scs480");
            e
        })
    }
}
// Scs960
#[derive(Clone, Copy, Debug)]
pub struct Scs960(pub u16);

impl Scs960 {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(
            decode::decode_integer(data, Some(0), Some(639), false)?.0 as u16,
        ))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_integer(data, Some(0), Some(639), false, self.0 as i128, false)
    }
}

impl PerCodec for Scs960 {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Scs960::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("Scs960");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("Scs960");
            e
        })
    }
}
// ScsSpecificCarrier
#[derive(Clone, Debug)]
pub struct ScsSpecificCarrier {
    pub offset_to_carrier: u16,
    pub subcarrier_spacing: SubcarrierSpacing3,
    pub carrier_bandwidth: u16,
}

impl ScsSpecificCarrier {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, false, 1)?;
        let offset_to_carrier = decode::decode_integer(data, Some(0), Some(2199), true)?.0 as u16;
        let subcarrier_spacing = SubcarrierSpacing3::decode(data)?;
        let carrier_bandwidth = decode::decode_integer(data, Some(1), Some(275), true)?.0 as u16;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            offset_to_carrier,
            subcarrier_spacing,
            carrier_bandwidth,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, false, &optionals, false)?;
        encode::encode_integer(
            data,
            Some(0),
            Some(2199),
            true,
            self.offset_to_carrier as i128,
            false,
        )?;
        self.subcarrier_spacing.encode(data)?;
        encode::encode_integer(
            data,
            Some(1),
            Some(275),
            true,
            self.carrier_bandwidth as i128,
            false,
        )?;

        Ok(())
    }
}

impl PerCodec for ScsSpecificCarrier {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        ScsSpecificCarrier::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ScsSpecificCarrier");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ScsSpecificCarrier");
            e
        })
    }
}
// SdtBearerConfigurationQueryIndication
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum SdtBearerConfigurationQueryIndication {
    True,
}

impl SdtBearerConfigurationQueryIndication {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(0), true)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(0),
            true,
            *self as i128,
            (*self as u32) >= 1,
        )
    }
}

impl PerCodec for SdtBearerConfigurationQueryIndication {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        SdtBearerConfigurationQueryIndication::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SdtBearerConfigurationQueryIndication");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SdtBearerConfigurationQueryIndication");
            e
        })
    }
}
// SdtBearerConfigurationInfo
#[derive(Clone, Debug)]
pub struct SdtBearerConfigurationInfo {
    pub sdt_bearer_config_list: SdtBearerConfigList,
}

impl SdtBearerConfigurationInfo {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, false, 1)?;
        let sdt_bearer_config_list = SdtBearerConfigList::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            sdt_bearer_config_list,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, false, &optionals, false)?;
        self.sdt_bearer_config_list.encode(data)?;

        Ok(())
    }
}

impl PerCodec for SdtBearerConfigurationInfo {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        SdtBearerConfigurationInfo::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SdtBearerConfigurationInfo");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SdtBearerConfigurationInfo");
            e
        })
    }
}
// SdtBearerConfigList
#[derive(Clone, Debug)]
pub struct SdtBearerConfigList(pub NonEmpty<SdtBearerConfigListItem>);

impl SdtBearerConfigList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(72), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(SdtBearerConfigListItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(72), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for SdtBearerConfigList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        SdtBearerConfigList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SdtBearerConfigList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SdtBearerConfigList");
            e
        })
    }
}
// SdtBearerConfigListItem
#[derive(Clone, Debug)]
pub struct SdtBearerConfigListItem {
    pub sdt_bearer_type: SdtBearerType,
    pub sdtrlc_bearer_configuration: SdtrlcBearerConfiguration,
}

impl SdtBearerConfigListItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, false, 1)?;
        let sdt_bearer_type = SdtBearerType::decode(data)?;
        let sdtrlc_bearer_configuration = SdtrlcBearerConfiguration::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            sdt_bearer_type,
            sdtrlc_bearer_configuration,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, false, &optionals, false)?;
        self.sdt_bearer_type.encode(data)?;
        self.sdtrlc_bearer_configuration.encode(data)?;

        Ok(())
    }
}

impl PerCodec for SdtBearerConfigListItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        SdtBearerConfigListItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SdtBearerConfigListItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SdtBearerConfigListItem");
            e
        })
    }
}
// SdtBearerType
#[derive(Clone, Debug)]
pub enum SdtBearerType {
    Srb(SrbId),
    Drb(DrbId),
}

impl SdtBearerType {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_choice_idx(data, 0, 2, false)?;
        if extended {
            return Err(per_codec_error_new("CHOICE additions not implemented"));
        }
        match idx {
            0 => Ok(Self::Srb(SrbId::decode(data)?)),
            1 => Ok(Self::Drb(DrbId::decode(data)?)),
            2 => {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _ = Criticality::decode(data)?;
                let _ = decode::decode_length_determinent(data, None, None, false)?;
                let result = match id {
                    x => Err(per_codec_error_new(format!("Unrecognised IE type {}", x))),
                };
                data.decode_align()?;
                result
            }
            _ => Err(per_codec_error_new("Unknown choice idx")),
        }
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        match self {
            Self::Srb(x) => {
                encode::encode_choice_idx(data, 0, 2, false, 0, false)?;
                x.encode(data)
            }
            Self::Drb(x) => {
                encode::encode_choice_idx(data, 0, 2, false, 1, false)?;
                x.encode(data)
            }
        }
    }
}

impl PerCodec for SdtBearerType {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        SdtBearerType::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SdtBearerType");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SdtBearerType");
            e
        })
    }
}
// SdtMacPhyCgConfig
#[derive(Clone, Debug)]
pub struct SdtMacPhyCgConfig(pub Vec<u8>);

impl SdtMacPhyCgConfig {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(decode::decode_octetstring(data, None, None, false)?))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_octetstring(data, None, None, false, &self.0, false)
    }
}

impl PerCodec for SdtMacPhyCgConfig {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        SdtMacPhyCgConfig::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SdtMacPhyCgConfig");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SdtMacPhyCgConfig");
            e
        })
    }
}
// SdtInformation
#[derive(Clone, Debug)]
pub struct SdtInformation {
    pub sdt_indicator: SdtIndicator,
    pub sdt_assistant_information: Option<SdtAssistantInformation>,
}

impl SdtInformation {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, false, 2)?;
        let sdt_indicator = SdtIndicator::decode(data)?;
        let sdt_assistant_information = if optionals[0] {
            Some(SdtAssistantInformation::decode(data)?)
        } else {
            None
        };

        // Process the extension container

        if optionals[1] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            sdt_indicator,
            sdt_assistant_information,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.sdt_assistant_information.is_some());
        optionals.push(false);

        encode::encode_sequence_header(data, false, &optionals, false)?;
        self.sdt_indicator.encode(data)?;
        if let Some(x) = &self.sdt_assistant_information {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl PerCodec for SdtInformation {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        SdtInformation::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SdtInformation");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SdtInformation");
            e
        })
    }
}
// SdtrlcBearerConfiguration
#[derive(Clone, Debug)]
pub struct SdtrlcBearerConfiguration(pub Vec<u8>);

impl SdtrlcBearerConfiguration {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(decode::decode_octetstring(data, None, None, false)?))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_octetstring(data, None, None, false, &self.0, false)
    }
}

impl PerCodec for SdtrlcBearerConfiguration {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        SdtrlcBearerConfiguration::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SdtrlcBearerConfiguration");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SdtrlcBearerConfiguration");
            e
        })
    }
}
// SdtTerminationRequest
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum SdtTerminationRequest {
    RadioLinkProblem,
    Normal,
    SdtVolumeThresholdCrossed,
}

impl SdtTerminationRequest {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(1), true)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(1),
            true,
            *self as i128,
            (*self as u32) >= 2,
        )
    }
}

impl PerCodec for SdtTerminationRequest {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        SdtTerminationRequest::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SdtTerminationRequest");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SdtTerminationRequest");
            e
        })
    }
}
// SdtVolumeThreshold
#[derive(Clone, Copy, Debug)]
pub struct SdtVolumeThreshold(pub u32);

impl SdtVolumeThreshold {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(
            decode::decode_integer(data, Some(1), Some(192000), true)?.0 as u32,
        ))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_integer(data, Some(1), Some(192000), true, self.0 as i128, false)
    }
}

impl PerCodec for SdtVolumeThreshold {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        SdtVolumeThreshold::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SdtVolumeThreshold");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SdtVolumeThreshold");
            e
        })
    }
}
// SearchWindowInformation
#[derive(Clone, Debug)]
pub struct SearchWindowInformation {
    pub expected_propagation_delay: i16,
    pub delay_uncertainty: u8,
}

impl SearchWindowInformation {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, false, 1)?;
        let expected_propagation_delay =
            decode::decode_integer(data, Some(-3841), Some(3841), true)?.0 as i16;
        let delay_uncertainty = decode::decode_integer(data, Some(1), Some(246), true)?.0 as u8;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            expected_propagation_delay,
            delay_uncertainty,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, false, &optionals, false)?;
        encode::encode_integer(
            data,
            Some(-3841),
            Some(3841),
            true,
            self.expected_propagation_delay as i128,
            false,
        )?;
        encode::encode_integer(
            data,
            Some(1),
            Some(246),
            true,
            self.delay_uncertainty as i128,
            false,
        )?;

        Ok(())
    }
}

impl PerCodec for SearchWindowInformation {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        SearchWindowInformation::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SearchWindowInformation");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SearchWindowInformation");
            e
        })
    }
}
// SerialNumber
#[derive(Clone, Debug)]
pub struct SerialNumber(pub BitString);

impl SerialNumber {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(decode::decode_bitstring(
            data,
            Some(16),
            Some(16),
            false,
        )?))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_bitstring(data, Some(16), Some(16), false, &self.0, false)
    }
}

impl PerCodec for SerialNumber {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        SerialNumber::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SerialNumber");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SerialNumber");
            e
        })
    }
}
// SibTypePws
#[derive(Clone, Copy, Debug)]
pub struct SibTypePws(pub u8);

impl SibTypePws {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(
            decode::decode_integer(data, Some(6), Some(8), true)?.0 as u8,
        ))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_integer(data, Some(6), Some(8), true, self.0 as i128, false)
    }
}

impl PerCodec for SibTypePws {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        SibTypePws::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SibTypePws");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SibTypePws");
            e
        })
    }
}
// SelectedBandCombinationIndex
#[derive(Clone, Debug)]
pub struct SelectedBandCombinationIndex(pub Vec<u8>);

impl SelectedBandCombinationIndex {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(decode::decode_octetstring(data, None, None, false)?))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_octetstring(data, None, None, false, &self.0, false)
    }
}

impl PerCodec for SelectedBandCombinationIndex {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        SelectedBandCombinationIndex::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SelectedBandCombinationIndex");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SelectedBandCombinationIndex");
            e
        })
    }
}
// SelectedFeatureSetEntryIndex
#[derive(Clone, Debug)]
pub struct SelectedFeatureSetEntryIndex(pub Vec<u8>);

impl SelectedFeatureSetEntryIndex {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(decode::decode_octetstring(data, None, None, false)?))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_octetstring(data, None, None, false, &self.0, false)
    }
}

impl PerCodec for SelectedFeatureSetEntryIndex {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        SelectedFeatureSetEntryIndex::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SelectedFeatureSetEntryIndex");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SelectedFeatureSetEntryIndex");
            e
        })
    }
}
// CgConfigInfo
#[derive(Clone, Debug)]
pub struct CgConfigInfo(pub Vec<u8>);

impl CgConfigInfo {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(decode::decode_octetstring(data, None, None, false)?))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_octetstring(data, None, None, false, &self.0, false)
    }
}

impl PerCodec for CgConfigInfo {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        CgConfigInfo::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CgConfigInfo");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CgConfigInfo");
            e
        })
    }
}
// ServCellInfoList
#[derive(Clone, Debug)]
pub struct ServCellInfoList(pub Vec<u8>);

impl ServCellInfoList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(decode::decode_octetstring(data, None, None, false)?))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_octetstring(data, None, None, false, &self.0, false)
    }
}

impl PerCodec for ServCellInfoList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        ServCellInfoList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ServCellInfoList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ServCellInfoList");
            e
        })
    }
}
// ServCellIndex
#[derive(Clone, Copy, Debug)]
pub struct ServCellIndex(pub u8);

impl ServCellIndex {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(
            decode::decode_integer(data, Some(0), Some(31), true)?.0 as u8,
        ))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_integer(data, Some(0), Some(31), true, self.0 as i128, false)
    }
}

impl PerCodec for ServCellIndex {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        ServCellIndex::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ServCellIndex");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ServCellIndex");
            e
        })
    }
}
// ServingCellMo
#[derive(Clone, Copy, Debug)]
pub struct ServingCellMo(pub u8);

impl ServingCellMo {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(
            decode::decode_integer(data, Some(1), Some(64), true)?.0 as u8,
        ))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_integer(data, Some(1), Some(64), true, self.0 as i128, false)
    }
}

impl PerCodec for ServingCellMo {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        ServingCellMo::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ServingCellMo");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ServingCellMo");
            e
        })
    }
}
// ServingCellMoListItem
#[derive(Clone, Debug)]
pub struct ServingCellMoListItem {
    pub serving_cell_mo: ServingCellMo,
    pub ssb_frequency: u32,
}

impl ServingCellMoListItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, false, 1)?;
        let serving_cell_mo = ServingCellMo::decode(data)?;
        let ssb_frequency = decode::decode_integer(data, Some(0), Some(3279165), false)?.0 as u32;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            serving_cell_mo,
            ssb_frequency,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, false, &optionals, false)?;
        self.serving_cell_mo.encode(data)?;
        encode::encode_integer(
            data,
            Some(0),
            Some(3279165),
            false,
            self.ssb_frequency as i128,
            false,
        )?;

        Ok(())
    }
}

impl PerCodec for ServingCellMoListItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        ServingCellMoListItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ServingCellMoListItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ServingCellMoListItem");
            e
        })
    }
}
// ServingCellMoEncodedInCgcList
#[derive(Clone, Debug)]
pub struct ServingCellMoEncodedInCgcList(pub NonEmpty<ServingCellMoEncodedInCgcItem>);

impl ServingCellMoEncodedInCgcList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(8), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(ServingCellMoEncodedInCgcItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(8), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for ServingCellMoEncodedInCgcList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        ServingCellMoEncodedInCgcList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ServingCellMoEncodedInCgcList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ServingCellMoEncodedInCgcList");
            e
        })
    }
}
// ServingCellMoEncodedInCgcItem
#[derive(Clone, Debug)]
pub struct ServingCellMoEncodedInCgcItem {
    pub serving_cell_mo: ServingCellMo,
    pub bwp_id: Option<BwpId>,
}

impl ServingCellMoEncodedInCgcItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let serving_cell_mo = ServingCellMo::decode(data)?;

        // Process the extension container
        let mut bwp_id: Option<BwpId> = None;

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    711 => bwp_id = Some(BwpId::decode(data)?),
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            serving_cell_mo,
            bwp_id,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();
        if let Some(x) = &self.bwp_id {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 711, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        let mut optionals = BitString::new();
        optionals.push(num_ies != 0);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.serving_cell_mo.encode(data)?;
        if num_ies != 0 {
            encode::encode_length_determinent(data, Some(1), Some(65535), false, num_ies)?;
            data.append_aligned(ies);
        }
        Ok(())
    }
}

impl PerCodec for ServingCellMoEncodedInCgcItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        ServingCellMoEncodedInCgcItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ServingCellMoEncodedInCgcItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ServingCellMoEncodedInCgcItem");
            e
        })
    }
}
// ServedCellInformation
#[derive(Clone, Debug)]
pub struct ServedCellInformation {
    pub nr_cgi: NrCgi,
    pub nr_pci: NrPci,
    pub five_gs_tac: Option<FiveGsTac>,
    pub configured_eps_tac: Option<ConfiguredEpsTac>,
    pub served_plmns: ServedPlmnsList,
    pub nr_mode_info: NrModeInfo,
    pub measurement_timing_configuration: Vec<u8>,
    pub ranac: Option<Ranac>,
    pub extended_served_plmns_list: Option<ExtendedServedPlmnsList>,
    pub cell_direction: Option<CellDirection>,
    pub b_plmn_id_info_list: Option<BPlmnIdInfoList>,
    pub cell_type: Option<CellType>,
    pub configured_tac_indication: Option<ConfiguredTacIndication>,
    pub aggressor_gnb_set_id: Option<AggressorGnbSetId>,
    pub victim_gnb_set_id: Option<VictimGnbSetId>,
    pub iab_info_iab_du: Option<IabInfoIabDu>,
    pub ssb_positions_in_burst: Option<SsbPositionsInBurst>,
    pub nr_prach_config: Option<NrPrachConfig>,
    pub sfn_offset: Option<SfnOffset>,
    pub npn_broadcast_information: Option<NpnBroadcastInformation>,
    pub supported_mbs_fsa_id_list: Option<SupportedMbsFsaIdList>,
    pub redcap_bcast_information: Option<RedcapBcastInformation>,
    pub e_redcap_bcast_information: Option<ERedcapBcastInformation>,
    pub xr_bcast_information: Option<XrBcastInformation>,
    pub barring_exemptionfor_emer_call_info: Option<BarringExemptionforEmerCallInfo>,
}

impl ServedCellInformation {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 3)?;
        let nr_cgi = NrCgi::decode(data)?;
        let nr_pci = NrPci::decode(data)?;
        let five_gs_tac = if optionals[0] {
            Some(FiveGsTac::decode(data)?)
        } else {
            None
        };
        let configured_eps_tac = if optionals[1] {
            Some(ConfiguredEpsTac::decode(data)?)
        } else {
            None
        };
        let served_plmns = ServedPlmnsList::decode(data)?;
        let nr_mode_info = NrModeInfo::decode(data)?;
        let measurement_timing_configuration = decode::decode_octetstring(data, None, None, false)?;

        // Process the extension container
        let mut ranac: Option<Ranac> = None;
        let mut extended_served_plmns_list: Option<ExtendedServedPlmnsList> = None;
        let mut cell_direction: Option<CellDirection> = None;
        let mut b_plmn_id_info_list: Option<BPlmnIdInfoList> = None;
        let mut cell_type: Option<CellType> = None;
        let mut configured_tac_indication: Option<ConfiguredTacIndication> = None;
        let mut aggressor_gnb_set_id: Option<AggressorGnbSetId> = None;
        let mut victim_gnb_set_id: Option<VictimGnbSetId> = None;
        let mut iab_info_iab_du: Option<IabInfoIabDu> = None;
        let mut ssb_positions_in_burst: Option<SsbPositionsInBurst> = None;
        let mut nr_prach_config: Option<NrPrachConfig> = None;
        let mut sfn_offset: Option<SfnOffset> = None;
        let mut npn_broadcast_information: Option<NpnBroadcastInformation> = None;
        let mut supported_mbs_fsa_id_list: Option<SupportedMbsFsaIdList> = None;
        let mut redcap_bcast_information: Option<RedcapBcastInformation> = None;
        let mut e_redcap_bcast_information: Option<ERedcapBcastInformation> = None;
        let mut xr_bcast_information: Option<XrBcastInformation> = None;
        let mut barring_exemptionfor_emer_call_info: Option<BarringExemptionforEmerCallInfo> = None;

        if optionals[2] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    139 => ranac = Some(Ranac::decode(data)?),
                    196 => {
                        extended_served_plmns_list = Some(ExtendedServedPlmnsList::decode(data)?)
                    }
                    201 => cell_direction = Some(CellDirection::decode(data)?),
                    223 => b_plmn_id_info_list = Some(BPlmnIdInfoList::decode(data)?),
                    232 => cell_type = Some(CellType::decode(data)?),
                    425 => configured_tac_indication = Some(ConfiguredTacIndication::decode(data)?),
                    251 => aggressor_gnb_set_id = Some(AggressorGnbSetId::decode(data)?),
                    252 => victim_gnb_set_id = Some(VictimGnbSetId::decode(data)?),
                    290 => iab_info_iab_du = Some(IabInfoIabDu::decode(data)?),
                    357 => ssb_positions_in_burst = Some(SsbPositionsInBurst::decode(data)?),
                    358 => nr_prach_config = Some(NrPrachConfig::decode(data)?),
                    429 => sfn_offset = Some(SfnOffset::decode(data)?),
                    383 => npn_broadcast_information = Some(NpnBroadcastInformation::decode(data)?),
                    478 => supported_mbs_fsa_id_list = Some(SupportedMbsFsaIdList::decode(data)?),
                    579 => redcap_bcast_information = Some(RedcapBcastInformation::decode(data)?),
                    784 => {
                        e_redcap_bcast_information = Some(ERedcapBcastInformation::decode(data)?)
                    }
                    835 => xr_bcast_information = Some(XrBcastInformation::decode(data)?),
                    849 => {
                        barring_exemptionfor_emer_call_info =
                            Some(BarringExemptionforEmerCallInfo::decode(data)?)
                    }
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            nr_cgi,
            nr_pci,
            five_gs_tac,
            configured_eps_tac,
            served_plmns,
            nr_mode_info,
            measurement_timing_configuration,
            ranac,
            extended_served_plmns_list,
            cell_direction,
            b_plmn_id_info_list,
            cell_type,
            configured_tac_indication,
            aggressor_gnb_set_id,
            victim_gnb_set_id,
            iab_info_iab_du,
            ssb_positions_in_burst,
            nr_prach_config,
            sfn_offset,
            npn_broadcast_information,
            supported_mbs_fsa_id_list,
            redcap_bcast_information,
            e_redcap_bcast_information,
            xr_bcast_information,
            barring_exemptionfor_emer_call_info,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();
        if let Some(x) = &self.ranac {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 139, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.extended_served_plmns_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 196, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.cell_direction {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 201, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.b_plmn_id_info_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 223, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.cell_type {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 232, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.configured_tac_indication {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 425, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.aggressor_gnb_set_id {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 251, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.victim_gnb_set_id {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 252, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.iab_info_iab_du {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 290, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.ssb_positions_in_burst {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 357, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.nr_prach_config {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 358, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.sfn_offset {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 429, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.npn_broadcast_information {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 383, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.supported_mbs_fsa_id_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 478, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.redcap_bcast_information {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 579, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.e_redcap_bcast_information {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 784, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.xr_bcast_information {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 835, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.barring_exemptionfor_emer_call_info {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 849, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        let mut optionals = BitString::new();
        optionals.push(self.five_gs_tac.is_some());
        optionals.push(self.configured_eps_tac.is_some());
        optionals.push(num_ies != 0);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.nr_cgi.encode(data)?;
        self.nr_pci.encode(data)?;
        if let Some(x) = &self.five_gs_tac {
            x.encode(data)?;
        }
        if let Some(x) = &self.configured_eps_tac {
            x.encode(data)?;
        }
        self.served_plmns.encode(data)?;
        self.nr_mode_info.encode(data)?;
        encode::encode_octetstring(
            data,
            None,
            None,
            false,
            &self.measurement_timing_configuration,
            false,
        )?;
        if num_ies != 0 {
            encode::encode_length_determinent(data, Some(1), Some(65535), false, num_ies)?;
            data.append_aligned(ies);
        }
        Ok(())
    }
}

impl PerCodec for ServedCellInformation {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        ServedCellInformation::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ServedCellInformation");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ServedCellInformation");
            e
        })
    }
}
// ServingCellsList
#[derive(Clone, Debug)]
pub struct ServingCellsList(pub NonEmpty<ServingCellsListItem>);

impl ServingCellsList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(32), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(ServingCellsListItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(32), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for ServingCellsList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        ServingCellsList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ServingCellsList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ServingCellsList");
            e
        })
    }
}
// ServingCellsListItem
#[derive(Clone, Debug)]
pub struct ServingCellsListItem {
    pub nr_cgi: NrCgi,
    pub iab_mt_cell_na_resource_configuration_mode_info:
        Option<IabMtCellNaResourceConfigurationModeInfo>,
}

impl ServingCellsListItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, false, 2)?;
        let nr_cgi = NrCgi::decode(data)?;
        let iab_mt_cell_na_resource_configuration_mode_info = if optionals[0] {
            Some(IabMtCellNaResourceConfigurationModeInfo::decode(data)?)
        } else {
            None
        };

        // Process the extension container

        if optionals[1] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            nr_cgi,
            iab_mt_cell_na_resource_configuration_mode_info,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(
            self.iab_mt_cell_na_resource_configuration_mode_info
                .is_some(),
        );
        optionals.push(false);

        encode::encode_sequence_header(data, false, &optionals, false)?;
        self.nr_cgi.encode(data)?;
        if let Some(x) = &self.iab_mt_cell_na_resource_configuration_mode_info {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl PerCodec for ServingCellsListItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        ServingCellsListItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ServingCellsListItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ServingCellsListItem");
            e
        })
    }
}
// SupportedMbsFsaIdList
#[derive(Clone, Debug)]
pub struct SupportedMbsFsaIdList(pub NonEmpty<MbsFrequencySelectionAreaIdentity>);

impl SupportedMbsFsaIdList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(256), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(MbsFrequencySelectionAreaIdentity::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(256), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for SupportedMbsFsaIdList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        SupportedMbsFsaIdList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SupportedMbsFsaIdList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SupportedMbsFsaIdList");
            e
        })
    }
}
// MbsFrequencySelectionAreaIdentity
#[derive(Clone, Debug)]
pub struct MbsFrequencySelectionAreaIdentity(pub [u8; 3]);

impl MbsFrequencySelectionAreaIdentity {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(
            decode::decode_octetstring(data, Some(3), Some(3), false)?
                .try_into()
                .unwrap(),
        ))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_octetstring(data, Some(3), Some(3), false, &(self.0).into(), false)
    }
}

impl PerCodec for MbsFrequencySelectionAreaIdentity {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        MbsFrequencySelectionAreaIdentity::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MbsFrequencySelectionAreaIdentity");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MbsFrequencySelectionAreaIdentity");
            e
        })
    }
}
// SfnOffset
#[derive(Clone, Debug)]
pub struct SfnOffset {
    pub sfn_time_offset: BitString,
}

impl SfnOffset {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let sfn_time_offset = decode::decode_bitstring(data, Some(24), Some(24), false)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self { sfn_time_offset })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        encode::encode_bitstring(
            data,
            Some(24),
            Some(24),
            false,
            &self.sfn_time_offset,
            false,
        )?;

        Ok(())
    }
}

impl PerCodec for SfnOffset {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        SfnOffset::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SfnOffset");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SfnOffset");
            e
        })
    }
}
// ServedCellsToAddItem
#[derive(Clone, Debug)]
pub struct ServedCellsToAddItem {
    pub served_cell_information: ServedCellInformation,
    pub gnb_du_system_information: Option<GnbDuSystemInformation>,
}

impl ServedCellsToAddItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 2)?;
        let served_cell_information = ServedCellInformation::decode(data)?;
        let gnb_du_system_information = if optionals[0] {
            Some(GnbDuSystemInformation::decode(data)?)
        } else {
            None
        };

        // Process the extension container

        if optionals[1] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            served_cell_information,
            gnb_du_system_information,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.gnb_du_system_information.is_some());
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.served_cell_information.encode(data)?;
        if let Some(x) = &self.gnb_du_system_information {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl PerCodec for ServedCellsToAddItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        ServedCellsToAddItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ServedCellsToAddItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ServedCellsToAddItem");
            e
        })
    }
}
// ServedCellsToDeleteItem
#[derive(Clone, Debug)]
pub struct ServedCellsToDeleteItem {
    pub old_nr_cgi: NrCgi,
}

impl ServedCellsToDeleteItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let old_nr_cgi = NrCgi::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self { old_nr_cgi })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.old_nr_cgi.encode(data)?;

        Ok(())
    }
}

impl PerCodec for ServedCellsToDeleteItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        ServedCellsToDeleteItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ServedCellsToDeleteItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ServedCellsToDeleteItem");
            e
        })
    }
}
// ServedCellsToModifyItem
#[derive(Clone, Debug)]
pub struct ServedCellsToModifyItem {
    pub old_nr_cgi: NrCgi,
    pub served_cell_information: ServedCellInformation,
    pub gnb_du_system_information: Option<GnbDuSystemInformation>,
}

impl ServedCellsToModifyItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 2)?;
        let old_nr_cgi = NrCgi::decode(data)?;
        let served_cell_information = ServedCellInformation::decode(data)?;
        let gnb_du_system_information = if optionals[0] {
            Some(GnbDuSystemInformation::decode(data)?)
        } else {
            None
        };

        // Process the extension container

        if optionals[1] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            old_nr_cgi,
            served_cell_information,
            gnb_du_system_information,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.gnb_du_system_information.is_some());
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.old_nr_cgi.encode(data)?;
        self.served_cell_information.encode(data)?;
        if let Some(x) = &self.gnb_du_system_information {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl PerCodec for ServedCellsToModifyItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        ServedCellsToModifyItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ServedCellsToModifyItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ServedCellsToModifyItem");
            e
        })
    }
}
// ServedEutraCellsInformation
#[derive(Clone, Debug)]
pub struct ServedEutraCellsInformation {
    pub eutra_mode_info: EutraModeInfo,
    pub protected_eutra_resource_indication: ProtectedEutraResourceIndication,
}

impl ServedEutraCellsInformation {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let eutra_mode_info = EutraModeInfo::decode(data)?;
        let protected_eutra_resource_indication = ProtectedEutraResourceIndication::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            eutra_mode_info,
            protected_eutra_resource_indication,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.eutra_mode_info.encode(data)?;
        self.protected_eutra_resource_indication.encode(data)?;

        Ok(())
    }
}

impl PerCodec for ServedEutraCellsInformation {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        ServedEutraCellsInformation::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ServedEutraCellsInformation");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ServedEutraCellsInformation");
            e
        })
    }
}
// ServiceState
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum ServiceState {
    InService,
    OutOfService,
}

impl ServiceState {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(1), true)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(1),
            true,
            *self as i128,
            (*self as u32) >= 2,
        )
    }
}

impl PerCodec for ServiceState {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        ServiceState::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ServiceState");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ServiceState");
            e
        })
    }
}
// ServiceStatus
#[derive(Clone, Debug)]
pub struct ServiceStatus {
    pub service_state: ServiceState,
    pub switching_off_ongoing: Option<SwitchingOffOngoing>,
}

impl ServiceStatus {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 2)?;
        let service_state = ServiceState::decode(data)?;
        let switching_off_ongoing = if optionals[0] {
            Some(SwitchingOffOngoing::decode(data)?)
        } else {
            None
        };

        // Process the extension container

        if optionals[1] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            service_state,
            switching_off_ongoing,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.switching_off_ongoing.is_some());
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.service_state.encode(data)?;
        if let Some(x) = &self.switching_off_ongoing {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl PerCodec for ServiceStatus {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        ServiceStatus::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ServiceStatus");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ServiceStatus");
            e
        })
    }
}
// RelativeTime1900
#[derive(Clone, Debug)]
pub struct RelativeTime1900(pub BitString);

impl RelativeTime1900 {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(decode::decode_bitstring(
            data,
            Some(64),
            Some(64),
            false,
        )?))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_bitstring(data, Some(64), Some(64), false, &self.0, false)
    }
}

impl PerCodec for RelativeTime1900 {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        RelativeTime1900::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("RelativeTime1900");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("RelativeTime1900");
            e
        })
    }
}
// ShortDrxCycleLength
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum ShortDrxCycleLength {
    Ms2,
    Ms3,
    Ms4,
    Ms5,
    Ms6,
    Ms7,
    Ms8,
    Ms10,
    Ms14,
    Ms16,
    Ms20,
    Ms30,
    Ms32,
    Ms35,
    Ms40,
    Ms64,
    Ms80,
    Ms128,
    Ms160,
    Ms256,
    Ms320,
    Ms512,
    Ms640,
}

impl ShortDrxCycleLength {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(22), true)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(22),
            true,
            *self as i128,
            (*self as u32) >= 23,
        )
    }
}

impl PerCodec for ShortDrxCycleLength {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        ShortDrxCycleLength::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ShortDrxCycleLength");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ShortDrxCycleLength");
            e
        })
    }
}
// ShortNonIntegerDrxCycleLength
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum ShortNonIntegerDrxCycleLength {
    Ms1001over240,
    Ms25over6,
    Ms25over3,
    Ms1001over120,
    Ms100over9,
    Ms25over2,
    Ms40over3,
    Ms125over9,
    Ms50over3,
    Ms1001over60,
    Ms125over6,
    Ms200over9,
    Ms100over3,
    Ms1001over30,
    Ms125over3,
    Ms1001over24,
    Ms200over3,
}

impl ShortNonIntegerDrxCycleLength {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(16), true)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(16),
            true,
            *self as i128,
            (*self as u32) >= 17,
        )
    }
}

impl PerCodec for ShortNonIntegerDrxCycleLength {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        ShortNonIntegerDrxCycleLength::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ShortNonIntegerDrxCycleLength");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ShortNonIntegerDrxCycleLength");
            e
        })
    }
}
// ShortDrxCycleTimer
#[derive(Clone, Copy, Debug)]
pub struct ShortDrxCycleTimer(pub u8);

impl ShortDrxCycleTimer {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(
            decode::decode_integer(data, Some(1), Some(16), false)?.0 as u8,
        ))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_integer(data, Some(1), Some(16), false, self.0 as i128, false)
    }
}

impl PerCodec for ShortDrxCycleTimer {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        ShortDrxCycleTimer::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ShortDrxCycleTimer");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ShortDrxCycleTimer");
            e
        })
    }
}
// Sib1Message
#[derive(Clone, Debug)]
pub struct Sib1Message(pub Vec<u8>);

impl Sib1Message {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(decode::decode_octetstring(data, None, None, false)?))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_octetstring(data, None, None, false, &self.0, false)
    }
}

impl PerCodec for Sib1Message {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Sib1Message::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("Sib1Message");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("Sib1Message");
            e
        })
    }
}
// Sib10Message
#[derive(Clone, Debug)]
pub struct Sib10Message(pub Vec<u8>);

impl Sib10Message {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(decode::decode_octetstring(data, None, None, false)?))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_octetstring(data, None, None, false, &self.0, false)
    }
}

impl PerCodec for Sib10Message {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Sib10Message::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("Sib10Message");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("Sib10Message");
            e
        })
    }
}
// Sib12Message
#[derive(Clone, Debug)]
pub struct Sib12Message(pub Vec<u8>);

impl Sib12Message {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(decode::decode_octetstring(data, None, None, false)?))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_octetstring(data, None, None, false, &self.0, false)
    }
}

impl PerCodec for Sib12Message {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Sib12Message::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("Sib12Message");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("Sib12Message");
            e
        })
    }
}
// Sib13Message
#[derive(Clone, Debug)]
pub struct Sib13Message(pub Vec<u8>);

impl Sib13Message {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(decode::decode_octetstring(data, None, None, false)?))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_octetstring(data, None, None, false, &self.0, false)
    }
}

impl PerCodec for Sib13Message {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Sib13Message::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("Sib13Message");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("Sib13Message");
            e
        })
    }
}
// Sib14Message
#[derive(Clone, Debug)]
pub struct Sib14Message(pub Vec<u8>);

impl Sib14Message {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(decode::decode_octetstring(data, None, None, false)?))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_octetstring(data, None, None, false, &self.0, false)
    }
}

impl PerCodec for Sib14Message {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Sib14Message::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("Sib14Message");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("Sib14Message");
            e
        })
    }
}
// Sib15Message
#[derive(Clone, Debug)]
pub struct Sib15Message(pub Vec<u8>);

impl Sib15Message {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(decode::decode_octetstring(data, None, None, false)?))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_octetstring(data, None, None, false, &self.0, false)
    }
}

impl PerCodec for Sib15Message {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Sib15Message::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("Sib15Message");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("Sib15Message");
            e
        })
    }
}
// Sib17Message
#[derive(Clone, Debug)]
pub struct Sib17Message(pub Vec<u8>);

impl Sib17Message {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(decode::decode_octetstring(data, None, None, false)?))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_octetstring(data, None, None, false, &self.0, false)
    }
}

impl PerCodec for Sib17Message {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Sib17Message::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("Sib17Message");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("Sib17Message");
            e
        })
    }
}
// Sib20Message
#[derive(Clone, Debug)]
pub struct Sib20Message(pub Vec<u8>);

impl Sib20Message {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(decode::decode_octetstring(data, None, None, false)?))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_octetstring(data, None, None, false, &self.0, false)
    }
}

impl PerCodec for Sib20Message {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Sib20Message::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("Sib20Message");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("Sib20Message");
            e
        })
    }
}
// Sib24Message
#[derive(Clone, Debug)]
pub struct Sib24Message(pub Vec<u8>);

impl Sib24Message {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(decode::decode_octetstring(data, None, None, false)?))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_octetstring(data, None, None, false, &self.0, false)
    }
}

impl PerCodec for Sib24Message {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Sib24Message::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("Sib24Message");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("Sib24Message");
            e
        })
    }
}
// Sib22Message
#[derive(Clone, Debug)]
pub struct Sib22Message(pub Vec<u8>);

impl Sib22Message {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(decode::decode_octetstring(data, None, None, false)?))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_octetstring(data, None, None, false, &self.0, false)
    }
}

impl PerCodec for Sib22Message {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Sib22Message::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("Sib22Message");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("Sib22Message");
            e
        })
    }
}
// Sib23Message
#[derive(Clone, Debug)]
pub struct Sib23Message(pub Vec<u8>);

impl Sib23Message {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(decode::decode_octetstring(data, None, None, false)?))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_octetstring(data, None, None, false, &self.0, false)
    }
}

impl PerCodec for Sib23Message {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Sib23Message::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("Sib23Message");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("Sib23Message");
            e
        })
    }
}
// Sib17bisMessage
#[derive(Clone, Debug)]
pub struct Sib17bisMessage(pub Vec<u8>);

impl Sib17bisMessage {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(decode::decode_octetstring(data, None, None, false)?))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_octetstring(data, None, None, false, &self.0, false)
    }
}

impl PerCodec for Sib17bisMessage {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Sib17bisMessage::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("Sib17bisMessage");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("Sib17bisMessage");
            e
        })
    }
}
// SiType
#[derive(Clone, Copy, Debug)]
pub struct SiType(pub u8);

impl SiType {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(
            decode::decode_integer(data, Some(1), Some(32), true)?.0 as u8,
        ))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_integer(data, Some(1), Some(32), true, self.0 as i128, false)
    }
}

impl PerCodec for SiType {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        SiType::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SiType");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SiType");
            e
        })
    }
}
// SiTypeList
#[derive(Clone, Debug)]
pub struct SiTypeList(pub NonEmpty<SiTypeItem>);

impl SiTypeList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(32), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(SiTypeItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(32), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for SiTypeList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        SiTypeList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SiTypeList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SiTypeList");
            e
        })
    }
}
// SiTypeItem
#[derive(Clone, Debug)]
pub struct SiTypeItem {
    pub si_type: SiType,
}

impl SiTypeItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, false, 1)?;
        let si_type = SiType::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self { si_type })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, false, &optionals, false)?;
        self.si_type.encode(data)?;

        Ok(())
    }
}

impl PerCodec for SiTypeItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        SiTypeItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SiTypeItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SiTypeItem");
            e
        })
    }
}
// SibTypeToBeUpdatedListItem
#[derive(Clone, Debug)]
pub struct SibTypeToBeUpdatedListItem {
    pub sib_type: u8,
    pub sib_message: Vec<u8>,
    pub value_tag: u8,
    pub area_scope: Option<AreaScope>,
}

impl SibTypeToBeUpdatedListItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let sib_type = decode::decode_integer(data, Some(2), Some(32), true)?.0 as u8;
        let sib_message = decode::decode_octetstring(data, None, None, false)?;
        let value_tag = decode::decode_integer(data, Some(0), Some(31), true)?.0 as u8;

        // Process the extension container
        let mut area_scope: Option<AreaScope> = None;

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    240 => area_scope = Some(AreaScope::decode(data)?),
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            sib_type,
            sib_message,
            value_tag,
            area_scope,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();
        if let Some(x) = &self.area_scope {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 240, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        let mut optionals = BitString::new();
        optionals.push(num_ies != 0);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        encode::encode_integer(data, Some(2), Some(32), true, self.sib_type as i128, false)?;
        encode::encode_octetstring(data, None, None, false, &self.sib_message, false)?;
        encode::encode_integer(data, Some(0), Some(31), true, self.value_tag as i128, false)?;
        if num_ies != 0 {
            encode::encode_length_determinent(data, Some(1), Some(65535), false, num_ies)?;
            data.append_aligned(ies);
        }
        Ok(())
    }
}

impl PerCodec for SibTypeToBeUpdatedListItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        SibTypeToBeUpdatedListItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SibTypeToBeUpdatedListItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SibTypeToBeUpdatedListItem");
            e
        })
    }
}
// SidelinkRelayConfiguration
#[derive(Clone, Debug)]
pub struct SidelinkRelayConfiguration {
    pub gnb_du_ue_f1api_dof_relay_ue: GnbDuUeF1apId,
    pub remote_ue_local_id: RemoteUeLocalId,
    pub sidelink_configuration_container: Option<SidelinkConfigurationContainer>,
}

impl SidelinkRelayConfiguration {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 2)?;
        let gnb_du_ue_f1api_dof_relay_ue = GnbDuUeF1apId::decode(data)?;
        let remote_ue_local_id = RemoteUeLocalId::decode(data)?;
        let sidelink_configuration_container = if optionals[0] {
            Some(SidelinkConfigurationContainer::decode(data)?)
        } else {
            None
        };

        // Process the extension container

        if optionals[1] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            gnb_du_ue_f1api_dof_relay_ue,
            remote_ue_local_id,
            sidelink_configuration_container,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.sidelink_configuration_container.is_some());
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.gnb_du_ue_f1api_dof_relay_ue.encode(data)?;
        self.remote_ue_local_id.encode(data)?;
        if let Some(x) = &self.sidelink_configuration_container {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl PerCodec for SidelinkRelayConfiguration {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        SidelinkRelayConfiguration::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SidelinkRelayConfiguration");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SidelinkRelayConfiguration");
            e
        })
    }
}
// SidelinkConfigurationContainer
#[derive(Clone, Debug)]
pub struct SidelinkConfigurationContainer(pub Vec<u8>);

impl SidelinkConfigurationContainer {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(decode::decode_octetstring(data, None, None, false)?))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_octetstring(data, None, None, false, &self.0, false)
    }
}

impl PerCodec for SidelinkConfigurationContainer {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        SidelinkConfigurationContainer::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SidelinkConfigurationContainer");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SidelinkConfigurationContainer");
            e
        })
    }
}
// SlDrbId
#[derive(Clone, Copy, Debug)]
pub struct SlDrbId(pub u16);

impl SlDrbId {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(
            decode::decode_integer(data, Some(1), Some(512), true)?.0 as u16,
        ))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_integer(data, Some(1), Some(512), true, self.0 as i128, false)
    }
}

impl PerCodec for SlDrbId {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        SlDrbId::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SlDrbId");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SlDrbId");
            e
        })
    }
}
// SlDrbInformation
#[derive(Clone, Debug)]
pub struct SlDrbInformation {
    pub sl_drb_qos: Pc5QosParameters,
    pub flows_mapped_to_sl_drb_list: FlowsMappedToSlDrbList,
}

impl SlDrbInformation {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (_optionals, _extensions_present) = decode::decode_sequence_header(data, true, 0)?;
        let sl_drb_qos = Pc5QosParameters::decode(data)?;
        let flows_mapped_to_sl_drb_list = FlowsMappedToSlDrbList::decode(data)?;

        Ok(Self {
            sl_drb_qos,
            flows_mapped_to_sl_drb_list,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let optionals = BitString::new();

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.sl_drb_qos.encode(data)?;
        self.flows_mapped_to_sl_drb_list.encode(data)?;

        Ok(())
    }
}

impl PerCodec for SlDrbInformation {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        SlDrbInformation::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SlDrbInformation");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SlDrbInformation");
            e
        })
    }
}
// SlDrbsFailedToBeModifiedItem
#[derive(Clone, Debug)]
pub struct SlDrbsFailedToBeModifiedItem {
    pub sl_drb_id: SlDrbId,
    pub cause: Option<Cause>,
}

impl SlDrbsFailedToBeModifiedItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, false, 2)?;
        let sl_drb_id = SlDrbId::decode(data)?;
        let cause = if optionals[0] {
            Some(Cause::decode(data)?)
        } else {
            None
        };

        // Process the extension container

        if optionals[1] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self { sl_drb_id, cause })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.cause.is_some());
        optionals.push(false);

        encode::encode_sequence_header(data, false, &optionals, false)?;
        self.sl_drb_id.encode(data)?;
        if let Some(x) = &self.cause {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl PerCodec for SlDrbsFailedToBeModifiedItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        SlDrbsFailedToBeModifiedItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SlDrbsFailedToBeModifiedItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SlDrbsFailedToBeModifiedItem");
            e
        })
    }
}
// SlDrbsFailedToBeSetupItem
#[derive(Clone, Debug)]
pub struct SlDrbsFailedToBeSetupItem {
    pub sl_drb_id: SlDrbId,
    pub cause: Option<Cause>,
}

impl SlDrbsFailedToBeSetupItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, false, 2)?;
        let sl_drb_id = SlDrbId::decode(data)?;
        let cause = if optionals[0] {
            Some(Cause::decode(data)?)
        } else {
            None
        };

        // Process the extension container

        if optionals[1] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self { sl_drb_id, cause })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.cause.is_some());
        optionals.push(false);

        encode::encode_sequence_header(data, false, &optionals, false)?;
        self.sl_drb_id.encode(data)?;
        if let Some(x) = &self.cause {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl PerCodec for SlDrbsFailedToBeSetupItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        SlDrbsFailedToBeSetupItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SlDrbsFailedToBeSetupItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SlDrbsFailedToBeSetupItem");
            e
        })
    }
}
// SlDrbsFailedToBeSetupModItem
#[derive(Clone, Debug)]
pub struct SlDrbsFailedToBeSetupModItem {
    pub sl_drb_id: SlDrbId,
    pub cause: Option<Cause>,
}

impl SlDrbsFailedToBeSetupModItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, false, 2)?;
        let sl_drb_id = SlDrbId::decode(data)?;
        let cause = if optionals[0] {
            Some(Cause::decode(data)?)
        } else {
            None
        };

        // Process the extension container

        if optionals[1] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self { sl_drb_id, cause })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.cause.is_some());
        optionals.push(false);

        encode::encode_sequence_header(data, false, &optionals, false)?;
        self.sl_drb_id.encode(data)?;
        if let Some(x) = &self.cause {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl PerCodec for SlDrbsFailedToBeSetupModItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        SlDrbsFailedToBeSetupModItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SlDrbsFailedToBeSetupModItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SlDrbsFailedToBeSetupModItem");
            e
        })
    }
}
// SlDrbsModifiedItem
#[derive(Clone, Debug)]
pub struct SlDrbsModifiedItem {
    pub sl_drb_id: SlDrbId,
}

impl SlDrbsModifiedItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, false, 1)?;
        let sl_drb_id = SlDrbId::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self { sl_drb_id })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, false, &optionals, false)?;
        self.sl_drb_id.encode(data)?;

        Ok(())
    }
}

impl PerCodec for SlDrbsModifiedItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        SlDrbsModifiedItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SlDrbsModifiedItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SlDrbsModifiedItem");
            e
        })
    }
}
// SlDrbsModifiedConfItem
#[derive(Clone, Debug)]
pub struct SlDrbsModifiedConfItem {
    pub sl_drb_id: SlDrbId,
}

impl SlDrbsModifiedConfItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, false, 1)?;
        let sl_drb_id = SlDrbId::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self { sl_drb_id })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, false, &optionals, false)?;
        self.sl_drb_id.encode(data)?;

        Ok(())
    }
}

impl PerCodec for SlDrbsModifiedConfItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        SlDrbsModifiedConfItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SlDrbsModifiedConfItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SlDrbsModifiedConfItem");
            e
        })
    }
}
// SlDrbsRequiredToBeModifiedItem
#[derive(Clone, Debug)]
pub struct SlDrbsRequiredToBeModifiedItem {
    pub sl_drb_id: SlDrbId,
}

impl SlDrbsRequiredToBeModifiedItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, false, 1)?;
        let sl_drb_id = SlDrbId::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self { sl_drb_id })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, false, &optionals, false)?;
        self.sl_drb_id.encode(data)?;

        Ok(())
    }
}

impl PerCodec for SlDrbsRequiredToBeModifiedItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        SlDrbsRequiredToBeModifiedItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SlDrbsRequiredToBeModifiedItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SlDrbsRequiredToBeModifiedItem");
            e
        })
    }
}
// SlDrbsRequiredToBeReleasedItem
#[derive(Clone, Debug)]
pub struct SlDrbsRequiredToBeReleasedItem {
    pub sl_drb_id: SlDrbId,
}

impl SlDrbsRequiredToBeReleasedItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, false, 1)?;
        let sl_drb_id = SlDrbId::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self { sl_drb_id })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, false, &optionals, false)?;
        self.sl_drb_id.encode(data)?;

        Ok(())
    }
}

impl PerCodec for SlDrbsRequiredToBeReleasedItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        SlDrbsRequiredToBeReleasedItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SlDrbsRequiredToBeReleasedItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SlDrbsRequiredToBeReleasedItem");
            e
        })
    }
}
// SlDrbsSetupItem
#[derive(Clone, Debug)]
pub struct SlDrbsSetupItem {
    pub sl_drb_id: SlDrbId,
}

impl SlDrbsSetupItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, false, 1)?;
        let sl_drb_id = SlDrbId::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self { sl_drb_id })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, false, &optionals, false)?;
        self.sl_drb_id.encode(data)?;

        Ok(())
    }
}

impl PerCodec for SlDrbsSetupItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        SlDrbsSetupItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SlDrbsSetupItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SlDrbsSetupItem");
            e
        })
    }
}
// SlDrbsSetupModItem
#[derive(Clone, Debug)]
pub struct SlDrbsSetupModItem {
    pub sl_drb_id: SlDrbId,
}

impl SlDrbsSetupModItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, false, 1)?;
        let sl_drb_id = SlDrbId::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self { sl_drb_id })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, false, &optionals, false)?;
        self.sl_drb_id.encode(data)?;

        Ok(())
    }
}

impl PerCodec for SlDrbsSetupModItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        SlDrbsSetupModItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SlDrbsSetupModItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SlDrbsSetupModItem");
            e
        })
    }
}
// SlDrbsToBeModifiedItem
#[derive(Clone, Debug)]
pub struct SlDrbsToBeModifiedItem {
    pub sl_drb_id: SlDrbId,
    pub sl_drb_information: Option<SlDrbInformation>,
    pub rlc_mode: Option<RlcMode>,
    pub duplication_indication: Option<DuplicationIndication>,
}

impl SlDrbsToBeModifiedItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, false, 3)?;
        let sl_drb_id = SlDrbId::decode(data)?;
        let sl_drb_information = if optionals[0] {
            Some(SlDrbInformation::decode(data)?)
        } else {
            None
        };
        let rlc_mode = if optionals[1] {
            Some(RlcMode::decode(data)?)
        } else {
            None
        };

        // Process the extension container
        let mut duplication_indication: Option<DuplicationIndication> = None;

        if optionals[2] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    719 => duplication_indication = Some(DuplicationIndication::decode(data)?),
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            sl_drb_id,
            sl_drb_information,
            rlc_mode,
            duplication_indication,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();
        if let Some(x) = &self.duplication_indication {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 719, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        let mut optionals = BitString::new();
        optionals.push(self.sl_drb_information.is_some());
        optionals.push(self.rlc_mode.is_some());
        optionals.push(num_ies != 0);

        encode::encode_sequence_header(data, false, &optionals, false)?;
        self.sl_drb_id.encode(data)?;
        if let Some(x) = &self.sl_drb_information {
            x.encode(data)?;
        }
        if let Some(x) = &self.rlc_mode {
            x.encode(data)?;
        }
        if num_ies != 0 {
            encode::encode_length_determinent(data, Some(1), Some(65535), false, num_ies)?;
            data.append_aligned(ies);
        }
        Ok(())
    }
}

impl PerCodec for SlDrbsToBeModifiedItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        SlDrbsToBeModifiedItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SlDrbsToBeModifiedItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SlDrbsToBeModifiedItem");
            e
        })
    }
}
// SlDrbsToBeReleasedItem
#[derive(Clone, Debug)]
pub struct SlDrbsToBeReleasedItem {
    pub sl_drb_id: SlDrbId,
}

impl SlDrbsToBeReleasedItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, false, 1)?;
        let sl_drb_id = SlDrbId::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self { sl_drb_id })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, false, &optionals, false)?;
        self.sl_drb_id.encode(data)?;

        Ok(())
    }
}

impl PerCodec for SlDrbsToBeReleasedItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        SlDrbsToBeReleasedItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SlDrbsToBeReleasedItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SlDrbsToBeReleasedItem");
            e
        })
    }
}
// SlDrbsToBeSetupItem
#[derive(Clone, Debug)]
pub struct SlDrbsToBeSetupItem {
    pub sl_drb_id: SlDrbId,
    pub sl_drb_information: SlDrbInformation,
    pub rlc_mode: RlcMode,
    pub duplication_indication: Option<DuplicationIndication>,
}

impl SlDrbsToBeSetupItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, false, 1)?;
        let sl_drb_id = SlDrbId::decode(data)?;
        let sl_drb_information = SlDrbInformation::decode(data)?;
        let rlc_mode = RlcMode::decode(data)?;

        // Process the extension container
        let mut duplication_indication: Option<DuplicationIndication> = None;

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    719 => duplication_indication = Some(DuplicationIndication::decode(data)?),
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            sl_drb_id,
            sl_drb_information,
            rlc_mode,
            duplication_indication,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();
        if let Some(x) = &self.duplication_indication {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 719, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        let mut optionals = BitString::new();
        optionals.push(num_ies != 0);

        encode::encode_sequence_header(data, false, &optionals, false)?;
        self.sl_drb_id.encode(data)?;
        self.sl_drb_information.encode(data)?;
        self.rlc_mode.encode(data)?;
        if num_ies != 0 {
            encode::encode_length_determinent(data, Some(1), Some(65535), false, num_ies)?;
            data.append_aligned(ies);
        }
        Ok(())
    }
}

impl PerCodec for SlDrbsToBeSetupItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        SlDrbsToBeSetupItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SlDrbsToBeSetupItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SlDrbsToBeSetupItem");
            e
        })
    }
}
// SlDrbsToBeSetupModItem
#[derive(Clone, Debug)]
pub struct SlDrbsToBeSetupModItem {
    pub sl_drb_id: SlDrbId,
    pub sl_drb_information: SlDrbInformation,
    pub rlc_mode: Option<RlcMode>,
    pub duplication_indication: Option<DuplicationIndication>,
}

impl SlDrbsToBeSetupModItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, false, 2)?;
        let sl_drb_id = SlDrbId::decode(data)?;
        let sl_drb_information = SlDrbInformation::decode(data)?;
        let rlc_mode = if optionals[0] {
            Some(RlcMode::decode(data)?)
        } else {
            None
        };

        // Process the extension container
        let mut duplication_indication: Option<DuplicationIndication> = None;

        if optionals[1] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    719 => duplication_indication = Some(DuplicationIndication::decode(data)?),
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            sl_drb_id,
            sl_drb_information,
            rlc_mode,
            duplication_indication,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();
        if let Some(x) = &self.duplication_indication {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 719, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        let mut optionals = BitString::new();
        optionals.push(self.rlc_mode.is_some());
        optionals.push(num_ies != 0);

        encode::encode_sequence_header(data, false, &optionals, false)?;
        self.sl_drb_id.encode(data)?;
        self.sl_drb_information.encode(data)?;
        if let Some(x) = &self.rlc_mode {
            x.encode(data)?;
        }
        if num_ies != 0 {
            encode::encode_length_determinent(data, Some(1), Some(65535), false, num_ies)?;
            data.append_aligned(ies);
        }
        Ok(())
    }
}

impl PerCodec for SlDrbsToBeSetupModItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        SlDrbsToBeSetupModItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SlDrbsToBeSetupModItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SlDrbsToBeSetupModItem");
            e
        })
    }
}
// SldrxCycleList
#[derive(Clone, Debug)]
pub struct SldrxCycleList(pub NonEmpty<SldrxCycleItem>);

impl SldrxCycleList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(32), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(SldrxCycleItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(32), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for SldrxCycleList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        SldrxCycleList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SldrxCycleList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SldrxCycleList");
            e
        })
    }
}
// SldrxCycleItem
#[derive(Clone, Debug)]
pub struct SldrxCycleItem {
    pub rx_ue_id: BitString,
    pub sldrx_information: SldrxInformation,
}

impl SldrxCycleItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let rx_ue_id = decode::decode_bitstring(data, Some(24), Some(24), false)?;
        let sldrx_information = SldrxInformation::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            rx_ue_id,
            sldrx_information,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        encode::encode_bitstring(data, Some(24), Some(24), false, &self.rx_ue_id, false)?;
        self.sldrx_information.encode(data)?;

        Ok(())
    }
}

impl PerCodec for SldrxCycleItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        SldrxCycleItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SldrxCycleItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SldrxCycleItem");
            e
        })
    }
}
// SldrxInformation
#[derive(Clone, Debug)]
pub enum SldrxInformation {
    SldrxCycle(SldrxCycleLength),
    NosLdrx(SldrxConfigurationIndicator),
}

impl SldrxInformation {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_choice_idx(data, 0, 2, false)?;
        if extended {
            return Err(per_codec_error_new("CHOICE additions not implemented"));
        }
        match idx {
            0 => Ok(Self::SldrxCycle(SldrxCycleLength::decode(data)?)),
            1 => Ok(Self::NosLdrx(SldrxConfigurationIndicator::decode(data)?)),
            2 => {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _ = Criticality::decode(data)?;
                let _ = decode::decode_length_determinent(data, None, None, false)?;
                let result = match id {
                    x => Err(per_codec_error_new(format!("Unrecognised IE type {}", x))),
                };
                data.decode_align()?;
                result
            }
            _ => Err(per_codec_error_new("Unknown choice idx")),
        }
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        match self {
            Self::SldrxCycle(x) => {
                encode::encode_choice_idx(data, 0, 2, false, 0, false)?;
                x.encode(data)
            }
            Self::NosLdrx(x) => {
                encode::encode_choice_idx(data, 0, 2, false, 1, false)?;
                x.encode(data)
            }
        }
    }
}

impl PerCodec for SldrxInformation {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        SldrxInformation::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SldrxInformation");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SldrxInformation");
            e
        })
    }
}
// SldrxCycleLength
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum SldrxCycleLength {
    Ms10,
    Ms20,
    Ms32,
    Ms40,
    Ms60,
    Ms64,
    Ms70,
    Ms80,
    Ms128,
    Ms160,
    Ms256,
    Ms320,
    Ms512,
    Ms640,
    Ms1024,
    Ms1280,
    Ms2048,
    Ms2560,
    Ms5120,
    Ms10240,
}

impl SldrxCycleLength {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(19), true)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(19),
            true,
            *self as i128,
            (*self as u32) >= 20,
        )
    }
}

impl PerCodec for SldrxCycleLength {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        SldrxCycleLength::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SldrxCycleLength");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SldrxCycleLength");
            e
        })
    }
}
// SldrxConfigurationIndicator
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum SldrxConfigurationIndicator {
    Release,
}

impl SldrxConfigurationIndicator {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(0), true)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(0),
            true,
            *self as i128,
            (*self as u32) >= 1,
        )
    }
}

impl PerCodec for SldrxConfigurationIndicator {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        SldrxConfigurationIndicator::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SldrxConfigurationIndicator");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SldrxConfigurationIndicator");
            e
        })
    }
}
// SlPhyMacRlcConfig
#[derive(Clone, Debug)]
pub struct SlPhyMacRlcConfig(pub Vec<u8>);

impl SlPhyMacRlcConfig {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(decode::decode_octetstring(data, None, None, false)?))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_octetstring(data, None, None, false, &self.0, false)
    }
}

impl PerCodec for SlPhyMacRlcConfig {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        SlPhyMacRlcConfig::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SlPhyMacRlcConfig");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SlPhyMacRlcConfig");
            e
        })
    }
}
// SlPhyMacRlcConfigExt
#[derive(Clone, Debug)]
pub struct SlPhyMacRlcConfigExt(pub Vec<u8>);

impl SlPhyMacRlcConfigExt {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(decode::decode_octetstring(data, None, None, false)?))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_octetstring(data, None, None, false, &self.0, false)
    }
}

impl PerCodec for SlPhyMacRlcConfigExt {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        SlPhyMacRlcConfigExt::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SlPhyMacRlcConfigExt");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SlPhyMacRlcConfigExt");
            e
        })
    }
}
// SlRlcChannelToAddModList
#[derive(Clone, Debug)]
pub struct SlRlcChannelToAddModList(pub Vec<u8>);

impl SlRlcChannelToAddModList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(decode::decode_octetstring(data, None, None, false)?))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_octetstring(data, None, None, false, &self.0, false)
    }
}

impl PerCodec for SlRlcChannelToAddModList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        SlRlcChannelToAddModList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SlRlcChannelToAddModList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SlRlcChannelToAddModList");
            e
        })
    }
}
// SlConfigDedicatedEutraInfo
#[derive(Clone, Debug)]
pub struct SlConfigDedicatedEutraInfo(pub Vec<u8>);

impl SlConfigDedicatedEutraInfo {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(decode::decode_octetstring(data, None, None, false)?))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_octetstring(data, None, None, false, &self.0, false)
    }
}

impl PerCodec for SlConfigDedicatedEutraInfo {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        SlConfigDedicatedEutraInfo::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SlConfigDedicatedEutraInfo");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SlConfigDedicatedEutraInfo");
            e
        })
    }
}
// SliceAvailableCapacity
#[derive(Clone, Debug)]
pub struct SliceAvailableCapacity {
    pub slice_available_capacity_list: SliceAvailableCapacityList,
}

impl SliceAvailableCapacity {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, false, 1)?;
        let slice_available_capacity_list = SliceAvailableCapacityList::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            slice_available_capacity_list,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, false, &optionals, false)?;
        self.slice_available_capacity_list.encode(data)?;

        Ok(())
    }
}

impl PerCodec for SliceAvailableCapacity {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        SliceAvailableCapacity::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SliceAvailableCapacity");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SliceAvailableCapacity");
            e
        })
    }
}
// SliceAvailableCapacityList
#[derive(Clone, Debug)]
pub struct SliceAvailableCapacityList(pub NonEmpty<SliceAvailableCapacityItem>);

impl SliceAvailableCapacityList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(12), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(SliceAvailableCapacityItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(12), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for SliceAvailableCapacityList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        SliceAvailableCapacityList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SliceAvailableCapacityList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SliceAvailableCapacityList");
            e
        })
    }
}
// SliceAvailableCapacityItem
#[derive(Clone, Debug)]
pub struct SliceAvailableCapacityItem {
    pub plmn_identity: PlmnIdentity,
    pub snssai_available_capacity_list: SnssaiAvailableCapacityList,
}

impl SliceAvailableCapacityItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, false, 1)?;
        let plmn_identity = PlmnIdentity::decode(data)?;
        let snssai_available_capacity_list = SnssaiAvailableCapacityList::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            plmn_identity,
            snssai_available_capacity_list,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, false, &optionals, false)?;
        self.plmn_identity.encode(data)?;
        self.snssai_available_capacity_list.encode(data)?;

        Ok(())
    }
}

impl PerCodec for SliceAvailableCapacityItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        SliceAvailableCapacityItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SliceAvailableCapacityItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SliceAvailableCapacityItem");
            e
        })
    }
}
// SnssaiAvailableCapacityList
#[derive(Clone, Debug)]
pub struct SnssaiAvailableCapacityList(pub NonEmpty<SnssaiAvailableCapacityItem>);

impl SnssaiAvailableCapacityList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(1024), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(SnssaiAvailableCapacityItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(1024), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for SnssaiAvailableCapacityList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        SnssaiAvailableCapacityList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SnssaiAvailableCapacityList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SnssaiAvailableCapacityList");
            e
        })
    }
}
// SnssaiAvailableCapacityItem
#[derive(Clone, Debug)]
pub struct SnssaiAvailableCapacityItem {
    pub snssai: Snssai,
    pub slice_available_capacity_value_downlink: Option<u8>,
    pub slice_available_capacity_value_uplink: Option<u8>,
}

impl SnssaiAvailableCapacityItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, false, 3)?;
        let snssai = Snssai::decode(data)?;
        let slice_available_capacity_value_downlink = if optionals[0] {
            Some(decode::decode_integer(data, Some(0), Some(100), false)?.0 as u8)
        } else {
            None
        };
        let slice_available_capacity_value_uplink = if optionals[1] {
            Some(decode::decode_integer(data, Some(0), Some(100), false)?.0 as u8)
        } else {
            None
        };

        // Process the extension container

        if optionals[2] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            snssai,
            slice_available_capacity_value_downlink,
            slice_available_capacity_value_uplink,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.slice_available_capacity_value_downlink.is_some());
        optionals.push(self.slice_available_capacity_value_uplink.is_some());
        optionals.push(false);

        encode::encode_sequence_header(data, false, &optionals, false)?;
        self.snssai.encode(data)?;
        if let Some(x) = &self.slice_available_capacity_value_downlink {
            encode::encode_integer(data, Some(0), Some(100), false, *x as i128, false)?;
        }
        if let Some(x) = &self.slice_available_capacity_value_uplink {
            encode::encode_integer(data, Some(0), Some(100), false, *x as i128, false)?;
        }

        Ok(())
    }
}

impl PerCodec for SnssaiAvailableCapacityItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        SnssaiAvailableCapacityItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SnssaiAvailableCapacityItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SnssaiAvailableCapacityItem");
            e
        })
    }
}
// SliceRadioResourceStatus
#[derive(Clone, Debug)]
pub struct SliceRadioResourceStatus {
    pub slice_radio_resource_status: SliceRadioResourceStatusList,
}

impl SliceRadioResourceStatus {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, false, 1)?;
        let slice_radio_resource_status = SliceRadioResourceStatusList::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            slice_radio_resource_status,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, false, &optionals, false)?;
        self.slice_radio_resource_status.encode(data)?;

        Ok(())
    }
}

impl PerCodec for SliceRadioResourceStatus {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        SliceRadioResourceStatus::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SliceRadioResourceStatus");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SliceRadioResourceStatus");
            e
        })
    }
}
// SliceRadioResourceStatusList
#[derive(Clone, Debug)]
pub struct SliceRadioResourceStatusList(pub NonEmpty<SliceRadioResourceStatusItem>);

impl SliceRadioResourceStatusList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(12), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(SliceRadioResourceStatusItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(12), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for SliceRadioResourceStatusList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        SliceRadioResourceStatusList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SliceRadioResourceStatusList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SliceRadioResourceStatusList");
            e
        })
    }
}
// SliceRadioResourceStatusItem
#[derive(Clone, Debug)]
pub struct SliceRadioResourceStatusItem {
    pub plmn_identity: PlmnIdentity,
    pub snssai_radio_resource_status_list: SnssaiRadioResourceStatusList,
}

impl SliceRadioResourceStatusItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, false, 1)?;
        let plmn_identity = PlmnIdentity::decode(data)?;
        let snssai_radio_resource_status_list = SnssaiRadioResourceStatusList::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            plmn_identity,
            snssai_radio_resource_status_list,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, false, &optionals, false)?;
        self.plmn_identity.encode(data)?;
        self.snssai_radio_resource_status_list.encode(data)?;

        Ok(())
    }
}

impl PerCodec for SliceRadioResourceStatusItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        SliceRadioResourceStatusItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SliceRadioResourceStatusItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SliceRadioResourceStatusItem");
            e
        })
    }
}
// SnssaiRadioResourceStatusList
#[derive(Clone, Debug)]
pub struct SnssaiRadioResourceStatusList(pub NonEmpty<SnssaiRadioResourceStatusItem>);

impl SnssaiRadioResourceStatusList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(1024), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(SnssaiRadioResourceStatusItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(1024), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for SnssaiRadioResourceStatusList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        SnssaiRadioResourceStatusList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SnssaiRadioResourceStatusList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SnssaiRadioResourceStatusList");
            e
        })
    }
}
// SnssaiRadioResourceStatusItem
#[derive(Clone, Debug)]
pub struct SnssaiRadioResourceStatusItem {
    pub snssai: Snssai,
    pub snssa_idl_gbrpr_busage: u8,
    pub snssa_iul_gbrpr_busage: u8,
    pub snssa_idl_non_gbrpr_busage: u8,
    pub snssa_iul_non_gbrpr_busage: u8,
    pub snssa_idl_total_pr_ballocation: u8,
    pub snssa_iul_total_pr_ballocation: u8,
}

impl SnssaiRadioResourceStatusItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, false, 1)?;
        let snssai = Snssai::decode(data)?;
        let snssa_idl_gbrpr_busage =
            decode::decode_integer(data, Some(0), Some(100), false)?.0 as u8;
        let snssa_iul_gbrpr_busage =
            decode::decode_integer(data, Some(0), Some(100), false)?.0 as u8;
        let snssa_idl_non_gbrpr_busage =
            decode::decode_integer(data, Some(0), Some(100), false)?.0 as u8;
        let snssa_iul_non_gbrpr_busage =
            decode::decode_integer(data, Some(0), Some(100), false)?.0 as u8;
        let snssa_idl_total_pr_ballocation =
            decode::decode_integer(data, Some(0), Some(100), false)?.0 as u8;
        let snssa_iul_total_pr_ballocation =
            decode::decode_integer(data, Some(0), Some(100), false)?.0 as u8;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            snssai,
            snssa_idl_gbrpr_busage,
            snssa_iul_gbrpr_busage,
            snssa_idl_non_gbrpr_busage,
            snssa_iul_non_gbrpr_busage,
            snssa_idl_total_pr_ballocation,
            snssa_iul_total_pr_ballocation,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, false, &optionals, false)?;
        self.snssai.encode(data)?;
        encode::encode_integer(
            data,
            Some(0),
            Some(100),
            false,
            self.snssa_idl_gbrpr_busage as i128,
            false,
        )?;
        encode::encode_integer(
            data,
            Some(0),
            Some(100),
            false,
            self.snssa_iul_gbrpr_busage as i128,
            false,
        )?;
        encode::encode_integer(
            data,
            Some(0),
            Some(100),
            false,
            self.snssa_idl_non_gbrpr_busage as i128,
            false,
        )?;
        encode::encode_integer(
            data,
            Some(0),
            Some(100),
            false,
            self.snssa_iul_non_gbrpr_busage as i128,
            false,
        )?;
        encode::encode_integer(
            data,
            Some(0),
            Some(100),
            false,
            self.snssa_idl_total_pr_ballocation as i128,
            false,
        )?;
        encode::encode_integer(
            data,
            Some(0),
            Some(100),
            false,
            self.snssa_iul_total_pr_ballocation as i128,
            false,
        )?;

        Ok(())
    }
}

impl PerCodec for SnssaiRadioResourceStatusItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        SnssaiRadioResourceStatusItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SnssaiRadioResourceStatusItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SnssaiRadioResourceStatusItem");
            e
        })
    }
}
// SliceSupportList
#[derive(Clone, Debug)]
pub struct SliceSupportList(pub NonEmpty<SliceSupportItem>);

impl SliceSupportList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(1024), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(SliceSupportItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(1024), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for SliceSupportList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        SliceSupportList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SliceSupportList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SliceSupportList");
            e
        })
    }
}
// SliceSupportItem
#[derive(Clone, Debug)]
pub struct SliceSupportItem {
    pub snssai: Snssai,
}

impl SliceSupportItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, false, 1)?;
        let snssai = Snssai::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self { snssai })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, false, &optionals, false)?;
        self.snssai.encode(data)?;

        Ok(())
    }
}

impl PerCodec for SliceSupportItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        SliceSupportItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SliceSupportItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SliceSupportItem");
            e
        })
    }
}
// SliceToReportList
#[derive(Clone, Debug)]
pub struct SliceToReportList(pub NonEmpty<SliceToReportItem>);

impl SliceToReportList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(12), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(SliceToReportItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(12), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for SliceToReportList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        SliceToReportList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SliceToReportList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SliceToReportList");
            e
        })
    }
}
// SliceToReportItem
#[derive(Clone, Debug)]
pub struct SliceToReportItem {
    pub plmn_identity: PlmnIdentity,
    pub snssa_ilist: SnssaiList,
}

impl SliceToReportItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, false, 1)?;
        let plmn_identity = PlmnIdentity::decode(data)?;
        let snssa_ilist = SnssaiList::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            plmn_identity,
            snssa_ilist,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, false, &optionals, false)?;
        self.plmn_identity.encode(data)?;
        self.snssa_ilist.encode(data)?;

        Ok(())
    }
}

impl PerCodec for SliceToReportItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        SliceToReportItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SliceToReportItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SliceToReportItem");
            e
        })
    }
}
// SlotNumber
#[derive(Clone, Copy, Debug)]
pub struct SlotNumber(pub u8);

impl SlotNumber {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(
            decode::decode_integer(data, Some(0), Some(79), false)?.0 as u8,
        ))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_integer(data, Some(0), Some(79), false, self.0 as i128, false)
    }
}

impl PerCodec for SlotNumber {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        SlotNumber::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SlotNumber");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SlotNumber");
            e
        })
    }
}
// SlPositioningRangingServiceInfo
#[derive(Clone, Debug)]
pub struct SlPositioningRangingServiceInfo {
    pub sl_positioning_ranging_authorized: SlPositioningRangingAuthorized,
    pub rspp_transport_qos_parameters: Option<RsppTransportQosParameters>,
}

impl SlPositioningRangingServiceInfo {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 2)?;
        let sl_positioning_ranging_authorized = SlPositioningRangingAuthorized::decode(data)?;
        let rspp_transport_qos_parameters = if optionals[0] {
            Some(RsppTransportQosParameters::decode(data)?)
        } else {
            None
        };

        // Process the extension container

        if optionals[1] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            sl_positioning_ranging_authorized,
            rspp_transport_qos_parameters,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.rspp_transport_qos_parameters.is_some());
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.sl_positioning_ranging_authorized.encode(data)?;
        if let Some(x) = &self.rspp_transport_qos_parameters {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl PerCodec for SlPositioningRangingServiceInfo {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        SlPositioningRangingServiceInfo::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SlPositioningRangingServiceInfo");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SlPositioningRangingServiceInfo");
            e
        })
    }
}
// SlPositioningRangingAuthorized
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum SlPositioningRangingAuthorized {
    Authorized,
    NotAuthorized,
}

impl SlPositioningRangingAuthorized {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(1), true)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(1),
            true,
            *self as i128,
            (*self as u32) >= 2,
        )
    }
}

impl PerCodec for SlPositioningRangingAuthorized {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        SlPositioningRangingAuthorized::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SlPositioningRangingAuthorized");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SlPositioningRangingAuthorized");
            e
        })
    }
}
// RsppTransportQosParameters
#[derive(Clone, Debug)]
pub struct RsppTransportQosParameters {
    pub rspp_qos_flow_list: RsppQosFlowList,
    pub rspp_link_aggregate_bit_rates: Option<BitRate>,
}

impl RsppTransportQosParameters {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 2)?;
        let rspp_qos_flow_list = RsppQosFlowList::decode(data)?;
        let rspp_link_aggregate_bit_rates = if optionals[0] {
            Some(BitRate::decode(data)?)
        } else {
            None
        };

        // Process the extension container

        if optionals[1] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            rspp_qos_flow_list,
            rspp_link_aggregate_bit_rates,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.rspp_link_aggregate_bit_rates.is_some());
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.rspp_qos_flow_list.encode(data)?;
        if let Some(x) = &self.rspp_link_aggregate_bit_rates {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl PerCodec for RsppTransportQosParameters {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        RsppTransportQosParameters::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("RsppTransportQosParameters");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("RsppTransportQosParameters");
            e
        })
    }
}
// RsppQosFlowList
#[derive(Clone, Debug)]
pub struct RsppQosFlowList(pub NonEmpty<RsppQosFlowItem>);

impl RsppQosFlowList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(2048), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(RsppQosFlowItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(2048), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for RsppQosFlowList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        RsppQosFlowList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("RsppQosFlowList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("RsppQosFlowList");
            e
        })
    }
}
// RsppQosFlowItem
#[derive(Clone, Debug)]
pub struct RsppQosFlowItem {
    pub pqi: FiveQi,
    pub rspp_flow_bit_rates: Option<RsppFlowBitRates>,
    pub range: Option<Range>,
}

impl RsppQosFlowItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 3)?;
        let pqi = FiveQi::decode(data)?;
        let rspp_flow_bit_rates = if optionals[0] {
            Some(RsppFlowBitRates::decode(data)?)
        } else {
            None
        };
        let range = if optionals[1] {
            Some(Range::decode(data)?)
        } else {
            None
        };

        // Process the extension container

        if optionals[2] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            pqi,
            rspp_flow_bit_rates,
            range,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.rspp_flow_bit_rates.is_some());
        optionals.push(self.range.is_some());
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.pqi.encode(data)?;
        if let Some(x) = &self.rspp_flow_bit_rates {
            x.encode(data)?;
        }
        if let Some(x) = &self.range {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl PerCodec for RsppQosFlowItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        RsppQosFlowItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("RsppQosFlowItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("RsppQosFlowItem");
            e
        })
    }
}
// RsppFlowBitRates
#[derive(Clone, Debug)]
pub struct RsppFlowBitRates {
    pub guaranteed_flow_bit_rate: BitRate,
    pub maximum_flow_bit_rate: BitRate,
}

impl RsppFlowBitRates {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let guaranteed_flow_bit_rate = BitRate::decode(data)?;
        let maximum_flow_bit_rate = BitRate::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            guaranteed_flow_bit_rate,
            maximum_flow_bit_rate,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.guaranteed_flow_bit_rate.encode(data)?;
        self.maximum_flow_bit_rate.encode(data)?;

        Ok(())
    }
}

impl PerCodec for RsppFlowBitRates {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        RsppFlowBitRates::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("RsppFlowBitRates");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("RsppFlowBitRates");
            e
        })
    }
}
// SnssaiList
#[derive(Clone, Debug)]
pub struct SnssaiList(pub NonEmpty<SnssaiItem>);

impl SnssaiList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(1024), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(SnssaiItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(1024), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for SnssaiList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        SnssaiList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SnssaiList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SnssaiList");
            e
        })
    }
}
// SnssaiItem
#[derive(Clone, Debug)]
pub struct SnssaiItem {
    pub snssai: Snssai,
}

impl SnssaiItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, false, 1)?;
        let snssai = Snssai::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self { snssai })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, false, &optionals, false)?;
        self.snssai.encode(data)?;

        Ok(())
    }
}

impl PerCodec for SnssaiItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        SnssaiItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SnssaiItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SnssaiItem");
            e
        })
    }
}
// SlotConfigurationList
#[derive(Clone, Debug)]
pub struct SlotConfigurationList(pub NonEmpty<SlotConfigurationItem>);

impl SlotConfigurationList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(5120), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(SlotConfigurationItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(5120), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for SlotConfigurationList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        SlotConfigurationList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SlotConfigurationList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SlotConfigurationList");
            e
        })
    }
}
// SlotConfigurationItem
#[derive(Clone, Debug)]
pub struct SlotConfigurationItem {
    pub slot_index: u16,
    pub symbol_alloc_in_slot: SymbolAllocInSlot,
}

impl SlotConfigurationItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, false, 1)?;
        let slot_index = decode::decode_integer(data, Some(0), Some(5119), true)?.0 as u16;
        let symbol_alloc_in_slot = SymbolAllocInSlot::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            slot_index,
            symbol_alloc_in_slot,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, false, &optionals, false)?;
        encode::encode_integer(
            data,
            Some(0),
            Some(5119),
            true,
            self.slot_index as i128,
            false,
        )?;
        self.symbol_alloc_in_slot.encode(data)?;

        Ok(())
    }
}

impl PerCodec for SlotConfigurationItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        SlotConfigurationItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SlotConfigurationItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SlotConfigurationItem");
            e
        })
    }
}
// SlotOffsetForRemainingHopsList
#[derive(Clone, Debug)]
pub struct SlotOffsetForRemainingHopsList(pub NonEmpty<SlotOffsetForRemainingHopsItem>);

impl SlotOffsetForRemainingHopsList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(5), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(SlotOffsetForRemainingHopsItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(5), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for SlotOffsetForRemainingHopsList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        SlotOffsetForRemainingHopsList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SlotOffsetForRemainingHopsList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SlotOffsetForRemainingHopsList");
            e
        })
    }
}
// SlotOffsetForRemainingHopsItem
#[derive(Clone, Debug)]
pub struct SlotOffsetForRemainingHopsItem {
    pub slot_offset_remaining_hops: SlotOffsetRemainingHops,
}

impl SlotOffsetForRemainingHopsItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let slot_offset_remaining_hops = SlotOffsetRemainingHops::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            slot_offset_remaining_hops,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.slot_offset_remaining_hops.encode(data)?;

        Ok(())
    }
}

impl PerCodec for SlotOffsetForRemainingHopsItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        SlotOffsetForRemainingHopsItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SlotOffsetForRemainingHopsItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SlotOffsetForRemainingHopsItem");
            e
        })
    }
}
// SlotOffsetRemainingHops
#[derive(Clone, Debug)]
pub enum SlotOffsetRemainingHops {
    Aperiodic(SlotOffsetRemainingHopsAperiodic),
    SemiPersistent(SlotOffsetRemainingHopsSemiPersistent),
    Periodic(SlotOffsetRemainingHopsPeriodic),
}

impl SlotOffsetRemainingHops {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_choice_idx(data, 0, 3, false)?;
        if extended {
            return Err(per_codec_error_new("CHOICE additions not implemented"));
        }
        match idx {
            0 => Ok(Self::Aperiodic(SlotOffsetRemainingHopsAperiodic::decode(
                data,
            )?)),
            1 => Ok(Self::SemiPersistent(
                SlotOffsetRemainingHopsSemiPersistent::decode(data)?,
            )),
            2 => Ok(Self::Periodic(SlotOffsetRemainingHopsPeriodic::decode(
                data,
            )?)),
            3 => {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _ = Criticality::decode(data)?;
                let _ = decode::decode_length_determinent(data, None, None, false)?;
                let result = match id {
                    x => Err(per_codec_error_new(format!("Unrecognised IE type {}", x))),
                };
                data.decode_align()?;
                result
            }
            _ => Err(per_codec_error_new("Unknown choice idx")),
        }
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        match self {
            Self::Aperiodic(x) => {
                encode::encode_choice_idx(data, 0, 3, false, 0, false)?;
                x.encode(data)
            }
            Self::SemiPersistent(x) => {
                encode::encode_choice_idx(data, 0, 3, false, 1, false)?;
                x.encode(data)
            }
            Self::Periodic(x) => {
                encode::encode_choice_idx(data, 0, 3, false, 2, false)?;
                x.encode(data)
            }
        }
    }
}

impl PerCodec for SlotOffsetRemainingHops {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        SlotOffsetRemainingHops::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SlotOffsetRemainingHops");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SlotOffsetRemainingHops");
            e
        })
    }
}
// SlotOffsetRemainingHopsAperiodic
#[derive(Clone, Debug)]
pub struct SlotOffsetRemainingHopsAperiodic {
    pub slot_offset: Option<u8>,
    pub start_position: Option<u8>,
}

impl SlotOffsetRemainingHopsAperiodic {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 3)?;
        let slot_offset = if optionals[0] {
            Some(decode::decode_integer(data, Some(1), Some(32), false)?.0 as u8)
        } else {
            None
        };
        let start_position = if optionals[1] {
            Some(decode::decode_integer(data, Some(0), Some(13), false)?.0 as u8)
        } else {
            None
        };

        // Process the extension container

        if optionals[2] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            slot_offset,
            start_position,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.slot_offset.is_some());
        optionals.push(self.start_position.is_some());
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        if let Some(x) = &self.slot_offset {
            encode::encode_integer(data, Some(1), Some(32), false, *x as i128, false)?;
        }
        if let Some(x) = &self.start_position {
            encode::encode_integer(data, Some(0), Some(13), false, *x as i128, false)?;
        }

        Ok(())
    }
}

impl PerCodec for SlotOffsetRemainingHopsAperiodic {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        SlotOffsetRemainingHopsAperiodic::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SlotOffsetRemainingHopsAperiodic");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SlotOffsetRemainingHopsAperiodic");
            e
        })
    }
}
// SlotOffsetRemainingHopsSemiPersistent
#[derive(Clone, Debug)]
pub struct SlotOffsetRemainingHopsSemiPersistent {
    pub sr_speriodicity: SrsPeriodicity,
    pub offset: u32,
    pub start_position: Option<u8>,
}

impl SlotOffsetRemainingHopsSemiPersistent {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 2)?;
        let sr_speriodicity = SrsPeriodicity::decode(data)?;
        let offset = decode::decode_integer(data, Some(0), Some(81919), true)?.0 as u32;
        let start_position = if optionals[0] {
            Some(decode::decode_integer(data, Some(0), Some(13), false)?.0 as u8)
        } else {
            None
        };

        // Process the extension container

        if optionals[1] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            sr_speriodicity,
            offset,
            start_position,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.start_position.is_some());
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.sr_speriodicity.encode(data)?;
        encode::encode_integer(data, Some(0), Some(81919), true, self.offset as i128, false)?;
        if let Some(x) = &self.start_position {
            encode::encode_integer(data, Some(0), Some(13), false, *x as i128, false)?;
        }

        Ok(())
    }
}

impl PerCodec for SlotOffsetRemainingHopsSemiPersistent {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        SlotOffsetRemainingHopsSemiPersistent::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SlotOffsetRemainingHopsSemiPersistent");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SlotOffsetRemainingHopsSemiPersistent");
            e
        })
    }
}
// SlotOffsetRemainingHopsPeriodic
#[derive(Clone, Debug)]
pub struct SlotOffsetRemainingHopsPeriodic {
    pub sr_speriodicity: SrsPeriodicity,
    pub offset: u32,
    pub start_position: Option<u8>,
}

impl SlotOffsetRemainingHopsPeriodic {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 2)?;
        let sr_speriodicity = SrsPeriodicity::decode(data)?;
        let offset = decode::decode_integer(data, Some(0), Some(81919), true)?.0 as u32;
        let start_position = if optionals[0] {
            Some(decode::decode_integer(data, Some(0), Some(13), false)?.0 as u8)
        } else {
            None
        };

        // Process the extension container

        if optionals[1] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            sr_speriodicity,
            offset,
            start_position,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.start_position.is_some());
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.sr_speriodicity.encode(data)?;
        encode::encode_integer(data, Some(0), Some(81919), true, self.offset as i128, false)?;
        if let Some(x) = &self.start_position {
            encode::encode_integer(data, Some(0), Some(13), false, *x as i128, false)?;
        }

        Ok(())
    }
}

impl PerCodec for SlotOffsetRemainingHopsPeriodic {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        SlotOffsetRemainingHopsPeriodic::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SlotOffsetRemainingHopsPeriodic");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SlotOffsetRemainingHopsPeriodic");
            e
        })
    }
}
// Snssai
#[derive(Clone, Debug)]
pub struct Snssai {
    pub sst: [u8; 1],
    pub sd: Option<[u8; 3]>,
}

impl Snssai {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, false, 2)?;
        let sst = decode::decode_octetstring(data, Some(1), Some(1), false)?
            .try_into()
            .unwrap();
        let sd = if optionals[0] {
            Some(
                decode::decode_octetstring(data, Some(3), Some(3), false)?
                    .try_into()
                    .unwrap(),
            )
        } else {
            None
        };

        // Process the extension container

        if optionals[1] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self { sst, sd })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.sd.is_some());
        optionals.push(false);

        encode::encode_sequence_header(data, false, &optionals, false)?;
        encode::encode_octetstring(data, Some(1), Some(1), false, &(self.sst).into(), false)?;
        if let Some(x) = &self.sd {
            encode::encode_octetstring(data, Some(3), Some(3), false, &(*x).into(), false)?;
        }

        Ok(())
    }
}

impl PerCodec for Snssai {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Snssai::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("Snssai");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("Snssai");
            e
        })
    }
}
// SpatialDirectionInformation
#[derive(Clone, Debug)]
pub struct SpatialDirectionInformation {
    pub nr_prs_beam_information: NrPrsBeamInformation,
}

impl SpatialDirectionInformation {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, false, 1)?;
        let nr_prs_beam_information = NrPrsBeamInformation::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            nr_prs_beam_information,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, false, &optionals, false)?;
        self.nr_prs_beam_information.encode(data)?;

        Ok(())
    }
}

impl PerCodec for SpatialDirectionInformation {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        SpatialDirectionInformation::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SpatialDirectionInformation");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SpatialDirectionInformation");
            e
        })
    }
}
// SpatialRelationInfo
#[derive(Clone, Debug)]
pub struct SpatialRelationInfo {
    pub spatial_relationfor_resource_id: SpatialRelationforResourceId,
}

impl SpatialRelationInfo {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, false, 1)?;
        let spatial_relationfor_resource_id = SpatialRelationforResourceId::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            spatial_relationfor_resource_id,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, false, &optionals, false)?;
        self.spatial_relationfor_resource_id.encode(data)?;

        Ok(())
    }
}

impl PerCodec for SpatialRelationInfo {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        SpatialRelationInfo::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SpatialRelationInfo");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SpatialRelationInfo");
            e
        })
    }
}
// SpatialRelationforResourceId
#[derive(Clone, Debug)]
pub struct SpatialRelationforResourceId(pub NonEmpty<SpatialRelationforResourceIdItem>);

impl SpatialRelationforResourceId {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(64), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(SpatialRelationforResourceIdItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(64), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for SpatialRelationforResourceId {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        SpatialRelationforResourceId::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SpatialRelationforResourceId");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SpatialRelationforResourceId");
            e
        })
    }
}
// SpatialRelationforResourceIdItem
#[derive(Clone, Debug)]
pub struct SpatialRelationforResourceIdItem {
    pub reference_signal: ReferenceSignal,
}

impl SpatialRelationforResourceIdItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, false, 1)?;
        let reference_signal = ReferenceSignal::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self { reference_signal })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, false, &optionals, false)?;
        self.reference_signal.encode(data)?;

        Ok(())
    }
}

impl PerCodec for SpatialRelationforResourceIdItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        SpatialRelationforResourceIdItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SpatialRelationforResourceIdItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SpatialRelationforResourceIdItem");
            e
        })
    }
}
// SpatialRelationPerSrsResource
#[derive(Clone, Debug)]
pub struct SpatialRelationPerSrsResource {
    pub spatial_relation_per_srs_resource_list: SpatialRelationPerSrsResourceList,
}

impl SpatialRelationPerSrsResource {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let spatial_relation_per_srs_resource_list =
            SpatialRelationPerSrsResourceList::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            spatial_relation_per_srs_resource_list,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.spatial_relation_per_srs_resource_list.encode(data)?;

        Ok(())
    }
}

impl PerCodec for SpatialRelationPerSrsResource {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        SpatialRelationPerSrsResource::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SpatialRelationPerSrsResource");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SpatialRelationPerSrsResource");
            e
        })
    }
}
// SpatialRelationPerSrsResourceList
#[derive(Clone, Debug)]
pub struct SpatialRelationPerSrsResourceList(pub NonEmpty<SpatialRelationPerSrsResourceItem>);

impl SpatialRelationPerSrsResourceList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(16), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(SpatialRelationPerSrsResourceItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(16), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for SpatialRelationPerSrsResourceList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        SpatialRelationPerSrsResourceList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SpatialRelationPerSrsResourceList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SpatialRelationPerSrsResourceList");
            e
        })
    }
}
// SpatialRelationPerSrsResourceItem
#[derive(Clone, Debug)]
pub struct SpatialRelationPerSrsResourceItem {
    pub reference_signal: ReferenceSignal,
}

impl SpatialRelationPerSrsResourceItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let reference_signal = ReferenceSignal::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self { reference_signal })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.reference_signal.encode(data)?;

        Ok(())
    }
}

impl PerCodec for SpatialRelationPerSrsResourceItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        SpatialRelationPerSrsResourceItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SpatialRelationPerSrsResourceItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SpatialRelationPerSrsResourceItem");
            e
        })
    }
}
// SpatialRelationPos
#[derive(Clone, Debug)]
pub enum SpatialRelationPos {
    SsbPos(Ssb),
    PrsInformationPos(PrsInformationPos),
}

impl SpatialRelationPos {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_choice_idx(data, 0, 2, false)?;
        if extended {
            return Err(per_codec_error_new("CHOICE additions not implemented"));
        }
        match idx {
            0 => Ok(Self::SsbPos(Ssb::decode(data)?)),
            1 => Ok(Self::PrsInformationPos(PrsInformationPos::decode(data)?)),
            2 => {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _ = Criticality::decode(data)?;
                let _ = decode::decode_length_determinent(data, None, None, false)?;
                let result = match id {
                    x => Err(per_codec_error_new(format!("Unrecognised IE type {}", x))),
                };
                data.decode_align()?;
                result
            }
            _ => Err(per_codec_error_new("Unknown choice idx")),
        }
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        match self {
            Self::SsbPos(x) => {
                encode::encode_choice_idx(data, 0, 2, false, 0, false)?;
                x.encode(data)
            }
            Self::PrsInformationPos(x) => {
                encode::encode_choice_idx(data, 0, 2, false, 1, false)?;
                x.encode(data)
            }
        }
    }
}

impl PerCodec for SpatialRelationPos {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        SpatialRelationPos::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SpatialRelationPos");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SpatialRelationPos");
            e
        })
    }
}
// SpectrumSharingGroupId
#[derive(Clone, Copy, Debug)]
pub struct SpectrumSharingGroupId(pub u16);

impl SpectrumSharingGroupId {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(
            decode::decode_integer(data, Some(1), Some(256), false)?.0 as u16,
        ))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_integer(data, Some(1), Some(256), false, self.0 as i128, false)
    }
}

impl PerCodec for SpectrumSharingGroupId {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        SpectrumSharingGroupId::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SpectrumSharingGroupId");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SpectrumSharingGroupId");
            e
        })
    }
}
// SrbId
#[derive(Clone, Copy, Debug)]
pub struct SrbId(pub i128);

impl SrbId {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(
            decode::decode_integer(data, Some(0), Some(3), true)?.0,
        ))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_integer(data, Some(0), Some(3), true, self.0, false)
    }
}

impl PerCodec for SrbId {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        SrbId::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SrbId");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SrbId");
            e
        })
    }
}
// SrbsFailedToBeSetupItem
#[derive(Clone, Debug)]
pub struct SrbsFailedToBeSetupItem {
    pub srb_id: SrbId,
    pub cause: Option<Cause>,
}

impl SrbsFailedToBeSetupItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 2)?;
        let srb_id = SrbId::decode(data)?;
        let cause = if optionals[0] {
            Some(Cause::decode(data)?)
        } else {
            None
        };

        // Process the extension container

        if optionals[1] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self { srb_id, cause })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.cause.is_some());
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.srb_id.encode(data)?;
        if let Some(x) = &self.cause {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl PerCodec for SrbsFailedToBeSetupItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        SrbsFailedToBeSetupItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SrbsFailedToBeSetupItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SrbsFailedToBeSetupItem");
            e
        })
    }
}
// SrbsFailedToBeSetupModItem
#[derive(Clone, Debug)]
pub struct SrbsFailedToBeSetupModItem {
    pub srb_id: SrbId,
    pub cause: Option<Cause>,
}

impl SrbsFailedToBeSetupModItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 2)?;
        let srb_id = SrbId::decode(data)?;
        let cause = if optionals[0] {
            Some(Cause::decode(data)?)
        } else {
            None
        };

        // Process the extension container

        if optionals[1] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self { srb_id, cause })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.cause.is_some());
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.srb_id.encode(data)?;
        if let Some(x) = &self.cause {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl PerCodec for SrbsFailedToBeSetupModItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        SrbsFailedToBeSetupModItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SrbsFailedToBeSetupModItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SrbsFailedToBeSetupModItem");
            e
        })
    }
}
// SrbsModifiedItem
#[derive(Clone, Debug)]
pub struct SrbsModifiedItem {
    pub srb_id: SrbId,
    pub lcid: Lcid,
}

impl SrbsModifiedItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let srb_id = SrbId::decode(data)?;
        let lcid = Lcid::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self { srb_id, lcid })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.srb_id.encode(data)?;
        self.lcid.encode(data)?;

        Ok(())
    }
}

impl PerCodec for SrbsModifiedItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        SrbsModifiedItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SrbsModifiedItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SrbsModifiedItem");
            e
        })
    }
}
// SrbsRequiredToBeReleasedItem
#[derive(Clone, Debug)]
pub struct SrbsRequiredToBeReleasedItem {
    pub srb_id: SrbId,
}

impl SrbsRequiredToBeReleasedItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let srb_id = SrbId::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self { srb_id })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.srb_id.encode(data)?;

        Ok(())
    }
}

impl PerCodec for SrbsRequiredToBeReleasedItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        SrbsRequiredToBeReleasedItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SrbsRequiredToBeReleasedItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SrbsRequiredToBeReleasedItem");
            e
        })
    }
}
// SrbsSetupItem
#[derive(Clone, Debug)]
pub struct SrbsSetupItem {
    pub srb_id: SrbId,
    pub lcid: Lcid,
}

impl SrbsSetupItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let srb_id = SrbId::decode(data)?;
        let lcid = Lcid::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self { srb_id, lcid })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.srb_id.encode(data)?;
        self.lcid.encode(data)?;

        Ok(())
    }
}

impl PerCodec for SrbsSetupItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        SrbsSetupItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SrbsSetupItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SrbsSetupItem");
            e
        })
    }
}
// SrbsSetupModItem
#[derive(Clone, Debug)]
pub struct SrbsSetupModItem {
    pub srb_id: SrbId,
    pub lcid: Lcid,
}

impl SrbsSetupModItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let srb_id = SrbId::decode(data)?;
        let lcid = Lcid::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self { srb_id, lcid })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.srb_id.encode(data)?;
        self.lcid.encode(data)?;

        Ok(())
    }
}

impl PerCodec for SrbsSetupModItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        SrbsSetupModItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SrbsSetupModItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SrbsSetupModItem");
            e
        })
    }
}
// SrbsToBeReleasedItem
#[derive(Clone, Debug)]
pub struct SrbsToBeReleasedItem {
    pub srb_id: SrbId,
}

impl SrbsToBeReleasedItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let srb_id = SrbId::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self { srb_id })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.srb_id.encode(data)?;

        Ok(())
    }
}

impl PerCodec for SrbsToBeReleasedItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        SrbsToBeReleasedItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SrbsToBeReleasedItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SrbsToBeReleasedItem");
            e
        })
    }
}
// SrbsToBeSetupItem
#[derive(Clone, Debug)]
pub struct SrbsToBeSetupItem {
    pub srb_id: SrbId,
    pub duplication_indication: Option<DuplicationIndication>,
    pub additional_duplication_indication: Option<AdditionalDuplicationIndication>,
    pub sdtrlc_bearer_configuration: Option<SdtrlcBearerConfiguration>,
    pub srb_mapping_info: Option<UuRlcChannelId>,
}

impl SrbsToBeSetupItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 2)?;
        let srb_id = SrbId::decode(data)?;
        let duplication_indication = if optionals[0] {
            Some(DuplicationIndication::decode(data)?)
        } else {
            None
        };

        // Process the extension container
        let mut additional_duplication_indication: Option<AdditionalDuplicationIndication> = None;
        let mut sdtrlc_bearer_configuration: Option<SdtrlcBearerConfiguration> = None;
        let mut srb_mapping_info: Option<UuRlcChannelId> = None;

        if optionals[1] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    372 => {
                        additional_duplication_indication =
                            Some(AdditionalDuplicationIndication::decode(data)?)
                    }
                    593 => {
                        sdtrlc_bearer_configuration = Some(SdtrlcBearerConfiguration::decode(data)?)
                    }
                    597 => srb_mapping_info = Some(UuRlcChannelId::decode(data)?),
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            srb_id,
            duplication_indication,
            additional_duplication_indication,
            sdtrlc_bearer_configuration,
            srb_mapping_info,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();
        if let Some(x) = &self.additional_duplication_indication {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 372, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.sdtrlc_bearer_configuration {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 593, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.srb_mapping_info {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 597, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        let mut optionals = BitString::new();
        optionals.push(self.duplication_indication.is_some());
        optionals.push(num_ies != 0);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.srb_id.encode(data)?;
        if let Some(x) = &self.duplication_indication {
            x.encode(data)?;
        }
        if num_ies != 0 {
            encode::encode_length_determinent(data, Some(1), Some(65535), false, num_ies)?;
            data.append_aligned(ies);
        }
        Ok(())
    }
}

impl PerCodec for SrbsToBeSetupItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        SrbsToBeSetupItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SrbsToBeSetupItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SrbsToBeSetupItem");
            e
        })
    }
}
// SrbsToBeSetupModItem
#[derive(Clone, Debug)]
pub struct SrbsToBeSetupModItem {
    pub srb_id: SrbId,
    pub duplication_indication: Option<DuplicationIndication>,
    pub additional_duplication_indication: Option<AdditionalDuplicationIndication>,
    pub srb_mapping_info: Option<UuRlcChannelId>,
    pub cg_sd_tindicator_setup: Option<CgSdTindicatorSetup>,
}

impl SrbsToBeSetupModItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 2)?;
        let srb_id = SrbId::decode(data)?;
        let duplication_indication = if optionals[0] {
            Some(DuplicationIndication::decode(data)?)
        } else {
            None
        };

        // Process the extension container
        let mut additional_duplication_indication: Option<AdditionalDuplicationIndication> = None;
        let mut srb_mapping_info: Option<UuRlcChannelId> = None;
        let mut cg_sd_tindicator_setup: Option<CgSdTindicatorSetup> = None;

        if optionals[1] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    372 => {
                        additional_duplication_indication =
                            Some(AdditionalDuplicationIndication::decode(data)?)
                    }
                    597 => srb_mapping_info = Some(UuRlcChannelId::decode(data)?),
                    589 => cg_sd_tindicator_setup = Some(CgSdTindicatorSetup::decode(data)?),
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            srb_id,
            duplication_indication,
            additional_duplication_indication,
            srb_mapping_info,
            cg_sd_tindicator_setup,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();
        if let Some(x) = &self.additional_duplication_indication {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 372, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.srb_mapping_info {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 597, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.cg_sd_tindicator_setup {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 589, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        let mut optionals = BitString::new();
        optionals.push(self.duplication_indication.is_some());
        optionals.push(num_ies != 0);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.srb_id.encode(data)?;
        if let Some(x) = &self.duplication_indication {
            x.encode(data)?;
        }
        if num_ies != 0 {
            encode::encode_length_determinent(data, Some(1), Some(65535), false, num_ies)?;
            data.append_aligned(ies);
        }
        Ok(())
    }
}

impl PerCodec for SrbsToBeSetupModItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        SrbsToBeSetupModItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SrbsToBeSetupModItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SrbsToBeSetupModItem");
            e
        })
    }
}
// SrsCarrierList
#[derive(Clone, Debug)]
pub struct SrsCarrierList(pub NonEmpty<SrsCarrierListItem>);

impl SrsCarrierList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(32), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(SrsCarrierListItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(32), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for SrsCarrierList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        SrsCarrierList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SrsCarrierList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SrsCarrierList");
            e
        })
    }
}
// SrsCarrierListItem
#[derive(Clone, Debug)]
pub struct SrsCarrierListItem {
    pub point_a: u32,
    pub uplink_channel_bw_per_scs_list: UplinkChannelBwPerScsList,
    pub active_ul_bwp: ActiveUlBwp,
    pub pci: Option<NrPci>,
}

impl SrsCarrierListItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, false, 2)?;
        let point_a = decode::decode_integer(data, Some(0), Some(3279165), false)?.0 as u32;
        let uplink_channel_bw_per_scs_list = UplinkChannelBwPerScsList::decode(data)?;
        let active_ul_bwp = ActiveUlBwp::decode(data)?;
        let pci = if optionals[0] {
            Some(NrPci::decode(data)?)
        } else {
            None
        };

        // Process the extension container

        if optionals[1] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            point_a,
            uplink_channel_bw_per_scs_list,
            active_ul_bwp,
            pci,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.pci.is_some());
        optionals.push(false);

        encode::encode_sequence_header(data, false, &optionals, false)?;
        encode::encode_integer(
            data,
            Some(0),
            Some(3279165),
            false,
            self.point_a as i128,
            false,
        )?;
        self.uplink_channel_bw_per_scs_list.encode(data)?;
        self.active_ul_bwp.encode(data)?;
        if let Some(x) = &self.pci {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl PerCodec for SrsCarrierListItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        SrsCarrierListItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SrsCarrierListItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SrsCarrierListItem");
            e
        })
    }
}
// SrsConfig
#[derive(Clone, Debug)]
pub struct SrsConfig {
    pub srs_resource_list: Option<SrsResourceList>,
    pub pos_srs_resource_list: Option<PosSrsResourceList>,
    pub srs_resource_set_list: Option<SrsResourceSetList1>,
    pub pos_srs_resource_set_list: Option<PosSrsResourceSetList>,
}

impl SrsConfig {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, false, 5)?;
        let srs_resource_list = if optionals[0] {
            Some(SrsResourceList::decode(data)?)
        } else {
            None
        };
        let pos_srs_resource_list = if optionals[1] {
            Some(PosSrsResourceList::decode(data)?)
        } else {
            None
        };
        let srs_resource_set_list = if optionals[2] {
            Some(SrsResourceSetList1::decode(data)?)
        } else {
            None
        };
        let pos_srs_resource_set_list = if optionals[3] {
            Some(PosSrsResourceSetList::decode(data)?)
        } else {
            None
        };

        // Process the extension container

        if optionals[4] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            srs_resource_list,
            pos_srs_resource_list,
            srs_resource_set_list,
            pos_srs_resource_set_list,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.srs_resource_list.is_some());
        optionals.push(self.pos_srs_resource_list.is_some());
        optionals.push(self.srs_resource_set_list.is_some());
        optionals.push(self.pos_srs_resource_set_list.is_some());
        optionals.push(false);

        encode::encode_sequence_header(data, false, &optionals, false)?;
        if let Some(x) = &self.srs_resource_list {
            x.encode(data)?;
        }
        if let Some(x) = &self.pos_srs_resource_list {
            x.encode(data)?;
        }
        if let Some(x) = &self.srs_resource_set_list {
            x.encode(data)?;
        }
        if let Some(x) = &self.pos_srs_resource_set_list {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl PerCodec for SrsConfig {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        SrsConfig::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SrsConfig");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SrsConfig");
            e
        })
    }
}
// SrsConfiguration
#[derive(Clone, Debug)]
pub struct SrsConfiguration {
    pub srs_carrier_list: SrsCarrierList,
    pub aggregated_pos_srs_resource_set_list: Option<AggregatedPosSrsResourceSetList>,
}

impl SrsConfiguration {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, false, 1)?;
        let srs_carrier_list = SrsCarrierList::decode(data)?;

        // Process the extension container
        let mut aggregated_pos_srs_resource_set_list: Option<AggregatedPosSrsResourceSetList> =
            None;

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    829 => {
                        aggregated_pos_srs_resource_set_list =
                            Some(AggregatedPosSrsResourceSetList::decode(data)?)
                    }
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            srs_carrier_list,
            aggregated_pos_srs_resource_set_list,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();
        if let Some(x) = &self.aggregated_pos_srs_resource_set_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 829, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        let mut optionals = BitString::new();
        optionals.push(num_ies != 0);

        encode::encode_sequence_header(data, false, &optionals, false)?;
        self.srs_carrier_list.encode(data)?;
        if num_ies != 0 {
            encode::encode_length_determinent(data, Some(1), Some(65535), false, num_ies)?;
            data.append_aligned(ies);
        }
        Ok(())
    }
}

impl PerCodec for SrsConfiguration {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        SrsConfiguration::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SrsConfiguration");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SrsConfiguration");
            e
        })
    }
}
// SrsFrequency
#[derive(Clone, Copy, Debug)]
pub struct SrsFrequency(pub u32);

impl SrsFrequency {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(
            decode::decode_integer(data, Some(0), Some(3279165), false)?.0 as u32,
        ))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_integer(data, Some(0), Some(3279165), false, self.0 as i128, false)
    }
}

impl PerCodec for SrsFrequency {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        SrsFrequency::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SrsFrequency");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SrsFrequency");
            e
        })
    }
}
// SrsPortIndex
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum SrsPortIndex {
    Id1000,
    Id1001,
    Id1002,
    Id1003,
}

impl SrsPortIndex {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(3), true)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(3),
            true,
            *self as i128,
            (*self as u32) >= 4,
        )
    }
}

impl PerCodec for SrsPortIndex {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        SrsPortIndex::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SrsPortIndex");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SrsPortIndex");
            e
        })
    }
}
// SrsPosPeriodicConfigHyperSfnIndex
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum SrsPosPeriodicConfigHyperSfnIndex {
    Even0,
    Odd1,
}

impl SrsPosPeriodicConfigHyperSfnIndex {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(1), false)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(1),
            false,
            *self as i128,
            (*self as u32) >= 2,
        )
    }
}

impl PerCodec for SrsPosPeriodicConfigHyperSfnIndex {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        SrsPosPeriodicConfigHyperSfnIndex::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SrsPosPeriodicConfigHyperSfnIndex");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SrsPosPeriodicConfigHyperSfnIndex");
            e
        })
    }
}
// SrsPosResourceId
#[derive(Clone, Copy, Debug)]
pub struct SrsPosResourceId(pub u8);

impl SrsPosResourceId {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(
            decode::decode_integer(data, Some(0), Some(63), false)?.0 as u8,
        ))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_integer(data, Some(0), Some(63), false, self.0 as i128, false)
    }
}

impl PerCodec for SrsPosResourceId {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        SrsPosResourceId::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SrsPosResourceId");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SrsPosResourceId");
            e
        })
    }
}
// SrsPreconfigurationList
#[derive(Clone, Debug)]
pub struct SrsPreconfigurationList(pub NonEmpty<SrsPreconfigurationItem>);

impl SrsPreconfigurationList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(16), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(SrsPreconfigurationItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(16), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for SrsPreconfigurationList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        SrsPreconfigurationList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SrsPreconfigurationList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SrsPreconfigurationList");
            e
        })
    }
}
// SrsPreconfigurationItem
#[derive(Clone, Debug)]
pub struct SrsPreconfigurationItem {
    pub srs_pos_rrc_inactive_validity_area_config: SrsPosRrcInactiveValidityAreaConfig,
    pub pos_validity_area_cell_list: PosValidityAreaCellList,
}

impl SrsPreconfigurationItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let srs_pos_rrc_inactive_validity_area_config =
            SrsPosRrcInactiveValidityAreaConfig::decode(data)?;
        let pos_validity_area_cell_list = PosValidityAreaCellList::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            srs_pos_rrc_inactive_validity_area_config,
            pos_validity_area_cell_list,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.srs_pos_rrc_inactive_validity_area_config
            .encode(data)?;
        self.pos_validity_area_cell_list.encode(data)?;

        Ok(())
    }
}

impl PerCodec for SrsPreconfigurationItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        SrsPreconfigurationItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SrsPreconfigurationItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SrsPreconfigurationItem");
            e
        })
    }
}
// SrsResource
#[derive(Clone, Debug)]
pub struct SrsResource {
    pub srs_resource_id: SrsResourceId,
    pub nrof_srs_ports: NrofSrsPorts,
    pub transmission_comb: TransmissionComb,
    pub start_position: u8,
    pub nrof_symbols: NrofSymbols1,
    pub repetition_factor: RepetitionFactor,
    pub freq_domain_position: u8,
    pub freq_domain_shift: u16,
    pub c_srs: u8,
    pub b_srs: u8,
    pub b_hop: u8,
    pub group_or_sequence_hopping: GroupOrSequenceHopping1,
    pub resource_type: ResourceType,
    pub sequence_id: u16,
    pub nrof_symbols_extended: Option<NrofSymbolsExtended>,
    pub repetition_factor_extended: Option<RepetitionFactorExtended>,
    pub start_rb_hopping: Option<StartRbHopping>,
    pub start_rb_index: Option<StartRbIndex>,
}

impl SrsResource {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, false, 1)?;
        let srs_resource_id = SrsResourceId::decode(data)?;
        let nrof_srs_ports = NrofSrsPorts::decode(data)?;
        let transmission_comb = TransmissionComb::decode(data)?;
        let start_position = decode::decode_integer(data, Some(0), Some(13), false)?.0 as u8;
        let nrof_symbols = NrofSymbols1::decode(data)?;
        let repetition_factor = RepetitionFactor::decode(data)?;
        let freq_domain_position = decode::decode_integer(data, Some(0), Some(67), false)?.0 as u8;
        let freq_domain_shift = decode::decode_integer(data, Some(0), Some(268), false)?.0 as u16;
        let c_srs = decode::decode_integer(data, Some(0), Some(63), false)?.0 as u8;
        let b_srs = decode::decode_integer(data, Some(0), Some(3), false)?.0 as u8;
        let b_hop = decode::decode_integer(data, Some(0), Some(3), false)?.0 as u8;
        let group_or_sequence_hopping = GroupOrSequenceHopping1::decode(data)?;
        let resource_type = ResourceType::decode(data)?;
        let sequence_id = decode::decode_integer(data, Some(0), Some(1023), false)?.0 as u16;

        // Process the extension container
        let mut nrof_symbols_extended: Option<NrofSymbolsExtended> = None;
        let mut repetition_factor_extended: Option<RepetitionFactorExtended> = None;
        let mut start_rb_hopping: Option<StartRbHopping> = None;
        let mut start_rb_index: Option<StartRbIndex> = None;

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    702 => nrof_symbols_extended = Some(NrofSymbolsExtended::decode(data)?),
                    703 => {
                        repetition_factor_extended = Some(RepetitionFactorExtended::decode(data)?)
                    }
                    704 => start_rb_hopping = Some(StartRbHopping::decode(data)?),
                    705 => start_rb_index = Some(StartRbIndex::decode(data)?),
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            srs_resource_id,
            nrof_srs_ports,
            transmission_comb,
            start_position,
            nrof_symbols,
            repetition_factor,
            freq_domain_position,
            freq_domain_shift,
            c_srs,
            b_srs,
            b_hop,
            group_or_sequence_hopping,
            resource_type,
            sequence_id,
            nrof_symbols_extended,
            repetition_factor_extended,
            start_rb_hopping,
            start_rb_index,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();
        if let Some(x) = &self.nrof_symbols_extended {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 702, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.repetition_factor_extended {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 703, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.start_rb_hopping {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 704, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.start_rb_index {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 705, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        let mut optionals = BitString::new();
        optionals.push(num_ies != 0);

        encode::encode_sequence_header(data, false, &optionals, false)?;
        self.srs_resource_id.encode(data)?;
        self.nrof_srs_ports.encode(data)?;
        self.transmission_comb.encode(data)?;
        encode::encode_integer(
            data,
            Some(0),
            Some(13),
            false,
            self.start_position as i128,
            false,
        )?;
        self.nrof_symbols.encode(data)?;
        self.repetition_factor.encode(data)?;
        encode::encode_integer(
            data,
            Some(0),
            Some(67),
            false,
            self.freq_domain_position as i128,
            false,
        )?;
        encode::encode_integer(
            data,
            Some(0),
            Some(268),
            false,
            self.freq_domain_shift as i128,
            false,
        )?;
        encode::encode_integer(data, Some(0), Some(63), false, self.c_srs as i128, false)?;
        encode::encode_integer(data, Some(0), Some(3), false, self.b_srs as i128, false)?;
        encode::encode_integer(data, Some(0), Some(3), false, self.b_hop as i128, false)?;
        self.group_or_sequence_hopping.encode(data)?;
        self.resource_type.encode(data)?;
        encode::encode_integer(
            data,
            Some(0),
            Some(1023),
            false,
            self.sequence_id as i128,
            false,
        )?;
        if num_ies != 0 {
            encode::encode_length_determinent(data, Some(1), Some(65535), false, num_ies)?;
            data.append_aligned(ies);
        }
        Ok(())
    }
}

impl PerCodec for SrsResource {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        SrsResource::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SrsResource");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SrsResource");
            e
        })
    }
}
// SrsResourceId
#[derive(Clone, Copy, Debug)]
pub struct SrsResourceId(pub u8);

impl SrsResourceId {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(
            decode::decode_integer(data, Some(0), Some(63), false)?.0 as u8,
        ))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_integer(data, Some(0), Some(63), false, self.0 as i128, false)
    }
}

impl PerCodec for SrsResourceId {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        SrsResourceId::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SrsResourceId");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SrsResourceId");
            e
        })
    }
}
// SrsResourceIdList
#[derive(Clone, Debug)]
pub struct SrsResourceIdList(pub NonEmpty<SrsResourceId>);

impl SrsResourceIdList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(16), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(SrsResourceId::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(16), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for SrsResourceIdList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        SrsResourceIdList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SrsResourceIdList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SrsResourceIdList");
            e
        })
    }
}
// SrsResourceList
#[derive(Clone, Debug)]
pub struct SrsResourceList(pub NonEmpty<SrsResource>);

impl SrsResourceList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(64), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(SrsResource::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(64), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for SrsResourceList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        SrsResourceList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SrsResourceList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SrsResourceList");
            e
        })
    }
}
// SrsResourceSet
#[derive(Clone, Debug)]
pub struct SrsResourceSet {
    pub srs_resource_set_id: SrsResourceSetId,
    pub srs_resource_id_list: SrsResourceIdList,
    pub resource_set_type: ResourceSetType,
}

impl SrsResourceSet {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, false, 1)?;
        let srs_resource_set_id = SrsResourceSetId::decode(data)?;
        let srs_resource_id_list = SrsResourceIdList::decode(data)?;
        let resource_set_type = ResourceSetType::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            srs_resource_set_id,
            srs_resource_id_list,
            resource_set_type,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, false, &optionals, false)?;
        self.srs_resource_set_id.encode(data)?;
        self.srs_resource_id_list.encode(data)?;
        self.resource_set_type.encode(data)?;

        Ok(())
    }
}

impl PerCodec for SrsResourceSet {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        SrsResourceSet::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SrsResourceSet");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SrsResourceSet");
            e
        })
    }
}
// SrsResourceSetId
#[derive(Clone, Copy, Debug)]
pub struct SrsResourceSetId(pub u8);

impl SrsResourceSetId {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(
            decode::decode_integer(data, Some(0), Some(15), true)?.0 as u8,
        ))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_integer(data, Some(0), Some(15), true, self.0 as i128, false)
    }
}

impl PerCodec for SrsResourceSetId {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        SrsResourceSetId::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SrsResourceSetId");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SrsResourceSetId");
            e
        })
    }
}
// SrsResourceSetList
#[derive(Clone, Debug)]
pub struct SrsResourceSetList(pub NonEmpty<SrsResourceSetItem>);

impl SrsResourceSetList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(16), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(SrsResourceSetItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(16), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for SrsResourceSetList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        SrsResourceSetList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SrsResourceSetList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SrsResourceSetList");
            e
        })
    }
}
// SrsResourceSetItem
#[derive(Clone, Debug)]
pub struct SrsResourceSetItem {
    pub num_sr_sresourcesperset: Option<u8>,
    pub periodicity_list: Option<PeriodicityList>,
    pub spatial_relation_info: Option<SpatialRelationInfo>,
    pub pathloss_reference_info: Option<PathlossReferenceInfo>,
    pub srs_spatial_relation_per_srs_resource: Option<SpatialRelationPerSrsResource>,
}

impl SrsResourceSetItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, false, 5)?;
        let num_sr_sresourcesperset = if optionals[0] {
            Some(decode::decode_integer(data, Some(1), Some(16), true)?.0 as u8)
        } else {
            None
        };
        let periodicity_list = if optionals[1] {
            Some(PeriodicityList::decode(data)?)
        } else {
            None
        };
        let spatial_relation_info = if optionals[2] {
            Some(SpatialRelationInfo::decode(data)?)
        } else {
            None
        };
        let pathloss_reference_info = if optionals[3] {
            Some(PathlossReferenceInfo::decode(data)?)
        } else {
            None
        };

        // Process the extension container
        let mut srs_spatial_relation_per_srs_resource: Option<SpatialRelationPerSrsResource> = None;

        if optionals[4] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    435 => {
                        srs_spatial_relation_per_srs_resource =
                            Some(SpatialRelationPerSrsResource::decode(data)?)
                    }
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            num_sr_sresourcesperset,
            periodicity_list,
            spatial_relation_info,
            pathloss_reference_info,
            srs_spatial_relation_per_srs_resource,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();
        if let Some(x) = &self.srs_spatial_relation_per_srs_resource {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 435, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        let mut optionals = BitString::new();
        optionals.push(self.num_sr_sresourcesperset.is_some());
        optionals.push(self.periodicity_list.is_some());
        optionals.push(self.spatial_relation_info.is_some());
        optionals.push(self.pathloss_reference_info.is_some());
        optionals.push(num_ies != 0);

        encode::encode_sequence_header(data, false, &optionals, false)?;
        if let Some(x) = &self.num_sr_sresourcesperset {
            encode::encode_integer(data, Some(1), Some(16), true, *x as i128, false)?;
        }
        if let Some(x) = &self.periodicity_list {
            x.encode(data)?;
        }
        if let Some(x) = &self.spatial_relation_info {
            x.encode(data)?;
        }
        if let Some(x) = &self.pathloss_reference_info {
            x.encode(data)?;
        }
        if num_ies != 0 {
            encode::encode_length_determinent(data, Some(1), Some(65535), false, num_ies)?;
            data.append_aligned(ies);
        }
        Ok(())
    }
}

impl PerCodec for SrsResourceSetItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        SrsResourceSetItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SrsResourceSetItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SrsResourceSetItem");
            e
        })
    }
}
// SrsResourceSetList1
#[derive(Clone, Debug)]
pub struct SrsResourceSetList1(pub NonEmpty<SrsResourceSet>);

impl SrsResourceSetList1 {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(16), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(SrsResourceSet::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(16), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for SrsResourceSetList1 {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        SrsResourceSetList1::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SrsResourceSetList1");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SrsResourceSetList1");
            e
        })
    }
}
// SrsResourceTrigger
#[derive(Clone, Debug)]
pub struct SrsResourceTrigger {
    pub aperiodic_srs_resource_trigger_list: AperiodicSrsResourceTriggerList,
}

impl SrsResourceTrigger {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, false, 1)?;
        let aperiodic_srs_resource_trigger_list = AperiodicSrsResourceTriggerList::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            aperiodic_srs_resource_trigger_list,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, false, &optionals, false)?;
        self.aperiodic_srs_resource_trigger_list.encode(data)?;

        Ok(())
    }
}

impl PerCodec for SrsResourceTrigger {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        SrsResourceTrigger::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SrsResourceTrigger");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SrsResourceTrigger");
            e
        })
    }
}
// SrsResourceType
#[derive(Clone, Debug)]
pub struct SrsResourceType {
    pub srs_resource_type_choice: SrsResourceTypeChoice,
    pub srs_port_index: Option<SrsPortIndex>,
}

impl SrsResourceType {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let srs_resource_type_choice = SrsResourceTypeChoice::decode(data)?;

        // Process the extension container
        let mut srs_port_index: Option<SrsPortIndex> = None;

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    663 => srs_port_index = Some(SrsPortIndex::decode(data)?),
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            srs_resource_type_choice,
            srs_port_index,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();
        if let Some(x) = &self.srs_port_index {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 663, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        let mut optionals = BitString::new();
        optionals.push(num_ies != 0);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.srs_resource_type_choice.encode(data)?;
        if num_ies != 0 {
            encode::encode_length_determinent(data, Some(1), Some(65535), false, num_ies)?;
            data.append_aligned(ies);
        }
        Ok(())
    }
}

impl PerCodec for SrsResourceType {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        SrsResourceType::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SrsResourceType");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SrsResourceType");
            e
        })
    }
}
// SrsResourceTypeChoice
#[derive(Clone, Debug)]
pub enum SrsResourceTypeChoice {
    SrsResourceInfo(SrsInfo),
    PosSrsResourceInfo(PosSrsInfo),
}

impl SrsResourceTypeChoice {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_choice_idx(data, 0, 2, false)?;
        if extended {
            return Err(per_codec_error_new("CHOICE additions not implemented"));
        }
        match idx {
            0 => Ok(Self::SrsResourceInfo(SrsInfo::decode(data)?)),
            1 => Ok(Self::PosSrsResourceInfo(PosSrsInfo::decode(data)?)),
            2 => {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _ = Criticality::decode(data)?;
                let _ = decode::decode_length_determinent(data, None, None, false)?;
                let result = match id {
                    x => Err(per_codec_error_new(format!("Unrecognised IE type {}", x))),
                };
                data.decode_align()?;
                result
            }
            _ => Err(per_codec_error_new("Unknown choice idx")),
        }
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        match self {
            Self::SrsResourceInfo(x) => {
                encode::encode_choice_idx(data, 0, 2, false, 0, false)?;
                x.encode(data)
            }
            Self::PosSrsResourceInfo(x) => {
                encode::encode_choice_idx(data, 0, 2, false, 1, false)?;
                x.encode(data)
            }
        }
    }
}

impl PerCodec for SrsResourceTypeChoice {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        SrsResourceTypeChoice::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SrsResourceTypeChoice");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SrsResourceTypeChoice");
            e
        })
    }
}
// SrsInfo
#[derive(Clone, Debug)]
pub struct SrsInfo {
    pub srs_resource: SrsResourceId,
}

impl SrsInfo {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (_optionals, _extensions_present) = decode::decode_sequence_header(data, true, 0)?;
        let srs_resource = SrsResourceId::decode(data)?;

        Ok(Self { srs_resource })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let optionals = BitString::new();

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.srs_resource.encode(data)?;

        Ok(())
    }
}

impl PerCodec for SrsInfo {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        SrsInfo::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SrsInfo");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SrsInfo");
            e
        })
    }
}
// SrsPeriodicity
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum SrsPeriodicity {
    Slot1,
    Slot2,
    Slot4,
    Slot5,
    Slot8,
    Slot10,
    Slot16,
    Slot20,
    Slot32,
    Slot40,
    Slot64,
    Slot80,
    Slot160,
    Slot320,
    Slot640,
    Slot1280,
    Slot2560,
    Slot5120,
    Slot10240,
    Slot40960,
    Slot81920,
    Slot128,
    Slot256,
    Slot512,
    Slot20480,
}

impl SrsPeriodicity {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(20), true)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(20),
            true,
            *self as i128,
            (*self as u32) >= 21,
        )
    }
}

impl PerCodec for SrsPeriodicity {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        SrsPeriodicity::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SrsPeriodicity");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SrsPeriodicity");
            e
        })
    }
}
// SrsPosRrcInactiveConfig
#[derive(Clone, Debug)]
pub struct SrsPosRrcInactiveConfig(pub Vec<u8>);

impl SrsPosRrcInactiveConfig {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(decode::decode_octetstring(data, None, None, false)?))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_octetstring(data, None, None, false, &self.0, false)
    }
}

impl PerCodec for SrsPosRrcInactiveConfig {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        SrsPosRrcInactiveConfig::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SrsPosRrcInactiveConfig");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SrsPosRrcInactiveConfig");
            e
        })
    }
}
// SrsPosRrcInactiveValidityAreaConfig
#[derive(Clone, Debug)]
pub struct SrsPosRrcInactiveValidityAreaConfig(pub Vec<u8>);

impl SrsPosRrcInactiveValidityAreaConfig {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(decode::decode_octetstring(data, None, None, false)?))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_octetstring(data, None, None, false, &self.0, false)
    }
}

impl PerCodec for SrsPosRrcInactiveValidityAreaConfig {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        SrsPosRrcInactiveValidityAreaConfig::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SrsPosRrcInactiveValidityAreaConfig");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SrsPosRrcInactiveValidityAreaConfig");
            e
        })
    }
}
// SrsPosRrcInactiveQueryIndication
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum SrsPosRrcInactiveQueryIndication {
    True,
}

impl SrsPosRrcInactiveQueryIndication {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(0), true)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(0),
            true,
            *self as i128,
            (*self as u32) >= 1,
        )
    }
}

impl PerCodec for SrsPosRrcInactiveQueryIndication {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        SrsPosRrcInactiveQueryIndication::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SrsPosRrcInactiveQueryIndication");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SrsPosRrcInactiveQueryIndication");
            e
        })
    }
}
// PosSrsInfo
#[derive(Clone, Debug)]
pub struct PosSrsInfo {
    pub pos_srs_resource_id: SrsPosResourceId,
}

impl PosSrsInfo {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (_optionals, _extensions_present) = decode::decode_sequence_header(data, true, 0)?;
        let pos_srs_resource_id = SrsPosResourceId::decode(data)?;

        Ok(Self {
            pos_srs_resource_id,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let optionals = BitString::new();

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.pos_srs_resource_id.encode(data)?;

        Ok(())
    }
}

impl PerCodec for PosSrsInfo {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PosSrsInfo::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PosSrsInfo");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PosSrsInfo");
            e
        })
    }
}
// SrsReservationType
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum SrsReservationType {
    Reserve,
    Release,
}

impl SrsReservationType {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(1), true)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(1),
            true,
            *self as i128,
            (*self as u32) >= 2,
        )
    }
}

impl PerCodec for SrsReservationType {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        SrsReservationType::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SrsReservationType");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SrsReservationType");
            e
        })
    }
}
// Ssb
#[derive(Clone, Debug)]
pub struct Ssb {
    pub pci_nr: NrPci,
    pub ssb_index: Option<SsbIndex>,
}

impl Ssb {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, false, 2)?;
        let pci_nr = NrPci::decode(data)?;
        let ssb_index = if optionals[0] {
            Some(SsbIndex::decode(data)?)
        } else {
            None
        };

        // Process the extension container

        if optionals[1] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self { pci_nr, ssb_index })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.ssb_index.is_some());
        optionals.push(false);

        encode::encode_sequence_header(data, false, &optionals, false)?;
        self.pci_nr.encode(data)?;
        if let Some(x) = &self.ssb_index {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl PerCodec for Ssb {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ssb::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("Ssb");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("Ssb");
            e
        })
    }
}
// SsbCoverageModificationList
#[derive(Clone, Debug)]
pub struct SsbCoverageModificationList(pub NonEmpty<SsbCoverageModificationItem>);

impl SsbCoverageModificationList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(64), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(SsbCoverageModificationItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(64), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for SsbCoverageModificationList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        SsbCoverageModificationList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SsbCoverageModificationList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SsbCoverageModificationList");
            e
        })
    }
}
// SsbCoverageModificationItem
#[derive(Clone, Debug)]
pub struct SsbCoverageModificationItem {
    pub ssb_index: u8,
    pub ssb_coverage_state: SsbCoverageState,
}

impl SsbCoverageModificationItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let ssb_index = decode::decode_integer(data, Some(0), Some(63), false)?.0 as u8;
        let ssb_coverage_state = SsbCoverageState::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            ssb_index,
            ssb_coverage_state,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        encode::encode_integer(
            data,
            Some(0),
            Some(63),
            false,
            self.ssb_index as i128,
            false,
        )?;
        self.ssb_coverage_state.encode(data)?;

        Ok(())
    }
}

impl PerCodec for SsbCoverageModificationItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        SsbCoverageModificationItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SsbCoverageModificationItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SsbCoverageModificationItem");
            e
        })
    }
}
// SsbCoverageState
#[derive(Clone, Copy, Debug)]
pub struct SsbCoverageState(pub u8);

impl SsbCoverageState {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(
            decode::decode_integer(data, Some(0), Some(15), true)?.0 as u8,
        ))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_integer(data, Some(0), Some(15), true, self.0 as i128, false)
    }
}

impl PerCodec for SsbCoverageState {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        SsbCoverageState::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SsbCoverageState");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SsbCoverageState");
            e
        })
    }
}
// SsbFreqInfo
#[derive(Clone, Copy, Debug)]
pub struct SsbFreqInfo(pub u32);

impl SsbFreqInfo {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(
            decode::decode_integer(data, Some(0), Some(3279165), false)?.0 as u32,
        ))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_integer(data, Some(0), Some(3279165), false, self.0 as i128, false)
    }
}

impl PerCodec for SsbFreqInfo {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        SsbFreqInfo::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SsbFreqInfo");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SsbFreqInfo");
            e
        })
    }
}
// SsbIndex
#[derive(Clone, Copy, Debug)]
pub struct SsbIndex(pub u8);

impl SsbIndex {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(
            decode::decode_integer(data, Some(0), Some(63), false)?.0 as u8,
        ))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_integer(data, Some(0), Some(63), false, self.0 as i128, false)
    }
}

impl PerCodec for SsbIndex {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        SsbIndex::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SsbIndex");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SsbIndex");
            e
        })
    }
}
// SsbSubcarrierSpacing
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum SsbSubcarrierSpacing {
    KHz15,
    KHz30,
    KHz120,
    KHz240,
    Spare3,
    Spare2,
    Spare1,
}

impl SsbSubcarrierSpacing {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(6), true)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(6),
            true,
            *self as i128,
            (*self as u32) >= 7,
        )
    }
}

impl PerCodec for SsbSubcarrierSpacing {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        SsbSubcarrierSpacing::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SsbSubcarrierSpacing");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SsbSubcarrierSpacing");
            e
        })
    }
}
// SsbTransmissionPeriodicity
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum SsbTransmissionPeriodicity {
    Sf10,
    Sf20,
    Sf40,
    Sf80,
    Sf160,
    Sf320,
    Sf640,
    Sf5,
}

impl SsbTransmissionPeriodicity {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(6), true)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(6),
            true,
            *self as i128,
            (*self as u32) >= 7,
        )
    }
}

impl PerCodec for SsbTransmissionPeriodicity {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        SsbTransmissionPeriodicity::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SsbTransmissionPeriodicity");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SsbTransmissionPeriodicity");
            e
        })
    }
}
// SsbTransmissionTimingOffset
#[derive(Clone, Copy, Debug)]
pub struct SsbTransmissionTimingOffset(pub u8);

impl SsbTransmissionTimingOffset {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(
            decode::decode_integer(data, Some(0), Some(127), true)?.0 as u8,
        ))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_integer(data, Some(0), Some(127), true, self.0 as i128, false)
    }
}

impl PerCodec for SsbTransmissionTimingOffset {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        SsbTransmissionTimingOffset::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SsbTransmissionTimingOffset");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SsbTransmissionTimingOffset");
            e
        })
    }
}
// SsbTransmissionBitmap
#[derive(Clone, Debug)]
pub enum SsbTransmissionBitmap {
    ShortBitmap(BitString),
    MediumBitmap(BitString),
    LongBitmap(BitString),
}

impl SsbTransmissionBitmap {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_choice_idx(data, 0, 3, false)?;
        if extended {
            return Err(per_codec_error_new("CHOICE additions not implemented"));
        }
        match idx {
            0 => Ok(Self::ShortBitmap(decode::decode_bitstring(
                data,
                Some(4),
                Some(4),
                false,
            )?)),
            1 => Ok(Self::MediumBitmap(decode::decode_bitstring(
                data,
                Some(8),
                Some(8),
                false,
            )?)),
            2 => Ok(Self::LongBitmap(decode::decode_bitstring(
                data,
                Some(64),
                Some(64),
                false,
            )?)),
            3 => {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _ = Criticality::decode(data)?;
                let _ = decode::decode_length_determinent(data, None, None, false)?;
                let result = match id {
                    x => Err(per_codec_error_new(format!("Unrecognised IE type {}", x))),
                };
                data.decode_align()?;
                result
            }
            _ => Err(per_codec_error_new("Unknown choice idx")),
        }
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        match self {
            Self::ShortBitmap(x) => {
                encode::encode_choice_idx(data, 0, 3, false, 0, false)?;
                encode::encode_bitstring(data, Some(4), Some(4), false, &x, false)
            }
            Self::MediumBitmap(x) => {
                encode::encode_choice_idx(data, 0, 3, false, 1, false)?;
                encode::encode_bitstring(data, Some(8), Some(8), false, &x, false)
            }
            Self::LongBitmap(x) => {
                encode::encode_choice_idx(data, 0, 3, false, 2, false)?;
                encode::encode_bitstring(data, Some(64), Some(64), false, &x, false)
            }
        }
    }
}

impl PerCodec for SsbTransmissionBitmap {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        SsbTransmissionBitmap::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SsbTransmissionBitmap");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SsbTransmissionBitmap");
            e
        })
    }
}
// SsbAreaCapacityValueList
#[derive(Clone, Debug)]
pub struct SsbAreaCapacityValueList(pub NonEmpty<SsbAreaCapacityValueItem>);

impl SsbAreaCapacityValueList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(64), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(SsbAreaCapacityValueItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(64), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for SsbAreaCapacityValueList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        SsbAreaCapacityValueList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SsbAreaCapacityValueList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SsbAreaCapacityValueList");
            e
        })
    }
}
// SsbAreaCapacityValueItem
#[derive(Clone, Debug)]
pub struct SsbAreaCapacityValueItem {
    pub ssb_index: u8,
    pub ssb_area_capacity_value: u8,
}

impl SsbAreaCapacityValueItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, false, 1)?;
        let ssb_index = decode::decode_integer(data, Some(0), Some(63), false)?.0 as u8;
        let ssb_area_capacity_value =
            decode::decode_integer(data, Some(0), Some(100), false)?.0 as u8;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            ssb_index,
            ssb_area_capacity_value,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, false, &optionals, false)?;
        encode::encode_integer(
            data,
            Some(0),
            Some(63),
            false,
            self.ssb_index as i128,
            false,
        )?;
        encode::encode_integer(
            data,
            Some(0),
            Some(100),
            false,
            self.ssb_area_capacity_value as i128,
            false,
        )?;

        Ok(())
    }
}

impl PerCodec for SsbAreaCapacityValueItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        SsbAreaCapacityValueItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SsbAreaCapacityValueItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SsbAreaCapacityValueItem");
            e
        })
    }
}
// SsbAreaRadioResourceStatusList
#[derive(Clone, Debug)]
pub struct SsbAreaRadioResourceStatusList(pub NonEmpty<SsbAreaRadioResourceStatusItem>);

impl SsbAreaRadioResourceStatusList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(64), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(SsbAreaRadioResourceStatusItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(64), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for SsbAreaRadioResourceStatusList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        SsbAreaRadioResourceStatusList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SsbAreaRadioResourceStatusList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SsbAreaRadioResourceStatusList");
            e
        })
    }
}
// SsbAreaRadioResourceStatusItem
#[derive(Clone, Debug)]
pub struct SsbAreaRadioResourceStatusItem {
    pub ssb_index: u8,
    pub ssb_area_dl_gbrpr_busage: u8,
    pub ssb_area_ul_gbrpr_busage: u8,
    pub ssb_area_dl_non_gbrpr_busage: u8,
    pub ssb_area_ul_non_gbrpr_busage: u8,
    pub ssb_area_dl_total_pr_busage: u8,
    pub ssb_area_ul_total_pr_busage: u8,
    pub d_lscheduling_pdcchcc_eusage: Option<u8>,
    pub u_lscheduling_pdcchcc_eusage: Option<u8>,
}

impl SsbAreaRadioResourceStatusItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, false, 3)?;
        let ssb_index = decode::decode_integer(data, Some(0), Some(63), false)?.0 as u8;
        let ssb_area_dl_gbrpr_busage =
            decode::decode_integer(data, Some(0), Some(100), false)?.0 as u8;
        let ssb_area_ul_gbrpr_busage =
            decode::decode_integer(data, Some(0), Some(100), false)?.0 as u8;
        let ssb_area_dl_non_gbrpr_busage =
            decode::decode_integer(data, Some(0), Some(100), false)?.0 as u8;
        let ssb_area_ul_non_gbrpr_busage =
            decode::decode_integer(data, Some(0), Some(100), false)?.0 as u8;
        let ssb_area_dl_total_pr_busage =
            decode::decode_integer(data, Some(0), Some(100), false)?.0 as u8;
        let ssb_area_ul_total_pr_busage =
            decode::decode_integer(data, Some(0), Some(100), false)?.0 as u8;
        let d_lscheduling_pdcchcc_eusage = if optionals[0] {
            Some(decode::decode_integer(data, Some(0), Some(100), false)?.0 as u8)
        } else {
            None
        };
        let u_lscheduling_pdcchcc_eusage = if optionals[1] {
            Some(decode::decode_integer(data, Some(0), Some(100), false)?.0 as u8)
        } else {
            None
        };

        // Process the extension container

        if optionals[2] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            ssb_index,
            ssb_area_dl_gbrpr_busage,
            ssb_area_ul_gbrpr_busage,
            ssb_area_dl_non_gbrpr_busage,
            ssb_area_ul_non_gbrpr_busage,
            ssb_area_dl_total_pr_busage,
            ssb_area_ul_total_pr_busage,
            d_lscheduling_pdcchcc_eusage,
            u_lscheduling_pdcchcc_eusage,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.d_lscheduling_pdcchcc_eusage.is_some());
        optionals.push(self.u_lscheduling_pdcchcc_eusage.is_some());
        optionals.push(false);

        encode::encode_sequence_header(data, false, &optionals, false)?;
        encode::encode_integer(
            data,
            Some(0),
            Some(63),
            false,
            self.ssb_index as i128,
            false,
        )?;
        encode::encode_integer(
            data,
            Some(0),
            Some(100),
            false,
            self.ssb_area_dl_gbrpr_busage as i128,
            false,
        )?;
        encode::encode_integer(
            data,
            Some(0),
            Some(100),
            false,
            self.ssb_area_ul_gbrpr_busage as i128,
            false,
        )?;
        encode::encode_integer(
            data,
            Some(0),
            Some(100),
            false,
            self.ssb_area_dl_non_gbrpr_busage as i128,
            false,
        )?;
        encode::encode_integer(
            data,
            Some(0),
            Some(100),
            false,
            self.ssb_area_ul_non_gbrpr_busage as i128,
            false,
        )?;
        encode::encode_integer(
            data,
            Some(0),
            Some(100),
            false,
            self.ssb_area_dl_total_pr_busage as i128,
            false,
        )?;
        encode::encode_integer(
            data,
            Some(0),
            Some(100),
            false,
            self.ssb_area_ul_total_pr_busage as i128,
            false,
        )?;
        if let Some(x) = &self.d_lscheduling_pdcchcc_eusage {
            encode::encode_integer(data, Some(0), Some(100), false, *x as i128, false)?;
        }
        if let Some(x) = &self.u_lscheduling_pdcchcc_eusage {
            encode::encode_integer(data, Some(0), Some(100), false, *x as i128, false)?;
        }

        Ok(())
    }
}

impl PerCodec for SsbAreaRadioResourceStatusItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        SsbAreaRadioResourceStatusItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SsbAreaRadioResourceStatusItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SsbAreaRadioResourceStatusItem");
            e
        })
    }
}
// SsbInformation
#[derive(Clone, Debug)]
pub struct SsbInformation {
    pub ssb_information_list: SsbInformationList,
}

impl SsbInformation {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, false, 1)?;
        let ssb_information_list = SsbInformationList::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            ssb_information_list,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, false, &optionals, false)?;
        self.ssb_information_list.encode(data)?;

        Ok(())
    }
}

impl PerCodec for SsbInformation {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        SsbInformation::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SsbInformation");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SsbInformation");
            e
        })
    }
}
// SsbInformationList
#[derive(Clone, Debug)]
pub struct SsbInformationList(pub NonEmpty<SsbInformationItem>);

impl SsbInformationList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(255), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(SsbInformationItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(255), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for SsbInformationList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        SsbInformationList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SsbInformationList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SsbInformationList");
            e
        })
    }
}
// SsbInformationItem
#[derive(Clone, Debug)]
pub struct SsbInformationItem {
    pub ssb_configuration: SsbTfConfiguration,
    pub pci_nr: NrPci,
}

impl SsbInformationItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, false, 1)?;
        let ssb_configuration = SsbTfConfiguration::decode(data)?;
        let pci_nr = NrPci::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            ssb_configuration,
            pci_nr,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, false, &optionals, false)?;
        self.ssb_configuration.encode(data)?;
        self.pci_nr.encode(data)?;

        Ok(())
    }
}

impl PerCodec for SsbInformationItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        SsbInformationItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SsbInformationItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SsbInformationItem");
            e
        })
    }
}
// SsbPositionsInBurst
#[derive(Clone, Debug)]
pub enum SsbPositionsInBurst {
    ShortBitmap(BitString),
    MediumBitmap(BitString),
    LongBitmap(BitString),
}

impl SsbPositionsInBurst {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_choice_idx(data, 0, 3, false)?;
        if extended {
            return Err(per_codec_error_new("CHOICE additions not implemented"));
        }
        match idx {
            0 => Ok(Self::ShortBitmap(decode::decode_bitstring(
                data,
                Some(4),
                Some(4),
                false,
            )?)),
            1 => Ok(Self::MediumBitmap(decode::decode_bitstring(
                data,
                Some(8),
                Some(8),
                false,
            )?)),
            2 => Ok(Self::LongBitmap(decode::decode_bitstring(
                data,
                Some(64),
                Some(64),
                false,
            )?)),
            3 => {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _ = Criticality::decode(data)?;
                let _ = decode::decode_length_determinent(data, None, None, false)?;
                let result = match id {
                    x => Err(per_codec_error_new(format!("Unrecognised IE type {}", x))),
                };
                data.decode_align()?;
                result
            }
            _ => Err(per_codec_error_new("Unknown choice idx")),
        }
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        match self {
            Self::ShortBitmap(x) => {
                encode::encode_choice_idx(data, 0, 3, false, 0, false)?;
                encode::encode_bitstring(data, Some(4), Some(4), false, &x, false)
            }
            Self::MediumBitmap(x) => {
                encode::encode_choice_idx(data, 0, 3, false, 1, false)?;
                encode::encode_bitstring(data, Some(8), Some(8), false, &x, false)
            }
            Self::LongBitmap(x) => {
                encode::encode_choice_idx(data, 0, 3, false, 2, false)?;
                encode::encode_bitstring(data, Some(64), Some(64), false, &x, false)
            }
        }
    }
}

impl PerCodec for SsbPositionsInBurst {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        SsbPositionsInBurst::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SsbPositionsInBurst");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SsbPositionsInBurst");
            e
        })
    }
}
// SsBsActivatedList
#[derive(Clone, Debug)]
pub struct SsBsActivatedList(pub NonEmpty<SsbIndex>);

impl SsBsActivatedList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(64), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(SsbIndex::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(64), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for SsBsActivatedList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        SsBsActivatedList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SsBsActivatedList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SsBsActivatedList");
            e
        })
    }
}
// SsBsForPagingList
#[derive(Clone, Debug)]
pub struct SsBsForPagingList(pub NonEmpty<SsbIndex>);

impl SsBsForPagingList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(64), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(SsbIndex::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(64), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for SsBsForPagingList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        SsBsForPagingList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SsBsForPagingList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SsBsForPagingList");
            e
        })
    }
}
// SsBsToBeActivatedList
#[derive(Clone, Debug)]
pub struct SsBsToBeActivatedList(pub NonEmpty<SsbIndex>);

impl SsBsToBeActivatedList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(64), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(SsbIndex::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(64), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for SsBsToBeActivatedList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        SsBsToBeActivatedList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SsBsToBeActivatedList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SsBsToBeActivatedList");
            e
        })
    }
}
// SsbTfConfiguration
#[derive(Clone, Debug)]
pub struct SsbTfConfiguration {
    pub ssb_frequency: u32,
    pub ssb_subcarrier_spacing: SsbSubcarrierSpacing1,
    pub ssb_transmit_power: i8,
    pub ssb_periodicity: SsbPeriodicity,
    pub ssb_half_frame_offset: u8,
    pub ssb_sfn_offset: u8,
    pub ssb_position_in_burst: Option<SsbPositionsInBurst>,
    pub sfn_initialisation_time: Option<RelativeTime1900>,
}

impl SsbTfConfiguration {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, false, 3)?;
        let ssb_frequency = decode::decode_integer(data, Some(0), Some(3279165), false)?.0 as u32;
        let ssb_subcarrier_spacing = SsbSubcarrierSpacing1::decode(data)?;
        let ssb_transmit_power = decode::decode_integer(data, Some(-60), Some(50), false)?.0 as i8;
        let ssb_periodicity = SsbPeriodicity::decode(data)?;
        let ssb_half_frame_offset = decode::decode_integer(data, Some(0), Some(1), false)?.0 as u8;
        let ssb_sfn_offset = decode::decode_integer(data, Some(0), Some(15), false)?.0 as u8;
        let ssb_position_in_burst = if optionals[0] {
            Some(SsbPositionsInBurst::decode(data)?)
        } else {
            None
        };
        let sfn_initialisation_time = if optionals[1] {
            Some(RelativeTime1900::decode(data)?)
        } else {
            None
        };

        // Process the extension container

        if optionals[2] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            ssb_frequency,
            ssb_subcarrier_spacing,
            ssb_transmit_power,
            ssb_periodicity,
            ssb_half_frame_offset,
            ssb_sfn_offset,
            ssb_position_in_burst,
            sfn_initialisation_time,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.ssb_position_in_burst.is_some());
        optionals.push(self.sfn_initialisation_time.is_some());
        optionals.push(false);

        encode::encode_sequence_header(data, false, &optionals, false)?;
        encode::encode_integer(
            data,
            Some(0),
            Some(3279165),
            false,
            self.ssb_frequency as i128,
            false,
        )?;
        self.ssb_subcarrier_spacing.encode(data)?;
        encode::encode_integer(
            data,
            Some(-60),
            Some(50),
            false,
            self.ssb_transmit_power as i128,
            false,
        )?;
        self.ssb_periodicity.encode(data)?;
        encode::encode_integer(
            data,
            Some(0),
            Some(1),
            false,
            self.ssb_half_frame_offset as i128,
            false,
        )?;
        encode::encode_integer(
            data,
            Some(0),
            Some(15),
            false,
            self.ssb_sfn_offset as i128,
            false,
        )?;
        if let Some(x) = &self.ssb_position_in_burst {
            x.encode(data)?;
        }
        if let Some(x) = &self.sfn_initialisation_time {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl PerCodec for SsbTfConfiguration {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        SsbTfConfiguration::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SsbTfConfiguration");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SsbTfConfiguration");
            e
        })
    }
}
// SsbToReportList
#[derive(Clone, Debug)]
pub struct SsbToReportList(pub NonEmpty<SsbToReportItem>);

impl SsbToReportList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(64), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(SsbToReportItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(64), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for SsbToReportList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        SsbToReportList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SsbToReportList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SsbToReportList");
            e
        })
    }
}
// SsbToReportItem
#[derive(Clone, Debug)]
pub struct SsbToReportItem {
    pub ssb_index: u8,
}

impl SsbToReportItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, false, 1)?;
        let ssb_index = decode::decode_integer(data, Some(0), Some(63), false)?.0 as u8;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self { ssb_index })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, false, &optionals, false)?;
        encode::encode_integer(
            data,
            Some(0),
            Some(63),
            false,
            self.ssb_index as i128,
            false,
        )?;

        Ok(())
    }
}

impl PerCodec for SsbToReportItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        SsbToReportItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SsbToReportItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SsbToReportItem");
            e
        })
    }
}
// StartRbIndex
#[derive(Clone, Debug)]
pub enum StartRbIndex {
    FreqScalingFactor2(u8),
    FreqScalingFactor4(u8),
}

impl StartRbIndex {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_choice_idx(data, 0, 2, false)?;
        if extended {
            return Err(per_codec_error_new("CHOICE additions not implemented"));
        }
        match idx {
            0 => Ok(Self::FreqScalingFactor2(
                decode::decode_integer(data, Some(0), Some(1), false)?.0 as u8,
            )),
            1 => Ok(Self::FreqScalingFactor4(
                decode::decode_integer(data, Some(0), Some(3), false)?.0 as u8,
            )),
            2 => {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _ = Criticality::decode(data)?;
                let _ = decode::decode_length_determinent(data, None, None, false)?;
                let result = match id {
                    x => Err(per_codec_error_new(format!("Unrecognised IE type {}", x))),
                };
                data.decode_align()?;
                result
            }
            _ => Err(per_codec_error_new("Unknown choice idx")),
        }
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        match self {
            Self::FreqScalingFactor2(x) => {
                encode::encode_choice_idx(data, 0, 2, false, 0, false)?;
                encode::encode_integer(data, Some(0), Some(1), false, *x as i128, false)
            }
            Self::FreqScalingFactor4(x) => {
                encode::encode_choice_idx(data, 0, 2, false, 1, false)?;
                encode::encode_integer(data, Some(0), Some(3), false, *x as i128, false)
            }
        }
    }
}

impl PerCodec for StartRbIndex {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        StartRbIndex::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("StartRbIndex");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("StartRbIndex");
            e
        })
    }
}
// StartRbHopping
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum StartRbHopping {
    Enable,
}

impl StartRbHopping {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(0), false)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(0),
            false,
            *self as i128,
            (*self as u32) >= 1,
        )
    }
}

impl PerCodec for StartRbHopping {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        StartRbHopping::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("StartRbHopping");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("StartRbHopping");
            e
        })
    }
}
// StartTimeAndDuration
#[derive(Clone, Debug)]
pub struct StartTimeAndDuration {
    pub start_time: Option<RelativeTime1900>,
    pub duration: Option<u32>,
}

impl StartTimeAndDuration {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 3)?;
        let start_time = if optionals[0] {
            Some(RelativeTime1900::decode(data)?)
        } else {
            None
        };
        let duration = if optionals[1] {
            Some(decode::decode_integer(data, Some(0), Some(90060), true)?.0 as u32)
        } else {
            None
        };

        // Process the extension container

        if optionals[2] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            start_time,
            duration,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.start_time.is_some());
        optionals.push(self.duration.is_some());
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        if let Some(x) = &self.start_time {
            x.encode(data)?;
        }
        if let Some(x) = &self.duration {
            encode::encode_integer(data, Some(0), Some(90060), true, *x as i128, false)?;
        }

        Ok(())
    }
}

impl PerCodec for StartTimeAndDuration {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        StartTimeAndDuration::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("StartTimeAndDuration");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("StartTimeAndDuration");
            e
        })
    }
}
// SulInformation
#[derive(Clone, Debug)]
pub struct SulInformation {
    pub sul_nr_arfcn: u32,
    pub sul_transmission_bandwidth: TransmissionBandwidth,
    pub carrier_list: Option<NrCarrierList>,
    pub frequency_shift7p5khz: Option<FrequencyShift7p5khz>,
}

impl SulInformation {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let sul_nr_arfcn = decode::decode_integer(data, Some(0), Some(3279165), false)?.0 as u32;
        let sul_transmission_bandwidth = TransmissionBandwidth::decode(data)?;

        // Process the extension container
        let mut carrier_list: Option<NrCarrierList> = None;
        let mut frequency_shift7p5khz: Option<FrequencyShift7p5khz> = None;

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    354 => carrier_list = Some(NrCarrierList::decode(data)?),
                    356 => frequency_shift7p5khz = Some(FrequencyShift7p5khz::decode(data)?),
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            sul_nr_arfcn,
            sul_transmission_bandwidth,
            carrier_list,
            frequency_shift7p5khz,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();
        if let Some(x) = &self.carrier_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 354, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.frequency_shift7p5khz {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 356, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        let mut optionals = BitString::new();
        optionals.push(num_ies != 0);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        encode::encode_integer(
            data,
            Some(0),
            Some(3279165),
            false,
            self.sul_nr_arfcn as i128,
            false,
        )?;
        self.sul_transmission_bandwidth.encode(data)?;
        if num_ies != 0 {
            encode::encode_length_determinent(data, Some(1), Some(65535), false, num_ies)?;
            data.append_aligned(ies);
        }
        Ok(())
    }
}

impl PerCodec for SulInformation {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        SulInformation::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SulInformation");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SulInformation");
            e
        })
    }
}
// SubcarrierSpacing
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum SubcarrierSpacing {
    KHz15,
    KHz30,
    KHz60,
    KHz120,
    KHz240,
    Spare3,
    Spare2,
    Spare1,
}

impl SubcarrierSpacing {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(7), true)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(7),
            true,
            *self as i128,
            (*self as u32) >= 8,
        )
    }
}

impl PerCodec for SubcarrierSpacing {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        SubcarrierSpacing::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SubcarrierSpacing");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SubcarrierSpacing");
            e
        })
    }
}
// SubscriberProfileIDforRfp
#[derive(Clone, Copy, Debug)]
pub struct SubscriberProfileIDforRfp(pub u16);

impl SubscriberProfileIDforRfp {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(
            decode::decode_integer(data, Some(1), Some(256), true)?.0 as u16,
        ))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_integer(data, Some(1), Some(256), true, self.0 as i128, false)
    }
}

impl PerCodec for SubscriberProfileIDforRfp {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        SubscriberProfileIDforRfp::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SubscriberProfileIDforRfp");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SubscriberProfileIDforRfp");
            e
        })
    }
}
// SuccessfulHoReportInformationList
#[derive(Clone, Debug)]
pub struct SuccessfulHoReportInformationList(pub NonEmpty<SuccessfulHoReportInformationItem>);

impl SuccessfulHoReportInformationList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(64), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(SuccessfulHoReportInformationItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(64), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for SuccessfulHoReportInformationList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        SuccessfulHoReportInformationList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SuccessfulHoReportInformationList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SuccessfulHoReportInformationList");
            e
        })
    }
}
// SuccessfulHoReportInformationItem
#[derive(Clone, Debug)]
pub struct SuccessfulHoReportInformationItem {
    pub successful_ho_report_container: Vec<u8>,
}

impl SuccessfulHoReportInformationItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, false, 1)?;
        let successful_ho_report_container = decode::decode_octetstring(data, None, None, false)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            successful_ho_report_container,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, false, &optionals, false)?;
        encode::encode_octetstring(
            data,
            None,
            None,
            false,
            &self.successful_ho_report_container,
            false,
        )?;

        Ok(())
    }
}

impl PerCodec for SuccessfulHoReportInformationItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        SuccessfulHoReportInformationItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SuccessfulHoReportInformationItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SuccessfulHoReportInformationItem");
            e
        })
    }
}
// SuccessfulPsCellChangeReportInformationList
#[derive(Clone, Debug)]
pub struct SuccessfulPsCellChangeReportInformationList(
    pub NonEmpty<SuccessfulPsCellChangeReportInformationItem>,
);

impl SuccessfulPsCellChangeReportInformationList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(64), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(SuccessfulPsCellChangeReportInformationItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(64), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for SuccessfulPsCellChangeReportInformationList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        SuccessfulPsCellChangeReportInformationList::decode_inner(data).map_err(
            |mut e: PerCodecError| {
                e.push_context("SuccessfulPsCellChangeReportInformationList");
                e
            },
        )
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SuccessfulPsCellChangeReportInformationList");
            e
        })
    }
}
// SuccessfulPsCellChangeReportInformationItem
#[derive(Clone, Debug)]
pub struct SuccessfulPsCellChangeReportInformationItem {
    pub successful_ps_cell_change_report_container: Vec<u8>,
}

impl SuccessfulPsCellChangeReportInformationItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, false, 1)?;
        let successful_ps_cell_change_report_container =
            decode::decode_octetstring(data, None, None, false)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            successful_ps_cell_change_report_container,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, false, &optionals, false)?;
        encode::encode_octetstring(
            data,
            None,
            None,
            false,
            &self.successful_ps_cell_change_report_container,
            false,
        )?;

        Ok(())
    }
}

impl PerCodec for SuccessfulPsCellChangeReportInformationItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        SuccessfulPsCellChangeReportInformationItem::decode_inner(data).map_err(
            |mut e: PerCodecError| {
                e.push_context("SuccessfulPsCellChangeReportInformationItem");
                e
            },
        )
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SuccessfulPsCellChangeReportInformationItem");
            e
        })
    }
}
// SulAccessIndication
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum SulAccessIndication {
    True,
}

impl SulAccessIndication {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(0), true)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(0),
            true,
            *self as i128,
            (*self as u32) >= 1,
        )
    }
}

impl PerCodec for SulAccessIndication {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        SulAccessIndication::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SulAccessIndication");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SulAccessIndication");
            e
        })
    }
}
// SupportedSulFreqBandItem
#[derive(Clone, Debug)]
pub struct SupportedSulFreqBandItem {
    pub freq_band_indicator_nr: u16,
}

impl SupportedSulFreqBandItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let freq_band_indicator_nr =
            decode::decode_integer(data, Some(1), Some(1024), true)?.0 as u16;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            freq_band_indicator_nr,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        encode::encode_integer(
            data,
            Some(1),
            Some(1024),
            true,
            self.freq_band_indicator_nr as i128,
            false,
        )?;

        Ok(())
    }
}

impl PerCodec for SupportedSulFreqBandItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        SupportedSulFreqBandItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SupportedSulFreqBandItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SupportedSulFreqBandItem");
            e
        })
    }
}
// SupportedUeTypeList
#[derive(Clone, Debug)]
pub struct SupportedUeTypeList(pub NonEmpty<SupportedUeTypeListItem>);

impl SupportedUeTypeList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(8), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(SupportedUeTypeListItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(8), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for SupportedUeTypeList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        SupportedUeTypeList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SupportedUeTypeList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SupportedUeTypeList");
            e
        })
    }
}
// SupportedUeTypeListItem
#[derive(Clone, Debug)]
pub struct SupportedUeTypeListItem {
    pub supported_ue_type: SupportedUeType,
}

impl SupportedUeTypeListItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let supported_ue_type = SupportedUeType::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self { supported_ue_type })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.supported_ue_type.encode(data)?;

        Ok(())
    }
}

impl PerCodec for SupportedUeTypeListItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        SupportedUeTypeListItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SupportedUeTypeListItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SupportedUeTypeListItem");
            e
        })
    }
}
// SurvivalTime
#[derive(Clone, Copy, Debug)]
pub struct SurvivalTime(pub u32);

impl SurvivalTime {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(
            decode::decode_integer(data, Some(0), Some(1920000), true)?.0 as u32,
        ))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_integer(data, Some(0), Some(1920000), true, self.0 as i128, false)
    }
}

impl PerCodec for SurvivalTime {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        SurvivalTime::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SurvivalTime");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SurvivalTime");
            e
        })
    }
}
// SymbolAllocInSlot
#[derive(Clone, Debug)]
pub enum SymbolAllocInSlot {
    AllDl,
    AllUl,
    BothDlAndUl(NumDlUlSymbols),
}

impl SymbolAllocInSlot {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_choice_idx(data, 0, 3, false)?;
        if extended {
            return Err(per_codec_error_new("CHOICE additions not implemented"));
        }
        match idx {
            0 => Ok(Self::AllDl),
            1 => Ok(Self::AllUl),
            2 => Ok(Self::BothDlAndUl(NumDlUlSymbols::decode(data)?)),
            3 => {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _ = Criticality::decode(data)?;
                let _ = decode::decode_length_determinent(data, None, None, false)?;
                let result = match id {
                    x => Err(per_codec_error_new(format!("Unrecognised IE type {}", x))),
                };
                data.decode_align()?;
                result
            }
            _ => Err(per_codec_error_new("Unknown choice idx")),
        }
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        match self {
            Self::AllDl => {
                encode::encode_choice_idx(data, 0, 3, false, 0, false)?;
                Ok(())
            }
            Self::AllUl => {
                encode::encode_choice_idx(data, 0, 3, false, 1, false)?;
                Ok(())
            }
            Self::BothDlAndUl(x) => {
                encode::encode_choice_idx(data, 0, 3, false, 2, false)?;
                x.encode(data)
            }
        }
    }
}

impl PerCodec for SymbolAllocInSlot {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        SymbolAllocInSlot::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SymbolAllocInSlot");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SymbolAllocInSlot");
            e
        })
    }
}
// SymbolIndex
#[derive(Clone, Copy, Debug)]
pub struct SymbolIndex(pub u8);

impl SymbolIndex {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(
            decode::decode_integer(data, Some(0), Some(13), false)?.0 as u8,
        ))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_integer(data, Some(0), Some(13), false, self.0 as i128, false)
    }
}

impl PerCodec for SymbolIndex {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        SymbolIndex::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SymbolIndex");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SymbolIndex");
            e
        })
    }
}
// SystemFrameNumber
#[derive(Clone, Copy, Debug)]
pub struct SystemFrameNumber(pub u16);

impl SystemFrameNumber {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(
            decode::decode_integer(data, Some(0), Some(1023), false)?.0 as u16,
        ))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_integer(data, Some(0), Some(1023), false, self.0 as i128, false)
    }
}

impl PerCodec for SystemFrameNumber {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        SystemFrameNumber::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SystemFrameNumber");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SystemFrameNumber");
            e
        })
    }
}
// SystemInformationAreaId
#[derive(Clone, Debug)]
pub struct SystemInformationAreaId(pub BitString);

impl SystemInformationAreaId {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(decode::decode_bitstring(
            data,
            Some(24),
            Some(24),
            false,
        )?))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_bitstring(data, Some(24), Some(24), false, &self.0, false)
    }
}

impl PerCodec for SystemInformationAreaId {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        SystemInformationAreaId::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SystemInformationAreaId");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SystemInformationAreaId");
            e
        })
    }
}
// Tai
#[derive(Clone, Debug)]
pub struct Tai {
    pub plmn_identity: PlmnIdentity,
    pub five_gs_tac: FiveGsTac,
}

impl Tai {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let plmn_identity = PlmnIdentity::decode(data)?;
        let five_gs_tac = FiveGsTac::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            plmn_identity,
            five_gs_tac,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.plmn_identity.encode(data)?;
        self.five_gs_tac.encode(data)?;

        Ok(())
    }
}

impl PerCodec for Tai {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Tai::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("Tai");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("Tai");
            e
        })
    }
}
// TaAssistanceInfo
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum TaAssistanceInfo {
    Zero,
}

impl TaAssistanceInfo {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(0), true)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(0),
            true,
            *self as i128,
            (*self as u32) >= 1,
        )
    }
}

impl PerCodec for TaAssistanceInfo {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        TaAssistanceInfo::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TaAssistanceInfo");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TaAssistanceInfo");
            e
        })
    }
}
// FiveGsTac
#[derive(Clone, Debug)]
pub struct FiveGsTac(pub [u8; 3]);

impl FiveGsTac {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(
            decode::decode_octetstring(data, Some(3), Some(3), false)?
                .try_into()
                .unwrap(),
        ))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_octetstring(data, Some(3), Some(3), false, &(self.0).into(), false)
    }
}

impl PerCodec for FiveGsTac {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        FiveGsTac::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("FiveGsTac");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("FiveGsTac");
            e
        })
    }
}
// ConfiguredEpsTac
#[derive(Clone, Debug)]
pub struct ConfiguredEpsTac(pub [u8; 2]);

impl ConfiguredEpsTac {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(
            decode::decode_octetstring(data, Some(2), Some(2), false)?
                .try_into()
                .unwrap(),
        ))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_octetstring(data, Some(2), Some(2), false, &(self.0).into(), false)
    }
}

impl PerCodec for ConfiguredEpsTac {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        ConfiguredEpsTac::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ConfiguredEpsTac");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ConfiguredEpsTac");
            e
        })
    }
}
// TagIdPointer
#[derive(Clone, Debug)]
pub struct TagIdPointer(pub Vec<u8>);

impl TagIdPointer {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(decode::decode_octetstring(data, None, None, false)?))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_octetstring(data, None, None, false, &self.0, false)
    }
}

impl PerCodec for TagIdPointer {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        TagIdPointer::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TagIdPointer");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TagIdPointer");
            e
        })
    }
}
// TargetCellList
#[derive(Clone, Debug)]
pub struct TargetCellList(pub NonEmpty<TargetCellListItem>);

impl TargetCellList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(8), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(TargetCellListItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(8), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for TargetCellList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        TargetCellList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TargetCellList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TargetCellList");
            e
        })
    }
}
// TargetCellListItem
#[derive(Clone, Debug)]
pub struct TargetCellListItem {
    pub target_cell: NrCgi,
}

impl TargetCellListItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, false, 1)?;
        let target_cell = NrCgi::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self { target_cell })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, false, &optionals, false)?;
        self.target_cell.encode(data)?;

        Ok(())
    }
}

impl PerCodec for TargetCellListItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        TargetCellListItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TargetCellListItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TargetCellListItem");
            e
        })
    }
}
// NsagSupportList
#[derive(Clone, Debug)]
pub struct NsagSupportList(pub NonEmpty<NsagSupportItem>);

impl NsagSupportList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(256), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(NsagSupportItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(256), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for NsagSupportList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        NsagSupportList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NsagSupportList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NsagSupportList");
            e
        })
    }
}
// NsagSupportItem
#[derive(Clone, Debug)]
pub struct NsagSupportItem {
    pub nsag_id: NsagId,
    pub nsag_slice_support: ExtendedSliceSupportList,
}

impl NsagSupportItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let nsag_id = NsagId::decode(data)?;
        let nsag_slice_support = ExtendedSliceSupportList::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            nsag_id,
            nsag_slice_support,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.nsag_id.encode(data)?;
        self.nsag_slice_support.encode(data)?;

        Ok(())
    }
}

impl PerCodec for NsagSupportItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        NsagSupportItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NsagSupportItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NsagSupportItem");
            e
        })
    }
}
// NsagId
#[derive(Clone, Copy, Debug)]
pub struct NsagId(pub u8);

impl NsagId {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(
            decode::decode_integer(data, Some(0), Some(255), true)?.0 as u8,
        ))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_integer(data, Some(0), Some(255), true, self.0 as i128, false)
    }
}

impl PerCodec for NsagId {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        NsagId::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NsagId");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NsagId");
            e
        })
    }
}
// TciStatesConfigurationsList
#[derive(Clone, Debug)]
pub struct TciStatesConfigurationsList(pub Vec<u8>);

impl TciStatesConfigurationsList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(decode::decode_octetstring(data, None, None, false)?))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_octetstring(data, None, None, false, &self.0, false)
    }
}

impl PerCodec for TciStatesConfigurationsList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        TciStatesConfigurationsList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TciStatesConfigurationsList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TciStatesConfigurationsList");
            e
        })
    }
}
// TaValue
#[derive(Clone, Copy, Debug)]
pub struct TaValue(pub u16);

impl TaValue {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(
            decode::decode_integer(data, Some(0), Some(4095), false)?.0 as u16,
        ))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_integer(data, Some(0), Some(4095), false, self.0 as i128, false)
    }
}

impl PerCodec for TaValue {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        TaValue::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TaValue");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TaValue");
            e
        })
    }
}
// TddInfo
#[derive(Clone, Debug)]
pub struct TddInfo {
    pub nr_freq_info: NrFreqInfo,
    pub transmission_bandwidth: TransmissionBandwidth,
    pub intended_tdd_dl_ul_config: Option<IntendedTddDlUlConfig>,
    pub tdd_ul_dl_config_common_nr: Option<TddUlDlConfigCommonNr>,
    pub carrier_list: Option<NrCarrierList>,
    pub transmission_bandwidth_asymmetric: Option<TransmissionBandwidthAsymmetric>,
}

impl TddInfo {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let nr_freq_info = NrFreqInfo::decode(data)?;
        let transmission_bandwidth = TransmissionBandwidth::decode(data)?;

        // Process the extension container
        let mut intended_tdd_dl_ul_config: Option<IntendedTddDlUlConfig> = None;
        let mut tdd_ul_dl_config_common_nr: Option<TddUlDlConfigCommonNr> = None;
        let mut carrier_list: Option<NrCarrierList> = None;
        let mut transmission_bandwidth_asymmetric: Option<TransmissionBandwidthAsymmetric> = None;

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    256 => intended_tdd_dl_ul_config = Some(IntendedTddDlUlConfig::decode(data)?),
                    361 => tdd_ul_dl_config_common_nr = Some(TddUlDlConfigCommonNr::decode(data)?),
                    354 => carrier_list = Some(NrCarrierList::decode(data)?),
                    852 => {
                        transmission_bandwidth_asymmetric =
                            Some(TransmissionBandwidthAsymmetric::decode(data)?)
                    }
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            nr_freq_info,
            transmission_bandwidth,
            intended_tdd_dl_ul_config,
            tdd_ul_dl_config_common_nr,
            carrier_list,
            transmission_bandwidth_asymmetric,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();
        if let Some(x) = &self.intended_tdd_dl_ul_config {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 256, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.tdd_ul_dl_config_common_nr {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 361, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.carrier_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 354, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.transmission_bandwidth_asymmetric {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 852, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        let mut optionals = BitString::new();
        optionals.push(num_ies != 0);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.nr_freq_info.encode(data)?;
        self.transmission_bandwidth.encode(data)?;
        if num_ies != 0 {
            encode::encode_length_determinent(data, Some(1), Some(65535), false, num_ies)?;
            data.append_aligned(ies);
        }
        Ok(())
    }
}

impl PerCodec for TddInfo {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        TddInfo::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TddInfo");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TddInfo");
            e
        })
    }
}
// TddInfoRel16
#[derive(Clone, Debug)]
pub struct TddInfoRel16 {
    pub tdd_freq_info: Option<FreqInfoRel16>,
    pub sul_freq_info: Option<FreqInfoRel16>,
    pub tdd_ul_dl_config_common_nr: Option<TddUlDlConfigCommonNr>,
}

impl TddInfoRel16 {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 4)?;
        let tdd_freq_info = if optionals[0] {
            Some(FreqInfoRel16::decode(data)?)
        } else {
            None
        };
        let sul_freq_info = if optionals[1] {
            Some(FreqInfoRel16::decode(data)?)
        } else {
            None
        };
        let tdd_ul_dl_config_common_nr = if optionals[2] {
            Some(TddUlDlConfigCommonNr::decode(data)?)
        } else {
            None
        };

        // Process the extension container

        if optionals[3] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            tdd_freq_info,
            sul_freq_info,
            tdd_ul_dl_config_common_nr,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.tdd_freq_info.is_some());
        optionals.push(self.sul_freq_info.is_some());
        optionals.push(self.tdd_ul_dl_config_common_nr.is_some());
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        if let Some(x) = &self.tdd_freq_info {
            x.encode(data)?;
        }
        if let Some(x) = &self.sul_freq_info {
            x.encode(data)?;
        }
        if let Some(x) = &self.tdd_ul_dl_config_common_nr {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl PerCodec for TddInfoRel16 {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        TddInfoRel16::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TddInfoRel16");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TddInfoRel16");
            e
        })
    }
}
// TddUlDlConfigCommonNr
#[derive(Clone, Debug)]
pub struct TddUlDlConfigCommonNr(pub Vec<u8>);

impl TddUlDlConfigCommonNr {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(decode::decode_octetstring(data, None, None, false)?))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_octetstring(data, None, None, false, &self.0, false)
    }
}

impl PerCodec for TddUlDlConfigCommonNr {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        TddUlDlConfigCommonNr::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TddUlDlConfigCommonNr");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TddUlDlConfigCommonNr");
            e
        })
    }
}
// TrptegInformation
#[derive(Clone, Debug)]
pub enum TrptegInformation {
    RxTxTeg(RxTxTeg),
    RxTeg(RxTeg),
}

impl TrptegInformation {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_choice_idx(data, 0, 2, false)?;
        if extended {
            return Err(per_codec_error_new("CHOICE additions not implemented"));
        }
        match idx {
            0 => Ok(Self::RxTxTeg(RxTxTeg::decode(data)?)),
            1 => Ok(Self::RxTeg(RxTeg::decode(data)?)),
            2 => {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _ = Criticality::decode(data)?;
                let _ = decode::decode_length_determinent(data, None, None, false)?;
                let result = match id {
                    x => Err(per_codec_error_new(format!("Unrecognised IE type {}", x))),
                };
                data.decode_align()?;
                result
            }
            _ => Err(per_codec_error_new("Unknown choice idx")),
        }
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        match self {
            Self::RxTxTeg(x) => {
                encode::encode_choice_idx(data, 0, 2, false, 0, false)?;
                x.encode(data)
            }
            Self::RxTeg(x) => {
                encode::encode_choice_idx(data, 0, 2, false, 1, false)?;
                x.encode(data)
            }
        }
    }
}

impl PerCodec for TrptegInformation {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        TrptegInformation::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TrptegInformation");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TrptegInformation");
            e
        })
    }
}
// RxTxTeg
#[derive(Clone, Debug)]
pub struct RxTxTeg {
    pub trp_rx_tx_teg_information: TrpRxTxTegInformation,
    pub trp_tx_teg_information: Option<TrpTxTegInformation>,
}

impl RxTxTeg {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 2)?;
        let trp_rx_tx_teg_information = TrpRxTxTegInformation::decode(data)?;
        let trp_tx_teg_information = if optionals[0] {
            Some(TrpTxTegInformation::decode(data)?)
        } else {
            None
        };

        // Process the extension container

        if optionals[1] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            trp_rx_tx_teg_information,
            trp_tx_teg_information,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.trp_tx_teg_information.is_some());
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.trp_rx_tx_teg_information.encode(data)?;
        if let Some(x) = &self.trp_tx_teg_information {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl PerCodec for RxTxTeg {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        RxTxTeg::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("RxTxTeg");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("RxTxTeg");
            e
        })
    }
}
// RxTeg
#[derive(Clone, Debug)]
pub struct RxTeg {
    pub trp_rx_teg_information: TrpRxTegInformation,
    pub trp_tx_teg_information: TrpTxTegInformation,
}

impl RxTeg {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let trp_rx_teg_information = TrpRxTegInformation::decode(data)?;
        let trp_tx_teg_information = TrpTxTegInformation::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            trp_rx_teg_information,
            trp_tx_teg_information,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.trp_rx_teg_information.encode(data)?;
        self.trp_tx_teg_information.encode(data)?;

        Ok(())
    }
}

impl PerCodec for RxTeg {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        RxTeg::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("RxTeg");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("RxTeg");
            e
        })
    }
}
// TimeReferenceInformation
#[derive(Clone, Debug)]
pub struct TimeReferenceInformation {
    pub reference_time: ReferenceTime,
    pub reference_sfn: ReferenceSfn,
    pub uncertainty: Option<Uncertainty>,
    pub time_information_type: Option<TimeInformationType>,
}

impl TimeReferenceInformation {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, false, 3)?;
        let reference_time = ReferenceTime::decode(data)?;
        let reference_sfn = ReferenceSfn::decode(data)?;
        let uncertainty = if optionals[0] {
            Some(Uncertainty::decode(data)?)
        } else {
            None
        };
        let time_information_type = if optionals[1] {
            Some(TimeInformationType::decode(data)?)
        } else {
            None
        };

        // Process the extension container

        if optionals[2] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            reference_time,
            reference_sfn,
            uncertainty,
            time_information_type,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.uncertainty.is_some());
        optionals.push(self.time_information_type.is_some());
        optionals.push(false);

        encode::encode_sequence_header(data, false, &optionals, false)?;
        self.reference_time.encode(data)?;
        self.reference_sfn.encode(data)?;
        if let Some(x) = &self.uncertainty {
            x.encode(data)?;
        }
        if let Some(x) = &self.time_information_type {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl PerCodec for TimeReferenceInformation {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        TimeReferenceInformation::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TimeReferenceInformation");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TimeReferenceInformation");
            e
        })
    }
}
// TimeInformationType
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum TimeInformationType {
    LocalClock,
}

impl TimeInformationType {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(0), false)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(0),
            false,
            *self as i128,
            (*self as u32) >= 1,
        )
    }
}

impl PerCodec for TimeInformationType {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        TimeInformationType::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TimeInformationType");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TimeInformationType");
            e
        })
    }
}
// TimeStamp
#[derive(Clone, Debug)]
pub struct TimeStamp {
    pub system_frame_number: SystemFrameNumber,
    pub slot_index: TimeStampSlotIndex,
    pub measurement_time: Option<RelativeTime1900>,
    pub symbol_index: Option<SymbolIndex>,
}

impl TimeStamp {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, false, 2)?;
        let system_frame_number = SystemFrameNumber::decode(data)?;
        let slot_index = TimeStampSlotIndex::decode(data)?;
        let measurement_time = if optionals[0] {
            Some(RelativeTime1900::decode(data)?)
        } else {
            None
        };

        // Process the extension container
        let mut symbol_index: Option<SymbolIndex> = None;

        if optionals[1] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    814 => symbol_index = Some(SymbolIndex::decode(data)?),
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            system_frame_number,
            slot_index,
            measurement_time,
            symbol_index,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();
        if let Some(x) = &self.symbol_index {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 814, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        let mut optionals = BitString::new();
        optionals.push(self.measurement_time.is_some());
        optionals.push(num_ies != 0);

        encode::encode_sequence_header(data, false, &optionals, false)?;
        self.system_frame_number.encode(data)?;
        self.slot_index.encode(data)?;
        if let Some(x) = &self.measurement_time {
            x.encode(data)?;
        }
        if num_ies != 0 {
            encode::encode_length_determinent(data, Some(1), Some(65535), false, num_ies)?;
            data.append_aligned(ies);
        }
        Ok(())
    }
}

impl PerCodec for TimeStamp {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        TimeStamp::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TimeStamp");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TimeStamp");
            e
        })
    }
}
// TimeStampSlotIndex
#[derive(Clone, Debug)]
pub enum TimeStampSlotIndex {
    Scs15(u8),
    Scs30(u8),
    Scs60(u8),
    Scs120(u8),
    Scs480(Scs480),
    Scs960(Scs960),
}

impl TimeStampSlotIndex {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_choice_idx(data, 0, 4, false)?;
        if extended {
            return Err(per_codec_error_new("CHOICE additions not implemented"));
        }
        match idx {
            0 => Ok(Self::Scs15(
                decode::decode_integer(data, Some(0), Some(9), false)?.0 as u8,
            )),
            1 => Ok(Self::Scs30(
                decode::decode_integer(data, Some(0), Some(19), false)?.0 as u8,
            )),
            2 => Ok(Self::Scs60(
                decode::decode_integer(data, Some(0), Some(39), false)?.0 as u8,
            )),
            3 => Ok(Self::Scs120(
                decode::decode_integer(data, Some(0), Some(79), false)?.0 as u8,
            )),
            4 => {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _ = Criticality::decode(data)?;
                let _ = decode::decode_length_determinent(data, None, None, false)?;
                let result = match id {
                    661 => Ok(Self::Scs480(Scs480::decode(data)?)),
                    662 => Ok(Self::Scs960(Scs960::decode(data)?)),
                    x => Err(per_codec_error_new(format!("Unrecognised IE type {}", x))),
                };
                data.decode_align()?;
                result
            }
            _ => Err(per_codec_error_new("Unknown choice idx")),
        }
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        match self {
            Self::Scs15(x) => {
                encode::encode_choice_idx(data, 0, 4, false, 0, false)?;
                encode::encode_integer(data, Some(0), Some(9), false, *x as i128, false)
            }
            Self::Scs30(x) => {
                encode::encode_choice_idx(data, 0, 4, false, 1, false)?;
                encode::encode_integer(data, Some(0), Some(19), false, *x as i128, false)
            }
            Self::Scs60(x) => {
                encode::encode_choice_idx(data, 0, 4, false, 2, false)?;
                encode::encode_integer(data, Some(0), Some(39), false, *x as i128, false)
            }
            Self::Scs120(x) => {
                encode::encode_choice_idx(data, 0, 4, false, 3, false)?;
                encode::encode_integer(data, Some(0), Some(79), false, *x as i128, false)
            }
            Self::Scs480(x) => {
                encode::encode_choice_idx(data, 0, 4, false, 4, false)?;
                encode::encode_integer(data, Some(0), Some(65535), false, 661, false)?;
                Criticality::Reject.encode(data)?;
                let ie = &mut Allocator::new_codec_data();
                x.encode(ie)?;
                encode::encode_length_determinent(data, None, None, false, ie.length_in_bytes())?;
                Ok(data.append_aligned(ie))
            }
            Self::Scs960(x) => {
                encode::encode_choice_idx(data, 0, 4, false, 4, false)?;
                encode::encode_integer(data, Some(0), Some(65535), false, 662, false)?;
                Criticality::Reject.encode(data)?;
                let ie = &mut Allocator::new_codec_data();
                x.encode(ie)?;
                encode::encode_length_determinent(data, None, None, false, ie.length_in_bytes())?;
                Ok(data.append_aligned(ie))
            }
        }
    }
}

impl PerCodec for TimeStampSlotIndex {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        TimeStampSlotIndex::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TimeStampSlotIndex");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TimeStampSlotIndex");
            e
        })
    }
}
// TimeToWait
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum TimeToWait {
    V1s,
    V2s,
    V5s,
    V10s,
    V20s,
    V60s,
}

impl TimeToWait {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(5), true)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(5),
            true,
            *self as i128,
            (*self as u32) >= 6,
        )
    }
}

impl PerCodec for TimeToWait {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        TimeToWait::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TimeToWait");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TimeToWait");
            e
        })
    }
}
// TimingErrorMargin
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum TimingErrorMargin {
    M0Tc,
    M2Tc,
    M4Tc,
    M6Tc,
    M8Tc,
    M12Tc,
    M16Tc,
    M20Tc,
    M24Tc,
    M32Tc,
    M40Tc,
    M48Tc,
    M56Tc,
    M64Tc,
    M72Tc,
    M80Tc,
}

impl TimingErrorMargin {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(15), true)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(15),
            true,
            *self as i128,
            (*self as u32) >= 16,
        )
    }
}

impl PerCodec for TimingErrorMargin {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        TimingErrorMargin::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TimingErrorMargin");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TimingErrorMargin");
            e
        })
    }
}
// TimingMeasurementQuality
#[derive(Clone, Debug)]
pub struct TimingMeasurementQuality {
    pub measurement_quality: u8,
    pub resolution: Resolution1,
}

impl TimingMeasurementQuality {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, false, 1)?;
        let measurement_quality = decode::decode_integer(data, Some(0), Some(31), false)?.0 as u8;
        let resolution = Resolution1::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            measurement_quality,
            resolution,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, false, &optionals, false)?;
        encode::encode_integer(
            data,
            Some(0),
            Some(31),
            false,
            self.measurement_quality as i128,
            false,
        )?;
        self.resolution.encode(data)?;

        Ok(())
    }
}

impl PerCodec for TimingMeasurementQuality {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        TimingMeasurementQuality::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TimingMeasurementQuality");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TimingMeasurementQuality");
            e
        })
    }
}
// TimingReportingGranularityFactorExtended
#[derive(Clone, Copy, Debug)]
pub struct TimingReportingGranularityFactorExtended(pub i8);

impl TimingReportingGranularityFactorExtended {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(
            decode::decode_integer(data, Some(-6), Some(-1), true)?.0 as i8,
        ))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_integer(data, Some(-6), Some(-1), true, self.0 as i128, false)
    }
}

impl PerCodec for TimingReportingGranularityFactorExtended {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        TimingReportingGranularityFactorExtended::decode_inner(data).map_err(
            |mut e: PerCodecError| {
                e.push_context("TimingReportingGranularityFactorExtended");
                e
            },
        )
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TimingReportingGranularityFactorExtended");
            e
        })
    }
}
// TimeWindowStart
#[derive(Clone, Debug)]
pub struct TimeWindowStart {
    pub system_frame_number: SystemFrameNumber,
    pub slot_number: SlotNumber,
    pub symbol_index: u8,
}

impl TimeWindowStart {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let system_frame_number = SystemFrameNumber::decode(data)?;
        let slot_number = SlotNumber::decode(data)?;
        let symbol_index = decode::decode_integer(data, Some(0), Some(13), false)?.0 as u8;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            system_frame_number,
            slot_number,
            symbol_index,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.system_frame_number.encode(data)?;
        self.slot_number.encode(data)?;
        encode::encode_integer(
            data,
            Some(0),
            Some(13),
            false,
            self.symbol_index as i128,
            false,
        )?;

        Ok(())
    }
}

impl PerCodec for TimeWindowStart {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        TimeWindowStart::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TimeWindowStart");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TimeWindowStart");
            e
        })
    }
}
// TimeWindowInformationMeasurementList
#[derive(Clone, Debug)]
pub struct TimeWindowInformationMeasurementList(pub NonEmpty<TimeWindowInformationMeasurementItem>);

impl TimeWindowInformationMeasurementList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(16), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(TimeWindowInformationMeasurementItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(16), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for TimeWindowInformationMeasurementList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        TimeWindowInformationMeasurementList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TimeWindowInformationMeasurementList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TimeWindowInformationMeasurementList");
            e
        })
    }
}
// TimeWindowInformationMeasurementItem
#[derive(Clone, Debug)]
pub struct TimeWindowInformationMeasurementItem {
    pub time_window_duration_measurement: TimeWindowDurationMeasurement,
    pub time_window_type: TimeWindowType,
    pub time_window_periodicity_measurement: Option<TimeWindowPeriodicityMeasurement>,
    pub time_window_start: TimeWindowStart,
}

impl TimeWindowInformationMeasurementItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 2)?;
        let time_window_duration_measurement = TimeWindowDurationMeasurement::decode(data)?;
        let time_window_type = TimeWindowType::decode(data)?;
        let time_window_periodicity_measurement = if optionals[0] {
            Some(TimeWindowPeriodicityMeasurement::decode(data)?)
        } else {
            None
        };
        let time_window_start = TimeWindowStart::decode(data)?;

        // Process the extension container

        if optionals[1] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            time_window_duration_measurement,
            time_window_type,
            time_window_periodicity_measurement,
            time_window_start,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.time_window_periodicity_measurement.is_some());
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.time_window_duration_measurement.encode(data)?;
        self.time_window_type.encode(data)?;
        if let Some(x) = &self.time_window_periodicity_measurement {
            x.encode(data)?;
        }
        self.time_window_start.encode(data)?;

        Ok(())
    }
}

impl PerCodec for TimeWindowInformationMeasurementItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        TimeWindowInformationMeasurementItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TimeWindowInformationMeasurementItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TimeWindowInformationMeasurementItem");
            e
        })
    }
}
// TimeWindowInformationSrsList
#[derive(Clone, Debug)]
pub struct TimeWindowInformationSrsList(pub NonEmpty<TimeWindowInformationSrsItem>);

impl TimeWindowInformationSrsList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(16), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(TimeWindowInformationSrsItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(16), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for TimeWindowInformationSrsList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        TimeWindowInformationSrsList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TimeWindowInformationSrsList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TimeWindowInformationSrsList");
            e
        })
    }
}
// TimeWindowInformationSrsItem
#[derive(Clone, Debug)]
pub struct TimeWindowInformationSrsItem {
    pub time_window_start_srs: TimeWindowStartSrs,
    pub time_window_duration_srs: TimeWindowDurationSrs,
    pub time_window_type: TimeWindowType1,
    pub time_window_periodicity_srs: Option<TimeWindowPeriodicitySrs>,
}

impl TimeWindowInformationSrsItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 2)?;
        let time_window_start_srs = TimeWindowStartSrs::decode(data)?;
        let time_window_duration_srs = TimeWindowDurationSrs::decode(data)?;
        let time_window_type = TimeWindowType1::decode(data)?;
        let time_window_periodicity_srs = if optionals[0] {
            Some(TimeWindowPeriodicitySrs::decode(data)?)
        } else {
            None
        };

        // Process the extension container

        if optionals[1] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            time_window_start_srs,
            time_window_duration_srs,
            time_window_type,
            time_window_periodicity_srs,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.time_window_periodicity_srs.is_some());
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.time_window_start_srs.encode(data)?;
        self.time_window_duration_srs.encode(data)?;
        self.time_window_type.encode(data)?;
        if let Some(x) = &self.time_window_periodicity_srs {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl PerCodec for TimeWindowInformationSrsItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        TimeWindowInformationSrsItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TimeWindowInformationSrsItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TimeWindowInformationSrsItem");
            e
        })
    }
}
// TimeWindowDurationMeasurement
#[derive(Clone, Debug)]
pub enum TimeWindowDurationMeasurement {
    DurationSlots(DurationSlots),
}

impl TimeWindowDurationMeasurement {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_choice_idx(data, 0, 1, false)?;
        if extended {
            return Err(per_codec_error_new("CHOICE additions not implemented"));
        }
        match idx {
            0 => Ok(Self::DurationSlots(DurationSlots::decode(data)?)),
            1 => {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _ = Criticality::decode(data)?;
                let _ = decode::decode_length_determinent(data, None, None, false)?;
                let result = match id {
                    x => Err(per_codec_error_new(format!("Unrecognised IE type {}", x))),
                };
                data.decode_align()?;
                result
            }
            _ => Err(per_codec_error_new("Unknown choice idx")),
        }
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        match self {
            Self::DurationSlots(x) => {
                encode::encode_choice_idx(data, 0, 1, false, 0, false)?;
                x.encode(data)
            }
        }
    }
}

impl PerCodec for TimeWindowDurationMeasurement {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        TimeWindowDurationMeasurement::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TimeWindowDurationMeasurement");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TimeWindowDurationMeasurement");
            e
        })
    }
}
// TimeWindowDurationSrs
#[derive(Clone, Debug)]
pub enum TimeWindowDurationSrs {
    DurationSymbols(DurationSymbols),
    DurationSlots(DurationSlots1),
}

impl TimeWindowDurationSrs {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_choice_idx(data, 0, 2, false)?;
        if extended {
            return Err(per_codec_error_new("CHOICE additions not implemented"));
        }
        match idx {
            0 => Ok(Self::DurationSymbols(DurationSymbols::decode(data)?)),
            1 => Ok(Self::DurationSlots(DurationSlots1::decode(data)?)),
            2 => {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _ = Criticality::decode(data)?;
                let _ = decode::decode_length_determinent(data, None, None, false)?;
                let result = match id {
                    x => Err(per_codec_error_new(format!("Unrecognised IE type {}", x))),
                };
                data.decode_align()?;
                result
            }
            _ => Err(per_codec_error_new("Unknown choice idx")),
        }
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        match self {
            Self::DurationSymbols(x) => {
                encode::encode_choice_idx(data, 0, 2, false, 0, false)?;
                x.encode(data)
            }
            Self::DurationSlots(x) => {
                encode::encode_choice_idx(data, 0, 2, false, 1, false)?;
                x.encode(data)
            }
        }
    }
}

impl PerCodec for TimeWindowDurationSrs {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        TimeWindowDurationSrs::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TimeWindowDurationSrs");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TimeWindowDurationSrs");
            e
        })
    }
}
// TimeWindowPeriodicityMeasurement
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum TimeWindowPeriodicityMeasurement {
    Ms160,
    Ms320,
    Ms640,
    Ms1280,
    Ms2560,
    Ms5120,
    Ms10240,
    Ms20480,
    Ms40960,
    Ms61440,
    Ms81920,
    Ms368640,
    Ms737280,
    Ms1843200,
}

impl TimeWindowPeriodicityMeasurement {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(13), true)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(13),
            true,
            *self as i128,
            (*self as u32) >= 14,
        )
    }
}

impl PerCodec for TimeWindowPeriodicityMeasurement {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        TimeWindowPeriodicityMeasurement::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TimeWindowPeriodicityMeasurement");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TimeWindowPeriodicityMeasurement");
            e
        })
    }
}
// TimeWindowPeriodicitySrs
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum TimeWindowPeriodicitySrs {
    Ms0dot125,
    Ms0dot25,
    Ms0dot5,
    Ms0dot625,
    Ms1,
    Ms1dot25,
    Ms2,
    Ms2dot5,
    Ms4,
    Ms5,
    Ms8,
    Ms10,
    Ms16,
    Ms20,
    Ms32,
    Ms40,
    Ms64,
    Ms80,
    Ms160,
    Ms320,
    Ms640,
    Ms1280,
    Ms2560,
    Ms5120,
    Ms10240,
}

impl TimeWindowPeriodicitySrs {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(24), true)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(24),
            true,
            *self as i128,
            (*self as u32) >= 25,
        )
    }
}

impl PerCodec for TimeWindowPeriodicitySrs {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        TimeWindowPeriodicitySrs::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TimeWindowPeriodicitySrs");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TimeWindowPeriodicitySrs");
            e
        })
    }
}
// TimeWindowStartSrs
#[derive(Clone, Debug)]
pub struct TimeWindowStartSrs {
    pub system_frame_number: SystemFrameNumber,
    pub slot_number: SlotNumber,
    pub symbol_index: SymbolIndex,
}

impl TimeWindowStartSrs {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let system_frame_number = SystemFrameNumber::decode(data)?;
        let slot_number = SlotNumber::decode(data)?;
        let symbol_index = SymbolIndex::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            system_frame_number,
            slot_number,
            symbol_index,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.system_frame_number.encode(data)?;
        self.slot_number.encode(data)?;
        self.symbol_index.encode(data)?;

        Ok(())
    }
}

impl PerCodec for TimeWindowStartSrs {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        TimeWindowStartSrs::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TimeWindowStartSrs");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TimeWindowStartSrs");
            e
        })
    }
}
// Tmgi
#[derive(Clone, Debug)]
pub struct Tmgi(pub [u8; 6]);

impl Tmgi {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(
            decode::decode_octetstring(data, Some(6), Some(6), false)?
                .try_into()
                .unwrap(),
        ))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_octetstring(data, Some(6), Some(6), false, &(self.0).into(), false)
    }
}

impl PerCodec for Tmgi {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Tmgi::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("Tmgi");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("Tmgi");
            e
        })
    }
}
// TnlAssociationUsage
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum TnlAssociationUsage {
    Ue,
    NonUe,
    Both,
}

impl TnlAssociationUsage {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(2), true)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(2),
            true,
            *self as i128,
            (*self as u32) >= 3,
        )
    }
}

impl PerCodec for TnlAssociationUsage {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        TnlAssociationUsage::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TnlAssociationUsage");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TnlAssociationUsage");
            e
        })
    }
}
// TnlCapacityIndicator
#[derive(Clone, Debug)]
pub struct TnlCapacityIndicator {
    pub dltnl_offered_capacity: u32,
    pub dltnl_available_capacity: u8,
    pub ultnl_offered_capacity: u32,
    pub ultnl_available_capacity: u8,
}

impl TnlCapacityIndicator {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, false, 1)?;
        let dltnl_offered_capacity =
            decode::decode_integer(data, Some(1), Some(16777216), true)?.0 as u32;
        let dltnl_available_capacity =
            decode::decode_integer(data, Some(0), Some(100), true)?.0 as u8;
        let ultnl_offered_capacity =
            decode::decode_integer(data, Some(1), Some(16777216), true)?.0 as u32;
        let ultnl_available_capacity =
            decode::decode_integer(data, Some(0), Some(100), true)?.0 as u8;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            dltnl_offered_capacity,
            dltnl_available_capacity,
            ultnl_offered_capacity,
            ultnl_available_capacity,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, false, &optionals, false)?;
        encode::encode_integer(
            data,
            Some(1),
            Some(16777216),
            true,
            self.dltnl_offered_capacity as i128,
            false,
        )?;
        encode::encode_integer(
            data,
            Some(0),
            Some(100),
            true,
            self.dltnl_available_capacity as i128,
            false,
        )?;
        encode::encode_integer(
            data,
            Some(1),
            Some(16777216),
            true,
            self.ultnl_offered_capacity as i128,
            false,
        )?;
        encode::encode_integer(
            data,
            Some(0),
            Some(100),
            true,
            self.ultnl_available_capacity as i128,
            false,
        )?;

        Ok(())
    }
}

impl PerCodec for TnlCapacityIndicator {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        TnlCapacityIndicator::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TnlCapacityIndicator");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TnlCapacityIndicator");
            e
        })
    }
}
// TraceActivation
#[derive(Clone, Debug)]
pub struct TraceActivation {
    pub trace_id: TraceId,
    pub interfaces_to_trace: InterfacesToTrace,
    pub trace_depth: TraceDepth,
    pub trace_collection_entity_ip_address: TransportLayerAddress,
    pub mdt_configuration: Option<MdtConfiguration>,
    pub trace_collection_entity_uri: Option<UriAddress>,
}

impl TraceActivation {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, false, 1)?;
        let trace_id = TraceId::decode(data)?;
        let interfaces_to_trace = InterfacesToTrace::decode(data)?;
        let trace_depth = TraceDepth::decode(data)?;
        let trace_collection_entity_ip_address = TransportLayerAddress::decode(data)?;

        // Process the extension container
        let mut mdt_configuration: Option<MdtConfiguration> = None;
        let mut trace_collection_entity_uri: Option<UriAddress> = None;

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    381 => mdt_configuration = Some(MdtConfiguration::decode(data)?),
                    380 => trace_collection_entity_uri = Some(UriAddress::decode(data)?),
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            trace_id,
            interfaces_to_trace,
            trace_depth,
            trace_collection_entity_ip_address,
            mdt_configuration,
            trace_collection_entity_uri,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();
        if let Some(x) = &self.mdt_configuration {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 381, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.trace_collection_entity_uri {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 380, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        let mut optionals = BitString::new();
        optionals.push(num_ies != 0);

        encode::encode_sequence_header(data, false, &optionals, false)?;
        self.trace_id.encode(data)?;
        self.interfaces_to_trace.encode(data)?;
        self.trace_depth.encode(data)?;
        self.trace_collection_entity_ip_address.encode(data)?;
        if num_ies != 0 {
            encode::encode_length_determinent(data, Some(1), Some(65535), false, num_ies)?;
            data.append_aligned(ies);
        }
        Ok(())
    }
}

impl PerCodec for TraceActivation {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        TraceActivation::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TraceActivation");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TraceActivation");
            e
        })
    }
}
// TraceDepth
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum TraceDepth {
    Minimum,
    Medium,
    Maximum,
    MinimumWithoutVendorSpecificExtension,
    MediumWithoutVendorSpecificExtension,
    MaximumWithoutVendorSpecificExtension,
}

impl TraceDepth {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(5), true)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(5),
            true,
            *self as i128,
            (*self as u32) >= 6,
        )
    }
}

impl PerCodec for TraceDepth {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        TraceDepth::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TraceDepth");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TraceDepth");
            e
        })
    }
}
// TraceId
#[derive(Clone, Debug)]
pub struct TraceId(pub [u8; 8]);

impl TraceId {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(
            decode::decode_octetstring(data, Some(8), Some(8), false)?
                .try_into()
                .unwrap(),
        ))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_octetstring(data, Some(8), Some(8), false, &(self.0).into(), false)
    }
}

impl PerCodec for TraceId {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        TraceId::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TraceId");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TraceId");
            e
        })
    }
}
// TrafficMappingInfo
#[derive(Clone, Debug)]
pub enum TrafficMappingInfo {
    IPtolayer2TrafficMappingInfo(IPtolayer2TrafficMappingInfo),
    BaPlayerBhrlCchannelMappingInfo(BaPlayerBhrlCchannelMappingInfo),
}

impl TrafficMappingInfo {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_choice_idx(data, 0, 2, false)?;
        if extended {
            return Err(per_codec_error_new("CHOICE additions not implemented"));
        }
        match idx {
            0 => Ok(Self::IPtolayer2TrafficMappingInfo(
                IPtolayer2TrafficMappingInfo::decode(data)?,
            )),
            1 => Ok(Self::BaPlayerBhrlCchannelMappingInfo(
                BaPlayerBhrlCchannelMappingInfo::decode(data)?,
            )),
            2 => {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _ = Criticality::decode(data)?;
                let _ = decode::decode_length_determinent(data, None, None, false)?;
                let result = match id {
                    x => Err(per_codec_error_new(format!("Unrecognised IE type {}", x))),
                };
                data.decode_align()?;
                result
            }
            _ => Err(per_codec_error_new("Unknown choice idx")),
        }
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        match self {
            Self::IPtolayer2TrafficMappingInfo(x) => {
                encode::encode_choice_idx(data, 0, 2, false, 0, false)?;
                x.encode(data)
            }
            Self::BaPlayerBhrlCchannelMappingInfo(x) => {
                encode::encode_choice_idx(data, 0, 2, false, 1, false)?;
                x.encode(data)
            }
        }
    }
}

impl PerCodec for TrafficMappingInfo {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        TrafficMappingInfo::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TrafficMappingInfo");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TrafficMappingInfo");
            e
        })
    }
}
// TransactionId
#[derive(Clone, Copy, Debug)]
pub struct TransactionId(pub u8);

impl TransactionId {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(
            decode::decode_integer(data, Some(0), Some(255), true)?.0 as u8,
        ))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_integer(data, Some(0), Some(255), true, self.0 as i128, false)
    }
}

impl PerCodec for TransactionId {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        TransactionId::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TransactionId");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TransactionId");
            e
        })
    }
}
// TransmissionBandwidth
#[derive(Clone, Debug)]
pub struct TransmissionBandwidth {
    pub nr_scs: NrScs,
    pub nr_nr_b: NrNrB,
}

impl TransmissionBandwidth {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let nr_scs = NrScs::decode(data)?;
        let nr_nr_b = NrNrB::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self { nr_scs, nr_nr_b })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.nr_scs.encode(data)?;
        self.nr_nr_b.encode(data)?;

        Ok(())
    }
}

impl PerCodec for TransmissionBandwidth {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        TransmissionBandwidth::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TransmissionBandwidth");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TransmissionBandwidth");
            e
        })
    }
}
// TransmissionBandwidthAsymmetric
#[derive(Clone, Debug)]
pub struct TransmissionBandwidthAsymmetric {
    pub ul_transmission_bandwidth: TransmissionBandwidth,
    pub dl_transmission_bandwidth: TransmissionBandwidth,
}

impl TransmissionBandwidthAsymmetric {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let ul_transmission_bandwidth = TransmissionBandwidth::decode(data)?;
        let dl_transmission_bandwidth = TransmissionBandwidth::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            ul_transmission_bandwidth,
            dl_transmission_bandwidth,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.ul_transmission_bandwidth.encode(data)?;
        self.dl_transmission_bandwidth.encode(data)?;

        Ok(())
    }
}

impl PerCodec for TransmissionBandwidthAsymmetric {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        TransmissionBandwidthAsymmetric::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TransmissionBandwidthAsymmetric");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TransmissionBandwidthAsymmetric");
            e
        })
    }
}
// TransmissionComb
#[derive(Clone, Debug)]
pub enum TransmissionComb {
    N2(N2),
    N4(N4),
    TransmissionCombn8(TransmissionCombn8),
}

impl TransmissionComb {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_choice_idx(data, 0, 2, false)?;
        if extended {
            return Err(per_codec_error_new("CHOICE additions not implemented"));
        }
        match idx {
            0 => Ok(Self::N2(N2::decode(data)?)),
            1 => Ok(Self::N4(N4::decode(data)?)),
            2 => {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _ = Criticality::decode(data)?;
                let _ = decode::decode_length_determinent(data, None, None, false)?;
                let result = match id {
                    706 => Ok(Self::TransmissionCombn8(TransmissionCombn8::decode(data)?)),
                    x => Err(per_codec_error_new(format!("Unrecognised IE type {}", x))),
                };
                data.decode_align()?;
                result
            }
            _ => Err(per_codec_error_new("Unknown choice idx")),
        }
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        match self {
            Self::N2(x) => {
                encode::encode_choice_idx(data, 0, 2, false, 0, false)?;
                x.encode(data)
            }
            Self::N4(x) => {
                encode::encode_choice_idx(data, 0, 2, false, 1, false)?;
                x.encode(data)
            }
            Self::TransmissionCombn8(x) => {
                encode::encode_choice_idx(data, 0, 2, false, 2, false)?;
                encode::encode_integer(data, Some(0), Some(65535), false, 706, false)?;
                Criticality::Reject.encode(data)?;
                let ie = &mut Allocator::new_codec_data();
                x.encode(ie)?;
                encode::encode_length_determinent(data, None, None, false, ie.length_in_bytes())?;
                Ok(data.append_aligned(ie))
            }
        }
    }
}

impl PerCodec for TransmissionComb {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        TransmissionComb::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TransmissionComb");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TransmissionComb");
            e
        })
    }
}
// TransmissionCombn8
#[derive(Clone, Debug)]
pub struct TransmissionCombn8 {
    pub comb_offset_n_8: u8,
    pub cyclic_shift_n_8: u8,
}

impl TransmissionCombn8 {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, false, 1)?;
        let comb_offset_n_8 = decode::decode_integer(data, Some(0), Some(7), false)?.0 as u8;
        let cyclic_shift_n_8 = decode::decode_integer(data, Some(0), Some(5), false)?.0 as u8;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            comb_offset_n_8,
            cyclic_shift_n_8,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, false, &optionals, false)?;
        encode::encode_integer(
            data,
            Some(0),
            Some(7),
            false,
            self.comb_offset_n_8 as i128,
            false,
        )?;
        encode::encode_integer(
            data,
            Some(0),
            Some(5),
            false,
            self.cyclic_shift_n_8 as i128,
            false,
        )?;

        Ok(())
    }
}

impl PerCodec for TransmissionCombn8 {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        TransmissionCombn8::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TransmissionCombn8");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TransmissionCombn8");
            e
        })
    }
}
// TransmissionCombPos
#[derive(Clone, Debug)]
pub enum TransmissionCombPos {
    N2(N2_1),
    N4(N4_1),
    N8(N8),
}

impl TransmissionCombPos {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_choice_idx(data, 0, 3, false)?;
        if extended {
            return Err(per_codec_error_new("CHOICE additions not implemented"));
        }
        match idx {
            0 => Ok(Self::N2(N2_1::decode(data)?)),
            1 => Ok(Self::N4(N4_1::decode(data)?)),
            2 => Ok(Self::N8(N8::decode(data)?)),
            3 => {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _ = Criticality::decode(data)?;
                let _ = decode::decode_length_determinent(data, None, None, false)?;
                let result = match id {
                    x => Err(per_codec_error_new(format!("Unrecognised IE type {}", x))),
                };
                data.decode_align()?;
                result
            }
            _ => Err(per_codec_error_new("Unknown choice idx")),
        }
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        match self {
            Self::N2(x) => {
                encode::encode_choice_idx(data, 0, 3, false, 0, false)?;
                x.encode(data)
            }
            Self::N4(x) => {
                encode::encode_choice_idx(data, 0, 3, false, 1, false)?;
                x.encode(data)
            }
            Self::N8(x) => {
                encode::encode_choice_idx(data, 0, 3, false, 2, false)?;
                x.encode(data)
            }
        }
    }
}

impl PerCodec for TransmissionCombPos {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        TransmissionCombPos::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TransmissionCombPos");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TransmissionCombPos");
            e
        })
    }
}
// TransmissionStopIndicator
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum TransmissionStopIndicator {
    True,
}

impl TransmissionStopIndicator {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(0), true)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(0),
            true,
            *self as i128,
            (*self as u32) >= 1,
        )
    }
}

impl PerCodec for TransmissionStopIndicator {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        TransmissionStopIndicator::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TransmissionStopIndicator");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TransmissionStopIndicator");
            e
        })
    }
}
// TransportUpLayerAddressInfoToAddList
#[derive(Clone, Debug)]
pub struct TransportUpLayerAddressInfoToAddList(pub NonEmpty<TransportUpLayerAddressInfoToAddItem>);

impl TransportUpLayerAddressInfoToAddList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(16), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(TransportUpLayerAddressInfoToAddItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(16), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for TransportUpLayerAddressInfoToAddList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        TransportUpLayerAddressInfoToAddList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TransportUpLayerAddressInfoToAddList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TransportUpLayerAddressInfoToAddList");
            e
        })
    }
}
// TransportUpLayerAddressInfoToAddItem
#[derive(Clone, Debug)]
pub struct TransportUpLayerAddressInfoToAddItem {
    pub ip_sec_transport_layer_address: TransportLayerAddress,
    pub gtp_transport_layer_address_to_add: Option<GtptlAs>,
}

impl TransportUpLayerAddressInfoToAddItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, false, 2)?;
        let ip_sec_transport_layer_address = TransportLayerAddress::decode(data)?;
        let gtp_transport_layer_address_to_add = if optionals[0] {
            Some(GtptlAs::decode(data)?)
        } else {
            None
        };

        // Process the extension container

        if optionals[1] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            ip_sec_transport_layer_address,
            gtp_transport_layer_address_to_add,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.gtp_transport_layer_address_to_add.is_some());
        optionals.push(false);

        encode::encode_sequence_header(data, false, &optionals, false)?;
        self.ip_sec_transport_layer_address.encode(data)?;
        if let Some(x) = &self.gtp_transport_layer_address_to_add {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl PerCodec for TransportUpLayerAddressInfoToAddItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        TransportUpLayerAddressInfoToAddItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TransportUpLayerAddressInfoToAddItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TransportUpLayerAddressInfoToAddItem");
            e
        })
    }
}
// TransportUpLayerAddressInfoToRemoveList
#[derive(Clone, Debug)]
pub struct TransportUpLayerAddressInfoToRemoveList(
    pub NonEmpty<TransportUpLayerAddressInfoToRemoveItem>,
);

impl TransportUpLayerAddressInfoToRemoveList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(16), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(TransportUpLayerAddressInfoToRemoveItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(16), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for TransportUpLayerAddressInfoToRemoveList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        TransportUpLayerAddressInfoToRemoveList::decode_inner(data).map_err(
            |mut e: PerCodecError| {
                e.push_context("TransportUpLayerAddressInfoToRemoveList");
                e
            },
        )
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TransportUpLayerAddressInfoToRemoveList");
            e
        })
    }
}
// TransportUpLayerAddressInfoToRemoveItem
#[derive(Clone, Debug)]
pub struct TransportUpLayerAddressInfoToRemoveItem {
    pub ip_sec_transport_layer_address: TransportLayerAddress,
    pub gtp_transport_layer_address_to_remove: Option<GtptlAs>,
}

impl TransportUpLayerAddressInfoToRemoveItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, false, 2)?;
        let ip_sec_transport_layer_address = TransportLayerAddress::decode(data)?;
        let gtp_transport_layer_address_to_remove = if optionals[0] {
            Some(GtptlAs::decode(data)?)
        } else {
            None
        };

        // Process the extension container

        if optionals[1] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            ip_sec_transport_layer_address,
            gtp_transport_layer_address_to_remove,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.gtp_transport_layer_address_to_remove.is_some());
        optionals.push(false);

        encode::encode_sequence_header(data, false, &optionals, false)?;
        self.ip_sec_transport_layer_address.encode(data)?;
        if let Some(x) = &self.gtp_transport_layer_address_to_remove {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl PerCodec for TransportUpLayerAddressInfoToRemoveItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        TransportUpLayerAddressInfoToRemoveItem::decode_inner(data).map_err(
            |mut e: PerCodecError| {
                e.push_context("TransportUpLayerAddressInfoToRemoveItem");
                e
            },
        )
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TransportUpLayerAddressInfoToRemoveItem");
            e
        })
    }
}
// TransmissionActionIndicator
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum TransmissionActionIndicator {
    Stop,
    Restart,
}

impl TransmissionActionIndicator {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(0), true)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(0),
            true,
            *self as i128,
            (*self as u32) >= 1,
        )
    }
}

impl PerCodec for TransmissionActionIndicator {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        TransmissionActionIndicator::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TransmissionActionIndicator");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TransmissionActionIndicator");
            e
        })
    }
}
// TrpBeamAntennaInformation
#[derive(Clone, Debug)]
pub struct TrpBeamAntennaInformation {
    pub choice_trp_beam_antenna_info_item: ChoiceTrpBeamAntennaInfoItem,
}

impl TrpBeamAntennaInformation {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let choice_trp_beam_antenna_info_item = ChoiceTrpBeamAntennaInfoItem::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            choice_trp_beam_antenna_info_item,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.choice_trp_beam_antenna_info_item.encode(data)?;

        Ok(())
    }
}

impl PerCodec for TrpBeamAntennaInformation {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        TrpBeamAntennaInformation::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TrpBeamAntennaInformation");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TrpBeamAntennaInformation");
            e
        })
    }
}
// ChoiceTrpBeamAntennaInfoItem
#[derive(Clone, Debug)]
pub enum ChoiceTrpBeamAntennaInfoItem {
    Reference(Trpid),
    Explicit(TrpBeamAntennaExplicitInformation),
    NoChange,
}

impl ChoiceTrpBeamAntennaInfoItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_choice_idx(data, 0, 3, false)?;
        if extended {
            return Err(per_codec_error_new("CHOICE additions not implemented"));
        }
        match idx {
            0 => Ok(Self::Reference(Trpid::decode(data)?)),
            1 => Ok(Self::Explicit(TrpBeamAntennaExplicitInformation::decode(
                data,
            )?)),
            2 => Ok(Self::NoChange),
            3 => {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _ = Criticality::decode(data)?;
                let _ = decode::decode_length_determinent(data, None, None, false)?;
                let result = match id {
                    x => Err(per_codec_error_new(format!("Unrecognised IE type {}", x))),
                };
                data.decode_align()?;
                result
            }
            _ => Err(per_codec_error_new("Unknown choice idx")),
        }
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        match self {
            Self::Reference(x) => {
                encode::encode_choice_idx(data, 0, 3, false, 0, false)?;
                x.encode(data)
            }
            Self::Explicit(x) => {
                encode::encode_choice_idx(data, 0, 3, false, 1, false)?;
                x.encode(data)
            }
            Self::NoChange => {
                encode::encode_choice_idx(data, 0, 3, false, 2, false)?;
                Ok(())
            }
        }
    }
}

impl PerCodec for ChoiceTrpBeamAntennaInfoItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        ChoiceTrpBeamAntennaInfoItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ChoiceTrpBeamAntennaInfoItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ChoiceTrpBeamAntennaInfoItem");
            e
        })
    }
}
// TrpBeamAntennaExplicitInformation
#[derive(Clone, Debug)]
pub struct TrpBeamAntennaExplicitInformation {
    pub trp_beam_antenna_angles: TrpBeamAntennaAngles,
    pub lcs_to_gcs_translation: Option<LcsToGcsTranslation>,
}

impl TrpBeamAntennaExplicitInformation {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 2)?;
        let trp_beam_antenna_angles = TrpBeamAntennaAngles::decode(data)?;
        let lcs_to_gcs_translation = if optionals[0] {
            Some(LcsToGcsTranslation::decode(data)?)
        } else {
            None
        };

        // Process the extension container

        if optionals[1] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            trp_beam_antenna_angles,
            lcs_to_gcs_translation,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.lcs_to_gcs_translation.is_some());
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.trp_beam_antenna_angles.encode(data)?;
        if let Some(x) = &self.lcs_to_gcs_translation {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl PerCodec for TrpBeamAntennaExplicitInformation {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        TrpBeamAntennaExplicitInformation::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TrpBeamAntennaExplicitInformation");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TrpBeamAntennaExplicitInformation");
            e
        })
    }
}
// TrpBeamAntennaAngles
#[derive(Clone, Debug)]
pub struct TrpBeamAntennaAngles(pub NonEmpty<TrpBeamAntennaAnglesListItem>);

impl TrpBeamAntennaAngles {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(3600), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(TrpBeamAntennaAnglesListItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(3600), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for TrpBeamAntennaAngles {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        TrpBeamAntennaAngles::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TrpBeamAntennaAngles");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TrpBeamAntennaAngles");
            e
        })
    }
}
// TrpBeamAntennaAnglesListItem
#[derive(Clone, Debug)]
pub struct TrpBeamAntennaAnglesListItem {
    pub trp_azimuth_angle: u16,
    pub trp_azimuth_angle_fine: Option<u8>,
    pub trp_elevation_angle_list: NonEmpty<TrpElevationAngleListItem>,
}

impl TrpBeamAntennaAnglesListItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 2)?;
        let trp_azimuth_angle = decode::decode_integer(data, Some(0), Some(359), false)?.0 as u16;
        let trp_azimuth_angle_fine = if optionals[0] {
            Some(decode::decode_integer(data, Some(0), Some(9), false)?.0 as u8)
        } else {
            None
        };
        let trp_elevation_angle_list = {
            let length = decode::decode_length_determinent(data, Some(1), Some(1801), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(TrpElevationAngleListItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        };

        // Process the extension container

        if optionals[1] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            trp_azimuth_angle,
            trp_azimuth_angle_fine,
            trp_elevation_angle_list,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.trp_azimuth_angle_fine.is_some());
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        encode::encode_integer(
            data,
            Some(0),
            Some(359),
            false,
            self.trp_azimuth_angle as i128,
            false,
        )?;
        if let Some(x) = &self.trp_azimuth_angle_fine {
            encode::encode_integer(data, Some(0), Some(9), false, *x as i128, false)?;
        }
        encode::encode_length_determinent(
            data,
            Some(1),
            Some(1801),
            false,
            self.trp_elevation_angle_list.len(),
        )?;
        for x in &self.trp_elevation_angle_list {
            x.encode(data)?;
        }
        Ok(())?;

        Ok(())
    }
}

impl PerCodec for TrpBeamAntennaAnglesListItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        TrpBeamAntennaAnglesListItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TrpBeamAntennaAnglesListItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TrpBeamAntennaAnglesListItem");
            e
        })
    }
}
// TrpElevationAngleListItem
#[derive(Clone, Debug)]
pub struct TrpElevationAngleListItem {
    pub trp_elevation_angle: u8,
    pub trp_elevation_angle_fine: Option<u8>,
    pub trp_beam_power_list: NonEmpty<TrpBeamPowerItem>,
}

impl TrpElevationAngleListItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 2)?;
        let trp_elevation_angle = decode::decode_integer(data, Some(0), Some(180), false)?.0 as u8;
        let trp_elevation_angle_fine = if optionals[0] {
            Some(decode::decode_integer(data, Some(0), Some(9), false)?.0 as u8)
        } else {
            None
        };
        let trp_beam_power_list = {
            let length = decode::decode_length_determinent(data, Some(2), Some(24), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(TrpBeamPowerItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        };

        // Process the extension container

        if optionals[1] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            trp_elevation_angle,
            trp_elevation_angle_fine,
            trp_beam_power_list,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.trp_elevation_angle_fine.is_some());
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        encode::encode_integer(
            data,
            Some(0),
            Some(180),
            false,
            self.trp_elevation_angle as i128,
            false,
        )?;
        if let Some(x) = &self.trp_elevation_angle_fine {
            encode::encode_integer(data, Some(0), Some(9), false, *x as i128, false)?;
        }
        encode::encode_length_determinent(
            data,
            Some(2),
            Some(24),
            false,
            self.trp_beam_power_list.len(),
        )?;
        for x in &self.trp_beam_power_list {
            x.encode(data)?;
        }
        Ok(())?;

        Ok(())
    }
}

impl PerCodec for TrpElevationAngleListItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        TrpElevationAngleListItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TrpElevationAngleListItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TrpElevationAngleListItem");
            e
        })
    }
}
// TrpBeamPowerItem
#[derive(Clone, Debug)]
pub struct TrpBeamPowerItem {
    pub prs_resource_set_id: Option<PrsResourceSetId>,
    pub prs_resource_id: PrsResourceId,
    pub relative_power: u8,
    pub relative_power_fine: Option<u8>,
}

impl TrpBeamPowerItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 3)?;
        let prs_resource_set_id = if optionals[0] {
            Some(PrsResourceSetId::decode(data)?)
        } else {
            None
        };
        let prs_resource_id = PrsResourceId::decode(data)?;
        let relative_power = decode::decode_integer(data, Some(0), Some(30), false)?.0 as u8;
        let relative_power_fine = if optionals[1] {
            Some(decode::decode_integer(data, Some(0), Some(9), false)?.0 as u8)
        } else {
            None
        };

        // Process the extension container

        if optionals[2] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            prs_resource_set_id,
            prs_resource_id,
            relative_power,
            relative_power_fine,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.prs_resource_set_id.is_some());
        optionals.push(self.relative_power_fine.is_some());
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        if let Some(x) = &self.prs_resource_set_id {
            x.encode(data)?;
        }
        self.prs_resource_id.encode(data)?;
        encode::encode_integer(
            data,
            Some(0),
            Some(30),
            false,
            self.relative_power as i128,
            false,
        )?;
        if let Some(x) = &self.relative_power_fine {
            encode::encode_integer(data, Some(0), Some(9), false, *x as i128, false)?;
        }

        Ok(())
    }
}

impl PerCodec for TrpBeamPowerItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        TrpBeamPowerItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TrpBeamPowerItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TrpBeamPowerItem");
            e
        })
    }
}
// Trpid
#[derive(Clone, Copy, Debug)]
pub struct Trpid(pub u16);

impl Trpid {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(
            decode::decode_integer(data, Some(0), Some(65535), true)?.0 as u16,
        ))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_integer(data, Some(0), Some(65535), true, self.0 as i128, false)
    }
}

impl PerCodec for Trpid {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Trpid::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("Trpid");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("Trpid");
            e
        })
    }
}
// TrpInformation
#[derive(Clone, Debug)]
pub struct TrpInformation {
    pub trpid: Trpid,
    pub trp_information_type_response_list: TrpInformationTypeResponseList,
    pub mobile_iab_mt_ue_id: Option<MobileIabMtUeId>,
}

impl TrpInformation {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, false, 1)?;
        let trpid = Trpid::decode(data)?;
        let trp_information_type_response_list = TrpInformationTypeResponseList::decode(data)?;

        // Process the extension container
        let mut mobile_iab_mt_ue_id: Option<MobileIabMtUeId> = None;

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    754 => mobile_iab_mt_ue_id = Some(MobileIabMtUeId::decode(data)?),
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            trpid,
            trp_information_type_response_list,
            mobile_iab_mt_ue_id,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();
        if let Some(x) = &self.mobile_iab_mt_ue_id {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 754, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        let mut optionals = BitString::new();
        optionals.push(num_ies != 0);

        encode::encode_sequence_header(data, false, &optionals, false)?;
        self.trpid.encode(data)?;
        self.trp_information_type_response_list.encode(data)?;
        if num_ies != 0 {
            encode::encode_length_determinent(data, Some(1), Some(65535), false, num_ies)?;
            data.append_aligned(ies);
        }
        Ok(())
    }
}

impl PerCodec for TrpInformation {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        TrpInformation::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TrpInformation");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TrpInformation");
            e
        })
    }
}
// TrpInformationItem
#[derive(Clone, Debug)]
pub struct TrpInformationItem {
    pub trp_information: TrpInformation,
}

impl TrpInformationItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, false, 1)?;
        let trp_information = TrpInformation::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self { trp_information })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, false, &optionals, false)?;
        self.trp_information.encode(data)?;

        Ok(())
    }
}

impl PerCodec for TrpInformationItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        TrpInformationItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TrpInformationItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TrpInformationItem");
            e
        })
    }
}
// TrpInformationTypeItem
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum TrpInformationTypeItem {
    NrPci,
    NgRanCgi,
    Arfcn,
    PrsConfig,
    SsbConfig,
    SfnInitTime,
    SpatialDirectInfo,
    GeoCoord,
    TrpType,
    OndemandPrs,
    TrpTxTeg,
    BeamAntennaInfo,
    MobileTrpLocationInfo,
}

impl TrpInformationTypeItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(7), true)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(7),
            true,
            *self as i128,
            (*self as u32) >= 8,
        )
    }
}

impl PerCodec for TrpInformationTypeItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        TrpInformationTypeItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TrpInformationTypeItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TrpInformationTypeItem");
            e
        })
    }
}
// TrpInformationTypeResponseList
#[derive(Clone, Debug)]
pub struct TrpInformationTypeResponseList(pub NonEmpty<TrpInformationTypeResponseItem>);

impl TrpInformationTypeResponseList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(64), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(TrpInformationTypeResponseItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(64), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for TrpInformationTypeResponseList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        TrpInformationTypeResponseList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TrpInformationTypeResponseList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TrpInformationTypeResponseList");
            e
        })
    }
}
// TrpInformationTypeResponseItem
#[derive(Clone, Debug)]
pub enum TrpInformationTypeResponseItem {
    PciNr(NrPci),
    NgRanCgi(NrCgi),
    NrArfcn(u32),
    PrsConfiguration(PrsConfiguration),
    SsBinformation(SsbInformation),
    SfnInitialisationTime(RelativeTime1900),
    SpatialDirectionInformation(SpatialDirectionInformation),
    GeographicalCoordinates(GeographicalCoordinates),
    TrpType(TrpType),
    OnDemandPrsInfo(OnDemandPrsInfo),
    TrpTxTegAssociation(TrpTxTegAssociation),
    TrpBeamAntennaInformation(TrpBeamAntennaInformation),
    MobileTrpLocationInformation(MobileTrpLocationInformation),
}

impl TrpInformationTypeResponseItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_choice_idx(data, 0, 8, false)?;
        if extended {
            return Err(per_codec_error_new("CHOICE additions not implemented"));
        }
        match idx {
            0 => Ok(Self::PciNr(NrPci::decode(data)?)),
            1 => Ok(Self::NgRanCgi(NrCgi::decode(data)?)),
            2 => Ok(Self::NrArfcn(
                decode::decode_integer(data, Some(0), Some(3279165), false)?.0 as u32,
            )),
            3 => Ok(Self::PrsConfiguration(PrsConfiguration::decode(data)?)),
            4 => Ok(Self::SsBinformation(SsbInformation::decode(data)?)),
            5 => Ok(Self::SfnInitialisationTime(RelativeTime1900::decode(data)?)),
            6 => Ok(Self::SpatialDirectionInformation(
                SpatialDirectionInformation::decode(data)?,
            )),
            7 => Ok(Self::GeographicalCoordinates(
                GeographicalCoordinates::decode(data)?,
            )),
            8 => {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _ = Criticality::decode(data)?;
                let _ = decode::decode_length_determinent(data, None, None, false)?;
                let result = match id {
                    434 => Ok(Self::TrpType(TrpType::decode(data)?)),
                    551 => Ok(Self::OnDemandPrsInfo(OnDemandPrsInfo::decode(data)?)),
                    566 => Ok(Self::TrpTxTegAssociation(TrpTxTegAssociation::decode(
                        data,
                    )?)),
                    577 => Ok(Self::TrpBeamAntennaInformation(
                        TrpBeamAntennaInformation::decode(data)?,
                    )),
                    753 => Ok(Self::MobileTrpLocationInformation(
                        MobileTrpLocationInformation::decode(data)?,
                    )),
                    x => Err(per_codec_error_new(format!("Unrecognised IE type {}", x))),
                };
                data.decode_align()?;
                result
            }
            _ => Err(per_codec_error_new("Unknown choice idx")),
        }
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        match self {
            Self::PciNr(x) => {
                encode::encode_choice_idx(data, 0, 8, false, 0, false)?;
                x.encode(data)
            }
            Self::NgRanCgi(x) => {
                encode::encode_choice_idx(data, 0, 8, false, 1, false)?;
                x.encode(data)
            }
            Self::NrArfcn(x) => {
                encode::encode_choice_idx(data, 0, 8, false, 2, false)?;
                encode::encode_integer(data, Some(0), Some(3279165), false, *x as i128, false)
            }
            Self::PrsConfiguration(x) => {
                encode::encode_choice_idx(data, 0, 8, false, 3, false)?;
                x.encode(data)
            }
            Self::SsBinformation(x) => {
                encode::encode_choice_idx(data, 0, 8, false, 4, false)?;
                x.encode(data)
            }
            Self::SfnInitialisationTime(x) => {
                encode::encode_choice_idx(data, 0, 8, false, 5, false)?;
                x.encode(data)
            }
            Self::SpatialDirectionInformation(x) => {
                encode::encode_choice_idx(data, 0, 8, false, 6, false)?;
                x.encode(data)
            }
            Self::GeographicalCoordinates(x) => {
                encode::encode_choice_idx(data, 0, 8, false, 7, false)?;
                x.encode(data)
            }
            Self::TrpType(x) => {
                encode::encode_choice_idx(data, 0, 8, false, 8, false)?;
                encode::encode_integer(data, Some(0), Some(65535), false, 434, false)?;
                Criticality::Reject.encode(data)?;
                let ie = &mut Allocator::new_codec_data();
                x.encode(ie)?;
                encode::encode_length_determinent(data, None, None, false, ie.length_in_bytes())?;
                Ok(data.append_aligned(ie))
            }
            Self::OnDemandPrsInfo(x) => {
                encode::encode_choice_idx(data, 0, 8, false, 8, false)?;
                encode::encode_integer(data, Some(0), Some(65535), false, 551, false)?;
                Criticality::Reject.encode(data)?;
                let ie = &mut Allocator::new_codec_data();
                x.encode(ie)?;
                encode::encode_length_determinent(data, None, None, false, ie.length_in_bytes())?;
                Ok(data.append_aligned(ie))
            }
            Self::TrpTxTegAssociation(x) => {
                encode::encode_choice_idx(data, 0, 8, false, 8, false)?;
                encode::encode_integer(data, Some(0), Some(65535), false, 566, false)?;
                Criticality::Reject.encode(data)?;
                let ie = &mut Allocator::new_codec_data();
                x.encode(ie)?;
                encode::encode_length_determinent(data, None, None, false, ie.length_in_bytes())?;
                Ok(data.append_aligned(ie))
            }
            Self::TrpBeamAntennaInformation(x) => {
                encode::encode_choice_idx(data, 0, 8, false, 8, false)?;
                encode::encode_integer(data, Some(0), Some(65535), false, 577, false)?;
                Criticality::Reject.encode(data)?;
                let ie = &mut Allocator::new_codec_data();
                x.encode(ie)?;
                encode::encode_length_determinent(data, None, None, false, ie.length_in_bytes())?;
                Ok(data.append_aligned(ie))
            }
            Self::MobileTrpLocationInformation(x) => {
                encode::encode_choice_idx(data, 0, 8, false, 8, false)?;
                encode::encode_integer(data, Some(0), Some(65535), false, 753, false)?;
                Criticality::Ignore.encode(data)?;
                let ie = &mut Allocator::new_codec_data();
                x.encode(ie)?;
                encode::encode_length_determinent(data, None, None, false, ie.length_in_bytes())?;
                Ok(data.append_aligned(ie))
            }
        }
    }
}

impl PerCodec for TrpInformationTypeResponseItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        TrpInformationTypeResponseItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TrpInformationTypeResponseItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TrpInformationTypeResponseItem");
            e
        })
    }
}
// TrpList
#[derive(Clone, Debug)]
pub struct TrpList(pub NonEmpty<TrpListItem>);

impl TrpList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(TrpListItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(65535), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for TrpList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        TrpList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TrpList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TrpList");
            e
        })
    }
}
// TrpListItem
#[derive(Clone, Debug)]
pub struct TrpListItem {
    pub trpid: Trpid,
}

impl TrpListItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, false, 1)?;
        let trpid = Trpid::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self { trpid })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, false, &optionals, false)?;
        self.trpid.encode(data)?;

        Ok(())
    }
}

impl PerCodec for TrpListItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        TrpListItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TrpListItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TrpListItem");
            e
        })
    }
}
// TrpMeasurementQuality
#[derive(Clone, Debug)]
pub struct TrpMeasurementQuality {
    pub tr_pmeasurement_quality_item: TrpMeasurementQualityItem,
}

impl TrpMeasurementQuality {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, false, 1)?;
        let tr_pmeasurement_quality_item = TrpMeasurementQualityItem::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            tr_pmeasurement_quality_item,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, false, &optionals, false)?;
        self.tr_pmeasurement_quality_item.encode(data)?;

        Ok(())
    }
}

impl PerCodec for TrpMeasurementQuality {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        TrpMeasurementQuality::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TrpMeasurementQuality");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TrpMeasurementQuality");
            e
        })
    }
}
// TrpMeasurementQualityItem
#[derive(Clone, Debug)]
pub enum TrpMeasurementQualityItem {
    TimingMeasurementQuality(TimingMeasurementQuality),
    AngleMeasurementQuality(AngleMeasurementQuality),
    PhaseQuality(PhaseQuality),
}

impl TrpMeasurementQualityItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_choice_idx(data, 0, 2, false)?;
        if extended {
            return Err(per_codec_error_new("CHOICE additions not implemented"));
        }
        match idx {
            0 => Ok(Self::TimingMeasurementQuality(
                TimingMeasurementQuality::decode(data)?,
            )),
            1 => Ok(Self::AngleMeasurementQuality(
                AngleMeasurementQuality::decode(data)?,
            )),
            2 => {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _ = Criticality::decode(data)?;
                let _ = decode::decode_length_determinent(data, None, None, false)?;
                let result = match id {
                    818 => Ok(Self::PhaseQuality(PhaseQuality::decode(data)?)),
                    x => Err(per_codec_error_new(format!("Unrecognised IE type {}", x))),
                };
                data.decode_align()?;
                result
            }
            _ => Err(per_codec_error_new("Unknown choice idx")),
        }
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        match self {
            Self::TimingMeasurementQuality(x) => {
                encode::encode_choice_idx(data, 0, 2, false, 0, false)?;
                x.encode(data)
            }
            Self::AngleMeasurementQuality(x) => {
                encode::encode_choice_idx(data, 0, 2, false, 1, false)?;
                x.encode(data)
            }
            Self::PhaseQuality(x) => {
                encode::encode_choice_idx(data, 0, 2, false, 2, false)?;
                encode::encode_integer(data, Some(0), Some(65535), false, 818, false)?;
                Criticality::Ignore.encode(data)?;
                let ie = &mut Allocator::new_codec_data();
                x.encode(ie)?;
                encode::encode_length_determinent(data, None, None, false, ie.length_in_bytes())?;
                Ok(data.append_aligned(ie))
            }
        }
    }
}

impl PerCodec for TrpMeasurementQualityItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        TrpMeasurementQualityItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TrpMeasurementQualityItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TrpMeasurementQualityItem");
            e
        })
    }
}
// PhaseQuality
#[derive(Clone, Debug)]
pub struct PhaseQuality {
    pub phase_quality_index: u8,
    pub phase_quality_resolution: PhaseQualityResolution,
}

impl PhaseQuality {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, false, 1)?;
        let phase_quality_index = decode::decode_integer(data, Some(0), Some(179), false)?.0 as u8;
        let phase_quality_resolution = PhaseQualityResolution::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            phase_quality_index,
            phase_quality_resolution,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, false, &optionals, false)?;
        encode::encode_integer(
            data,
            Some(0),
            Some(179),
            false,
            self.phase_quality_index as i128,
            false,
        )?;
        self.phase_quality_resolution.encode(data)?;

        Ok(())
    }
}

impl PerCodec for PhaseQuality {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PhaseQuality::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PhaseQuality");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PhaseQuality");
            e
        })
    }
}
// TrpMeasurementRequestList
#[derive(Clone, Debug)]
pub struct TrpMeasurementRequestList(pub NonEmpty<TrpMeasurementRequestItem>);

impl TrpMeasurementRequestList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(64), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(TrpMeasurementRequestItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(64), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for TrpMeasurementRequestList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        TrpMeasurementRequestList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TrpMeasurementRequestList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TrpMeasurementRequestList");
            e
        })
    }
}
// TrpMeasurementRequestItem
#[derive(Clone, Debug)]
pub struct TrpMeasurementRequestItem {
    pub trpid: Trpid,
    pub search_window_information: Option<SearchWindowInformation>,
    pub nr_cgi: Option<NrCgi>,
    pub ao_a_search_window: Option<AoAAssistanceInfo>,
    pub number_of_trp_rx_teg: Option<NumberOfTrpRxTeg>,
    pub number_of_trp_rx_tx_teg: Option<NumberOfTrpRxTxTeg>,
}

impl TrpMeasurementRequestItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, false, 2)?;
        let trpid = Trpid::decode(data)?;
        let search_window_information = if optionals[0] {
            Some(SearchWindowInformation::decode(data)?)
        } else {
            None
        };

        // Process the extension container
        let mut nr_cgi: Option<NrCgi> = None;
        let mut ao_a_search_window: Option<AoAAssistanceInfo> = None;
        let mut number_of_trp_rx_teg: Option<NumberOfTrpRxTeg> = None;
        let mut number_of_trp_rx_tx_teg: Option<NumberOfTrpRxTxTeg> = None;

        if optionals[1] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    111 => nr_cgi = Some(NrCgi::decode(data)?),
                    552 => ao_a_search_window = Some(AoAAssistanceInfo::decode(data)?),
                    564 => number_of_trp_rx_teg = Some(NumberOfTrpRxTeg::decode(data)?),
                    565 => number_of_trp_rx_tx_teg = Some(NumberOfTrpRxTxTeg::decode(data)?),
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            trpid,
            search_window_information,
            nr_cgi,
            ao_a_search_window,
            number_of_trp_rx_teg,
            number_of_trp_rx_tx_teg,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();
        if let Some(x) = &self.nr_cgi {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 111, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.ao_a_search_window {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 552, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.number_of_trp_rx_teg {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 564, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.number_of_trp_rx_tx_teg {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 565, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        let mut optionals = BitString::new();
        optionals.push(self.search_window_information.is_some());
        optionals.push(num_ies != 0);

        encode::encode_sequence_header(data, false, &optionals, false)?;
        self.trpid.encode(data)?;
        if let Some(x) = &self.search_window_information {
            x.encode(data)?;
        }
        if num_ies != 0 {
            encode::encode_length_determinent(data, Some(1), Some(65535), false, num_ies)?;
            data.append_aligned(ies);
        }
        Ok(())
    }
}

impl PerCodec for TrpMeasurementRequestItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        TrpMeasurementRequestItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TrpMeasurementRequestItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TrpMeasurementRequestItem");
            e
        })
    }
}
// TrpPrsInfoList
#[derive(Clone, Debug)]
pub struct TrpPrsInfoList(pub NonEmpty<TrpPrsInfoListItem>);

impl TrpPrsInfoList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(256), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(TrpPrsInfoListItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(256), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for TrpPrsInfoList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        TrpPrsInfoList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TrpPrsInfoList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TrpPrsInfoList");
            e
        })
    }
}
// TrpPrsInfoListItem
#[derive(Clone, Debug)]
pub struct TrpPrsInfoListItem {
    pub trp_id: Trpid,
    pub nr_pci: NrPci,
    pub cgi_nr: Option<NrCgi>,
    pub prs_configuration: PrsConfiguration,
}

impl TrpPrsInfoListItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 2)?;
        let trp_id = Trpid::decode(data)?;
        let nr_pci = NrPci::decode(data)?;
        let cgi_nr = if optionals[0] {
            Some(NrCgi::decode(data)?)
        } else {
            None
        };
        let prs_configuration = PrsConfiguration::decode(data)?;

        // Process the extension container

        if optionals[1] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            trp_id,
            nr_pci,
            cgi_nr,
            prs_configuration,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.cgi_nr.is_some());
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.trp_id.encode(data)?;
        self.nr_pci.encode(data)?;
        if let Some(x) = &self.cgi_nr {
            x.encode(data)?;
        }
        self.prs_configuration.encode(data)?;

        Ok(())
    }
}

impl PerCodec for TrpPrsInfoListItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        TrpPrsInfoListItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TrpPrsInfoListItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TrpPrsInfoListItem");
            e
        })
    }
}
// TrpPositionDefinitionType
#[derive(Clone, Debug)]
pub enum TrpPositionDefinitionType {
    Direct(TrpPositionDirect),
    Referenced(TrpPositionReferenced),
}

impl TrpPositionDefinitionType {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_choice_idx(data, 0, 2, false)?;
        if extended {
            return Err(per_codec_error_new("CHOICE additions not implemented"));
        }
        match idx {
            0 => Ok(Self::Direct(TrpPositionDirect::decode(data)?)),
            1 => Ok(Self::Referenced(TrpPositionReferenced::decode(data)?)),
            2 => {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _ = Criticality::decode(data)?;
                let _ = decode::decode_length_determinent(data, None, None, false)?;
                let result = match id {
                    x => Err(per_codec_error_new(format!("Unrecognised IE type {}", x))),
                };
                data.decode_align()?;
                result
            }
            _ => Err(per_codec_error_new("Unknown choice idx")),
        }
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        match self {
            Self::Direct(x) => {
                encode::encode_choice_idx(data, 0, 2, false, 0, false)?;
                x.encode(data)
            }
            Self::Referenced(x) => {
                encode::encode_choice_idx(data, 0, 2, false, 1, false)?;
                x.encode(data)
            }
        }
    }
}

impl PerCodec for TrpPositionDefinitionType {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        TrpPositionDefinitionType::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TrpPositionDefinitionType");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TrpPositionDefinitionType");
            e
        })
    }
}
// TrpPositionDirect
#[derive(Clone, Debug)]
pub struct TrpPositionDirect {
    pub accuracy: TrpPositionDirectAccuracy,
}

impl TrpPositionDirect {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, false, 1)?;
        let accuracy = TrpPositionDirectAccuracy::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self { accuracy })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, false, &optionals, false)?;
        self.accuracy.encode(data)?;

        Ok(())
    }
}

impl PerCodec for TrpPositionDirect {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        TrpPositionDirect::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TrpPositionDirect");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TrpPositionDirect");
            e
        })
    }
}
// TrpPositionDirectAccuracy
#[derive(Clone, Debug)]
pub enum TrpPositionDirectAccuracy {
    TrpPosition(AccessPointPosition),
    TrphAposition(NgranHighAccuracyAccessPointPosition),
}

impl TrpPositionDirectAccuracy {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_choice_idx(data, 0, 2, false)?;
        if extended {
            return Err(per_codec_error_new("CHOICE additions not implemented"));
        }
        match idx {
            0 => Ok(Self::TrpPosition(AccessPointPosition::decode(data)?)),
            1 => Ok(Self::TrphAposition(
                NgranHighAccuracyAccessPointPosition::decode(data)?,
            )),
            2 => {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _ = Criticality::decode(data)?;
                let _ = decode::decode_length_determinent(data, None, None, false)?;
                let result = match id {
                    x => Err(per_codec_error_new(format!("Unrecognised IE type {}", x))),
                };
                data.decode_align()?;
                result
            }
            _ => Err(per_codec_error_new("Unknown choice idx")),
        }
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        match self {
            Self::TrpPosition(x) => {
                encode::encode_choice_idx(data, 0, 2, false, 0, false)?;
                x.encode(data)
            }
            Self::TrphAposition(x) => {
                encode::encode_choice_idx(data, 0, 2, false, 1, false)?;
                x.encode(data)
            }
        }
    }
}

impl PerCodec for TrpPositionDirectAccuracy {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        TrpPositionDirectAccuracy::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TrpPositionDirectAccuracy");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TrpPositionDirectAccuracy");
            e
        })
    }
}
// TrpPositionReferenced
#[derive(Clone, Debug)]
pub struct TrpPositionReferenced {
    pub reference_point: ReferencePoint,
    pub reference_point_type: TrpReferencePointType,
}

impl TrpPositionReferenced {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, false, 1)?;
        let reference_point = ReferencePoint::decode(data)?;
        let reference_point_type = TrpReferencePointType::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            reference_point,
            reference_point_type,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, false, &optionals, false)?;
        self.reference_point.encode(data)?;
        self.reference_point_type.encode(data)?;

        Ok(())
    }
}

impl PerCodec for TrpPositionReferenced {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        TrpPositionReferenced::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TrpPositionReferenced");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TrpPositionReferenced");
            e
        })
    }
}
// TrpReferencePointType
#[derive(Clone, Debug)]
pub enum TrpReferencePointType {
    TrpPositionRelativeGeodetic(RelativeGeodeticLocation),
    TrpPositionRelativeCartesian(RelativeCartesianLocation),
}

impl TrpReferencePointType {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_choice_idx(data, 0, 2, false)?;
        if extended {
            return Err(per_codec_error_new("CHOICE additions not implemented"));
        }
        match idx {
            0 => Ok(Self::TrpPositionRelativeGeodetic(
                RelativeGeodeticLocation::decode(data)?,
            )),
            1 => Ok(Self::TrpPositionRelativeCartesian(
                RelativeCartesianLocation::decode(data)?,
            )),
            2 => {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _ = Criticality::decode(data)?;
                let _ = decode::decode_length_determinent(data, None, None, false)?;
                let result = match id {
                    x => Err(per_codec_error_new(format!("Unrecognised IE type {}", x))),
                };
                data.decode_align()?;
                result
            }
            _ => Err(per_codec_error_new("Unknown choice idx")),
        }
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        match self {
            Self::TrpPositionRelativeGeodetic(x) => {
                encode::encode_choice_idx(data, 0, 2, false, 0, false)?;
                x.encode(data)
            }
            Self::TrpPositionRelativeCartesian(x) => {
                encode::encode_choice_idx(data, 0, 2, false, 1, false)?;
                x.encode(data)
            }
        }
    }
}

impl PerCodec for TrpReferencePointType {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        TrpReferencePointType::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TrpReferencePointType");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TrpReferencePointType");
            e
        })
    }
}
// TrpRxTegInformation
#[derive(Clone, Debug)]
pub struct TrpRxTegInformation {
    pub trp_rx_tegid: u8,
    pub trp_rx_timing_error_margin: TimingErrorMargin,
}

impl TrpRxTegInformation {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let trp_rx_tegid = decode::decode_integer(data, Some(0), Some(31), false)?.0 as u8;
        let trp_rx_timing_error_margin = TimingErrorMargin::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            trp_rx_tegid,
            trp_rx_timing_error_margin,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        encode::encode_integer(
            data,
            Some(0),
            Some(31),
            false,
            self.trp_rx_tegid as i128,
            false,
        )?;
        self.trp_rx_timing_error_margin.encode(data)?;

        Ok(())
    }
}

impl PerCodec for TrpRxTegInformation {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        TrpRxTegInformation::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TrpRxTegInformation");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TrpRxTegInformation");
            e
        })
    }
}
// TrpRxTxTegInformation
#[derive(Clone, Debug)]
pub struct TrpRxTxTegInformation {
    pub trp_rx_tx_tegid: u8,
    pub trp_rx_tx_timing_error_margin: RxTxTimingErrorMargin,
}

impl TrpRxTxTegInformation {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let trp_rx_tx_tegid = decode::decode_integer(data, Some(0), Some(255), false)?.0 as u8;
        let trp_rx_tx_timing_error_margin = RxTxTimingErrorMargin::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            trp_rx_tx_tegid,
            trp_rx_tx_timing_error_margin,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        encode::encode_integer(
            data,
            Some(0),
            Some(255),
            false,
            self.trp_rx_tx_tegid as i128,
            false,
        )?;
        self.trp_rx_tx_timing_error_margin.encode(data)?;

        Ok(())
    }
}

impl PerCodec for TrpRxTxTegInformation {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        TrpRxTxTegInformation::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TrpRxTxTegInformation");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TrpRxTxTegInformation");
            e
        })
    }
}
// TrpTxTegInformation
#[derive(Clone, Debug)]
pub struct TrpTxTegInformation {
    pub trp_tx_tegid: u8,
    pub trp_tx_timing_error_margin: TimingErrorMargin,
}

impl TrpTxTegInformation {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let trp_tx_tegid = decode::decode_integer(data, Some(0), Some(7), false)?.0 as u8;
        let trp_tx_timing_error_margin = TimingErrorMargin::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            trp_tx_tegid,
            trp_tx_timing_error_margin,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        encode::encode_integer(
            data,
            Some(0),
            Some(7),
            false,
            self.trp_tx_tegid as i128,
            false,
        )?;
        self.trp_tx_timing_error_margin.encode(data)?;

        Ok(())
    }
}

impl PerCodec for TrpTxTegInformation {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        TrpTxTegInformation::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TrpTxTegInformation");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TrpTxTegInformation");
            e
        })
    }
}
// TrpTxTegAssociation
#[derive(Clone, Debug)]
pub struct TrpTxTegAssociation(pub NonEmpty<TrptegItem>);

impl TrpTxTegAssociation {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(8), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(TrptegItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(8), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for TrpTxTegAssociation {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        TrpTxTegAssociation::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TrpTxTegAssociation");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TrpTxTegAssociation");
            e
        })
    }
}
// TrptegItem
#[derive(Clone, Debug)]
pub struct TrptegItem {
    pub trp_tx_teg_information: TrpTxTegInformation,
    pub dl_prs_resource_set_id: PrsResourceSetId,
    pub dl_prs_resource_id_list: Option<NonEmpty<DlprsResourceIdItem>>,
}

impl TrptegItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 2)?;
        let trp_tx_teg_information = TrpTxTegInformation::decode(data)?;
        let dl_prs_resource_set_id = PrsResourceSetId::decode(data)?;
        let dl_prs_resource_id_list = if optionals[0] {
            Some({
                let length = decode::decode_length_determinent(data, Some(1), Some(64), false)?;
                let mut items = vec![];
                for _ in 0..length {
                    items.push(DlprsResourceIdItem::decode(data)?);
                }
                NonEmpty::from_vec(items).unwrap()
            })
        } else {
            None
        };

        // Process the extension container

        if optionals[1] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            trp_tx_teg_information,
            dl_prs_resource_set_id,
            dl_prs_resource_id_list,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.dl_prs_resource_id_list.is_some());
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.trp_tx_teg_information.encode(data)?;
        self.dl_prs_resource_set_id.encode(data)?;
        if let Some(x) = &self.dl_prs_resource_id_list {
            encode::encode_length_determinent(data, Some(1), Some(64), false, x.len())?;
            for x in *&x {
                x.encode(data)?;
            }
            Ok(())?;
        }

        Ok(())
    }
}

impl PerCodec for TrptegItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        TrptegItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TrptegItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TrptegItem");
            e
        })
    }
}
// DlprsResourceIdItem
#[derive(Clone, Debug)]
pub struct DlprsResourceIdItem {
    pub dl_prs_resource_id: PrsResourceId,
}

impl DlprsResourceIdItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let dl_prs_resource_id = PrsResourceId::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self { dl_prs_resource_id })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.dl_prs_resource_id.encode(data)?;

        Ok(())
    }
}

impl PerCodec for DlprsResourceIdItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        DlprsResourceIdItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DlprsResourceIdItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DlprsResourceIdItem");
            e
        })
    }
}
// TypeOfError
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum TypeOfError {
    NotUnderstood,
    Missing,
}

impl TypeOfError {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(1), true)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(1),
            true,
            *self as i128,
            (*self as u32) >= 2,
        )
    }
}

impl PerCodec for TypeOfError {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        TypeOfError::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TypeOfError");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TypeOfError");
            e
        })
    }
}
// TransportLayerAddressInfo
#[derive(Clone, Debug)]
pub struct TransportLayerAddressInfo {
    pub transport_up_layer_address_info_to_add_list: Option<TransportUpLayerAddressInfoToAddList>,
    pub transport_up_layer_address_info_to_remove_list:
        Option<TransportUpLayerAddressInfoToRemoveList>,
}

impl TransportLayerAddressInfo {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, false, 3)?;
        let transport_up_layer_address_info_to_add_list = if optionals[0] {
            Some(TransportUpLayerAddressInfoToAddList::decode(data)?)
        } else {
            None
        };
        let transport_up_layer_address_info_to_remove_list = if optionals[1] {
            Some(TransportUpLayerAddressInfoToRemoveList::decode(data)?)
        } else {
            None
        };

        // Process the extension container

        if optionals[2] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            transport_up_layer_address_info_to_add_list,
            transport_up_layer_address_info_to_remove_list,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.transport_up_layer_address_info_to_add_list.is_some());
        optionals.push(
            self.transport_up_layer_address_info_to_remove_list
                .is_some(),
        );
        optionals.push(false);

        encode::encode_sequence_header(data, false, &optionals, false)?;
        if let Some(x) = &self.transport_up_layer_address_info_to_add_list {
            x.encode(data)?;
        }
        if let Some(x) = &self.transport_up_layer_address_info_to_remove_list {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl PerCodec for TransportLayerAddressInfo {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        TransportLayerAddressInfo::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TransportLayerAddressInfo");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TransportLayerAddressInfo");
            e
        })
    }
}
// TrpType
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum TrpType {
    PrsOnlyTp,
    SrsOnlyRp,
    Tp,
    Rp,
    Trp,
    MobileTrp,
}

impl TrpType {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(4), true)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(4),
            true,
            *self as i128,
            (*self as u32) >= 5,
        )
    }
}

impl PerCodec for TrpType {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        TrpType::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TrpType");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TrpType");
            e
        })
    }
}
// TscAssistanceInformation
#[derive(Clone, Debug)]
pub struct TscAssistanceInformation {
    pub periodicity: Periodicity,
    pub burst_arrival_time: Option<BurstArrivalTime>,
    pub survival_time: Option<SurvivalTime>,
    pub ra_nfeedback_type: Option<RaNfeedbackType>,
    pub n6_jitter_information: Option<N6JitterInformation>,
}

impl TscAssistanceInformation {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 2)?;
        let periodicity = Periodicity::decode(data)?;
        let burst_arrival_time = if optionals[0] {
            Some(BurstArrivalTime::decode(data)?)
        } else {
            None
        };

        // Process the extension container
        let mut survival_time: Option<SurvivalTime> = None;
        let mut ra_nfeedback_type: Option<RaNfeedbackType> = None;
        let mut n6_jitter_information: Option<N6JitterInformation> = None;

        if optionals[1] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    540 => survival_time = Some(SurvivalTime::decode(data)?),
                    752 => ra_nfeedback_type = Some(RaNfeedbackType::decode(data)?),
                    776 => n6_jitter_information = Some(N6JitterInformation::decode(data)?),
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            periodicity,
            burst_arrival_time,
            survival_time,
            ra_nfeedback_type,
            n6_jitter_information,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();
        if let Some(x) = &self.survival_time {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 540, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.ra_nfeedback_type {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 752, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.n6_jitter_information {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 776, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        let mut optionals = BitString::new();
        optionals.push(self.burst_arrival_time.is_some());
        optionals.push(num_ies != 0);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.periodicity.encode(data)?;
        if let Some(x) = &self.burst_arrival_time {
            x.encode(data)?;
        }
        if num_ies != 0 {
            encode::encode_length_determinent(data, Some(1), Some(65535), false, num_ies)?;
            data.append_aligned(ies);
        }
        Ok(())
    }
}

impl PerCodec for TscAssistanceInformation {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        TscAssistanceInformation::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TscAssistanceInformation");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TscAssistanceInformation");
            e
        })
    }
}
// TscTrafficCharacteristics
#[derive(Clone, Debug)]
pub struct TscTrafficCharacteristics {
    pub tsc_assistance_information_dl: Option<TscAssistanceInformation>,
    pub tsc_assistance_information_ul: Option<TscAssistanceInformation>,
}

impl TscTrafficCharacteristics {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 3)?;
        let tsc_assistance_information_dl = if optionals[0] {
            Some(TscAssistanceInformation::decode(data)?)
        } else {
            None
        };
        let tsc_assistance_information_ul = if optionals[1] {
            Some(TscAssistanceInformation::decode(data)?)
        } else {
            None
        };

        // Process the extension container

        if optionals[2] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            tsc_assistance_information_dl,
            tsc_assistance_information_ul,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.tsc_assistance_information_dl.is_some());
        optionals.push(self.tsc_assistance_information_ul.is_some());
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        if let Some(x) = &self.tsc_assistance_information_dl {
            x.encode(data)?;
        }
        if let Some(x) = &self.tsc_assistance_information_ul {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl PerCodec for TscTrafficCharacteristics {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        TscTrafficCharacteristics::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TscTrafficCharacteristics");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TscTrafficCharacteristics");
            e
        })
    }
}
// TscTrafficCharacteristicsFeedback
#[derive(Clone, Debug)]
pub struct TscTrafficCharacteristicsFeedback {
    pub tsc_feedback_information_dl: Option<TscFeedbackInformation>,
    pub tsc_feedback_information_ul: Option<TscFeedbackInformation>,
}

impl TscTrafficCharacteristicsFeedback {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 3)?;
        let tsc_feedback_information_dl = if optionals[0] {
            Some(TscFeedbackInformation::decode(data)?)
        } else {
            None
        };
        let tsc_feedback_information_ul = if optionals[1] {
            Some(TscFeedbackInformation::decode(data)?)
        } else {
            None
        };

        // Process the extension container

        if optionals[2] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            tsc_feedback_information_dl,
            tsc_feedback_information_ul,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.tsc_feedback_information_dl.is_some());
        optionals.push(self.tsc_feedback_information_ul.is_some());
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        if let Some(x) = &self.tsc_feedback_information_dl {
            x.encode(data)?;
        }
        if let Some(x) = &self.tsc_feedback_information_ul {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl PerCodec for TscTrafficCharacteristicsFeedback {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        TscTrafficCharacteristicsFeedback::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TscTrafficCharacteristicsFeedback");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TscTrafficCharacteristicsFeedback");
            e
        })
    }
}
// TscFeedbackInformation
#[derive(Clone, Debug)]
pub struct TscFeedbackInformation {
    pub burst_arrival_time_offset: i32,
    pub adjusted_periodicity: Option<Periodicity>,
}

impl TscFeedbackInformation {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 2)?;
        let burst_arrival_time_offset =
            decode::decode_integer(data, Some(-640000), Some(640000), true)?.0 as i32;
        let adjusted_periodicity = if optionals[0] {
            Some(Periodicity::decode(data)?)
        } else {
            None
        };

        // Process the extension container

        if optionals[1] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            burst_arrival_time_offset,
            adjusted_periodicity,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.adjusted_periodicity.is_some());
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        encode::encode_integer(
            data,
            Some(-640000),
            Some(640000),
            true,
            self.burst_arrival_time_offset as i128,
            false,
        )?;
        if let Some(x) = &self.adjusted_periodicity {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl PerCodec for TscFeedbackInformation {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        TscFeedbackInformation::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TscFeedbackInformation");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TscFeedbackInformation");
            e
        })
    }
}
// TrpMeasurementUpdateList
#[derive(Clone, Debug)]
pub struct TrpMeasurementUpdateList(pub NonEmpty<TrpMeasurementUpdateItem>);

impl TrpMeasurementUpdateList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(64), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(TrpMeasurementUpdateItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(64), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for TrpMeasurementUpdateList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        TrpMeasurementUpdateList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TrpMeasurementUpdateList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TrpMeasurementUpdateList");
            e
        })
    }
}
// TrpMeasurementUpdateItem
#[derive(Clone, Debug)]
pub struct TrpMeasurementUpdateItem {
    pub trp_id: Trpid,
    pub ao_a_window_information: Option<AoAAssistanceInfo>,
    pub number_of_trp_rx_teg: Option<NumberOfTrpRxTeg>,
    pub number_of_trp_rx_tx_teg: Option<NumberOfTrpRxTxTeg>,
}

impl TrpMeasurementUpdateItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 2)?;
        let trp_id = Trpid::decode(data)?;
        let ao_a_window_information = if optionals[0] {
            Some(AoAAssistanceInfo::decode(data)?)
        } else {
            None
        };

        // Process the extension container
        let mut number_of_trp_rx_teg: Option<NumberOfTrpRxTeg> = None;
        let mut number_of_trp_rx_tx_teg: Option<NumberOfTrpRxTxTeg> = None;

        if optionals[1] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    564 => number_of_trp_rx_teg = Some(NumberOfTrpRxTeg::decode(data)?),
                    565 => number_of_trp_rx_tx_teg = Some(NumberOfTrpRxTxTeg::decode(data)?),
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            trp_id,
            ao_a_window_information,
            number_of_trp_rx_teg,
            number_of_trp_rx_tx_teg,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();
        if let Some(x) = &self.number_of_trp_rx_teg {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 564, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.number_of_trp_rx_tx_teg {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 565, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        let mut optionals = BitString::new();
        optionals.push(self.ao_a_window_information.is_some());
        optionals.push(num_ies != 0);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.trp_id.encode(data)?;
        if let Some(x) = &self.ao_a_window_information {
            x.encode(data)?;
        }
        if num_ies != 0 {
            encode::encode_length_determinent(data, Some(1), Some(65535), false, num_ies)?;
            data.append_aligned(ies);
        }
        Ok(())
    }
}

impl PerCodec for TrpMeasurementUpdateItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        TrpMeasurementUpdateItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TrpMeasurementUpdateItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TrpMeasurementUpdateItem");
            e
        })
    }
}
// TwoPhrModeMcg
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum TwoPhrModeMcg {
    Enabled,
}

impl TwoPhrModeMcg {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(0), true)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(0),
            true,
            *self as i128,
            (*self as u32) >= 1,
        )
    }
}

impl PerCodec for TwoPhrModeMcg {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        TwoPhrModeMcg::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TwoPhrModeMcg");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TwoPhrModeMcg");
            e
        })
    }
}
// TwoPhrModeScg
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum TwoPhrModeScg {
    Enabled,
}

impl TwoPhrModeScg {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(0), true)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(0),
            true,
            *self as i128,
            (*self as u32) >= 1,
        )
    }
}

impl PerCodec for TwoPhrModeScg {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        TwoPhrModeScg::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TwoPhrModeScg");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TwoPhrModeScg");
            e
        })
    }
}
// TxHoppingConfiguration
#[derive(Clone, Debug)]
pub struct TxHoppingConfiguration {
    pub overlap_value: OverlapValue,
    pub number_of_hops: u8,
    pub slot_offset_for_remaining_hops_list: SlotOffsetForRemainingHopsList,
}

impl TxHoppingConfiguration {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let overlap_value = OverlapValue::decode(data)?;
        let number_of_hops = decode::decode_integer(data, Some(2), Some(6), false)?.0 as u8;
        let slot_offset_for_remaining_hops_list = SlotOffsetForRemainingHopsList::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            overlap_value,
            number_of_hops,
            slot_offset_for_remaining_hops_list,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.overlap_value.encode(data)?;
        encode::encode_integer(
            data,
            Some(2),
            Some(6),
            false,
            self.number_of_hops as i128,
            false,
        )?;
        self.slot_offset_for_remaining_hops_list.encode(data)?;

        Ok(())
    }
}

impl PerCodec for TxHoppingConfiguration {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        TxHoppingConfiguration::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TxHoppingConfiguration");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TxHoppingConfiguration");
            e
        })
    }
}
// TaInformationList
#[derive(Clone, Debug)]
pub struct TaInformationList(pub NonEmpty<TaInformationItem>);

impl TaInformationList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(8), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(TaInformationItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(8), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for TaInformationList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        TaInformationList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TaInformationList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TaInformationList");
            e
        })
    }
}
// TaInformationItem
#[derive(Clone, Debug)]
pub struct TaInformationItem {
    pub nr_cgi: NrCgi,
    pub ta_value: TaValue,
    pub tag_id_pointer: Option<TagIdPointer>,
}

impl TaInformationItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let nr_cgi = NrCgi::decode(data)?;
        let ta_value = TaValue::decode(data)?;

        // Process the extension container
        let mut tag_id_pointer: Option<TagIdPointer> = None;

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    853 => tag_id_pointer = Some(TagIdPointer::decode(data)?),
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            nr_cgi,
            ta_value,
            tag_id_pointer,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();
        if let Some(x) = &self.tag_id_pointer {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 853, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        let mut optionals = BitString::new();
        optionals.push(num_ies != 0);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.nr_cgi.encode(data)?;
        self.ta_value.encode(data)?;
        if num_ies != 0 {
            encode::encode_length_determinent(data, Some(1), Some(65535), false, num_ies)?;
            data.append_aligned(ies);
        }
        Ok(())
    }
}

impl PerCodec for TaInformationItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        TaInformationItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TaInformationItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TaInformationItem");
            e
        })
    }
}
// UacAssistanceInfo
#[derive(Clone, Debug)]
pub struct UacAssistanceInfo {
    pub uac_plmn_list: UacPlmnList,
}

impl UacAssistanceInfo {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, false, 1)?;
        let uac_plmn_list = UacPlmnList::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self { uac_plmn_list })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, false, &optionals, false)?;
        self.uac_plmn_list.encode(data)?;

        Ok(())
    }
}

impl PerCodec for UacAssistanceInfo {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        UacAssistanceInfo::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UacAssistanceInfo");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UacAssistanceInfo");
            e
        })
    }
}
// UacPlmnList
#[derive(Clone, Debug)]
pub struct UacPlmnList(pub NonEmpty<UacPlmnItem>);

impl UacPlmnList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(12), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(UacPlmnItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(12), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for UacPlmnList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        UacPlmnList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UacPlmnList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UacPlmnList");
            e
        })
    }
}
// UacPlmnItem
#[derive(Clone, Debug)]
pub struct UacPlmnItem {
    pub plmn_identity: PlmnIdentity,
    pub uac_type_list: UacTypeList,
    pub nid: Option<Nid>,
}

impl UacPlmnItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, false, 1)?;
        let plmn_identity = PlmnIdentity::decode(data)?;
        let uac_type_list = UacTypeList::decode(data)?;

        // Process the extension container
        let mut nid: Option<Nid> = None;

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    385 => nid = Some(Nid::decode(data)?),
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            plmn_identity,
            uac_type_list,
            nid,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();
        if let Some(x) = &self.nid {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 385, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        let mut optionals = BitString::new();
        optionals.push(num_ies != 0);

        encode::encode_sequence_header(data, false, &optionals, false)?;
        self.plmn_identity.encode(data)?;
        self.uac_type_list.encode(data)?;
        if num_ies != 0 {
            encode::encode_length_determinent(data, Some(1), Some(65535), false, num_ies)?;
            data.append_aligned(ies);
        }
        Ok(())
    }
}

impl PerCodec for UacPlmnItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        UacPlmnItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UacPlmnItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UacPlmnItem");
            e
        })
    }
}
// UacTypeList
#[derive(Clone, Debug)]
pub struct UacTypeList(pub NonEmpty<UacTypeItem>);

impl UacTypeList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(64), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(UacTypeItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(64), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for UacTypeList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        UacTypeList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UacTypeList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UacTypeList");
            e
        })
    }
}
// UacTypeItem
#[derive(Clone, Debug)]
pub struct UacTypeItem {
    pub uac_reduction_indication: UacReductionIndication,
    pub uac_category_type: UacCategoryType,
}

impl UacTypeItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, false, 1)?;
        let uac_reduction_indication = UacReductionIndication::decode(data)?;
        let uac_category_type = UacCategoryType::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            uac_reduction_indication,
            uac_category_type,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, false, &optionals, false)?;
        self.uac_reduction_indication.encode(data)?;
        self.uac_category_type.encode(data)?;

        Ok(())
    }
}

impl PerCodec for UacTypeItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        UacTypeItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UacTypeItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UacTypeItem");
            e
        })
    }
}
// UacCategoryType
#[derive(Clone, Debug)]
pub enum UacCategoryType {
    UaCstandardized(UacAction),
    UacOperatorDefined(UacOperatorDefined),
}

impl UacCategoryType {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_choice_idx(data, 0, 2, false)?;
        if extended {
            return Err(per_codec_error_new("CHOICE additions not implemented"));
        }
        match idx {
            0 => Ok(Self::UaCstandardized(UacAction::decode(data)?)),
            1 => Ok(Self::UacOperatorDefined(UacOperatorDefined::decode(data)?)),
            2 => {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _ = Criticality::decode(data)?;
                let _ = decode::decode_length_determinent(data, None, None, false)?;
                let result = match id {
                    x => Err(per_codec_error_new(format!("Unrecognised IE type {}", x))),
                };
                data.decode_align()?;
                result
            }
            _ => Err(per_codec_error_new("Unknown choice idx")),
        }
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        match self {
            Self::UaCstandardized(x) => {
                encode::encode_choice_idx(data, 0, 2, false, 0, false)?;
                x.encode(data)
            }
            Self::UacOperatorDefined(x) => {
                encode::encode_choice_idx(data, 0, 2, false, 1, false)?;
                x.encode(data)
            }
        }
    }
}

impl PerCodec for UacCategoryType {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        UacCategoryType::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UacCategoryType");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UacCategoryType");
            e
        })
    }
}
// UacOperatorDefined
#[derive(Clone, Debug)]
pub struct UacOperatorDefined {
    pub access_category: u8,
    pub access_identity: BitString,
}

impl UacOperatorDefined {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, false, 1)?;
        let access_category = decode::decode_integer(data, Some(32), Some(63), true)?.0 as u8;
        let access_identity = decode::decode_bitstring(data, Some(7), Some(7), false)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            access_category,
            access_identity,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, false, &optionals, false)?;
        encode::encode_integer(
            data,
            Some(32),
            Some(63),
            true,
            self.access_category as i128,
            false,
        )?;
        encode::encode_bitstring(data, Some(7), Some(7), false, &self.access_identity, false)?;

        Ok(())
    }
}

impl PerCodec for UacOperatorDefined {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        UacOperatorDefined::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UacOperatorDefined");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UacOperatorDefined");
            e
        })
    }
}
// UacAction
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum UacAction {
    RejectNonEmergencyMoDt,
    RejectRrcCrSignalling,
    PermitEmergencySessionsAndMobileTerminatedServicesOnly,
    PermitHighPrioritySessionsAndMobileTerminatedServicesOnly,
}

impl UacAction {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(3), true)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(3),
            true,
            *self as i128,
            (*self as u32) >= 4,
        )
    }
}

impl PerCodec for UacAction {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        UacAction::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UacAction");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UacAction");
            e
        })
    }
}
// UacReductionIndication
#[derive(Clone, Copy, Debug)]
pub struct UacReductionIndication(pub u8);

impl UacReductionIndication {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(
            decode::decode_integer(data, Some(0), Some(100), false)?.0 as u8,
        ))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_integer(data, Some(0), Some(100), false, self.0 as i128, false)
    }
}

impl PerCodec for UacReductionIndication {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        UacReductionIndication::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UacReductionIndication");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UacReductionIndication");
            e
        })
    }
}
// UeAssociatedLogicalF1ConnectionItem
#[derive(Clone, Debug)]
pub struct UeAssociatedLogicalF1ConnectionItem {
    pub gnb_cu_ue_f1ap_id: Option<GnbCuUeF1apId>,
    pub gnb_du_ue_f1ap_id: Option<GnbDuUeF1apId>,
}

impl UeAssociatedLogicalF1ConnectionItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 3)?;
        let gnb_cu_ue_f1ap_id = if optionals[0] {
            Some(GnbCuUeF1apId::decode(data)?)
        } else {
            None
        };
        let gnb_du_ue_f1ap_id = if optionals[1] {
            Some(GnbDuUeF1apId::decode(data)?)
        } else {
            None
        };

        // Process the extension container

        if optionals[2] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            gnb_cu_ue_f1ap_id,
            gnb_du_ue_f1ap_id,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.gnb_cu_ue_f1ap_id.is_some());
        optionals.push(self.gnb_du_ue_f1ap_id.is_some());
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        if let Some(x) = &self.gnb_cu_ue_f1ap_id {
            x.encode(data)?;
        }
        if let Some(x) = &self.gnb_du_ue_f1ap_id {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl PerCodec for UeAssociatedLogicalF1ConnectionItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        UeAssociatedLogicalF1ConnectionItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UeAssociatedLogicalF1ConnectionItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UeAssociatedLogicalF1ConnectionItem");
            e
        })
    }
}
// UeAssistanceInformation
#[derive(Clone, Debug)]
pub struct UeAssistanceInformation(pub Vec<u8>);

impl UeAssistanceInformation {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(decode::decode_octetstring(data, None, None, false)?))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_octetstring(data, None, None, false, &self.0, false)
    }
}

impl PerCodec for UeAssistanceInformation {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        UeAssistanceInformation::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UeAssistanceInformation");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UeAssistanceInformation");
            e
        })
    }
}
// UeAssistanceInformationEutra
#[derive(Clone, Debug)]
pub struct UeAssistanceInformationEutra(pub Vec<u8>);

impl UeAssistanceInformationEutra {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(decode::decode_octetstring(data, None, None, false)?))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_octetstring(data, None, None, false, &self.0, false)
    }
}

impl PerCodec for UeAssistanceInformationEutra {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        UeAssistanceInformationEutra::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UeAssistanceInformationEutra");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UeAssistanceInformationEutra");
            e
        })
    }
}
// UeCapabilityRatContainerList
#[derive(Clone, Debug)]
pub struct UeCapabilityRatContainerList(pub Vec<u8>);

impl UeCapabilityRatContainerList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(decode::decode_octetstring(data, None, None, false)?))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_octetstring(data, None, None, false, &self.0, false)
    }
}

impl PerCodec for UeCapabilityRatContainerList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        UeCapabilityRatContainerList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UeCapabilityRatContainerList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UeCapabilityRatContainerList");
            e
        })
    }
}
// UeContextNotRetrievable
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum UeContextNotRetrievable {
    True,
}

impl UeContextNotRetrievable {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(0), true)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(0),
            true,
            *self as i128,
            (*self as u32) >= 1,
        )
    }
}

impl PerCodec for UeContextNotRetrievable {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        UeContextNotRetrievable::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UeContextNotRetrievable");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UeContextNotRetrievable");
            e
        })
    }
}
// UeIdentityIndexValue
#[derive(Clone, Debug)]
pub enum UeIdentityIndexValue {
    IndexLength10(BitString),
}

impl UeIdentityIndexValue {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_choice_idx(data, 0, 1, false)?;
        if extended {
            return Err(per_codec_error_new("CHOICE additions not implemented"));
        }
        match idx {
            0 => Ok(Self::IndexLength10(decode::decode_bitstring(
                data,
                Some(10),
                Some(10),
                false,
            )?)),
            1 => {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _ = Criticality::decode(data)?;
                let _ = decode::decode_length_determinent(data, None, None, false)?;
                let result = match id {
                    x => Err(per_codec_error_new(format!("Unrecognised IE type {}", x))),
                };
                data.decode_align()?;
                result
            }
            _ => Err(per_codec_error_new("Unknown choice idx")),
        }
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        match self {
            Self::IndexLength10(x) => {
                encode::encode_choice_idx(data, 0, 1, false, 0, false)?;
                encode::encode_bitstring(data, Some(10), Some(10), false, &x, false)
            }
        }
    }
}

impl PerCodec for UeIdentityIndexValue {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        UeIdentityIndexValue::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UeIdentityIndexValue");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UeIdentityIndexValue");
            e
        })
    }
}
// UeIdentityListForPagingItem
#[derive(Clone, Debug)]
pub struct UeIdentityListForPagingItem {
    pub ue_identity_index_value: UeIdentityIndexValue,
    pub paging_drx: Option<PagingDrx>,
}

impl UeIdentityListForPagingItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, false, 2)?;
        let ue_identity_index_value = UeIdentityIndexValue::decode(data)?;
        let paging_drx = if optionals[0] {
            Some(PagingDrx::decode(data)?)
        } else {
            None
        };

        // Process the extension container

        if optionals[1] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            ue_identity_index_value,
            paging_drx,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.paging_drx.is_some());
        optionals.push(false);

        encode::encode_sequence_header(data, false, &optionals, false)?;
        self.ue_identity_index_value.encode(data)?;
        if let Some(x) = &self.paging_drx {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl PerCodec for UeIdentityListForPagingItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        UeIdentityListForPagingItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UeIdentityListForPagingItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UeIdentityListForPagingItem");
            e
        })
    }
}
// UeMulticastMrBsConfirmedToBeModifiedItem
#[derive(Clone, Debug)]
pub struct UeMulticastMrBsConfirmedToBeModifiedItem {
    pub mrb_id: MrbId,
    pub mrb_type_reconfiguration: Option<MbsptpRetransmissionTunnelRequired>,
}

impl UeMulticastMrBsConfirmedToBeModifiedItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, false, 2)?;
        let mrb_id = MrbId::decode(data)?;
        let mrb_type_reconfiguration = if optionals[0] {
            Some(MbsptpRetransmissionTunnelRequired::decode(data)?)
        } else {
            None
        };

        // Process the extension container

        if optionals[1] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            mrb_id,
            mrb_type_reconfiguration,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.mrb_type_reconfiguration.is_some());
        optionals.push(false);

        encode::encode_sequence_header(data, false, &optionals, false)?;
        self.mrb_id.encode(data)?;
        if let Some(x) = &self.mrb_type_reconfiguration {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl PerCodec for UeMulticastMrBsConfirmedToBeModifiedItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        UeMulticastMrBsConfirmedToBeModifiedItem::decode_inner(data).map_err(
            |mut e: PerCodecError| {
                e.push_context("UeMulticastMrBsConfirmedToBeModifiedItem");
                e
            },
        )
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UeMulticastMrBsConfirmedToBeModifiedItem");
            e
        })
    }
}
// UeMulticastMrBsRequiredToBeModifiedItem
#[derive(Clone, Debug)]
pub struct UeMulticastMrBsRequiredToBeModifiedItem {
    pub mrb_id: MrbId,
    pub mrb_type_reconfiguration: Option<MrbTypeReconfiguration>,
    pub mrb_reconfigured_rlc_type: Option<MrbReconfiguredRlcType>,
    pub multicast_f1u_context_reference_cu: Option<MulticastF1uContextReferenceCu>,
}

impl UeMulticastMrBsRequiredToBeModifiedItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, false, 3)?;
        let mrb_id = MrbId::decode(data)?;
        let mrb_type_reconfiguration = if optionals[0] {
            Some(MrbTypeReconfiguration::decode(data)?)
        } else {
            None
        };
        let mrb_reconfigured_rlc_type = if optionals[1] {
            Some(MrbReconfiguredRlcType::decode(data)?)
        } else {
            None
        };

        // Process the extension container
        let mut multicast_f1u_context_reference_cu: Option<MulticastF1uContextReferenceCu> = None;

        if optionals[2] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    681 => {
                        multicast_f1u_context_reference_cu =
                            Some(MulticastF1uContextReferenceCu::decode(data)?)
                    }
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            mrb_id,
            mrb_type_reconfiguration,
            mrb_reconfigured_rlc_type,
            multicast_f1u_context_reference_cu,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();
        if let Some(x) = &self.multicast_f1u_context_reference_cu {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 681, false)?;
            Criticality::Reject.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        let mut optionals = BitString::new();
        optionals.push(self.mrb_type_reconfiguration.is_some());
        optionals.push(self.mrb_reconfigured_rlc_type.is_some());
        optionals.push(num_ies != 0);

        encode::encode_sequence_header(data, false, &optionals, false)?;
        self.mrb_id.encode(data)?;
        if let Some(x) = &self.mrb_type_reconfiguration {
            x.encode(data)?;
        }
        if let Some(x) = &self.mrb_reconfigured_rlc_type {
            x.encode(data)?;
        }
        if num_ies != 0 {
            encode::encode_length_determinent(data, Some(1), Some(65535), false, num_ies)?;
            data.append_aligned(ies);
        }
        Ok(())
    }
}

impl PerCodec for UeMulticastMrBsRequiredToBeModifiedItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        UeMulticastMrBsRequiredToBeModifiedItem::decode_inner(data).map_err(
            |mut e: PerCodecError| {
                e.push_context("UeMulticastMrBsRequiredToBeModifiedItem");
                e
            },
        )
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UeMulticastMrBsRequiredToBeModifiedItem");
            e
        })
    }
}
// UeMulticastMrBsRequiredToBeReleasedItem
#[derive(Clone, Debug)]
pub struct UeMulticastMrBsRequiredToBeReleasedItem {
    pub mrb_id: MrbId,
}

impl UeMulticastMrBsRequiredToBeReleasedItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, false, 1)?;
        let mrb_id = MrbId::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self { mrb_id })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, false, &optionals, false)?;
        self.mrb_id.encode(data)?;

        Ok(())
    }
}

impl PerCodec for UeMulticastMrBsRequiredToBeReleasedItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        UeMulticastMrBsRequiredToBeReleasedItem::decode_inner(data).map_err(
            |mut e: PerCodecError| {
                e.push_context("UeMulticastMrBsRequiredToBeReleasedItem");
                e
            },
        )
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UeMulticastMrBsRequiredToBeReleasedItem");
            e
        })
    }
}
// UeMulticastMrBsSetupItem
#[derive(Clone, Debug)]
pub struct UeMulticastMrBsSetupItem {
    pub mrb_id: MrbId,
    pub multicast_f1u_context_reference_cu: MulticastF1uContextReferenceCu,
}

impl UeMulticastMrBsSetupItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, false, 1)?;
        let mrb_id = MrbId::decode(data)?;
        let multicast_f1u_context_reference_cu = MulticastF1uContextReferenceCu::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            mrb_id,
            multicast_f1u_context_reference_cu,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, false, &optionals, false)?;
        self.mrb_id.encode(data)?;
        self.multicast_f1u_context_reference_cu.encode(data)?;

        Ok(())
    }
}

impl PerCodec for UeMulticastMrBsSetupItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        UeMulticastMrBsSetupItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UeMulticastMrBsSetupItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UeMulticastMrBsSetupItem");
            e
        })
    }
}
// UeMulticastMrBsSetupnewItem
#[derive(Clone, Debug)]
pub struct UeMulticastMrBsSetupnewItem {
    pub mrb_id: MrbId,
    pub multicast_f1u_context_reference_cu: MulticastF1uContextReferenceCu,
}

impl UeMulticastMrBsSetupnewItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, false, 1)?;
        let mrb_id = MrbId::decode(data)?;
        let multicast_f1u_context_reference_cu = MulticastF1uContextReferenceCu::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            mrb_id,
            multicast_f1u_context_reference_cu,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, false, &optionals, false)?;
        self.mrb_id.encode(data)?;
        self.multicast_f1u_context_reference_cu.encode(data)?;

        Ok(())
    }
}

impl PerCodec for UeMulticastMrBsSetupnewItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        UeMulticastMrBsSetupnewItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UeMulticastMrBsSetupnewItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UeMulticastMrBsSetupnewItem");
            e
        })
    }
}
// UeMulticastMrBsToBeReleasedItem
#[derive(Clone, Debug)]
pub struct UeMulticastMrBsToBeReleasedItem {
    pub mrb_id: MrbId,
}

impl UeMulticastMrBsToBeReleasedItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, false, 1)?;
        let mrb_id = MrbId::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self { mrb_id })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, false, &optionals, false)?;
        self.mrb_id.encode(data)?;

        Ok(())
    }
}

impl PerCodec for UeMulticastMrBsToBeReleasedItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        UeMulticastMrBsToBeReleasedItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UeMulticastMrBsToBeReleasedItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UeMulticastMrBsToBeReleasedItem");
            e
        })
    }
}
// UeMulticastMrBsToBeSetupItem
#[derive(Clone, Debug)]
pub struct UeMulticastMrBsToBeSetupItem {
    pub mrb_id: MrbId,
    pub mbs_ptp_retransmission_tunnel_required: Option<MbsptpRetransmissionTunnelRequired>,
    pub mbs_ptp_forwarding_required_information: Option<MrbProgressInformation>,
    pub source_mrb_id: Option<MrbId>,
}

impl UeMulticastMrBsToBeSetupItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, false, 3)?;
        let mrb_id = MrbId::decode(data)?;
        let mbs_ptp_retransmission_tunnel_required = if optionals[0] {
            Some(MbsptpRetransmissionTunnelRequired::decode(data)?)
        } else {
            None
        };
        let mbs_ptp_forwarding_required_information = if optionals[1] {
            Some(MrbProgressInformation::decode(data)?)
        } else {
            None
        };

        // Process the extension container
        let mut source_mrb_id: Option<MrbId> = None;

        if optionals[2] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    671 => source_mrb_id = Some(MrbId::decode(data)?),
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            mrb_id,
            mbs_ptp_retransmission_tunnel_required,
            mbs_ptp_forwarding_required_information,
            source_mrb_id,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();
        if let Some(x) = &self.source_mrb_id {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 671, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        let mut optionals = BitString::new();
        optionals.push(self.mbs_ptp_retransmission_tunnel_required.is_some());
        optionals.push(self.mbs_ptp_forwarding_required_information.is_some());
        optionals.push(num_ies != 0);

        encode::encode_sequence_header(data, false, &optionals, false)?;
        self.mrb_id.encode(data)?;
        if let Some(x) = &self.mbs_ptp_retransmission_tunnel_required {
            x.encode(data)?;
        }
        if let Some(x) = &self.mbs_ptp_forwarding_required_information {
            x.encode(data)?;
        }
        if num_ies != 0 {
            encode::encode_length_determinent(data, Some(1), Some(65535), false, num_ies)?;
            data.append_aligned(ies);
        }
        Ok(())
    }
}

impl PerCodec for UeMulticastMrBsToBeSetupItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        UeMulticastMrBsToBeSetupItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UeMulticastMrBsToBeSetupItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UeMulticastMrBsToBeSetupItem");
            e
        })
    }
}
// UeMulticastMrBsToBeSetupAtModifyItem
#[derive(Clone, Debug)]
pub struct UeMulticastMrBsToBeSetupAtModifyItem {
    pub mrb_id: MrbId,
    pub mbs_ptp_retransmission_tunnel_required: Option<MbsptpRetransmissionTunnelRequired>,
    pub mbs_ptp_forwarding_required_information: Option<MrbProgressInformation>,
}

impl UeMulticastMrBsToBeSetupAtModifyItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, false, 3)?;
        let mrb_id = MrbId::decode(data)?;
        let mbs_ptp_retransmission_tunnel_required = if optionals[0] {
            Some(MbsptpRetransmissionTunnelRequired::decode(data)?)
        } else {
            None
        };
        let mbs_ptp_forwarding_required_information = if optionals[1] {
            Some(MrbProgressInformation::decode(data)?)
        } else {
            None
        };

        // Process the extension container

        if optionals[2] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            mrb_id,
            mbs_ptp_retransmission_tunnel_required,
            mbs_ptp_forwarding_required_information,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.mbs_ptp_retransmission_tunnel_required.is_some());
        optionals.push(self.mbs_ptp_forwarding_required_information.is_some());
        optionals.push(false);

        encode::encode_sequence_header(data, false, &optionals, false)?;
        self.mrb_id.encode(data)?;
        if let Some(x) = &self.mbs_ptp_retransmission_tunnel_required {
            x.encode(data)?;
        }
        if let Some(x) = &self.mbs_ptp_forwarding_required_information {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl PerCodec for UeMulticastMrBsToBeSetupAtModifyItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        UeMulticastMrBsToBeSetupAtModifyItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UeMulticastMrBsToBeSetupAtModifyItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UeMulticastMrBsToBeSetupAtModifyItem");
            e
        })
    }
}
// UePagingCapability
#[derive(Clone, Debug)]
pub struct UePagingCapability {
    pub inactive_state_po_determination: Option<InactiveStatePoDetermination>,
    pub red_cap_indication: Option<RedCapIndication>,
}

impl UePagingCapability {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 2)?;
        let inactive_state_po_determination = if optionals[0] {
            Some(InactiveStatePoDetermination::decode(data)?)
        } else {
            None
        };

        // Process the extension container
        let mut red_cap_indication: Option<RedCapIndication> = None;

        if optionals[1] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    673 => red_cap_indication = Some(RedCapIndication::decode(data)?),
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            inactive_state_po_determination,
            red_cap_indication,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();
        if let Some(x) = &self.red_cap_indication {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 673, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        let mut optionals = BitString::new();
        optionals.push(self.inactive_state_po_determination.is_some());
        optionals.push(num_ies != 0);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        if let Some(x) = &self.inactive_state_po_determination {
            x.encode(data)?;
        }
        if num_ies != 0 {
            encode::encode_length_determinent(data, Some(1), Some(65535), false, num_ies)?;
            data.append_aligned(ies);
        }
        Ok(())
    }
}

impl PerCodec for UePagingCapability {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        UePagingCapability::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UePagingCapability");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UePagingCapability");
            e
        })
    }
}
// UeReportingInformation
#[derive(Clone, Debug)]
pub struct UeReportingInformation {
    pub reporting_amount: ReportingAmount,
    pub reporting_interval: ReportingInterval,
    pub reporting_interval_i_ms: Option<ReportingIntervalIMs>,
}

impl UeReportingInformation {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let reporting_amount = ReportingAmount::decode(data)?;
        let reporting_interval = ReportingInterval::decode(data)?;

        // Process the extension container
        let mut reporting_interval_i_ms: Option<ReportingIntervalIMs> = None;

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    851 => reporting_interval_i_ms = Some(ReportingIntervalIMs::decode(data)?),
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            reporting_amount,
            reporting_interval,
            reporting_interval_i_ms,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();
        if let Some(x) = &self.reporting_interval_i_ms {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 851, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        let mut optionals = BitString::new();
        optionals.push(num_ies != 0);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.reporting_amount.encode(data)?;
        self.reporting_interval.encode(data)?;
        if num_ies != 0 {
            encode::encode_length_determinent(data, Some(1), Some(65535), false, num_ies)?;
            data.append_aligned(ies);
        }
        Ok(())
    }
}

impl PerCodec for UeReportingInformation {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        UeReportingInformation::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UeReportingInformation");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UeReportingInformation");
            e
        })
    }
}
// UlTxDirectCurrentMoreCarrierInformation
#[derive(Clone, Debug)]
pub struct UlTxDirectCurrentMoreCarrierInformation(pub Vec<u8>);

impl UlTxDirectCurrentMoreCarrierInformation {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(decode::decode_octetstring(data, None, None, false)?))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_octetstring(data, None, None, false, &self.0, false)
    }
}

impl PerCodec for UlTxDirectCurrentMoreCarrierInformation {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        UlTxDirectCurrentMoreCarrierInformation::decode_inner(data).map_err(
            |mut e: PerCodecError| {
                e.push_context("UlTxDirectCurrentMoreCarrierInformation");
                e
            },
        )
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UlTxDirectCurrentMoreCarrierInformation");
            e
        })
    }
}
// UlAoA
#[derive(Clone, Debug)]
pub struct UlAoA {
    pub azimuth_ao_a: u16,
    pub zenith_ao_a: Option<u16>,
    pub lcs_to_gcs_translation: Option<LcsToGcsTranslation>,
}

impl UlAoA {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 3)?;
        let azimuth_ao_a = decode::decode_integer(data, Some(0), Some(3599), false)?.0 as u16;
        let zenith_ao_a = if optionals[0] {
            Some(decode::decode_integer(data, Some(0), Some(1799), false)?.0 as u16)
        } else {
            None
        };
        let lcs_to_gcs_translation = if optionals[1] {
            Some(LcsToGcsTranslation::decode(data)?)
        } else {
            None
        };

        // Process the extension container

        if optionals[2] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            azimuth_ao_a,
            zenith_ao_a,
            lcs_to_gcs_translation,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.zenith_ao_a.is_some());
        optionals.push(self.lcs_to_gcs_translation.is_some());
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        encode::encode_integer(
            data,
            Some(0),
            Some(3599),
            false,
            self.azimuth_ao_a as i128,
            false,
        )?;
        if let Some(x) = &self.zenith_ao_a {
            encode::encode_integer(data, Some(0), Some(1799), false, *x as i128, false)?;
        }
        if let Some(x) = &self.lcs_to_gcs_translation {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl PerCodec for UlAoA {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        UlAoA::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UlAoA");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UlAoA");
            e
        })
    }
}
// UlBhNonUpTrafficMapping
#[derive(Clone, Debug)]
pub struct UlBhNonUpTrafficMapping {
    pub ul_bh_non_up_traffic_mapping_list: UlBhNonUpTrafficMappingList,
}

impl UlBhNonUpTrafficMapping {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, false, 1)?;
        let ul_bh_non_up_traffic_mapping_list = UlBhNonUpTrafficMappingList::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            ul_bh_non_up_traffic_mapping_list,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, false, &optionals, false)?;
        self.ul_bh_non_up_traffic_mapping_list.encode(data)?;

        Ok(())
    }
}

impl PerCodec for UlBhNonUpTrafficMapping {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        UlBhNonUpTrafficMapping::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UlBhNonUpTrafficMapping");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UlBhNonUpTrafficMapping");
            e
        })
    }
}
// UlBhNonUpTrafficMappingList
#[derive(Clone, Debug)]
pub struct UlBhNonUpTrafficMappingList(pub NonEmpty<UlBhNonUpTrafficMappingItem>);

impl UlBhNonUpTrafficMappingList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(32), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(UlBhNonUpTrafficMappingItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(32), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for UlBhNonUpTrafficMappingList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        UlBhNonUpTrafficMappingList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UlBhNonUpTrafficMappingList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UlBhNonUpTrafficMappingList");
            e
        })
    }
}
// UlBhNonUpTrafficMappingItem
#[derive(Clone, Debug)]
pub struct UlBhNonUpTrafficMappingItem {
    pub non_up_traffic_type: NonUpTrafficType,
    pub bh_info: BhInfo,
}

impl UlBhNonUpTrafficMappingItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, false, 1)?;
        let non_up_traffic_type = NonUpTrafficType::decode(data)?;
        let bh_info = BhInfo::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            non_up_traffic_type,
            bh_info,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, false, &optionals, false)?;
        self.non_up_traffic_type.encode(data)?;
        self.bh_info.encode(data)?;

        Ok(())
    }
}

impl PerCodec for UlBhNonUpTrafficMappingItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        UlBhNonUpTrafficMappingItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UlBhNonUpTrafficMappingItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UlBhNonUpTrafficMappingItem");
            e
        })
    }
}
// UlConfiguration
#[derive(Clone, Debug)]
pub struct UlConfiguration {
    pub ul_ue_configuration: UlUeConfiguration,
}

impl UlConfiguration {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let ul_ue_configuration = UlUeConfiguration::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            ul_ue_configuration,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.ul_ue_configuration.encode(data)?;

        Ok(())
    }
}

impl PerCodec for UlConfiguration {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        UlConfiguration::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UlConfiguration");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UlConfiguration");
            e
        })
    }
}
// UlGapFr2Config
#[derive(Clone, Debug)]
pub struct UlGapFr2Config(pub Vec<u8>);

impl UlGapFr2Config {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(decode::decode_octetstring(data, None, None, false)?))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_octetstring(data, None, None, false, &self.0, false)
    }
}

impl PerCodec for UlGapFr2Config {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        UlGapFr2Config::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UlGapFr2Config");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UlGapFr2Config");
            e
        })
    }
}
// UlRtoaMeasurement
#[derive(Clone, Debug)]
pub struct UlRtoaMeasurement {
    pub ul_rtoa_measurement_item: UlRtoaMeasurementItem,
    pub additional_path_list: Option<AdditionalPathList>,
    pub extended_additional_path_list: Option<ExtendedAdditionalPathList>,
    pub trp_rx_teg_information: Option<TrpRxTegInformation>,
}

impl UlRtoaMeasurement {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, false, 2)?;
        let ul_rtoa_measurement_item = UlRtoaMeasurementItem::decode(data)?;
        let additional_path_list = if optionals[0] {
            Some(AdditionalPathList::decode(data)?)
        } else {
            None
        };

        // Process the extension container
        let mut extended_additional_path_list: Option<ExtendedAdditionalPathList> = None;
        let mut trp_rx_teg_information: Option<TrpRxTegInformation> = None;

        if optionals[1] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    561 => {
                        extended_additional_path_list =
                            Some(ExtendedAdditionalPathList::decode(data)?)
                    }
                    568 => trp_rx_teg_information = Some(TrpRxTegInformation::decode(data)?),
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            ul_rtoa_measurement_item,
            additional_path_list,
            extended_additional_path_list,
            trp_rx_teg_information,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();
        if let Some(x) = &self.extended_additional_path_list {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 561, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.trp_rx_teg_information {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 568, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        let mut optionals = BitString::new();
        optionals.push(self.additional_path_list.is_some());
        optionals.push(num_ies != 0);

        encode::encode_sequence_header(data, false, &optionals, false)?;
        self.ul_rtoa_measurement_item.encode(data)?;
        if let Some(x) = &self.additional_path_list {
            x.encode(data)?;
        }
        if num_ies != 0 {
            encode::encode_length_determinent(data, Some(1), Some(65535), false, num_ies)?;
            data.append_aligned(ies);
        }
        Ok(())
    }
}

impl PerCodec for UlRtoaMeasurement {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        UlRtoaMeasurement::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UlRtoaMeasurement");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UlRtoaMeasurement");
            e
        })
    }
}
// UlRtoaMeasurementItem
#[derive(Clone, Debug)]
pub enum UlRtoaMeasurementItem {
    K0(u32),
    K1(u32),
    K2(u32),
    K3(u32),
    K4(u32),
    K5(u16),
    ReportingGranularitykminus1(ReportingGranularitykminus1),
    ReportingGranularitykminus2(ReportingGranularitykminus2),
    ReportingGranularitykminus3(ReportingGranularitykminus3),
    ReportingGranularitykminus4(ReportingGranularitykminus4),
    ReportingGranularitykminus5(ReportingGranularitykminus5),
    ReportingGranularitykminus6(ReportingGranularitykminus6),
}

impl UlRtoaMeasurementItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_choice_idx(data, 0, 6, false)?;
        if extended {
            return Err(per_codec_error_new("CHOICE additions not implemented"));
        }
        match idx {
            0 => Ok(Self::K0(
                decode::decode_integer(data, Some(0), Some(1970049), false)?.0 as u32,
            )),
            1 => Ok(Self::K1(
                decode::decode_integer(data, Some(0), Some(985025), false)?.0 as u32,
            )),
            2 => Ok(Self::K2(
                decode::decode_integer(data, Some(0), Some(492513), false)?.0 as u32,
            )),
            3 => Ok(Self::K3(
                decode::decode_integer(data, Some(0), Some(246257), false)?.0 as u32,
            )),
            4 => Ok(Self::K4(
                decode::decode_integer(data, Some(0), Some(123129), false)?.0 as u32,
            )),
            5 => Ok(Self::K5(
                decode::decode_integer(data, Some(0), Some(61565), false)?.0 as u16,
            )),
            6 => {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _ = Criticality::decode(data)?;
                let _ = decode::decode_length_determinent(data, None, None, false)?;
                let result = match id {
                    806 => Ok(Self::ReportingGranularitykminus1(
                        ReportingGranularitykminus1::decode(data)?,
                    )),
                    807 => Ok(Self::ReportingGranularitykminus2(
                        ReportingGranularitykminus2::decode(data)?,
                    )),
                    821 => Ok(Self::ReportingGranularitykminus3(
                        ReportingGranularitykminus3::decode(data)?,
                    )),
                    822 => Ok(Self::ReportingGranularitykminus4(
                        ReportingGranularitykminus4::decode(data)?,
                    )),
                    823 => Ok(Self::ReportingGranularitykminus5(
                        ReportingGranularitykminus5::decode(data)?,
                    )),
                    824 => Ok(Self::ReportingGranularitykminus6(
                        ReportingGranularitykminus6::decode(data)?,
                    )),
                    x => Err(per_codec_error_new(format!("Unrecognised IE type {}", x))),
                };
                data.decode_align()?;
                result
            }
            _ => Err(per_codec_error_new("Unknown choice idx")),
        }
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        match self {
            Self::K0(x) => {
                encode::encode_choice_idx(data, 0, 6, false, 0, false)?;
                encode::encode_integer(data, Some(0), Some(1970049), false, *x as i128, false)
            }
            Self::K1(x) => {
                encode::encode_choice_idx(data, 0, 6, false, 1, false)?;
                encode::encode_integer(data, Some(0), Some(985025), false, *x as i128, false)
            }
            Self::K2(x) => {
                encode::encode_choice_idx(data, 0, 6, false, 2, false)?;
                encode::encode_integer(data, Some(0), Some(492513), false, *x as i128, false)
            }
            Self::K3(x) => {
                encode::encode_choice_idx(data, 0, 6, false, 3, false)?;
                encode::encode_integer(data, Some(0), Some(246257), false, *x as i128, false)
            }
            Self::K4(x) => {
                encode::encode_choice_idx(data, 0, 6, false, 4, false)?;
                encode::encode_integer(data, Some(0), Some(123129), false, *x as i128, false)
            }
            Self::K5(x) => {
                encode::encode_choice_idx(data, 0, 6, false, 5, false)?;
                encode::encode_integer(data, Some(0), Some(61565), false, *x as i128, false)
            }
            Self::ReportingGranularitykminus1(x) => {
                encode::encode_choice_idx(data, 0, 6, false, 6, false)?;
                encode::encode_integer(data, Some(0), Some(65535), false, 806, false)?;
                Criticality::Ignore.encode(data)?;
                let ie = &mut Allocator::new_codec_data();
                x.encode(ie)?;
                encode::encode_length_determinent(data, None, None, false, ie.length_in_bytes())?;
                Ok(data.append_aligned(ie))
            }
            Self::ReportingGranularitykminus2(x) => {
                encode::encode_choice_idx(data, 0, 6, false, 6, false)?;
                encode::encode_integer(data, Some(0), Some(65535), false, 807, false)?;
                Criticality::Ignore.encode(data)?;
                let ie = &mut Allocator::new_codec_data();
                x.encode(ie)?;
                encode::encode_length_determinent(data, None, None, false, ie.length_in_bytes())?;
                Ok(data.append_aligned(ie))
            }
            Self::ReportingGranularitykminus3(x) => {
                encode::encode_choice_idx(data, 0, 6, false, 6, false)?;
                encode::encode_integer(data, Some(0), Some(65535), false, 821, false)?;
                Criticality::Ignore.encode(data)?;
                let ie = &mut Allocator::new_codec_data();
                x.encode(ie)?;
                encode::encode_length_determinent(data, None, None, false, ie.length_in_bytes())?;
                Ok(data.append_aligned(ie))
            }
            Self::ReportingGranularitykminus4(x) => {
                encode::encode_choice_idx(data, 0, 6, false, 6, false)?;
                encode::encode_integer(data, Some(0), Some(65535), false, 822, false)?;
                Criticality::Ignore.encode(data)?;
                let ie = &mut Allocator::new_codec_data();
                x.encode(ie)?;
                encode::encode_length_determinent(data, None, None, false, ie.length_in_bytes())?;
                Ok(data.append_aligned(ie))
            }
            Self::ReportingGranularitykminus5(x) => {
                encode::encode_choice_idx(data, 0, 6, false, 6, false)?;
                encode::encode_integer(data, Some(0), Some(65535), false, 823, false)?;
                Criticality::Ignore.encode(data)?;
                let ie = &mut Allocator::new_codec_data();
                x.encode(ie)?;
                encode::encode_length_determinent(data, None, None, false, ie.length_in_bytes())?;
                Ok(data.append_aligned(ie))
            }
            Self::ReportingGranularitykminus6(x) => {
                encode::encode_choice_idx(data, 0, 6, false, 6, false)?;
                encode::encode_integer(data, Some(0), Some(65535), false, 824, false)?;
                Criticality::Ignore.encode(data)?;
                let ie = &mut Allocator::new_codec_data();
                x.encode(ie)?;
                encode::encode_length_determinent(data, None, None, false, ie.length_in_bytes())?;
                Ok(data.append_aligned(ie))
            }
        }
    }
}

impl PerCodec for UlRtoaMeasurementItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        UlRtoaMeasurementItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UlRtoaMeasurementItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UlRtoaMeasurementItem");
            e
        })
    }
}
// UlSrsRsrp
#[derive(Clone, Copy, Debug)]
pub struct UlSrsRsrp(pub u8);

impl UlSrsRsrp {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(
            decode::decode_integer(data, Some(0), Some(126), false)?.0 as u8,
        ))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_integer(data, Some(0), Some(126), false, self.0 as i128, false)
    }
}

impl PerCodec for UlSrsRsrp {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        UlSrsRsrp::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UlSrsRsrp");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UlSrsRsrp");
            e
        })
    }
}
// UlSrsRsrpp
#[derive(Clone, Debug)]
pub struct UlSrsRsrpp {
    pub first_path_rsrpp: u8,
}

impl UlSrsRsrpp {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let first_path_rsrpp = decode::decode_integer(data, Some(0), Some(126), false)?.0 as u8;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self { first_path_rsrpp })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        encode::encode_integer(
            data,
            Some(0),
            Some(126),
            false,
            self.first_path_rsrpp as i128,
            false,
        )?;

        Ok(())
    }
}

impl PerCodec for UlSrsRsrpp {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        UlSrsRsrpp::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UlSrsRsrpp");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UlSrsRsrpp");
            e
        })
    }
}
// UlRscp
#[derive(Clone, Debug)]
pub struct UlRscp {
    pub ulrscp: u16,
}

impl UlRscp {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let ulrscp = decode::decode_integer(data, Some(0), Some(3599), false)?.0 as u16;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self { ulrscp })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        encode::encode_integer(data, Some(0), Some(3599), false, self.ulrscp as i128, false)?;

        Ok(())
    }
}

impl PerCodec for UlRscp {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        UlRscp::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UlRscp");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UlRscp");
            e
        })
    }
}
// UlUeConfiguration
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum UlUeConfiguration {
    NoData,
    Shared,
    Only,
}

impl UlUeConfiguration {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(2), true)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(2),
            true,
            *self as i128,
            (*self as u32) >= 3,
        )
    }
}

impl PerCodec for UlUeConfiguration {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        UlUeConfiguration::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UlUeConfiguration");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UlUeConfiguration");
            e
        })
    }
}
// UlUpTnlInformationToUpdateListItem
#[derive(Clone, Debug)]
pub struct UlUpTnlInformationToUpdateListItem {
    pub ul_up_tnl_information: UpTransportLayerInformation,
    pub new_ul_up_tnl_information: Option<UpTransportLayerInformation>,
    pub bh_info: BhInfo,
}

impl UlUpTnlInformationToUpdateListItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 2)?;
        let ul_up_tnl_information = UpTransportLayerInformation::decode(data)?;
        let new_ul_up_tnl_information = if optionals[0] {
            Some(UpTransportLayerInformation::decode(data)?)
        } else {
            None
        };
        let bh_info = BhInfo::decode(data)?;

        // Process the extension container

        if optionals[1] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            ul_up_tnl_information,
            new_ul_up_tnl_information,
            bh_info,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.new_ul_up_tnl_information.is_some());
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.ul_up_tnl_information.encode(data)?;
        if let Some(x) = &self.new_ul_up_tnl_information {
            x.encode(data)?;
        }
        self.bh_info.encode(data)?;

        Ok(())
    }
}

impl PerCodec for UlUpTnlInformationToUpdateListItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        UlUpTnlInformationToUpdateListItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UlUpTnlInformationToUpdateListItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UlUpTnlInformationToUpdateListItem");
            e
        })
    }
}
// UlUpTnlAddressToUpdateListItem
#[derive(Clone, Debug)]
pub struct UlUpTnlAddressToUpdateListItem {
    pub old_ip_adress: TransportLayerAddress,
    pub new_ip_adress: TransportLayerAddress,
}

impl UlUpTnlAddressToUpdateListItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let old_ip_adress = TransportLayerAddress::decode(data)?;
        let new_ip_adress = TransportLayerAddress::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            old_ip_adress,
            new_ip_adress,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.old_ip_adress.encode(data)?;
        self.new_ip_adress.encode(data)?;

        Ok(())
    }
}

impl PerCodec for UlUpTnlAddressToUpdateListItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        UlUpTnlAddressToUpdateListItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UlUpTnlAddressToUpdateListItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UlUpTnlAddressToUpdateListItem");
            e
        })
    }
}
// UlUpTnlInformationToBeSetupList
#[derive(Clone, Debug)]
pub struct UlUpTnlInformationToBeSetupList(pub NonEmpty<UlUpTnlInformationToBeSetupItem>);

impl UlUpTnlInformationToBeSetupList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(2), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(UlUpTnlInformationToBeSetupItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(2), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for UlUpTnlInformationToBeSetupList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        UlUpTnlInformationToBeSetupList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UlUpTnlInformationToBeSetupList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UlUpTnlInformationToBeSetupList");
            e
        })
    }
}
// UlUpTnlInformationToBeSetupItem
#[derive(Clone, Debug)]
pub struct UlUpTnlInformationToBeSetupItem {
    pub ul_up_tnl_information: UpTransportLayerInformation,
    pub bh_info: Option<BhInfo>,
    pub drb_mapping_info: Option<UuRlcChannelId>,
}

impl UlUpTnlInformationToBeSetupItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let ul_up_tnl_information = UpTransportLayerInformation::decode(data)?;

        // Process the extension container
        let mut bh_info: Option<BhInfo> = None;
        let mut drb_mapping_info: Option<UuRlcChannelId> = None;

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    280 => bh_info = Some(BhInfo::decode(data)?),
                    598 => drb_mapping_info = Some(UuRlcChannelId::decode(data)?),
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            ul_up_tnl_information,
            bh_info,
            drb_mapping_info,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut num_ies = 0;
        let ies = &mut Allocator::new_codec_data();
        if let Some(x) = &self.bh_info {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 280, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        if let Some(x) = &self.drb_mapping_info {
            let ie = &mut Allocator::new_codec_data();
            x.encode(ie)?;
            encode::encode_integer(ies, Some(0), Some(65535), false, 598, false)?;
            Criticality::Ignore.encode(ies)?;
            encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
            ies.append_aligned(ie);
            num_ies += 1;
        }

        let mut optionals = BitString::new();
        optionals.push(num_ies != 0);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.ul_up_tnl_information.encode(data)?;
        if num_ies != 0 {
            encode::encode_length_determinent(data, Some(1), Some(65535), false, num_ies)?;
            data.append_aligned(ies);
        }
        Ok(())
    }
}

impl PerCodec for UlUpTnlInformationToBeSetupItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        UlUpTnlInformationToBeSetupItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UlUpTnlInformationToBeSetupItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UlUpTnlInformationToBeSetupItem");
            e
        })
    }
}
// Uncertainty
#[derive(Clone, Copy, Debug)]
pub struct Uncertainty(pub u16);

impl Uncertainty {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(
            decode::decode_integer(data, Some(0), Some(32767), true)?.0 as u16,
        ))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_integer(data, Some(0), Some(32767), true, self.0 as i128, false)
    }
}

impl PerCodec for Uncertainty {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Uncertainty::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("Uncertainty");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("Uncertainty");
            e
        })
    }
}
// UplinkChannelBwPerScsList
#[derive(Clone, Debug)]
pub struct UplinkChannelBwPerScsList(pub NonEmpty<ScsSpecificCarrier>);

impl UplinkChannelBwPerScsList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(5), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(ScsSpecificCarrier::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(5), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for UplinkChannelBwPerScsList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        UplinkChannelBwPerScsList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UplinkChannelBwPerScsList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UplinkChannelBwPerScsList");
            e
        })
    }
}
// UplinkTxDirectCurrentListInformation
#[derive(Clone, Debug)]
pub struct UplinkTxDirectCurrentListInformation(pub Vec<u8>);

impl UplinkTxDirectCurrentListInformation {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(decode::decode_octetstring(data, None, None, false)?))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_octetstring(data, None, None, false, &self.0, false)
    }
}

impl PerCodec for UplinkTxDirectCurrentListInformation {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        UplinkTxDirectCurrentListInformation::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UplinkTxDirectCurrentListInformation");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UplinkTxDirectCurrentListInformation");
            e
        })
    }
}
// UplinkTxDirectCurrentTwoCarrierListInfo
#[derive(Clone, Debug)]
pub struct UplinkTxDirectCurrentTwoCarrierListInfo(pub Vec<u8>);

impl UplinkTxDirectCurrentTwoCarrierListInfo {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(decode::decode_octetstring(data, None, None, false)?))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_octetstring(data, None, None, false, &self.0, false)
    }
}

impl PerCodec for UplinkTxDirectCurrentTwoCarrierListInfo {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        UplinkTxDirectCurrentTwoCarrierListInfo::decode_inner(data).map_err(
            |mut e: PerCodecError| {
                e.push_context("UplinkTxDirectCurrentTwoCarrierListInfo");
                e
            },
        )
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UplinkTxDirectCurrentTwoCarrierListInfo");
            e
        })
    }
}
// UltciStateId
#[derive(Clone, Debug)]
pub struct UltciStateId(pub Vec<u8>);

impl UltciStateId {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(decode::decode_octetstring(data, None, None, false)?))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_octetstring(data, None, None, false, &self.0, false)
    }
}

impl PerCodec for UltciStateId {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        UltciStateId::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UltciStateId");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UltciStateId");
            e
        })
    }
}
// UpTransportLayerInformation
#[derive(Clone, Debug)]
pub enum UpTransportLayerInformation {
    GtpTunnel(GtpTunnel),
}

impl UpTransportLayerInformation {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_choice_idx(data, 0, 1, false)?;
        if extended {
            return Err(per_codec_error_new("CHOICE additions not implemented"));
        }
        match idx {
            0 => Ok(Self::GtpTunnel(GtpTunnel::decode(data)?)),
            1 => {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _ = Criticality::decode(data)?;
                let _ = decode::decode_length_determinent(data, None, None, false)?;
                let result = match id {
                    x => Err(per_codec_error_new(format!("Unrecognised IE type {}", x))),
                };
                data.decode_align()?;
                result
            }
            _ => Err(per_codec_error_new("Unknown choice idx")),
        }
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        match self {
            Self::GtpTunnel(x) => {
                encode::encode_choice_idx(data, 0, 1, false, 0, false)?;
                x.encode(data)
            }
        }
    }
}

impl PerCodec for UpTransportLayerInformation {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        UpTransportLayerInformation::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UpTransportLayerInformation");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UpTransportLayerInformation");
            e
        })
    }
}
// UriAddress
#[derive(Clone, Debug)]
pub struct UriAddress(pub String);

impl UriAddress {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(decode::decode_visible_string(
            data, None, None, false,
        )?))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_visible_string(data, None, None, false, &self.0, false)
    }
}

impl PerCodec for UriAddress {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        UriAddress::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UriAddress");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UriAddress");
            e
        })
    }
}
// UncertaintyRangeAoA
#[derive(Clone, Copy, Debug)]
pub struct UncertaintyRangeAoA(pub u16);

impl UncertaintyRangeAoA {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(
            decode::decode_integer(data, Some(0), Some(3599), false)?.0 as u16,
        ))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_integer(data, Some(0), Some(3599), false, self.0 as i128, false)
    }
}

impl PerCodec for UncertaintyRangeAoA {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        UncertaintyRangeAoA::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UncertaintyRangeAoA");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UncertaintyRangeAoA");
            e
        })
    }
}
// UncertaintyRangeZoA
#[derive(Clone, Copy, Debug)]
pub struct UncertaintyRangeZoA(pub u16);

impl UncertaintyRangeZoA {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(
            decode::decode_integer(data, Some(0), Some(1799), false)?.0 as u16,
        ))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_integer(data, Some(0), Some(1799), false, self.0 as i128, false)
    }
}

impl PerCodec for UncertaintyRangeZoA {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        UncertaintyRangeZoA::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UncertaintyRangeZoA");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UncertaintyRangeZoA");
            e
        })
    }
}
// UuRlcChannelId
#[derive(Clone, Copy, Debug)]
pub struct UuRlcChannelId(pub u8);

impl UuRlcChannelId {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self(
            decode::decode_integer(data, Some(1), Some(32), false)?.0 as u8,
        ))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_integer(data, Some(1), Some(32), false, self.0 as i128, false)
    }
}

impl PerCodec for UuRlcChannelId {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        UuRlcChannelId::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UuRlcChannelId");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UuRlcChannelId");
            e
        })
    }
}
// UuRlcChannelQosInformation
#[derive(Clone, Debug)]
pub enum UuRlcChannelQosInformation {
    UuRlcChannelQos(QosFlowLevelQosParameters),
    UuControlPlaneTrafficType(UuControlPlaneTrafficType),
}

impl UuRlcChannelQosInformation {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, extended) = decode::decode_choice_idx(data, 0, 2, false)?;
        if extended {
            return Err(per_codec_error_new("CHOICE additions not implemented"));
        }
        match idx {
            0 => Ok(Self::UuRlcChannelQos(QosFlowLevelQosParameters::decode(
                data,
            )?)),
            1 => Ok(Self::UuControlPlaneTrafficType(
                UuControlPlaneTrafficType::decode(data)?,
            )),
            2 => {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _ = Criticality::decode(data)?;
                let _ = decode::decode_length_determinent(data, None, None, false)?;
                let result = match id {
                    x => Err(per_codec_error_new(format!("Unrecognised IE type {}", x))),
                };
                data.decode_align()?;
                result
            }
            _ => Err(per_codec_error_new("Unknown choice idx")),
        }
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        match self {
            Self::UuRlcChannelQos(x) => {
                encode::encode_choice_idx(data, 0, 2, false, 0, false)?;
                x.encode(data)
            }
            Self::UuControlPlaneTrafficType(x) => {
                encode::encode_choice_idx(data, 0, 2, false, 1, false)?;
                x.encode(data)
            }
        }
    }
}

impl PerCodec for UuRlcChannelQosInformation {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        UuRlcChannelQosInformation::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UuRlcChannelQosInformation");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UuRlcChannelQosInformation");
            e
        })
    }
}
// UuRlcChannelToBeSetupList
#[derive(Clone, Debug)]
pub struct UuRlcChannelToBeSetupList(pub NonEmpty<UuRlcChannelToBeSetupItem>);

impl UuRlcChannelToBeSetupList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(32), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(UuRlcChannelToBeSetupItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(32), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for UuRlcChannelToBeSetupList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        UuRlcChannelToBeSetupList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UuRlcChannelToBeSetupList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UuRlcChannelToBeSetupList");
            e
        })
    }
}
// UuRlcChannelToBeSetupItem
#[derive(Clone, Debug)]
pub struct UuRlcChannelToBeSetupItem {
    pub uu_rlc_channel_id: UuRlcChannelId,
    pub uu_rlc_channel_qos_information: UuRlcChannelQosInformation,
    pub rlc_mode: RlcMode,
}

impl UuRlcChannelToBeSetupItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let uu_rlc_channel_id = UuRlcChannelId::decode(data)?;
        let uu_rlc_channel_qos_information = UuRlcChannelQosInformation::decode(data)?;
        let rlc_mode = RlcMode::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            uu_rlc_channel_id,
            uu_rlc_channel_qos_information,
            rlc_mode,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.uu_rlc_channel_id.encode(data)?;
        self.uu_rlc_channel_qos_information.encode(data)?;
        self.rlc_mode.encode(data)?;

        Ok(())
    }
}

impl PerCodec for UuRlcChannelToBeSetupItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        UuRlcChannelToBeSetupItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UuRlcChannelToBeSetupItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UuRlcChannelToBeSetupItem");
            e
        })
    }
}
// UuRlcChannelToBeModifiedList
#[derive(Clone, Debug)]
pub struct UuRlcChannelToBeModifiedList(pub NonEmpty<UuRlcChannelToBeModifiedItem>);

impl UuRlcChannelToBeModifiedList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(32), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(UuRlcChannelToBeModifiedItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(32), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for UuRlcChannelToBeModifiedList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        UuRlcChannelToBeModifiedList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UuRlcChannelToBeModifiedList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UuRlcChannelToBeModifiedList");
            e
        })
    }
}
// UuRlcChannelToBeModifiedItem
#[derive(Clone, Debug)]
pub struct UuRlcChannelToBeModifiedItem {
    pub uu_rlc_channel_id: UuRlcChannelId,
    pub uu_rlc_channel_qos_information: Option<UuRlcChannelQosInformation>,
    pub rlc_mode: Option<RlcMode>,
}

impl UuRlcChannelToBeModifiedItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 3)?;
        let uu_rlc_channel_id = UuRlcChannelId::decode(data)?;
        let uu_rlc_channel_qos_information = if optionals[0] {
            Some(UuRlcChannelQosInformation::decode(data)?)
        } else {
            None
        };
        let rlc_mode = if optionals[1] {
            Some(RlcMode::decode(data)?)
        } else {
            None
        };

        // Process the extension container

        if optionals[2] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            uu_rlc_channel_id,
            uu_rlc_channel_qos_information,
            rlc_mode,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.uu_rlc_channel_qos_information.is_some());
        optionals.push(self.rlc_mode.is_some());
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.uu_rlc_channel_id.encode(data)?;
        if let Some(x) = &self.uu_rlc_channel_qos_information {
            x.encode(data)?;
        }
        if let Some(x) = &self.rlc_mode {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl PerCodec for UuRlcChannelToBeModifiedItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        UuRlcChannelToBeModifiedItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UuRlcChannelToBeModifiedItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UuRlcChannelToBeModifiedItem");
            e
        })
    }
}
// UuRlcChannelToBeReleasedList
#[derive(Clone, Debug)]
pub struct UuRlcChannelToBeReleasedList(pub NonEmpty<UuRlcChannelToBeReleasedItem>);

impl UuRlcChannelToBeReleasedList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(32), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(UuRlcChannelToBeReleasedItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(32), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for UuRlcChannelToBeReleasedList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        UuRlcChannelToBeReleasedList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UuRlcChannelToBeReleasedList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UuRlcChannelToBeReleasedList");
            e
        })
    }
}
// UuRlcChannelToBeReleasedItem
#[derive(Clone, Debug)]
pub struct UuRlcChannelToBeReleasedItem {
    pub uu_rlc_channel_id: UuRlcChannelId,
}

impl UuRlcChannelToBeReleasedItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let uu_rlc_channel_id = UuRlcChannelId::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self { uu_rlc_channel_id })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.uu_rlc_channel_id.encode(data)?;

        Ok(())
    }
}

impl PerCodec for UuRlcChannelToBeReleasedItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        UuRlcChannelToBeReleasedItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UuRlcChannelToBeReleasedItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UuRlcChannelToBeReleasedItem");
            e
        })
    }
}
// UuRlcChannelSetupList
#[derive(Clone, Debug)]
pub struct UuRlcChannelSetupList(pub NonEmpty<UuRlcChannelSetupItem>);

impl UuRlcChannelSetupList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(32), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(UuRlcChannelSetupItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(32), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for UuRlcChannelSetupList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        UuRlcChannelSetupList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UuRlcChannelSetupList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UuRlcChannelSetupList");
            e
        })
    }
}
// UuRlcChannelSetupItem
#[derive(Clone, Debug)]
pub struct UuRlcChannelSetupItem {
    pub uu_rlc_channel_id: UuRlcChannelId,
}

impl UuRlcChannelSetupItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let uu_rlc_channel_id = UuRlcChannelId::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self { uu_rlc_channel_id })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.uu_rlc_channel_id.encode(data)?;

        Ok(())
    }
}

impl PerCodec for UuRlcChannelSetupItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        UuRlcChannelSetupItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UuRlcChannelSetupItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UuRlcChannelSetupItem");
            e
        })
    }
}
// UuRlcChannelFailedToBeSetupList
#[derive(Clone, Debug)]
pub struct UuRlcChannelFailedToBeSetupList(pub NonEmpty<UuRlcChannelFailedToBeSetupItem>);

impl UuRlcChannelFailedToBeSetupList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(32), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(UuRlcChannelFailedToBeSetupItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(32), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for UuRlcChannelFailedToBeSetupList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        UuRlcChannelFailedToBeSetupList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UuRlcChannelFailedToBeSetupList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UuRlcChannelFailedToBeSetupList");
            e
        })
    }
}
// UuRlcChannelFailedToBeSetupItem
#[derive(Clone, Debug)]
pub struct UuRlcChannelFailedToBeSetupItem {
    pub uu_rlc_channel_id: UuRlcChannelId,
    pub cause: Option<Cause>,
}

impl UuRlcChannelFailedToBeSetupItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 2)?;
        let uu_rlc_channel_id = UuRlcChannelId::decode(data)?;
        let cause = if optionals[0] {
            Some(Cause::decode(data)?)
        } else {
            None
        };

        // Process the extension container

        if optionals[1] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            uu_rlc_channel_id,
            cause,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.cause.is_some());
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.uu_rlc_channel_id.encode(data)?;
        if let Some(x) = &self.cause {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl PerCodec for UuRlcChannelFailedToBeSetupItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        UuRlcChannelFailedToBeSetupItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UuRlcChannelFailedToBeSetupItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UuRlcChannelFailedToBeSetupItem");
            e
        })
    }
}
// UuRlcChannelModifiedList
#[derive(Clone, Debug)]
pub struct UuRlcChannelModifiedList(pub NonEmpty<UuRlcChannelModifiedItem>);

impl UuRlcChannelModifiedList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(32), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(UuRlcChannelModifiedItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(32), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for UuRlcChannelModifiedList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        UuRlcChannelModifiedList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UuRlcChannelModifiedList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UuRlcChannelModifiedList");
            e
        })
    }
}
// UuRlcChannelModifiedItem
#[derive(Clone, Debug)]
pub struct UuRlcChannelModifiedItem {
    pub uu_rlc_channel_id: UuRlcChannelId,
}

impl UuRlcChannelModifiedItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let uu_rlc_channel_id = UuRlcChannelId::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self { uu_rlc_channel_id })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.uu_rlc_channel_id.encode(data)?;

        Ok(())
    }
}

impl PerCodec for UuRlcChannelModifiedItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        UuRlcChannelModifiedItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UuRlcChannelModifiedItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UuRlcChannelModifiedItem");
            e
        })
    }
}
// UuRlcChannelFailedToBeModifiedList
#[derive(Clone, Debug)]
pub struct UuRlcChannelFailedToBeModifiedList(pub NonEmpty<UuRlcChannelFailedToBeModifiedItem>);

impl UuRlcChannelFailedToBeModifiedList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(32), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(UuRlcChannelFailedToBeModifiedItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(32), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for UuRlcChannelFailedToBeModifiedList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        UuRlcChannelFailedToBeModifiedList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UuRlcChannelFailedToBeModifiedList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UuRlcChannelFailedToBeModifiedList");
            e
        })
    }
}
// UuRlcChannelFailedToBeModifiedItem
#[derive(Clone, Debug)]
pub struct UuRlcChannelFailedToBeModifiedItem {
    pub uu_rlc_channel_id: UuRlcChannelId,
    pub cause: Option<Cause>,
}

impl UuRlcChannelFailedToBeModifiedItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 2)?;
        let uu_rlc_channel_id = UuRlcChannelId::decode(data)?;
        let cause = if optionals[0] {
            Some(Cause::decode(data)?)
        } else {
            None
        };

        // Process the extension container

        if optionals[1] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            uu_rlc_channel_id,
            cause,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.cause.is_some());
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.uu_rlc_channel_id.encode(data)?;
        if let Some(x) = &self.cause {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl PerCodec for UuRlcChannelFailedToBeModifiedItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        UuRlcChannelFailedToBeModifiedItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UuRlcChannelFailedToBeModifiedItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UuRlcChannelFailedToBeModifiedItem");
            e
        })
    }
}
// UuRlcChannelRequiredToBeModifiedList
#[derive(Clone, Debug)]
pub struct UuRlcChannelRequiredToBeModifiedList(pub NonEmpty<UuRlcChannelRequiredToBeModifiedItem>);

impl UuRlcChannelRequiredToBeModifiedList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(32), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(UuRlcChannelRequiredToBeModifiedItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(32), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for UuRlcChannelRequiredToBeModifiedList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        UuRlcChannelRequiredToBeModifiedList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UuRlcChannelRequiredToBeModifiedList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UuRlcChannelRequiredToBeModifiedList");
            e
        })
    }
}
// UuRlcChannelRequiredToBeModifiedItem
#[derive(Clone, Debug)]
pub struct UuRlcChannelRequiredToBeModifiedItem {
    pub uu_rlc_channel_id: UuRlcChannelId,
}

impl UuRlcChannelRequiredToBeModifiedItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let uu_rlc_channel_id = UuRlcChannelId::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self { uu_rlc_channel_id })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.uu_rlc_channel_id.encode(data)?;

        Ok(())
    }
}

impl PerCodec for UuRlcChannelRequiredToBeModifiedItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        UuRlcChannelRequiredToBeModifiedItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UuRlcChannelRequiredToBeModifiedItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UuRlcChannelRequiredToBeModifiedItem");
            e
        })
    }
}
// UuRlcChannelRequiredToBeReleasedList
#[derive(Clone, Debug)]
pub struct UuRlcChannelRequiredToBeReleasedList(pub NonEmpty<UuRlcChannelRequiredToBeReleasedItem>);

impl UuRlcChannelRequiredToBeReleasedList {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Ok(Self({
            let length = decode::decode_length_determinent(data, Some(1), Some(32), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(UuRlcChannelRequiredToBeReleasedItem::decode(data)?);
            }
            NonEmpty::from_vec(items).unwrap()
        }))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_length_determinent(data, Some(1), Some(32), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl PerCodec for UuRlcChannelRequiredToBeReleasedList {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        UuRlcChannelRequiredToBeReleasedList::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UuRlcChannelRequiredToBeReleasedList");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UuRlcChannelRequiredToBeReleasedList");
            e
        })
    }
}
// UuRlcChannelRequiredToBeReleasedItem
#[derive(Clone, Debug)]
pub struct UuRlcChannelRequiredToBeReleasedItem {
    pub uu_rlc_channel_id: UuRlcChannelId,
}

impl UuRlcChannelRequiredToBeReleasedItem {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
        let uu_rlc_channel_id = UuRlcChannelId::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self { uu_rlc_channel_id })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        self.uu_rlc_channel_id.encode(data)?;

        Ok(())
    }
}

impl PerCodec for UuRlcChannelRequiredToBeReleasedItem {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        UuRlcChannelRequiredToBeReleasedItem::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UuRlcChannelRequiredToBeReleasedItem");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UuRlcChannelRequiredToBeReleasedItem");
            e
        })
    }
}
// VictimGnbSetId
#[derive(Clone, Debug)]
pub struct VictimGnbSetId {
    pub victim_gnb_set_id: GnbSetId,
}

impl VictimGnbSetId {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, false, 1)?;
        let victim_gnb_set_id = GnbSetId::decode(data)?;

        // Process the extension container

        if optionals[0] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self { victim_gnb_set_id })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(false);

        encode::encode_sequence_header(data, false, &optionals, false)?;
        self.victim_gnb_set_id.encode(data)?;

        Ok(())
    }
}

impl PerCodec for VictimGnbSetId {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        VictimGnbSetId::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("VictimGnbSetId");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("VictimGnbSetId");
            e
        })
    }
}
// VehicleUe
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum VehicleUe {
    Authorized,
    NotAuthorized,
}

impl VehicleUe {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(1), true)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(1),
            true,
            *self as i128,
            (*self as u32) >= 2,
        )
    }
}

impl PerCodec for VehicleUe {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        VehicleUe::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("VehicleUe");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("VehicleUe");
            e
        })
    }
}
// PedestrianUe
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum PedestrianUe {
    Authorized,
    NotAuthorized,
}

impl PedestrianUe {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(1), true)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(1),
            true,
            *self as i128,
            (*self as u32) >= 2,
        )
    }
}

impl PerCodec for PedestrianUe {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PedestrianUe::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PedestrianUe");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PedestrianUe");
            e
        })
    }
}
// ValidityAreaSpecificSrsInformation
#[derive(Clone, Debug)]
pub struct ValidityAreaSpecificSrsInformation {
    pub transmission_comb_pos: Option<TransmissionCombPos>,
    pub resource_mapping: Option<ResourceMapping>,
    pub freq_domain_shift: Option<u16>,
    pub c_srs: Option<u8>,
    pub resource_type_pos: Option<ResourceTypePos>,
    pub sequence_id_pos: Option<u16>,
}

impl ValidityAreaSpecificSrsInformation {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 7)?;
        let transmission_comb_pos = if optionals[0] {
            Some(TransmissionCombPos::decode(data)?)
        } else {
            None
        };
        let resource_mapping = if optionals[1] {
            Some(ResourceMapping::decode(data)?)
        } else {
            None
        };
        let freq_domain_shift = if optionals[2] {
            Some(decode::decode_integer(data, Some(0), Some(268), false)?.0 as u16)
        } else {
            None
        };
        let c_srs = if optionals[3] {
            Some(decode::decode_integer(data, Some(0), Some(63), false)?.0 as u8)
        } else {
            None
        };
        let resource_type_pos = if optionals[4] {
            Some(ResourceTypePos::decode(data)?)
        } else {
            None
        };
        let sequence_id_pos = if optionals[5] {
            Some(decode::decode_integer(data, Some(0), Some(65535), false)?.0 as u16)
        } else {
            None
        };

        // Process the extension container

        if optionals[6] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            transmission_comb_pos,
            resource_mapping,
            freq_domain_shift,
            c_srs,
            resource_type_pos,
            sequence_id_pos,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.transmission_comb_pos.is_some());
        optionals.push(self.resource_mapping.is_some());
        optionals.push(self.freq_domain_shift.is_some());
        optionals.push(self.c_srs.is_some());
        optionals.push(self.resource_type_pos.is_some());
        optionals.push(self.sequence_id_pos.is_some());
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        if let Some(x) = &self.transmission_comb_pos {
            x.encode(data)?;
        }
        if let Some(x) = &self.resource_mapping {
            x.encode(data)?;
        }
        if let Some(x) = &self.freq_domain_shift {
            encode::encode_integer(data, Some(0), Some(268), false, *x as i128, false)?;
        }
        if let Some(x) = &self.c_srs {
            encode::encode_integer(data, Some(0), Some(63), false, *x as i128, false)?;
        }
        if let Some(x) = &self.resource_type_pos {
            x.encode(data)?;
        }
        if let Some(x) = &self.sequence_id_pos {
            encode::encode_integer(data, Some(0), Some(65535), false, *x as i128, false)?;
        }

        Ok(())
    }
}

impl PerCodec for ValidityAreaSpecificSrsInformation {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        ValidityAreaSpecificSrsInformation::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ValidityAreaSpecificSrsInformation");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ValidityAreaSpecificSrsInformation");
            e
        })
    }
}
// XrBcastInformation
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum XrBcastInformation {
    True,
}

impl XrBcastInformation {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(0), true)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(0),
            true,
            *self as i128,
            (*self as u32) >= 1,
        )
    }
}

impl PerCodec for XrBcastInformation {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        XrBcastInformation::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("XrBcastInformation");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("XrBcastInformation");
            e
        })
    }
}
// ZoAInformation
#[derive(Clone, Debug)]
pub struct ZoAInformation {
    pub zenith_ao_a: u16,
    pub lcs_to_gcs_translation: Option<LcsToGcsTranslation>,
}

impl ZoAInformation {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 2)?;
        let zenith_ao_a = decode::decode_integer(data, Some(0), Some(1799), false)?.0 as u16;
        let lcs_to_gcs_translation = if optionals[0] {
            Some(LcsToGcsTranslation::decode(data)?)
        } else {
            None
        };

        // Process the extension container

        if optionals[1] {
            let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            for _ in 0..num_ies {
                let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _criticality = Criticality::decode(data)?;
                let ie_length = decode::decode_length_determinent(data, None, None, false)?;
                match id {
                    _ => data.advance_maybe_err(ie_length, false)?,
                }
                data.decode_align()?;
            }
        }
        Ok(Self {
            zenith_ao_a,
            lcs_to_gcs_translation,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let mut optionals = BitString::new();
        optionals.push(self.lcs_to_gcs_translation.is_some());
        optionals.push(false);

        encode::encode_sequence_header(data, true, &optionals, false)?;
        encode::encode_integer(
            data,
            Some(0),
            Some(1799),
            false,
            self.zenith_ao_a as i128,
            false,
        )?;
        if let Some(x) = &self.lcs_to_gcs_translation {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl PerCodec for ZoAInformation {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        ZoAInformation::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ZoAInformation");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ZoAInformation");
            e
        })
    }
}
// LatitudeSign
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum LatitudeSign {
    North,
    South,
}

impl LatitudeSign {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(1), false)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(1),
            false,
            *self as i128,
            (*self as u32) >= 2,
        )
    }
}

impl PerCodec for LatitudeSign {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        LatitudeSign::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("LatitudeSign");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("LatitudeSign");
            e
        })
    }
}
// DirectionOfAltitude
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum DirectionOfAltitude {
    Height,
    Depth,
}

impl DirectionOfAltitude {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(1), false)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(1),
            false,
            *self as i128,
            (*self as u32) >= 2,
        )
    }
}

impl PerCodec for DirectionOfAltitude {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        DirectionOfAltitude::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DirectionOfAltitude");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DirectionOfAltitude");
            e
        })
    }
}
// SubcarrierSpacing1
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum SubcarrierSpacing1 {
    KHz15,
    KHz30,
    KHz60,
    KHz120,
    KHz480,
    KHz960,
}

impl SubcarrierSpacing1 {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(3), true)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(3),
            true,
            *self as i128,
            (*self as u32) >= 4,
        )
    }
}

impl PerCodec for SubcarrierSpacing1 {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        SubcarrierSpacing1::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SubcarrierSpacing1");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SubcarrierSpacing1");
            e
        })
    }
}
// CyclicPrefix
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum CyclicPrefix {
    Normal,
    Extended,
}

impl CyclicPrefix {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(1), false)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(1),
            false,
            *self as i128,
            (*self as u32) >= 2,
        )
    }
}

impl PerCodec for CyclicPrefix {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        CyclicPrefix::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CyclicPrefix");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CyclicPrefix");
            e
        })
    }
}
// Shift7dot5kHz
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum Shift7dot5kHz {
    True,
}

impl Shift7dot5kHz {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(0), true)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(0),
            true,
            *self as i128,
            (*self as u32) >= 1,
        )
    }
}

impl PerCodec for Shift7dot5kHz {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Shift7dot5kHz::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("Shift7dot5kHz");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("Shift7dot5kHz");
            e
        })
    }
}
// Resolution
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum Resolution {
    Deg0dot1,
}

impl Resolution {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(0), true)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(0),
            true,
            *self as i128,
            (*self as u32) >= 1,
        )
    }
}

impl PerCodec for Resolution {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Resolution::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("Resolution");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("Resolution");
            e
        })
    }
}
// DelayCritical
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum DelayCritical {
    DelayCritical,
    NonDelayCritical,
}

impl DelayCritical {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(1), false)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(1),
            false,
            *self as i128,
            (*self as u32) >= 2,
        )
    }
}

impl PerCodec for DelayCritical {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        DelayCritical::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DelayCritical");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DelayCritical");
            e
        })
    }
}
// ResourceType1
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum ResourceType1 {
    Gbr,
    NonGbr,
    DelayCriticalGrb,
}

impl ResourceType1 {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(2), true)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(2),
            true,
            *self as i128,
            (*self as u32) >= 3,
        )
    }
}

impl PerCodec for ResourceType1 {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        ResourceType1::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ResourceType1");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ResourceType1");
            e
        })
    }
}
// NrScs1
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum NrScs1 {
    Scs15,
    Scs30,
    Scs60,
    Scs120,
    Scs480,
    Scs960,
}

impl NrScs1 {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(3), true)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(3),
            true,
            *self as i128,
            (*self as u32) >= 4,
        )
    }
}

impl PerCodec for NrScs1 {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        NrScs1::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NrScs1");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NrScs1");
            e
        })
    }
}
// NrCp
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum NrCp {
    Normal,
    Extended,
}

impl NrCp {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(1), true)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(1),
            true,
            *self as i128,
            (*self as u32) >= 2,
        )
    }
}

impl PerCodec for NrCp {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        NrCp::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NrCp");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NrCp");
            e
        })
    }
}
// NrDlUlTxPeriodicity
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum NrDlUlTxPeriodicity {
    Ms0p5,
    Ms0p625,
    Ms1,
    Ms1p25,
    Ms2,
    Ms2p5,
    Ms3,
    Ms4,
    Ms5,
    Ms10,
    Ms20,
    Ms40,
    Ms60,
    Ms80,
    Ms100,
    Ms120,
    Ms140,
    Ms160,
}

impl NrDlUlTxPeriodicity {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(17), true)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(17),
            true,
            *self as i128,
            (*self as u32) >= 18,
        )
    }
}

impl PerCodec for NrDlUlTxPeriodicity {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        NrDlUlTxPeriodicity::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NrDlUlTxPeriodicity");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NrDlUlTxPeriodicity");
            e
        })
    }
}
// PrachScs
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum PrachScs {
    Scs15,
    Scs30,
    Scs60,
    Scs120,
    Scs480,
    Scs960,
}

impl PrachScs {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(3), true)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(3),
            true,
            *self as i128,
            (*self as u32) >= 4,
        )
    }
}

impl PerCodec for PrachScs {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PrachScs::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PrachScs");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PrachScs");
            e
        })
    }
}
// RestrictedSetConfig
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum RestrictedSetConfig {
    UnrestrictedSet,
    RestrictedSetTypeA,
    RestrictedSetTypeB,
}

impl RestrictedSetConfig {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(2), true)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(2),
            true,
            *self as i128,
            (*self as u32) >= 3,
        )
    }
}

impl PerCodec for RestrictedSetConfig {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        RestrictedSetConfig::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("RestrictedSetConfig");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("RestrictedSetConfig");
            e
        })
    }
}
// PrachScsForL571
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum PrachScsForL571 {
    Scs30,
    Scs120,
    Scs480,
}

impl PrachScsForL571 {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(1), true)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(1),
            true,
            *self as i128,
            (*self as u32) >= 2,
        )
    }
}

impl PerCodec for PrachScsForL571 {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PrachScsForL571::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PrachScsForL571");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PrachScsForL571");
            e
        })
    }
}
// PrachScsForL1151
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum PrachScsForL1151 {
    Scs15,
    Scs120,
}

impl PrachScsForL1151 {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(1), true)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(1),
            true,
            *self as i128,
            (*self as u32) >= 2,
        )
    }
}

impl PerCodec for PrachScsForL1151 {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PrachScsForL1151::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PrachScsForL1151");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PrachScsForL1151");
            e
        })
    }
}
// McF1uCtxtusage
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum McF1uCtxtusage {
    Ptm,
    Ptp,
    PtpRetransmission,
    PtpForwarding,
}

impl McF1uCtxtusage {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(3), true)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(3),
            true,
            *self as i128,
            (*self as u32) >= 4,
        )
    }
}

impl PerCodec for McF1uCtxtusage {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        McF1uCtxtusage::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("McF1uCtxtusage");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("McF1uCtxtusage");
            e
        })
    }
}
// MbsMulticastConfigurationRequest
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum MbsMulticastConfigurationRequest {
    Query,
}

impl MbsMulticastConfigurationRequest {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(0), true)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(0),
            true,
            *self as i128,
            (*self as u32) >= 1,
        )
    }
}

impl PerCodec for MbsMulticastConfigurationRequest {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        MbsMulticastConfigurationRequest::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MbsMulticastConfigurationRequest");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MbsMulticastConfigurationRequest");
            e
        })
    }
}
// MbsMulticastConfigurationNotavailable1
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum MbsMulticastConfigurationNotavailable1 {
    NotAvailable,
}

impl MbsMulticastConfigurationNotavailable1 {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(0), true)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(0),
            true,
            *self as i128,
            (*self as u32) >= 1,
        )
    }
}

impl PerCodec for MbsMulticastConfigurationNotavailable1 {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        MbsMulticastConfigurationNotavailable1::decode_inner(data).map_err(
            |mut e: PerCodecError| {
                e.push_context("MbsMulticastConfigurationNotavailable1");
                e
            },
        )
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MbsMulticastConfigurationNotavailable1");
            e
        })
    }
}
// PeerParentNodeIndicator
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum PeerParentNodeIndicator {
    True,
}

impl PeerParentNodeIndicator {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(0), true)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(0),
            true,
            *self as i128,
            (*self as u32) >= 1,
        )
    }
}

impl PerCodec for PeerParentNodeIndicator {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PeerParentNodeIndicator::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PeerParentNodeIndicator");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PeerParentNodeIndicator");
            e
        })
    }
}
// PrachFdm
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum PrachFdm {
    One,
    Two,
    Four,
    Eight,
}

impl PrachFdm {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(3), true)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(3),
            true,
            *self as i128,
            (*self as u32) >= 4,
        )
    }
}

impl PerCodec for PrachFdm {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PrachFdm::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PrachFdm");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PrachFdm");
            e
        })
    }
}
// SsbPerRachOccasion
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum SsbPerRachOccasion {
    OneEighth,
    OneFourth,
    OneHalf,
    One,
    Two,
    Four,
    Eight,
    Sixteen,
}

impl SsbPerRachOccasion {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(7), true)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(7),
            true,
            *self as i128,
            (*self as u32) >= 8,
        )
    }
}

impl PerCodec for SsbPerRachOccasion {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        SsbPerRachOccasion::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SsbPerRachOccasion");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SsbPerRachOccasion");
            e
        })
    }
}
// Bandwidth
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum Bandwidth {
    MHz10,
    MHz20,
    MHz40,
    MHz60,
    MHz80,
    MHz100,
}

impl Bandwidth {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(4), true)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(4),
            true,
            *self as i128,
            (*self as u32) >= 5,
        )
    }
}

impl PerCodec for Bandwidth {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Bandwidth::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("Bandwidth");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("Bandwidth");
            e
        })
    }
}
// T420
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum T420 {
    Ms50,
    Ms100,
    Ms150,
    Ms200,
    Ms500,
    Ms1000,
    Ms2000,
    Ms10000,
}

impl T420 {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(7), false)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(7),
            false,
            *self as i128,
            (*self as u32) >= 8,
        )
    }
}

impl PerCodec for T420 {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        T420::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("T420");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("T420");
            e
        })
    }
}
// Pc5ControlPlaneTrafficType
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum Pc5ControlPlaneTrafficType {
    Srb1,
    Srb2,
}

impl Pc5ControlPlaneTrafficType {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(1), true)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(1),
            true,
            *self as i128,
            (*self as u32) >= 2,
        )
    }
}

impl PerCodec for Pc5ControlPlaneTrafficType {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Pc5ControlPlaneTrafficType::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("Pc5ControlPlaneTrafficType");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("Pc5ControlPlaneTrafficType");
            e
        })
    }
}
// PosperiodicSet
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum PosperiodicSet {
    True,
}

impl PosperiodicSet {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(0), true)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(0),
            true,
            *self as i128,
            (*self as u32) >= 1,
        )
    }
}

impl PerCodec for PosperiodicSet {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PosperiodicSet::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PosperiodicSet");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PosperiodicSet");
            e
        })
    }
}
// PossemiPersistentSet
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum PossemiPersistentSet {
    True,
}

impl PossemiPersistentSet {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(0), true)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(0),
            true,
            *self as i128,
            (*self as u32) >= 1,
        )
    }
}

impl PerCodec for PossemiPersistentSet {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PossemiPersistentSet::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PossemiPersistentSet");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PossemiPersistentSet");
            e
        })
    }
}
// NrofSymbols
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum NrofSymbols {
    N1,
    N2,
    N4,
    N8,
    N12,
}

impl NrofSymbols {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(4), false)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(4),
            false,
            *self as i128,
            (*self as u32) >= 5,
        )
    }
}

impl PerCodec for NrofSymbols {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        NrofSymbols::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NrofSymbols");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NrofSymbols");
            e
        })
    }
}
// GroupOrSequenceHopping
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum GroupOrSequenceHopping {
    Neither,
    GroupHopping,
    SequenceHopping,
}

impl GroupOrSequenceHopping {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(2), false)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(2),
            false,
            *self as i128,
            (*self as u32) >= 3,
        )
    }
}

impl PerCodec for GroupOrSequenceHopping {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        GroupOrSequenceHopping::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("GroupOrSequenceHopping");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("GroupOrSequenceHopping");
            e
        })
    }
}
// MeasPrsPeriodicity
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum MeasPrsPeriodicity {
    Ms20,
    Ms40,
    Ms80,
    Ms160,
}

impl MeasPrsPeriodicity {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(3), true)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(3),
            true,
            *self as i128,
            (*self as u32) >= 4,
        )
    }
}

impl PerCodec for MeasPrsPeriodicity {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        MeasPrsPeriodicity::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MeasPrsPeriodicity");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MeasPrsPeriodicity");
            e
        })
    }
}
// MeasurementPrsLength
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum MeasurementPrsLength {
    Ms1dot5,
    Ms3,
    Ms3dot5,
    Ms4,
    Ms5dot5,
    Ms6,
    Ms10,
    Ms20,
}

impl MeasurementPrsLength {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(7), false)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(7),
            false,
            *self as i128,
            (*self as u32) >= 8,
        )
    }
}

impl PerCodec for MeasurementPrsLength {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        MeasurementPrsLength::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MeasurementPrsLength");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MeasurementPrsLength");
            e
        })
    }
}
// MutingBitRepetitionFactor
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum MutingBitRepetitionFactor {
    Rf1,
    Rf2,
    Rf4,
    Rf8,
}

impl MutingBitRepetitionFactor {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(3), true)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(3),
            true,
            *self as i128,
            (*self as u32) >= 4,
        )
    }
}

impl PerCodec for MutingBitRepetitionFactor {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        MutingBitRepetitionFactor::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MutingBitRepetitionFactor");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MutingBitRepetitionFactor");
            e
        })
    }
}
// SubcarrierSpacing2
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum SubcarrierSpacing2 {
    KHz15,
    KHz30,
    KHz60,
    KHz120,
}

impl SubcarrierSpacing2 {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(3), true)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(3),
            true,
            *self as i128,
            (*self as u32) >= 4,
        )
    }
}

impl PerCodec for SubcarrierSpacing2 {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        SubcarrierSpacing2::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SubcarrierSpacing2");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SubcarrierSpacing2");
            e
        })
    }
}
// CombSize
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum CombSize {
    N2,
    N4,
    N6,
    N12,
}

impl CombSize {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(3), true)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(3),
            true,
            *self as i128,
            (*self as u32) >= 4,
        )
    }
}

impl PerCodec for CombSize {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        CombSize::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CombSize");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CombSize");
            e
        })
    }
}
// CpType
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum CpType {
    Normal,
    Extended,
}

impl CpType {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(1), true)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(1),
            true,
            *self as i128,
            (*self as u32) >= 2,
        )
    }
}

impl PerCodec for CpType {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        CpType::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CpType");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CpType");
            e
        })
    }
}
// ResourceSetPeriodicity
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum ResourceSetPeriodicity {
    N4,
    N5,
    N8,
    N10,
    N16,
    N20,
    N32,
    N40,
    N64,
    N80,
    N160,
    N320,
    N640,
    N1280,
    N2560,
    N5120,
    N10240,
    N20480,
    N40960,
    N81920,
    N128,
    N256,
    N512,
}

impl ResourceSetPeriodicity {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(19), true)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(19),
            true,
            *self as i128,
            (*self as u32) >= 20,
        )
    }
}

impl PerCodec for ResourceSetPeriodicity {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        ResourceSetPeriodicity::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ResourceSetPeriodicity");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ResourceSetPeriodicity");
            e
        })
    }
}
// ResourceRepetitionFactor
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum ResourceRepetitionFactor {
    Rf1,
    Rf2,
    Rf4,
    Rf6,
    Rf8,
    Rf16,
    Rf32,
}

impl ResourceRepetitionFactor {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(6), true)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(6),
            true,
            *self as i128,
            (*self as u32) >= 7,
        )
    }
}

impl PerCodec for ResourceRepetitionFactor {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        ResourceRepetitionFactor::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ResourceRepetitionFactor");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ResourceRepetitionFactor");
            e
        })
    }
}
// ResourceTimeGap
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum ResourceTimeGap {
    Tg1,
    Tg2,
    Tg4,
    Tg8,
    Tg16,
    Tg32,
}

impl ResourceTimeGap {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(5), true)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(5),
            true,
            *self as i128,
            (*self as u32) >= 6,
        )
    }
}

impl PerCodec for ResourceTimeGap {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        ResourceTimeGap::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ResourceTimeGap");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ResourceTimeGap");
            e
        })
    }
}
// ResourceNumberofSymbols
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum ResourceNumberofSymbols {
    N2,
    N4,
    N6,
    N12,
    N1,
}

impl ResourceNumberofSymbols {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(3), true)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(3),
            true,
            *self as i128,
            (*self as u32) >= 4,
        )
    }
}

impl PerCodec for ResourceNumberofSymbols {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        ResourceNumberofSymbols::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ResourceNumberofSymbols");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ResourceNumberofSymbols");
            e
        })
    }
}
// CombSize1
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum CombSize1 {
    N2,
    N4,
    N6,
    N12,
}

impl CombSize1 {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(3), true)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(3),
            true,
            *self as i128,
            (*self as u32) >= 4,
        )
    }
}

impl PerCodec for CombSize1 {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        CombSize1::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CombSize1");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CombSize1");
            e
        })
    }
}
// ResourceSetPeriodicity1
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum ResourceSetPeriodicity1 {
    N4,
    N5,
    N8,
    N10,
    N16,
    N20,
    N32,
    N40,
    N64,
    N80,
    N160,
    N320,
    N640,
    N1280,
    N2560,
    N5120,
    N10240,
    N20480,
    N40960,
    N81920,
    N128,
    N256,
    N512,
}

impl ResourceSetPeriodicity1 {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(19), true)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(19),
            true,
            *self as i128,
            (*self as u32) >= 20,
        )
    }
}

impl PerCodec for ResourceSetPeriodicity1 {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        ResourceSetPeriodicity1::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ResourceSetPeriodicity1");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ResourceSetPeriodicity1");
            e
        })
    }
}
// ResourceRepetitionFactor1
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum ResourceRepetitionFactor1 {
    Rf1,
    Rf2,
    Rf4,
    Rf6,
    Rf8,
    Rf16,
    Rf32,
}

impl ResourceRepetitionFactor1 {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(6), true)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(6),
            true,
            *self as i128,
            (*self as u32) >= 7,
        )
    }
}

impl PerCodec for ResourceRepetitionFactor1 {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        ResourceRepetitionFactor1::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ResourceRepetitionFactor1");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ResourceRepetitionFactor1");
            e
        })
    }
}
// ResourceNumberofSymbols1
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum ResourceNumberofSymbols1 {
    N2,
    N4,
    N6,
    N12,
    N1,
}

impl ResourceNumberofSymbols1 {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(3), true)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(3),
            true,
            *self as i128,
            (*self as u32) >= 4,
        )
    }
}

impl PerCodec for ResourceNumberofSymbols1 {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        ResourceNumberofSymbols1::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ResourceNumberofSymbols1");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ResourceNumberofSymbols1");
            e
        })
    }
}
// PduSetIntegratedHandlingInformation
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum PduSetIntegratedHandlingInformation {
    True,
    False,
}

impl PduSetIntegratedHandlingInformation {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(1), true)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(1),
            true,
            *self as i128,
            (*self as u32) >= 2,
        )
    }
}

impl PerCodec for PduSetIntegratedHandlingInformation {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PduSetIntegratedHandlingInformation::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PduSetIntegratedHandlingInformation");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PduSetIntegratedHandlingInformation");
            e
        })
    }
}
// ReflectiveQosAttribute
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum ReflectiveQosAttribute {
    SubjectTo,
}

impl ReflectiveQosAttribute {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(0), true)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(0),
            true,
            *self as i128,
            (*self as u32) >= 1,
        )
    }
}

impl PerCodec for ReflectiveQosAttribute {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        ReflectiveQosAttribute::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ReflectiveQosAttribute");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ReflectiveQosAttribute");
            e
        })
    }
}
// CapabilityForBatAdaptation
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum CapabilityForBatAdaptation {
    True,
}

impl CapabilityForBatAdaptation {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(0), true)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(0),
            true,
            *self as i128,
            (*self as u32) >= 1,
        )
    }
}

impl PerCodec for CapabilityForBatAdaptation {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        CapabilityForBatAdaptation::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CapabilityForBatAdaptation");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("CapabilityForBatAdaptation");
            e
        })
    }
}
// Synchronisationstate
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum Synchronisationstate {
    Locked,
    Holdover,
    FreeRun,
}

impl Synchronisationstate {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(2), true)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(2),
            true,
            *self as i128,
            (*self as u32) >= 3,
        )
    }
}

impl PerCodec for Synchronisationstate {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Synchronisationstate::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("Synchronisationstate");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("Synchronisationstate");
            e
        })
    }
}
// TraceabletoUtc
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum TraceabletoUtc {
    True,
    False,
}

impl TraceabletoUtc {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(1), true)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(1),
            true,
            *self as i128,
            (*self as u32) >= 2,
        )
    }
}

impl PerCodec for TraceabletoUtc {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        TraceabletoUtc::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TraceabletoUtc");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TraceabletoUtc");
            e
        })
    }
}
// TraceabletoGnss
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum TraceabletoGnss {
    True,
    False,
}

impl TraceabletoGnss {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(1), true)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(1),
            true,
            *self as i128,
            (*self as u32) >= 2,
        )
    }
}

impl PerCodec for TraceabletoGnss {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        TraceabletoGnss::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TraceabletoGnss");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TraceabletoGnss");
            e
        })
    }
}
// XyZunit
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum XyZunit {
    Mm,
    Cm,
    Dm,
}

impl XyZunit {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(2), true)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(2),
            true,
            *self as i128,
            (*self as u32) >= 3,
        )
    }
}

impl PerCodec for XyZunit {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        XyZunit::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("XyZunit");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("XyZunit");
            e
        })
    }
}
// MilliArcSecondUnits
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum MilliArcSecondUnits {
    Zerodot03,
    Zerodot3,
    Three,
}

impl MilliArcSecondUnits {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(2), true)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(2),
            true,
            *self as i128,
            (*self as u32) >= 3,
        )
    }
}

impl PerCodec for MilliArcSecondUnits {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        MilliArcSecondUnits::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MilliArcSecondUnits");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MilliArcSecondUnits");
            e
        })
    }
}
// HeightUnits
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum HeightUnits {
    Mm,
    Cm,
    M,
}

impl HeightUnits {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(2), true)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(2),
            true,
            *self as i128,
            (*self as u32) >= 3,
        )
    }
}

impl PerCodec for HeightUnits {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        HeightUnits::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("HeightUnits");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("HeightUnits");
            e
        })
    }
}
// ResourceType2
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum ResourceType2 {
    Periodic,
    SemiPersistent,
    Aperiodic,
}

impl ResourceType2 {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(2), true)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(2),
            true,
            *self as i128,
            (*self as u32) >= 3,
        )
    }
}

impl PerCodec for ResourceType2 {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        ResourceType2::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ResourceType2");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ResourceType2");
            e
        })
    }
}
// NrofSumbols
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum NrofSumbols {
    N1,
    N2,
    N4,
    N8,
    N12,
}

impl NrofSumbols {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(4), false)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(4),
            false,
            *self as i128,
            (*self as u32) >= 5,
        )
    }
}

impl PerCodec for NrofSumbols {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        NrofSumbols::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NrofSumbols");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NrofSumbols");
            e
        })
    }
}
// PeriodicSet
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum PeriodicSet {
    True,
}

impl PeriodicSet {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(0), true)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(0),
            true,
            *self as i128,
            (*self as u32) >= 1,
        )
    }
}

impl PerCodec for PeriodicSet {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PeriodicSet::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PeriodicSet");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PeriodicSet");
            e
        })
    }
}
// SemiPersistentSet
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum SemiPersistentSet {
    True,
}

impl SemiPersistentSet {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(0), true)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(0),
            true,
            *self as i128,
            (*self as u32) >= 1,
        )
    }
}

impl PerCodec for SemiPersistentSet {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        SemiPersistentSet::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SemiPersistentSet");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SemiPersistentSet");
            e
        })
    }
}
// Periodicity1
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum Periodicity1 {
    Slot1,
    Slot2,
    Slot4,
    Slot5,
    Slot8,
    Slot10,
    Slot16,
    Slot20,
    Slot32,
    Slot40,
    Slot64,
    Slot80,
    Slot160,
    Slot320,
    Slot640,
    Slot1280,
    Slot2560,
}

impl Periodicity1 {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(16), true)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(16),
            true,
            *self as i128,
            (*self as u32) >= 17,
        )
    }
}

impl PerCodec for Periodicity1 {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Periodicity1::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("Periodicity1");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("Periodicity1");
            e
        })
    }
}
// Periodicity2
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum Periodicity2 {
    Slot1,
    Slot2,
    Slot4,
    Slot5,
    Slot8,
    Slot10,
    Slot16,
    Slot20,
    Slot32,
    Slot40,
    Slot64,
    Slot80,
    Slot160,
    Slot320,
    Slot640,
    Slot1280,
    Slot2560,
}

impl Periodicity2 {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(16), true)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(16),
            true,
            *self as i128,
            (*self as u32) >= 17,
        )
    }
}

impl PerCodec for Periodicity2 {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Periodicity2::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("Periodicity2");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("Periodicity2");
            e
        })
    }
}
// AperiodicResourceType
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum AperiodicResourceType {
    True,
}

impl AperiodicResourceType {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(0), true)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(0),
            true,
            *self as i128,
            (*self as u32) >= 1,
        )
    }
}

impl PerCodec for AperiodicResourceType {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        AperiodicResourceType::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("AperiodicResourceType");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("AperiodicResourceType");
            e
        })
    }
}
// TimeUnit
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum TimeUnit {
    Second,
    TenSeconds,
    TenMilliseconds,
}

impl TimeUnit {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(2), true)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(2),
            true,
            *self as i128,
            (*self as u32) >= 3,
        )
    }
}

impl PerCodec for TimeUnit {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        TimeUnit::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TimeUnit");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TimeUnit");
            e
        })
    }
}
// SubcarrierSpacing3
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum SubcarrierSpacing3 {
    KHz15,
    KHz30,
    KHz60,
    KHz120,
    KHz480,
    KHz960,
}

impl SubcarrierSpacing3 {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(3), true)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(3),
            true,
            *self as i128,
            (*self as u32) >= 4,
        )
    }
}

impl PerCodec for SubcarrierSpacing3 {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        SubcarrierSpacing3::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SubcarrierSpacing3");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SubcarrierSpacing3");
            e
        })
    }
}
// SdtIndicator
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum SdtIndicator {
    True,
}

impl SdtIndicator {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(0), true)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(0),
            true,
            *self as i128,
            (*self as u32) >= 1,
        )
    }
}

impl PerCodec for SdtIndicator {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        SdtIndicator::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SdtIndicator");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SdtIndicator");
            e
        })
    }
}
// SdtAssistantInformation
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum SdtAssistantInformation {
    Singlepacket,
    Multiplepackets,
}

impl SdtAssistantInformation {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(1), true)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(1),
            true,
            *self as i128,
            (*self as u32) >= 2,
        )
    }
}

impl PerCodec for SdtAssistantInformation {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        SdtAssistantInformation::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SdtAssistantInformation");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SdtAssistantInformation");
            e
        })
    }
}
// SwitchingOffOngoing
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum SwitchingOffOngoing {
    True,
}

impl SwitchingOffOngoing {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(0), true)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(0),
            true,
            *self as i128,
            (*self as u32) >= 1,
        )
    }
}

impl PerCodec for SwitchingOffOngoing {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        SwitchingOffOngoing::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SwitchingOffOngoing");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SwitchingOffOngoing");
            e
        })
    }
}
// NrofSrsPorts
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum NrofSrsPorts {
    Port1,
    Ports2,
    Ports4,
}

impl NrofSrsPorts {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(2), false)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(2),
            false,
            *self as i128,
            (*self as u32) >= 3,
        )
    }
}

impl PerCodec for NrofSrsPorts {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        NrofSrsPorts::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NrofSrsPorts");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NrofSrsPorts");
            e
        })
    }
}
// NrofSymbols1
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum NrofSymbols1 {
    N1,
    N2,
    N4,
}

impl NrofSymbols1 {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(2), false)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(2),
            false,
            *self as i128,
            (*self as u32) >= 3,
        )
    }
}

impl PerCodec for NrofSymbols1 {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        NrofSymbols1::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NrofSymbols1");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("NrofSymbols1");
            e
        })
    }
}
// RepetitionFactor
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum RepetitionFactor {
    N1,
    N2,
    N4,
}

impl RepetitionFactor {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(2), false)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(2),
            false,
            *self as i128,
            (*self as u32) >= 3,
        )
    }
}

impl PerCodec for RepetitionFactor {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        RepetitionFactor::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("RepetitionFactor");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("RepetitionFactor");
            e
        })
    }
}
// GroupOrSequenceHopping1
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum GroupOrSequenceHopping1 {
    Neither,
    GroupHopping,
    SequenceHopping,
}

impl GroupOrSequenceHopping1 {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(2), false)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(2),
            false,
            *self as i128,
            (*self as u32) >= 3,
        )
    }
}

impl PerCodec for GroupOrSequenceHopping1 {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        GroupOrSequenceHopping1::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("GroupOrSequenceHopping1");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("GroupOrSequenceHopping1");
            e
        })
    }
}
// SsbSubcarrierSpacing1
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum SsbSubcarrierSpacing1 {
    KHz15,
    KHz30,
    KHz60,
    KHz120,
    KHz240,
    KHz480,
    KHz960,
}

impl SsbSubcarrierSpacing1 {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(4), true)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(4),
            true,
            *self as i128,
            (*self as u32) >= 5,
        )
    }
}

impl PerCodec for SsbSubcarrierSpacing1 {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        SsbSubcarrierSpacing1::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SsbSubcarrierSpacing1");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SsbSubcarrierSpacing1");
            e
        })
    }
}
// SsbPeriodicity
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum SsbPeriodicity {
    Ms5,
    Ms10,
    Ms20,
    Ms40,
    Ms80,
    Ms160,
}

impl SsbPeriodicity {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(5), true)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(5),
            true,
            *self as i128,
            (*self as u32) >= 6,
        )
    }
}

impl PerCodec for SsbPeriodicity {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        SsbPeriodicity::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SsbPeriodicity");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SsbPeriodicity");
            e
        })
    }
}
// SupportedUeType
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum SupportedUeType {
    NonRedcapEredcapUe,
    RedcapEredcapUe,
}

impl SupportedUeType {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(1), true)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(1),
            true,
            *self as i128,
            (*self as u32) >= 2,
        )
    }
}

impl PerCodec for SupportedUeType {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        SupportedUeType::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SupportedUeType");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("SupportedUeType");
            e
        })
    }
}
// Resolution1
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum Resolution1 {
    M0dot1,
    M1,
    M10,
    M30,
}

impl Resolution1 {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(3), true)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(3),
            true,
            *self as i128,
            (*self as u32) >= 4,
        )
    }
}

impl PerCodec for Resolution1 {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        Resolution1::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("Resolution1");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("Resolution1");
            e
        })
    }
}
// TimeWindowType
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum TimeWindowType {
    Single,
    Periodic,
}

impl TimeWindowType {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(1), true)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(1),
            true,
            *self as i128,
            (*self as u32) >= 2,
        )
    }
}

impl PerCodec for TimeWindowType {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        TimeWindowType::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TimeWindowType");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TimeWindowType");
            e
        })
    }
}
// TimeWindowType1
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum TimeWindowType1 {
    Single,
    Periodic,
}

impl TimeWindowType1 {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(1), true)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(1),
            true,
            *self as i128,
            (*self as u32) >= 2,
        )
    }
}

impl PerCodec for TimeWindowType1 {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        TimeWindowType1::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TimeWindowType1");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("TimeWindowType1");
            e
        })
    }
}
// DurationSlots
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum DurationSlots {
    N1,
    N2,
    N4,
    N6,
    N8,
    N12,
    N16,
}

impl DurationSlots {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(6), true)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(6),
            true,
            *self as i128,
            (*self as u32) >= 7,
        )
    }
}

impl PerCodec for DurationSlots {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        DurationSlots::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DurationSlots");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DurationSlots");
            e
        })
    }
}
// DurationSymbols
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum DurationSymbols {
    N1,
    N2,
    N4,
    N8,
    N12,
}

impl DurationSymbols {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(4), true)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(4),
            true,
            *self as i128,
            (*self as u32) >= 5,
        )
    }
}

impl PerCodec for DurationSymbols {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        DurationSymbols::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DurationSymbols");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DurationSymbols");
            e
        })
    }
}
// DurationSlots1
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum DurationSlots1 {
    N1,
    N2,
    N4,
    N6,
    N8,
    N12,
    N16,
}

impl DurationSlots1 {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(6), true)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(6),
            true,
            *self as i128,
            (*self as u32) >= 7,
        )
    }
}

impl PerCodec for DurationSlots1 {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        DurationSlots1::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DurationSlots1");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("DurationSlots1");
            e
        })
    }
}
// N2
#[derive(Clone, Debug)]
pub struct N2 {
    pub comb_offset_n_2: u8,
    pub cyclic_shift_n_2: u8,
}

impl N2 {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (_optionals, _extensions_present) = decode::decode_sequence_header(data, false, 0)?;
        let comb_offset_n_2 = decode::decode_integer(data, Some(0), Some(1), false)?.0 as u8;
        let cyclic_shift_n_2 = decode::decode_integer(data, Some(0), Some(7), false)?.0 as u8;

        Ok(Self {
            comb_offset_n_2,
            cyclic_shift_n_2,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let optionals = BitString::new();

        encode::encode_sequence_header(data, false, &optionals, false)?;
        encode::encode_integer(
            data,
            Some(0),
            Some(1),
            false,
            self.comb_offset_n_2 as i128,
            false,
        )?;
        encode::encode_integer(
            data,
            Some(0),
            Some(7),
            false,
            self.cyclic_shift_n_2 as i128,
            false,
        )?;

        Ok(())
    }
}

impl PerCodec for N2 {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        N2::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("N2");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("N2");
            e
        })
    }
}
// N4
#[derive(Clone, Debug)]
pub struct N4 {
    pub comb_offset_n_4: u8,
    pub cyclic_shift_n_4: u8,
}

impl N4 {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (_optionals, _extensions_present) = decode::decode_sequence_header(data, false, 0)?;
        let comb_offset_n_4 = decode::decode_integer(data, Some(0), Some(3), false)?.0 as u8;
        let cyclic_shift_n_4 = decode::decode_integer(data, Some(0), Some(11), false)?.0 as u8;

        Ok(Self {
            comb_offset_n_4,
            cyclic_shift_n_4,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let optionals = BitString::new();

        encode::encode_sequence_header(data, false, &optionals, false)?;
        encode::encode_integer(
            data,
            Some(0),
            Some(3),
            false,
            self.comb_offset_n_4 as i128,
            false,
        )?;
        encode::encode_integer(
            data,
            Some(0),
            Some(11),
            false,
            self.cyclic_shift_n_4 as i128,
            false,
        )?;

        Ok(())
    }
}

impl PerCodec for N4 {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        N4::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("N4");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("N4");
            e
        })
    }
}
// N2_1
#[derive(Clone, Debug)]
pub struct N2_1 {
    pub comb_offset_n_2: u8,
    pub cyclic_shift_n_2: u8,
}

impl N2_1 {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (_optionals, _extensions_present) = decode::decode_sequence_header(data, false, 0)?;
        let comb_offset_n_2 = decode::decode_integer(data, Some(0), Some(1), false)?.0 as u8;
        let cyclic_shift_n_2 = decode::decode_integer(data, Some(0), Some(7), false)?.0 as u8;

        Ok(Self {
            comb_offset_n_2,
            cyclic_shift_n_2,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let optionals = BitString::new();

        encode::encode_sequence_header(data, false, &optionals, false)?;
        encode::encode_integer(
            data,
            Some(0),
            Some(1),
            false,
            self.comb_offset_n_2 as i128,
            false,
        )?;
        encode::encode_integer(
            data,
            Some(0),
            Some(7),
            false,
            self.cyclic_shift_n_2 as i128,
            false,
        )?;

        Ok(())
    }
}

impl PerCodec for N2_1 {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        N2_1::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("N2_1");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("N2_1");
            e
        })
    }
}
// N4_1
#[derive(Clone, Debug)]
pub struct N4_1 {
    pub comb_offset_n_4: u8,
    pub cyclic_shift_n_4: u8,
}

impl N4_1 {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (_optionals, _extensions_present) = decode::decode_sequence_header(data, false, 0)?;
        let comb_offset_n_4 = decode::decode_integer(data, Some(0), Some(3), false)?.0 as u8;
        let cyclic_shift_n_4 = decode::decode_integer(data, Some(0), Some(11), false)?.0 as u8;

        Ok(Self {
            comb_offset_n_4,
            cyclic_shift_n_4,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let optionals = BitString::new();

        encode::encode_sequence_header(data, false, &optionals, false)?;
        encode::encode_integer(
            data,
            Some(0),
            Some(3),
            false,
            self.comb_offset_n_4 as i128,
            false,
        )?;
        encode::encode_integer(
            data,
            Some(0),
            Some(11),
            false,
            self.cyclic_shift_n_4 as i128,
            false,
        )?;

        Ok(())
    }
}

impl PerCodec for N4_1 {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        N4_1::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("N4_1");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("N4_1");
            e
        })
    }
}
// N8
#[derive(Clone, Debug)]
pub struct N8 {
    pub comb_offset_n_8: u8,
    pub cyclic_shift_n_8: u8,
}

impl N8 {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (_optionals, _extensions_present) = decode::decode_sequence_header(data, false, 0)?;
        let comb_offset_n_8 = decode::decode_integer(data, Some(0), Some(7), false)?.0 as u8;
        let cyclic_shift_n_8 = decode::decode_integer(data, Some(0), Some(5), false)?.0 as u8;

        Ok(Self {
            comb_offset_n_8,
            cyclic_shift_n_8,
        })
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        let optionals = BitString::new();

        encode::encode_sequence_header(data, false, &optionals, false)?;
        encode::encode_integer(
            data,
            Some(0),
            Some(7),
            false,
            self.comb_offset_n_8 as i128,
            false,
        )?;
        encode::encode_integer(
            data,
            Some(0),
            Some(5),
            false,
            self.cyclic_shift_n_8 as i128,
            false,
        )?;

        Ok(())
    }
}

impl PerCodec for N8 {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        N8::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("N8");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("N8");
            e
        })
    }
}
// PhaseQualityResolution
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum PhaseQualityResolution {
    Deg0dot1,
    Deg1,
}

impl PhaseQualityResolution {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(1), true)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(1),
            true,
            *self as i128,
            (*self as u32) >= 2,
        )
    }
}

impl PerCodec for PhaseQualityResolution {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        PhaseQualityResolution::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PhaseQualityResolution");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("PhaseQualityResolution");
            e
        })
    }
}
// OverlapValue
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum OverlapValue {
    Rb0,
    Rb1,
    Rb2,
    Rb4,
}

impl OverlapValue {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(3), false)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(3),
            false,
            *self as i128,
            (*self as u32) >= 4,
        )
    }
}

impl PerCodec for OverlapValue {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        OverlapValue::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("OverlapValue");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("OverlapValue");
            e
        })
    }
}
// MrbTypeReconfiguration
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum MrbTypeReconfiguration {
    True,
}

impl MrbTypeReconfiguration {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(0), true)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(0),
            true,
            *self as i128,
            (*self as u32) >= 1,
        )
    }
}

impl PerCodec for MrbTypeReconfiguration {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        MrbTypeReconfiguration::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MrbTypeReconfiguration");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MrbTypeReconfiguration");
            e
        })
    }
}
// MrbReconfiguredRlcType
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum MrbReconfiguredRlcType {
    RlcUmPtp,
    RlcAmPtp,
    RlcUmDlPtm,
    TwoRlcUmDlPtpAndDlPtm,
    ThreeRlcUmDlPtpUlPtpDlPtm,
    TwoRlcAmPtpUmDlPtm,
}

impl MrbReconfiguredRlcType {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(5), true)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(5),
            true,
            *self as i128,
            (*self as u32) >= 6,
        )
    }
}

impl PerCodec for MrbReconfiguredRlcType {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        MrbReconfiguredRlcType::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MrbReconfiguredRlcType");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("MrbReconfiguredRlcType");
            e
        })
    }
}
// InactiveStatePoDetermination
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum InactiveStatePoDetermination {
    Supported,
}

impl InactiveStatePoDetermination {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(0), true)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(0),
            true,
            *self as i128,
            (*self as u32) >= 1,
        )
    }
}

impl PerCodec for InactiveStatePoDetermination {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        InactiveStatePoDetermination::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("InactiveStatePoDetermination");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("InactiveStatePoDetermination");
            e
        })
    }
}
// ReportingAmount
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum ReportingAmount {
    Ma0,
    Ma1,
    Ma2,
    Ma4,
    Ma8,
    Ma16,
    Ma32,
    Ma64,
}

impl ReportingAmount {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(7), false)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(7),
            false,
            *self as i128,
            (*self as u32) >= 8,
        )
    }
}

impl PerCodec for ReportingAmount {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        ReportingAmount::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ReportingAmount");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ReportingAmount");
            e
        })
    }
}
// ReportingInterval
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum ReportingInterval {
    None,
    One,
    Two,
    Four,
    Eight,
    Ten,
    Sixteen,
    Twenty,
    ThirtyTwo,
    SixtyFour,
}

impl ReportingInterval {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(9), true)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(9),
            true,
            *self as i128,
            (*self as u32) >= 10,
        )
    }
}

impl PerCodec for ReportingInterval {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        ReportingInterval::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ReportingInterval");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("ReportingInterval");
            e
        })
    }
}
// UuControlPlaneTrafficType
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u32)]
pub enum UuControlPlaneTrafficType {
    Srb0,
    Srb1,
    Srb2,
}

impl UuControlPlaneTrafficType {
    fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        let (idx, _extended) = decode::decode_enumerated(data, Some(0), Some(2), true)?;
        Self::try_from(idx as u32).map_err(|_| per_codec_error_new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        encode::encode_enumerated(
            data,
            Some(0),
            Some(2),
            true,
            *self as i128,
            (*self as u32) >= 3,
        )
    }
}

impl PerCodec for UuControlPlaneTrafficType {
    type Allocator = Allocator;
    fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
        UuControlPlaneTrafficType::decode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UuControlPlaneTrafficType");
            e
        })
    }
    fn encode(&self, data: &mut PerCodecData) -> Result<(), PerCodecError> {
        self.encode_inner(data).map_err(|mut e: PerCodecError| {
            e.push_context("UuControlPlaneTrafficType");
            e
        })
    }
}
