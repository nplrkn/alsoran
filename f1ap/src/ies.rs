// Autogenerated from F1AP-IEs.asn
use super::common::*;
use asn1_codecs::aper::{self, AperCodec, AperCodecData, AperCodecError};
use bitvec::prelude::*;
#[allow(dead_code)]
pub type BitString = BitVec<Msb0, u8>;
#[allow(unused_imports)]
use num_enum::TryFromPrimitive;

// AbortTransmission
#[derive(Clone, Debug)]
pub enum AbortTransmission {
    SrsResourceSetId(SrsResourceSetId),
    ReleaseAll,
}

impl AbortTransmission {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (idx, extended) = aper::decode::decode_choice_idx(data, 0, 2, false)?;
        if extended {
            return Err(aper::AperCodecError::new(
                "CHOICE additions not implemented",
            ));
        }
        match idx {
            0 => Ok(Self::SrsResourceSetId(SrsResourceSetId::decode(data)?)),
            1 => Ok(Self::ReleaseAll),
            2 => Err(AperCodecError::new(
                "Choice extension container not implemented",
            )),
            _ => Err(AperCodecError::new("Unknown choice idx")),
        }
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        match self {
            Self::SrsResourceSetId(x) => {
                aper::encode::encode_choice_idx(data, 0, 2, false, 0, false)?;
                x.encode(data)
            }
            Self::ReleaseAll => {
                aper::encode::encode_choice_idx(data, 0, 2, false, 1, false)?;
                Ok(())
            }
        }
    }
}

impl AperCodec for AbortTransmission {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        AbortTransmission::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("AbortTransmission"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("AbortTransmission"))
    }
}
// AccessPointPosition
#[derive(Clone, Debug)]
pub struct AccessPointPosition {
    pub latitude_sign: LatitudeSign,
    pub latitude: u32,
    pub longitude: i32,
    pub direction_of_altitude: DirectionOfAltitude,
    pub altitude: u16,
    pub uncertainty_semi_major: u8,
    pub uncertainty_semi_minor: u8,
    pub orientation_of_major_axis: u8,
    pub uncertainty_altitude: u8,
    pub confidence: u8,
}

impl AccessPointPosition {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (_optionals, _extensions_present) =
            aper::decode::decode_sequence_header(data, false, 1)?;
        let latitude_sign = LatitudeSign::decode(data)?;
        let latitude = aper::decode::decode_integer(data, Some(0), Some(8388607), false)?.0 as u32;
        let longitude =
            aper::decode::decode_integer(data, Some(-8388608), Some(8388607), false)?.0 as i32;
        let direction_of_altitude = DirectionOfAltitude::decode(data)?;
        let altitude = aper::decode::decode_integer(data, Some(0), Some(32767), false)?.0 as u16;
        let uncertainty_semi_major =
            aper::decode::decode_integer(data, Some(0), Some(127), false)?.0 as u8;
        let uncertainty_semi_minor =
            aper::decode::decode_integer(data, Some(0), Some(127), false)?.0 as u8;
        let orientation_of_major_axis =
            aper::decode::decode_integer(data, Some(0), Some(179), false)?.0 as u8;
        let uncertainty_altitude =
            aper::decode::decode_integer(data, Some(0), Some(127), false)?.0 as u8;
        let confidence = aper::decode::decode_integer(data, Some(0), Some(100), false)?.0 as u8;

        Ok(Self {
            latitude_sign,
            latitude,
            longitude,
            direction_of_altitude,
            altitude,
            uncertainty_semi_major,
            uncertainty_semi_minor,
            orientation_of_major_axis,
            uncertainty_altitude,
            confidence,
        })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(false);

        aper::encode::encode_sequence_header(data, false, &optionals, false)?;
        self.latitude_sign.encode(data)?;
        aper::encode::encode_integer(
            data,
            Some(0),
            Some(8388607),
            false,
            self.latitude as i128,
            false,
        )?;
        aper::encode::encode_integer(
            data,
            Some(-8388608),
            Some(8388607),
            false,
            self.longitude as i128,
            false,
        )?;
        self.direction_of_altitude.encode(data)?;
        aper::encode::encode_integer(
            data,
            Some(0),
            Some(32767),
            false,
            self.altitude as i128,
            false,
        )?;
        aper::encode::encode_integer(
            data,
            Some(0),
            Some(127),
            false,
            self.uncertainty_semi_major as i128,
            false,
        )?;
        aper::encode::encode_integer(
            data,
            Some(0),
            Some(127),
            false,
            self.uncertainty_semi_minor as i128,
            false,
        )?;
        aper::encode::encode_integer(
            data,
            Some(0),
            Some(179),
            false,
            self.orientation_of_major_axis as i128,
            false,
        )?;
        aper::encode::encode_integer(
            data,
            Some(0),
            Some(127),
            false,
            self.uncertainty_altitude as i128,
            false,
        )?;
        aper::encode::encode_integer(
            data,
            Some(0),
            Some(100),
            false,
            self.confidence as i128,
            false,
        )?;

        Ok(())
    }
}

impl AperCodec for AccessPointPosition {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        AccessPointPosition::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("AccessPointPosition"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("AccessPointPosition"))
    }
}
// ActivatedCellsToBeUpdatedList
#[derive(Clone, Debug)]
pub struct ActivatedCellsToBeUpdatedList(pub Vec<ActivatedCellsToBeUpdatedListItem>);

impl ActivatedCellsToBeUpdatedList {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        Ok(Self({
            let length = aper::decode::decode_length_determinent(data, Some(1), Some(512), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(ActivatedCellsToBeUpdatedListItem::decode(data)?);
            }
            items
        }))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_length_determinent(data, Some(1), Some(512), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl AperCodec for ActivatedCellsToBeUpdatedList {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        ActivatedCellsToBeUpdatedList::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("ActivatedCellsToBeUpdatedList"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("ActivatedCellsToBeUpdatedList"))
    }
}
// ActivatedCellsToBeUpdatedListItem
#[derive(Clone, Debug)]
pub struct ActivatedCellsToBeUpdatedListItem {
    pub nrcgi: Nrcgi,
    pub iab_du_cell_resource_configuration_mode_info: IabDuCellResourceConfigurationModeInfo,
}

impl ActivatedCellsToBeUpdatedListItem {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (_optionals, _extensions_present) =
            aper::decode::decode_sequence_header(data, false, 1)?;
        let nrcgi = Nrcgi::decode(data)?;
        let iab_du_cell_resource_configuration_mode_info =
            IabDuCellResourceConfigurationModeInfo::decode(data)?;

        Ok(Self {
            nrcgi,
            iab_du_cell_resource_configuration_mode_info,
        })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(false);

        aper::encode::encode_sequence_header(data, false, &optionals, false)?;
        self.nrcgi.encode(data)?;
        self.iab_du_cell_resource_configuration_mode_info
            .encode(data)?;

        Ok(())
    }
}

impl AperCodec for ActivatedCellsToBeUpdatedListItem {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        ActivatedCellsToBeUpdatedListItem::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("ActivatedCellsToBeUpdatedListItem"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("ActivatedCellsToBeUpdatedListItem"))
    }
}
// ActiveUlbwp
#[derive(Clone, Debug)]
pub struct ActiveUlbwp {
    pub location_and_bandwidth: u16,
    pub subcarrier_spacing: SubcarrierSpacing1,
    pub cyclic_prefix: CyclicPrefix,
    pub tx_direct_current_location: u16,
    pub shift7dot5k_hz: Option<Shift7dot5kHz>,
    pub srs_config: SrsConfig,
}

impl ActiveUlbwp {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (optionals, _extensions_present) =
            aper::decode::decode_sequence_header(data, false, 2)?;
        let location_and_bandwidth =
            aper::decode::decode_integer(data, Some(0), Some(37949), true)?.0 as u16;
        let subcarrier_spacing = SubcarrierSpacing1::decode(data)?;
        let cyclic_prefix = CyclicPrefix::decode(data)?;
        let tx_direct_current_location =
            aper::decode::decode_integer(data, Some(0), Some(3301), true)?.0 as u16;
        let shift7dot5k_hz = if optionals[0] {
            Some(Shift7dot5kHz::decode(data)?)
        } else {
            None
        };
        let srs_config = SrsConfig::decode(data)?;

        Ok(Self {
            location_and_bandwidth,
            subcarrier_spacing,
            cyclic_prefix,
            tx_direct_current_location,
            shift7dot5k_hz,
            srs_config,
        })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(self.shift7dot5k_hz.is_some());
        optionals.push(false);

        aper::encode::encode_sequence_header(data, false, &optionals, false)?;
        aper::encode::encode_integer(
            data,
            Some(0),
            Some(37949),
            true,
            self.location_and_bandwidth as i128,
            false,
        )?;
        self.subcarrier_spacing.encode(data)?;
        self.cyclic_prefix.encode(data)?;
        aper::encode::encode_integer(
            data,
            Some(0),
            Some(3301),
            true,
            self.tx_direct_current_location as i128,
            false,
        )?;
        if let Some(x) = &self.shift7dot5k_hz {
            x.encode(data)?;
        }
        self.srs_config.encode(data)?;

        Ok(())
    }
}

impl AperCodec for ActiveUlbwp {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        ActiveUlbwp::decode_inner(data).map_err(|e: AperCodecError| e.push_context("ActiveUlbwp"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("ActiveUlbwp"))
    }
}
// AdditionalDuplicationIndication
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum AdditionalDuplicationIndication {
    Three,
    Four,
}

impl AdditionalDuplicationIndication {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (idx, extended) = aper::decode::decode_enumerated(data, Some(0), Some(1), true)?;
        if extended {
            return Err(aper::AperCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| AperCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_enumerated(data, Some(0), Some(1), true, *self as i128, false)
    }
}

impl AperCodec for AdditionalDuplicationIndication {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        AdditionalDuplicationIndication::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("AdditionalDuplicationIndication"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("AdditionalDuplicationIndication"))
    }
}
// AdditionalPathList
#[derive(Clone, Debug)]
pub struct AdditionalPathList(pub Vec<AdditionalPathItem>);

impl AdditionalPathList {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        Ok(Self({
            let length = aper::decode::decode_length_determinent(data, Some(1), Some(2), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(AdditionalPathItem::decode(data)?);
            }
            items
        }))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_length_determinent(data, Some(1), Some(2), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl AperCodec for AdditionalPathList {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        AdditionalPathList::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("AdditionalPathList"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("AdditionalPathList"))
    }
}
// AdditionalPathItem
#[derive(Clone, Debug)]
pub struct AdditionalPathItem {
    pub relative_path_delay: RelativePathDelay,
    pub path_quality: Option<TrpMeasurementQuality>,
}

impl AdditionalPathItem {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (optionals, _extensions_present) =
            aper::decode::decode_sequence_header(data, false, 2)?;
        let relative_path_delay = RelativePathDelay::decode(data)?;
        let path_quality = if optionals[0] {
            Some(TrpMeasurementQuality::decode(data)?)
        } else {
            None
        };

        Ok(Self {
            relative_path_delay,
            path_quality,
        })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(self.path_quality.is_some());
        optionals.push(false);

        aper::encode::encode_sequence_header(data, false, &optionals, false)?;
        self.relative_path_delay.encode(data)?;
        if let Some(x) = &self.path_quality {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl AperCodec for AdditionalPathItem {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        AdditionalPathItem::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("AdditionalPathItem"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("AdditionalPathItem"))
    }
}
// AdditionalPdcpDuplicationTnlList
#[derive(Clone, Debug)]
pub struct AdditionalPdcpDuplicationTnlList(pub Vec<AdditionalPdcpDuplicationTnlItem>);

impl AdditionalPdcpDuplicationTnlList {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        Ok(Self({
            let length = aper::decode::decode_length_determinent(data, Some(1), Some(2), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(AdditionalPdcpDuplicationTnlItem::decode(data)?);
            }
            items
        }))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_length_determinent(data, Some(1), Some(2), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl AperCodec for AdditionalPdcpDuplicationTnlList {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        AdditionalPdcpDuplicationTnlList::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("AdditionalPdcpDuplicationTnlList"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("AdditionalPdcpDuplicationTnlList"))
    }
}
// AdditionalPdcpDuplicationTnlItem
#[derive(Clone, Debug)]
pub struct AdditionalPdcpDuplicationTnlItem {
    pub additional_pdcp_duplication_uptnl_information: UpTransportLayerInformation,
}

impl AdditionalPdcpDuplicationTnlItem {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (_optionals, _extensions_present) =
            aper::decode::decode_sequence_header(data, true, 1)?;
        let additional_pdcp_duplication_uptnl_information =
            UpTransportLayerInformation::decode(data)?;

        Ok(Self {
            additional_pdcp_duplication_uptnl_information,
        })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(false);

        aper::encode::encode_sequence_header(data, true, &optionals, false)?;
        self.additional_pdcp_duplication_uptnl_information
            .encode(data)?;

        Ok(())
    }
}

impl AperCodec for AdditionalPdcpDuplicationTnlItem {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        AdditionalPdcpDuplicationTnlItem::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("AdditionalPdcpDuplicationTnlItem"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("AdditionalPdcpDuplicationTnlItem"))
    }
}
// AdditionalSibMessageList
#[derive(Clone, Debug)]
pub struct AdditionalSibMessageList(pub Vec<AdditionalSibMessageListItem>);

impl AdditionalSibMessageList {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        Ok(Self({
            let length = aper::decode::decode_length_determinent(data, Some(1), Some(63), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(AdditionalSibMessageListItem::decode(data)?);
            }
            items
        }))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_length_determinent(data, Some(1), Some(63), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl AperCodec for AdditionalSibMessageList {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        AdditionalSibMessageList::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("AdditionalSibMessageList"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("AdditionalSibMessageList"))
    }
}
// AdditionalSibMessageListItem
#[derive(Clone, Debug)]
pub struct AdditionalSibMessageListItem {
    pub additional_sib: Vec<u8>,
}

impl AdditionalSibMessageListItem {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (_optionals, _extensions_present) =
            aper::decode::decode_sequence_header(data, false, 1)?;
        let additional_sib = aper::decode::decode_octetstring(data, None, None, false)?;

        Ok(Self { additional_sib })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(false);

        aper::encode::encode_sequence_header(data, false, &optionals, false)?;
        aper::encode::encode_octetstring(data, None, None, false, &self.additional_sib, false)?;

        Ok(())
    }
}

impl AperCodec for AdditionalSibMessageListItem {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        AdditionalSibMessageListItem::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("AdditionalSibMessageListItem"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("AdditionalSibMessageListItem"))
    }
}
// AdditionalRrmPriorityIndex
#[derive(Clone, Debug)]
pub struct AdditionalRrmPriorityIndex(pub BitString);

impl AdditionalRrmPriorityIndex {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        Ok(Self(aper::decode::decode_bitstring(
            data,
            Some(32),
            Some(32),
            false,
        )?))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_bitstring(data, Some(32), Some(32), false, &self.0, false)
    }
}

impl AperCodec for AdditionalRrmPriorityIndex {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        AdditionalRrmPriorityIndex::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("AdditionalRrmPriorityIndex"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("AdditionalRrmPriorityIndex"))
    }
}
// AggressorCellList
#[derive(Clone, Debug)]
pub struct AggressorCellList(pub Vec<AggressorCellListItem>);

impl AggressorCellList {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        Ok(Self({
            let length = aper::decode::decode_length_determinent(data, Some(1), Some(512), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(AggressorCellListItem::decode(data)?);
            }
            items
        }))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_length_determinent(data, Some(1), Some(512), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl AperCodec for AggressorCellList {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        AggressorCellList::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("AggressorCellList"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("AggressorCellList"))
    }
}
// AggressorCellListItem
#[derive(Clone, Debug)]
pub struct AggressorCellListItem {
    pub aggressor_cell_id: Nrcgi,
}

impl AggressorCellListItem {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (_optionals, _extensions_present) =
            aper::decode::decode_sequence_header(data, false, 1)?;
        let aggressor_cell_id = Nrcgi::decode(data)?;

        Ok(Self { aggressor_cell_id })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(false);

        aper::encode::encode_sequence_header(data, false, &optionals, false)?;
        self.aggressor_cell_id.encode(data)?;

        Ok(())
    }
}

impl AperCodec for AggressorCellListItem {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        AggressorCellListItem::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("AggressorCellListItem"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("AggressorCellListItem"))
    }
}
// AggressorGnbSetId
#[derive(Clone, Debug)]
pub struct AggressorGnbSetId {
    pub aggressor_gnb_set_id: GnbSetId,
}

impl AggressorGnbSetId {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (_optionals, _extensions_present) =
            aper::decode::decode_sequence_header(data, false, 1)?;
        let aggressor_gnb_set_id = GnbSetId::decode(data)?;

        Ok(Self {
            aggressor_gnb_set_id,
        })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(false);

        aper::encode::encode_sequence_header(data, false, &optionals, false)?;
        self.aggressor_gnb_set_id.encode(data)?;

        Ok(())
    }
}

impl AperCodec for AggressorGnbSetId {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        AggressorGnbSetId::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("AggressorGnbSetId"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("AggressorGnbSetId"))
    }
}
// AllocationAndRetentionPriority
#[derive(Clone, Debug)]
pub struct AllocationAndRetentionPriority {
    pub priority_level: PriorityLevel,
    pub pre_emption_capability: PreEmptionCapability,
    pub pre_emption_vulnerability: PreEmptionVulnerability,
}

impl AllocationAndRetentionPriority {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (_optionals, _extensions_present) =
            aper::decode::decode_sequence_header(data, true, 1)?;
        let priority_level = PriorityLevel::decode(data)?;
        let pre_emption_capability = PreEmptionCapability::decode(data)?;
        let pre_emption_vulnerability = PreEmptionVulnerability::decode(data)?;

        Ok(Self {
            priority_level,
            pre_emption_capability,
            pre_emption_vulnerability,
        })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(false);

        aper::encode::encode_sequence_header(data, true, &optionals, false)?;
        self.priority_level.encode(data)?;
        self.pre_emption_capability.encode(data)?;
        self.pre_emption_vulnerability.encode(data)?;

        Ok(())
    }
}

impl AperCodec for AllocationAndRetentionPriority {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        AllocationAndRetentionPriority::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("AllocationAndRetentionPriority"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("AllocationAndRetentionPriority"))
    }
}
// AlternativeQosParaSetList
#[derive(Clone, Debug)]
pub struct AlternativeQosParaSetList(pub Vec<AlternativeQosParaSetItem>);

impl AlternativeQosParaSetList {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        Ok(Self({
            let length = aper::decode::decode_length_determinent(data, Some(1), Some(8), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(AlternativeQosParaSetItem::decode(data)?);
            }
            items
        }))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_length_determinent(data, Some(1), Some(8), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl AperCodec for AlternativeQosParaSetList {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        AlternativeQosParaSetList::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("AlternativeQosParaSetList"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("AlternativeQosParaSetList"))
    }
}
// AlternativeQosParaSetItem
#[derive(Clone, Debug)]
pub struct AlternativeQosParaSetItem {
    pub alternative_qos_para_set_index: QosParaSetIndex,
    pub guaranteed_flow_bit_rate_dl: Option<BitRate>,
    pub guaranteed_flow_bit_rate_ul: Option<BitRate>,
    pub packet_delay_budget: Option<PacketDelayBudget>,
    pub packet_error_rate: Option<PacketErrorRate>,
}

impl AlternativeQosParaSetItem {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (optionals, _extensions_present) = aper::decode::decode_sequence_header(data, true, 5)?;
        let alternative_qos_para_set_index = QosParaSetIndex::decode(data)?;
        let guaranteed_flow_bit_rate_dl = if optionals[0] {
            Some(BitRate::decode(data)?)
        } else {
            None
        };
        let guaranteed_flow_bit_rate_ul = if optionals[1] {
            Some(BitRate::decode(data)?)
        } else {
            None
        };
        let packet_delay_budget = if optionals[2] {
            Some(PacketDelayBudget::decode(data)?)
        } else {
            None
        };
        let packet_error_rate = if optionals[3] {
            Some(PacketErrorRate::decode(data)?)
        } else {
            None
        };

        Ok(Self {
            alternative_qos_para_set_index,
            guaranteed_flow_bit_rate_dl,
            guaranteed_flow_bit_rate_ul,
            packet_delay_budget,
            packet_error_rate,
        })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(self.guaranteed_flow_bit_rate_dl.is_some());
        optionals.push(self.guaranteed_flow_bit_rate_ul.is_some());
        optionals.push(self.packet_delay_budget.is_some());
        optionals.push(self.packet_error_rate.is_some());
        optionals.push(false);

        aper::encode::encode_sequence_header(data, true, &optionals, false)?;
        self.alternative_qos_para_set_index.encode(data)?;
        if let Some(x) = &self.guaranteed_flow_bit_rate_dl {
            x.encode(data)?;
        }
        if let Some(x) = &self.guaranteed_flow_bit_rate_ul {
            x.encode(data)?;
        }
        if let Some(x) = &self.packet_delay_budget {
            x.encode(data)?;
        }
        if let Some(x) = &self.packet_error_rate {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl AperCodec for AlternativeQosParaSetItem {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        AlternativeQosParaSetItem::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("AlternativeQosParaSetItem"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("AlternativeQosParaSetItem"))
    }
}
// AngleMeasurementQuality
#[derive(Clone, Debug)]
pub struct AngleMeasurementQuality {
    pub azimuth_quality: u8,
    pub zenith_quality: Option<u8>,
    pub resolution: Resolution,
}

impl AngleMeasurementQuality {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (optionals, _extensions_present) =
            aper::decode::decode_sequence_header(data, false, 2)?;
        let azimuth_quality =
            aper::decode::decode_integer(data, Some(0), Some(255), false)?.0 as u8;
        let zenith_quality = if optionals[0] {
            Some(aper::decode::decode_integer(data, Some(0), Some(255), false)?.0 as u8)
        } else {
            None
        };
        let resolution = Resolution::decode(data)?;

        Ok(Self {
            azimuth_quality,
            zenith_quality,
            resolution,
        })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(self.zenith_quality.is_some());
        optionals.push(false);

        aper::encode::encode_sequence_header(data, false, &optionals, false)?;
        aper::encode::encode_integer(
            data,
            Some(0),
            Some(255),
            false,
            self.azimuth_quality as i128,
            false,
        )?;
        if let Some(x) = &self.zenith_quality {
            aper::encode::encode_integer(data, Some(0), Some(255), false, *x as i128, false)?;
        }
        self.resolution.encode(data)?;

        Ok(())
    }
}

impl AperCodec for AngleMeasurementQuality {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        AngleMeasurementQuality::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("AngleMeasurementQuality"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("AngleMeasurementQuality"))
    }
}
// AperiodicSrsResourceTriggerList
#[derive(Clone, Debug)]
pub struct AperiodicSrsResourceTriggerList(pub Vec<AperiodicSrsResourceTrigger>);

impl AperiodicSrsResourceTriggerList {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        Ok(Self({
            let length = aper::decode::decode_length_determinent(data, Some(1), Some(3), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(AperiodicSrsResourceTrigger::decode(data)?);
            }
            items
        }))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_length_determinent(data, Some(1), Some(3), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl AperCodec for AperiodicSrsResourceTriggerList {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        AperiodicSrsResourceTriggerList::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("AperiodicSrsResourceTriggerList"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("AperiodicSrsResourceTriggerList"))
    }
}
// AperiodicSrsResourceTrigger
#[derive(Clone, Debug)]
pub struct AperiodicSrsResourceTrigger(pub u8);

impl AperiodicSrsResourceTrigger {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        Ok(Self(
            aper::decode::decode_integer(data, Some(1), Some(3), false)?.0 as u8,
        ))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_integer(data, Some(1), Some(3), false, self.0 as i128, false)
    }
}

impl AperCodec for AperiodicSrsResourceTrigger {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        AperiodicSrsResourceTrigger::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("AperiodicSrsResourceTrigger"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("AperiodicSrsResourceTrigger"))
    }
}
// AssociatedSCellItem
#[derive(Clone, Debug)]
pub struct AssociatedSCellItem {
    pub s_cell_id: Nrcgi,
}

impl AssociatedSCellItem {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (_optionals, _extensions_present) =
            aper::decode::decode_sequence_header(data, false, 1)?;
        let s_cell_id = Nrcgi::decode(data)?;

        Ok(Self { s_cell_id })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(false);

        aper::encode::encode_sequence_header(data, false, &optionals, false)?;
        self.s_cell_id.encode(data)?;

        Ok(())
    }
}

impl AperCodec for AssociatedSCellItem {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        AssociatedSCellItem::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("AssociatedSCellItem"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("AssociatedSCellItem"))
    }
}
// AvailablePlmnList
#[derive(Clone, Debug)]
pub struct AvailablePlmnList(pub Vec<AvailablePlmnListItem>);

impl AvailablePlmnList {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        Ok(Self({
            let length = aper::decode::decode_length_determinent(data, Some(1), Some(6), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(AvailablePlmnListItem::decode(data)?);
            }
            items
        }))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_length_determinent(data, Some(1), Some(6), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl AperCodec for AvailablePlmnList {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        AvailablePlmnList::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("AvailablePlmnList"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("AvailablePlmnList"))
    }
}
// AvailablePlmnListItem
#[derive(Clone, Debug)]
pub struct AvailablePlmnListItem {
    pub plmn_identity: PlmnIdentity,
}

impl AvailablePlmnListItem {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (_optionals, _extensions_present) =
            aper::decode::decode_sequence_header(data, false, 1)?;
        let plmn_identity = PlmnIdentity::decode(data)?;

        Ok(Self { plmn_identity })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(false);

        aper::encode::encode_sequence_header(data, false, &optionals, false)?;
        self.plmn_identity.encode(data)?;

        Ok(())
    }
}

impl AperCodec for AvailablePlmnListItem {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        AvailablePlmnListItem::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("AvailablePlmnListItem"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("AvailablePlmnListItem"))
    }
}
// AvailableSnpnIdList
#[derive(Clone, Debug)]
pub struct AvailableSnpnIdList(pub Vec<AvailableSnpnIdListItem>);

impl AvailableSnpnIdList {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        Ok(Self({
            let length = aper::decode::decode_length_determinent(data, Some(1), Some(12), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(AvailableSnpnIdListItem::decode(data)?);
            }
            items
        }))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_length_determinent(data, Some(1), Some(12), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl AperCodec for AvailableSnpnIdList {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        AvailableSnpnIdList::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("AvailableSnpnIdList"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("AvailableSnpnIdList"))
    }
}
// AvailableSnpnIdListItem
#[derive(Clone, Debug)]
pub struct AvailableSnpnIdListItem {
    pub plmn_identity: PlmnIdentity,
    pub available_nid_list: BroadcastNidList,
}

impl AvailableSnpnIdListItem {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (_optionals, _extensions_present) =
            aper::decode::decode_sequence_header(data, true, 1)?;
        let plmn_identity = PlmnIdentity::decode(data)?;
        let available_nid_list = BroadcastNidList::decode(data)?;

        Ok(Self {
            plmn_identity,
            available_nid_list,
        })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(false);

        aper::encode::encode_sequence_header(data, true, &optionals, false)?;
        self.plmn_identity.encode(data)?;
        self.available_nid_list.encode(data)?;

        Ok(())
    }
}

impl AperCodec for AvailableSnpnIdListItem {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        AvailableSnpnIdListItem::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("AvailableSnpnIdListItem"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("AvailableSnpnIdListItem"))
    }
}
// AveragingWindow
#[derive(Clone, Debug)]
pub struct AveragingWindow(pub u16);

impl AveragingWindow {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        Ok(Self(
            aper::decode::decode_integer(data, Some(0), Some(4095), true)?.0 as u16,
        ))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_integer(data, Some(0), Some(4095), true, self.0 as i128, false)
    }
}

impl AperCodec for AveragingWindow {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        AveragingWindow::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("AveragingWindow"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("AveragingWindow"))
    }
}
// AreaScope
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum AreaScope {
    True,
}

impl AreaScope {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (idx, extended) = aper::decode::decode_enumerated(data, Some(0), Some(0), true)?;
        if extended {
            return Err(aper::AperCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| AperCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_enumerated(data, Some(0), Some(0), true, *self as i128, false)
    }
}

impl AperCodec for AreaScope {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        AreaScope::decode_inner(data).map_err(|e: AperCodecError| e.push_context("AreaScope"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("AreaScope"))
    }
}
// BandwidthSrs
#[derive(Clone, Debug)]
pub enum BandwidthSrs {
    Fr1(Fr1Bandwidth),
    Fr2(Fr2Bandwidth),
}

impl BandwidthSrs {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (idx, extended) = aper::decode::decode_choice_idx(data, 0, 2, false)?;
        if extended {
            return Err(aper::AperCodecError::new(
                "CHOICE additions not implemented",
            ));
        }
        match idx {
            0 => Ok(Self::Fr1(Fr1Bandwidth::decode(data)?)),
            1 => Ok(Self::Fr2(Fr2Bandwidth::decode(data)?)),
            2 => Err(AperCodecError::new(
                "Choice extension container not implemented",
            )),
            _ => Err(AperCodecError::new("Unknown choice idx")),
        }
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        match self {
            Self::Fr1(x) => {
                aper::encode::encode_choice_idx(data, 0, 2, false, 0, false)?;
                x.encode(data)
            }
            Self::Fr2(x) => {
                aper::encode::encode_choice_idx(data, 0, 2, false, 1, false)?;
                x.encode(data)
            }
        }
    }
}

impl AperCodec for BandwidthSrs {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        BandwidthSrs::decode_inner(data).map_err(|e: AperCodecError| e.push_context("BandwidthSrs"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("BandwidthSrs"))
    }
}
// BapAddress
#[derive(Clone, Debug)]
pub struct BapAddress(pub BitString);

impl BapAddress {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        Ok(Self(aper::decode::decode_bitstring(
            data,
            Some(10),
            Some(10),
            false,
        )?))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_bitstring(data, Some(10), Some(10), false, &self.0, false)
    }
}

impl AperCodec for BapAddress {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        BapAddress::decode_inner(data).map_err(|e: AperCodecError| e.push_context("BapAddress"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("BapAddress"))
    }
}
// BapCtrlPduChannel
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum BapCtrlPduChannel {
    True,
}

impl BapCtrlPduChannel {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (idx, extended) = aper::decode::decode_enumerated(data, Some(0), Some(0), true)?;
        if extended {
            return Err(aper::AperCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| AperCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_enumerated(data, Some(0), Some(0), true, *self as i128, false)
    }
}

impl AperCodec for BapCtrlPduChannel {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        BapCtrlPduChannel::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("BapCtrlPduChannel"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("BapCtrlPduChannel"))
    }
}
// BaPlayerBhrlCchannelMappingInfo
#[derive(Clone, Debug)]
pub struct BaPlayerBhrlCchannelMappingInfo {
    pub ba_player_bhrl_cchannel_mapping_info_to_add: Option<BaPlayerBhrlCchannelMappingInfoList>,
    pub ba_player_bhrl_cchannel_mapping_info_to_remove: Option<MappingInformationtoRemove>,
}

impl BaPlayerBhrlCchannelMappingInfo {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (optionals, _extensions_present) = aper::decode::decode_sequence_header(data, true, 3)?;
        let ba_player_bhrl_cchannel_mapping_info_to_add = if optionals[0] {
            Some(BaPlayerBhrlCchannelMappingInfoList::decode(data)?)
        } else {
            None
        };
        let ba_player_bhrl_cchannel_mapping_info_to_remove = if optionals[1] {
            Some(MappingInformationtoRemove::decode(data)?)
        } else {
            None
        };

        Ok(Self {
            ba_player_bhrl_cchannel_mapping_info_to_add,
            ba_player_bhrl_cchannel_mapping_info_to_remove,
        })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(self.ba_player_bhrl_cchannel_mapping_info_to_add.is_some());
        optionals.push(
            self.ba_player_bhrl_cchannel_mapping_info_to_remove
                .is_some(),
        );
        optionals.push(false);

        aper::encode::encode_sequence_header(data, true, &optionals, false)?;
        if let Some(x) = &self.ba_player_bhrl_cchannel_mapping_info_to_add {
            x.encode(data)?;
        }
        if let Some(x) = &self.ba_player_bhrl_cchannel_mapping_info_to_remove {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl AperCodec for BaPlayerBhrlCchannelMappingInfo {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        BaPlayerBhrlCchannelMappingInfo::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("BaPlayerBhrlCchannelMappingInfo"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("BaPlayerBhrlCchannelMappingInfo"))
    }
}
// BaPlayerBhrlCchannelMappingInfoList
#[derive(Clone, Debug)]
pub struct BaPlayerBhrlCchannelMappingInfoList(pub Vec<BaPlayerBhrlCchannelMappingInfoItem>);

impl BaPlayerBhrlCchannelMappingInfoList {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        Ok(Self({
            let length =
                aper::decode::decode_length_determinent(data, Some(1), Some(67108864), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(BaPlayerBhrlCchannelMappingInfoItem::decode(data)?);
            }
            items
        }))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_length_determinent(
            data,
            Some(1),
            Some(67108864),
            false,
            self.0.len(),
        )?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl AperCodec for BaPlayerBhrlCchannelMappingInfoList {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        BaPlayerBhrlCchannelMappingInfoList::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("BaPlayerBhrlCchannelMappingInfoList"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("BaPlayerBhrlCchannelMappingInfoList"))
    }
}
// BaPlayerBhrlCchannelMappingInfoItem
#[derive(Clone, Debug)]
pub struct BaPlayerBhrlCchannelMappingInfoItem {
    pub mapping_information_index: MappingInformationIndex,
    pub prior_hop_bap_address: Option<BapAddress>,
    pub ingressb_hrlc_channel_id: Option<BhrlcChannelId>,
    pub next_hop_bap_address: Option<BapAddress>,
    pub egressb_hrlc_channel_id: Option<BhrlcChannelId>,
}

impl BaPlayerBhrlCchannelMappingInfoItem {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (optionals, _extensions_present) = aper::decode::decode_sequence_header(data, true, 5)?;
        let mapping_information_index = MappingInformationIndex::decode(data)?;
        let prior_hop_bap_address = if optionals[0] {
            Some(BapAddress::decode(data)?)
        } else {
            None
        };
        let ingressb_hrlc_channel_id = if optionals[1] {
            Some(BhrlcChannelId::decode(data)?)
        } else {
            None
        };
        let next_hop_bap_address = if optionals[2] {
            Some(BapAddress::decode(data)?)
        } else {
            None
        };
        let egressb_hrlc_channel_id = if optionals[3] {
            Some(BhrlcChannelId::decode(data)?)
        } else {
            None
        };

        Ok(Self {
            mapping_information_index,
            prior_hop_bap_address,
            ingressb_hrlc_channel_id,
            next_hop_bap_address,
            egressb_hrlc_channel_id,
        })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(self.prior_hop_bap_address.is_some());
        optionals.push(self.ingressb_hrlc_channel_id.is_some());
        optionals.push(self.next_hop_bap_address.is_some());
        optionals.push(self.egressb_hrlc_channel_id.is_some());
        optionals.push(false);

        aper::encode::encode_sequence_header(data, true, &optionals, false)?;
        self.mapping_information_index.encode(data)?;
        if let Some(x) = &self.prior_hop_bap_address {
            x.encode(data)?;
        }
        if let Some(x) = &self.ingressb_hrlc_channel_id {
            x.encode(data)?;
        }
        if let Some(x) = &self.next_hop_bap_address {
            x.encode(data)?;
        }
        if let Some(x) = &self.egressb_hrlc_channel_id {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl AperCodec for BaPlayerBhrlCchannelMappingInfoItem {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        BaPlayerBhrlCchannelMappingInfoItem::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("BaPlayerBhrlCchannelMappingInfoItem"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("BaPlayerBhrlCchannelMappingInfoItem"))
    }
}
// BapPathId
#[derive(Clone, Debug)]
pub struct BapPathId(pub BitString);

impl BapPathId {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        Ok(Self(aper::decode::decode_bitstring(
            data,
            Some(10),
            Some(10),
            false,
        )?))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_bitstring(data, Some(10), Some(10), false, &self.0, false)
    }
}

impl AperCodec for BapPathId {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        BapPathId::decode_inner(data).map_err(|e: AperCodecError| e.push_context("BapPathId"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("BapPathId"))
    }
}
// BapRoutingId
#[derive(Clone, Debug)]
pub struct BapRoutingId {
    pub bap_address: BapAddress,
    pub bap_path_id: BapPathId,
}

impl BapRoutingId {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (_optionals, _extensions_present) =
            aper::decode::decode_sequence_header(data, false, 1)?;
        let bap_address = BapAddress::decode(data)?;
        let bap_path_id = BapPathId::decode(data)?;

        Ok(Self {
            bap_address,
            bap_path_id,
        })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(false);

        aper::encode::encode_sequence_header(data, false, &optionals, false)?;
        self.bap_address.encode(data)?;
        self.bap_path_id.encode(data)?;

        Ok(())
    }
}

impl AperCodec for BapRoutingId {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        BapRoutingId::decode_inner(data).map_err(|e: AperCodecError| e.push_context("BapRoutingId"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("BapRoutingId"))
    }
}
// BitRate
#[derive(Clone, Debug)]
pub struct BitRate(pub u64);

impl BitRate {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        Ok(Self(
            aper::decode::decode_integer(data, Some(0), Some(4000000000000), true)?.0 as u64,
        ))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_integer(
            data,
            Some(0),
            Some(4000000000000),
            true,
            self.0 as i128,
            false,
        )
    }
}

impl AperCodec for BitRate {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        BitRate::decode_inner(data).map_err(|e: AperCodecError| e.push_context("BitRate"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("BitRate"))
    }
}
// BearerTypeChange
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum BearerTypeChange {
    True,
}

impl BearerTypeChange {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (idx, extended) = aper::decode::decode_enumerated(data, Some(0), Some(0), true)?;
        if extended {
            return Err(aper::AperCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| AperCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_enumerated(data, Some(0), Some(0), true, *self as i128, false)
    }
}

impl AperCodec for BearerTypeChange {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        BearerTypeChange::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("BearerTypeChange"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("BearerTypeChange"))
    }
}
// BhrlcChannelId
#[derive(Clone, Debug)]
pub struct BhrlcChannelId(pub BitString);

impl BhrlcChannelId {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        Ok(Self(aper::decode::decode_bitstring(
            data,
            Some(16),
            Some(16),
            false,
        )?))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_bitstring(data, Some(16), Some(16), false, &self.0, false)
    }
}

impl AperCodec for BhrlcChannelId {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        BhrlcChannelId::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("BhrlcChannelId"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("BhrlcChannelId"))
    }
}
// BhChannelsFailedToBeModifiedItem
#[derive(Clone, Debug)]
pub struct BhChannelsFailedToBeModifiedItem {
    pub bhrlc_channel_id: BhrlcChannelId,
    pub cause: Option<Cause>,
}

impl BhChannelsFailedToBeModifiedItem {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (optionals, _extensions_present) =
            aper::decode::decode_sequence_header(data, false, 2)?;
        let bhrlc_channel_id = BhrlcChannelId::decode(data)?;
        let cause = if optionals[0] {
            Some(Cause::decode(data)?)
        } else {
            None
        };

        Ok(Self {
            bhrlc_channel_id,
            cause,
        })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(self.cause.is_some());
        optionals.push(false);

        aper::encode::encode_sequence_header(data, false, &optionals, false)?;
        self.bhrlc_channel_id.encode(data)?;
        if let Some(x) = &self.cause {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl AperCodec for BhChannelsFailedToBeModifiedItem {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        BhChannelsFailedToBeModifiedItem::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("BhChannelsFailedToBeModifiedItem"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("BhChannelsFailedToBeModifiedItem"))
    }
}
// BhChannelsFailedToBeSetupItem
#[derive(Clone, Debug)]
pub struct BhChannelsFailedToBeSetupItem {
    pub bhrlc_channel_id: BhrlcChannelId,
    pub cause: Option<Cause>,
}

impl BhChannelsFailedToBeSetupItem {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (optionals, _extensions_present) =
            aper::decode::decode_sequence_header(data, false, 2)?;
        let bhrlc_channel_id = BhrlcChannelId::decode(data)?;
        let cause = if optionals[0] {
            Some(Cause::decode(data)?)
        } else {
            None
        };

        Ok(Self {
            bhrlc_channel_id,
            cause,
        })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(self.cause.is_some());
        optionals.push(false);

        aper::encode::encode_sequence_header(data, false, &optionals, false)?;
        self.bhrlc_channel_id.encode(data)?;
        if let Some(x) = &self.cause {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl AperCodec for BhChannelsFailedToBeSetupItem {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        BhChannelsFailedToBeSetupItem::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("BhChannelsFailedToBeSetupItem"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("BhChannelsFailedToBeSetupItem"))
    }
}
// BhChannelsFailedToBeSetupModItem
#[derive(Clone, Debug)]
pub struct BhChannelsFailedToBeSetupModItem {
    pub bhrlc_channel_id: BhrlcChannelId,
    pub cause: Option<Cause>,
}

impl BhChannelsFailedToBeSetupModItem {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (optionals, _extensions_present) =
            aper::decode::decode_sequence_header(data, false, 2)?;
        let bhrlc_channel_id = BhrlcChannelId::decode(data)?;
        let cause = if optionals[0] {
            Some(Cause::decode(data)?)
        } else {
            None
        };

        Ok(Self {
            bhrlc_channel_id,
            cause,
        })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(self.cause.is_some());
        optionals.push(false);

        aper::encode::encode_sequence_header(data, false, &optionals, false)?;
        self.bhrlc_channel_id.encode(data)?;
        if let Some(x) = &self.cause {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl AperCodec for BhChannelsFailedToBeSetupModItem {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        BhChannelsFailedToBeSetupModItem::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("BhChannelsFailedToBeSetupModItem"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("BhChannelsFailedToBeSetupModItem"))
    }
}
// BhChannelsModifiedItem
#[derive(Clone, Debug)]
pub struct BhChannelsModifiedItem {
    pub bhrlc_channel_id: BhrlcChannelId,
}

impl BhChannelsModifiedItem {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (_optionals, _extensions_present) =
            aper::decode::decode_sequence_header(data, false, 1)?;
        let bhrlc_channel_id = BhrlcChannelId::decode(data)?;

        Ok(Self { bhrlc_channel_id })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(false);

        aper::encode::encode_sequence_header(data, false, &optionals, false)?;
        self.bhrlc_channel_id.encode(data)?;

        Ok(())
    }
}

impl AperCodec for BhChannelsModifiedItem {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        BhChannelsModifiedItem::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("BhChannelsModifiedItem"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("BhChannelsModifiedItem"))
    }
}
// BhChannelsRequiredToBeReleasedItem
#[derive(Clone, Debug)]
pub struct BhChannelsRequiredToBeReleasedItem {
    pub bhrlc_channel_id: BhrlcChannelId,
}

impl BhChannelsRequiredToBeReleasedItem {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (_optionals, _extensions_present) =
            aper::decode::decode_sequence_header(data, false, 1)?;
        let bhrlc_channel_id = BhrlcChannelId::decode(data)?;

        Ok(Self { bhrlc_channel_id })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(false);

        aper::encode::encode_sequence_header(data, false, &optionals, false)?;
        self.bhrlc_channel_id.encode(data)?;

        Ok(())
    }
}

impl AperCodec for BhChannelsRequiredToBeReleasedItem {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        BhChannelsRequiredToBeReleasedItem::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("BhChannelsRequiredToBeReleasedItem"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("BhChannelsRequiredToBeReleasedItem"))
    }
}
// BhChannelsSetupItem
#[derive(Clone, Debug)]
pub struct BhChannelsSetupItem {
    pub bhrlc_channel_id: BhrlcChannelId,
}

impl BhChannelsSetupItem {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (_optionals, _extensions_present) =
            aper::decode::decode_sequence_header(data, false, 1)?;
        let bhrlc_channel_id = BhrlcChannelId::decode(data)?;

        Ok(Self { bhrlc_channel_id })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(false);

        aper::encode::encode_sequence_header(data, false, &optionals, false)?;
        self.bhrlc_channel_id.encode(data)?;

        Ok(())
    }
}

impl AperCodec for BhChannelsSetupItem {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        BhChannelsSetupItem::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("BhChannelsSetupItem"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("BhChannelsSetupItem"))
    }
}
// BhChannelsSetupModItem
#[derive(Clone, Debug)]
pub struct BhChannelsSetupModItem {
    pub bhrlc_channel_id: BhrlcChannelId,
}

impl BhChannelsSetupModItem {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (_optionals, _extensions_present) =
            aper::decode::decode_sequence_header(data, false, 1)?;
        let bhrlc_channel_id = BhrlcChannelId::decode(data)?;

        Ok(Self { bhrlc_channel_id })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(false);

        aper::encode::encode_sequence_header(data, false, &optionals, false)?;
        self.bhrlc_channel_id.encode(data)?;

        Ok(())
    }
}

impl AperCodec for BhChannelsSetupModItem {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        BhChannelsSetupModItem::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("BhChannelsSetupModItem"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("BhChannelsSetupModItem"))
    }
}
// BhChannelsToBeModifiedItem
#[derive(Clone, Debug)]
pub struct BhChannelsToBeModifiedItem {
    pub bhrlc_channel_id: BhrlcChannelId,
    pub bh_qos_information: BhQosInformation,
    pub rl_cmode: Option<RlcMode>,
    pub bap_ctrl_pdu_channel: Option<BapCtrlPduChannel>,
    pub traffic_mapping_info: Option<TrafficMappingInfo>,
}

impl BhChannelsToBeModifiedItem {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (optionals, _extensions_present) =
            aper::decode::decode_sequence_header(data, false, 4)?;
        let bhrlc_channel_id = BhrlcChannelId::decode(data)?;
        let bh_qos_information = BhQosInformation::decode(data)?;
        let rl_cmode = if optionals[0] {
            Some(RlcMode::decode(data)?)
        } else {
            None
        };
        let bap_ctrl_pdu_channel = if optionals[1] {
            Some(BapCtrlPduChannel::decode(data)?)
        } else {
            None
        };
        let traffic_mapping_info = if optionals[2] {
            Some(TrafficMappingInfo::decode(data)?)
        } else {
            None
        };

        Ok(Self {
            bhrlc_channel_id,
            bh_qos_information,
            rl_cmode,
            bap_ctrl_pdu_channel,
            traffic_mapping_info,
        })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(self.rl_cmode.is_some());
        optionals.push(self.bap_ctrl_pdu_channel.is_some());
        optionals.push(self.traffic_mapping_info.is_some());
        optionals.push(false);

        aper::encode::encode_sequence_header(data, false, &optionals, false)?;
        self.bhrlc_channel_id.encode(data)?;
        self.bh_qos_information.encode(data)?;
        if let Some(x) = &self.rl_cmode {
            x.encode(data)?;
        }
        if let Some(x) = &self.bap_ctrl_pdu_channel {
            x.encode(data)?;
        }
        if let Some(x) = &self.traffic_mapping_info {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl AperCodec for BhChannelsToBeModifiedItem {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        BhChannelsToBeModifiedItem::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("BhChannelsToBeModifiedItem"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("BhChannelsToBeModifiedItem"))
    }
}
// BhChannelsToBeReleasedItem
#[derive(Clone, Debug)]
pub struct BhChannelsToBeReleasedItem {
    pub bhrlc_channel_id: BhrlcChannelId,
}

impl BhChannelsToBeReleasedItem {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (_optionals, _extensions_present) =
            aper::decode::decode_sequence_header(data, false, 1)?;
        let bhrlc_channel_id = BhrlcChannelId::decode(data)?;

        Ok(Self { bhrlc_channel_id })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(false);

        aper::encode::encode_sequence_header(data, false, &optionals, false)?;
        self.bhrlc_channel_id.encode(data)?;

        Ok(())
    }
}

impl AperCodec for BhChannelsToBeReleasedItem {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        BhChannelsToBeReleasedItem::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("BhChannelsToBeReleasedItem"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("BhChannelsToBeReleasedItem"))
    }
}
// BhChannelsToBeSetupItem
#[derive(Clone, Debug)]
pub struct BhChannelsToBeSetupItem {
    pub bhrlc_channel_id: BhrlcChannelId,
    pub bh_qos_information: BhQosInformation,
    pub rl_cmode: RlcMode,
    pub bap_ctrl_pdu_channel: Option<BapCtrlPduChannel>,
    pub traffic_mapping_info: Option<TrafficMappingInfo>,
}

impl BhChannelsToBeSetupItem {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (optionals, _extensions_present) =
            aper::decode::decode_sequence_header(data, false, 3)?;
        let bhrlc_channel_id = BhrlcChannelId::decode(data)?;
        let bh_qos_information = BhQosInformation::decode(data)?;
        let rl_cmode = RlcMode::decode(data)?;
        let bap_ctrl_pdu_channel = if optionals[0] {
            Some(BapCtrlPduChannel::decode(data)?)
        } else {
            None
        };
        let traffic_mapping_info = if optionals[1] {
            Some(TrafficMappingInfo::decode(data)?)
        } else {
            None
        };

        Ok(Self {
            bhrlc_channel_id,
            bh_qos_information,
            rl_cmode,
            bap_ctrl_pdu_channel,
            traffic_mapping_info,
        })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(self.bap_ctrl_pdu_channel.is_some());
        optionals.push(self.traffic_mapping_info.is_some());
        optionals.push(false);

        aper::encode::encode_sequence_header(data, false, &optionals, false)?;
        self.bhrlc_channel_id.encode(data)?;
        self.bh_qos_information.encode(data)?;
        self.rl_cmode.encode(data)?;
        if let Some(x) = &self.bap_ctrl_pdu_channel {
            x.encode(data)?;
        }
        if let Some(x) = &self.traffic_mapping_info {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl AperCodec for BhChannelsToBeSetupItem {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        BhChannelsToBeSetupItem::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("BhChannelsToBeSetupItem"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("BhChannelsToBeSetupItem"))
    }
}
// BhChannelsToBeSetupModItem
#[derive(Clone, Debug)]
pub struct BhChannelsToBeSetupModItem {
    pub bhrlc_channel_id: BhrlcChannelId,
    pub bh_qos_information: BhQosInformation,
    pub rl_cmode: RlcMode,
    pub bap_ctrl_pdu_channel: Option<BapCtrlPduChannel>,
    pub traffic_mapping_info: Option<TrafficMappingInfo>,
}

impl BhChannelsToBeSetupModItem {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (optionals, _extensions_present) =
            aper::decode::decode_sequence_header(data, false, 3)?;
        let bhrlc_channel_id = BhrlcChannelId::decode(data)?;
        let bh_qos_information = BhQosInformation::decode(data)?;
        let rl_cmode = RlcMode::decode(data)?;
        let bap_ctrl_pdu_channel = if optionals[0] {
            Some(BapCtrlPduChannel::decode(data)?)
        } else {
            None
        };
        let traffic_mapping_info = if optionals[1] {
            Some(TrafficMappingInfo::decode(data)?)
        } else {
            None
        };

        Ok(Self {
            bhrlc_channel_id,
            bh_qos_information,
            rl_cmode,
            bap_ctrl_pdu_channel,
            traffic_mapping_info,
        })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(self.bap_ctrl_pdu_channel.is_some());
        optionals.push(self.traffic_mapping_info.is_some());
        optionals.push(false);

        aper::encode::encode_sequence_header(data, false, &optionals, false)?;
        self.bhrlc_channel_id.encode(data)?;
        self.bh_qos_information.encode(data)?;
        self.rl_cmode.encode(data)?;
        if let Some(x) = &self.bap_ctrl_pdu_channel {
            x.encode(data)?;
        }
        if let Some(x) = &self.traffic_mapping_info {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl AperCodec for BhChannelsToBeSetupModItem {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        BhChannelsToBeSetupModItem::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("BhChannelsToBeSetupModItem"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("BhChannelsToBeSetupModItem"))
    }
}
// BhInfo
#[derive(Clone, Debug)]
pub struct BhInfo {
    pub ba_prouting_id: Option<BapRoutingId>,
    pub egress_bhrlcch_list: Option<EgressBhrlcchList>,
}

impl BhInfo {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (optionals, _extensions_present) =
            aper::decode::decode_sequence_header(data, false, 3)?;
        let ba_prouting_id = if optionals[0] {
            Some(BapRoutingId::decode(data)?)
        } else {
            None
        };
        let egress_bhrlcch_list = if optionals[1] {
            Some(EgressBhrlcchList::decode(data)?)
        } else {
            None
        };

        Ok(Self {
            ba_prouting_id,
            egress_bhrlcch_list,
        })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(self.ba_prouting_id.is_some());
        optionals.push(self.egress_bhrlcch_list.is_some());
        optionals.push(false);

        aper::encode::encode_sequence_header(data, false, &optionals, false)?;
        if let Some(x) = &self.ba_prouting_id {
            x.encode(data)?;
        }
        if let Some(x) = &self.egress_bhrlcch_list {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl AperCodec for BhInfo {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        BhInfo::decode_inner(data).map_err(|e: AperCodecError| e.push_context("BhInfo"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("BhInfo"))
    }
}
// BhQosInformation
#[derive(Clone, Debug)]
pub enum BhQosInformation {
    BhrlcchQos(QosFlowLevelQosParameters),
    EutranBhrlcchQos(EutranQos),
    CpTrafficType(CpTrafficType),
}

impl BhQosInformation {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (idx, extended) = aper::decode::decode_choice_idx(data, 0, 3, false)?;
        if extended {
            return Err(aper::AperCodecError::new(
                "CHOICE additions not implemented",
            ));
        }
        match idx {
            0 => Ok(Self::BhrlcchQos(QosFlowLevelQosParameters::decode(data)?)),
            1 => Ok(Self::EutranBhrlcchQos(EutranQos::decode(data)?)),
            2 => Ok(Self::CpTrafficType(CpTrafficType::decode(data)?)),
            3 => Err(AperCodecError::new(
                "Choice extension container not implemented",
            )),
            _ => Err(AperCodecError::new("Unknown choice idx")),
        }
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        match self {
            Self::BhrlcchQos(x) => {
                aper::encode::encode_choice_idx(data, 0, 3, false, 0, false)?;
                x.encode(data)
            }
            Self::EutranBhrlcchQos(x) => {
                aper::encode::encode_choice_idx(data, 0, 3, false, 1, false)?;
                x.encode(data)
            }
            Self::CpTrafficType(x) => {
                aper::encode::encode_choice_idx(data, 0, 3, false, 2, false)?;
                x.encode(data)
            }
        }
    }
}

impl AperCodec for BhQosInformation {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        BhQosInformation::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("BhQosInformation"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("BhQosInformation"))
    }
}
// BhRoutingInformationAddedListItem
#[derive(Clone, Debug)]
pub struct BhRoutingInformationAddedListItem {
    pub bap_routing_id: BapRoutingId,
    pub next_hop_bap_address: BapAddress,
}

impl BhRoutingInformationAddedListItem {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (_optionals, _extensions_present) =
            aper::decode::decode_sequence_header(data, false, 1)?;
        let bap_routing_id = BapRoutingId::decode(data)?;
        let next_hop_bap_address = BapAddress::decode(data)?;

        Ok(Self {
            bap_routing_id,
            next_hop_bap_address,
        })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(false);

        aper::encode::encode_sequence_header(data, false, &optionals, false)?;
        self.bap_routing_id.encode(data)?;
        self.next_hop_bap_address.encode(data)?;

        Ok(())
    }
}

impl AperCodec for BhRoutingInformationAddedListItem {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        BhRoutingInformationAddedListItem::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("BhRoutingInformationAddedListItem"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("BhRoutingInformationAddedListItem"))
    }
}
// BhRoutingInformationRemovedListItem
#[derive(Clone, Debug)]
pub struct BhRoutingInformationRemovedListItem {
    pub bap_routing_id: BapRoutingId,
}

impl BhRoutingInformationRemovedListItem {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (_optionals, _extensions_present) =
            aper::decode::decode_sequence_header(data, false, 1)?;
        let bap_routing_id = BapRoutingId::decode(data)?;

        Ok(Self { bap_routing_id })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(false);

        aper::encode::encode_sequence_header(data, false, &optionals, false)?;
        self.bap_routing_id.encode(data)?;

        Ok(())
    }
}

impl AperCodec for BhRoutingInformationRemovedListItem {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        BhRoutingInformationRemovedListItem::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("BhRoutingInformationRemovedListItem"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("BhRoutingInformationRemovedListItem"))
    }
}
// BPlmnIdInfoList
#[derive(Clone, Debug)]
pub struct BPlmnIdInfoList(pub Vec<BPlmnIdInfoItem>);

impl BPlmnIdInfoList {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        Ok(Self({
            let length = aper::decode::decode_length_determinent(data, Some(1), Some(12), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(BPlmnIdInfoItem::decode(data)?);
            }
            items
        }))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_length_determinent(data, Some(1), Some(12), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl AperCodec for BPlmnIdInfoList {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        BPlmnIdInfoList::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("BPlmnIdInfoList"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("BPlmnIdInfoList"))
    }
}
// BPlmnIdInfoItem
#[derive(Clone, Debug)]
pub struct BPlmnIdInfoItem {
    pub plmn_identity_list: AvailablePlmnList,
    pub extended_plmn_identity_list: Option<ExtendedAvailablePlmnList>,
    pub five_gs_tac: Option<FiveGsTac>,
    pub nr_cell_id: NrCellIdentity,
    pub ranac: Option<Ranac>,
}

impl BPlmnIdInfoItem {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (optionals, _extensions_present) = aper::decode::decode_sequence_header(data, true, 4)?;
        let plmn_identity_list = AvailablePlmnList::decode(data)?;
        let extended_plmn_identity_list = if optionals[0] {
            Some(ExtendedAvailablePlmnList::decode(data)?)
        } else {
            None
        };
        let five_gs_tac = if optionals[1] {
            Some(FiveGsTac::decode(data)?)
        } else {
            None
        };
        let nr_cell_id = NrCellIdentity::decode(data)?;
        let ranac = if optionals[2] {
            Some(Ranac::decode(data)?)
        } else {
            None
        };

        Ok(Self {
            plmn_identity_list,
            extended_plmn_identity_list,
            five_gs_tac,
            nr_cell_id,
            ranac,
        })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(self.extended_plmn_identity_list.is_some());
        optionals.push(self.five_gs_tac.is_some());
        optionals.push(self.ranac.is_some());
        optionals.push(false);

        aper::encode::encode_sequence_header(data, true, &optionals, false)?;
        self.plmn_identity_list.encode(data)?;
        if let Some(x) = &self.extended_plmn_identity_list {
            x.encode(data)?;
        }
        if let Some(x) = &self.five_gs_tac {
            x.encode(data)?;
        }
        self.nr_cell_id.encode(data)?;
        if let Some(x) = &self.ranac {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl AperCodec for BPlmnIdInfoItem {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        BPlmnIdInfoItem::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("BPlmnIdInfoItem"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("BPlmnIdInfoItem"))
    }
}
// ServedPlmnSList
#[derive(Clone, Debug)]
pub struct ServedPlmnSList(pub Vec<ServedPlmnSItem>);

impl ServedPlmnSList {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        Ok(Self({
            let length = aper::decode::decode_length_determinent(data, Some(1), Some(6), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(ServedPlmnSItem::decode(data)?);
            }
            items
        }))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_length_determinent(data, Some(1), Some(6), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl AperCodec for ServedPlmnSList {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        ServedPlmnSList::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("ServedPlmnSList"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("ServedPlmnSList"))
    }
}
// ServedPlmnSItem
#[derive(Clone, Debug)]
pub struct ServedPlmnSItem {
    pub plmn_identity: PlmnIdentity,
}

impl ServedPlmnSItem {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (_optionals, _extensions_present) =
            aper::decode::decode_sequence_header(data, true, 1)?;
        let plmn_identity = PlmnIdentity::decode(data)?;

        Ok(Self { plmn_identity })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(false);

        aper::encode::encode_sequence_header(data, true, &optionals, false)?;
        self.plmn_identity.encode(data)?;

        Ok(())
    }
}

impl AperCodec for ServedPlmnSItem {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        ServedPlmnSItem::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("ServedPlmnSItem"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("ServedPlmnSItem"))
    }
}
// BroadcastCagList
#[derive(Clone, Debug)]
pub struct BroadcastCagList(pub Vec<Cagid>);

impl BroadcastCagList {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        Ok(Self({
            let length = aper::decode::decode_length_determinent(data, Some(1), Some(12), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(Cagid::decode(data)?);
            }
            items
        }))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_length_determinent(data, Some(1), Some(12), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl AperCodec for BroadcastCagList {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        BroadcastCagList::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("BroadcastCagList"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("BroadcastCagList"))
    }
}
// BroadcastNidList
#[derive(Clone, Debug)]
pub struct BroadcastNidList(pub Vec<Nid>);

impl BroadcastNidList {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        Ok(Self({
            let length = aper::decode::decode_length_determinent(data, Some(1), Some(12), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(Nid::decode(data)?);
            }
            items
        }))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_length_determinent(data, Some(1), Some(12), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl AperCodec for BroadcastNidList {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        BroadcastNidList::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("BroadcastNidList"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("BroadcastNidList"))
    }
}
// BroadcastSnpnIdList
#[derive(Clone, Debug)]
pub struct BroadcastSnpnIdList(pub Vec<BroadcastSnpnIdListItem>);

impl BroadcastSnpnIdList {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        Ok(Self({
            let length = aper::decode::decode_length_determinent(data, Some(1), Some(12), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(BroadcastSnpnIdListItem::decode(data)?);
            }
            items
        }))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_length_determinent(data, Some(1), Some(12), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl AperCodec for BroadcastSnpnIdList {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        BroadcastSnpnIdList::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("BroadcastSnpnIdList"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("BroadcastSnpnIdList"))
    }
}
// BroadcastSnpnIdListItem
#[derive(Clone, Debug)]
pub struct BroadcastSnpnIdListItem {
    pub plmn_identity: PlmnIdentity,
    pub broadcast_nid_list: BroadcastNidList,
}

impl BroadcastSnpnIdListItem {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (_optionals, _extensions_present) =
            aper::decode::decode_sequence_header(data, true, 1)?;
        let plmn_identity = PlmnIdentity::decode(data)?;
        let broadcast_nid_list = BroadcastNidList::decode(data)?;

        Ok(Self {
            plmn_identity,
            broadcast_nid_list,
        })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(false);

        aper::encode::encode_sequence_header(data, true, &optionals, false)?;
        self.plmn_identity.encode(data)?;
        self.broadcast_nid_list.encode(data)?;

        Ok(())
    }
}

impl AperCodec for BroadcastSnpnIdListItem {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        BroadcastSnpnIdListItem::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("BroadcastSnpnIdListItem"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("BroadcastSnpnIdListItem"))
    }
}
// BroadcastPniNpnIdList
#[derive(Clone, Debug)]
pub struct BroadcastPniNpnIdList(pub Vec<BroadcastPniNpnIdListItem>);

impl BroadcastPniNpnIdList {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        Ok(Self({
            let length = aper::decode::decode_length_determinent(data, Some(1), Some(12), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(BroadcastPniNpnIdListItem::decode(data)?);
            }
            items
        }))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_length_determinent(data, Some(1), Some(12), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl AperCodec for BroadcastPniNpnIdList {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        BroadcastPniNpnIdList::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("BroadcastPniNpnIdList"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("BroadcastPniNpnIdList"))
    }
}
// BroadcastPniNpnIdListItem
#[derive(Clone, Debug)]
pub struct BroadcastPniNpnIdListItem {
    pub plmn_identity: PlmnIdentity,
    pub broadcast_cag_list: BroadcastCagList,
}

impl BroadcastPniNpnIdListItem {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (_optionals, _extensions_present) =
            aper::decode::decode_sequence_header(data, true, 1)?;
        let plmn_identity = PlmnIdentity::decode(data)?;
        let broadcast_cag_list = BroadcastCagList::decode(data)?;

        Ok(Self {
            plmn_identity,
            broadcast_cag_list,
        })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(false);

        aper::encode::encode_sequence_header(data, true, &optionals, false)?;
        self.plmn_identity.encode(data)?;
        self.broadcast_cag_list.encode(data)?;

        Ok(())
    }
}

impl AperCodec for BroadcastPniNpnIdListItem {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        BroadcastPniNpnIdListItem::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("BroadcastPniNpnIdListItem"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("BroadcastPniNpnIdListItem"))
    }
}
// BurstArrivalTime
#[derive(Clone, Debug)]
pub struct BurstArrivalTime(pub Vec<u8>);

impl BurstArrivalTime {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        Ok(Self(aper::decode::decode_octetstring(
            data, None, None, false,
        )?))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_octetstring(data, None, None, false, &self.0, false)
    }
}

impl AperCodec for BurstArrivalTime {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        BurstArrivalTime::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("BurstArrivalTime"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("BurstArrivalTime"))
    }
}
// Cagid
#[derive(Clone, Debug)]
pub struct Cagid(pub BitString);

impl Cagid {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        Ok(Self(aper::decode::decode_bitstring(
            data,
            Some(32),
            Some(32),
            false,
        )?))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_bitstring(data, Some(32), Some(32), false, &self.0, false)
    }
}

impl AperCodec for Cagid {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        Cagid::decode_inner(data).map_err(|e: AperCodecError| e.push_context("Cagid"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("Cagid"))
    }
}
// CancelAllWarningMessagesIndicator
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum CancelAllWarningMessagesIndicator {
    True,
}

impl CancelAllWarningMessagesIndicator {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (idx, extended) = aper::decode::decode_enumerated(data, Some(0), Some(0), true)?;
        if extended {
            return Err(aper::AperCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| AperCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_enumerated(data, Some(0), Some(0), true, *self as i128, false)
    }
}

impl AperCodec for CancelAllWarningMessagesIndicator {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        CancelAllWarningMessagesIndicator::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("CancelAllWarningMessagesIndicator"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("CancelAllWarningMessagesIndicator"))
    }
}
// CandidateSpCellItem
#[derive(Clone, Debug)]
pub struct CandidateSpCellItem {
    pub candidate_sp_cell_id: Nrcgi,
}

impl CandidateSpCellItem {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (_optionals, _extensions_present) =
            aper::decode::decode_sequence_header(data, true, 1)?;
        let candidate_sp_cell_id = Nrcgi::decode(data)?;

        Ok(Self {
            candidate_sp_cell_id,
        })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(false);

        aper::encode::encode_sequence_header(data, true, &optionals, false)?;
        self.candidate_sp_cell_id.encode(data)?;

        Ok(())
    }
}

impl AperCodec for CandidateSpCellItem {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        CandidateSpCellItem::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("CandidateSpCellItem"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("CandidateSpCellItem"))
    }
}
// CapacityValue
#[derive(Clone, Debug)]
pub struct CapacityValue {
    pub capacity_value: u8,
    pub ssb_area_capacity_value_list: Option<SsbAreaCapacityValueList>,
}

impl CapacityValue {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (optionals, _extensions_present) =
            aper::decode::decode_sequence_header(data, false, 2)?;
        let capacity_value = aper::decode::decode_integer(data, Some(0), Some(100), false)?.0 as u8;
        let ssb_area_capacity_value_list = if optionals[0] {
            Some(SsbAreaCapacityValueList::decode(data)?)
        } else {
            None
        };

        Ok(Self {
            capacity_value,
            ssb_area_capacity_value_list,
        })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(self.ssb_area_capacity_value_list.is_some());
        optionals.push(false);

        aper::encode::encode_sequence_header(data, false, &optionals, false)?;
        aper::encode::encode_integer(
            data,
            Some(0),
            Some(100),
            false,
            self.capacity_value as i128,
            false,
        )?;
        if let Some(x) = &self.ssb_area_capacity_value_list {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl AperCodec for CapacityValue {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        CapacityValue::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("CapacityValue"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("CapacityValue"))
    }
}
// Cause
#[derive(Clone, Debug)]
pub enum Cause {
    RadioNetwork(CauseRadioNetwork),
    Transport(CauseTransport),
    Protocol(CauseProtocol),
    Misc(CauseMisc),
}

impl Cause {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (idx, extended) = aper::decode::decode_choice_idx(data, 0, 4, false)?;
        if extended {
            return Err(aper::AperCodecError::new(
                "CHOICE additions not implemented",
            ));
        }
        match idx {
            0 => Ok(Self::RadioNetwork(CauseRadioNetwork::decode(data)?)),
            1 => Ok(Self::Transport(CauseTransport::decode(data)?)),
            2 => Ok(Self::Protocol(CauseProtocol::decode(data)?)),
            3 => Ok(Self::Misc(CauseMisc::decode(data)?)),
            4 => Err(AperCodecError::new(
                "Choice extension container not implemented",
            )),
            _ => Err(AperCodecError::new("Unknown choice idx")),
        }
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        match self {
            Self::RadioNetwork(x) => {
                aper::encode::encode_choice_idx(data, 0, 4, false, 0, false)?;
                x.encode(data)
            }
            Self::Transport(x) => {
                aper::encode::encode_choice_idx(data, 0, 4, false, 1, false)?;
                x.encode(data)
            }
            Self::Protocol(x) => {
                aper::encode::encode_choice_idx(data, 0, 4, false, 2, false)?;
                x.encode(data)
            }
            Self::Misc(x) => {
                aper::encode::encode_choice_idx(data, 0, 4, false, 3, false)?;
                x.encode(data)
            }
        }
    }
}

impl AperCodec for Cause {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        Cause::decode_inner(data).map_err(|e: AperCodecError| e.push_context("Cause"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("Cause"))
    }
}
// CauseMisc
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum CauseMisc {
    ControlProcessingOverload,
    NotEnoughUserPlaneProcessingResources,
    HardwareFailure,
    OmIntervention,
    Unspecified,
}

impl CauseMisc {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (idx, extended) = aper::decode::decode_enumerated(data, Some(0), Some(4), true)?;
        if extended {
            return Err(aper::AperCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| AperCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_enumerated(data, Some(0), Some(4), true, *self as i128, false)
    }
}

impl AperCodec for CauseMisc {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        CauseMisc::decode_inner(data).map_err(|e: AperCodecError| e.push_context("CauseMisc"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("CauseMisc"))
    }
}
// CauseProtocol
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum CauseProtocol {
    TransferSyntaxError,
    AbstractSyntaxErrorReject,
    AbstractSyntaxErrorIgnoreAndNotify,
    MessageNotCompatibleWithReceiverState,
    SemanticError,
    AbstractSyntaxErrorFalselyConstructedMessage,
    Unspecified,
}

impl CauseProtocol {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (idx, extended) = aper::decode::decode_enumerated(data, Some(0), Some(6), true)?;
        if extended {
            return Err(aper::AperCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| AperCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_enumerated(data, Some(0), Some(6), true, *self as i128, false)
    }
}

impl AperCodec for CauseProtocol {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        CauseProtocol::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("CauseProtocol"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("CauseProtocol"))
    }
}
// CauseRadioNetwork
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum CauseRadioNetwork {
    Unspecified,
    RlFailureRlc,
    UnknownOrAlreadyAllocatedGnbCuUeF1apId,
    UnknownOrAlreadyAllocatedGnbDuUeF1apId,
    UnknownOrInconsistentPairOfUeF1apId,
    InteractionWithOtherProcedure,
    NotSupportedQciValue,
    ActionDesirableForRadioReasons,
    NoRadioResourcesAvailable,
    ProcedureCancelled,
    NormalRelease,
}

impl CauseRadioNetwork {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (idx, extended) = aper::decode::decode_enumerated(data, Some(0), Some(10), true)?;
        if extended {
            return Err(aper::AperCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| AperCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_enumerated(data, Some(0), Some(10), true, *self as i128, false)
    }
}

impl AperCodec for CauseRadioNetwork {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        CauseRadioNetwork::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("CauseRadioNetwork"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("CauseRadioNetwork"))
    }
}
// CauseTransport
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum CauseTransport {
    Unspecified,
    TransportResourceUnavailable,
}

impl CauseTransport {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (idx, extended) = aper::decode::decode_enumerated(data, Some(0), Some(1), true)?;
        if extended {
            return Err(aper::AperCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| AperCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_enumerated(data, Some(0), Some(1), true, *self as i128, false)
    }
}

impl AperCodec for CauseTransport {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        CauseTransport::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("CauseTransport"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("CauseTransport"))
    }
}
// CellGroupConfig
#[derive(Clone, Debug)]
pub struct CellGroupConfig(pub Vec<u8>);

impl CellGroupConfig {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        Ok(Self(aper::decode::decode_octetstring(
            data, None, None, false,
        )?))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_octetstring(data, None, None, false, &self.0, false)
    }
}

impl AperCodec for CellGroupConfig {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        CellGroupConfig::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("CellGroupConfig"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("CellGroupConfig"))
    }
}
// CellCapacityClassValue
#[derive(Clone, Debug)]
pub struct CellCapacityClassValue(pub u8);

impl CellCapacityClassValue {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        Ok(Self(
            aper::decode::decode_integer(data, Some(1), Some(100), true)?.0 as u8,
        ))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_integer(data, Some(1), Some(100), true, self.0 as i128, false)
    }
}

impl AperCodec for CellCapacityClassValue {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        CellCapacityClassValue::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("CellCapacityClassValue"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("CellCapacityClassValue"))
    }
}
// CellDirection
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum CellDirection {
    DlOnly,
    UlOnly,
}

impl CellDirection {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (idx, extended) = aper::decode::decode_enumerated(data, Some(0), Some(1), false)?;
        if extended {
            return Err(aper::AperCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| AperCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_enumerated(data, Some(0), Some(1), false, *self as i128, false)
    }
}

impl AperCodec for CellDirection {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        CellDirection::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("CellDirection"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("CellDirection"))
    }
}
// CellMeasurementResultList
#[derive(Clone, Debug)]
pub struct CellMeasurementResultList(pub Vec<CellMeasurementResultItem>);

impl CellMeasurementResultList {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        Ok(Self({
            let length = aper::decode::decode_length_determinent(data, Some(1), Some(512), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(CellMeasurementResultItem::decode(data)?);
            }
            items
        }))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_length_determinent(data, Some(1), Some(512), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl AperCodec for CellMeasurementResultList {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        CellMeasurementResultList::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("CellMeasurementResultList"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("CellMeasurementResultList"))
    }
}
// CellMeasurementResultItem
#[derive(Clone, Debug)]
pub struct CellMeasurementResultItem {
    pub cell_id: Nrcgi,
    pub radio_resource_status: Option<RadioResourceStatus>,
    pub composite_available_capacity_group: Option<CompositeAvailableCapacityGroup>,
    pub slice_available_capacity: Option<SliceAvailableCapacity>,
    pub numberof_active_u_es: Option<NumberofActiveUEs>,
}

impl CellMeasurementResultItem {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (optionals, _extensions_present) =
            aper::decode::decode_sequence_header(data, false, 5)?;
        let cell_id = Nrcgi::decode(data)?;
        let radio_resource_status = if optionals[0] {
            Some(RadioResourceStatus::decode(data)?)
        } else {
            None
        };
        let composite_available_capacity_group = if optionals[1] {
            Some(CompositeAvailableCapacityGroup::decode(data)?)
        } else {
            None
        };
        let slice_available_capacity = if optionals[2] {
            Some(SliceAvailableCapacity::decode(data)?)
        } else {
            None
        };
        let numberof_active_u_es = if optionals[3] {
            Some(NumberofActiveUEs::decode(data)?)
        } else {
            None
        };

        Ok(Self {
            cell_id,
            radio_resource_status,
            composite_available_capacity_group,
            slice_available_capacity,
            numberof_active_u_es,
        })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(self.radio_resource_status.is_some());
        optionals.push(self.composite_available_capacity_group.is_some());
        optionals.push(self.slice_available_capacity.is_some());
        optionals.push(self.numberof_active_u_es.is_some());
        optionals.push(false);

        aper::encode::encode_sequence_header(data, false, &optionals, false)?;
        self.cell_id.encode(data)?;
        if let Some(x) = &self.radio_resource_status {
            x.encode(data)?;
        }
        if let Some(x) = &self.composite_available_capacity_group {
            x.encode(data)?;
        }
        if let Some(x) = &self.slice_available_capacity {
            x.encode(data)?;
        }
        if let Some(x) = &self.numberof_active_u_es {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl AperCodec for CellMeasurementResultItem {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        CellMeasurementResultItem::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("CellMeasurementResultItem"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("CellMeasurementResultItem"))
    }
}
// CellPortionId
#[derive(Clone, Debug)]
pub struct CellPortionId(pub u16);

impl CellPortionId {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        Ok(Self(
            aper::decode::decode_integer(data, Some(0), Some(4095), true)?.0 as u16,
        ))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_integer(data, Some(0), Some(4095), true, self.0 as i128, false)
    }
}

impl AperCodec for CellPortionId {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        CellPortionId::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("CellPortionId"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("CellPortionId"))
    }
}
// CellsFailedToBeActivatedListItem
#[derive(Clone, Debug)]
pub struct CellsFailedToBeActivatedListItem {
    pub nrcgi: Nrcgi,
    pub cause: Cause,
}

impl CellsFailedToBeActivatedListItem {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (_optionals, _extensions_present) =
            aper::decode::decode_sequence_header(data, true, 1)?;
        let nrcgi = Nrcgi::decode(data)?;
        let cause = Cause::decode(data)?;

        Ok(Self { nrcgi, cause })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(false);

        aper::encode::encode_sequence_header(data, true, &optionals, false)?;
        self.nrcgi.encode(data)?;
        self.cause.encode(data)?;

        Ok(())
    }
}

impl AperCodec for CellsFailedToBeActivatedListItem {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        CellsFailedToBeActivatedListItem::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("CellsFailedToBeActivatedListItem"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("CellsFailedToBeActivatedListItem"))
    }
}
// CellsStatusItem
#[derive(Clone, Debug)]
pub struct CellsStatusItem {
    pub nrcgi: Nrcgi,
    pub service_status: ServiceStatus,
}

impl CellsStatusItem {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (_optionals, _extensions_present) =
            aper::decode::decode_sequence_header(data, true, 1)?;
        let nrcgi = Nrcgi::decode(data)?;
        let service_status = ServiceStatus::decode(data)?;

        Ok(Self {
            nrcgi,
            service_status,
        })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(false);

        aper::encode::encode_sequence_header(data, true, &optionals, false)?;
        self.nrcgi.encode(data)?;
        self.service_status.encode(data)?;

        Ok(())
    }
}

impl AperCodec for CellsStatusItem {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        CellsStatusItem::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("CellsStatusItem"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("CellsStatusItem"))
    }
}
// CellsToBeBroadcastItem
#[derive(Clone, Debug)]
pub struct CellsToBeBroadcastItem {
    pub nrcgi: Nrcgi,
}

impl CellsToBeBroadcastItem {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (_optionals, _extensions_present) =
            aper::decode::decode_sequence_header(data, true, 1)?;
        let nrcgi = Nrcgi::decode(data)?;

        Ok(Self { nrcgi })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(false);

        aper::encode::encode_sequence_header(data, true, &optionals, false)?;
        self.nrcgi.encode(data)?;

        Ok(())
    }
}

impl AperCodec for CellsToBeBroadcastItem {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        CellsToBeBroadcastItem::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("CellsToBeBroadcastItem"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("CellsToBeBroadcastItem"))
    }
}
// CellsBroadcastCompletedItem
#[derive(Clone, Debug)]
pub struct CellsBroadcastCompletedItem {
    pub nrcgi: Nrcgi,
}

impl CellsBroadcastCompletedItem {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (_optionals, _extensions_present) =
            aper::decode::decode_sequence_header(data, true, 1)?;
        let nrcgi = Nrcgi::decode(data)?;

        Ok(Self { nrcgi })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(false);

        aper::encode::encode_sequence_header(data, true, &optionals, false)?;
        self.nrcgi.encode(data)?;

        Ok(())
    }
}

impl AperCodec for CellsBroadcastCompletedItem {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        CellsBroadcastCompletedItem::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("CellsBroadcastCompletedItem"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("CellsBroadcastCompletedItem"))
    }
}
// BroadcastToBeCancelledItem
#[derive(Clone, Debug)]
pub struct BroadcastToBeCancelledItem {
    pub nrcgi: Nrcgi,
}

impl BroadcastToBeCancelledItem {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (_optionals, _extensions_present) =
            aper::decode::decode_sequence_header(data, true, 1)?;
        let nrcgi = Nrcgi::decode(data)?;

        Ok(Self { nrcgi })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(false);

        aper::encode::encode_sequence_header(data, true, &optionals, false)?;
        self.nrcgi.encode(data)?;

        Ok(())
    }
}

impl AperCodec for BroadcastToBeCancelledItem {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        BroadcastToBeCancelledItem::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("BroadcastToBeCancelledItem"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("BroadcastToBeCancelledItem"))
    }
}
// CellsBroadcastCancelledItem
#[derive(Clone, Debug)]
pub struct CellsBroadcastCancelledItem {
    pub nrcgi: Nrcgi,
    pub number_of_broadcasts: NumberOfBroadcasts,
}

impl CellsBroadcastCancelledItem {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (_optionals, _extensions_present) =
            aper::decode::decode_sequence_header(data, true, 1)?;
        let nrcgi = Nrcgi::decode(data)?;
        let number_of_broadcasts = NumberOfBroadcasts::decode(data)?;

        Ok(Self {
            nrcgi,
            number_of_broadcasts,
        })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(false);

        aper::encode::encode_sequence_header(data, true, &optionals, false)?;
        self.nrcgi.encode(data)?;
        self.number_of_broadcasts.encode(data)?;

        Ok(())
    }
}

impl AperCodec for CellsBroadcastCancelledItem {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        CellsBroadcastCancelledItem::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("CellsBroadcastCancelledItem"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("CellsBroadcastCancelledItem"))
    }
}
// CellsToBeActivatedListItem
#[derive(Clone, Debug)]
pub struct CellsToBeActivatedListItem {
    pub nrcgi: Nrcgi,
    pub nrpci: Option<Nrpci>,
}

impl CellsToBeActivatedListItem {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (optionals, _extensions_present) = aper::decode::decode_sequence_header(data, true, 2)?;
        let nrcgi = Nrcgi::decode(data)?;
        let nrpci = if optionals[0] {
            Some(Nrpci::decode(data)?)
        } else {
            None
        };

        Ok(Self { nrcgi, nrpci })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(self.nrpci.is_some());
        optionals.push(false);

        aper::encode::encode_sequence_header(data, true, &optionals, false)?;
        self.nrcgi.encode(data)?;
        if let Some(x) = &self.nrpci {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl AperCodec for CellsToBeActivatedListItem {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        CellsToBeActivatedListItem::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("CellsToBeActivatedListItem"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("CellsToBeActivatedListItem"))
    }
}
// CellsToBeDeactivatedListItem
#[derive(Clone, Debug)]
pub struct CellsToBeDeactivatedListItem {
    pub nrcgi: Nrcgi,
}

impl CellsToBeDeactivatedListItem {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (_optionals, _extensions_present) =
            aper::decode::decode_sequence_header(data, true, 1)?;
        let nrcgi = Nrcgi::decode(data)?;

        Ok(Self { nrcgi })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(false);

        aper::encode::encode_sequence_header(data, true, &optionals, false)?;
        self.nrcgi.encode(data)?;

        Ok(())
    }
}

impl AperCodec for CellsToBeDeactivatedListItem {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        CellsToBeDeactivatedListItem::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("CellsToBeDeactivatedListItem"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("CellsToBeDeactivatedListItem"))
    }
}
// CellsToBeBarredItem
#[derive(Clone, Debug)]
pub struct CellsToBeBarredItem {
    pub nrcgi: Nrcgi,
    pub cell_barred: CellBarred,
}

impl CellsToBeBarredItem {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (_optionals, _extensions_present) =
            aper::decode::decode_sequence_header(data, false, 1)?;
        let nrcgi = Nrcgi::decode(data)?;
        let cell_barred = CellBarred::decode(data)?;

        Ok(Self { nrcgi, cell_barred })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(false);

        aper::encode::encode_sequence_header(data, false, &optionals, false)?;
        self.nrcgi.encode(data)?;
        self.cell_barred.encode(data)?;

        Ok(())
    }
}

impl AperCodec for CellsToBeBarredItem {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        CellsToBeBarredItem::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("CellsToBeBarredItem"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("CellsToBeBarredItem"))
    }
}
// CellBarred
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum CellBarred {
    Barred,
    NotBarred,
}

impl CellBarred {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (idx, extended) = aper::decode::decode_enumerated(data, Some(0), Some(1), true)?;
        if extended {
            return Err(aper::AperCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| AperCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_enumerated(data, Some(0), Some(1), true, *self as i128, false)
    }
}

impl AperCodec for CellBarred {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        CellBarred::decode_inner(data).map_err(|e: AperCodecError| e.push_context("CellBarred"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("CellBarred"))
    }
}
// CellSize
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum CellSize {
    Verysmall,
    Small,
    Medium,
    Large,
}

impl CellSize {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (idx, extended) = aper::decode::decode_enumerated(data, Some(0), Some(3), true)?;
        if extended {
            return Err(aper::AperCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| AperCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_enumerated(data, Some(0), Some(3), true, *self as i128, false)
    }
}

impl AperCodec for CellSize {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        CellSize::decode_inner(data).map_err(|e: AperCodecError| e.push_context("CellSize"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("CellSize"))
    }
}
// CellToReportList
#[derive(Clone, Debug)]
pub struct CellToReportList(pub Vec<CellToReportItem>);

impl CellToReportList {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        Ok(Self({
            let length = aper::decode::decode_length_determinent(data, Some(1), Some(512), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(CellToReportItem::decode(data)?);
            }
            items
        }))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_length_determinent(data, Some(1), Some(512), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl AperCodec for CellToReportList {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        CellToReportList::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("CellToReportList"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("CellToReportList"))
    }
}
// CellToReportItem
#[derive(Clone, Debug)]
pub struct CellToReportItem {
    pub cell_id: Nrcgi,
    pub ssb_to_report_list: Option<SsbToReportList>,
    pub slice_to_report_list: Option<SliceToReportList>,
}

impl CellToReportItem {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (optionals, _extensions_present) =
            aper::decode::decode_sequence_header(data, false, 3)?;
        let cell_id = Nrcgi::decode(data)?;
        let ssb_to_report_list = if optionals[0] {
            Some(SsbToReportList::decode(data)?)
        } else {
            None
        };
        let slice_to_report_list = if optionals[1] {
            Some(SliceToReportList::decode(data)?)
        } else {
            None
        };

        Ok(Self {
            cell_id,
            ssb_to_report_list,
            slice_to_report_list,
        })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(self.ssb_to_report_list.is_some());
        optionals.push(self.slice_to_report_list.is_some());
        optionals.push(false);

        aper::encode::encode_sequence_header(data, false, &optionals, false)?;
        self.cell_id.encode(data)?;
        if let Some(x) = &self.ssb_to_report_list {
            x.encode(data)?;
        }
        if let Some(x) = &self.slice_to_report_list {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl AperCodec for CellToReportItem {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        CellToReportItem::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("CellToReportItem"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("CellToReportItem"))
    }
}
// CellType
#[derive(Clone, Debug)]
pub struct CellType {
    pub cell_size: CellSize,
}

impl CellType {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (_optionals, _extensions_present) =
            aper::decode::decode_sequence_header(data, true, 1)?;
        let cell_size = CellSize::decode(data)?;

        Ok(Self { cell_size })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(false);

        aper::encode::encode_sequence_header(data, true, &optionals, false)?;
        self.cell_size.encode(data)?;

        Ok(())
    }
}

impl AperCodec for CellType {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        CellType::decode_inner(data).map_err(|e: AperCodecError| e.push_context("CellType"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("CellType"))
    }
}
// CellUlConfigured
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum CellUlConfigured {
    None,
    Ul,
    Sul,
    UlAndSul,
}

impl CellUlConfigured {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (idx, extended) = aper::decode::decode_enumerated(data, Some(0), Some(3), true)?;
        if extended {
            return Err(aper::AperCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| AperCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_enumerated(data, Some(0), Some(3), true, *self as i128, false)
    }
}

impl AperCodec for CellUlConfigured {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        CellUlConfigured::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("CellUlConfigured"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("CellUlConfigured"))
    }
}
// ChildNodeCellsList
#[derive(Clone, Debug)]
pub struct ChildNodeCellsList(pub Vec<ChildNodeCellsListItem>);

impl ChildNodeCellsList {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        Ok(Self({
            let length = aper::decode::decode_length_determinent(data, Some(1), Some(1024), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(ChildNodeCellsListItem::decode(data)?);
            }
            items
        }))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_length_determinent(data, Some(1), Some(1024), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl AperCodec for ChildNodeCellsList {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        ChildNodeCellsList::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("ChildNodeCellsList"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("ChildNodeCellsList"))
    }
}
// ChildNodeCellsListItem
#[derive(Clone, Debug)]
pub struct ChildNodeCellsListItem {
    pub nrcgi: Nrcgi,
    pub iab_du_cell_resource_configuration_mode_info:
        Option<IabDuCellResourceConfigurationModeInfo>,
    pub iab_stc_info: Option<IabStcInfo>,
    pub rach_config_common: Option<RachConfigCommon>,
    pub rach_config_common_iab: Option<RachConfigCommonIab>,
    pub csi_rs_configuration: Option<Vec<u8>>,
    pub sr_configuration: Option<Vec<u8>>,
    pub pdcch_config_sib1: Option<Vec<u8>>,
    pub scs_common: Option<Vec<u8>>,
    pub multiplexing_info: Option<MultiplexingInfo>,
}

impl ChildNodeCellsListItem {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (optionals, _extensions_present) =
            aper::decode::decode_sequence_header(data, false, 10)?;
        let nrcgi = Nrcgi::decode(data)?;
        let iab_du_cell_resource_configuration_mode_info = if optionals[0] {
            Some(IabDuCellResourceConfigurationModeInfo::decode(data)?)
        } else {
            None
        };
        let iab_stc_info = if optionals[1] {
            Some(IabStcInfo::decode(data)?)
        } else {
            None
        };
        let rach_config_common = if optionals[2] {
            Some(RachConfigCommon::decode(data)?)
        } else {
            None
        };
        let rach_config_common_iab = if optionals[3] {
            Some(RachConfigCommonIab::decode(data)?)
        } else {
            None
        };
        let csi_rs_configuration = if optionals[4] {
            Some(aper::decode::decode_octetstring(data, None, None, false)?)
        } else {
            None
        };
        let sr_configuration = if optionals[5] {
            Some(aper::decode::decode_octetstring(data, None, None, false)?)
        } else {
            None
        };
        let pdcch_config_sib1 = if optionals[6] {
            Some(aper::decode::decode_octetstring(data, None, None, false)?)
        } else {
            None
        };
        let scs_common = if optionals[7] {
            Some(aper::decode::decode_octetstring(data, None, None, false)?)
        } else {
            None
        };
        let multiplexing_info = if optionals[8] {
            Some(MultiplexingInfo::decode(data)?)
        } else {
            None
        };

        Ok(Self {
            nrcgi,
            iab_du_cell_resource_configuration_mode_info,
            iab_stc_info,
            rach_config_common,
            rach_config_common_iab,
            csi_rs_configuration,
            sr_configuration,
            pdcch_config_sib1,
            scs_common,
            multiplexing_info,
        })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(self.iab_du_cell_resource_configuration_mode_info.is_some());
        optionals.push(self.iab_stc_info.is_some());
        optionals.push(self.rach_config_common.is_some());
        optionals.push(self.rach_config_common_iab.is_some());
        optionals.push(self.csi_rs_configuration.is_some());
        optionals.push(self.sr_configuration.is_some());
        optionals.push(self.pdcch_config_sib1.is_some());
        optionals.push(self.scs_common.is_some());
        optionals.push(self.multiplexing_info.is_some());
        optionals.push(false);

        aper::encode::encode_sequence_header(data, false, &optionals, false)?;
        self.nrcgi.encode(data)?;
        if let Some(x) = &self.iab_du_cell_resource_configuration_mode_info {
            x.encode(data)?;
        }
        if let Some(x) = &self.iab_stc_info {
            x.encode(data)?;
        }
        if let Some(x) = &self.rach_config_common {
            x.encode(data)?;
        }
        if let Some(x) = &self.rach_config_common_iab {
            x.encode(data)?;
        }
        if let Some(x) = &self.csi_rs_configuration {
            aper::encode::encode_octetstring(data, None, None, false, &x, false)?;
        }
        if let Some(x) = &self.sr_configuration {
            aper::encode::encode_octetstring(data, None, None, false, &x, false)?;
        }
        if let Some(x) = &self.pdcch_config_sib1 {
            aper::encode::encode_octetstring(data, None, None, false, &x, false)?;
        }
        if let Some(x) = &self.scs_common {
            aper::encode::encode_octetstring(data, None, None, false, &x, false)?;
        }
        if let Some(x) = &self.multiplexing_info {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl AperCodec for ChildNodeCellsListItem {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        ChildNodeCellsListItem::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("ChildNodeCellsListItem"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("ChildNodeCellsListItem"))
    }
}
// ChildNodesList
#[derive(Clone, Debug)]
pub struct ChildNodesList(pub Vec<ChildNodesListItem>);

impl ChildNodesList {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        Ok(Self({
            let length = aper::decode::decode_length_determinent(data, Some(1), Some(1024), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(ChildNodesListItem::decode(data)?);
            }
            items
        }))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_length_determinent(data, Some(1), Some(1024), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl AperCodec for ChildNodesList {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        ChildNodesList::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("ChildNodesList"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("ChildNodesList"))
    }
}
// ChildNodesListItem
#[derive(Clone, Debug)]
pub struct ChildNodesListItem {
    pub gnb_cu_ue_f1ap_id: GnbCuUeF1apId,
    pub gnb_du_ue_f1ap_id: GnbDuUeF1apId,
    pub child_node_cells_list: Option<ChildNodeCellsList>,
}

impl ChildNodesListItem {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (optionals, _extensions_present) =
            aper::decode::decode_sequence_header(data, false, 2)?;
        let gnb_cu_ue_f1ap_id = GnbCuUeF1apId::decode(data)?;
        let gnb_du_ue_f1ap_id = GnbDuUeF1apId::decode(data)?;
        let child_node_cells_list = if optionals[0] {
            Some(ChildNodeCellsList::decode(data)?)
        } else {
            None
        };

        Ok(Self {
            gnb_cu_ue_f1ap_id,
            gnb_du_ue_f1ap_id,
            child_node_cells_list,
        })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(self.child_node_cells_list.is_some());
        optionals.push(false);

        aper::encode::encode_sequence_header(data, false, &optionals, false)?;
        self.gnb_cu_ue_f1ap_id.encode(data)?;
        self.gnb_du_ue_f1ap_id.encode(data)?;
        if let Some(x) = &self.child_node_cells_list {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl AperCodec for ChildNodesListItem {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        ChildNodesListItem::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("ChildNodesListItem"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("ChildNodesListItem"))
    }
}
// ChOtriggerInterDu
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum ChOtriggerInterDu {
    ChoInitiation,
    ChoReplace,
}

impl ChOtriggerInterDu {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (idx, extended) = aper::decode::decode_enumerated(data, Some(0), Some(1), true)?;
        if extended {
            return Err(aper::AperCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| AperCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_enumerated(data, Some(0), Some(1), true, *self as i128, false)
    }
}

impl AperCodec for ChOtriggerInterDu {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        ChOtriggerInterDu::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("ChOtriggerInterDu"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("ChOtriggerInterDu"))
    }
}
// ChOtriggerIntraDu
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum ChOtriggerIntraDu {
    ChoInitiation,
    ChoReplace,
    ChoCancel,
}

impl ChOtriggerIntraDu {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (idx, extended) = aper::decode::decode_enumerated(data, Some(0), Some(2), true)?;
        if extended {
            return Err(aper::AperCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| AperCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_enumerated(data, Some(0), Some(2), true, *self as i128, false)
    }
}

impl AperCodec for ChOtriggerIntraDu {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        ChOtriggerIntraDu::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("ChOtriggerIntraDu"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("ChOtriggerIntraDu"))
    }
}
// CnuePagingIdentity
#[derive(Clone, Debug)]
pub enum CnuePagingIdentity {
    FiveGSTmsi(BitString),
}

impl CnuePagingIdentity {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (idx, extended) = aper::decode::decode_choice_idx(data, 0, 1, false)?;
        if extended {
            return Err(aper::AperCodecError::new(
                "CHOICE additions not implemented",
            ));
        }
        match idx {
            0 => Ok(Self::FiveGSTmsi(aper::decode::decode_bitstring(
                data,
                Some(48),
                Some(48),
                false,
            )?)),
            1 => Err(AperCodecError::new(
                "Choice extension container not implemented",
            )),
            _ => Err(AperCodecError::new("Unknown choice idx")),
        }
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        match self {
            Self::FiveGSTmsi(x) => {
                aper::encode::encode_choice_idx(data, 0, 1, false, 0, false)?;
                aper::encode::encode_bitstring(data, Some(48), Some(48), false, &x, false)
            }
        }
    }
}

impl AperCodec for CnuePagingIdentity {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        CnuePagingIdentity::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("CnuePagingIdentity"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("CnuePagingIdentity"))
    }
}
// CompositeAvailableCapacityGroup
#[derive(Clone, Debug)]
pub struct CompositeAvailableCapacityGroup {
    pub composite_available_capacity_downlink: CompositeAvailableCapacity,
    pub composite_available_capacity_uplink: CompositeAvailableCapacity,
}

impl CompositeAvailableCapacityGroup {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (_optionals, _extensions_present) =
            aper::decode::decode_sequence_header(data, false, 1)?;
        let composite_available_capacity_downlink = CompositeAvailableCapacity::decode(data)?;
        let composite_available_capacity_uplink = CompositeAvailableCapacity::decode(data)?;

        Ok(Self {
            composite_available_capacity_downlink,
            composite_available_capacity_uplink,
        })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(false);

        aper::encode::encode_sequence_header(data, false, &optionals, false)?;
        self.composite_available_capacity_downlink.encode(data)?;
        self.composite_available_capacity_uplink.encode(data)?;

        Ok(())
    }
}

impl AperCodec for CompositeAvailableCapacityGroup {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        CompositeAvailableCapacityGroup::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("CompositeAvailableCapacityGroup"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("CompositeAvailableCapacityGroup"))
    }
}
// CompositeAvailableCapacity
#[derive(Clone, Debug)]
pub struct CompositeAvailableCapacity {
    pub cell_capacity_class_value: Option<CellCapacityClassValue>,
    pub capacity_value: CapacityValue,
}

impl CompositeAvailableCapacity {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (optionals, _extensions_present) =
            aper::decode::decode_sequence_header(data, false, 2)?;
        let cell_capacity_class_value = if optionals[0] {
            Some(CellCapacityClassValue::decode(data)?)
        } else {
            None
        };
        let capacity_value = CapacityValue::decode(data)?;

        Ok(Self {
            cell_capacity_class_value,
            capacity_value,
        })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(self.cell_capacity_class_value.is_some());
        optionals.push(false);

        aper::encode::encode_sequence_header(data, false, &optionals, false)?;
        if let Some(x) = &self.cell_capacity_class_value {
            x.encode(data)?;
        }
        self.capacity_value.encode(data)?;

        Ok(())
    }
}

impl AperCodec for CompositeAvailableCapacity {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        CompositeAvailableCapacity::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("CompositeAvailableCapacity"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("CompositeAvailableCapacity"))
    }
}
// ChoProbability
#[derive(Clone, Debug)]
pub struct ChoProbability(pub u8);

impl ChoProbability {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        Ok(Self(
            aper::decode::decode_integer(data, Some(1), Some(100), false)?.0 as u8,
        ))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_integer(data, Some(1), Some(100), false, self.0 as i128, false)
    }
}

impl AperCodec for ChoProbability {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        ChoProbability::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("ChoProbability"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("ChoProbability"))
    }
}
// ConditionalInterDuMobilityInformation
#[derive(Clone, Debug)]
pub struct ConditionalInterDuMobilityInformation {
    pub cho_trigger: ChOtriggerInterDu,
    pub target_gnb_duuef1apid: Option<GnbDuUeF1apId>,
}

impl ConditionalInterDuMobilityInformation {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (optionals, _extensions_present) = aper::decode::decode_sequence_header(data, true, 2)?;
        let cho_trigger = ChOtriggerInterDu::decode(data)?;
        let target_gnb_duuef1apid = if optionals[0] {
            Some(GnbDuUeF1apId::decode(data)?)
        } else {
            None
        };

        Ok(Self {
            cho_trigger,
            target_gnb_duuef1apid,
        })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(self.target_gnb_duuef1apid.is_some());
        optionals.push(false);

        aper::encode::encode_sequence_header(data, true, &optionals, false)?;
        self.cho_trigger.encode(data)?;
        if let Some(x) = &self.target_gnb_duuef1apid {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl AperCodec for ConditionalInterDuMobilityInformation {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        ConditionalInterDuMobilityInformation::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("ConditionalInterDuMobilityInformation"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("ConditionalInterDuMobilityInformation"))
    }
}
// ConditionalIntraDuMobilityInformation
#[derive(Clone, Debug)]
pub struct ConditionalIntraDuMobilityInformation {
    pub cho_trigger: ChOtriggerIntraDu,
    pub target_cells_tocancel: Option<TargetCellList>,
}

impl ConditionalIntraDuMobilityInformation {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (optionals, _extensions_present) = aper::decode::decode_sequence_header(data, true, 2)?;
        let cho_trigger = ChOtriggerIntraDu::decode(data)?;
        let target_cells_tocancel = if optionals[0] {
            Some(TargetCellList::decode(data)?)
        } else {
            None
        };

        Ok(Self {
            cho_trigger,
            target_cells_tocancel,
        })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(self.target_cells_tocancel.is_some());
        optionals.push(false);

        aper::encode::encode_sequence_header(data, true, &optionals, false)?;
        self.cho_trigger.encode(data)?;
        if let Some(x) = &self.target_cells_tocancel {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl AperCodec for ConditionalIntraDuMobilityInformation {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        ConditionalIntraDuMobilityInformation::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("ConditionalIntraDuMobilityInformation"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("ConditionalIntraDuMobilityInformation"))
    }
}
// ConfiguredTacIndication
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum ConfiguredTacIndication {
    True,
}

impl ConfiguredTacIndication {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (idx, extended) = aper::decode::decode_enumerated(data, Some(0), Some(0), true)?;
        if extended {
            return Err(aper::AperCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| AperCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_enumerated(data, Some(0), Some(0), true, *self as i128, false)
    }
}

impl AperCodec for ConfiguredTacIndication {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        ConfiguredTacIndication::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("ConfiguredTacIndication"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("ConfiguredTacIndication"))
    }
}
// CoordinateId
#[derive(Clone, Debug)]
pub struct CoordinateId(pub u16);

impl CoordinateId {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        Ok(Self(
            aper::decode::decode_integer(data, Some(0), Some(511), true)?.0 as u16,
        ))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_integer(data, Some(0), Some(511), true, self.0 as i128, false)
    }
}

impl AperCodec for CoordinateId {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        CoordinateId::decode_inner(data).map_err(|e: AperCodecError| e.push_context("CoordinateId"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("CoordinateId"))
    }
}
// CpTransportLayerAddress
#[derive(Clone, Debug)]
pub enum CpTransportLayerAddress {
    EndpointIpAddress(TransportLayerAddress),
    EndpointIpAddressAndPort(EndpointIpAddressAndPort),
}

impl CpTransportLayerAddress {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (idx, extended) = aper::decode::decode_choice_idx(data, 0, 2, false)?;
        if extended {
            return Err(aper::AperCodecError::new(
                "CHOICE additions not implemented",
            ));
        }
        match idx {
            0 => Ok(Self::EndpointIpAddress(TransportLayerAddress::decode(
                data,
            )?)),
            1 => Ok(Self::EndpointIpAddressAndPort(
                EndpointIpAddressAndPort::decode(data)?,
            )),
            2 => Err(AperCodecError::new(
                "Choice extension container not implemented",
            )),
            _ => Err(AperCodecError::new("Unknown choice idx")),
        }
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        match self {
            Self::EndpointIpAddress(x) => {
                aper::encode::encode_choice_idx(data, 0, 2, false, 0, false)?;
                x.encode(data)
            }
            Self::EndpointIpAddressAndPort(x) => {
                aper::encode::encode_choice_idx(data, 0, 2, false, 1, false)?;
                x.encode(data)
            }
        }
    }
}

impl AperCodec for CpTransportLayerAddress {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        CpTransportLayerAddress::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("CpTransportLayerAddress"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("CpTransportLayerAddress"))
    }
}
// CpTrafficType
#[derive(Clone, Debug)]
pub struct CpTrafficType(pub u8);

impl CpTrafficType {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        Ok(Self(
            aper::decode::decode_integer(data, Some(1), Some(3), true)?.0 as u8,
        ))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_integer(data, Some(1), Some(3), true, self.0 as i128, false)
    }
}

impl AperCodec for CpTrafficType {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        CpTrafficType::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("CpTrafficType"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("CpTrafficType"))
    }
}
// CriticalityDiagnostics
#[derive(Clone, Debug)]
pub struct CriticalityDiagnostics {
    pub procedure_code: Option<ProcedureCode>,
    pub triggering_message: Option<TriggeringMessage>,
    pub procedure_criticality: Option<Criticality>,
    pub transaction_id: Option<TransactionId>,
    pub i_es_criticality_diagnostics: Option<CriticalityDiagnosticsIeList>,
}

impl CriticalityDiagnostics {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (optionals, _extensions_present) = aper::decode::decode_sequence_header(data, true, 6)?;
        let procedure_code = if optionals[0] {
            Some(ProcedureCode::decode(data)?)
        } else {
            None
        };
        let triggering_message = if optionals[1] {
            Some(TriggeringMessage::decode(data)?)
        } else {
            None
        };
        let procedure_criticality = if optionals[2] {
            Some(Criticality::decode(data)?)
        } else {
            None
        };
        let transaction_id = if optionals[3] {
            Some(TransactionId::decode(data)?)
        } else {
            None
        };
        let i_es_criticality_diagnostics = if optionals[4] {
            Some(CriticalityDiagnosticsIeList::decode(data)?)
        } else {
            None
        };

        Ok(Self {
            procedure_code,
            triggering_message,
            procedure_criticality,
            transaction_id,
            i_es_criticality_diagnostics,
        })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(self.procedure_code.is_some());
        optionals.push(self.triggering_message.is_some());
        optionals.push(self.procedure_criticality.is_some());
        optionals.push(self.transaction_id.is_some());
        optionals.push(self.i_es_criticality_diagnostics.is_some());
        optionals.push(false);

        aper::encode::encode_sequence_header(data, true, &optionals, false)?;
        if let Some(x) = &self.procedure_code {
            x.encode(data)?;
        }
        if let Some(x) = &self.triggering_message {
            x.encode(data)?;
        }
        if let Some(x) = &self.procedure_criticality {
            x.encode(data)?;
        }
        if let Some(x) = &self.transaction_id {
            x.encode(data)?;
        }
        if let Some(x) = &self.i_es_criticality_diagnostics {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl AperCodec for CriticalityDiagnostics {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        CriticalityDiagnostics::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("CriticalityDiagnostics"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("CriticalityDiagnostics"))
    }
}
// CriticalityDiagnosticsIeList
#[derive(Clone, Debug)]
pub struct CriticalityDiagnosticsIeList(pub Vec<CriticalityDiagnosticsIeItem>);

impl CriticalityDiagnosticsIeList {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        Ok(Self({
            let length = aper::decode::decode_length_determinent(data, Some(1), Some(256), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(CriticalityDiagnosticsIeItem::decode(data)?);
            }
            items
        }))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_length_determinent(data, Some(1), Some(256), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl AperCodec for CriticalityDiagnosticsIeList {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        CriticalityDiagnosticsIeList::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("CriticalityDiagnosticsIeList"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("CriticalityDiagnosticsIeList"))
    }
}
// CriticalityDiagnosticsIeItem
#[derive(Clone, Debug)]
pub struct CriticalityDiagnosticsIeItem {
    pub ie_criticality: Criticality,
    pub ie_id: ProtocolIeId,
    pub type_of_error: TypeOfError,
}

impl CriticalityDiagnosticsIeItem {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (_optionals, _extensions_present) =
            aper::decode::decode_sequence_header(data, true, 1)?;
        let ie_criticality = Criticality::decode(data)?;
        let ie_id = ProtocolIeId::decode(data)?;
        let type_of_error = TypeOfError::decode(data)?;

        Ok(Self {
            ie_criticality,
            ie_id,
            type_of_error,
        })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(false);

        aper::encode::encode_sequence_header(data, true, &optionals, false)?;
        self.ie_criticality.encode(data)?;
        self.ie_id.encode(data)?;
        self.type_of_error.encode(data)?;

        Ok(())
    }
}

impl AperCodec for CriticalityDiagnosticsIeItem {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        CriticalityDiagnosticsIeItem::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("CriticalityDiagnosticsIeItem"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("CriticalityDiagnosticsIeItem"))
    }
}
// CRnti
#[derive(Clone, Debug)]
pub struct CRnti(pub u16);

impl CRnti {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        Ok(Self(
            aper::decode::decode_integer(data, Some(0), Some(65535), true)?.0 as u16,
        ))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_integer(data, Some(0), Some(65535), true, self.0 as i128, false)
    }
}

impl AperCodec for CRnti {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        CRnti::decode_inner(data).map_err(|e: AperCodecError| e.push_context("CRnti"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("CRnti"))
    }
}
// CuduRadioInformationType
#[derive(Clone, Debug)]
pub enum CuduRadioInformationType {
    Rim(CudurimInformation),
}

impl CuduRadioInformationType {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (idx, extended) = aper::decode::decode_choice_idx(data, 0, 1, false)?;
        if extended {
            return Err(aper::AperCodecError::new(
                "CHOICE additions not implemented",
            ));
        }
        match idx {
            0 => Ok(Self::Rim(CudurimInformation::decode(data)?)),
            1 => Err(AperCodecError::new(
                "Choice extension container not implemented",
            )),
            _ => Err(AperCodecError::new("Unknown choice idx")),
        }
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        match self {
            Self::Rim(x) => {
                aper::encode::encode_choice_idx(data, 0, 1, false, 0, false)?;
                x.encode(data)
            }
        }
    }
}

impl AperCodec for CuduRadioInformationType {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        CuduRadioInformationType::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("CuduRadioInformationType"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("CuduRadioInformationType"))
    }
}
// CudurimInformation
#[derive(Clone, Debug)]
pub struct CudurimInformation {
    pub victim_gnb_set_id: GnbSetId,
    pub rimrs_detection_status: RimrsDetectionStatus,
}

impl CudurimInformation {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (_optionals, _extensions_present) =
            aper::decode::decode_sequence_header(data, false, 1)?;
        let victim_gnb_set_id = GnbSetId::decode(data)?;
        let rimrs_detection_status = RimrsDetectionStatus::decode(data)?;

        Ok(Self {
            victim_gnb_set_id,
            rimrs_detection_status,
        })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(false);

        aper::encode::encode_sequence_header(data, false, &optionals, false)?;
        self.victim_gnb_set_id.encode(data)?;
        self.rimrs_detection_status.encode(data)?;

        Ok(())
    }
}

impl AperCodec for CudurimInformation {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        CudurimInformation::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("CudurimInformation"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("CudurimInformation"))
    }
}
// CUtoDurrcInformation
#[derive(Clone, Debug)]
pub struct CUtoDurrcInformation {
    pub cg_config_info: Option<CgConfigInfo>,
    pub ue_capability_rat_container_list: Option<UeCapabilityRatContainerList>,
    pub meas_config: Option<MeasConfig>,
}

impl CUtoDurrcInformation {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (optionals, _extensions_present) = aper::decode::decode_sequence_header(data, true, 4)?;
        let cg_config_info = if optionals[0] {
            Some(CgConfigInfo::decode(data)?)
        } else {
            None
        };
        let ue_capability_rat_container_list = if optionals[1] {
            Some(UeCapabilityRatContainerList::decode(data)?)
        } else {
            None
        };
        let meas_config = if optionals[2] {
            Some(MeasConfig::decode(data)?)
        } else {
            None
        };

        Ok(Self {
            cg_config_info,
            ue_capability_rat_container_list,
            meas_config,
        })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(self.cg_config_info.is_some());
        optionals.push(self.ue_capability_rat_container_list.is_some());
        optionals.push(self.meas_config.is_some());
        optionals.push(false);

        aper::encode::encode_sequence_header(data, true, &optionals, false)?;
        if let Some(x) = &self.cg_config_info {
            x.encode(data)?;
        }
        if let Some(x) = &self.ue_capability_rat_container_list {
            x.encode(data)?;
        }
        if let Some(x) = &self.meas_config {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl AperCodec for CUtoDurrcInformation {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        CUtoDurrcInformation::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("CUtoDurrcInformation"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("CUtoDurrcInformation"))
    }
}
// DcBasedDuplicationConfigured
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum DcBasedDuplicationConfigured {
    True,
}

impl DcBasedDuplicationConfigured {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (idx, extended) = aper::decode::decode_enumerated(data, Some(0), Some(0), true)?;
        if extended {
            return Err(aper::AperCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| AperCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_enumerated(data, Some(0), Some(0), true, *self as i128, false)
    }
}

impl AperCodec for DcBasedDuplicationConfigured {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        DcBasedDuplicationConfigured::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("DcBasedDuplicationConfigured"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("DcBasedDuplicationConfigured"))
    }
}
// DedicatedSiDeliveryNeededUeItem
#[derive(Clone, Debug)]
pub struct DedicatedSiDeliveryNeededUeItem {
    pub gnb_cu_ue_f1ap_id: GnbCuUeF1apId,
    pub nrcgi: Nrcgi,
}

impl DedicatedSiDeliveryNeededUeItem {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (_optionals, _extensions_present) =
            aper::decode::decode_sequence_header(data, true, 1)?;
        let gnb_cu_ue_f1ap_id = GnbCuUeF1apId::decode(data)?;
        let nrcgi = Nrcgi::decode(data)?;

        Ok(Self {
            gnb_cu_ue_f1ap_id,
            nrcgi,
        })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(false);

        aper::encode::encode_sequence_header(data, true, &optionals, false)?;
        self.gnb_cu_ue_f1ap_id.encode(data)?;
        self.nrcgi.encode(data)?;

        Ok(())
    }
}

impl AperCodec for DedicatedSiDeliveryNeededUeItem {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        DedicatedSiDeliveryNeededUeItem::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("DedicatedSiDeliveryNeededUeItem"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("DedicatedSiDeliveryNeededUeItem"))
    }
}
// DlPrs
#[derive(Clone, Debug)]
pub struct DlPrs {
    pub prsid: u8,
    pub dl_prs_resource_set_id: PrsResourceSetId,
    pub dl_prs_resource_id: Option<PrsResourceId>,
}

impl DlPrs {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (optionals, _extensions_present) =
            aper::decode::decode_sequence_header(data, false, 2)?;
        let prsid = aper::decode::decode_integer(data, Some(0), Some(255), false)?.0 as u8;
        let dl_prs_resource_set_id = PrsResourceSetId::decode(data)?;
        let dl_prs_resource_id = if optionals[0] {
            Some(PrsResourceId::decode(data)?)
        } else {
            None
        };

        Ok(Self {
            prsid,
            dl_prs_resource_set_id,
            dl_prs_resource_id,
        })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(self.dl_prs_resource_id.is_some());
        optionals.push(false);

        aper::encode::encode_sequence_header(data, false, &optionals, false)?;
        aper::encode::encode_integer(data, Some(0), Some(255), false, self.prsid as i128, false)?;
        self.dl_prs_resource_set_id.encode(data)?;
        if let Some(x) = &self.dl_prs_resource_id {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl AperCodec for DlPrs {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        DlPrs::decode_inner(data).map_err(|e: AperCodecError| e.push_context("DlPrs"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("DlPrs"))
    }
}
// DlPrsMutingPattern
#[derive(Clone, Debug)]
pub enum DlPrsMutingPattern {
    Two(BitString),
    Four(BitString),
    Six(BitString),
    Eight(BitString),
    Sixteen(BitString),
    ThirtyTwo(BitString),
}

impl DlPrsMutingPattern {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (idx, extended) = aper::decode::decode_choice_idx(data, 0, 6, false)?;
        if extended {
            return Err(aper::AperCodecError::new(
                "CHOICE additions not implemented",
            ));
        }
        match idx {
            0 => Ok(Self::Two(aper::decode::decode_bitstring(
                data,
                Some(2),
                Some(2),
                false,
            )?)),
            1 => Ok(Self::Four(aper::decode::decode_bitstring(
                data,
                Some(4),
                Some(4),
                false,
            )?)),
            2 => Ok(Self::Six(aper::decode::decode_bitstring(
                data,
                Some(6),
                Some(6),
                false,
            )?)),
            3 => Ok(Self::Eight(aper::decode::decode_bitstring(
                data,
                Some(8),
                Some(8),
                false,
            )?)),
            4 => Ok(Self::Sixteen(aper::decode::decode_bitstring(
                data,
                Some(16),
                Some(16),
                false,
            )?)),
            5 => Ok(Self::ThirtyTwo(aper::decode::decode_bitstring(
                data,
                Some(32),
                Some(32),
                false,
            )?)),
            6 => Err(AperCodecError::new(
                "Choice extension container not implemented",
            )),
            _ => Err(AperCodecError::new("Unknown choice idx")),
        }
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        match self {
            Self::Two(x) => {
                aper::encode::encode_choice_idx(data, 0, 6, false, 0, false)?;
                aper::encode::encode_bitstring(data, Some(2), Some(2), false, &x, false)
            }
            Self::Four(x) => {
                aper::encode::encode_choice_idx(data, 0, 6, false, 1, false)?;
                aper::encode::encode_bitstring(data, Some(4), Some(4), false, &x, false)
            }
            Self::Six(x) => {
                aper::encode::encode_choice_idx(data, 0, 6, false, 2, false)?;
                aper::encode::encode_bitstring(data, Some(6), Some(6), false, &x, false)
            }
            Self::Eight(x) => {
                aper::encode::encode_choice_idx(data, 0, 6, false, 3, false)?;
                aper::encode::encode_bitstring(data, Some(8), Some(8), false, &x, false)
            }
            Self::Sixteen(x) => {
                aper::encode::encode_choice_idx(data, 0, 6, false, 4, false)?;
                aper::encode::encode_bitstring(data, Some(16), Some(16), false, &x, false)
            }
            Self::ThirtyTwo(x) => {
                aper::encode::encode_choice_idx(data, 0, 6, false, 5, false)?;
                aper::encode::encode_bitstring(data, Some(32), Some(32), false, &x, false)
            }
        }
    }
}

impl AperCodec for DlPrsMutingPattern {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        DlPrsMutingPattern::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("DlPrsMutingPattern"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("DlPrsMutingPattern"))
    }
}
// DlprsResourceCoordinates
#[derive(Clone, Debug)]
pub struct DlprsResourceCoordinates {
    pub listof_dl_prs_resource_set_arp: Vec<DlprsResourceSetArp>,
}

impl DlprsResourceCoordinates {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (_optionals, _extensions_present) =
            aper::decode::decode_sequence_header(data, false, 1)?;
        let listof_dl_prs_resource_set_arp = {
            let length = aper::decode::decode_length_determinent(data, Some(1), Some(2), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(DlprsResourceSetArp::decode(data)?);
            }
            items
        };

        Ok(Self {
            listof_dl_prs_resource_set_arp,
        })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(false);

        aper::encode::encode_sequence_header(data, false, &optionals, false)?;
        aper::encode::encode_length_determinent(
            data,
            Some(1),
            Some(2),
            false,
            self.listof_dl_prs_resource_set_arp.len(),
        )?;
        for x in &self.listof_dl_prs_resource_set_arp {
            x.encode(data)?;
        }
        Ok(())?;

        Ok(())
    }
}

impl AperCodec for DlprsResourceCoordinates {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        DlprsResourceCoordinates::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("DlprsResourceCoordinates"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("DlprsResourceCoordinates"))
    }
}
// DlprsResourceSetArp
#[derive(Clone, Debug)]
pub struct DlprsResourceSetArp {
    pub dl_prs_resource_set_id: PrsResourceSetId,
    pub dl_prs_resource_set_arp_location: DlPrsResourceSetArpLocation,
    pub listof_dl_prs_resource_arp: Vec<DlprsResourceArp>,
}

impl DlprsResourceSetArp {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (_optionals, _extensions_present) =
            aper::decode::decode_sequence_header(data, false, 1)?;
        let dl_prs_resource_set_id = PrsResourceSetId::decode(data)?;
        let dl_prs_resource_set_arp_location = DlPrsResourceSetArpLocation::decode(data)?;
        let listof_dl_prs_resource_arp = {
            let length = aper::decode::decode_length_determinent(data, Some(1), Some(64), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(DlprsResourceArp::decode(data)?);
            }
            items
        };

        Ok(Self {
            dl_prs_resource_set_id,
            dl_prs_resource_set_arp_location,
            listof_dl_prs_resource_arp,
        })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(false);

        aper::encode::encode_sequence_header(data, false, &optionals, false)?;
        self.dl_prs_resource_set_id.encode(data)?;
        self.dl_prs_resource_set_arp_location.encode(data)?;
        aper::encode::encode_length_determinent(
            data,
            Some(1),
            Some(64),
            false,
            self.listof_dl_prs_resource_arp.len(),
        )?;
        for x in &self.listof_dl_prs_resource_arp {
            x.encode(data)?;
        }
        Ok(())?;

        Ok(())
    }
}

impl AperCodec for DlprsResourceSetArp {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        DlprsResourceSetArp::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("DlprsResourceSetArp"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("DlprsResourceSetArp"))
    }
}
// DlPrsResourceSetArpLocation
#[derive(Clone, Debug)]
pub enum DlPrsResourceSetArpLocation {
    RelativeGeodeticLocation(RelativeGeodeticLocation),
    RelativeCartesianLocation(RelativeCartesianLocation),
}

impl DlPrsResourceSetArpLocation {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (idx, extended) = aper::decode::decode_choice_idx(data, 0, 2, false)?;
        if extended {
            return Err(aper::AperCodecError::new(
                "CHOICE additions not implemented",
            ));
        }
        match idx {
            0 => Ok(Self::RelativeGeodeticLocation(
                RelativeGeodeticLocation::decode(data)?,
            )),
            1 => Ok(Self::RelativeCartesianLocation(
                RelativeCartesianLocation::decode(data)?,
            )),
            2 => Err(AperCodecError::new(
                "Choice extension container not implemented",
            )),
            _ => Err(AperCodecError::new("Unknown choice idx")),
        }
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        match self {
            Self::RelativeGeodeticLocation(x) => {
                aper::encode::encode_choice_idx(data, 0, 2, false, 0, false)?;
                x.encode(data)
            }
            Self::RelativeCartesianLocation(x) => {
                aper::encode::encode_choice_idx(data, 0, 2, false, 1, false)?;
                x.encode(data)
            }
        }
    }
}

impl AperCodec for DlPrsResourceSetArpLocation {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        DlPrsResourceSetArpLocation::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("DlPrsResourceSetArpLocation"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("DlPrsResourceSetArpLocation"))
    }
}
// DlprsResourceArp
#[derive(Clone, Debug)]
pub struct DlprsResourceArp {
    pub dl_prs_resource_id: PrsResourceId,
    pub dl_prs_resource_arp_location: DlPrsResourceArpLocation,
}

impl DlprsResourceArp {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (_optionals, _extensions_present) =
            aper::decode::decode_sequence_header(data, false, 1)?;
        let dl_prs_resource_id = PrsResourceId::decode(data)?;
        let dl_prs_resource_arp_location = DlPrsResourceArpLocation::decode(data)?;

        Ok(Self {
            dl_prs_resource_id,
            dl_prs_resource_arp_location,
        })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(false);

        aper::encode::encode_sequence_header(data, false, &optionals, false)?;
        self.dl_prs_resource_id.encode(data)?;
        self.dl_prs_resource_arp_location.encode(data)?;

        Ok(())
    }
}

impl AperCodec for DlprsResourceArp {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        DlprsResourceArp::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("DlprsResourceArp"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("DlprsResourceArp"))
    }
}
// DlPrsResourceArpLocation
#[derive(Clone, Debug)]
pub enum DlPrsResourceArpLocation {
    RelativeGeodeticLocation(RelativeGeodeticLocation),
    RelativeCartesianLocation(RelativeCartesianLocation),
}

impl DlPrsResourceArpLocation {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (idx, extended) = aper::decode::decode_choice_idx(data, 0, 2, false)?;
        if extended {
            return Err(aper::AperCodecError::new(
                "CHOICE additions not implemented",
            ));
        }
        match idx {
            0 => Ok(Self::RelativeGeodeticLocation(
                RelativeGeodeticLocation::decode(data)?,
            )),
            1 => Ok(Self::RelativeCartesianLocation(
                RelativeCartesianLocation::decode(data)?,
            )),
            2 => Err(AperCodecError::new(
                "Choice extension container not implemented",
            )),
            _ => Err(AperCodecError::new("Unknown choice idx")),
        }
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        match self {
            Self::RelativeGeodeticLocation(x) => {
                aper::encode::encode_choice_idx(data, 0, 2, false, 0, false)?;
                x.encode(data)
            }
            Self::RelativeCartesianLocation(x) => {
                aper::encode::encode_choice_idx(data, 0, 2, false, 1, false)?;
                x.encode(data)
            }
        }
    }
}

impl AperCodec for DlPrsResourceArpLocation {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        DlPrsResourceArpLocation::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("DlPrsResourceArpLocation"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("DlPrsResourceArpLocation"))
    }
}
// DlUpTnlAddressToUpdateListItem
#[derive(Clone, Debug)]
pub struct DlUpTnlAddressToUpdateListItem {
    pub old_ip_adress: TransportLayerAddress,
    pub new_ip_adress: TransportLayerAddress,
}

impl DlUpTnlAddressToUpdateListItem {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (_optionals, _extensions_present) =
            aper::decode::decode_sequence_header(data, true, 1)?;
        let old_ip_adress = TransportLayerAddress::decode(data)?;
        let new_ip_adress = TransportLayerAddress::decode(data)?;

        Ok(Self {
            old_ip_adress,
            new_ip_adress,
        })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(false);

        aper::encode::encode_sequence_header(data, true, &optionals, false)?;
        self.old_ip_adress.encode(data)?;
        self.new_ip_adress.encode(data)?;

        Ok(())
    }
}

impl AperCodec for DlUpTnlAddressToUpdateListItem {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        DlUpTnlAddressToUpdateListItem::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("DlUpTnlAddressToUpdateListItem"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("DlUpTnlAddressToUpdateListItem"))
    }
}
// DluptnlInformationToBeSetupList
#[derive(Clone, Debug)]
pub struct DluptnlInformationToBeSetupList(pub Vec<DluptnlInformationToBeSetupItem>);

impl DluptnlInformationToBeSetupList {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        Ok(Self({
            let length = aper::decode::decode_length_determinent(data, Some(1), Some(2), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(DluptnlInformationToBeSetupItem::decode(data)?);
            }
            items
        }))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_length_determinent(data, Some(1), Some(2), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl AperCodec for DluptnlInformationToBeSetupList {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        DluptnlInformationToBeSetupList::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("DluptnlInformationToBeSetupList"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("DluptnlInformationToBeSetupList"))
    }
}
// DluptnlInformationToBeSetupItem
#[derive(Clone, Debug)]
pub struct DluptnlInformationToBeSetupItem {
    pub dluptnl_information: UpTransportLayerInformation,
}

impl DluptnlInformationToBeSetupItem {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (_optionals, _extensions_present) =
            aper::decode::decode_sequence_header(data, true, 1)?;
        let dluptnl_information = UpTransportLayerInformation::decode(data)?;

        Ok(Self {
            dluptnl_information,
        })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(false);

        aper::encode::encode_sequence_header(data, true, &optionals, false)?;
        self.dluptnl_information.encode(data)?;

        Ok(())
    }
}

impl AperCodec for DluptnlInformationToBeSetupItem {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        DluptnlInformationToBeSetupItem::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("DluptnlInformationToBeSetupItem"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("DluptnlInformationToBeSetupItem"))
    }
}
// DrbActivityItem
#[derive(Clone, Debug)]
pub struct DrbActivityItem {
    pub drbid: Drbid,
    pub drb_activity: Option<DrbActivity>,
}

impl DrbActivityItem {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (optionals, _extensions_present) = aper::decode::decode_sequence_header(data, true, 2)?;
        let drbid = Drbid::decode(data)?;
        let drb_activity = if optionals[0] {
            Some(DrbActivity::decode(data)?)
        } else {
            None
        };

        Ok(Self {
            drbid,
            drb_activity,
        })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(self.drb_activity.is_some());
        optionals.push(false);

        aper::encode::encode_sequence_header(data, true, &optionals, false)?;
        self.drbid.encode(data)?;
        if let Some(x) = &self.drb_activity {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl AperCodec for DrbActivityItem {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        DrbActivityItem::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("DrbActivityItem"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("DrbActivityItem"))
    }
}
// DrbActivity
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum DrbActivity {
    Active,
    NotActive,
}

impl DrbActivity {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (idx, extended) = aper::decode::decode_enumerated(data, Some(0), Some(1), false)?;
        if extended {
            return Err(aper::AperCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| AperCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_enumerated(data, Some(0), Some(1), false, *self as i128, false)
    }
}

impl AperCodec for DrbActivity {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        DrbActivity::decode_inner(data).map_err(|e: AperCodecError| e.push_context("DrbActivity"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("DrbActivity"))
    }
}
// Drbid
#[derive(Clone, Debug)]
pub struct Drbid(pub u8);

impl Drbid {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        Ok(Self(
            aper::decode::decode_integer(data, Some(1), Some(32), true)?.0 as u8,
        ))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_integer(data, Some(1), Some(32), true, self.0 as i128, false)
    }
}

impl AperCodec for Drbid {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        Drbid::decode_inner(data).map_err(|e: AperCodecError| e.push_context("Drbid"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("Drbid"))
    }
}
// DrBsFailedToBeModifiedItem
#[derive(Clone, Debug)]
pub struct DrBsFailedToBeModifiedItem {
    pub drbid: Drbid,
    pub cause: Option<Cause>,
}

impl DrBsFailedToBeModifiedItem {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (optionals, _extensions_present) = aper::decode::decode_sequence_header(data, true, 2)?;
        let drbid = Drbid::decode(data)?;
        let cause = if optionals[0] {
            Some(Cause::decode(data)?)
        } else {
            None
        };

        Ok(Self { drbid, cause })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(self.cause.is_some());
        optionals.push(false);

        aper::encode::encode_sequence_header(data, true, &optionals, false)?;
        self.drbid.encode(data)?;
        if let Some(x) = &self.cause {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl AperCodec for DrBsFailedToBeModifiedItem {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        DrBsFailedToBeModifiedItem::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("DrBsFailedToBeModifiedItem"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("DrBsFailedToBeModifiedItem"))
    }
}
// DrBsFailedToBeSetupItem
#[derive(Clone, Debug)]
pub struct DrBsFailedToBeSetupItem {
    pub drbid: Drbid,
    pub cause: Option<Cause>,
}

impl DrBsFailedToBeSetupItem {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (optionals, _extensions_present) = aper::decode::decode_sequence_header(data, true, 2)?;
        let drbid = Drbid::decode(data)?;
        let cause = if optionals[0] {
            Some(Cause::decode(data)?)
        } else {
            None
        };

        Ok(Self { drbid, cause })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(self.cause.is_some());
        optionals.push(false);

        aper::encode::encode_sequence_header(data, true, &optionals, false)?;
        self.drbid.encode(data)?;
        if let Some(x) = &self.cause {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl AperCodec for DrBsFailedToBeSetupItem {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        DrBsFailedToBeSetupItem::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("DrBsFailedToBeSetupItem"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("DrBsFailedToBeSetupItem"))
    }
}
// DrBsFailedToBeSetupModItem
#[derive(Clone, Debug)]
pub struct DrBsFailedToBeSetupModItem {
    pub drbid: Drbid,
    pub cause: Option<Cause>,
}

impl DrBsFailedToBeSetupModItem {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (optionals, _extensions_present) = aper::decode::decode_sequence_header(data, true, 2)?;
        let drbid = Drbid::decode(data)?;
        let cause = if optionals[0] {
            Some(Cause::decode(data)?)
        } else {
            None
        };

        Ok(Self { drbid, cause })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(self.cause.is_some());
        optionals.push(false);

        aper::encode::encode_sequence_header(data, true, &optionals, false)?;
        self.drbid.encode(data)?;
        if let Some(x) = &self.cause {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl AperCodec for DrBsFailedToBeSetupModItem {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        DrBsFailedToBeSetupModItem::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("DrBsFailedToBeSetupModItem"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("DrBsFailedToBeSetupModItem"))
    }
}
// DrbInformation
#[derive(Clone, Debug)]
pub struct DrbInformation {
    pub drb_qos: QosFlowLevelQosParameters,
    pub snssai: Snssai,
    pub notification_control: Option<NotificationControl>,
    pub flows_mapped_to_drb_list: FlowsMappedToDrbList,
}

impl DrbInformation {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (optionals, _extensions_present) =
            aper::decode::decode_sequence_header(data, false, 2)?;
        let drb_qos = QosFlowLevelQosParameters::decode(data)?;
        let snssai = Snssai::decode(data)?;
        let notification_control = if optionals[0] {
            Some(NotificationControl::decode(data)?)
        } else {
            None
        };
        let flows_mapped_to_drb_list = FlowsMappedToDrbList::decode(data)?;

        Ok(Self {
            drb_qos,
            snssai,
            notification_control,
            flows_mapped_to_drb_list,
        })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(self.notification_control.is_some());
        optionals.push(false);

        aper::encode::encode_sequence_header(data, false, &optionals, false)?;
        self.drb_qos.encode(data)?;
        self.snssai.encode(data)?;
        if let Some(x) = &self.notification_control {
            x.encode(data)?;
        }
        self.flows_mapped_to_drb_list.encode(data)?;

        Ok(())
    }
}

impl AperCodec for DrbInformation {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        DrbInformation::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("DrbInformation"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("DrbInformation"))
    }
}
// DrBsModifiedItem
#[derive(Clone, Debug)]
pub struct DrBsModifiedItem {
    pub drbid: Drbid,
    pub lcid: Option<Lcid>,
    pub dluptnl_information_to_be_setup_list: DluptnlInformationToBeSetupList,
}

impl DrBsModifiedItem {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (optionals, _extensions_present) = aper::decode::decode_sequence_header(data, true, 2)?;
        let drbid = Drbid::decode(data)?;
        let lcid = if optionals[0] {
            Some(Lcid::decode(data)?)
        } else {
            None
        };
        let dluptnl_information_to_be_setup_list = DluptnlInformationToBeSetupList::decode(data)?;

        Ok(Self {
            drbid,
            lcid,
            dluptnl_information_to_be_setup_list,
        })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(self.lcid.is_some());
        optionals.push(false);

        aper::encode::encode_sequence_header(data, true, &optionals, false)?;
        self.drbid.encode(data)?;
        if let Some(x) = &self.lcid {
            x.encode(data)?;
        }
        self.dluptnl_information_to_be_setup_list.encode(data)?;

        Ok(())
    }
}

impl AperCodec for DrBsModifiedItem {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        DrBsModifiedItem::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("DrBsModifiedItem"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("DrBsModifiedItem"))
    }
}
// DrBsModifiedConfItem
#[derive(Clone, Debug)]
pub struct DrBsModifiedConfItem {
    pub drbid: Drbid,
    pub uluptnl_information_to_be_setup_list: UluptnlInformationToBeSetupList,
}

impl DrBsModifiedConfItem {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (_optionals, _extensions_present) =
            aper::decode::decode_sequence_header(data, true, 1)?;
        let drbid = Drbid::decode(data)?;
        let uluptnl_information_to_be_setup_list = UluptnlInformationToBeSetupList::decode(data)?;

        Ok(Self {
            drbid,
            uluptnl_information_to_be_setup_list,
        })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(false);

        aper::encode::encode_sequence_header(data, true, &optionals, false)?;
        self.drbid.encode(data)?;
        self.uluptnl_information_to_be_setup_list.encode(data)?;

        Ok(())
    }
}

impl AperCodec for DrBsModifiedConfItem {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        DrBsModifiedConfItem::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("DrBsModifiedConfItem"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("DrBsModifiedConfItem"))
    }
}
// DrbNotifyItem
#[derive(Clone, Debug)]
pub struct DrbNotifyItem {
    pub drbid: Drbid,
    pub notification_cause: NotificationCause,
}

impl DrbNotifyItem {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (_optionals, _extensions_present) =
            aper::decode::decode_sequence_header(data, true, 1)?;
        let drbid = Drbid::decode(data)?;
        let notification_cause = NotificationCause::decode(data)?;

        Ok(Self {
            drbid,
            notification_cause,
        })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(false);

        aper::encode::encode_sequence_header(data, true, &optionals, false)?;
        self.drbid.encode(data)?;
        self.notification_cause.encode(data)?;

        Ok(())
    }
}

impl AperCodec for DrbNotifyItem {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        DrbNotifyItem::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("DrbNotifyItem"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("DrbNotifyItem"))
    }
}
// DrBsRequiredToBeModifiedItem
#[derive(Clone, Debug)]
pub struct DrBsRequiredToBeModifiedItem {
    pub drbid: Drbid,
    pub dluptnl_information_to_be_setup_list: DluptnlInformationToBeSetupList,
}

impl DrBsRequiredToBeModifiedItem {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (_optionals, _extensions_present) =
            aper::decode::decode_sequence_header(data, true, 1)?;
        let drbid = Drbid::decode(data)?;
        let dluptnl_information_to_be_setup_list = DluptnlInformationToBeSetupList::decode(data)?;

        Ok(Self {
            drbid,
            dluptnl_information_to_be_setup_list,
        })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(false);

        aper::encode::encode_sequence_header(data, true, &optionals, false)?;
        self.drbid.encode(data)?;
        self.dluptnl_information_to_be_setup_list.encode(data)?;

        Ok(())
    }
}

impl AperCodec for DrBsRequiredToBeModifiedItem {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        DrBsRequiredToBeModifiedItem::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("DrBsRequiredToBeModifiedItem"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("DrBsRequiredToBeModifiedItem"))
    }
}
// DrBsRequiredToBeReleasedItem
#[derive(Clone, Debug)]
pub struct DrBsRequiredToBeReleasedItem {
    pub drbid: Drbid,
}

impl DrBsRequiredToBeReleasedItem {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (_optionals, _extensions_present) =
            aper::decode::decode_sequence_header(data, true, 1)?;
        let drbid = Drbid::decode(data)?;

        Ok(Self { drbid })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(false);

        aper::encode::encode_sequence_header(data, true, &optionals, false)?;
        self.drbid.encode(data)?;

        Ok(())
    }
}

impl AperCodec for DrBsRequiredToBeReleasedItem {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        DrBsRequiredToBeReleasedItem::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("DrBsRequiredToBeReleasedItem"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("DrBsRequiredToBeReleasedItem"))
    }
}
// DrBsSetupItem
#[derive(Clone, Debug)]
pub struct DrBsSetupItem {
    pub drbid: Drbid,
    pub lcid: Option<Lcid>,
    pub dluptnl_information_to_be_setup_list: DluptnlInformationToBeSetupList,
}

impl DrBsSetupItem {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (optionals, _extensions_present) = aper::decode::decode_sequence_header(data, true, 2)?;
        let drbid = Drbid::decode(data)?;
        let lcid = if optionals[0] {
            Some(Lcid::decode(data)?)
        } else {
            None
        };
        let dluptnl_information_to_be_setup_list = DluptnlInformationToBeSetupList::decode(data)?;

        Ok(Self {
            drbid,
            lcid,
            dluptnl_information_to_be_setup_list,
        })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(self.lcid.is_some());
        optionals.push(false);

        aper::encode::encode_sequence_header(data, true, &optionals, false)?;
        self.drbid.encode(data)?;
        if let Some(x) = &self.lcid {
            x.encode(data)?;
        }
        self.dluptnl_information_to_be_setup_list.encode(data)?;

        Ok(())
    }
}

impl AperCodec for DrBsSetupItem {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        DrBsSetupItem::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("DrBsSetupItem"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("DrBsSetupItem"))
    }
}
// DrBsSetupModItem
#[derive(Clone, Debug)]
pub struct DrBsSetupModItem {
    pub drbid: Drbid,
    pub lcid: Option<Lcid>,
    pub dluptnl_information_to_be_setup_list: DluptnlInformationToBeSetupList,
}

impl DrBsSetupModItem {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (optionals, _extensions_present) = aper::decode::decode_sequence_header(data, true, 2)?;
        let drbid = Drbid::decode(data)?;
        let lcid = if optionals[0] {
            Some(Lcid::decode(data)?)
        } else {
            None
        };
        let dluptnl_information_to_be_setup_list = DluptnlInformationToBeSetupList::decode(data)?;

        Ok(Self {
            drbid,
            lcid,
            dluptnl_information_to_be_setup_list,
        })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(self.lcid.is_some());
        optionals.push(false);

        aper::encode::encode_sequence_header(data, true, &optionals, false)?;
        self.drbid.encode(data)?;
        if let Some(x) = &self.lcid {
            x.encode(data)?;
        }
        self.dluptnl_information_to_be_setup_list.encode(data)?;

        Ok(())
    }
}

impl AperCodec for DrBsSetupModItem {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        DrBsSetupModItem::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("DrBsSetupModItem"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("DrBsSetupModItem"))
    }
}
// DrBsToBeModifiedItem
#[derive(Clone, Debug)]
pub struct DrBsToBeModifiedItem {
    pub drbid: Drbid,
    pub qos_information: Option<QosInformation>,
    pub uluptnl_information_to_be_setup_list: UluptnlInformationToBeSetupList,
    pub ul_configuration: Option<UlConfiguration>,
}

impl DrBsToBeModifiedItem {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (optionals, _extensions_present) = aper::decode::decode_sequence_header(data, true, 3)?;
        let drbid = Drbid::decode(data)?;
        let qos_information = if optionals[0] {
            Some(QosInformation::decode(data)?)
        } else {
            None
        };
        let uluptnl_information_to_be_setup_list = UluptnlInformationToBeSetupList::decode(data)?;
        let ul_configuration = if optionals[1] {
            Some(UlConfiguration::decode(data)?)
        } else {
            None
        };

        Ok(Self {
            drbid,
            qos_information,
            uluptnl_information_to_be_setup_list,
            ul_configuration,
        })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(self.qos_information.is_some());
        optionals.push(self.ul_configuration.is_some());
        optionals.push(false);

        aper::encode::encode_sequence_header(data, true, &optionals, false)?;
        self.drbid.encode(data)?;
        if let Some(x) = &self.qos_information {
            x.encode(data)?;
        }
        self.uluptnl_information_to_be_setup_list.encode(data)?;
        if let Some(x) = &self.ul_configuration {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl AperCodec for DrBsToBeModifiedItem {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        DrBsToBeModifiedItem::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("DrBsToBeModifiedItem"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("DrBsToBeModifiedItem"))
    }
}
// DrBsToBeReleasedItem
#[derive(Clone, Debug)]
pub struct DrBsToBeReleasedItem {
    pub drbid: Drbid,
}

impl DrBsToBeReleasedItem {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (_optionals, _extensions_present) =
            aper::decode::decode_sequence_header(data, true, 1)?;
        let drbid = Drbid::decode(data)?;

        Ok(Self { drbid })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(false);

        aper::encode::encode_sequence_header(data, true, &optionals, false)?;
        self.drbid.encode(data)?;

        Ok(())
    }
}

impl AperCodec for DrBsToBeReleasedItem {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        DrBsToBeReleasedItem::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("DrBsToBeReleasedItem"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("DrBsToBeReleasedItem"))
    }
}
// DrBsToBeSetupItem
#[derive(Clone, Debug)]
pub struct DrBsToBeSetupItem {
    pub drbid: Drbid,
    pub qos_information: QosInformation,
    pub uluptnl_information_to_be_setup_list: UluptnlInformationToBeSetupList,
    pub rlc_mode: RlcMode,
    pub ul_configuration: Option<UlConfiguration>,
    pub duplication_activation: Option<DuplicationActivation>,
}

impl DrBsToBeSetupItem {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (optionals, _extensions_present) = aper::decode::decode_sequence_header(data, true, 3)?;
        let drbid = Drbid::decode(data)?;
        let qos_information = QosInformation::decode(data)?;
        let uluptnl_information_to_be_setup_list = UluptnlInformationToBeSetupList::decode(data)?;
        let rlc_mode = RlcMode::decode(data)?;
        let ul_configuration = if optionals[0] {
            Some(UlConfiguration::decode(data)?)
        } else {
            None
        };
        let duplication_activation = if optionals[1] {
            Some(DuplicationActivation::decode(data)?)
        } else {
            None
        };

        Ok(Self {
            drbid,
            qos_information,
            uluptnl_information_to_be_setup_list,
            rlc_mode,
            ul_configuration,
            duplication_activation,
        })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(self.ul_configuration.is_some());
        optionals.push(self.duplication_activation.is_some());
        optionals.push(false);

        aper::encode::encode_sequence_header(data, true, &optionals, false)?;
        self.drbid.encode(data)?;
        self.qos_information.encode(data)?;
        self.uluptnl_information_to_be_setup_list.encode(data)?;
        self.rlc_mode.encode(data)?;
        if let Some(x) = &self.ul_configuration {
            x.encode(data)?;
        }
        if let Some(x) = &self.duplication_activation {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl AperCodec for DrBsToBeSetupItem {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        DrBsToBeSetupItem::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("DrBsToBeSetupItem"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("DrBsToBeSetupItem"))
    }
}
// DrBsToBeSetupModItem
#[derive(Clone, Debug)]
pub struct DrBsToBeSetupModItem {
    pub drbid: Drbid,
    pub qos_information: QosInformation,
    pub uluptnl_information_to_be_setup_list: UluptnlInformationToBeSetupList,
    pub rlc_mode: RlcMode,
    pub ul_configuration: Option<UlConfiguration>,
    pub duplication_activation: Option<DuplicationActivation>,
}

impl DrBsToBeSetupModItem {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (optionals, _extensions_present) = aper::decode::decode_sequence_header(data, true, 3)?;
        let drbid = Drbid::decode(data)?;
        let qos_information = QosInformation::decode(data)?;
        let uluptnl_information_to_be_setup_list = UluptnlInformationToBeSetupList::decode(data)?;
        let rlc_mode = RlcMode::decode(data)?;
        let ul_configuration = if optionals[0] {
            Some(UlConfiguration::decode(data)?)
        } else {
            None
        };
        let duplication_activation = if optionals[1] {
            Some(DuplicationActivation::decode(data)?)
        } else {
            None
        };

        Ok(Self {
            drbid,
            qos_information,
            uluptnl_information_to_be_setup_list,
            rlc_mode,
            ul_configuration,
            duplication_activation,
        })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(self.ul_configuration.is_some());
        optionals.push(self.duplication_activation.is_some());
        optionals.push(false);

        aper::encode::encode_sequence_header(data, true, &optionals, false)?;
        self.drbid.encode(data)?;
        self.qos_information.encode(data)?;
        self.uluptnl_information_to_be_setup_list.encode(data)?;
        self.rlc_mode.encode(data)?;
        if let Some(x) = &self.ul_configuration {
            x.encode(data)?;
        }
        if let Some(x) = &self.duplication_activation {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl AperCodec for DrBsToBeSetupModItem {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        DrBsToBeSetupModItem::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("DrBsToBeSetupModItem"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("DrBsToBeSetupModItem"))
    }
}
// DrxCycle
#[derive(Clone, Debug)]
pub struct DrxCycle {
    pub long_drx_cycle_length: LongDrxCycleLength,
    pub short_drx_cycle_length: Option<ShortDrxCycleLength>,
    pub short_drx_cycle_timer: Option<ShortDrxCycleTimer>,
}

impl DrxCycle {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (optionals, _extensions_present) = aper::decode::decode_sequence_header(data, true, 3)?;
        let long_drx_cycle_length = LongDrxCycleLength::decode(data)?;
        let short_drx_cycle_length = if optionals[0] {
            Some(ShortDrxCycleLength::decode(data)?)
        } else {
            None
        };
        let short_drx_cycle_timer = if optionals[1] {
            Some(ShortDrxCycleTimer::decode(data)?)
        } else {
            None
        };

        Ok(Self {
            long_drx_cycle_length,
            short_drx_cycle_length,
            short_drx_cycle_timer,
        })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(self.short_drx_cycle_length.is_some());
        optionals.push(self.short_drx_cycle_timer.is_some());
        optionals.push(false);

        aper::encode::encode_sequence_header(data, true, &optionals, false)?;
        self.long_drx_cycle_length.encode(data)?;
        if let Some(x) = &self.short_drx_cycle_length {
            x.encode(data)?;
        }
        if let Some(x) = &self.short_drx_cycle_timer {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl AperCodec for DrxCycle {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        DrxCycle::decode_inner(data).map_err(|e: AperCodecError| e.push_context("DrxCycle"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("DrxCycle"))
    }
}
// DrxConfig
#[derive(Clone, Debug)]
pub struct DrxConfig(pub Vec<u8>);

impl DrxConfig {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        Ok(Self(aper::decode::decode_octetstring(
            data, None, None, false,
        )?))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_octetstring(data, None, None, false, &self.0, false)
    }
}

impl AperCodec for DrxConfig {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        DrxConfig::decode_inner(data).map_err(|e: AperCodecError| e.push_context("DrxConfig"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("DrxConfig"))
    }
}
// DrxConfigurationIndicator
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum DrxConfigurationIndicator {
    Release,
}

impl DrxConfigurationIndicator {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (idx, extended) = aper::decode::decode_enumerated(data, Some(0), Some(0), true)?;
        if extended {
            return Err(aper::AperCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| AperCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_enumerated(data, Some(0), Some(0), true, *self as i128, false)
    }
}

impl AperCodec for DrxConfigurationIndicator {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        DrxConfigurationIndicator::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("DrxConfigurationIndicator"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("DrxConfigurationIndicator"))
    }
}
// DrxLongCycleStartOffset
#[derive(Clone, Debug)]
pub struct DrxLongCycleStartOffset(pub u16);

impl DrxLongCycleStartOffset {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        Ok(Self(
            aper::decode::decode_integer(data, Some(0), Some(10239), false)?.0 as u16,
        ))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_integer(data, Some(0), Some(10239), false, self.0 as i128, false)
    }
}

impl AperCodec for DrxLongCycleStartOffset {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        DrxLongCycleStartOffset::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("DrxLongCycleStartOffset"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("DrxLongCycleStartOffset"))
    }
}
// DsInformationList
#[derive(Clone, Debug)]
pub struct DsInformationList(pub Vec<Dscp>);

impl DsInformationList {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        Ok(Self({
            let length = aper::decode::decode_length_determinent(data, Some(0), Some(64), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(Dscp::decode(data)?);
            }
            items
        }))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_length_determinent(data, Some(0), Some(64), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl AperCodec for DsInformationList {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        DsInformationList::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("DsInformationList"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("DsInformationList"))
    }
}
// Dscp
#[derive(Clone, Debug)]
pub struct Dscp(pub BitString);

impl Dscp {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        Ok(Self(aper::decode::decode_bitstring(
            data,
            Some(6),
            Some(6),
            false,
        )?))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_bitstring(data, Some(6), Some(6), false, &self.0, false)
    }
}

impl AperCodec for Dscp {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        Dscp::decode_inner(data).map_err(|e: AperCodecError| e.push_context("Dscp"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("Dscp"))
    }
}
// DUtoCurrcContainer
#[derive(Clone, Debug)]
pub struct DUtoCurrcContainer(pub Vec<u8>);

impl DUtoCurrcContainer {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        Ok(Self(aper::decode::decode_octetstring(
            data, None, None, false,
        )?))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_octetstring(data, None, None, false, &self.0, false)
    }
}

impl AperCodec for DUtoCurrcContainer {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        DUtoCurrcContainer::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("DUtoCurrcContainer"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("DUtoCurrcContainer"))
    }
}
// DucuRadioInformationType
#[derive(Clone, Debug)]
pub enum DucuRadioInformationType {
    Rim(DucurimInformation),
}

impl DucuRadioInformationType {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (idx, extended) = aper::decode::decode_choice_idx(data, 0, 1, false)?;
        if extended {
            return Err(aper::AperCodecError::new(
                "CHOICE additions not implemented",
            ));
        }
        match idx {
            0 => Ok(Self::Rim(DucurimInformation::decode(data)?)),
            1 => Err(AperCodecError::new(
                "Choice extension container not implemented",
            )),
            _ => Err(AperCodecError::new("Unknown choice idx")),
        }
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        match self {
            Self::Rim(x) => {
                aper::encode::encode_choice_idx(data, 0, 1, false, 0, false)?;
                x.encode(data)
            }
        }
    }
}

impl AperCodec for DucuRadioInformationType {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        DucuRadioInformationType::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("DucuRadioInformationType"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("DucuRadioInformationType"))
    }
}
// DucurimInformation
#[derive(Clone, Debug)]
pub struct DucurimInformation {
    pub victim_gnb_set_id: GnbSetId,
    pub rimrs_detection_status: RimrsDetectionStatus,
    pub aggressor_cell_list: AggressorCellList,
}

impl DucurimInformation {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (_optionals, _extensions_present) =
            aper::decode::decode_sequence_header(data, false, 1)?;
        let victim_gnb_set_id = GnbSetId::decode(data)?;
        let rimrs_detection_status = RimrsDetectionStatus::decode(data)?;
        let aggressor_cell_list = AggressorCellList::decode(data)?;

        Ok(Self {
            victim_gnb_set_id,
            rimrs_detection_status,
            aggressor_cell_list,
        })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(false);

        aper::encode::encode_sequence_header(data, false, &optionals, false)?;
        self.victim_gnb_set_id.encode(data)?;
        self.rimrs_detection_status.encode(data)?;
        self.aggressor_cell_list.encode(data)?;

        Ok(())
    }
}

impl AperCodec for DucurimInformation {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        DucurimInformation::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("DucurimInformation"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("DucurimInformation"))
    }
}
// DufSlotConfigItem
#[derive(Clone, Debug)]
pub enum DufSlotConfigItem {
    ExplicitFormat(ExplicitFormat),
    ImplicitFormat(ImplicitFormat),
}

impl DufSlotConfigItem {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (idx, extended) = aper::decode::decode_choice_idx(data, 0, 2, false)?;
        if extended {
            return Err(aper::AperCodecError::new(
                "CHOICE additions not implemented",
            ));
        }
        match idx {
            0 => Ok(Self::ExplicitFormat(ExplicitFormat::decode(data)?)),
            1 => Ok(Self::ImplicitFormat(ImplicitFormat::decode(data)?)),
            2 => Err(AperCodecError::new(
                "Choice extension container not implemented",
            )),
            _ => Err(AperCodecError::new("Unknown choice idx")),
        }
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        match self {
            Self::ExplicitFormat(x) => {
                aper::encode::encode_choice_idx(data, 0, 2, false, 0, false)?;
                x.encode(data)
            }
            Self::ImplicitFormat(x) => {
                aper::encode::encode_choice_idx(data, 0, 2, false, 1, false)?;
                x.encode(data)
            }
        }
    }
}

impl AperCodec for DufSlotConfigItem {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        DufSlotConfigItem::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("DufSlotConfigItem"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("DufSlotConfigItem"))
    }
}
// DufSlotConfigList
#[derive(Clone, Debug)]
pub struct DufSlotConfigList(pub Vec<DufSlotConfigItem>);

impl DufSlotConfigList {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        Ok(Self({
            let length = aper::decode::decode_length_determinent(data, Some(1), Some(320), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(DufSlotConfigItem::decode(data)?);
            }
            items
        }))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_length_determinent(data, Some(1), Some(320), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl AperCodec for DufSlotConfigList {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        DufSlotConfigList::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("DufSlotConfigList"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("DufSlotConfigList"))
    }
}
// DufSlotformatIndex
#[derive(Clone, Debug)]
pub struct DufSlotformatIndex(pub u8);

impl DufSlotformatIndex {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        Ok(Self(
            aper::decode::decode_integer(data, Some(0), Some(254), false)?.0 as u8,
        ))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_integer(data, Some(0), Some(254), false, self.0 as i128, false)
    }
}

impl AperCodec for DufSlotformatIndex {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        DufSlotformatIndex::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("DufSlotformatIndex"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("DufSlotformatIndex"))
    }
}
// DufTransmissionPeriodicity
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum DufTransmissionPeriodicity {
    Ms0p5,
    Ms0p625,
    Ms1,
    Ms1p25,
    Ms2,
    Ms2p5,
    Ms5,
    Ms10,
}

impl DufTransmissionPeriodicity {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (idx, extended) = aper::decode::decode_enumerated(data, Some(0), Some(7), true)?;
        if extended {
            return Err(aper::AperCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| AperCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_enumerated(data, Some(0), Some(7), true, *self as i128, false)
    }
}

impl AperCodec for DufTransmissionPeriodicity {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        DufTransmissionPeriodicity::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("DufTransmissionPeriodicity"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("DufTransmissionPeriodicity"))
    }
}
// DuRxMtRx
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum DuRxMtRx {
    Supported,
    NotSupported,
}

impl DuRxMtRx {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (idx, extended) = aper::decode::decode_enumerated(data, Some(0), Some(1), false)?;
        if extended {
            return Err(aper::AperCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| AperCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_enumerated(data, Some(0), Some(1), false, *self as i128, false)
    }
}

impl AperCodec for DuRxMtRx {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        DuRxMtRx::decode_inner(data).map_err(|e: AperCodecError| e.push_context("DuRxMtRx"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("DuRxMtRx"))
    }
}
// DuTxMtTx
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum DuTxMtTx {
    Supported,
    NotSupported,
}

impl DuTxMtTx {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (idx, extended) = aper::decode::decode_enumerated(data, Some(0), Some(1), false)?;
        if extended {
            return Err(aper::AperCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| AperCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_enumerated(data, Some(0), Some(1), false, *self as i128, false)
    }
}

impl AperCodec for DuTxMtTx {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        DuTxMtTx::decode_inner(data).map_err(|e: AperCodecError| e.push_context("DuTxMtTx"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("DuTxMtTx"))
    }
}
// DuRxMtTx
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum DuRxMtTx {
    Supported,
    NotSupported,
}

impl DuRxMtTx {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (idx, extended) = aper::decode::decode_enumerated(data, Some(0), Some(1), false)?;
        if extended {
            return Err(aper::AperCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| AperCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_enumerated(data, Some(0), Some(1), false, *self as i128, false)
    }
}

impl AperCodec for DuRxMtTx {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        DuRxMtTx::decode_inner(data).map_err(|e: AperCodecError| e.push_context("DuRxMtTx"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("DuRxMtTx"))
    }
}
// DuTxMtRx
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum DuTxMtRx {
    Supported,
    NotSupported,
}

impl DuTxMtRx {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (idx, extended) = aper::decode::decode_enumerated(data, Some(0), Some(1), false)?;
        if extended {
            return Err(aper::AperCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| AperCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_enumerated(data, Some(0), Some(1), false, *self as i128, false)
    }
}

impl AperCodec for DuTxMtRx {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        DuTxMtRx::decode_inner(data).map_err(|e: AperCodecError| e.push_context("DuTxMtRx"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("DuTxMtRx"))
    }
}
// DUtoCurrcInformation
#[derive(Clone, Debug)]
pub struct DUtoCurrcInformation {
    pub cell_group_config: CellGroupConfig,
    pub meas_gap_config: Option<MeasGapConfig>,
    pub requested_p_max_fr1: Option<Vec<u8>>,
}

impl DUtoCurrcInformation {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (optionals, _extensions_present) = aper::decode::decode_sequence_header(data, true, 3)?;
        let cell_group_config = CellGroupConfig::decode(data)?;
        let meas_gap_config = if optionals[0] {
            Some(MeasGapConfig::decode(data)?)
        } else {
            None
        };
        let requested_p_max_fr1 = if optionals[1] {
            Some(aper::decode::decode_octetstring(data, None, None, false)?)
        } else {
            None
        };

        Ok(Self {
            cell_group_config,
            meas_gap_config,
            requested_p_max_fr1,
        })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(self.meas_gap_config.is_some());
        optionals.push(self.requested_p_max_fr1.is_some());
        optionals.push(false);

        aper::encode::encode_sequence_header(data, true, &optionals, false)?;
        self.cell_group_config.encode(data)?;
        if let Some(x) = &self.meas_gap_config {
            x.encode(data)?;
        }
        if let Some(x) = &self.requested_p_max_fr1 {
            aper::encode::encode_octetstring(data, None, None, false, &x, false)?;
        }

        Ok(())
    }
}

impl AperCodec for DUtoCurrcInformation {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        DUtoCurrcInformation::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("DUtoCurrcInformation"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("DUtoCurrcInformation"))
    }
}
// DuplicationActivation
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum DuplicationActivation {
    Active,
    Inactive,
}

impl DuplicationActivation {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (idx, extended) = aper::decode::decode_enumerated(data, Some(0), Some(1), true)?;
        if extended {
            return Err(aper::AperCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| AperCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_enumerated(data, Some(0), Some(1), true, *self as i128, false)
    }
}

impl AperCodec for DuplicationActivation {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        DuplicationActivation::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("DuplicationActivation"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("DuplicationActivation"))
    }
}
// DuplicationIndication
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum DuplicationIndication {
    True,
}

impl DuplicationIndication {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (idx, extended) = aper::decode::decode_enumerated(data, Some(0), Some(0), true)?;
        if extended {
            return Err(aper::AperCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| AperCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_enumerated(data, Some(0), Some(0), true, *self as i128, false)
    }
}

impl AperCodec for DuplicationIndication {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        DuplicationIndication::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("DuplicationIndication"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("DuplicationIndication"))
    }
}
// DuplicationState
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum DuplicationState {
    Active,
    Inactive,
}

impl DuplicationState {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (idx, extended) = aper::decode::decode_enumerated(data, Some(0), Some(1), true)?;
        if extended {
            return Err(aper::AperCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| AperCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_enumerated(data, Some(0), Some(1), true, *self as i128, false)
    }
}

impl AperCodec for DuplicationState {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        DuplicationState::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("DuplicationState"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("DuplicationState"))
    }
}
// Dynamic5qiDescriptor
#[derive(Clone, Debug)]
pub struct Dynamic5qiDescriptor {
    pub qos_priority_level: u8,
    pub packet_delay_budget: PacketDelayBudget,
    pub packet_error_rate: PacketErrorRate,
    pub five_qi: Option<u8>,
    pub delay_critical: Option<DelayCritical>,
    pub averaging_window: Option<AveragingWindow>,
    pub max_data_burst_volume: Option<MaxDataBurstVolume>,
}

impl Dynamic5qiDescriptor {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (optionals, _extensions_present) =
            aper::decode::decode_sequence_header(data, false, 5)?;
        let qos_priority_level =
            aper::decode::decode_integer(data, Some(1), Some(127), false)?.0 as u8;
        let packet_delay_budget = PacketDelayBudget::decode(data)?;
        let packet_error_rate = PacketErrorRate::decode(data)?;
        let five_qi = if optionals[0] {
            Some(aper::decode::decode_integer(data, Some(0), Some(255), true)?.0 as u8)
        } else {
            None
        };
        let delay_critical = if optionals[1] {
            Some(DelayCritical::decode(data)?)
        } else {
            None
        };
        let averaging_window = if optionals[2] {
            Some(AveragingWindow::decode(data)?)
        } else {
            None
        };
        let max_data_burst_volume = if optionals[3] {
            Some(MaxDataBurstVolume::decode(data)?)
        } else {
            None
        };

        Ok(Self {
            qos_priority_level,
            packet_delay_budget,
            packet_error_rate,
            five_qi,
            delay_critical,
            averaging_window,
            max_data_burst_volume,
        })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(self.five_qi.is_some());
        optionals.push(self.delay_critical.is_some());
        optionals.push(self.averaging_window.is_some());
        optionals.push(self.max_data_burst_volume.is_some());
        optionals.push(false);

        aper::encode::encode_sequence_header(data, false, &optionals, false)?;
        aper::encode::encode_integer(
            data,
            Some(1),
            Some(127),
            false,
            self.qos_priority_level as i128,
            false,
        )?;
        self.packet_delay_budget.encode(data)?;
        self.packet_error_rate.encode(data)?;
        if let Some(x) = &self.five_qi {
            aper::encode::encode_integer(data, Some(0), Some(255), true, *x as i128, false)?;
        }
        if let Some(x) = &self.delay_critical {
            x.encode(data)?;
        }
        if let Some(x) = &self.averaging_window {
            x.encode(data)?;
        }
        if let Some(x) = &self.max_data_burst_volume {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl AperCodec for Dynamic5qiDescriptor {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        Dynamic5qiDescriptor::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("Dynamic5qiDescriptor"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("Dynamic5qiDescriptor"))
    }
}
// DynamicPqiDescriptor
#[derive(Clone, Debug)]
pub struct DynamicPqiDescriptor {
    pub resource_type: Option<ResourceType1>,
    pub qos_priority_level: u8,
    pub packet_delay_budget: PacketDelayBudget,
    pub packet_error_rate: PacketErrorRate,
    pub averaging_window: Option<AveragingWindow>,
    pub max_data_burst_volume: Option<MaxDataBurstVolume>,
}

impl DynamicPqiDescriptor {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (optionals, _extensions_present) =
            aper::decode::decode_sequence_header(data, false, 4)?;
        let resource_type = if optionals[0] {
            Some(ResourceType1::decode(data)?)
        } else {
            None
        };
        let qos_priority_level =
            aper::decode::decode_integer(data, Some(1), Some(8), true)?.0 as u8;
        let packet_delay_budget = PacketDelayBudget::decode(data)?;
        let packet_error_rate = PacketErrorRate::decode(data)?;
        let averaging_window = if optionals[1] {
            Some(AveragingWindow::decode(data)?)
        } else {
            None
        };
        let max_data_burst_volume = if optionals[2] {
            Some(MaxDataBurstVolume::decode(data)?)
        } else {
            None
        };

        Ok(Self {
            resource_type,
            qos_priority_level,
            packet_delay_budget,
            packet_error_rate,
            averaging_window,
            max_data_burst_volume,
        })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(self.resource_type.is_some());
        optionals.push(self.averaging_window.is_some());
        optionals.push(self.max_data_burst_volume.is_some());
        optionals.push(false);

        aper::encode::encode_sequence_header(data, false, &optionals, false)?;
        if let Some(x) = &self.resource_type {
            x.encode(data)?;
        }
        aper::encode::encode_integer(
            data,
            Some(1),
            Some(8),
            true,
            self.qos_priority_level as i128,
            false,
        )?;
        self.packet_delay_budget.encode(data)?;
        self.packet_error_rate.encode(data)?;
        if let Some(x) = &self.averaging_window {
            x.encode(data)?;
        }
        if let Some(x) = &self.max_data_burst_volume {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl AperCodec for DynamicPqiDescriptor {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        DynamicPqiDescriptor::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("DynamicPqiDescriptor"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("DynamicPqiDescriptor"))
    }
}
// ECidMeasurementQuantities
#[derive(Clone, Debug)]
pub struct ECidMeasurementQuantities(pub Vec<ECidMeasurementQuantitiesItem>);

impl ECidMeasurementQuantities {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        Ok(Self({
            let length = aper::decode::decode_length_determinent(data, Some(1), Some(64), false)?;
            let mut items = vec![];
            for _ in 0..length {
                let _ = aper::decode::decode_integer(data, Some(0), Some(65535), false)?;
                let _ = Criticality::decode(data)?;
                let _ = aper::decode::decode_length_determinent(data, None, None, false)?;
                items.push(ECidMeasurementQuantitiesItem::decode(data)?);
            }
            items
        }))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_length_determinent(data, Some(1), Some(64), false, self.0.len())?;
        for x in &self.0 {
            let ie = &mut AperCodecData::new();
            x.encode(ie)?;
            aper::encode::encode_integer(data, Some(0), Some(65535), false, 415, false)?;
            Criticality::Reject.encode(data)?;
            aper::encode::encode_length_determinent(data, None, None, false, ie.length_in_bytes())?;
            data.append_aligned(ie);
        }
        Ok(())
    }
}

impl AperCodec for ECidMeasurementQuantities {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        ECidMeasurementQuantities::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("ECidMeasurementQuantities"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("ECidMeasurementQuantities"))
    }
}
// ECidMeasurementQuantitiesItem
#[derive(Clone, Debug)]
pub struct ECidMeasurementQuantitiesItem {
    pub e_ci_dmeasurement_quantities_value: ECidMeasurementQuantitiesValue,
}

impl ECidMeasurementQuantitiesItem {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (_optionals, _extensions_present) =
            aper::decode::decode_sequence_header(data, false, 1)?;
        let e_ci_dmeasurement_quantities_value = ECidMeasurementQuantitiesValue::decode(data)?;

        Ok(Self {
            e_ci_dmeasurement_quantities_value,
        })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(false);

        aper::encode::encode_sequence_header(data, false, &optionals, false)?;
        self.e_ci_dmeasurement_quantities_value.encode(data)?;

        Ok(())
    }
}

impl AperCodec for ECidMeasurementQuantitiesItem {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        ECidMeasurementQuantitiesItem::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("ECidMeasurementQuantitiesItem"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("ECidMeasurementQuantitiesItem"))
    }
}
// ECidMeasurementQuantitiesValue
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum ECidMeasurementQuantitiesValue {
    Default,
    AngleOfArrivalNr,
}

impl ECidMeasurementQuantitiesValue {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (idx, extended) = aper::decode::decode_enumerated(data, Some(0), Some(1), true)?;
        if extended {
            return Err(aper::AperCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| AperCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_enumerated(data, Some(0), Some(1), true, *self as i128, false)
    }
}

impl AperCodec for ECidMeasurementQuantitiesValue {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        ECidMeasurementQuantitiesValue::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("ECidMeasurementQuantitiesValue"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("ECidMeasurementQuantitiesValue"))
    }
}
// ECidMeasurementResult
#[derive(Clone, Debug)]
pub struct ECidMeasurementResult {
    pub geographical_coordinates: Option<GeographicalCoordinates>,
    pub measured_results_list: Option<ECidMeasuredResultsList>,
}

impl ECidMeasurementResult {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (optionals, _extensions_present) =
            aper::decode::decode_sequence_header(data, false, 3)?;
        let geographical_coordinates = if optionals[0] {
            Some(GeographicalCoordinates::decode(data)?)
        } else {
            None
        };
        let measured_results_list = if optionals[1] {
            Some(ECidMeasuredResultsList::decode(data)?)
        } else {
            None
        };

        Ok(Self {
            geographical_coordinates,
            measured_results_list,
        })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(self.geographical_coordinates.is_some());
        optionals.push(self.measured_results_list.is_some());
        optionals.push(false);

        aper::encode::encode_sequence_header(data, false, &optionals, false)?;
        if let Some(x) = &self.geographical_coordinates {
            x.encode(data)?;
        }
        if let Some(x) = &self.measured_results_list {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl AperCodec for ECidMeasurementResult {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        ECidMeasurementResult::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("ECidMeasurementResult"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("ECidMeasurementResult"))
    }
}
// ECidMeasuredResultsList
#[derive(Clone, Debug)]
pub struct ECidMeasuredResultsList(pub Vec<ECidMeasuredResultsItem>);

impl ECidMeasuredResultsList {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        Ok(Self({
            let length = aper::decode::decode_length_determinent(data, Some(1), Some(64), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(ECidMeasuredResultsItem::decode(data)?);
            }
            items
        }))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_length_determinent(data, Some(1), Some(64), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl AperCodec for ECidMeasuredResultsList {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        ECidMeasuredResultsList::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("ECidMeasuredResultsList"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("ECidMeasuredResultsList"))
    }
}
// ECidMeasuredResultsItem
#[derive(Clone, Debug)]
pub struct ECidMeasuredResultsItem {
    pub e_cid_measured_results_value: ECidMeasuredResultsValue,
}

impl ECidMeasuredResultsItem {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (_optionals, _extensions_present) =
            aper::decode::decode_sequence_header(data, false, 1)?;
        let e_cid_measured_results_value = ECidMeasuredResultsValue::decode(data)?;

        Ok(Self {
            e_cid_measured_results_value,
        })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(false);

        aper::encode::encode_sequence_header(data, false, &optionals, false)?;
        self.e_cid_measured_results_value.encode(data)?;

        Ok(())
    }
}

impl AperCodec for ECidMeasuredResultsItem {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        ECidMeasuredResultsItem::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("ECidMeasuredResultsItem"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("ECidMeasuredResultsItem"))
    }
}
// ECidMeasuredResultsValue
#[derive(Clone, Debug)]
pub enum ECidMeasuredResultsValue {
    ValueAngleofArrivalNr(UlAoA),
}

impl ECidMeasuredResultsValue {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (idx, extended) = aper::decode::decode_choice_idx(data, 0, 1, false)?;
        if extended {
            return Err(aper::AperCodecError::new(
                "CHOICE additions not implemented",
            ));
        }
        match idx {
            0 => Ok(Self::ValueAngleofArrivalNr(UlAoA::decode(data)?)),
            1 => Err(AperCodecError::new(
                "Choice extension container not implemented",
            )),
            _ => Err(AperCodecError::new("Unknown choice idx")),
        }
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        match self {
            Self::ValueAngleofArrivalNr(x) => {
                aper::encode::encode_choice_idx(data, 0, 1, false, 0, false)?;
                x.encode(data)
            }
        }
    }
}

impl AperCodec for ECidMeasuredResultsValue {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        ECidMeasuredResultsValue::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("ECidMeasuredResultsValue"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("ECidMeasuredResultsValue"))
    }
}
// ECidReportCharacteristics
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum ECidReportCharacteristics {
    OnDemand,
    Periodic,
}

impl ECidReportCharacteristics {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (idx, extended) = aper::decode::decode_enumerated(data, Some(0), Some(1), true)?;
        if extended {
            return Err(aper::AperCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| AperCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_enumerated(data, Some(0), Some(1), true, *self as i128, false)
    }
}

impl AperCodec for ECidReportCharacteristics {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        ECidReportCharacteristics::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("ECidReportCharacteristics"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("ECidReportCharacteristics"))
    }
}
// EgressBhrlcchList
#[derive(Clone, Debug)]
pub struct EgressBhrlcchList(pub Vec<EgressBhrlcchItem>);

impl EgressBhrlcchList {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        Ok(Self({
            let length = aper::decode::decode_length_determinent(data, Some(1), Some(2), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(EgressBhrlcchItem::decode(data)?);
            }
            items
        }))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_length_determinent(data, Some(1), Some(2), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl AperCodec for EgressBhrlcchList {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        EgressBhrlcchList::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("EgressBhrlcchList"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("EgressBhrlcchList"))
    }
}
// EgressBhrlcchItem
#[derive(Clone, Debug)]
pub struct EgressBhrlcchItem {
    pub next_hop_bap_address: BapAddress,
    pub bhrlc_channel_id: BhrlcChannelId,
}

impl EgressBhrlcchItem {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (_optionals, _extensions_present) =
            aper::decode::decode_sequence_header(data, false, 1)?;
        let next_hop_bap_address = BapAddress::decode(data)?;
        let bhrlc_channel_id = BhrlcChannelId::decode(data)?;

        Ok(Self {
            next_hop_bap_address,
            bhrlc_channel_id,
        })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(false);

        aper::encode::encode_sequence_header(data, false, &optionals, false)?;
        self.next_hop_bap_address.encode(data)?;
        self.bhrlc_channel_id.encode(data)?;

        Ok(())
    }
}

impl AperCodec for EgressBhrlcchItem {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        EgressBhrlcchItem::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("EgressBhrlcchItem"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("EgressBhrlcchItem"))
    }
}
// EndpointIpAddressAndPort
#[derive(Clone, Debug)]
pub struct EndpointIpAddressAndPort {
    pub endpoint_ip_address: TransportLayerAddress,
}

impl EndpointIpAddressAndPort {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (_optionals, _extensions_present) =
            aper::decode::decode_sequence_header(data, false, 1)?;
        let endpoint_ip_address = TransportLayerAddress::decode(data)?;

        Ok(Self {
            endpoint_ip_address,
        })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(false);

        aper::encode::encode_sequence_header(data, false, &optionals, false)?;
        self.endpoint_ip_address.encode(data)?;

        Ok(())
    }
}

impl AperCodec for EndpointIpAddressAndPort {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        EndpointIpAddressAndPort::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("EndpointIpAddressAndPort"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("EndpointIpAddressAndPort"))
    }
}
// ExtendedAvailablePlmnList
#[derive(Clone, Debug)]
pub struct ExtendedAvailablePlmnList(pub Vec<ExtendedAvailablePlmnItem>);

impl ExtendedAvailablePlmnList {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        Ok(Self({
            let length = aper::decode::decode_length_determinent(data, Some(1), Some(6), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(ExtendedAvailablePlmnItem::decode(data)?);
            }
            items
        }))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_length_determinent(data, Some(1), Some(6), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl AperCodec for ExtendedAvailablePlmnList {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        ExtendedAvailablePlmnList::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("ExtendedAvailablePlmnList"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("ExtendedAvailablePlmnList"))
    }
}
// ExtendedAvailablePlmnItem
#[derive(Clone, Debug)]
pub struct ExtendedAvailablePlmnItem {
    pub plmn_identity: PlmnIdentity,
}

impl ExtendedAvailablePlmnItem {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (_optionals, _extensions_present) =
            aper::decode::decode_sequence_header(data, false, 1)?;
        let plmn_identity = PlmnIdentity::decode(data)?;

        Ok(Self { plmn_identity })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(false);

        aper::encode::encode_sequence_header(data, false, &optionals, false)?;
        self.plmn_identity.encode(data)?;

        Ok(())
    }
}

impl AperCodec for ExtendedAvailablePlmnItem {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        ExtendedAvailablePlmnItem::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("ExtendedAvailablePlmnItem"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("ExtendedAvailablePlmnItem"))
    }
}
// ExplicitFormat
#[derive(Clone, Debug)]
pub struct ExplicitFormat {
    pub permutation: Permutation,
    pub noof_downlink_symbols: Option<NoofDownlinkSymbols>,
    pub noof_uplink_symbols: Option<NoofUplinkSymbols>,
}

impl ExplicitFormat {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (optionals, _extensions_present) =
            aper::decode::decode_sequence_header(data, false, 3)?;
        let permutation = Permutation::decode(data)?;
        let noof_downlink_symbols = if optionals[0] {
            Some(NoofDownlinkSymbols::decode(data)?)
        } else {
            None
        };
        let noof_uplink_symbols = if optionals[1] {
            Some(NoofUplinkSymbols::decode(data)?)
        } else {
            None
        };

        Ok(Self {
            permutation,
            noof_downlink_symbols,
            noof_uplink_symbols,
        })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(self.noof_downlink_symbols.is_some());
        optionals.push(self.noof_uplink_symbols.is_some());
        optionals.push(false);

        aper::encode::encode_sequence_header(data, false, &optionals, false)?;
        self.permutation.encode(data)?;
        if let Some(x) = &self.noof_downlink_symbols {
            x.encode(data)?;
        }
        if let Some(x) = &self.noof_uplink_symbols {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl AperCodec for ExplicitFormat {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        ExplicitFormat::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("ExplicitFormat"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("ExplicitFormat"))
    }
}
// ExtendedServedPlmnSList
#[derive(Clone, Debug)]
pub struct ExtendedServedPlmnSList(pub Vec<ExtendedServedPlmnSItem>);

impl ExtendedServedPlmnSList {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        Ok(Self({
            let length = aper::decode::decode_length_determinent(data, Some(1), Some(6), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(ExtendedServedPlmnSItem::decode(data)?);
            }
            items
        }))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_length_determinent(data, Some(1), Some(6), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl AperCodec for ExtendedServedPlmnSList {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        ExtendedServedPlmnSList::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("ExtendedServedPlmnSList"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("ExtendedServedPlmnSList"))
    }
}
// ExtendedServedPlmnSItem
#[derive(Clone, Debug)]
pub struct ExtendedServedPlmnSItem {
    pub plmn_identity: PlmnIdentity,
    pub tai_slice_support_list: Option<SliceSupportList>,
}

impl ExtendedServedPlmnSItem {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (optionals, _extensions_present) = aper::decode::decode_sequence_header(data, true, 2)?;
        let plmn_identity = PlmnIdentity::decode(data)?;
        let tai_slice_support_list = if optionals[0] {
            Some(SliceSupportList::decode(data)?)
        } else {
            None
        };

        Ok(Self {
            plmn_identity,
            tai_slice_support_list,
        })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(self.tai_slice_support_list.is_some());
        optionals.push(false);

        aper::encode::encode_sequence_header(data, true, &optionals, false)?;
        self.plmn_identity.encode(data)?;
        if let Some(x) = &self.tai_slice_support_list {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl AperCodec for ExtendedServedPlmnSItem {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        ExtendedServedPlmnSItem::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("ExtendedServedPlmnSItem"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("ExtendedServedPlmnSItem"))
    }
}
// ExtendedSliceSupportList
#[derive(Clone, Debug)]
pub struct ExtendedSliceSupportList(pub Vec<SliceSupportItem>);

impl ExtendedSliceSupportList {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        Ok(Self({
            let length =
                aper::decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(SliceSupportItem::decode(data)?);
            }
            items
        }))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_length_determinent(data, Some(1), Some(65535), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl AperCodec for ExtendedSliceSupportList {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        ExtendedSliceSupportList::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("ExtendedSliceSupportList"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("ExtendedSliceSupportList"))
    }
}
// EutraCellsList
#[derive(Clone, Debug)]
pub struct EutraCellsList(pub Vec<EutraCellsListItem>);

impl EutraCellsList {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        Ok(Self({
            let length = aper::decode::decode_length_determinent(data, Some(1), Some(256), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(EutraCellsListItem::decode(data)?);
            }
            items
        }))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_length_determinent(data, Some(1), Some(256), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl AperCodec for EutraCellsList {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        EutraCellsList::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("EutraCellsList"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("EutraCellsList"))
    }
}
// EutraCellsListItem
#[derive(Clone, Debug)]
pub struct EutraCellsListItem {
    pub eutra_cell_id: EutraCellId,
    pub served_eutra_cells_information: ServedEutraCellsInformation,
}

impl EutraCellsListItem {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (_optionals, _extensions_present) =
            aper::decode::decode_sequence_header(data, false, 1)?;
        let eutra_cell_id = EutraCellId::decode(data)?;
        let served_eutra_cells_information = ServedEutraCellsInformation::decode(data)?;

        Ok(Self {
            eutra_cell_id,
            served_eutra_cells_information,
        })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(false);

        aper::encode::encode_sequence_header(data, false, &optionals, false)?;
        self.eutra_cell_id.encode(data)?;
        self.served_eutra_cells_information.encode(data)?;

        Ok(())
    }
}

impl AperCodec for EutraCellsListItem {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        EutraCellsListItem::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("EutraCellsListItem"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("EutraCellsListItem"))
    }
}
// EutraCellId
#[derive(Clone, Debug)]
pub struct EutraCellId(pub BitString);

impl EutraCellId {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        Ok(Self(aper::decode::decode_bitstring(
            data,
            Some(28),
            Some(28),
            false,
        )?))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_bitstring(data, Some(28), Some(28), false, &self.0, false)
    }
}

impl AperCodec for EutraCellId {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        EutraCellId::decode_inner(data).map_err(|e: AperCodecError| e.push_context("EutraCellId"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("EutraCellId"))
    }
}
// EutraCoexFddInfo
#[derive(Clone, Debug)]
pub struct EutraCoexFddInfo {
    pub ul_earfcn: Option<ExtendedEarfcn>,
    pub dl_earfcn: ExtendedEarfcn,
    pub ul_transmission_bandwidth: Option<EutraTransmissionBandwidth>,
    pub dl_transmission_bandwidth: EutraTransmissionBandwidth,
}

impl EutraCoexFddInfo {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (optionals, _extensions_present) = aper::decode::decode_sequence_header(data, true, 3)?;
        let ul_earfcn = if optionals[0] {
            Some(ExtendedEarfcn::decode(data)?)
        } else {
            None
        };
        let dl_earfcn = ExtendedEarfcn::decode(data)?;
        let ul_transmission_bandwidth = if optionals[1] {
            Some(EutraTransmissionBandwidth::decode(data)?)
        } else {
            None
        };
        let dl_transmission_bandwidth = EutraTransmissionBandwidth::decode(data)?;

        Ok(Self {
            ul_earfcn,
            dl_earfcn,
            ul_transmission_bandwidth,
            dl_transmission_bandwidth,
        })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(self.ul_earfcn.is_some());
        optionals.push(self.ul_transmission_bandwidth.is_some());
        optionals.push(false);

        aper::encode::encode_sequence_header(data, true, &optionals, false)?;
        if let Some(x) = &self.ul_earfcn {
            x.encode(data)?;
        }
        self.dl_earfcn.encode(data)?;
        if let Some(x) = &self.ul_transmission_bandwidth {
            x.encode(data)?;
        }
        self.dl_transmission_bandwidth.encode(data)?;

        Ok(())
    }
}

impl AperCodec for EutraCoexFddInfo {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        EutraCoexFddInfo::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("EutraCoexFddInfo"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("EutraCoexFddInfo"))
    }
}
// EutraCoexModeInfo
#[derive(Clone, Debug)]
pub enum EutraCoexModeInfo {
    Fdd(EutraCoexFddInfo),
    Tdd(EutraCoexTddInfo),
}

impl EutraCoexModeInfo {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (idx, extended) = aper::decode::decode_choice_idx(data, 0, 1, true)?;
        if extended {
            return Err(aper::AperCodecError::new(
                "CHOICE additions not implemented",
            ));
        }
        match idx {
            0 => Ok(Self::Fdd(EutraCoexFddInfo::decode(data)?)),
            1 => Ok(Self::Tdd(EutraCoexTddInfo::decode(data)?)),
            _ => Err(AperCodecError::new("Unknown choice idx")),
        }
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        match self {
            Self::Fdd(x) => {
                aper::encode::encode_choice_idx(data, 0, 1, true, 0, false)?;
                x.encode(data)
            }
            Self::Tdd(x) => {
                aper::encode::encode_choice_idx(data, 0, 1, true, 1, false)?;
                x.encode(data)
            }
        }
    }
}

impl AperCodec for EutraCoexModeInfo {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        EutraCoexModeInfo::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("EutraCoexModeInfo"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("EutraCoexModeInfo"))
    }
}
// EutraCoexTddInfo
#[derive(Clone, Debug)]
pub struct EutraCoexTddInfo {
    pub earfcn: ExtendedEarfcn,
    pub transmission_bandwidth: EutraTransmissionBandwidth,
    pub subframe_assignment: EutraSubframeAssignment,
    pub special_subframe_info: EutraSpecialSubframeInfo,
}

impl EutraCoexTddInfo {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (_optionals, _extensions_present) =
            aper::decode::decode_sequence_header(data, true, 1)?;
        let earfcn = ExtendedEarfcn::decode(data)?;
        let transmission_bandwidth = EutraTransmissionBandwidth::decode(data)?;
        let subframe_assignment = EutraSubframeAssignment::decode(data)?;
        let special_subframe_info = EutraSpecialSubframeInfo::decode(data)?;

        Ok(Self {
            earfcn,
            transmission_bandwidth,
            subframe_assignment,
            special_subframe_info,
        })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(false);

        aper::encode::encode_sequence_header(data, true, &optionals, false)?;
        self.earfcn.encode(data)?;
        self.transmission_bandwidth.encode(data)?;
        self.subframe_assignment.encode(data)?;
        self.special_subframe_info.encode(data)?;

        Ok(())
    }
}

impl AperCodec for EutraCoexTddInfo {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        EutraCoexTddInfo::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("EutraCoexTddInfo"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("EutraCoexTddInfo"))
    }
}
// EutraCyclicPrefixDl
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum EutraCyclicPrefixDl {
    Normal,
    Extended,
}

impl EutraCyclicPrefixDl {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (idx, extended) = aper::decode::decode_enumerated(data, Some(0), Some(1), true)?;
        if extended {
            return Err(aper::AperCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| AperCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_enumerated(data, Some(0), Some(1), true, *self as i128, false)
    }
}

impl AperCodec for EutraCyclicPrefixDl {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        EutraCyclicPrefixDl::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("EutraCyclicPrefixDl"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("EutraCyclicPrefixDl"))
    }
}
// EutraCyclicPrefixUl
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum EutraCyclicPrefixUl {
    Normal,
    Extended,
}

impl EutraCyclicPrefixUl {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (idx, extended) = aper::decode::decode_enumerated(data, Some(0), Some(1), true)?;
        if extended {
            return Err(aper::AperCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| AperCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_enumerated(data, Some(0), Some(1), true, *self as i128, false)
    }
}

impl AperCodec for EutraCyclicPrefixUl {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        EutraCyclicPrefixUl::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("EutraCyclicPrefixUl"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("EutraCyclicPrefixUl"))
    }
}
// EutraPrachConfiguration
#[derive(Clone, Debug)]
pub struct EutraPrachConfiguration {
    pub root_sequence_index: u16,
    pub zero_correlation_index: u8,
    pub high_speed_flag: bool,
    pub prach_freq_offset: u8,
    pub prach_config_index: Option<u8>,
}

impl EutraPrachConfiguration {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (optionals, _extensions_present) = aper::decode::decode_sequence_header(data, true, 2)?;
        let root_sequence_index =
            aper::decode::decode_integer(data, Some(0), Some(837), false)?.0 as u16;
        let zero_correlation_index =
            aper::decode::decode_integer(data, Some(0), Some(15), false)?.0 as u8;
        let high_speed_flag = aper::decode::decode_bool(data)?;
        let prach_freq_offset =
            aper::decode::decode_integer(data, Some(0), Some(94), false)?.0 as u8;
        let prach_config_index = if optionals[0] {
            Some(aper::decode::decode_integer(data, Some(0), Some(63), false)?.0 as u8)
        } else {
            None
        };

        Ok(Self {
            root_sequence_index,
            zero_correlation_index,
            high_speed_flag,
            prach_freq_offset,
            prach_config_index,
        })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(self.prach_config_index.is_some());
        optionals.push(false);

        aper::encode::encode_sequence_header(data, true, &optionals, false)?;
        aper::encode::encode_integer(
            data,
            Some(0),
            Some(837),
            false,
            self.root_sequence_index as i128,
            false,
        )?;
        aper::encode::encode_integer(
            data,
            Some(0),
            Some(15),
            false,
            self.zero_correlation_index as i128,
            false,
        )?;
        aper::encode::encode_bool(data, self.high_speed_flag)?;
        aper::encode::encode_integer(
            data,
            Some(0),
            Some(94),
            false,
            self.prach_freq_offset as i128,
            false,
        )?;
        if let Some(x) = &self.prach_config_index {
            aper::encode::encode_integer(data, Some(0), Some(63), false, *x as i128, false)?;
        }

        Ok(())
    }
}

impl AperCodec for EutraPrachConfiguration {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        EutraPrachConfiguration::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("EutraPrachConfiguration"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("EutraPrachConfiguration"))
    }
}
// EutraSpecialSubframeInfo
#[derive(Clone, Debug)]
pub struct EutraSpecialSubframeInfo {
    pub special_subframe_patterns: EutraSpecialSubframePatterns,
    pub cyclic_prefix_dl: EutraCyclicPrefixDl,
    pub cyclic_prefix_ul: EutraCyclicPrefixUl,
}

impl EutraSpecialSubframeInfo {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (_optionals, _extensions_present) =
            aper::decode::decode_sequence_header(data, true, 1)?;
        let special_subframe_patterns = EutraSpecialSubframePatterns::decode(data)?;
        let cyclic_prefix_dl = EutraCyclicPrefixDl::decode(data)?;
        let cyclic_prefix_ul = EutraCyclicPrefixUl::decode(data)?;

        Ok(Self {
            special_subframe_patterns,
            cyclic_prefix_dl,
            cyclic_prefix_ul,
        })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(false);

        aper::encode::encode_sequence_header(data, true, &optionals, false)?;
        self.special_subframe_patterns.encode(data)?;
        self.cyclic_prefix_dl.encode(data)?;
        self.cyclic_prefix_ul.encode(data)?;

        Ok(())
    }
}

impl AperCodec for EutraSpecialSubframeInfo {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        EutraSpecialSubframeInfo::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("EutraSpecialSubframeInfo"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("EutraSpecialSubframeInfo"))
    }
}
// EutraSpecialSubframePatterns
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum EutraSpecialSubframePatterns {
    Ssp0,
    Ssp1,
    Ssp2,
    Ssp3,
    Ssp4,
    Ssp5,
    Ssp6,
    Ssp7,
    Ssp8,
    Ssp9,
    Ssp10,
}

impl EutraSpecialSubframePatterns {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (idx, extended) = aper::decode::decode_enumerated(data, Some(0), Some(10), true)?;
        if extended {
            return Err(aper::AperCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| AperCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_enumerated(data, Some(0), Some(10), true, *self as i128, false)
    }
}

impl AperCodec for EutraSpecialSubframePatterns {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        EutraSpecialSubframePatterns::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("EutraSpecialSubframePatterns"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("EutraSpecialSubframePatterns"))
    }
}
// EutraSubframeAssignment
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum EutraSubframeAssignment {
    Sa0,
    Sa1,
    Sa2,
    Sa3,
    Sa4,
    Sa5,
    Sa6,
}

impl EutraSubframeAssignment {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (idx, extended) = aper::decode::decode_enumerated(data, Some(0), Some(6), true)?;
        if extended {
            return Err(aper::AperCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| AperCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_enumerated(data, Some(0), Some(6), true, *self as i128, false)
    }
}

impl AperCodec for EutraSubframeAssignment {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        EutraSubframeAssignment::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("EutraSubframeAssignment"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("EutraSubframeAssignment"))
    }
}
// EutraTransmissionBandwidth
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum EutraTransmissionBandwidth {
    Bw6,
    Bw15,
    Bw25,
    Bw50,
    Bw75,
    Bw100,
}

impl EutraTransmissionBandwidth {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (idx, extended) = aper::decode::decode_enumerated(data, Some(0), Some(5), true)?;
        if extended {
            return Err(aper::AperCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| AperCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_enumerated(data, Some(0), Some(5), true, *self as i128, false)
    }
}

impl AperCodec for EutraTransmissionBandwidth {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        EutraTransmissionBandwidth::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("EutraTransmissionBandwidth"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("EutraTransmissionBandwidth"))
    }
}
// EutranQos
#[derive(Clone, Debug)]
pub struct EutranQos {
    pub qci: Qci,
    pub allocation_and_retention_priority: AllocationAndRetentionPriority,
    pub gbr_qos_information: Option<GbrQosInformation>,
}

impl EutranQos {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (optionals, _extensions_present) = aper::decode::decode_sequence_header(data, true, 2)?;
        let qci = Qci::decode(data)?;
        let allocation_and_retention_priority = AllocationAndRetentionPriority::decode(data)?;
        let gbr_qos_information = if optionals[0] {
            Some(GbrQosInformation::decode(data)?)
        } else {
            None
        };

        Ok(Self {
            qci,
            allocation_and_retention_priority,
            gbr_qos_information,
        })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(self.gbr_qos_information.is_some());
        optionals.push(false);

        aper::encode::encode_sequence_header(data, true, &optionals, false)?;
        self.qci.encode(data)?;
        self.allocation_and_retention_priority.encode(data)?;
        if let Some(x) = &self.gbr_qos_information {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl AperCodec for EutranQos {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        EutranQos::decode_inner(data).map_err(|e: AperCodecError| e.push_context("EutranQos"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("EutranQos"))
    }
}
// ExecuteDuplication
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum ExecuteDuplication {
    True,
}

impl ExecuteDuplication {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (idx, extended) = aper::decode::decode_enumerated(data, Some(0), Some(0), true)?;
        if extended {
            return Err(aper::AperCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| AperCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_enumerated(data, Some(0), Some(0), true, *self as i128, false)
    }
}

impl AperCodec for ExecuteDuplication {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        ExecuteDuplication::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("ExecuteDuplication"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("ExecuteDuplication"))
    }
}
// ExtendedEarfcn
#[derive(Clone, Debug)]
pub struct ExtendedEarfcn(pub u32);

impl ExtendedEarfcn {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        Ok(Self(
            aper::decode::decode_integer(data, Some(0), Some(262143), false)?.0 as u32,
        ))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_integer(data, Some(0), Some(262143), false, self.0 as i128, false)
    }
}

impl AperCodec for ExtendedEarfcn {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        ExtendedEarfcn::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("ExtendedEarfcn"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("ExtendedEarfcn"))
    }
}
// EutraModeInfo
#[derive(Clone, Debug)]
pub enum EutraModeInfo {
    Eutrafdd(EutraFddInfo),
    Eutratdd(EutraTddInfo),
}

impl EutraModeInfo {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (idx, extended) = aper::decode::decode_choice_idx(data, 0, 2, false)?;
        if extended {
            return Err(aper::AperCodecError::new(
                "CHOICE additions not implemented",
            ));
        }
        match idx {
            0 => Ok(Self::Eutrafdd(EutraFddInfo::decode(data)?)),
            1 => Ok(Self::Eutratdd(EutraTddInfo::decode(data)?)),
            2 => Err(AperCodecError::new(
                "Choice extension container not implemented",
            )),
            _ => Err(AperCodecError::new("Unknown choice idx")),
        }
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        match self {
            Self::Eutrafdd(x) => {
                aper::encode::encode_choice_idx(data, 0, 2, false, 0, false)?;
                x.encode(data)
            }
            Self::Eutratdd(x) => {
                aper::encode::encode_choice_idx(data, 0, 2, false, 1, false)?;
                x.encode(data)
            }
        }
    }
}

impl AperCodec for EutraModeInfo {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        EutraModeInfo::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("EutraModeInfo"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("EutraModeInfo"))
    }
}
// EutraNrCellResourceCoordinationReqContainer
#[derive(Clone, Debug)]
pub struct EutraNrCellResourceCoordinationReqContainer(pub Vec<u8>);

impl EutraNrCellResourceCoordinationReqContainer {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        Ok(Self(aper::decode::decode_octetstring(
            data, None, None, false,
        )?))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_octetstring(data, None, None, false, &self.0, false)
    }
}

impl AperCodec for EutraNrCellResourceCoordinationReqContainer {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        EutraNrCellResourceCoordinationReqContainer::decode_inner(data).map_err(
            |e: AperCodecError| e.push_context("EutraNrCellResourceCoordinationReqContainer"),
        )
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data).map_err(|e: AperCodecError| {
            e.push_context("EutraNrCellResourceCoordinationReqContainer")
        })
    }
}
// EutraNrCellResourceCoordinationReqAckContainer
#[derive(Clone, Debug)]
pub struct EutraNrCellResourceCoordinationReqAckContainer(pub Vec<u8>);

impl EutraNrCellResourceCoordinationReqAckContainer {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        Ok(Self(aper::decode::decode_octetstring(
            data, None, None, false,
        )?))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_octetstring(data, None, None, false, &self.0, false)
    }
}

impl AperCodec for EutraNrCellResourceCoordinationReqAckContainer {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        EutraNrCellResourceCoordinationReqAckContainer::decode_inner(data).map_err(
            |e: AperCodecError| e.push_context("EutraNrCellResourceCoordinationReqAckContainer"),
        )
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data).map_err(|e: AperCodecError| {
            e.push_context("EutraNrCellResourceCoordinationReqAckContainer")
        })
    }
}
// EutraFddInfo
#[derive(Clone, Debug)]
pub struct EutraFddInfo {
    pub ul_offset_to_point_a: OffsetToPointA,
    pub dl_offset_to_point_a: OffsetToPointA,
}

impl EutraFddInfo {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (_optionals, _extensions_present) =
            aper::decode::decode_sequence_header(data, true, 1)?;
        let ul_offset_to_point_a = OffsetToPointA::decode(data)?;
        let dl_offset_to_point_a = OffsetToPointA::decode(data)?;

        Ok(Self {
            ul_offset_to_point_a,
            dl_offset_to_point_a,
        })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(false);

        aper::encode::encode_sequence_header(data, true, &optionals, false)?;
        self.ul_offset_to_point_a.encode(data)?;
        self.dl_offset_to_point_a.encode(data)?;

        Ok(())
    }
}

impl AperCodec for EutraFddInfo {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        EutraFddInfo::decode_inner(data).map_err(|e: AperCodecError| e.push_context("EutraFddInfo"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("EutraFddInfo"))
    }
}
// EutraTddInfo
#[derive(Clone, Debug)]
pub struct EutraTddInfo {
    pub offset_to_point_a: OffsetToPointA,
}

impl EutraTddInfo {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (_optionals, _extensions_present) =
            aper::decode::decode_sequence_header(data, true, 1)?;
        let offset_to_point_a = OffsetToPointA::decode(data)?;

        Ok(Self { offset_to_point_a })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(false);

        aper::encode::encode_sequence_header(data, true, &optionals, false)?;
        self.offset_to_point_a.encode(data)?;

        Ok(())
    }
}

impl AperCodec for EutraTddInfo {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        EutraTddInfo::decode_inner(data).map_err(|e: AperCodecError| e.push_context("EutraTddInfo"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("EutraTddInfo"))
    }
}
// EventType
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum EventType {
    OnDemand,
    Periodic,
    Stop,
}

impl EventType {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (idx, extended) = aper::decode::decode_enumerated(data, Some(0), Some(2), true)?;
        if extended {
            return Err(aper::AperCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| AperCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_enumerated(data, Some(0), Some(2), true, *self as i128, false)
    }
}

impl AperCodec for EventType {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        EventType::decode_inner(data).map_err(|e: AperCodecError| e.push_context("EventType"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("EventType"))
    }
}
// ExtendedPacketDelayBudget
#[derive(Clone, Debug)]
pub struct ExtendedPacketDelayBudget(pub u16);

impl ExtendedPacketDelayBudget {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        Ok(Self(
            aper::decode::decode_integer(data, Some(1), Some(65535), true)?.0 as u16,
        ))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_integer(data, Some(1), Some(65535), true, self.0 as i128, false)
    }
}

impl AperCodec for ExtendedPacketDelayBudget {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        ExtendedPacketDelayBudget::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("ExtendedPacketDelayBudget"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("ExtendedPacketDelayBudget"))
    }
}
// F1cPathNsa
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum F1cPathNsa {
    Lte,
    Nr,
    Both,
}

impl F1cPathNsa {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (idx, extended) = aper::decode::decode_enumerated(data, Some(0), Some(2), false)?;
        if extended {
            return Err(aper::AperCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| AperCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_enumerated(data, Some(0), Some(2), false, *self as i128, false)
    }
}

impl AperCodec for F1cPathNsa {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        F1cPathNsa::decode_inner(data).map_err(|e: AperCodecError| e.push_context("F1cPathNsa"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("F1cPathNsa"))
    }
}
// F1cTransferPath
#[derive(Clone, Debug)]
pub struct F1cTransferPath {
    pub f1c_path_nsa: F1cPathNsa,
}

impl F1cTransferPath {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (_optionals, _extensions_present) =
            aper::decode::decode_sequence_header(data, true, 1)?;
        let f1c_path_nsa = F1cPathNsa::decode(data)?;

        Ok(Self { f1c_path_nsa })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(false);

        aper::encode::encode_sequence_header(data, true, &optionals, false)?;
        self.f1c_path_nsa.encode(data)?;

        Ok(())
    }
}

impl AperCodec for F1cTransferPath {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        F1cTransferPath::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("F1cTransferPath"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("F1cTransferPath"))
    }
}
// FddInfo
#[derive(Clone, Debug)]
pub struct FddInfo {
    pub ul_nr_freq_info: NrFreqInfo,
    pub dl_nr_freq_info: NrFreqInfo,
    pub ul_transmission_bandwidth: TransmissionBandwidth,
    pub dl_transmission_bandwidth: TransmissionBandwidth,
}

impl FddInfo {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (_optionals, _extensions_present) =
            aper::decode::decode_sequence_header(data, true, 1)?;
        let ul_nr_freq_info = NrFreqInfo::decode(data)?;
        let dl_nr_freq_info = NrFreqInfo::decode(data)?;
        let ul_transmission_bandwidth = TransmissionBandwidth::decode(data)?;
        let dl_transmission_bandwidth = TransmissionBandwidth::decode(data)?;

        Ok(Self {
            ul_nr_freq_info,
            dl_nr_freq_info,
            ul_transmission_bandwidth,
            dl_transmission_bandwidth,
        })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(false);

        aper::encode::encode_sequence_header(data, true, &optionals, false)?;
        self.ul_nr_freq_info.encode(data)?;
        self.dl_nr_freq_info.encode(data)?;
        self.ul_transmission_bandwidth.encode(data)?;
        self.dl_transmission_bandwidth.encode(data)?;

        Ok(())
    }
}

impl AperCodec for FddInfo {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        FddInfo::decode_inner(data).map_err(|e: AperCodecError| e.push_context("FddInfo"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("FddInfo"))
    }
}
// FlowsMappedToDrbList
#[derive(Clone, Debug)]
pub struct FlowsMappedToDrbList(pub Vec<FlowsMappedToDrbItem>);

impl FlowsMappedToDrbList {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        Ok(Self({
            let length = aper::decode::decode_length_determinent(data, Some(1), Some(64), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(FlowsMappedToDrbItem::decode(data)?);
            }
            items
        }))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_length_determinent(data, Some(1), Some(64), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl AperCodec for FlowsMappedToDrbList {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        FlowsMappedToDrbList::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("FlowsMappedToDrbList"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("FlowsMappedToDrbList"))
    }
}
// FlowsMappedToDrbItem
#[derive(Clone, Debug)]
pub struct FlowsMappedToDrbItem {
    pub qos_flow_identifier: QosFlowIdentifier,
    pub qos_flow_level_qos_parameters: QosFlowLevelQosParameters,
}

impl FlowsMappedToDrbItem {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (_optionals, _extensions_present) =
            aper::decode::decode_sequence_header(data, false, 1)?;
        let qos_flow_identifier = QosFlowIdentifier::decode(data)?;
        let qos_flow_level_qos_parameters = QosFlowLevelQosParameters::decode(data)?;

        Ok(Self {
            qos_flow_identifier,
            qos_flow_level_qos_parameters,
        })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(false);

        aper::encode::encode_sequence_header(data, false, &optionals, false)?;
        self.qos_flow_identifier.encode(data)?;
        self.qos_flow_level_qos_parameters.encode(data)?;

        Ok(())
    }
}

impl AperCodec for FlowsMappedToDrbItem {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        FlowsMappedToDrbItem::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("FlowsMappedToDrbItem"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("FlowsMappedToDrbItem"))
    }
}
// Fr1Bandwidth
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum Fr1Bandwidth {
    Bw5,
    Bw10,
    Bw20,
    Bw40,
    Bw50,
    Bw80,
    Bw100,
}

impl Fr1Bandwidth {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (idx, extended) = aper::decode::decode_enumerated(data, Some(0), Some(6), true)?;
        if extended {
            return Err(aper::AperCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| AperCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_enumerated(data, Some(0), Some(6), true, *self as i128, false)
    }
}

impl AperCodec for Fr1Bandwidth {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        Fr1Bandwidth::decode_inner(data).map_err(|e: AperCodecError| e.push_context("Fr1Bandwidth"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("Fr1Bandwidth"))
    }
}
// Fr2Bandwidth
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum Fr2Bandwidth {
    Bw50,
    Bw100,
    Bw200,
    Bw400,
}

impl Fr2Bandwidth {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (idx, extended) = aper::decode::decode_enumerated(data, Some(0), Some(3), true)?;
        if extended {
            return Err(aper::AperCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| AperCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_enumerated(data, Some(0), Some(3), true, *self as i128, false)
    }
}

impl AperCodec for Fr2Bandwidth {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        Fr2Bandwidth::decode_inner(data).map_err(|e: AperCodecError| e.push_context("Fr2Bandwidth"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("Fr2Bandwidth"))
    }
}
// FreqBandNrItem
#[derive(Clone, Debug)]
pub struct FreqBandNrItem {
    pub freq_band_indicator_nr: u16,
    pub supported_sul_band_list: Vec<SupportedSulFreqBandItem>,
}

impl FreqBandNrItem {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (_optionals, _extensions_present) =
            aper::decode::decode_sequence_header(data, true, 1)?;
        let freq_band_indicator_nr =
            aper::decode::decode_integer(data, Some(1), Some(1024), true)?.0 as u16;
        let supported_sul_band_list = {
            let length = aper::decode::decode_length_determinent(data, Some(0), Some(32), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(SupportedSulFreqBandItem::decode(data)?);
            }
            items
        };

        Ok(Self {
            freq_band_indicator_nr,
            supported_sul_band_list,
        })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(false);

        aper::encode::encode_sequence_header(data, true, &optionals, false)?;
        aper::encode::encode_integer(
            data,
            Some(1),
            Some(1024),
            true,
            self.freq_band_indicator_nr as i128,
            false,
        )?;
        aper::encode::encode_length_determinent(
            data,
            Some(0),
            Some(32),
            false,
            self.supported_sul_band_list.len(),
        )?;
        for x in &self.supported_sul_band_list {
            x.encode(data)?;
        }
        Ok(())?;

        Ok(())
    }
}

impl AperCodec for FreqBandNrItem {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        FreqBandNrItem::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("FreqBandNrItem"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("FreqBandNrItem"))
    }
}
// FreqDomainLength
#[derive(Clone, Debug)]
pub enum FreqDomainLength {
    L839(L839Info),
    L139(L139Info),
}

impl FreqDomainLength {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (idx, extended) = aper::decode::decode_choice_idx(data, 0, 2, false)?;
        if extended {
            return Err(aper::AperCodecError::new(
                "CHOICE additions not implemented",
            ));
        }
        match idx {
            0 => Ok(Self::L839(L839Info::decode(data)?)),
            1 => Ok(Self::L139(L139Info::decode(data)?)),
            2 => Err(AperCodecError::new(
                "Choice extension container not implemented",
            )),
            _ => Err(AperCodecError::new("Unknown choice idx")),
        }
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        match self {
            Self::L839(x) => {
                aper::encode::encode_choice_idx(data, 0, 2, false, 0, false)?;
                x.encode(data)
            }
            Self::L139(x) => {
                aper::encode::encode_choice_idx(data, 0, 2, false, 1, false)?;
                x.encode(data)
            }
        }
    }
}

impl AperCodec for FreqDomainLength {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        FreqDomainLength::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("FreqDomainLength"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("FreqDomainLength"))
    }
}
// FrequencyShift7p5khz
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum FrequencyShift7p5khz {
    False,
    True,
}

impl FrequencyShift7p5khz {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (idx, extended) = aper::decode::decode_enumerated(data, Some(0), Some(1), true)?;
        if extended {
            return Err(aper::AperCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| AperCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_enumerated(data, Some(0), Some(1), true, *self as i128, false)
    }
}

impl AperCodec for FrequencyShift7p5khz {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        FrequencyShift7p5khz::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("FrequencyShift7p5khz"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("FrequencyShift7p5khz"))
    }
}
// FullConfiguration
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum FullConfiguration {
    Full,
}

impl FullConfiguration {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (idx, extended) = aper::decode::decode_enumerated(data, Some(0), Some(0), true)?;
        if extended {
            return Err(aper::AperCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| AperCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_enumerated(data, Some(0), Some(0), true, *self as i128, false)
    }
}

impl AperCodec for FullConfiguration {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        FullConfiguration::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("FullConfiguration"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("FullConfiguration"))
    }
}
// FlowsMappedToSldrbList
#[derive(Clone, Debug)]
pub struct FlowsMappedToSldrbList(pub Vec<FlowsMappedToSldrbItem>);

impl FlowsMappedToSldrbList {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        Ok(Self({
            let length = aper::decode::decode_length_determinent(data, Some(1), Some(2048), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(FlowsMappedToSldrbItem::decode(data)?);
            }
            items
        }))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_length_determinent(data, Some(1), Some(2048), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl AperCodec for FlowsMappedToSldrbList {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        FlowsMappedToSldrbList::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("FlowsMappedToSldrbList"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("FlowsMappedToSldrbList"))
    }
}
// FlowsMappedToSldrbItem
#[derive(Clone, Debug)]
pub struct FlowsMappedToSldrbItem {
    pub pc_5_qos_flow_identifier: Pc5QosFlowIdentifier,
}

impl FlowsMappedToSldrbItem {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (_optionals, _extensions_present) =
            aper::decode::decode_sequence_header(data, true, 1)?;
        let pc_5_qos_flow_identifier = Pc5QosFlowIdentifier::decode(data)?;

        Ok(Self {
            pc_5_qos_flow_identifier,
        })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(false);

        aper::encode::encode_sequence_header(data, true, &optionals, false)?;
        self.pc_5_qos_flow_identifier.encode(data)?;

        Ok(())
    }
}

impl AperCodec for FlowsMappedToSldrbItem {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        FlowsMappedToSldrbItem::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("FlowsMappedToSldrbItem"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("FlowsMappedToSldrbItem"))
    }
}
// GbrQosInformation
#[derive(Clone, Debug)]
pub struct GbrQosInformation {
    pub e_rab_maximum_bitrate_dl: BitRate,
    pub e_rab_maximum_bitrate_ul: BitRate,
    pub e_rab_guaranteed_bitrate_dl: BitRate,
    pub e_rab_guaranteed_bitrate_ul: BitRate,
}

impl GbrQosInformation {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (_optionals, _extensions_present) =
            aper::decode::decode_sequence_header(data, true, 1)?;
        let e_rab_maximum_bitrate_dl = BitRate::decode(data)?;
        let e_rab_maximum_bitrate_ul = BitRate::decode(data)?;
        let e_rab_guaranteed_bitrate_dl = BitRate::decode(data)?;
        let e_rab_guaranteed_bitrate_ul = BitRate::decode(data)?;

        Ok(Self {
            e_rab_maximum_bitrate_dl,
            e_rab_maximum_bitrate_ul,
            e_rab_guaranteed_bitrate_dl,
            e_rab_guaranteed_bitrate_ul,
        })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(false);

        aper::encode::encode_sequence_header(data, true, &optionals, false)?;
        self.e_rab_maximum_bitrate_dl.encode(data)?;
        self.e_rab_maximum_bitrate_ul.encode(data)?;
        self.e_rab_guaranteed_bitrate_dl.encode(data)?;
        self.e_rab_guaranteed_bitrate_ul.encode(data)?;

        Ok(())
    }
}

impl AperCodec for GbrQosInformation {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        GbrQosInformation::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("GbrQosInformation"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("GbrQosInformation"))
    }
}
// GbrQosFlowInformation
#[derive(Clone, Debug)]
pub struct GbrQosFlowInformation {
    pub max_flow_bit_rate_downlink: BitRate,
    pub max_flow_bit_rate_uplink: BitRate,
    pub guaranteed_flow_bit_rate_downlink: BitRate,
    pub guaranteed_flow_bit_rate_uplink: BitRate,
    pub max_packet_loss_rate_downlink: Option<MaxPacketLossRate>,
    pub max_packet_loss_rate_uplink: Option<MaxPacketLossRate>,
}

impl GbrQosFlowInformation {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (optionals, _extensions_present) = aper::decode::decode_sequence_header(data, true, 3)?;
        let max_flow_bit_rate_downlink = BitRate::decode(data)?;
        let max_flow_bit_rate_uplink = BitRate::decode(data)?;
        let guaranteed_flow_bit_rate_downlink = BitRate::decode(data)?;
        let guaranteed_flow_bit_rate_uplink = BitRate::decode(data)?;
        let max_packet_loss_rate_downlink = if optionals[0] {
            Some(MaxPacketLossRate::decode(data)?)
        } else {
            None
        };
        let max_packet_loss_rate_uplink = if optionals[1] {
            Some(MaxPacketLossRate::decode(data)?)
        } else {
            None
        };

        Ok(Self {
            max_flow_bit_rate_downlink,
            max_flow_bit_rate_uplink,
            guaranteed_flow_bit_rate_downlink,
            guaranteed_flow_bit_rate_uplink,
            max_packet_loss_rate_downlink,
            max_packet_loss_rate_uplink,
        })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(self.max_packet_loss_rate_downlink.is_some());
        optionals.push(self.max_packet_loss_rate_uplink.is_some());
        optionals.push(false);

        aper::encode::encode_sequence_header(data, true, &optionals, false)?;
        self.max_flow_bit_rate_downlink.encode(data)?;
        self.max_flow_bit_rate_uplink.encode(data)?;
        self.guaranteed_flow_bit_rate_downlink.encode(data)?;
        self.guaranteed_flow_bit_rate_uplink.encode(data)?;
        if let Some(x) = &self.max_packet_loss_rate_downlink {
            x.encode(data)?;
        }
        if let Some(x) = &self.max_packet_loss_rate_uplink {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl AperCodec for GbrQosFlowInformation {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        GbrQosFlowInformation::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("GbrQosFlowInformation"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("GbrQosFlowInformation"))
    }
}
// CgConfig
#[derive(Clone, Debug)]
pub struct CgConfig(pub Vec<u8>);

impl CgConfig {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        Ok(Self(aper::decode::decode_octetstring(
            data, None, None, false,
        )?))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_octetstring(data, None, None, false, &self.0, false)
    }
}

impl AperCodec for CgConfig {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        CgConfig::decode_inner(data).map_err(|e: AperCodecError| e.push_context("CgConfig"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("CgConfig"))
    }
}
// GeographicalCoordinates
#[derive(Clone, Debug)]
pub struct GeographicalCoordinates {
    pub trp_position_definition_type: TrpPositionDefinitionType,
    pub dlprs_resource_coordinates: Option<DlprsResourceCoordinates>,
}

impl GeographicalCoordinates {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (optionals, _extensions_present) =
            aper::decode::decode_sequence_header(data, false, 2)?;
        let trp_position_definition_type = TrpPositionDefinitionType::decode(data)?;
        let dlprs_resource_coordinates = if optionals[0] {
            Some(DlprsResourceCoordinates::decode(data)?)
        } else {
            None
        };

        Ok(Self {
            trp_position_definition_type,
            dlprs_resource_coordinates,
        })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(self.dlprs_resource_coordinates.is_some());
        optionals.push(false);

        aper::encode::encode_sequence_header(data, false, &optionals, false)?;
        self.trp_position_definition_type.encode(data)?;
        if let Some(x) = &self.dlprs_resource_coordinates {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl AperCodec for GeographicalCoordinates {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        GeographicalCoordinates::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("GeographicalCoordinates"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("GeographicalCoordinates"))
    }
}
// GnbCuMeasurementId
#[derive(Clone, Debug)]
pub struct GnbCuMeasurementId(pub u16);

impl GnbCuMeasurementId {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        Ok(Self(
            aper::decode::decode_integer(data, Some(0), Some(4095), true)?.0 as u16,
        ))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_integer(data, Some(0), Some(4095), true, self.0 as i128, false)
    }
}

impl AperCodec for GnbCuMeasurementId {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        GnbCuMeasurementId::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("GnbCuMeasurementId"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("GnbCuMeasurementId"))
    }
}
// GnbDuMeasurementId
#[derive(Clone, Debug)]
pub struct GnbDuMeasurementId(pub u16);

impl GnbDuMeasurementId {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        Ok(Self(
            aper::decode::decode_integer(data, Some(0), Some(4095), true)?.0 as u16,
        ))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_integer(data, Some(0), Some(4095), true, self.0 as i128, false)
    }
}

impl AperCodec for GnbDuMeasurementId {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        GnbDuMeasurementId::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("GnbDuMeasurementId"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("GnbDuMeasurementId"))
    }
}
// GnbCuSystemInformation
#[derive(Clone, Debug)]
pub struct GnbCuSystemInformation {
    pub sibtypetobeupdatedlist: Vec<SibtypetobeupdatedListItem>,
}

impl GnbCuSystemInformation {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (_optionals, _extensions_present) =
            aper::decode::decode_sequence_header(data, true, 1)?;
        let sibtypetobeupdatedlist = {
            let length = aper::decode::decode_length_determinent(data, Some(1), Some(32), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(SibtypetobeupdatedListItem::decode(data)?);
            }
            items
        };

        Ok(Self {
            sibtypetobeupdatedlist,
        })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(false);

        aper::encode::encode_sequence_header(data, true, &optionals, false)?;
        aper::encode::encode_length_determinent(
            data,
            Some(1),
            Some(32),
            false,
            self.sibtypetobeupdatedlist.len(),
        )?;
        for x in &self.sibtypetobeupdatedlist {
            x.encode(data)?;
        }
        Ok(())?;

        Ok(())
    }
}

impl AperCodec for GnbCuSystemInformation {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        GnbCuSystemInformation::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("GnbCuSystemInformation"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("GnbCuSystemInformation"))
    }
}
// GnbCuTnlAssociationSetupItem
#[derive(Clone, Debug)]
pub struct GnbCuTnlAssociationSetupItem {
    pub tnl_association_transport_layer_address: CpTransportLayerAddress,
}

impl GnbCuTnlAssociationSetupItem {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (_optionals, _extensions_present) =
            aper::decode::decode_sequence_header(data, false, 1)?;
        let tnl_association_transport_layer_address = CpTransportLayerAddress::decode(data)?;

        Ok(Self {
            tnl_association_transport_layer_address,
        })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(false);

        aper::encode::encode_sequence_header(data, false, &optionals, false)?;
        self.tnl_association_transport_layer_address.encode(data)?;

        Ok(())
    }
}

impl AperCodec for GnbCuTnlAssociationSetupItem {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        GnbCuTnlAssociationSetupItem::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("GnbCuTnlAssociationSetupItem"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("GnbCuTnlAssociationSetupItem"))
    }
}
// GnbCuTnlAssociationFailedToSetupItem
#[derive(Clone, Debug)]
pub struct GnbCuTnlAssociationFailedToSetupItem {
    pub tnl_association_transport_layer_address: CpTransportLayerAddress,
    pub cause: Cause,
}

impl GnbCuTnlAssociationFailedToSetupItem {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (_optionals, _extensions_present) =
            aper::decode::decode_sequence_header(data, false, 1)?;
        let tnl_association_transport_layer_address = CpTransportLayerAddress::decode(data)?;
        let cause = Cause::decode(data)?;

        Ok(Self {
            tnl_association_transport_layer_address,
            cause,
        })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(false);

        aper::encode::encode_sequence_header(data, false, &optionals, false)?;
        self.tnl_association_transport_layer_address.encode(data)?;
        self.cause.encode(data)?;

        Ok(())
    }
}

impl AperCodec for GnbCuTnlAssociationFailedToSetupItem {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        GnbCuTnlAssociationFailedToSetupItem::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("GnbCuTnlAssociationFailedToSetupItem"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("GnbCuTnlAssociationFailedToSetupItem"))
    }
}
// GnbCuTnlAssociationToAddItem
#[derive(Clone, Debug)]
pub struct GnbCuTnlAssociationToAddItem {
    pub tnl_association_transport_layer_address: CpTransportLayerAddress,
    pub tnl_association_usage: TnlAssociationUsage,
}

impl GnbCuTnlAssociationToAddItem {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (_optionals, _extensions_present) =
            aper::decode::decode_sequence_header(data, false, 1)?;
        let tnl_association_transport_layer_address = CpTransportLayerAddress::decode(data)?;
        let tnl_association_usage = TnlAssociationUsage::decode(data)?;

        Ok(Self {
            tnl_association_transport_layer_address,
            tnl_association_usage,
        })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(false);

        aper::encode::encode_sequence_header(data, false, &optionals, false)?;
        self.tnl_association_transport_layer_address.encode(data)?;
        self.tnl_association_usage.encode(data)?;

        Ok(())
    }
}

impl AperCodec for GnbCuTnlAssociationToAddItem {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        GnbCuTnlAssociationToAddItem::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("GnbCuTnlAssociationToAddItem"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("GnbCuTnlAssociationToAddItem"))
    }
}
// GnbCuTnlAssociationToRemoveItem
#[derive(Clone, Debug)]
pub struct GnbCuTnlAssociationToRemoveItem {
    pub tnl_association_transport_layer_address: CpTransportLayerAddress,
}

impl GnbCuTnlAssociationToRemoveItem {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (_optionals, _extensions_present) =
            aper::decode::decode_sequence_header(data, false, 1)?;
        let tnl_association_transport_layer_address = CpTransportLayerAddress::decode(data)?;

        Ok(Self {
            tnl_association_transport_layer_address,
        })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(false);

        aper::encode::encode_sequence_header(data, false, &optionals, false)?;
        self.tnl_association_transport_layer_address.encode(data)?;

        Ok(())
    }
}

impl AperCodec for GnbCuTnlAssociationToRemoveItem {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        GnbCuTnlAssociationToRemoveItem::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("GnbCuTnlAssociationToRemoveItem"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("GnbCuTnlAssociationToRemoveItem"))
    }
}
// GnbCuTnlAssociationToUpdateItem
#[derive(Clone, Debug)]
pub struct GnbCuTnlAssociationToUpdateItem {
    pub tnl_association_transport_layer_address: CpTransportLayerAddress,
    pub tnl_association_usage: Option<TnlAssociationUsage>,
}

impl GnbCuTnlAssociationToUpdateItem {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (optionals, _extensions_present) =
            aper::decode::decode_sequence_header(data, false, 2)?;
        let tnl_association_transport_layer_address = CpTransportLayerAddress::decode(data)?;
        let tnl_association_usage = if optionals[0] {
            Some(TnlAssociationUsage::decode(data)?)
        } else {
            None
        };

        Ok(Self {
            tnl_association_transport_layer_address,
            tnl_association_usage,
        })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(self.tnl_association_usage.is_some());
        optionals.push(false);

        aper::encode::encode_sequence_header(data, false, &optionals, false)?;
        self.tnl_association_transport_layer_address.encode(data)?;
        if let Some(x) = &self.tnl_association_usage {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl AperCodec for GnbCuTnlAssociationToUpdateItem {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        GnbCuTnlAssociationToUpdateItem::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("GnbCuTnlAssociationToUpdateItem"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("GnbCuTnlAssociationToUpdateItem"))
    }
}
// GnbCuUeF1apId
#[derive(Clone, Debug)]
pub struct GnbCuUeF1apId(pub u64);

impl GnbCuUeF1apId {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        Ok(Self(
            aper::decode::decode_integer(data, Some(0), Some(4294967295), false)?.0 as u64,
        ))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_integer(
            data,
            Some(0),
            Some(4294967295),
            false,
            self.0 as i128,
            false,
        )
    }
}

impl AperCodec for GnbCuUeF1apId {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        GnbCuUeF1apId::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("GnbCuUeF1apId"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("GnbCuUeF1apId"))
    }
}
// GnbDuCellResourceConfiguration
#[derive(Clone, Debug)]
pub struct GnbDuCellResourceConfiguration {
    pub subcarrier_spacing: SubcarrierSpacing,
    pub duf_transmission_periodicity: Option<DufTransmissionPeriodicity>,
    pub duf_slot_config_list: Option<DufSlotConfigList>,
    pub hsna_transmission_periodicity: HsnaTransmissionPeriodicity,
    pub hnsa_slot_config_list: Option<HsnaSlotConfigList>,
}

impl GnbDuCellResourceConfiguration {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (optionals, _extensions_present) =
            aper::decode::decode_sequence_header(data, false, 4)?;
        let subcarrier_spacing = SubcarrierSpacing::decode(data)?;
        let duf_transmission_periodicity = if optionals[0] {
            Some(DufTransmissionPeriodicity::decode(data)?)
        } else {
            None
        };
        let duf_slot_config_list = if optionals[1] {
            Some(DufSlotConfigList::decode(data)?)
        } else {
            None
        };
        let hsna_transmission_periodicity = HsnaTransmissionPeriodicity::decode(data)?;
        let hnsa_slot_config_list = if optionals[2] {
            Some(HsnaSlotConfigList::decode(data)?)
        } else {
            None
        };

        Ok(Self {
            subcarrier_spacing,
            duf_transmission_periodicity,
            duf_slot_config_list,
            hsna_transmission_periodicity,
            hnsa_slot_config_list,
        })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(self.duf_transmission_periodicity.is_some());
        optionals.push(self.duf_slot_config_list.is_some());
        optionals.push(self.hnsa_slot_config_list.is_some());
        optionals.push(false);

        aper::encode::encode_sequence_header(data, false, &optionals, false)?;
        self.subcarrier_spacing.encode(data)?;
        if let Some(x) = &self.duf_transmission_periodicity {
            x.encode(data)?;
        }
        if let Some(x) = &self.duf_slot_config_list {
            x.encode(data)?;
        }
        self.hsna_transmission_periodicity.encode(data)?;
        if let Some(x) = &self.hnsa_slot_config_list {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl AperCodec for GnbDuCellResourceConfiguration {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        GnbDuCellResourceConfiguration::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("GnbDuCellResourceConfiguration"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("GnbDuCellResourceConfiguration"))
    }
}
// GnbDuUeF1apId
#[derive(Clone, Debug)]
pub struct GnbDuUeF1apId(pub u64);

impl GnbDuUeF1apId {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        Ok(Self(
            aper::decode::decode_integer(data, Some(0), Some(4294967295), false)?.0 as u64,
        ))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_integer(
            data,
            Some(0),
            Some(4294967295),
            false,
            self.0 as i128,
            false,
        )
    }
}

impl AperCodec for GnbDuUeF1apId {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        GnbDuUeF1apId::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("GnbDuUeF1apId"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("GnbDuUeF1apId"))
    }
}
// GnbDuId
#[derive(Clone, Debug)]
pub struct GnbDuId(pub u64);

impl GnbDuId {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        Ok(Self(
            aper::decode::decode_integer(data, Some(0), Some(68719476735), false)?.0 as u64,
        ))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_integer(
            data,
            Some(0),
            Some(68719476735),
            false,
            self.0 as i128,
            false,
        )
    }
}

impl AperCodec for GnbDuId {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        GnbDuId::decode_inner(data).map_err(|e: AperCodecError| e.push_context("GnbDuId"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("GnbDuId"))
    }
}
// GnbCuName
#[derive(Clone, Debug)]
pub struct GnbCuName(pub String);

impl GnbCuName {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        Ok(Self(aper::decode::decode_printable_string(
            data,
            Some(1),
            Some(150),
            true,
        )?))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_printable_string(data, Some(1), Some(150), true, &self.0, false)
    }
}

impl AperCodec for GnbCuName {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        GnbCuName::decode_inner(data).map_err(|e: AperCodecError| e.push_context("GnbCuName"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("GnbCuName"))
    }
}
// GnbDuName
#[derive(Clone, Debug)]
pub struct GnbDuName(pub String);

impl GnbDuName {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        Ok(Self(aper::decode::decode_printable_string(
            data,
            Some(1),
            Some(150),
            true,
        )?))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_printable_string(data, Some(1), Some(150), true, &self.0, false)
    }
}

impl AperCodec for GnbDuName {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        GnbDuName::decode_inner(data).map_err(|e: AperCodecError| e.push_context("GnbDuName"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("GnbDuName"))
    }
}
// ExtendedGnbCuName
#[derive(Clone, Debug)]
pub struct ExtendedGnbCuName {
    pub gnb_cu_name_visible_string: Option<GnbCuNameVisibleString>,
    pub gnb_cu_name_utf8_string: Option<GnbCuNameUtf8String>,
}

impl ExtendedGnbCuName {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (optionals, _extensions_present) = aper::decode::decode_sequence_header(data, true, 3)?;
        let gnb_cu_name_visible_string = if optionals[0] {
            Some(GnbCuNameVisibleString::decode(data)?)
        } else {
            None
        };
        let gnb_cu_name_utf8_string = if optionals[1] {
            Some(GnbCuNameUtf8String::decode(data)?)
        } else {
            None
        };

        Ok(Self {
            gnb_cu_name_visible_string,
            gnb_cu_name_utf8_string,
        })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(self.gnb_cu_name_visible_string.is_some());
        optionals.push(self.gnb_cu_name_utf8_string.is_some());
        optionals.push(false);

        aper::encode::encode_sequence_header(data, true, &optionals, false)?;
        if let Some(x) = &self.gnb_cu_name_visible_string {
            x.encode(data)?;
        }
        if let Some(x) = &self.gnb_cu_name_utf8_string {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl AperCodec for ExtendedGnbCuName {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        ExtendedGnbCuName::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("ExtendedGnbCuName"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("ExtendedGnbCuName"))
    }
}
// GnbCuNameVisibleString
#[derive(Clone, Debug)]
pub struct GnbCuNameVisibleString(pub String);

impl GnbCuNameVisibleString {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        Ok(Self(aper::decode::decode_visible_string(
            data,
            Some(1),
            Some(150),
            true,
        )?))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_visible_string(data, Some(1), Some(150), true, &self.0, false)
    }
}

impl AperCodec for GnbCuNameVisibleString {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        GnbCuNameVisibleString::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("GnbCuNameVisibleString"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("GnbCuNameVisibleString"))
    }
}
// GnbCuNameUtf8String
#[derive(Clone, Debug)]
pub struct GnbCuNameUtf8String(pub String);

impl GnbCuNameUtf8String {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        Ok(Self(aper::decode::decode_utf8_string(
            data,
            Some(1),
            Some(150),
            true,
        )?))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_utf8_string(data, Some(1), Some(150), true, &self.0, false)
    }
}

impl AperCodec for GnbCuNameUtf8String {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        GnbCuNameUtf8String::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("GnbCuNameUtf8String"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("GnbCuNameUtf8String"))
    }
}
// ExtendedGnbDuName
#[derive(Clone, Debug)]
pub struct ExtendedGnbDuName {
    pub gnb_du_name_visible_string: Option<GnbDuNameVisibleString>,
    pub gnb_du_name_utf8_string: Option<GnbDuNameUtf8String>,
}

impl ExtendedGnbDuName {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (optionals, _extensions_present) = aper::decode::decode_sequence_header(data, true, 3)?;
        let gnb_du_name_visible_string = if optionals[0] {
            Some(GnbDuNameVisibleString::decode(data)?)
        } else {
            None
        };
        let gnb_du_name_utf8_string = if optionals[1] {
            Some(GnbDuNameUtf8String::decode(data)?)
        } else {
            None
        };

        Ok(Self {
            gnb_du_name_visible_string,
            gnb_du_name_utf8_string,
        })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(self.gnb_du_name_visible_string.is_some());
        optionals.push(self.gnb_du_name_utf8_string.is_some());
        optionals.push(false);

        aper::encode::encode_sequence_header(data, true, &optionals, false)?;
        if let Some(x) = &self.gnb_du_name_visible_string {
            x.encode(data)?;
        }
        if let Some(x) = &self.gnb_du_name_utf8_string {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl AperCodec for ExtendedGnbDuName {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        ExtendedGnbDuName::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("ExtendedGnbDuName"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("ExtendedGnbDuName"))
    }
}
// GnbDuNameVisibleString
#[derive(Clone, Debug)]
pub struct GnbDuNameVisibleString(pub String);

impl GnbDuNameVisibleString {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        Ok(Self(aper::decode::decode_visible_string(
            data,
            Some(1),
            Some(150),
            true,
        )?))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_visible_string(data, Some(1), Some(150), true, &self.0, false)
    }
}

impl AperCodec for GnbDuNameVisibleString {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        GnbDuNameVisibleString::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("GnbDuNameVisibleString"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("GnbDuNameVisibleString"))
    }
}
// GnbDuNameUtf8String
#[derive(Clone, Debug)]
pub struct GnbDuNameUtf8String(pub String);

impl GnbDuNameUtf8String {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        Ok(Self(aper::decode::decode_utf8_string(
            data,
            Some(1),
            Some(150),
            true,
        )?))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_utf8_string(data, Some(1), Some(150), true, &self.0, false)
    }
}

impl AperCodec for GnbDuNameUtf8String {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        GnbDuNameUtf8String::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("GnbDuNameUtf8String"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("GnbDuNameUtf8String"))
    }
}
// GnbDuServedCellsItem
#[derive(Clone, Debug)]
pub struct GnbDuServedCellsItem {
    pub served_cell_information: ServedCellInformation,
    pub gnb_du_system_information: Option<GnbDuSystemInformation>,
}

impl GnbDuServedCellsItem {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (optionals, _extensions_present) = aper::decode::decode_sequence_header(data, true, 2)?;
        let served_cell_information = ServedCellInformation::decode(data)?;
        let gnb_du_system_information = if optionals[0] {
            Some(GnbDuSystemInformation::decode(data)?)
        } else {
            None
        };

        Ok(Self {
            served_cell_information,
            gnb_du_system_information,
        })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(self.gnb_du_system_information.is_some());
        optionals.push(false);

        aper::encode::encode_sequence_header(data, true, &optionals, false)?;
        self.served_cell_information.encode(data)?;
        if let Some(x) = &self.gnb_du_system_information {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl AperCodec for GnbDuServedCellsItem {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        GnbDuServedCellsItem::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("GnbDuServedCellsItem"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("GnbDuServedCellsItem"))
    }
}
// GnbDuSystemInformation
#[derive(Clone, Debug)]
pub struct GnbDuSystemInformation {
    pub mib_message: MibMessage,
    pub sib1_message: Sib1Message,
}

impl GnbDuSystemInformation {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (_optionals, _extensions_present) =
            aper::decode::decode_sequence_header(data, true, 1)?;
        let mib_message = MibMessage::decode(data)?;
        let sib1_message = Sib1Message::decode(data)?;

        Ok(Self {
            mib_message,
            sib1_message,
        })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(false);

        aper::encode::encode_sequence_header(data, true, &optionals, false)?;
        self.mib_message.encode(data)?;
        self.sib1_message.encode(data)?;

        Ok(())
    }
}

impl AperCodec for GnbDuSystemInformation {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        GnbDuSystemInformation::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("GnbDuSystemInformation"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("GnbDuSystemInformation"))
    }
}
// GnbDuConfigurationQuery
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum GnbDuConfigurationQuery {
    True,
}

impl GnbDuConfigurationQuery {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (idx, extended) = aper::decode::decode_enumerated(data, Some(0), Some(0), true)?;
        if extended {
            return Err(aper::AperCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| AperCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_enumerated(data, Some(0), Some(0), true, *self as i128, false)
    }
}

impl AperCodec for GnbDuConfigurationQuery {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        GnbDuConfigurationQuery::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("GnbDuConfigurationQuery"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("GnbDuConfigurationQuery"))
    }
}
// GnbDuOverloadInformation
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum GnbDuOverloadInformation {
    Overloaded,
    NotOverloaded,
}

impl GnbDuOverloadInformation {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (idx, extended) = aper::decode::decode_enumerated(data, Some(0), Some(1), false)?;
        if extended {
            return Err(aper::AperCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| AperCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_enumerated(data, Some(0), Some(1), false, *self as i128, false)
    }
}

impl AperCodec for GnbDuOverloadInformation {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        GnbDuOverloadInformation::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("GnbDuOverloadInformation"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("GnbDuOverloadInformation"))
    }
}
// GnbDuTnlAssociationToRemoveItem
#[derive(Clone, Debug)]
pub struct GnbDuTnlAssociationToRemoveItem {
    pub tnl_association_transport_layer_address: CpTransportLayerAddress,
    pub tnl_association_transport_layer_address_gnb_cu: Option<CpTransportLayerAddress>,
}

impl GnbDuTnlAssociationToRemoveItem {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (optionals, _extensions_present) =
            aper::decode::decode_sequence_header(data, false, 2)?;
        let tnl_association_transport_layer_address = CpTransportLayerAddress::decode(data)?;
        let tnl_association_transport_layer_address_gnb_cu = if optionals[0] {
            Some(CpTransportLayerAddress::decode(data)?)
        } else {
            None
        };

        Ok(Self {
            tnl_association_transport_layer_address,
            tnl_association_transport_layer_address_gnb_cu,
        })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(
            self.tnl_association_transport_layer_address_gnb_cu
                .is_some(),
        );
        optionals.push(false);

        aper::encode::encode_sequence_header(data, false, &optionals, false)?;
        self.tnl_association_transport_layer_address.encode(data)?;
        if let Some(x) = &self.tnl_association_transport_layer_address_gnb_cu {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl AperCodec for GnbDuTnlAssociationToRemoveItem {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        GnbDuTnlAssociationToRemoveItem::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("GnbDuTnlAssociationToRemoveItem"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("GnbDuTnlAssociationToRemoveItem"))
    }
}
// GnbRxTxTimeDiff
#[derive(Clone, Debug)]
pub struct GnbRxTxTimeDiff {
    pub rx_tx_time_diff: GnbRxTxTimeDiffMeas,
    pub additional_path_list: Option<AdditionalPathList>,
}

impl GnbRxTxTimeDiff {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (optionals, _extensions_present) =
            aper::decode::decode_sequence_header(data, false, 2)?;
        let rx_tx_time_diff = GnbRxTxTimeDiffMeas::decode(data)?;
        let additional_path_list = if optionals[0] {
            Some(AdditionalPathList::decode(data)?)
        } else {
            None
        };

        Ok(Self {
            rx_tx_time_diff,
            additional_path_list,
        })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(self.additional_path_list.is_some());
        optionals.push(false);

        aper::encode::encode_sequence_header(data, false, &optionals, false)?;
        self.rx_tx_time_diff.encode(data)?;
        if let Some(x) = &self.additional_path_list {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl AperCodec for GnbRxTxTimeDiff {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        GnbRxTxTimeDiff::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("GnbRxTxTimeDiff"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("GnbRxTxTimeDiff"))
    }
}
// GnbRxTxTimeDiffMeas
#[derive(Clone, Debug)]
pub enum GnbRxTxTimeDiffMeas {
    K0(u32),
    K1(u32),
    K2(u32),
    K3(u32),
    K4(u32),
    K5(u16),
}

impl GnbRxTxTimeDiffMeas {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (idx, extended) = aper::decode::decode_choice_idx(data, 0, 6, false)?;
        if extended {
            return Err(aper::AperCodecError::new(
                "CHOICE additions not implemented",
            ));
        }
        match idx {
            0 => Ok(Self::K0(
                aper::decode::decode_integer(data, Some(0), Some(1970049), false)?.0 as u32,
            )),
            1 => Ok(Self::K1(
                aper::decode::decode_integer(data, Some(0), Some(985025), false)?.0 as u32,
            )),
            2 => Ok(Self::K2(
                aper::decode::decode_integer(data, Some(0), Some(492513), false)?.0 as u32,
            )),
            3 => Ok(Self::K3(
                aper::decode::decode_integer(data, Some(0), Some(246257), false)?.0 as u32,
            )),
            4 => Ok(Self::K4(
                aper::decode::decode_integer(data, Some(0), Some(123129), false)?.0 as u32,
            )),
            5 => Ok(Self::K5(
                aper::decode::decode_integer(data, Some(0), Some(61565), false)?.0 as u16,
            )),
            6 => Err(AperCodecError::new(
                "Choice extension container not implemented",
            )),
            _ => Err(AperCodecError::new("Unknown choice idx")),
        }
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        match self {
            Self::K0(x) => {
                aper::encode::encode_choice_idx(data, 0, 6, false, 0, false)?;
                aper::encode::encode_integer(data, Some(0), Some(1970049), false, *x as i128, false)
            }
            Self::K1(x) => {
                aper::encode::encode_choice_idx(data, 0, 6, false, 1, false)?;
                aper::encode::encode_integer(data, Some(0), Some(985025), false, *x as i128, false)
            }
            Self::K2(x) => {
                aper::encode::encode_choice_idx(data, 0, 6, false, 2, false)?;
                aper::encode::encode_integer(data, Some(0), Some(492513), false, *x as i128, false)
            }
            Self::K3(x) => {
                aper::encode::encode_choice_idx(data, 0, 6, false, 3, false)?;
                aper::encode::encode_integer(data, Some(0), Some(246257), false, *x as i128, false)
            }
            Self::K4(x) => {
                aper::encode::encode_choice_idx(data, 0, 6, false, 4, false)?;
                aper::encode::encode_integer(data, Some(0), Some(123129), false, *x as i128, false)
            }
            Self::K5(x) => {
                aper::encode::encode_choice_idx(data, 0, 6, false, 5, false)?;
                aper::encode::encode_integer(data, Some(0), Some(61565), false, *x as i128, false)
            }
        }
    }
}

impl AperCodec for GnbRxTxTimeDiffMeas {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        GnbRxTxTimeDiffMeas::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("GnbRxTxTimeDiffMeas"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("GnbRxTxTimeDiffMeas"))
    }
}
// GnbSetId
#[derive(Clone, Debug)]
pub struct GnbSetId(pub BitString);

impl GnbSetId {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        Ok(Self(aper::decode::decode_bitstring(
            data,
            Some(22),
            Some(22),
            false,
        )?))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_bitstring(data, Some(22), Some(22), false, &self.0, false)
    }
}

impl AperCodec for GnbSetId {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        GnbSetId::decode_inner(data).map_err(|e: AperCodecError| e.push_context("GnbSetId"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("GnbSetId"))
    }
}
// GtpTeid
#[derive(Clone, Debug)]
pub struct GtpTeid(pub Vec<u8>);

impl GtpTeid {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        Ok(Self(aper::decode::decode_octetstring(
            data,
            Some(4),
            Some(4),
            false,
        )?))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_octetstring(data, Some(4), Some(4), false, &self.0, false)
    }
}

impl AperCodec for GtpTeid {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        GtpTeid::decode_inner(data).map_err(|e: AperCodecError| e.push_context("GtpTeid"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("GtpTeid"))
    }
}
// GtptlAs
#[derive(Clone, Debug)]
pub struct GtptlAs(pub Vec<GtptlaItem>);

impl GtptlAs {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        Ok(Self({
            let length = aper::decode::decode_length_determinent(data, Some(1), Some(16), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(GtptlaItem::decode(data)?);
            }
            items
        }))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_length_determinent(data, Some(1), Some(16), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl AperCodec for GtptlAs {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        GtptlAs::decode_inner(data).map_err(|e: AperCodecError| e.push_context("GtptlAs"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("GtptlAs"))
    }
}
// GtptlaItem
#[derive(Clone, Debug)]
pub struct GtptlaItem {
    pub gtp_transport_layer_address: TransportLayerAddress,
}

impl GtptlaItem {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (_optionals, _extensions_present) =
            aper::decode::decode_sequence_header(data, false, 1)?;
        let gtp_transport_layer_address = TransportLayerAddress::decode(data)?;

        Ok(Self {
            gtp_transport_layer_address,
        })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(false);

        aper::encode::encode_sequence_header(data, false, &optionals, false)?;
        self.gtp_transport_layer_address.encode(data)?;

        Ok(())
    }
}

impl AperCodec for GtptlaItem {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        GtptlaItem::decode_inner(data).map_err(|e: AperCodecError| e.push_context("GtptlaItem"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("GtptlaItem"))
    }
}
// GtpTunnel
#[derive(Clone, Debug)]
pub struct GtpTunnel {
    pub transport_layer_address: TransportLayerAddress,
    pub gtp_teid: GtpTeid,
}

impl GtpTunnel {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (_optionals, _extensions_present) =
            aper::decode::decode_sequence_header(data, true, 1)?;
        let transport_layer_address = TransportLayerAddress::decode(data)?;
        let gtp_teid = GtpTeid::decode(data)?;

        Ok(Self {
            transport_layer_address,
            gtp_teid,
        })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(false);

        aper::encode::encode_sequence_header(data, true, &optionals, false)?;
        self.transport_layer_address.encode(data)?;
        self.gtp_teid.encode(data)?;

        Ok(())
    }
}

impl AperCodec for GtpTunnel {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        GtpTunnel::decode_inner(data).map_err(|e: AperCodecError| e.push_context("GtpTunnel"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("GtpTunnel"))
    }
}
// HandoverPreparationInformation
#[derive(Clone, Debug)]
pub struct HandoverPreparationInformation(pub Vec<u8>);

impl HandoverPreparationInformation {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        Ok(Self(aper::decode::decode_octetstring(
            data, None, None, false,
        )?))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_octetstring(data, None, None, false, &self.0, false)
    }
}

impl AperCodec for HandoverPreparationInformation {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        HandoverPreparationInformation::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("HandoverPreparationInformation"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("HandoverPreparationInformation"))
    }
}
// HardwareLoadIndicator
#[derive(Clone, Debug)]
pub struct HardwareLoadIndicator {
    pub dl_hardware_load_indicator: u8,
    pub ul_hardware_load_indicator: u8,
}

impl HardwareLoadIndicator {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (_optionals, _extensions_present) =
            aper::decode::decode_sequence_header(data, true, 1)?;
        let dl_hardware_load_indicator =
            aper::decode::decode_integer(data, Some(0), Some(100), true)?.0 as u8;
        let ul_hardware_load_indicator =
            aper::decode::decode_integer(data, Some(0), Some(100), true)?.0 as u8;

        Ok(Self {
            dl_hardware_load_indicator,
            ul_hardware_load_indicator,
        })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(false);

        aper::encode::encode_sequence_header(data, true, &optionals, false)?;
        aper::encode::encode_integer(
            data,
            Some(0),
            Some(100),
            true,
            self.dl_hardware_load_indicator as i128,
            false,
        )?;
        aper::encode::encode_integer(
            data,
            Some(0),
            Some(100),
            true,
            self.ul_hardware_load_indicator as i128,
            false,
        )?;

        Ok(())
    }
}

impl AperCodec for HardwareLoadIndicator {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        HardwareLoadIndicator::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("HardwareLoadIndicator"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("HardwareLoadIndicator"))
    }
}
// HsnaSlotConfigList
#[derive(Clone, Debug)]
pub struct HsnaSlotConfigList(pub Vec<HsnaSlotConfigItem>);

impl HsnaSlotConfigList {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        Ok(Self({
            let length = aper::decode::decode_length_determinent(data, Some(1), Some(5120), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(HsnaSlotConfigItem::decode(data)?);
            }
            items
        }))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_length_determinent(data, Some(1), Some(5120), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl AperCodec for HsnaSlotConfigList {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        HsnaSlotConfigList::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("HsnaSlotConfigList"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("HsnaSlotConfigList"))
    }
}
// HsnaSlotConfigItem
#[derive(Clone, Debug)]
pub struct HsnaSlotConfigItem {
    pub hsna_downlink: Option<HsnaDownlink>,
    pub hsna_uplink: Option<HsnaUplink>,
    pub hsna_flexible: Option<HsnaFlexible>,
}

impl HsnaSlotConfigItem {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (optionals, _extensions_present) =
            aper::decode::decode_sequence_header(data, false, 4)?;
        let hsna_downlink = if optionals[0] {
            Some(HsnaDownlink::decode(data)?)
        } else {
            None
        };
        let hsna_uplink = if optionals[1] {
            Some(HsnaUplink::decode(data)?)
        } else {
            None
        };
        let hsna_flexible = if optionals[2] {
            Some(HsnaFlexible::decode(data)?)
        } else {
            None
        };

        Ok(Self {
            hsna_downlink,
            hsna_uplink,
            hsna_flexible,
        })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(self.hsna_downlink.is_some());
        optionals.push(self.hsna_uplink.is_some());
        optionals.push(self.hsna_flexible.is_some());
        optionals.push(false);

        aper::encode::encode_sequence_header(data, false, &optionals, false)?;
        if let Some(x) = &self.hsna_downlink {
            x.encode(data)?;
        }
        if let Some(x) = &self.hsna_uplink {
            x.encode(data)?;
        }
        if let Some(x) = &self.hsna_flexible {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl AperCodec for HsnaSlotConfigItem {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        HsnaSlotConfigItem::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("HsnaSlotConfigItem"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("HsnaSlotConfigItem"))
    }
}
// HsnaDownlink
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum HsnaDownlink {
    Hard,
    Soft,
    Notavailable,
}

impl HsnaDownlink {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (idx, extended) = aper::decode::decode_enumerated(data, Some(0), Some(2), false)?;
        if extended {
            return Err(aper::AperCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| AperCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_enumerated(data, Some(0), Some(2), false, *self as i128, false)
    }
}

impl AperCodec for HsnaDownlink {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        HsnaDownlink::decode_inner(data).map_err(|e: AperCodecError| e.push_context("HsnaDownlink"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("HsnaDownlink"))
    }
}
// HsnaFlexible
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum HsnaFlexible {
    Hard,
    Soft,
    Notavailable,
}

impl HsnaFlexible {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (idx, extended) = aper::decode::decode_enumerated(data, Some(0), Some(2), false)?;
        if extended {
            return Err(aper::AperCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| AperCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_enumerated(data, Some(0), Some(2), false, *self as i128, false)
    }
}

impl AperCodec for HsnaFlexible {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        HsnaFlexible::decode_inner(data).map_err(|e: AperCodecError| e.push_context("HsnaFlexible"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("HsnaFlexible"))
    }
}
// HsnaUplink
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum HsnaUplink {
    Hard,
    Soft,
    Notavailable,
}

impl HsnaUplink {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (idx, extended) = aper::decode::decode_enumerated(data, Some(0), Some(2), false)?;
        if extended {
            return Err(aper::AperCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| AperCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_enumerated(data, Some(0), Some(2), false, *self as i128, false)
    }
}

impl AperCodec for HsnaUplink {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        HsnaUplink::decode_inner(data).map_err(|e: AperCodecError| e.push_context("HsnaUplink"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("HsnaUplink"))
    }
}
// HsnaTransmissionPeriodicity
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum HsnaTransmissionPeriodicity {
    Ms0p5,
    Ms0p625,
    Ms1,
    Ms1p25,
    Ms2,
    Ms2p5,
    Ms5,
    Ms10,
    Ms20,
    Ms40,
    Ms80,
    Ms160,
}

impl HsnaTransmissionPeriodicity {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (idx, extended) = aper::decode::decode_enumerated(data, Some(0), Some(11), true)?;
        if extended {
            return Err(aper::AperCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| AperCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_enumerated(data, Some(0), Some(11), true, *self as i128, false)
    }
}

impl AperCodec for HsnaTransmissionPeriodicity {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        HsnaTransmissionPeriodicity::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("HsnaTransmissionPeriodicity"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("HsnaTransmissionPeriodicity"))
    }
}
// IabBarred
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum IabBarred {
    Barred,
    NotBarred,
}

impl IabBarred {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (idx, extended) = aper::decode::decode_enumerated(data, Some(0), Some(1), true)?;
        if extended {
            return Err(aper::AperCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| AperCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_enumerated(data, Some(0), Some(1), true, *self as i128, false)
    }
}

impl AperCodec for IabBarred {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        IabBarred::decode_inner(data).map_err(|e: AperCodecError| e.push_context("IabBarred"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("IabBarred"))
    }
}
// IabInfoIabDonorCu
#[derive(Clone, Debug)]
pub struct IabInfoIabDonorCu {
    pub iab_stc_info: Option<IabStcInfo>,
}

impl IabInfoIabDonorCu {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (optionals, _extensions_present) =
            aper::decode::decode_sequence_header(data, false, 2)?;
        let iab_stc_info = if optionals[0] {
            Some(IabStcInfo::decode(data)?)
        } else {
            None
        };

        Ok(Self { iab_stc_info })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(self.iab_stc_info.is_some());
        optionals.push(false);

        aper::encode::encode_sequence_header(data, false, &optionals, false)?;
        if let Some(x) = &self.iab_stc_info {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl AperCodec for IabInfoIabDonorCu {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        IabInfoIabDonorCu::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("IabInfoIabDonorCu"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("IabInfoIabDonorCu"))
    }
}
// IabInfoIabDu
#[derive(Clone, Debug)]
pub struct IabInfoIabDu {
    pub multiplexing_info: Option<MultiplexingInfo>,
    pub iab_stc_info: Option<IabStcInfo>,
}

impl IabInfoIabDu {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (optionals, _extensions_present) =
            aper::decode::decode_sequence_header(data, false, 3)?;
        let multiplexing_info = if optionals[0] {
            Some(MultiplexingInfo::decode(data)?)
        } else {
            None
        };
        let iab_stc_info = if optionals[1] {
            Some(IabStcInfo::decode(data)?)
        } else {
            None
        };

        Ok(Self {
            multiplexing_info,
            iab_stc_info,
        })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(self.multiplexing_info.is_some());
        optionals.push(self.iab_stc_info.is_some());
        optionals.push(false);

        aper::encode::encode_sequence_header(data, false, &optionals, false)?;
        if let Some(x) = &self.multiplexing_info {
            x.encode(data)?;
        }
        if let Some(x) = &self.iab_stc_info {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl AperCodec for IabInfoIabDu {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        IabInfoIabDu::decode_inner(data).map_err(|e: AperCodecError| e.push_context("IabInfoIabDu"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("IabInfoIabDu"))
    }
}
// IabMtCellList
#[derive(Clone, Debug)]
pub struct IabMtCellList(pub Vec<IabMtCellListItem>);

impl IabMtCellList {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        Ok(Self({
            let length = aper::decode::decode_length_determinent(data, Some(1), Some(32), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(IabMtCellListItem::decode(data)?);
            }
            items
        }))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_length_determinent(data, Some(1), Some(32), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl AperCodec for IabMtCellList {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        IabMtCellList::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("IabMtCellList"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("IabMtCellList"))
    }
}
// IabMtCellListItem
#[derive(Clone, Debug)]
pub struct IabMtCellListItem {
    pub nr_cell_identity: NrCellIdentity,
    pub du_rx_mt_rx: DuRxMtRx,
    pub du_tx_mt_tx: DuTxMtTx,
    pub du_rx_mt_tx: DuRxMtTx,
    pub du_tx_mt_rx: DuTxMtRx,
}

impl IabMtCellListItem {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (_optionals, _extensions_present) =
            aper::decode::decode_sequence_header(data, false, 1)?;
        let nr_cell_identity = NrCellIdentity::decode(data)?;
        let du_rx_mt_rx = DuRxMtRx::decode(data)?;
        let du_tx_mt_tx = DuTxMtTx::decode(data)?;
        let du_rx_mt_tx = DuRxMtTx::decode(data)?;
        let du_tx_mt_rx = DuTxMtRx::decode(data)?;

        Ok(Self {
            nr_cell_identity,
            du_rx_mt_rx,
            du_tx_mt_tx,
            du_rx_mt_tx,
            du_tx_mt_rx,
        })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(false);

        aper::encode::encode_sequence_header(data, false, &optionals, false)?;
        self.nr_cell_identity.encode(data)?;
        self.du_rx_mt_rx.encode(data)?;
        self.du_tx_mt_tx.encode(data)?;
        self.du_rx_mt_tx.encode(data)?;
        self.du_tx_mt_rx.encode(data)?;

        Ok(())
    }
}

impl AperCodec for IabMtCellListItem {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        IabMtCellListItem::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("IabMtCellListItem"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("IabMtCellListItem"))
    }
}
// IabStcInfo
#[derive(Clone, Debug)]
pub struct IabStcInfo {
    pub iab_stc_info_list: IabStcInfoList,
}

impl IabStcInfo {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (_optionals, _extensions_present) =
            aper::decode::decode_sequence_header(data, false, 1)?;
        let iab_stc_info_list = IabStcInfoList::decode(data)?;

        Ok(Self { iab_stc_info_list })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(false);

        aper::encode::encode_sequence_header(data, false, &optionals, false)?;
        self.iab_stc_info_list.encode(data)?;

        Ok(())
    }
}

impl AperCodec for IabStcInfo {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        IabStcInfo::decode_inner(data).map_err(|e: AperCodecError| e.push_context("IabStcInfo"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("IabStcInfo"))
    }
}
// IabStcInfoList
#[derive(Clone, Debug)]
pub struct IabStcInfoList(pub Vec<IabStcInfoItem>);

impl IabStcInfoList {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        Ok(Self({
            let length = aper::decode::decode_length_determinent(data, Some(1), Some(45), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(IabStcInfoItem::decode(data)?);
            }
            items
        }))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_length_determinent(data, Some(1), Some(45), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl AperCodec for IabStcInfoList {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        IabStcInfoList::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("IabStcInfoList"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("IabStcInfoList"))
    }
}
// IabStcInfoItem
#[derive(Clone, Debug)]
pub struct IabStcInfoItem {
    pub ssb_freq_info: SsbFreqInfo,
    pub ssb_subcarrier_spacing: SsbSubcarrierSpacing,
    pub ssb_transmission_periodicity: SsbTransmissionPeriodicity,
    pub ssb_transmission_timing_offset: SsbTransmissionTimingOffset,
    pub ssb_transmission_bitmap: SsbTransmissionBitmap,
}

impl IabStcInfoItem {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (_optionals, _extensions_present) =
            aper::decode::decode_sequence_header(data, false, 1)?;
        let ssb_freq_info = SsbFreqInfo::decode(data)?;
        let ssb_subcarrier_spacing = SsbSubcarrierSpacing::decode(data)?;
        let ssb_transmission_periodicity = SsbTransmissionPeriodicity::decode(data)?;
        let ssb_transmission_timing_offset = SsbTransmissionTimingOffset::decode(data)?;
        let ssb_transmission_bitmap = SsbTransmissionBitmap::decode(data)?;

        Ok(Self {
            ssb_freq_info,
            ssb_subcarrier_spacing,
            ssb_transmission_periodicity,
            ssb_transmission_timing_offset,
            ssb_transmission_bitmap,
        })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(false);

        aper::encode::encode_sequence_header(data, false, &optionals, false)?;
        self.ssb_freq_info.encode(data)?;
        self.ssb_subcarrier_spacing.encode(data)?;
        self.ssb_transmission_periodicity.encode(data)?;
        self.ssb_transmission_timing_offset.encode(data)?;
        self.ssb_transmission_bitmap.encode(data)?;

        Ok(())
    }
}

impl AperCodec for IabStcInfoItem {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        IabStcInfoItem::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("IabStcInfoItem"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("IabStcInfoItem"))
    }
}
// IabAllocatedTnlAddressItem
#[derive(Clone, Debug)]
pub struct IabAllocatedTnlAddressItem {
    pub iabtnl_address: IabtnlAddress,
    pub iabtnl_address_usage: Option<IabtnlAddressUsage>,
}

impl IabAllocatedTnlAddressItem {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (optionals, _extensions_present) =
            aper::decode::decode_sequence_header(data, false, 2)?;
        let iabtnl_address = IabtnlAddress::decode(data)?;
        let iabtnl_address_usage = if optionals[0] {
            Some(IabtnlAddressUsage::decode(data)?)
        } else {
            None
        };

        Ok(Self {
            iabtnl_address,
            iabtnl_address_usage,
        })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(self.iabtnl_address_usage.is_some());
        optionals.push(false);

        aper::encode::encode_sequence_header(data, false, &optionals, false)?;
        self.iabtnl_address.encode(data)?;
        if let Some(x) = &self.iabtnl_address_usage {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl AperCodec for IabAllocatedTnlAddressItem {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        IabAllocatedTnlAddressItem::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("IabAllocatedTnlAddressItem"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("IabAllocatedTnlAddressItem"))
    }
}
// IabDuCellResourceConfigurationModeInfo
#[derive(Clone, Debug)]
pub enum IabDuCellResourceConfigurationModeInfo {
    Fdd(IabDuCellResourceConfigurationFddInfo),
    Tdd(IabDuCellResourceConfigurationTddInfo),
}

impl IabDuCellResourceConfigurationModeInfo {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (idx, extended) = aper::decode::decode_choice_idx(data, 0, 2, false)?;
        if extended {
            return Err(aper::AperCodecError::new(
                "CHOICE additions not implemented",
            ));
        }
        match idx {
            0 => Ok(Self::Fdd(IabDuCellResourceConfigurationFddInfo::decode(
                data,
            )?)),
            1 => Ok(Self::Tdd(IabDuCellResourceConfigurationTddInfo::decode(
                data,
            )?)),
            2 => Err(AperCodecError::new(
                "Choice extension container not implemented",
            )),
            _ => Err(AperCodecError::new("Unknown choice idx")),
        }
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        match self {
            Self::Fdd(x) => {
                aper::encode::encode_choice_idx(data, 0, 2, false, 0, false)?;
                x.encode(data)
            }
            Self::Tdd(x) => {
                aper::encode::encode_choice_idx(data, 0, 2, false, 1, false)?;
                x.encode(data)
            }
        }
    }
}

impl AperCodec for IabDuCellResourceConfigurationModeInfo {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        IabDuCellResourceConfigurationModeInfo::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("IabDuCellResourceConfigurationModeInfo"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("IabDuCellResourceConfigurationModeInfo"))
    }
}
// IabDuCellResourceConfigurationFddInfo
#[derive(Clone, Debug)]
pub struct IabDuCellResourceConfigurationFddInfo {
    pub gnb_du_cell_resource_configuration_fdd_ul: GnbDuCellResourceConfiguration,
    pub gnb_du_cell_resource_configuration_fdd_dl: GnbDuCellResourceConfiguration,
}

impl IabDuCellResourceConfigurationFddInfo {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (_optionals, _extensions_present) =
            aper::decode::decode_sequence_header(data, true, 1)?;
        let gnb_du_cell_resource_configuration_fdd_ul =
            GnbDuCellResourceConfiguration::decode(data)?;
        let gnb_du_cell_resource_configuration_fdd_dl =
            GnbDuCellResourceConfiguration::decode(data)?;

        Ok(Self {
            gnb_du_cell_resource_configuration_fdd_ul,
            gnb_du_cell_resource_configuration_fdd_dl,
        })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(false);

        aper::encode::encode_sequence_header(data, true, &optionals, false)?;
        self.gnb_du_cell_resource_configuration_fdd_ul
            .encode(data)?;
        self.gnb_du_cell_resource_configuration_fdd_dl
            .encode(data)?;

        Ok(())
    }
}

impl AperCodec for IabDuCellResourceConfigurationFddInfo {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        IabDuCellResourceConfigurationFddInfo::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("IabDuCellResourceConfigurationFddInfo"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("IabDuCellResourceConfigurationFddInfo"))
    }
}
// IabDuCellResourceConfigurationTddInfo
#[derive(Clone, Debug)]
pub struct IabDuCellResourceConfigurationTddInfo {
    pub gnb_du_cell_resourc_configuration_tdd: GnbDuCellResourceConfiguration,
}

impl IabDuCellResourceConfigurationTddInfo {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (_optionals, _extensions_present) =
            aper::decode::decode_sequence_header(data, true, 1)?;
        let gnb_du_cell_resourc_configuration_tdd = GnbDuCellResourceConfiguration::decode(data)?;

        Ok(Self {
            gnb_du_cell_resourc_configuration_tdd,
        })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(false);

        aper::encode::encode_sequence_header(data, true, &optionals, false)?;
        self.gnb_du_cell_resourc_configuration_tdd.encode(data)?;

        Ok(())
    }
}

impl AperCodec for IabDuCellResourceConfigurationTddInfo {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        IabDuCellResourceConfigurationTddInfo::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("IabDuCellResourceConfigurationTddInfo"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("IabDuCellResourceConfigurationTddInfo"))
    }
}
// IabiPv6RequestType
#[derive(Clone, Debug)]
pub enum IabiPv6RequestType {
    IPv6Address(IabtnlAddressesRequested),
    IPv6Prefix(IabtnlAddressesRequested),
}

impl IabiPv6RequestType {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (idx, extended) = aper::decode::decode_choice_idx(data, 0, 2, false)?;
        if extended {
            return Err(aper::AperCodecError::new(
                "CHOICE additions not implemented",
            ));
        }
        match idx {
            0 => Ok(Self::IPv6Address(IabtnlAddressesRequested::decode(data)?)),
            1 => Ok(Self::IPv6Prefix(IabtnlAddressesRequested::decode(data)?)),
            2 => Err(AperCodecError::new(
                "Choice extension container not implemented",
            )),
            _ => Err(AperCodecError::new("Unknown choice idx")),
        }
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        match self {
            Self::IPv6Address(x) => {
                aper::encode::encode_choice_idx(data, 0, 2, false, 0, false)?;
                x.encode(data)
            }
            Self::IPv6Prefix(x) => {
                aper::encode::encode_choice_idx(data, 0, 2, false, 1, false)?;
                x.encode(data)
            }
        }
    }
}

impl AperCodec for IabiPv6RequestType {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        IabiPv6RequestType::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("IabiPv6RequestType"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("IabiPv6RequestType"))
    }
}
// IabtnlAddress
#[derive(Clone, Debug)]
pub enum IabtnlAddress {
    IPv4Address(BitString),
    IPv6Address(BitString),
    IPv6Prefix(BitString),
}

impl IabtnlAddress {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (idx, extended) = aper::decode::decode_choice_idx(data, 0, 3, false)?;
        if extended {
            return Err(aper::AperCodecError::new(
                "CHOICE additions not implemented",
            ));
        }
        match idx {
            0 => Ok(Self::IPv4Address(aper::decode::decode_bitstring(
                data,
                Some(32),
                Some(32),
                false,
            )?)),
            1 => Ok(Self::IPv6Address(aper::decode::decode_bitstring(
                data,
                Some(128),
                Some(128),
                false,
            )?)),
            2 => Ok(Self::IPv6Prefix(aper::decode::decode_bitstring(
                data,
                Some(64),
                Some(64),
                false,
            )?)),
            3 => Err(AperCodecError::new(
                "Choice extension container not implemented",
            )),
            _ => Err(AperCodecError::new("Unknown choice idx")),
        }
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        match self {
            Self::IPv4Address(x) => {
                aper::encode::encode_choice_idx(data, 0, 3, false, 0, false)?;
                aper::encode::encode_bitstring(data, Some(32), Some(32), false, &x, false)
            }
            Self::IPv6Address(x) => {
                aper::encode::encode_choice_idx(data, 0, 3, false, 1, false)?;
                aper::encode::encode_bitstring(data, Some(128), Some(128), false, &x, false)
            }
            Self::IPv6Prefix(x) => {
                aper::encode::encode_choice_idx(data, 0, 3, false, 2, false)?;
                aper::encode::encode_bitstring(data, Some(64), Some(64), false, &x, false)
            }
        }
    }
}

impl AperCodec for IabtnlAddress {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        IabtnlAddress::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("IabtnlAddress"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("IabtnlAddress"))
    }
}
// IabtnlAddressesRequested
#[derive(Clone, Debug)]
pub struct IabtnlAddressesRequested {
    pub tnl_addresses_or_prefixes_requested_all_traffic: Option<u16>,
    pub tnl_addresses_or_prefixes_requested_f1_c: Option<u16>,
    pub tnl_addresses_or_prefixes_requested_f1_u: Option<u16>,
    pub tnl_addresses_or_prefixes_requested_no_nf1: Option<u16>,
}

impl IabtnlAddressesRequested {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (optionals, _extensions_present) =
            aper::decode::decode_sequence_header(data, false, 5)?;
        let tnl_addresses_or_prefixes_requested_all_traffic = if optionals[0] {
            Some(aper::decode::decode_integer(data, Some(1), Some(256), false)?.0 as u16)
        } else {
            None
        };
        let tnl_addresses_or_prefixes_requested_f1_c = if optionals[1] {
            Some(aper::decode::decode_integer(data, Some(1), Some(256), false)?.0 as u16)
        } else {
            None
        };
        let tnl_addresses_or_prefixes_requested_f1_u = if optionals[2] {
            Some(aper::decode::decode_integer(data, Some(1), Some(256), false)?.0 as u16)
        } else {
            None
        };
        let tnl_addresses_or_prefixes_requested_no_nf1 = if optionals[3] {
            Some(aper::decode::decode_integer(data, Some(1), Some(256), false)?.0 as u16)
        } else {
            None
        };

        Ok(Self {
            tnl_addresses_or_prefixes_requested_all_traffic,
            tnl_addresses_or_prefixes_requested_f1_c,
            tnl_addresses_or_prefixes_requested_f1_u,
            tnl_addresses_or_prefixes_requested_no_nf1,
        })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(
            self.tnl_addresses_or_prefixes_requested_all_traffic
                .is_some(),
        );
        optionals.push(self.tnl_addresses_or_prefixes_requested_f1_c.is_some());
        optionals.push(self.tnl_addresses_or_prefixes_requested_f1_u.is_some());
        optionals.push(self.tnl_addresses_or_prefixes_requested_no_nf1.is_some());
        optionals.push(false);

        aper::encode::encode_sequence_header(data, false, &optionals, false)?;
        if let Some(x) = &self.tnl_addresses_or_prefixes_requested_all_traffic {
            aper::encode::encode_integer(data, Some(1), Some(256), false, *x as i128, false)?;
        }
        if let Some(x) = &self.tnl_addresses_or_prefixes_requested_f1_c {
            aper::encode::encode_integer(data, Some(1), Some(256), false, *x as i128, false)?;
        }
        if let Some(x) = &self.tnl_addresses_or_prefixes_requested_f1_u {
            aper::encode::encode_integer(data, Some(1), Some(256), false, *x as i128, false)?;
        }
        if let Some(x) = &self.tnl_addresses_or_prefixes_requested_no_nf1 {
            aper::encode::encode_integer(data, Some(1), Some(256), false, *x as i128, false)?;
        }

        Ok(())
    }
}

impl AperCodec for IabtnlAddressesRequested {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        IabtnlAddressesRequested::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("IabtnlAddressesRequested"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("IabtnlAddressesRequested"))
    }
}
// IabTnlAddressesToRemoveItem
#[derive(Clone, Debug)]
pub struct IabTnlAddressesToRemoveItem {
    pub iabtnl_address: IabtnlAddress,
}

impl IabTnlAddressesToRemoveItem {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (_optionals, _extensions_present) =
            aper::decode::decode_sequence_header(data, false, 1)?;
        let iabtnl_address = IabtnlAddress::decode(data)?;

        Ok(Self { iabtnl_address })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(false);

        aper::encode::encode_sequence_header(data, false, &optionals, false)?;
        self.iabtnl_address.encode(data)?;

        Ok(())
    }
}

impl AperCodec for IabTnlAddressesToRemoveItem {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        IabTnlAddressesToRemoveItem::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("IabTnlAddressesToRemoveItem"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("IabTnlAddressesToRemoveItem"))
    }
}
// IabtnlAddressUsage
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum IabtnlAddressUsage {
    F1C,
    F1U,
    NonF1,
}

impl IabtnlAddressUsage {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (idx, extended) = aper::decode::decode_enumerated(data, Some(0), Some(2), true)?;
        if extended {
            return Err(aper::AperCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| AperCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_enumerated(data, Some(0), Some(2), true, *self as i128, false)
    }
}

impl AperCodec for IabtnlAddressUsage {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        IabtnlAddressUsage::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("IabtnlAddressUsage"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("IabtnlAddressUsage"))
    }
}
// IaBv4AddressesRequested
#[derive(Clone, Debug)]
pub struct IaBv4AddressesRequested {
    pub ia_bv_4_addresses_requested: IabtnlAddressesRequested,
}

impl IaBv4AddressesRequested {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (_optionals, _extensions_present) =
            aper::decode::decode_sequence_header(data, false, 1)?;
        let ia_bv_4_addresses_requested = IabtnlAddressesRequested::decode(data)?;

        Ok(Self {
            ia_bv_4_addresses_requested,
        })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(false);

        aper::encode::encode_sequence_header(data, false, &optionals, false)?;
        self.ia_bv_4_addresses_requested.encode(data)?;

        Ok(())
    }
}

impl AperCodec for IaBv4AddressesRequested {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        IaBv4AddressesRequested::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("IaBv4AddressesRequested"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("IaBv4AddressesRequested"))
    }
}
// ImplicitFormat
#[derive(Clone, Debug)]
pub struct ImplicitFormat {
    pub duf_slotformat_index: DufSlotformatIndex,
}

impl ImplicitFormat {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (_optionals, _extensions_present) =
            aper::decode::decode_sequence_header(data, false, 1)?;
        let duf_slotformat_index = DufSlotformatIndex::decode(data)?;

        Ok(Self {
            duf_slotformat_index,
        })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(false);

        aper::encode::encode_sequence_header(data, false, &optionals, false)?;
        self.duf_slotformat_index.encode(data)?;

        Ok(())
    }
}

impl AperCodec for ImplicitFormat {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        ImplicitFormat::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("ImplicitFormat"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("ImplicitFormat"))
    }
}
// IgnorePrachConfiguration
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum IgnorePrachConfiguration {
    True,
}

impl IgnorePrachConfiguration {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (idx, extended) = aper::decode::decode_enumerated(data, Some(0), Some(0), true)?;
        if extended {
            return Err(aper::AperCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| AperCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_enumerated(data, Some(0), Some(0), true, *self as i128, false)
    }
}

impl AperCodec for IgnorePrachConfiguration {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        IgnorePrachConfiguration::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("IgnorePrachConfiguration"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("IgnorePrachConfiguration"))
    }
}
// IgnoreResourceCoordinationContainer
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum IgnoreResourceCoordinationContainer {
    Yes,
}

impl IgnoreResourceCoordinationContainer {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (idx, extended) = aper::decode::decode_enumerated(data, Some(0), Some(0), true)?;
        if extended {
            return Err(aper::AperCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| AperCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_enumerated(data, Some(0), Some(0), true, *self as i128, false)
    }
}

impl AperCodec for IgnoreResourceCoordinationContainer {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        IgnoreResourceCoordinationContainer::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("IgnoreResourceCoordinationContainer"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("IgnoreResourceCoordinationContainer"))
    }
}
// InactivityMonitoringRequest
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum InactivityMonitoringRequest {
    True,
}

impl InactivityMonitoringRequest {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (idx, extended) = aper::decode::decode_enumerated(data, Some(0), Some(0), true)?;
        if extended {
            return Err(aper::AperCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| AperCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_enumerated(data, Some(0), Some(0), true, *self as i128, false)
    }
}

impl AperCodec for InactivityMonitoringRequest {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        InactivityMonitoringRequest::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("InactivityMonitoringRequest"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("InactivityMonitoringRequest"))
    }
}
// InactivityMonitoringResponse
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum InactivityMonitoringResponse {
    NotSupported,
}

impl InactivityMonitoringResponse {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (idx, extended) = aper::decode::decode_enumerated(data, Some(0), Some(0), true)?;
        if extended {
            return Err(aper::AperCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| AperCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_enumerated(data, Some(0), Some(0), true, *self as i128, false)
    }
}

impl AperCodec for InactivityMonitoringResponse {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        InactivityMonitoringResponse::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("InactivityMonitoringResponse"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("InactivityMonitoringResponse"))
    }
}
// InterfacesToTrace
#[derive(Clone, Debug)]
pub struct InterfacesToTrace(pub BitString);

impl InterfacesToTrace {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        Ok(Self(aper::decode::decode_bitstring(
            data,
            Some(8),
            Some(8),
            false,
        )?))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_bitstring(data, Some(8), Some(8), false, &self.0, false)
    }
}

impl AperCodec for InterfacesToTrace {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        InterfacesToTrace::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("InterfacesToTrace"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("InterfacesToTrace"))
    }
}
// IntendedTddDlUlConfig
#[derive(Clone, Debug)]
pub struct IntendedTddDlUlConfig {
    pub nrscs: Nrscs1,
    pub nrcp: Nrcp,
    pub nrdlul_tx_periodicity: NrdlulTxPeriodicity,
    pub slot_configuration_list: SlotConfigurationList,
}

impl IntendedTddDlUlConfig {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (_optionals, _extensions_present) =
            aper::decode::decode_sequence_header(data, false, 1)?;
        let nrscs = Nrscs1::decode(data)?;
        let nrcp = Nrcp::decode(data)?;
        let nrdlul_tx_periodicity = NrdlulTxPeriodicity::decode(data)?;
        let slot_configuration_list = SlotConfigurationList::decode(data)?;

        Ok(Self {
            nrscs,
            nrcp,
            nrdlul_tx_periodicity,
            slot_configuration_list,
        })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(false);

        aper::encode::encode_sequence_header(data, false, &optionals, false)?;
        self.nrscs.encode(data)?;
        self.nrcp.encode(data)?;
        self.nrdlul_tx_periodicity.encode(data)?;
        self.slot_configuration_list.encode(data)?;

        Ok(())
    }
}

impl AperCodec for IntendedTddDlUlConfig {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        IntendedTddDlUlConfig::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("IntendedTddDlUlConfig"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("IntendedTddDlUlConfig"))
    }
}
// IpHeaderInformation
#[derive(Clone, Debug)]
pub struct IpHeaderInformation {
    pub destination_iabtnl_address: IabtnlAddress,
    pub ds_information_list: Option<DsInformationList>,
    pub i_pv_6_flow_label: Option<BitString>,
}

impl IpHeaderInformation {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (optionals, _extensions_present) = aper::decode::decode_sequence_header(data, true, 3)?;
        let destination_iabtnl_address = IabtnlAddress::decode(data)?;
        let ds_information_list = if optionals[0] {
            Some(DsInformationList::decode(data)?)
        } else {
            None
        };
        let i_pv_6_flow_label = if optionals[1] {
            Some(aper::decode::decode_bitstring(
                data,
                Some(20),
                Some(20),
                false,
            )?)
        } else {
            None
        };

        Ok(Self {
            destination_iabtnl_address,
            ds_information_list,
            i_pv_6_flow_label,
        })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(self.ds_information_list.is_some());
        optionals.push(self.i_pv_6_flow_label.is_some());
        optionals.push(false);

        aper::encode::encode_sequence_header(data, true, &optionals, false)?;
        self.destination_iabtnl_address.encode(data)?;
        if let Some(x) = &self.ds_information_list {
            x.encode(data)?;
        }
        if let Some(x) = &self.i_pv_6_flow_label {
            aper::encode::encode_bitstring(data, Some(20), Some(20), false, &x, false)?;
        }

        Ok(())
    }
}

impl AperCodec for IpHeaderInformation {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        IpHeaderInformation::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("IpHeaderInformation"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("IpHeaderInformation"))
    }
}
// IPtolayer2TrafficMappingInfo
#[derive(Clone, Debug)]
pub struct IPtolayer2TrafficMappingInfo {
    pub i_ptolayer_2_traffic_mapping_info_to_add: Option<IPtolayer2TrafficMappingInfoList>,
    pub i_ptolayer_2_traffic_mapping_info_to_remove: Option<MappingInformationtoRemove>,
}

impl IPtolayer2TrafficMappingInfo {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (optionals, _extensions_present) = aper::decode::decode_sequence_header(data, true, 3)?;
        let i_ptolayer_2_traffic_mapping_info_to_add = if optionals[0] {
            Some(IPtolayer2TrafficMappingInfoList::decode(data)?)
        } else {
            None
        };
        let i_ptolayer_2_traffic_mapping_info_to_remove = if optionals[1] {
            Some(MappingInformationtoRemove::decode(data)?)
        } else {
            None
        };

        Ok(Self {
            i_ptolayer_2_traffic_mapping_info_to_add,
            i_ptolayer_2_traffic_mapping_info_to_remove,
        })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(self.i_ptolayer_2_traffic_mapping_info_to_add.is_some());
        optionals.push(self.i_ptolayer_2_traffic_mapping_info_to_remove.is_some());
        optionals.push(false);

        aper::encode::encode_sequence_header(data, true, &optionals, false)?;
        if let Some(x) = &self.i_ptolayer_2_traffic_mapping_info_to_add {
            x.encode(data)?;
        }
        if let Some(x) = &self.i_ptolayer_2_traffic_mapping_info_to_remove {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl AperCodec for IPtolayer2TrafficMappingInfo {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        IPtolayer2TrafficMappingInfo::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("IPtolayer2TrafficMappingInfo"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("IPtolayer2TrafficMappingInfo"))
    }
}
// IPtolayer2TrafficMappingInfoList
#[derive(Clone, Debug)]
pub struct IPtolayer2TrafficMappingInfoList(pub Vec<IPtolayer2TrafficMappingInfoItem>);

impl IPtolayer2TrafficMappingInfoList {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        Ok(Self({
            let length =
                aper::decode::decode_length_determinent(data, Some(1), Some(67108864), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(IPtolayer2TrafficMappingInfoItem::decode(data)?);
            }
            items
        }))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_length_determinent(
            data,
            Some(1),
            Some(67108864),
            false,
            self.0.len(),
        )?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl AperCodec for IPtolayer2TrafficMappingInfoList {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        IPtolayer2TrafficMappingInfoList::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("IPtolayer2TrafficMappingInfoList"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("IPtolayer2TrafficMappingInfoList"))
    }
}
// IPtolayer2TrafficMappingInfoItem
#[derive(Clone, Debug)]
pub struct IPtolayer2TrafficMappingInfoItem {
    pub mapping_information_index: MappingInformationIndex,
    pub ip_header_information: IpHeaderInformation,
    pub bh_info: BhInfo,
}

impl IPtolayer2TrafficMappingInfoItem {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (_optionals, _extensions_present) =
            aper::decode::decode_sequence_header(data, true, 1)?;
        let mapping_information_index = MappingInformationIndex::decode(data)?;
        let ip_header_information = IpHeaderInformation::decode(data)?;
        let bh_info = BhInfo::decode(data)?;

        Ok(Self {
            mapping_information_index,
            ip_header_information,
            bh_info,
        })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(false);

        aper::encode::encode_sequence_header(data, true, &optionals, false)?;
        self.mapping_information_index.encode(data)?;
        self.ip_header_information.encode(data)?;
        self.bh_info.encode(data)?;

        Ok(())
    }
}

impl AperCodec for IPtolayer2TrafficMappingInfoItem {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        IPtolayer2TrafficMappingInfoItem::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("IPtolayer2TrafficMappingInfoItem"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("IPtolayer2TrafficMappingInfoItem"))
    }
}
// L139Info
#[derive(Clone, Debug)]
pub struct L139Info {
    pub msg_1scs: Msg1scs,
    pub root_sequence_index: Option<u8>,
}

impl L139Info {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (optionals, _extensions_present) = aper::decode::decode_sequence_header(data, true, 2)?;
        let msg_1scs = Msg1scs::decode(data)?;
        let root_sequence_index = if optionals[0] {
            Some(aper::decode::decode_integer(data, Some(0), Some(137), false)?.0 as u8)
        } else {
            None
        };

        Ok(Self {
            msg_1scs,
            root_sequence_index,
        })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(self.root_sequence_index.is_some());
        optionals.push(false);

        aper::encode::encode_sequence_header(data, true, &optionals, false)?;
        self.msg_1scs.encode(data)?;
        if let Some(x) = &self.root_sequence_index {
            aper::encode::encode_integer(data, Some(0), Some(137), false, *x as i128, false)?;
        }

        Ok(())
    }
}

impl AperCodec for L139Info {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        L139Info::decode_inner(data).map_err(|e: AperCodecError| e.push_context("L139Info"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("L139Info"))
    }
}
// L839Info
#[derive(Clone, Debug)]
pub struct L839Info {
    pub root_sequence_index: u16,
    pub restricted_set_config: RestrictedSetConfig,
}

impl L839Info {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (_optionals, _extensions_present) =
            aper::decode::decode_sequence_header(data, true, 1)?;
        let root_sequence_index =
            aper::decode::decode_integer(data, Some(0), Some(837), false)?.0 as u16;
        let restricted_set_config = RestrictedSetConfig::decode(data)?;

        Ok(Self {
            root_sequence_index,
            restricted_set_config,
        })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(false);

        aper::encode::encode_sequence_header(data, true, &optionals, false)?;
        aper::encode::encode_integer(
            data,
            Some(0),
            Some(837),
            false,
            self.root_sequence_index as i128,
            false,
        )?;
        self.restricted_set_config.encode(data)?;

        Ok(())
    }
}

impl AperCodec for L839Info {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        L839Info::decode_inner(data).map_err(|e: AperCodecError| e.push_context("L839Info"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("L839Info"))
    }
}
// Lcid
#[derive(Clone, Debug)]
pub struct Lcid(pub u8);

impl Lcid {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        Ok(Self(
            aper::decode::decode_integer(data, Some(1), Some(32), true)?.0 as u8,
        ))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_integer(data, Some(1), Some(32), true, self.0 as i128, false)
    }
}

impl AperCodec for Lcid {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        Lcid::decode_inner(data).map_err(|e: AperCodecError| e.push_context("Lcid"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("Lcid"))
    }
}
// LcsToGcsTranslationAoA
#[derive(Clone, Debug)]
pub struct LcsToGcsTranslationAoA {
    pub alpha: u16,
    pub beta: u16,
    pub gamma: u16,
}

impl LcsToGcsTranslationAoA {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (_optionals, _extensions_present) =
            aper::decode::decode_sequence_header(data, true, 1)?;
        let alpha = aper::decode::decode_integer(data, Some(0), Some(3599), false)?.0 as u16;
        let beta = aper::decode::decode_integer(data, Some(0), Some(3599), false)?.0 as u16;
        let gamma = aper::decode::decode_integer(data, Some(0), Some(3599), false)?.0 as u16;

        Ok(Self { alpha, beta, gamma })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(false);

        aper::encode::encode_sequence_header(data, true, &optionals, false)?;
        aper::encode::encode_integer(data, Some(0), Some(3599), false, self.alpha as i128, false)?;
        aper::encode::encode_integer(data, Some(0), Some(3599), false, self.beta as i128, false)?;
        aper::encode::encode_integer(data, Some(0), Some(3599), false, self.gamma as i128, false)?;

        Ok(())
    }
}

impl AperCodec for LcsToGcsTranslationAoA {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        LcsToGcsTranslationAoA::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("LcsToGcsTranslationAoA"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("LcsToGcsTranslationAoA"))
    }
}
// LcStoGcsTranslationList
#[derive(Clone, Debug)]
pub struct LcStoGcsTranslationList(pub Vec<LcStoGcsTranslation>);

impl LcStoGcsTranslationList {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        Ok(Self({
            let length = aper::decode::decode_length_determinent(data, Some(1), Some(3), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(LcStoGcsTranslation::decode(data)?);
            }
            items
        }))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_length_determinent(data, Some(1), Some(3), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl AperCodec for LcStoGcsTranslationList {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        LcStoGcsTranslationList::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("LcStoGcsTranslationList"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("LcStoGcsTranslationList"))
    }
}
// LcStoGcsTranslation
#[derive(Clone, Debug)]
pub struct LcStoGcsTranslation {
    pub alpha: u16,
    pub alpha_fine: Option<u8>,
    pub beta: u16,
    pub beta_fine: Option<u8>,
    pub gamma: u16,
    pub gamma_fine: Option<u8>,
}

impl LcStoGcsTranslation {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (optionals, _extensions_present) =
            aper::decode::decode_sequence_header(data, false, 4)?;
        let alpha = aper::decode::decode_integer(data, Some(0), Some(359), false)?.0 as u16;
        let alpha_fine = if optionals[0] {
            Some(aper::decode::decode_integer(data, Some(0), Some(9), false)?.0 as u8)
        } else {
            None
        };
        let beta = aper::decode::decode_integer(data, Some(0), Some(359), false)?.0 as u16;
        let beta_fine = if optionals[1] {
            Some(aper::decode::decode_integer(data, Some(0), Some(9), false)?.0 as u8)
        } else {
            None
        };
        let gamma = aper::decode::decode_integer(data, Some(0), Some(359), false)?.0 as u16;
        let gamma_fine = if optionals[2] {
            Some(aper::decode::decode_integer(data, Some(0), Some(9), false)?.0 as u8)
        } else {
            None
        };

        Ok(Self {
            alpha,
            alpha_fine,
            beta,
            beta_fine,
            gamma,
            gamma_fine,
        })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(self.alpha_fine.is_some());
        optionals.push(self.beta_fine.is_some());
        optionals.push(self.gamma_fine.is_some());
        optionals.push(false);

        aper::encode::encode_sequence_header(data, false, &optionals, false)?;
        aper::encode::encode_integer(data, Some(0), Some(359), false, self.alpha as i128, false)?;
        if let Some(x) = &self.alpha_fine {
            aper::encode::encode_integer(data, Some(0), Some(9), false, *x as i128, false)?;
        }
        aper::encode::encode_integer(data, Some(0), Some(359), false, self.beta as i128, false)?;
        if let Some(x) = &self.beta_fine {
            aper::encode::encode_integer(data, Some(0), Some(9), false, *x as i128, false)?;
        }
        aper::encode::encode_integer(data, Some(0), Some(359), false, self.gamma as i128, false)?;
        if let Some(x) = &self.gamma_fine {
            aper::encode::encode_integer(data, Some(0), Some(9), false, *x as i128, false)?;
        }

        Ok(())
    }
}

impl AperCodec for LcStoGcsTranslation {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        LcStoGcsTranslation::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("LcStoGcsTranslation"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("LcStoGcsTranslation"))
    }
}
// LmfMeasurementId
#[derive(Clone, Debug)]
pub struct LmfMeasurementId(pub u32);

impl LmfMeasurementId {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        Ok(Self(
            aper::decode::decode_integer(data, Some(1), Some(65536), true)?.0 as u32,
        ))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_integer(data, Some(1), Some(65536), true, self.0 as i128, false)
    }
}

impl AperCodec for LmfMeasurementId {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        LmfMeasurementId::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("LmfMeasurementId"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("LmfMeasurementId"))
    }
}
// LmfUeMeasurementId
#[derive(Clone, Debug)]
pub struct LmfUeMeasurementId(pub u16);

impl LmfUeMeasurementId {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        Ok(Self(
            aper::decode::decode_integer(data, Some(1), Some(256), true)?.0 as u16,
        ))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_integer(data, Some(1), Some(256), true, self.0 as i128, false)
    }
}

impl AperCodec for LmfUeMeasurementId {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        LmfUeMeasurementId::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("LmfUeMeasurementId"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("LmfUeMeasurementId"))
    }
}
// LocationUncertainty
#[derive(Clone, Debug)]
pub struct LocationUncertainty {
    pub horizontal_uncertainty: u8,
    pub horizontal_confidence: u8,
    pub vertical_uncertainty: u8,
    pub vertical_confidence: u8,
}

impl LocationUncertainty {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (_optionals, _extensions_present) =
            aper::decode::decode_sequence_header(data, false, 1)?;
        let horizontal_uncertainty =
            aper::decode::decode_integer(data, Some(0), Some(255), false)?.0 as u8;
        let horizontal_confidence =
            aper::decode::decode_integer(data, Some(0), Some(100), false)?.0 as u8;
        let vertical_uncertainty =
            aper::decode::decode_integer(data, Some(0), Some(255), false)?.0 as u8;
        let vertical_confidence =
            aper::decode::decode_integer(data, Some(0), Some(100), false)?.0 as u8;

        Ok(Self {
            horizontal_uncertainty,
            horizontal_confidence,
            vertical_uncertainty,
            vertical_confidence,
        })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(false);

        aper::encode::encode_sequence_header(data, false, &optionals, false)?;
        aper::encode::encode_integer(
            data,
            Some(0),
            Some(255),
            false,
            self.horizontal_uncertainty as i128,
            false,
        )?;
        aper::encode::encode_integer(
            data,
            Some(0),
            Some(100),
            false,
            self.horizontal_confidence as i128,
            false,
        )?;
        aper::encode::encode_integer(
            data,
            Some(0),
            Some(255),
            false,
            self.vertical_uncertainty as i128,
            false,
        )?;
        aper::encode::encode_integer(
            data,
            Some(0),
            Some(100),
            false,
            self.vertical_confidence as i128,
            false,
        )?;

        Ok(())
    }
}

impl AperCodec for LocationUncertainty {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        LocationUncertainty::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("LocationUncertainty"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("LocationUncertainty"))
    }
}
// LongDrxCycleLength
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum LongDrxCycleLength {
    Ms10,
    Ms20,
    Ms32,
    Ms40,
    Ms60,
    Ms64,
    Ms70,
    Ms80,
    Ms128,
    Ms160,
    Ms256,
    Ms320,
    Ms512,
    Ms640,
    Ms1024,
    Ms1280,
    Ms2048,
    Ms2560,
    Ms5120,
    Ms10240,
}

impl LongDrxCycleLength {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (idx, extended) = aper::decode::decode_enumerated(data, Some(0), Some(19), true)?;
        if extended {
            return Err(aper::AperCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| AperCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_enumerated(data, Some(0), Some(19), true, *self as i128, false)
    }
}

impl AperCodec for LongDrxCycleLength {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        LongDrxCycleLength::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("LongDrxCycleLength"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("LongDrxCycleLength"))
    }
}
// LowerLayerPresenceStatusChange
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum LowerLayerPresenceStatusChange {
    SuspendLowerLayers,
    ResumeLowerLayers,
}

impl LowerLayerPresenceStatusChange {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (idx, extended) = aper::decode::decode_enumerated(data, Some(0), Some(1), true)?;
        if extended {
            return Err(aper::AperCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| AperCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_enumerated(data, Some(0), Some(1), true, *self as i128, false)
    }
}

impl AperCodec for LowerLayerPresenceStatusChange {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        LowerLayerPresenceStatusChange::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("LowerLayerPresenceStatusChange"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("LowerLayerPresenceStatusChange"))
    }
}
// LteueSidelinkAggregateMaximumBitrate
#[derive(Clone, Debug)]
pub struct LteueSidelinkAggregateMaximumBitrate {
    pub uelte_sidelink_aggregate_maximum_bitrate: BitRate,
}

impl LteueSidelinkAggregateMaximumBitrate {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (_optionals, _extensions_present) =
            aper::decode::decode_sequence_header(data, false, 1)?;
        let uelte_sidelink_aggregate_maximum_bitrate = BitRate::decode(data)?;

        Ok(Self {
            uelte_sidelink_aggregate_maximum_bitrate,
        })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(false);

        aper::encode::encode_sequence_header(data, false, &optionals, false)?;
        self.uelte_sidelink_aggregate_maximum_bitrate.encode(data)?;

        Ok(())
    }
}

impl AperCodec for LteueSidelinkAggregateMaximumBitrate {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        LteueSidelinkAggregateMaximumBitrate::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("LteueSidelinkAggregateMaximumBitrate"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("LteueSidelinkAggregateMaximumBitrate"))
    }
}
// Ltev2xServicesAuthorized
#[derive(Clone, Debug)]
pub struct Ltev2xServicesAuthorized {
    pub vehicle_ue: Option<VehicleUe>,
    pub pedestrian_ue: Option<PedestrianUe>,
}

impl Ltev2xServicesAuthorized {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (optionals, _extensions_present) =
            aper::decode::decode_sequence_header(data, false, 3)?;
        let vehicle_ue = if optionals[0] {
            Some(VehicleUe::decode(data)?)
        } else {
            None
        };
        let pedestrian_ue = if optionals[1] {
            Some(PedestrianUe::decode(data)?)
        } else {
            None
        };

        Ok(Self {
            vehicle_ue,
            pedestrian_ue,
        })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(self.vehicle_ue.is_some());
        optionals.push(self.pedestrian_ue.is_some());
        optionals.push(false);

        aper::encode::encode_sequence_header(data, false, &optionals, false)?;
        if let Some(x) = &self.vehicle_ue {
            x.encode(data)?;
        }
        if let Some(x) = &self.pedestrian_ue {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl AperCodec for Ltev2xServicesAuthorized {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        Ltev2xServicesAuthorized::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("Ltev2xServicesAuthorized"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("Ltev2xServicesAuthorized"))
    }
}
// MappingInformationIndex
#[derive(Clone, Debug)]
pub struct MappingInformationIndex(pub BitString);

impl MappingInformationIndex {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        Ok(Self(aper::decode::decode_bitstring(
            data,
            Some(26),
            Some(26),
            false,
        )?))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_bitstring(data, Some(26), Some(26), false, &self.0, false)
    }
}

impl AperCodec for MappingInformationIndex {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        MappingInformationIndex::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("MappingInformationIndex"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("MappingInformationIndex"))
    }
}
// MappingInformationtoRemove
#[derive(Clone, Debug)]
pub struct MappingInformationtoRemove(pub Vec<MappingInformationIndex>);

impl MappingInformationtoRemove {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        Ok(Self({
            let length =
                aper::decode::decode_length_determinent(data, Some(1), Some(67108864), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(MappingInformationIndex::decode(data)?);
            }
            items
        }))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_length_determinent(
            data,
            Some(1),
            Some(67108864),
            false,
            self.0.len(),
        )?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl AperCodec for MappingInformationtoRemove {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        MappingInformationtoRemove::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("MappingInformationtoRemove"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("MappingInformationtoRemove"))
    }
}
// MaskedImeisv
#[derive(Clone, Debug)]
pub struct MaskedImeisv(pub BitString);

impl MaskedImeisv {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        Ok(Self(aper::decode::decode_bitstring(
            data,
            Some(64),
            Some(64),
            false,
        )?))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_bitstring(data, Some(64), Some(64), false, &self.0, false)
    }
}

impl AperCodec for MaskedImeisv {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        MaskedImeisv::decode_inner(data).map_err(|e: AperCodecError| e.push_context("MaskedImeisv"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("MaskedImeisv"))
    }
}
// MaxDataBurstVolume
#[derive(Clone, Debug)]
pub struct MaxDataBurstVolume(pub i128);

impl MaxDataBurstVolume {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        Ok(Self(
            aper::decode::decode_integer(data, Some(0), Some(4095), true)?.0,
        ))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_integer(data, Some(0), Some(4095), true, self.0, false)
    }
}

impl AperCodec for MaxDataBurstVolume {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        MaxDataBurstVolume::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("MaxDataBurstVolume"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("MaxDataBurstVolume"))
    }
}
// MaxPacketLossRate
#[derive(Clone, Debug)]
pub struct MaxPacketLossRate(pub u16);

impl MaxPacketLossRate {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        Ok(Self(
            aper::decode::decode_integer(data, Some(0), Some(1000), false)?.0 as u16,
        ))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_integer(data, Some(0), Some(1000), false, self.0 as i128, false)
    }
}

impl AperCodec for MaxPacketLossRate {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        MaxPacketLossRate::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("MaxPacketLossRate"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("MaxPacketLossRate"))
    }
}
// MibMessage
#[derive(Clone, Debug)]
pub struct MibMessage(pub Vec<u8>);

impl MibMessage {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        Ok(Self(aper::decode::decode_octetstring(
            data, None, None, false,
        )?))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_octetstring(data, None, None, false, &self.0, false)
    }
}

impl AperCodec for MibMessage {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        MibMessage::decode_inner(data).map_err(|e: AperCodecError| e.push_context("MibMessage"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("MibMessage"))
    }
}
// MeasConfig
#[derive(Clone, Debug)]
pub struct MeasConfig(pub Vec<u8>);

impl MeasConfig {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        Ok(Self(aper::decode::decode_octetstring(
            data, None, None, false,
        )?))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_octetstring(data, None, None, false, &self.0, false)
    }
}

impl AperCodec for MeasConfig {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        MeasConfig::decode_inner(data).map_err(|e: AperCodecError| e.push_context("MeasConfig"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("MeasConfig"))
    }
}
// MeasGapConfig
#[derive(Clone, Debug)]
pub struct MeasGapConfig(pub Vec<u8>);

impl MeasGapConfig {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        Ok(Self(aper::decode::decode_octetstring(
            data, None, None, false,
        )?))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_octetstring(data, None, None, false, &self.0, false)
    }
}

impl AperCodec for MeasGapConfig {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        MeasGapConfig::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("MeasGapConfig"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("MeasGapConfig"))
    }
}
// MeasGapSharingConfig
#[derive(Clone, Debug)]
pub struct MeasGapSharingConfig(pub Vec<u8>);

impl MeasGapSharingConfig {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        Ok(Self(aper::decode::decode_octetstring(
            data, None, None, false,
        )?))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_octetstring(data, None, None, false, &self.0, false)
    }
}

impl AperCodec for MeasGapSharingConfig {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        MeasGapSharingConfig::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("MeasGapSharingConfig"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("MeasGapSharingConfig"))
    }
}
// MeasurementBeamInfoRequest
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum MeasurementBeamInfoRequest {
    True,
}

impl MeasurementBeamInfoRequest {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (idx, extended) = aper::decode::decode_enumerated(data, Some(0), Some(0), true)?;
        if extended {
            return Err(aper::AperCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| AperCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_enumerated(data, Some(0), Some(0), true, *self as i128, false)
    }
}

impl AperCodec for MeasurementBeamInfoRequest {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        MeasurementBeamInfoRequest::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("MeasurementBeamInfoRequest"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("MeasurementBeamInfoRequest"))
    }
}
// MeasurementBeamInfo
#[derive(Clone, Debug)]
pub struct MeasurementBeamInfo {
    pub prs_resource_id: Option<PrsResourceId>,
    pub prs_resource_set_id: Option<PrsResourceSetId>,
    pub ssb_index: Option<SsbIndex>,
}

impl MeasurementBeamInfo {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (optionals, _extensions_present) =
            aper::decode::decode_sequence_header(data, false, 4)?;
        let prs_resource_id = if optionals[0] {
            Some(PrsResourceId::decode(data)?)
        } else {
            None
        };
        let prs_resource_set_id = if optionals[1] {
            Some(PrsResourceSetId::decode(data)?)
        } else {
            None
        };
        let ssb_index = if optionals[2] {
            Some(SsbIndex::decode(data)?)
        } else {
            None
        };

        Ok(Self {
            prs_resource_id,
            prs_resource_set_id,
            ssb_index,
        })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(self.prs_resource_id.is_some());
        optionals.push(self.prs_resource_set_id.is_some());
        optionals.push(self.ssb_index.is_some());
        optionals.push(false);

        aper::encode::encode_sequence_header(data, false, &optionals, false)?;
        if let Some(x) = &self.prs_resource_id {
            x.encode(data)?;
        }
        if let Some(x) = &self.prs_resource_set_id {
            x.encode(data)?;
        }
        if let Some(x) = &self.ssb_index {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl AperCodec for MeasurementBeamInfo {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        MeasurementBeamInfo::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("MeasurementBeamInfo"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("MeasurementBeamInfo"))
    }
}
// MeasurementTimingConfiguration
#[derive(Clone, Debug)]
pub struct MeasurementTimingConfiguration(pub Vec<u8>);

impl MeasurementTimingConfiguration {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        Ok(Self(aper::decode::decode_octetstring(
            data, None, None, false,
        )?))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_octetstring(data, None, None, false, &self.0, false)
    }
}

impl AperCodec for MeasurementTimingConfiguration {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        MeasurementTimingConfiguration::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("MeasurementTimingConfiguration"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("MeasurementTimingConfiguration"))
    }
}
// MessageIdentifier
#[derive(Clone, Debug)]
pub struct MessageIdentifier(pub BitString);

impl MessageIdentifier {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        Ok(Self(aper::decode::decode_bitstring(
            data,
            Some(16),
            Some(16),
            false,
        )?))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_bitstring(data, Some(16), Some(16), false, &self.0, false)
    }
}

impl AperCodec for MessageIdentifier {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        MessageIdentifier::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("MessageIdentifier"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("MessageIdentifier"))
    }
}
// MultiplexingInfo
#[derive(Clone, Debug)]
pub struct MultiplexingInfo {
    pub iab_mt_cell_list: IabMtCellList,
}

impl MultiplexingInfo {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (_optionals, _extensions_present) =
            aper::decode::decode_sequence_header(data, false, 1)?;
        let iab_mt_cell_list = IabMtCellList::decode(data)?;

        Ok(Self { iab_mt_cell_list })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(false);

        aper::encode::encode_sequence_header(data, false, &optionals, false)?;
        self.iab_mt_cell_list.encode(data)?;

        Ok(())
    }
}

impl AperCodec for MultiplexingInfo {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        MultiplexingInfo::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("MultiplexingInfo"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("MultiplexingInfo"))
    }
}
// M2Configuration
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum M2Configuration {
    True,
}

impl M2Configuration {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (idx, extended) = aper::decode::decode_enumerated(data, Some(0), Some(0), true)?;
        if extended {
            return Err(aper::AperCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| AperCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_enumerated(data, Some(0), Some(0), true, *self as i128, false)
    }
}

impl AperCodec for M2Configuration {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        M2Configuration::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("M2Configuration"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("M2Configuration"))
    }
}
// M5Configuration
#[derive(Clone, Debug)]
pub struct M5Configuration {
    pub m5period: M5period,
    pub m5_links_to_log: M5LinksToLog,
}

impl M5Configuration {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (_optionals, _extensions_present) =
            aper::decode::decode_sequence_header(data, true, 1)?;
        let m5period = M5period::decode(data)?;
        let m5_links_to_log = M5LinksToLog::decode(data)?;

        Ok(Self {
            m5period,
            m5_links_to_log,
        })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(false);

        aper::encode::encode_sequence_header(data, true, &optionals, false)?;
        self.m5period.encode(data)?;
        self.m5_links_to_log.encode(data)?;

        Ok(())
    }
}

impl AperCodec for M5Configuration {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        M5Configuration::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("M5Configuration"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("M5Configuration"))
    }
}
// M5period
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum M5period {
    Ms1024,
    Ms2048,
    Ms5120,
    Ms10240,
    Min1,
}

impl M5period {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (idx, extended) = aper::decode::decode_enumerated(data, Some(0), Some(4), true)?;
        if extended {
            return Err(aper::AperCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| AperCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_enumerated(data, Some(0), Some(4), true, *self as i128, false)
    }
}

impl AperCodec for M5period {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        M5period::decode_inner(data).map_err(|e: AperCodecError| e.push_context("M5period"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("M5period"))
    }
}
// M5LinksToLog
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum M5LinksToLog {
    Uplink,
    Downlink,
    BothUplinkAndDownlink,
}

impl M5LinksToLog {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (idx, extended) = aper::decode::decode_enumerated(data, Some(0), Some(2), true)?;
        if extended {
            return Err(aper::AperCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| AperCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_enumerated(data, Some(0), Some(2), true, *self as i128, false)
    }
}

impl AperCodec for M5LinksToLog {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        M5LinksToLog::decode_inner(data).map_err(|e: AperCodecError| e.push_context("M5LinksToLog"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("M5LinksToLog"))
    }
}
// M6Configuration
#[derive(Clone, Debug)]
pub struct M6Configuration {
    pub m6report_interval: M6reportInterval,
    pub m6_links_to_log: M6LinksToLog,
}

impl M6Configuration {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (_optionals, _extensions_present) =
            aper::decode::decode_sequence_header(data, true, 1)?;
        let m6report_interval = M6reportInterval::decode(data)?;
        let m6_links_to_log = M6LinksToLog::decode(data)?;

        Ok(Self {
            m6report_interval,
            m6_links_to_log,
        })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(false);

        aper::encode::encode_sequence_header(data, true, &optionals, false)?;
        self.m6report_interval.encode(data)?;
        self.m6_links_to_log.encode(data)?;

        Ok(())
    }
}

impl AperCodec for M6Configuration {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        M6Configuration::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("M6Configuration"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("M6Configuration"))
    }
}
// M6reportInterval
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum M6reportInterval {
    Ms120,
    Ms240,
    Ms640,
    Ms1024,
    Ms2048,
    Ms5120,
    Ms10240,
    Ms20480,
    Ms40960,
    Min1,
    Min6,
    Min12,
    Min30,
}

impl M6reportInterval {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (idx, extended) = aper::decode::decode_enumerated(data, Some(0), Some(12), true)?;
        if extended {
            return Err(aper::AperCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| AperCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_enumerated(data, Some(0), Some(12), true, *self as i128, false)
    }
}

impl AperCodec for M6reportInterval {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        M6reportInterval::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("M6reportInterval"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("M6reportInterval"))
    }
}
// M6LinksToLog
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum M6LinksToLog {
    Uplink,
    Downlink,
    BothUplinkAndDownlink,
}

impl M6LinksToLog {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (idx, extended) = aper::decode::decode_enumerated(data, Some(0), Some(2), true)?;
        if extended {
            return Err(aper::AperCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| AperCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_enumerated(data, Some(0), Some(2), true, *self as i128, false)
    }
}

impl AperCodec for M6LinksToLog {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        M6LinksToLog::decode_inner(data).map_err(|e: AperCodecError| e.push_context("M6LinksToLog"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("M6LinksToLog"))
    }
}
// M7Configuration
#[derive(Clone, Debug)]
pub struct M7Configuration {
    pub m7period: M7period,
    pub m7_links_to_log: M7LinksToLog,
}

impl M7Configuration {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (_optionals, _extensions_present) =
            aper::decode::decode_sequence_header(data, true, 1)?;
        let m7period = M7period::decode(data)?;
        let m7_links_to_log = M7LinksToLog::decode(data)?;

        Ok(Self {
            m7period,
            m7_links_to_log,
        })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(false);

        aper::encode::encode_sequence_header(data, true, &optionals, false)?;
        self.m7period.encode(data)?;
        self.m7_links_to_log.encode(data)?;

        Ok(())
    }
}

impl AperCodec for M7Configuration {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        M7Configuration::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("M7Configuration"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("M7Configuration"))
    }
}
// M7period
#[derive(Clone, Debug)]
pub struct M7period(pub u8);

impl M7period {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        Ok(Self(
            aper::decode::decode_integer(data, Some(1), Some(60), true)?.0 as u8,
        ))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_integer(data, Some(1), Some(60), true, self.0 as i128, false)
    }
}

impl AperCodec for M7period {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        M7period::decode_inner(data).map_err(|e: AperCodecError| e.push_context("M7period"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("M7period"))
    }
}
// M7LinksToLog
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum M7LinksToLog {
    Downlink,
}

impl M7LinksToLog {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (idx, extended) = aper::decode::decode_enumerated(data, Some(0), Some(0), true)?;
        if extended {
            return Err(aper::AperCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| AperCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_enumerated(data, Some(0), Some(0), true, *self as i128, false)
    }
}

impl AperCodec for M7LinksToLog {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        M7LinksToLog::decode_inner(data).map_err(|e: AperCodecError| e.push_context("M7LinksToLog"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("M7LinksToLog"))
    }
}
// MdtActivation
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum MdtActivation {
    ImmediateMdtOnly,
    ImmediateMdtAndTrace,
}

impl MdtActivation {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (idx, extended) = aper::decode::decode_enumerated(data, Some(0), Some(1), true)?;
        if extended {
            return Err(aper::AperCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| AperCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_enumerated(data, Some(0), Some(1), true, *self as i128, false)
    }
}

impl AperCodec for MdtActivation {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        MdtActivation::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("MdtActivation"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("MdtActivation"))
    }
}
// MdtConfiguration
#[derive(Clone, Debug)]
pub struct MdtConfiguration {
    pub mdt_activation: MdtActivation,
    pub measurements_to_activate: MeasurementsToActivate,
    pub m2_configuration: Option<M2Configuration>,
    pub m5_configuration: Option<M5Configuration>,
    pub m6_configuration: Option<M6Configuration>,
    pub m7_configuration: Option<M7Configuration>,
}

impl MdtConfiguration {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (optionals, _extensions_present) = aper::decode::decode_sequence_header(data, true, 5)?;
        let mdt_activation = MdtActivation::decode(data)?;
        let measurements_to_activate = MeasurementsToActivate::decode(data)?;
        let m2_configuration = if optionals[0] {
            Some(M2Configuration::decode(data)?)
        } else {
            None
        };
        let m5_configuration = if optionals[1] {
            Some(M5Configuration::decode(data)?)
        } else {
            None
        };
        let m6_configuration = if optionals[2] {
            Some(M6Configuration::decode(data)?)
        } else {
            None
        };
        let m7_configuration = if optionals[3] {
            Some(M7Configuration::decode(data)?)
        } else {
            None
        };

        Ok(Self {
            mdt_activation,
            measurements_to_activate,
            m2_configuration,
            m5_configuration,
            m6_configuration,
            m7_configuration,
        })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(self.m2_configuration.is_some());
        optionals.push(self.m5_configuration.is_some());
        optionals.push(self.m6_configuration.is_some());
        optionals.push(self.m7_configuration.is_some());
        optionals.push(false);

        aper::encode::encode_sequence_header(data, true, &optionals, false)?;
        self.mdt_activation.encode(data)?;
        self.measurements_to_activate.encode(data)?;
        if let Some(x) = &self.m2_configuration {
            x.encode(data)?;
        }
        if let Some(x) = &self.m5_configuration {
            x.encode(data)?;
        }
        if let Some(x) = &self.m6_configuration {
            x.encode(data)?;
        }
        if let Some(x) = &self.m7_configuration {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl AperCodec for MdtConfiguration {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        MdtConfiguration::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("MdtConfiguration"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("MdtConfiguration"))
    }
}
// MdtPlmnList
#[derive(Clone, Debug)]
pub struct MdtPlmnList(pub Vec<PlmnIdentity>);

impl MdtPlmnList {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        Ok(Self({
            let length = aper::decode::decode_length_determinent(data, Some(1), Some(16), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(PlmnIdentity::decode(data)?);
            }
            items
        }))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_length_determinent(data, Some(1), Some(16), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl AperCodec for MdtPlmnList {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        MdtPlmnList::decode_inner(data).map_err(|e: AperCodecError| e.push_context("MdtPlmnList"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("MdtPlmnList"))
    }
}
// MeasuredResultsValue
#[derive(Clone, Debug)]
pub enum MeasuredResultsValue {
    UlAngleOfArrival(UlAoA),
    UlSrsRsrp(UlSrsRsrp),
    UlRtoa(UlRtoaMeasurement),
    GnbRxTxTimeDiff(GnbRxTxTimeDiff),
}

impl MeasuredResultsValue {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (idx, extended) = aper::decode::decode_choice_idx(data, 0, 4, false)?;
        if extended {
            return Err(aper::AperCodecError::new(
                "CHOICE additions not implemented",
            ));
        }
        match idx {
            0 => Ok(Self::UlAngleOfArrival(UlAoA::decode(data)?)),
            1 => Ok(Self::UlSrsRsrp(UlSrsRsrp::decode(data)?)),
            2 => Ok(Self::UlRtoa(UlRtoaMeasurement::decode(data)?)),
            3 => Ok(Self::GnbRxTxTimeDiff(GnbRxTxTimeDiff::decode(data)?)),
            4 => Err(AperCodecError::new(
                "Choice extension container not implemented",
            )),
            _ => Err(AperCodecError::new("Unknown choice idx")),
        }
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        match self {
            Self::UlAngleOfArrival(x) => {
                aper::encode::encode_choice_idx(data, 0, 4, false, 0, false)?;
                x.encode(data)
            }
            Self::UlSrsRsrp(x) => {
                aper::encode::encode_choice_idx(data, 0, 4, false, 1, false)?;
                x.encode(data)
            }
            Self::UlRtoa(x) => {
                aper::encode::encode_choice_idx(data, 0, 4, false, 2, false)?;
                x.encode(data)
            }
            Self::GnbRxTxTimeDiff(x) => {
                aper::encode::encode_choice_idx(data, 0, 4, false, 3, false)?;
                x.encode(data)
            }
        }
    }
}

impl AperCodec for MeasuredResultsValue {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        MeasuredResultsValue::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("MeasuredResultsValue"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("MeasuredResultsValue"))
    }
}
// MeasurementsToActivate
#[derive(Clone, Debug)]
pub struct MeasurementsToActivate(pub BitString);

impl MeasurementsToActivate {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        Ok(Self(aper::decode::decode_bitstring(
            data,
            Some(8),
            Some(8),
            false,
        )?))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_bitstring(data, Some(8), Some(8), false, &self.0, false)
    }
}

impl AperCodec for MeasurementsToActivate {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        MeasurementsToActivate::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("MeasurementsToActivate"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("MeasurementsToActivate"))
    }
}
// NeedforGap
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum NeedforGap {
    True,
}

impl NeedforGap {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (idx, extended) = aper::decode::decode_enumerated(data, Some(0), Some(0), true)?;
        if extended {
            return Err(aper::AperCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| AperCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_enumerated(data, Some(0), Some(0), true, *self as i128, false)
    }
}

impl AperCodec for NeedforGap {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        NeedforGap::decode_inner(data).map_err(|e: AperCodecError| e.push_context("NeedforGap"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("NeedforGap"))
    }
}
// NeighbourCellInformationItem
#[derive(Clone, Debug)]
pub struct NeighbourCellInformationItem {
    pub nrcgi: Nrcgi,
    pub intended_tdd_dl_ul_config: Option<IntendedTddDlUlConfig>,
}

impl NeighbourCellInformationItem {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (optionals, _extensions_present) =
            aper::decode::decode_sequence_header(data, false, 2)?;
        let nrcgi = Nrcgi::decode(data)?;
        let intended_tdd_dl_ul_config = if optionals[0] {
            Some(IntendedTddDlUlConfig::decode(data)?)
        } else {
            None
        };

        Ok(Self {
            nrcgi,
            intended_tdd_dl_ul_config,
        })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(self.intended_tdd_dl_ul_config.is_some());
        optionals.push(false);

        aper::encode::encode_sequence_header(data, false, &optionals, false)?;
        self.nrcgi.encode(data)?;
        if let Some(x) = &self.intended_tdd_dl_ul_config {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl AperCodec for NeighbourCellInformationItem {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        NeighbourCellInformationItem::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("NeighbourCellInformationItem"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("NeighbourCellInformationItem"))
    }
}
// NgranAllocationAndRetentionPriority
#[derive(Clone, Debug)]
pub struct NgranAllocationAndRetentionPriority {
    pub priority_level: PriorityLevel,
    pub pre_emption_capability: PreEmptionCapability,
    pub pre_emption_vulnerability: PreEmptionVulnerability,
}

impl NgranAllocationAndRetentionPriority {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (_optionals, _extensions_present) =
            aper::decode::decode_sequence_header(data, false, 1)?;
        let priority_level = PriorityLevel::decode(data)?;
        let pre_emption_capability = PreEmptionCapability::decode(data)?;
        let pre_emption_vulnerability = PreEmptionVulnerability::decode(data)?;

        Ok(Self {
            priority_level,
            pre_emption_capability,
            pre_emption_vulnerability,
        })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(false);

        aper::encode::encode_sequence_header(data, false, &optionals, false)?;
        self.priority_level.encode(data)?;
        self.pre_emption_capability.encode(data)?;
        self.pre_emption_vulnerability.encode(data)?;

        Ok(())
    }
}

impl AperCodec for NgranAllocationAndRetentionPriority {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        NgranAllocationAndRetentionPriority::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("NgranAllocationAndRetentionPriority"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("NgranAllocationAndRetentionPriority"))
    }
}
// NgranHighAccuracyAccessPointPosition
#[derive(Clone, Debug)]
pub struct NgranHighAccuracyAccessPointPosition {
    pub latitude: i32,
    pub longitude: i32,
    pub altitude: i32,
    pub uncertainty_semi_major: u8,
    pub uncertainty_semi_minor: u8,
    pub orientation_of_major_axis: u8,
    pub horizontal_confidence: u8,
    pub uncertainty_altitude: u8,
    pub vertical_confidence: u8,
}

impl NgranHighAccuracyAccessPointPosition {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (_optionals, _extensions_present) =
            aper::decode::decode_sequence_header(data, false, 1)?;
        let latitude =
            aper::decode::decode_integer(data, Some(-2147483648), Some(2147483647), false)?.0
                as i32;
        let longitude =
            aper::decode::decode_integer(data, Some(-2147483648), Some(2147483647), false)?.0
                as i32;
        let altitude =
            aper::decode::decode_integer(data, Some(-64000), Some(1280000), false)?.0 as i32;
        let uncertainty_semi_major =
            aper::decode::decode_integer(data, Some(0), Some(255), false)?.0 as u8;
        let uncertainty_semi_minor =
            aper::decode::decode_integer(data, Some(0), Some(255), false)?.0 as u8;
        let orientation_of_major_axis =
            aper::decode::decode_integer(data, Some(0), Some(179), false)?.0 as u8;
        let horizontal_confidence =
            aper::decode::decode_integer(data, Some(0), Some(100), false)?.0 as u8;
        let uncertainty_altitude =
            aper::decode::decode_integer(data, Some(0), Some(255), false)?.0 as u8;
        let vertical_confidence =
            aper::decode::decode_integer(data, Some(0), Some(100), false)?.0 as u8;

        Ok(Self {
            latitude,
            longitude,
            altitude,
            uncertainty_semi_major,
            uncertainty_semi_minor,
            orientation_of_major_axis,
            horizontal_confidence,
            uncertainty_altitude,
            vertical_confidence,
        })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(false);

        aper::encode::encode_sequence_header(data, false, &optionals, false)?;
        aper::encode::encode_integer(
            data,
            Some(-2147483648),
            Some(2147483647),
            false,
            self.latitude as i128,
            false,
        )?;
        aper::encode::encode_integer(
            data,
            Some(-2147483648),
            Some(2147483647),
            false,
            self.longitude as i128,
            false,
        )?;
        aper::encode::encode_integer(
            data,
            Some(-64000),
            Some(1280000),
            false,
            self.altitude as i128,
            false,
        )?;
        aper::encode::encode_integer(
            data,
            Some(0),
            Some(255),
            false,
            self.uncertainty_semi_major as i128,
            false,
        )?;
        aper::encode::encode_integer(
            data,
            Some(0),
            Some(255),
            false,
            self.uncertainty_semi_minor as i128,
            false,
        )?;
        aper::encode::encode_integer(
            data,
            Some(0),
            Some(179),
            false,
            self.orientation_of_major_axis as i128,
            false,
        )?;
        aper::encode::encode_integer(
            data,
            Some(0),
            Some(100),
            false,
            self.horizontal_confidence as i128,
            false,
        )?;
        aper::encode::encode_integer(
            data,
            Some(0),
            Some(255),
            false,
            self.uncertainty_altitude as i128,
            false,
        )?;
        aper::encode::encode_integer(
            data,
            Some(0),
            Some(100),
            false,
            self.vertical_confidence as i128,
            false,
        )?;

        Ok(())
    }
}

impl AperCodec for NgranHighAccuracyAccessPointPosition {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        NgranHighAccuracyAccessPointPosition::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("NgranHighAccuracyAccessPointPosition"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("NgranHighAccuracyAccessPointPosition"))
    }
}
// Nid
#[derive(Clone, Debug)]
pub struct Nid(pub BitString);

impl Nid {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        Ok(Self(aper::decode::decode_bitstring(
            data,
            Some(44),
            Some(44),
            false,
        )?))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_bitstring(data, Some(44), Some(44), false, &self.0, false)
    }
}

impl AperCodec for Nid {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        Nid::decode_inner(data).map_err(|e: AperCodecError| e.push_context("Nid"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("Nid"))
    }
}
// NrCgiListForRestartItem
#[derive(Clone, Debug)]
pub struct NrCgiListForRestartItem {
    pub nrcgi: Nrcgi,
}

impl NrCgiListForRestartItem {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (_optionals, _extensions_present) =
            aper::decode::decode_sequence_header(data, true, 1)?;
        let nrcgi = Nrcgi::decode(data)?;

        Ok(Self { nrcgi })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(false);

        aper::encode::encode_sequence_header(data, true, &optionals, false)?;
        self.nrcgi.encode(data)?;

        Ok(())
    }
}

impl AperCodec for NrCgiListForRestartItem {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        NrCgiListForRestartItem::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("NrCgiListForRestartItem"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("NrCgiListForRestartItem"))
    }
}
// NrPrsBeamInformation
#[derive(Clone, Debug)]
pub struct NrPrsBeamInformation {
    pub nr_prs_beam_information_list: NrPrsBeamInformationList,
    pub lc_sto_gcs_translation_list: Option<LcStoGcsTranslationList>,
}

impl NrPrsBeamInformation {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (optionals, _extensions_present) =
            aper::decode::decode_sequence_header(data, false, 2)?;
        let nr_prs_beam_information_list = NrPrsBeamInformationList::decode(data)?;
        let lc_sto_gcs_translation_list = if optionals[0] {
            Some(LcStoGcsTranslationList::decode(data)?)
        } else {
            None
        };

        Ok(Self {
            nr_prs_beam_information_list,
            lc_sto_gcs_translation_list,
        })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(self.lc_sto_gcs_translation_list.is_some());
        optionals.push(false);

        aper::encode::encode_sequence_header(data, false, &optionals, false)?;
        self.nr_prs_beam_information_list.encode(data)?;
        if let Some(x) = &self.lc_sto_gcs_translation_list {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl AperCodec for NrPrsBeamInformation {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        NrPrsBeamInformation::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("NrPrsBeamInformation"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("NrPrsBeamInformation"))
    }
}
// NrPrsBeamInformationList
#[derive(Clone, Debug)]
pub struct NrPrsBeamInformationList(pub Vec<NrPrsBeamInformationItem>);

impl NrPrsBeamInformationList {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        Ok(Self({
            let length = aper::decode::decode_length_determinent(data, Some(1), Some(2), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(NrPrsBeamInformationItem::decode(data)?);
            }
            items
        }))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_length_determinent(data, Some(1), Some(2), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl AperCodec for NrPrsBeamInformationList {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        NrPrsBeamInformationList::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("NrPrsBeamInformationList"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("NrPrsBeamInformationList"))
    }
}
// NrPrsBeamInformationItem
#[derive(Clone, Debug)]
pub struct NrPrsBeamInformationItem {
    pub prs_resource_set_id: PrsResourceSetId,
    pub prs_angle_list: PrsAngleList,
}

impl NrPrsBeamInformationItem {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (_optionals, _extensions_present) =
            aper::decode::decode_sequence_header(data, false, 1)?;
        let prs_resource_set_id = PrsResourceSetId::decode(data)?;
        let prs_angle_list = PrsAngleList::decode(data)?;

        Ok(Self {
            prs_resource_set_id,
            prs_angle_list,
        })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(false);

        aper::encode::encode_sequence_header(data, false, &optionals, false)?;
        self.prs_resource_set_id.encode(data)?;
        self.prs_angle_list.encode(data)?;

        Ok(())
    }
}

impl AperCodec for NrPrsBeamInformationItem {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        NrPrsBeamInformationItem::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("NrPrsBeamInformationItem"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("NrPrsBeamInformationItem"))
    }
}
// NonDynamic5qiDescriptor
#[derive(Clone, Debug)]
pub struct NonDynamic5qiDescriptor {
    pub five_qi: u8,
    pub qos_priority_level: Option<u8>,
    pub averaging_window: Option<AveragingWindow>,
    pub max_data_burst_volume: Option<MaxDataBurstVolume>,
}

impl NonDynamic5qiDescriptor {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (optionals, _extensions_present) =
            aper::decode::decode_sequence_header(data, false, 4)?;
        let five_qi = aper::decode::decode_integer(data, Some(0), Some(255), true)?.0 as u8;
        let qos_priority_level = if optionals[0] {
            Some(aper::decode::decode_integer(data, Some(1), Some(127), false)?.0 as u8)
        } else {
            None
        };
        let averaging_window = if optionals[1] {
            Some(AveragingWindow::decode(data)?)
        } else {
            None
        };
        let max_data_burst_volume = if optionals[2] {
            Some(MaxDataBurstVolume::decode(data)?)
        } else {
            None
        };

        Ok(Self {
            five_qi,
            qos_priority_level,
            averaging_window,
            max_data_burst_volume,
        })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(self.qos_priority_level.is_some());
        optionals.push(self.averaging_window.is_some());
        optionals.push(self.max_data_burst_volume.is_some());
        optionals.push(false);

        aper::encode::encode_sequence_header(data, false, &optionals, false)?;
        aper::encode::encode_integer(data, Some(0), Some(255), true, self.five_qi as i128, false)?;
        if let Some(x) = &self.qos_priority_level {
            aper::encode::encode_integer(data, Some(1), Some(127), false, *x as i128, false)?;
        }
        if let Some(x) = &self.averaging_window {
            x.encode(data)?;
        }
        if let Some(x) = &self.max_data_burst_volume {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl AperCodec for NonDynamic5qiDescriptor {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        NonDynamic5qiDescriptor::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("NonDynamic5qiDescriptor"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("NonDynamic5qiDescriptor"))
    }
}
// NonDynamicPqiDescriptor
#[derive(Clone, Debug)]
pub struct NonDynamicPqiDescriptor {
    pub five_qi: u8,
    pub qos_priority_level: Option<u8>,
    pub averaging_window: Option<AveragingWindow>,
    pub max_data_burst_volume: Option<MaxDataBurstVolume>,
}

impl NonDynamicPqiDescriptor {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (optionals, _extensions_present) =
            aper::decode::decode_sequence_header(data, false, 4)?;
        let five_qi = aper::decode::decode_integer(data, Some(0), Some(255), true)?.0 as u8;
        let qos_priority_level = if optionals[0] {
            Some(aper::decode::decode_integer(data, Some(1), Some(8), true)?.0 as u8)
        } else {
            None
        };
        let averaging_window = if optionals[1] {
            Some(AveragingWindow::decode(data)?)
        } else {
            None
        };
        let max_data_burst_volume = if optionals[2] {
            Some(MaxDataBurstVolume::decode(data)?)
        } else {
            None
        };

        Ok(Self {
            five_qi,
            qos_priority_level,
            averaging_window,
            max_data_burst_volume,
        })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(self.qos_priority_level.is_some());
        optionals.push(self.averaging_window.is_some());
        optionals.push(self.max_data_burst_volume.is_some());
        optionals.push(false);

        aper::encode::encode_sequence_header(data, false, &optionals, false)?;
        aper::encode::encode_integer(data, Some(0), Some(255), true, self.five_qi as i128, false)?;
        if let Some(x) = &self.qos_priority_level {
            aper::encode::encode_integer(data, Some(1), Some(8), true, *x as i128, false)?;
        }
        if let Some(x) = &self.averaging_window {
            x.encode(data)?;
        }
        if let Some(x) = &self.max_data_burst_volume {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl AperCodec for NonDynamicPqiDescriptor {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        NonDynamicPqiDescriptor::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("NonDynamicPqiDescriptor"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("NonDynamicPqiDescriptor"))
    }
}
// NonUpTrafficType
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum NonUpTrafficType {
    UeAssociated,
    NonUeAssociated,
    NonF1,
    BapControlPdu,
}

impl NonUpTrafficType {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (idx, extended) = aper::decode::decode_enumerated(data, Some(0), Some(3), true)?;
        if extended {
            return Err(aper::AperCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| AperCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_enumerated(data, Some(0), Some(3), true, *self as i128, false)
    }
}

impl AperCodec for NonUpTrafficType {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        NonUpTrafficType::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("NonUpTrafficType"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("NonUpTrafficType"))
    }
}
// NoofDownlinkSymbols
#[derive(Clone, Debug)]
pub struct NoofDownlinkSymbols(pub u8);

impl NoofDownlinkSymbols {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        Ok(Self(
            aper::decode::decode_integer(data, Some(0), Some(14), false)?.0 as u8,
        ))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_integer(data, Some(0), Some(14), false, self.0 as i128, false)
    }
}

impl AperCodec for NoofDownlinkSymbols {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        NoofDownlinkSymbols::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("NoofDownlinkSymbols"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("NoofDownlinkSymbols"))
    }
}
// NoofUplinkSymbols
#[derive(Clone, Debug)]
pub struct NoofUplinkSymbols(pub u8);

impl NoofUplinkSymbols {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        Ok(Self(
            aper::decode::decode_integer(data, Some(0), Some(14), false)?.0 as u8,
        ))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_integer(data, Some(0), Some(14), false, self.0 as i128, false)
    }
}

impl AperCodec for NoofUplinkSymbols {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        NoofUplinkSymbols::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("NoofUplinkSymbols"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("NoofUplinkSymbols"))
    }
}
// NotificationCause
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum NotificationCause {
    Fulfilled,
    NotFulfilled,
}

impl NotificationCause {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (idx, extended) = aper::decode::decode_enumerated(data, Some(0), Some(1), true)?;
        if extended {
            return Err(aper::AperCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| AperCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_enumerated(data, Some(0), Some(1), true, *self as i128, false)
    }
}

impl AperCodec for NotificationCause {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        NotificationCause::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("NotificationCause"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("NotificationCause"))
    }
}
// NotificationControl
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum NotificationControl {
    Active,
    NotActive,
}

impl NotificationControl {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (idx, extended) = aper::decode::decode_enumerated(data, Some(0), Some(1), true)?;
        if extended {
            return Err(aper::AperCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| AperCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_enumerated(data, Some(0), Some(1), true, *self as i128, false)
    }
}

impl AperCodec for NotificationControl {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        NotificationControl::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("NotificationControl"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("NotificationControl"))
    }
}
// NotificationInformation
#[derive(Clone, Debug)]
pub struct NotificationInformation {
    pub message_identifier: MessageIdentifier,
    pub serial_number: SerialNumber,
}

impl NotificationInformation {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (_optionals, _extensions_present) =
            aper::decode::decode_sequence_header(data, true, 1)?;
        let message_identifier = MessageIdentifier::decode(data)?;
        let serial_number = SerialNumber::decode(data)?;

        Ok(Self {
            message_identifier,
            serial_number,
        })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(false);

        aper::encode::encode_sequence_header(data, true, &optionals, false)?;
        self.message_identifier.encode(data)?;
        self.serial_number.encode(data)?;

        Ok(())
    }
}

impl AperCodec for NotificationInformation {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        NotificationInformation::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("NotificationInformation"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("NotificationInformation"))
    }
}
// NpnBroadcastInformation
#[derive(Clone, Debug)]
pub enum NpnBroadcastInformation {
    SnpnBroadcastInformation(NpnBroadcastInformationSnpn),
    PniNpnBroadcastInformation(NpnBroadcastInformationPniNpn),
}

impl NpnBroadcastInformation {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (idx, extended) = aper::decode::decode_choice_idx(data, 0, 2, false)?;
        if extended {
            return Err(aper::AperCodecError::new(
                "CHOICE additions not implemented",
            ));
        }
        match idx {
            0 => Ok(Self::SnpnBroadcastInformation(
                NpnBroadcastInformationSnpn::decode(data)?,
            )),
            1 => Ok(Self::PniNpnBroadcastInformation(
                NpnBroadcastInformationPniNpn::decode(data)?,
            )),
            2 => Err(AperCodecError::new(
                "Choice extension container not implemented",
            )),
            _ => Err(AperCodecError::new("Unknown choice idx")),
        }
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        match self {
            Self::SnpnBroadcastInformation(x) => {
                aper::encode::encode_choice_idx(data, 0, 2, false, 0, false)?;
                x.encode(data)
            }
            Self::PniNpnBroadcastInformation(x) => {
                aper::encode::encode_choice_idx(data, 0, 2, false, 1, false)?;
                x.encode(data)
            }
        }
    }
}

impl AperCodec for NpnBroadcastInformation {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        NpnBroadcastInformation::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("NpnBroadcastInformation"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("NpnBroadcastInformation"))
    }
}
// NpnBroadcastInformationSnpn
#[derive(Clone, Debug)]
pub struct NpnBroadcastInformationSnpn {
    pub broadcast_snpnid_list: BroadcastSnpnIdList,
}

impl NpnBroadcastInformationSnpn {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (_optionals, _extensions_present) =
            aper::decode::decode_sequence_header(data, true, 1)?;
        let broadcast_snpnid_list = BroadcastSnpnIdList::decode(data)?;

        Ok(Self {
            broadcast_snpnid_list,
        })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(false);

        aper::encode::encode_sequence_header(data, true, &optionals, false)?;
        self.broadcast_snpnid_list.encode(data)?;

        Ok(())
    }
}

impl AperCodec for NpnBroadcastInformationSnpn {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        NpnBroadcastInformationSnpn::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("NpnBroadcastInformationSnpn"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("NpnBroadcastInformationSnpn"))
    }
}
// NpnBroadcastInformationPniNpn
#[derive(Clone, Debug)]
pub struct NpnBroadcastInformationPniNpn {
    pub broadcast_pni_npn_id_information: BroadcastPniNpnIdList,
}

impl NpnBroadcastInformationPniNpn {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (_optionals, _extensions_present) =
            aper::decode::decode_sequence_header(data, true, 1)?;
        let broadcast_pni_npn_id_information = BroadcastPniNpnIdList::decode(data)?;

        Ok(Self {
            broadcast_pni_npn_id_information,
        })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(false);

        aper::encode::encode_sequence_header(data, true, &optionals, false)?;
        self.broadcast_pni_npn_id_information.encode(data)?;

        Ok(())
    }
}

impl AperCodec for NpnBroadcastInformationPniNpn {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        NpnBroadcastInformationPniNpn::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("NpnBroadcastInformationPniNpn"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("NpnBroadcastInformationPniNpn"))
    }
}
// NpnSupportInfo
#[derive(Clone, Debug)]
pub enum NpnSupportInfo {
    SnpnInformation(Nid),
}

impl NpnSupportInfo {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (idx, extended) = aper::decode::decode_choice_idx(data, 0, 1, false)?;
        if extended {
            return Err(aper::AperCodecError::new(
                "CHOICE additions not implemented",
            ));
        }
        match idx {
            0 => Ok(Self::SnpnInformation(Nid::decode(data)?)),
            1 => Err(AperCodecError::new(
                "Choice extension container not implemented",
            )),
            _ => Err(AperCodecError::new("Unknown choice idx")),
        }
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        match self {
            Self::SnpnInformation(x) => {
                aper::encode::encode_choice_idx(data, 0, 1, false, 0, false)?;
                x.encode(data)
            }
        }
    }
}

impl AperCodec for NpnSupportInfo {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        NpnSupportInfo::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("NpnSupportInfo"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("NpnSupportInfo"))
    }
}
// NrCarrierList
#[derive(Clone, Debug)]
pub struct NrCarrierList(pub Vec<NrCarrierItem>);

impl NrCarrierList {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        Ok(Self({
            let length = aper::decode::decode_length_determinent(data, Some(1), Some(5), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(NrCarrierItem::decode(data)?);
            }
            items
        }))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_length_determinent(data, Some(1), Some(5), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl AperCodec for NrCarrierList {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        NrCarrierList::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("NrCarrierList"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("NrCarrierList"))
    }
}
// NrCarrierItem
#[derive(Clone, Debug)]
pub struct NrCarrierItem {
    pub carrier_scs: Nrscs,
    pub offset_to_carrier: u16,
    pub carrier_bandwidth: u16,
}

impl NrCarrierItem {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (_optionals, _extensions_present) =
            aper::decode::decode_sequence_header(data, true, 1)?;
        let carrier_scs = Nrscs::decode(data)?;
        let offset_to_carrier =
            aper::decode::decode_integer(data, Some(0), Some(2199), true)?.0 as u16;
        let carrier_bandwidth =
            aper::decode::decode_integer(data, Some(0), Some(275), true)?.0 as u16;

        Ok(Self {
            carrier_scs,
            offset_to_carrier,
            carrier_bandwidth,
        })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(false);

        aper::encode::encode_sequence_header(data, true, &optionals, false)?;
        self.carrier_scs.encode(data)?;
        aper::encode::encode_integer(
            data,
            Some(0),
            Some(2199),
            true,
            self.offset_to_carrier as i128,
            false,
        )?;
        aper::encode::encode_integer(
            data,
            Some(0),
            Some(275),
            true,
            self.carrier_bandwidth as i128,
            false,
        )?;

        Ok(())
    }
}

impl AperCodec for NrCarrierItem {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        NrCarrierItem::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("NrCarrierItem"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("NrCarrierItem"))
    }
}
// NrFreqInfo
#[derive(Clone, Debug)]
pub struct NrFreqInfo {
    pub nrarfcn: u32,
    pub sul_information: Option<SulInformation>,
    pub freq_band_list_nr: Vec<FreqBandNrItem>,
}

impl NrFreqInfo {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (optionals, _extensions_present) = aper::decode::decode_sequence_header(data, true, 2)?;
        let nrarfcn = aper::decode::decode_integer(data, Some(0), Some(3279165), false)?.0 as u32;
        let sul_information = if optionals[0] {
            Some(SulInformation::decode(data)?)
        } else {
            None
        };
        let freq_band_list_nr = {
            let length = aper::decode::decode_length_determinent(data, Some(1), Some(32), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(FreqBandNrItem::decode(data)?);
            }
            items
        };

        Ok(Self {
            nrarfcn,
            sul_information,
            freq_band_list_nr,
        })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(self.sul_information.is_some());
        optionals.push(false);

        aper::encode::encode_sequence_header(data, true, &optionals, false)?;
        aper::encode::encode_integer(
            data,
            Some(0),
            Some(3279165),
            false,
            self.nrarfcn as i128,
            false,
        )?;
        if let Some(x) = &self.sul_information {
            x.encode(data)?;
        }
        aper::encode::encode_length_determinent(
            data,
            Some(1),
            Some(32),
            false,
            self.freq_band_list_nr.len(),
        )?;
        for x in &self.freq_band_list_nr {
            x.encode(data)?;
        }
        Ok(())?;

        Ok(())
    }
}

impl AperCodec for NrFreqInfo {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        NrFreqInfo::decode_inner(data).map_err(|e: AperCodecError| e.push_context("NrFreqInfo"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("NrFreqInfo"))
    }
}
// Nrcgi
#[derive(Clone, Debug)]
pub struct Nrcgi {
    pub plmn_identity: PlmnIdentity,
    pub nr_cell_identity: NrCellIdentity,
}

impl Nrcgi {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (_optionals, _extensions_present) =
            aper::decode::decode_sequence_header(data, true, 1)?;
        let plmn_identity = PlmnIdentity::decode(data)?;
        let nr_cell_identity = NrCellIdentity::decode(data)?;

        Ok(Self {
            plmn_identity,
            nr_cell_identity,
        })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(false);

        aper::encode::encode_sequence_header(data, true, &optionals, false)?;
        self.plmn_identity.encode(data)?;
        self.nr_cell_identity.encode(data)?;

        Ok(())
    }
}

impl AperCodec for Nrcgi {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        Nrcgi::decode_inner(data).map_err(|e: AperCodecError| e.push_context("Nrcgi"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("Nrcgi"))
    }
}
// NrModeInfo
#[derive(Clone, Debug)]
pub enum NrModeInfo {
    Fdd(FddInfo),
    Tdd(TddInfo),
}

impl NrModeInfo {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (idx, extended) = aper::decode::decode_choice_idx(data, 0, 2, false)?;
        if extended {
            return Err(aper::AperCodecError::new(
                "CHOICE additions not implemented",
            ));
        }
        match idx {
            0 => Ok(Self::Fdd(FddInfo::decode(data)?)),
            1 => Ok(Self::Tdd(TddInfo::decode(data)?)),
            2 => Err(AperCodecError::new(
                "Choice extension container not implemented",
            )),
            _ => Err(AperCodecError::new("Unknown choice idx")),
        }
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        match self {
            Self::Fdd(x) => {
                aper::encode::encode_choice_idx(data, 0, 2, false, 0, false)?;
                x.encode(data)
            }
            Self::Tdd(x) => {
                aper::encode::encode_choice_idx(data, 0, 2, false, 1, false)?;
                x.encode(data)
            }
        }
    }
}

impl AperCodec for NrModeInfo {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        NrModeInfo::decode_inner(data).map_err(|e: AperCodecError| e.push_context("NrModeInfo"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("NrModeInfo"))
    }
}
// NrprachConfig
#[derive(Clone, Debug)]
pub struct NrprachConfig {
    pub ul_prach_config_list: Option<NrprachConfigList>,
    pub sul_prach_config_list: Option<NrprachConfigList>,
}

impl NrprachConfig {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (optionals, _extensions_present) = aper::decode::decode_sequence_header(data, true, 3)?;
        let ul_prach_config_list = if optionals[0] {
            Some(NrprachConfigList::decode(data)?)
        } else {
            None
        };
        let sul_prach_config_list = if optionals[1] {
            Some(NrprachConfigList::decode(data)?)
        } else {
            None
        };

        Ok(Self {
            ul_prach_config_list,
            sul_prach_config_list,
        })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(self.ul_prach_config_list.is_some());
        optionals.push(self.sul_prach_config_list.is_some());
        optionals.push(false);

        aper::encode::encode_sequence_header(data, true, &optionals, false)?;
        if let Some(x) = &self.ul_prach_config_list {
            x.encode(data)?;
        }
        if let Some(x) = &self.sul_prach_config_list {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl AperCodec for NrprachConfig {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        NrprachConfig::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("NrprachConfig"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("NrprachConfig"))
    }
}
// NrCellIdentity
#[derive(Clone, Debug)]
pub struct NrCellIdentity(pub BitString);

impl NrCellIdentity {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        Ok(Self(aper::decode::decode_bitstring(
            data,
            Some(36),
            Some(36),
            false,
        )?))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_bitstring(data, Some(36), Some(36), false, &self.0, false)
    }
}

impl AperCodec for NrCellIdentity {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        NrCellIdentity::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("NrCellIdentity"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("NrCellIdentity"))
    }
}
// Nrnrb
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum Nrnrb {
    Nrb11,
    Nrb18,
    Nrb24,
    Nrb25,
    Nrb31,
    Nrb32,
    Nrb38,
    Nrb51,
    Nrb52,
    Nrb65,
    Nrb66,
    Nrb78,
    Nrb79,
    Nrb93,
    Nrb106,
    Nrb107,
    Nrb121,
    Nrb132,
    Nrb133,
    Nrb135,
    Nrb160,
    Nrb162,
    Nrb189,
    Nrb216,
    Nrb217,
    Nrb245,
    Nrb264,
    Nrb270,
    Nrb273,
}

impl Nrnrb {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (idx, extended) = aper::decode::decode_enumerated(data, Some(0), Some(28), true)?;
        if extended {
            return Err(aper::AperCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| AperCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_enumerated(data, Some(0), Some(28), true, *self as i128, false)
    }
}

impl AperCodec for Nrnrb {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        Nrnrb::decode_inner(data).map_err(|e: AperCodecError| e.push_context("Nrnrb"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("Nrnrb"))
    }
}
// Nrpci
#[derive(Clone, Debug)]
pub struct Nrpci(pub u16);

impl Nrpci {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        Ok(Self(
            aper::decode::decode_integer(data, Some(0), Some(1007), false)?.0 as u16,
        ))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_integer(data, Some(0), Some(1007), false, self.0 as i128, false)
    }
}

impl AperCodec for Nrpci {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        Nrpci::decode_inner(data).map_err(|e: AperCodecError| e.push_context("Nrpci"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("Nrpci"))
    }
}
// NrprachConfigList
#[derive(Clone, Debug)]
pub struct NrprachConfigList(pub Vec<NrprachConfigItem>);

impl NrprachConfigList {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        Ok(Self({
            let length = aper::decode::decode_length_determinent(data, Some(0), Some(16), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(NrprachConfigItem::decode(data)?);
            }
            items
        }))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_length_determinent(data, Some(0), Some(16), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl AperCodec for NrprachConfigList {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        NrprachConfigList::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("NrprachConfigList"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("NrprachConfigList"))
    }
}
// NrprachConfigItem
#[derive(Clone, Debug)]
pub struct NrprachConfigItem {
    pub nrscs: Nrscs,
    pub prach_freq_startfrom_carrier: u16,
    pub msg_1fdm: Msg1fdm,
    pub parch_config_index: i128,
    pub ssb_per_rach_occasion: SsbPerRachOccasion,
    pub freq_domain_length: FreqDomainLength,
    pub zero_correl_zone_config: u8,
}

impl NrprachConfigItem {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (_optionals, _extensions_present) =
            aper::decode::decode_sequence_header(data, true, 1)?;
        let nrscs = Nrscs::decode(data)?;
        let prach_freq_startfrom_carrier =
            aper::decode::decode_integer(data, Some(0), Some(274), true)?.0 as u16;
        let msg_1fdm = Msg1fdm::decode(data)?;
        let parch_config_index = aper::decode::decode_integer(data, Some(0), Some(255), true)?.0;
        let ssb_per_rach_occasion = SsbPerRachOccasion::decode(data)?;
        let freq_domain_length = FreqDomainLength::decode(data)?;
        let zero_correl_zone_config =
            aper::decode::decode_integer(data, Some(0), Some(15), false)?.0 as u8;

        Ok(Self {
            nrscs,
            prach_freq_startfrom_carrier,
            msg_1fdm,
            parch_config_index,
            ssb_per_rach_occasion,
            freq_domain_length,
            zero_correl_zone_config,
        })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(false);

        aper::encode::encode_sequence_header(data, true, &optionals, false)?;
        self.nrscs.encode(data)?;
        aper::encode::encode_integer(
            data,
            Some(0),
            Some(274),
            true,
            self.prach_freq_startfrom_carrier as i128,
            false,
        )?;
        self.msg_1fdm.encode(data)?;
        aper::encode::encode_integer(
            data,
            Some(0),
            Some(255),
            true,
            self.parch_config_index,
            false,
        )?;
        self.ssb_per_rach_occasion.encode(data)?;
        self.freq_domain_length.encode(data)?;
        aper::encode::encode_integer(
            data,
            Some(0),
            Some(15),
            false,
            self.zero_correl_zone_config as i128,
            false,
        )?;

        Ok(())
    }
}

impl AperCodec for NrprachConfigItem {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        NrprachConfigItem::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("NrprachConfigItem"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("NrprachConfigItem"))
    }
}
// Nrscs
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum Nrscs {
    Scs15,
    Scs30,
    Scs60,
    Scs120,
}

impl Nrscs {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (idx, extended) = aper::decode::decode_enumerated(data, Some(0), Some(3), true)?;
        if extended {
            return Err(aper::AperCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| AperCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_enumerated(data, Some(0), Some(3), true, *self as i128, false)
    }
}

impl AperCodec for Nrscs {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        Nrscs::decode_inner(data).map_err(|e: AperCodecError| e.push_context("Nrscs"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("Nrscs"))
    }
}
// NrueRlfReportContainer
#[derive(Clone, Debug)]
pub struct NrueRlfReportContainer(pub Vec<u8>);

impl NrueRlfReportContainer {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        Ok(Self(aper::decode::decode_octetstring(
            data, None, None, false,
        )?))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_octetstring(data, None, None, false, &self.0, false)
    }
}

impl AperCodec for NrueRlfReportContainer {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        NrueRlfReportContainer::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("NrueRlfReportContainer"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("NrueRlfReportContainer"))
    }
}
// NumberofActiveUEs
#[derive(Clone, Debug)]
pub struct NumberofActiveUEs(pub u32);

impl NumberofActiveUEs {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        Ok(Self(
            aper::decode::decode_integer(data, Some(0), Some(16777215), true)?.0 as u32,
        ))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_integer(data, Some(0), Some(16777215), true, self.0 as i128, false)
    }
}

impl AperCodec for NumberofActiveUEs {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        NumberofActiveUEs::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("NumberofActiveUEs"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("NumberofActiveUEs"))
    }
}
// NumberOfBroadcasts
#[derive(Clone, Debug)]
pub struct NumberOfBroadcasts(pub u16);

impl NumberOfBroadcasts {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        Ok(Self(
            aper::decode::decode_integer(data, Some(0), Some(65535), false)?.0 as u16,
        ))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_integer(data, Some(0), Some(65535), false, self.0 as i128, false)
    }
}

impl AperCodec for NumberOfBroadcasts {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        NumberOfBroadcasts::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("NumberOfBroadcasts"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("NumberOfBroadcasts"))
    }
}
// NumberofBroadcastRequest
#[derive(Clone, Debug)]
pub struct NumberofBroadcastRequest(pub u16);

impl NumberofBroadcastRequest {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        Ok(Self(
            aper::decode::decode_integer(data, Some(0), Some(65535), false)?.0 as u16,
        ))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_integer(data, Some(0), Some(65535), false, self.0 as i128, false)
    }
}

impl AperCodec for NumberofBroadcastRequest {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        NumberofBroadcastRequest::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("NumberofBroadcastRequest"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("NumberofBroadcastRequest"))
    }
}
// NumDlulSymbols
#[derive(Clone, Debug)]
pub struct NumDlulSymbols {
    pub num_dl_symbols: u8,
    pub num_ul_symbols: u8,
}

impl NumDlulSymbols {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (_optionals, _extensions_present) =
            aper::decode::decode_sequence_header(data, false, 1)?;
        let num_dl_symbols = aper::decode::decode_integer(data, Some(0), Some(13), true)?.0 as u8;
        let num_ul_symbols = aper::decode::decode_integer(data, Some(0), Some(13), true)?.0 as u8;

        Ok(Self {
            num_dl_symbols,
            num_ul_symbols,
        })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(false);

        aper::encode::encode_sequence_header(data, false, &optionals, false)?;
        aper::encode::encode_integer(
            data,
            Some(0),
            Some(13),
            true,
            self.num_dl_symbols as i128,
            false,
        )?;
        aper::encode::encode_integer(
            data,
            Some(0),
            Some(13),
            true,
            self.num_ul_symbols as i128,
            false,
        )?;

        Ok(())
    }
}

impl AperCodec for NumDlulSymbols {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        NumDlulSymbols::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("NumDlulSymbols"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("NumDlulSymbols"))
    }
}
// Nrv2xServicesAuthorized
#[derive(Clone, Debug)]
pub struct Nrv2xServicesAuthorized {
    pub vehicle_ue: Option<VehicleUe>,
    pub pedestrian_ue: Option<PedestrianUe>,
}

impl Nrv2xServicesAuthorized {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (optionals, _extensions_present) =
            aper::decode::decode_sequence_header(data, false, 3)?;
        let vehicle_ue = if optionals[0] {
            Some(VehicleUe::decode(data)?)
        } else {
            None
        };
        let pedestrian_ue = if optionals[1] {
            Some(PedestrianUe::decode(data)?)
        } else {
            None
        };

        Ok(Self {
            vehicle_ue,
            pedestrian_ue,
        })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(self.vehicle_ue.is_some());
        optionals.push(self.pedestrian_ue.is_some());
        optionals.push(false);

        aper::encode::encode_sequence_header(data, false, &optionals, false)?;
        if let Some(x) = &self.vehicle_ue {
            x.encode(data)?;
        }
        if let Some(x) = &self.pedestrian_ue {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl AperCodec for Nrv2xServicesAuthorized {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        Nrv2xServicesAuthorized::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("Nrv2xServicesAuthorized"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("Nrv2xServicesAuthorized"))
    }
}
// NrueSidelinkAggregateMaximumBitrate
#[derive(Clone, Debug)]
pub struct NrueSidelinkAggregateMaximumBitrate {
    pub uenr_sidelink_aggregate_maximum_bitrate: BitRate,
}

impl NrueSidelinkAggregateMaximumBitrate {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (_optionals, _extensions_present) =
            aper::decode::decode_sequence_header(data, false, 1)?;
        let uenr_sidelink_aggregate_maximum_bitrate = BitRate::decode(data)?;

        Ok(Self {
            uenr_sidelink_aggregate_maximum_bitrate,
        })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(false);

        aper::encode::encode_sequence_header(data, false, &optionals, false)?;
        self.uenr_sidelink_aggregate_maximum_bitrate.encode(data)?;

        Ok(())
    }
}

impl AperCodec for NrueSidelinkAggregateMaximumBitrate {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        NrueSidelinkAggregateMaximumBitrate::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("NrueSidelinkAggregateMaximumBitrate"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("NrueSidelinkAggregateMaximumBitrate"))
    }
}
// NzpCsiRsResourceId
#[derive(Clone, Debug)]
pub struct NzpCsiRsResourceId(pub u8);

impl NzpCsiRsResourceId {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        Ok(Self(
            aper::decode::decode_integer(data, Some(0), Some(191), false)?.0 as u8,
        ))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_integer(data, Some(0), Some(191), false, self.0 as i128, false)
    }
}

impl AperCodec for NzpCsiRsResourceId {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        NzpCsiRsResourceId::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("NzpCsiRsResourceId"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("NzpCsiRsResourceId"))
    }
}
// OffsetToPointA
#[derive(Clone, Debug)]
pub struct OffsetToPointA(pub u16);

impl OffsetToPointA {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        Ok(Self(
            aper::decode::decode_integer(data, Some(0), Some(2199), true)?.0 as u16,
        ))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_integer(data, Some(0), Some(2199), true, self.0 as i128, false)
    }
}

impl AperCodec for OffsetToPointA {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        OffsetToPointA::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("OffsetToPointA"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("OffsetToPointA"))
    }
}
// PacketDelayBudget
#[derive(Clone, Debug)]
pub struct PacketDelayBudget(pub u16);

impl PacketDelayBudget {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        Ok(Self(
            aper::decode::decode_integer(data, Some(0), Some(1023), true)?.0 as u16,
        ))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_integer(data, Some(0), Some(1023), true, self.0 as i128, false)
    }
}

impl AperCodec for PacketDelayBudget {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        PacketDelayBudget::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("PacketDelayBudget"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("PacketDelayBudget"))
    }
}
// PacketErrorRate
#[derive(Clone, Debug)]
pub struct PacketErrorRate {
    pub per_scalar: PerScalar,
    pub per_exponent: PerExponent,
}

impl PacketErrorRate {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (_optionals, _extensions_present) =
            aper::decode::decode_sequence_header(data, true, 1)?;
        let per_scalar = PerScalar::decode(data)?;
        let per_exponent = PerExponent::decode(data)?;

        Ok(Self {
            per_scalar,
            per_exponent,
        })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(false);

        aper::encode::encode_sequence_header(data, true, &optionals, false)?;
        self.per_scalar.encode(data)?;
        self.per_exponent.encode(data)?;

        Ok(())
    }
}

impl AperCodec for PacketErrorRate {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        PacketErrorRate::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("PacketErrorRate"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("PacketErrorRate"))
    }
}
// PerScalar
#[derive(Clone, Debug)]
pub struct PerScalar(pub u8);

impl PerScalar {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        Ok(Self(
            aper::decode::decode_integer(data, Some(0), Some(9), true)?.0 as u8,
        ))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_integer(data, Some(0), Some(9), true, self.0 as i128, false)
    }
}

impl AperCodec for PerScalar {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        PerScalar::decode_inner(data).map_err(|e: AperCodecError| e.push_context("PerScalar"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("PerScalar"))
    }
}
// PerExponent
#[derive(Clone, Debug)]
pub struct PerExponent(pub u8);

impl PerExponent {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        Ok(Self(
            aper::decode::decode_integer(data, Some(0), Some(9), true)?.0 as u8,
        ))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_integer(data, Some(0), Some(9), true, self.0 as i128, false)
    }
}

impl AperCodec for PerExponent {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        PerExponent::decode_inner(data).map_err(|e: AperCodecError| e.push_context("PerExponent"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("PerExponent"))
    }
}
// PagingCellItem
#[derive(Clone, Debug)]
pub struct PagingCellItem {
    pub nrcgi: Nrcgi,
}

impl PagingCellItem {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (_optionals, _extensions_present) =
            aper::decode::decode_sequence_header(data, false, 1)?;
        let nrcgi = Nrcgi::decode(data)?;

        Ok(Self { nrcgi })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(false);

        aper::encode::encode_sequence_header(data, false, &optionals, false)?;
        self.nrcgi.encode(data)?;

        Ok(())
    }
}

impl AperCodec for PagingCellItem {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        PagingCellItem::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("PagingCellItem"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("PagingCellItem"))
    }
}
// PagingDrx
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum PagingDrx {
    V32,
    V64,
    V128,
    V256,
}

impl PagingDrx {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (idx, extended) = aper::decode::decode_enumerated(data, Some(0), Some(3), true)?;
        if extended {
            return Err(aper::AperCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| AperCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_enumerated(data, Some(0), Some(3), true, *self as i128, false)
    }
}

impl AperCodec for PagingDrx {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        PagingDrx::decode_inner(data).map_err(|e: AperCodecError| e.push_context("PagingDrx"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("PagingDrx"))
    }
}
// PagingIdentity
#[derive(Clone, Debug)]
pub enum PagingIdentity {
    RanuePagingIdentity(RanuePagingIdentity),
    CnuePagingIdentity(CnuePagingIdentity),
}

impl PagingIdentity {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (idx, extended) = aper::decode::decode_choice_idx(data, 0, 2, false)?;
        if extended {
            return Err(aper::AperCodecError::new(
                "CHOICE additions not implemented",
            ));
        }
        match idx {
            0 => Ok(Self::RanuePagingIdentity(RanuePagingIdentity::decode(
                data,
            )?)),
            1 => Ok(Self::CnuePagingIdentity(CnuePagingIdentity::decode(data)?)),
            2 => Err(AperCodecError::new(
                "Choice extension container not implemented",
            )),
            _ => Err(AperCodecError::new("Unknown choice idx")),
        }
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        match self {
            Self::RanuePagingIdentity(x) => {
                aper::encode::encode_choice_idx(data, 0, 2, false, 0, false)?;
                x.encode(data)
            }
            Self::CnuePagingIdentity(x) => {
                aper::encode::encode_choice_idx(data, 0, 2, false, 1, false)?;
                x.encode(data)
            }
        }
    }
}

impl AperCodec for PagingIdentity {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        PagingIdentity::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("PagingIdentity"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("PagingIdentity"))
    }
}
// PagingOrigin
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum PagingOrigin {
    Non3gpp,
}

impl PagingOrigin {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (idx, extended) = aper::decode::decode_enumerated(data, Some(0), Some(0), true)?;
        if extended {
            return Err(aper::AperCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| AperCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_enumerated(data, Some(0), Some(0), true, *self as i128, false)
    }
}

impl AperCodec for PagingOrigin {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        PagingOrigin::decode_inner(data).map_err(|e: AperCodecError| e.push_context("PagingOrigin"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("PagingOrigin"))
    }
}
// PagingPriority
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum PagingPriority {
    Priolevel1,
    Priolevel2,
    Priolevel3,
    Priolevel4,
    Priolevel5,
    Priolevel6,
    Priolevel7,
    Priolevel8,
}

impl PagingPriority {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (idx, extended) = aper::decode::decode_enumerated(data, Some(0), Some(7), true)?;
        if extended {
            return Err(aper::AperCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| AperCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_enumerated(data, Some(0), Some(7), true, *self as i128, false)
    }
}

impl AperCodec for PagingPriority {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        PagingPriority::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("PagingPriority"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("PagingPriority"))
    }
}
// RelativePathDelay
#[derive(Clone, Debug)]
pub enum RelativePathDelay {
    K0(u16),
    K1(u16),
    K2(u16),
    K3(u16),
    K4(u16),
    K5(u16),
}

impl RelativePathDelay {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (idx, extended) = aper::decode::decode_choice_idx(data, 0, 6, false)?;
        if extended {
            return Err(aper::AperCodecError::new(
                "CHOICE additions not implemented",
            ));
        }
        match idx {
            0 => Ok(Self::K0(
                aper::decode::decode_integer(data, Some(0), Some(16351), false)?.0 as u16,
            )),
            1 => Ok(Self::K1(
                aper::decode::decode_integer(data, Some(0), Some(8176), false)?.0 as u16,
            )),
            2 => Ok(Self::K2(
                aper::decode::decode_integer(data, Some(0), Some(4088), false)?.0 as u16,
            )),
            3 => Ok(Self::K3(
                aper::decode::decode_integer(data, Some(0), Some(2044), false)?.0 as u16,
            )),
            4 => Ok(Self::K4(
                aper::decode::decode_integer(data, Some(0), Some(1022), false)?.0 as u16,
            )),
            5 => Ok(Self::K5(
                aper::decode::decode_integer(data, Some(0), Some(511), false)?.0 as u16,
            )),
            6 => Err(AperCodecError::new(
                "Choice extension container not implemented",
            )),
            _ => Err(AperCodecError::new("Unknown choice idx")),
        }
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        match self {
            Self::K0(x) => {
                aper::encode::encode_choice_idx(data, 0, 6, false, 0, false)?;
                aper::encode::encode_integer(data, Some(0), Some(16351), false, *x as i128, false)
            }
            Self::K1(x) => {
                aper::encode::encode_choice_idx(data, 0, 6, false, 1, false)?;
                aper::encode::encode_integer(data, Some(0), Some(8176), false, *x as i128, false)
            }
            Self::K2(x) => {
                aper::encode::encode_choice_idx(data, 0, 6, false, 2, false)?;
                aper::encode::encode_integer(data, Some(0), Some(4088), false, *x as i128, false)
            }
            Self::K3(x) => {
                aper::encode::encode_choice_idx(data, 0, 6, false, 3, false)?;
                aper::encode::encode_integer(data, Some(0), Some(2044), false, *x as i128, false)
            }
            Self::K4(x) => {
                aper::encode::encode_choice_idx(data, 0, 6, false, 4, false)?;
                aper::encode::encode_integer(data, Some(0), Some(1022), false, *x as i128, false)
            }
            Self::K5(x) => {
                aper::encode::encode_choice_idx(data, 0, 6, false, 5, false)?;
                aper::encode::encode_integer(data, Some(0), Some(511), false, *x as i128, false)
            }
        }
    }
}

impl AperCodec for RelativePathDelay {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        RelativePathDelay::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("RelativePathDelay"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("RelativePathDelay"))
    }
}
// PathlossReferenceInfo
#[derive(Clone, Debug)]
pub struct PathlossReferenceInfo {
    pub pathloss_reference_signal: PathlossReferenceSignal,
}

impl PathlossReferenceInfo {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (_optionals, _extensions_present) =
            aper::decode::decode_sequence_header(data, false, 1)?;
        let pathloss_reference_signal = PathlossReferenceSignal::decode(data)?;

        Ok(Self {
            pathloss_reference_signal,
        })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(false);

        aper::encode::encode_sequence_header(data, false, &optionals, false)?;
        self.pathloss_reference_signal.encode(data)?;

        Ok(())
    }
}

impl AperCodec for PathlossReferenceInfo {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        PathlossReferenceInfo::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("PathlossReferenceInfo"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("PathlossReferenceInfo"))
    }
}
// PathlossReferenceSignal
#[derive(Clone, Debug)]
pub enum PathlossReferenceSignal {
    Ssb(Ssb),
    DlPrs(DlPrs),
}

impl PathlossReferenceSignal {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (idx, extended) = aper::decode::decode_choice_idx(data, 0, 2, false)?;
        if extended {
            return Err(aper::AperCodecError::new(
                "CHOICE additions not implemented",
            ));
        }
        match idx {
            0 => Ok(Self::Ssb(Ssb::decode(data)?)),
            1 => Ok(Self::DlPrs(DlPrs::decode(data)?)),
            2 => Err(AperCodecError::new(
                "Choice extension container not implemented",
            )),
            _ => Err(AperCodecError::new("Unknown choice idx")),
        }
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        match self {
            Self::Ssb(x) => {
                aper::encode::encode_choice_idx(data, 0, 2, false, 0, false)?;
                x.encode(data)
            }
            Self::DlPrs(x) => {
                aper::encode::encode_choice_idx(data, 0, 2, false, 1, false)?;
                x.encode(data)
            }
        }
    }
}

impl AperCodec for PathlossReferenceSignal {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        PathlossReferenceSignal::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("PathlossReferenceSignal"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("PathlossReferenceSignal"))
    }
}
// Pc5QosFlowIdentifier
#[derive(Clone, Debug)]
pub struct Pc5QosFlowIdentifier(pub u16);

impl Pc5QosFlowIdentifier {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        Ok(Self(
            aper::decode::decode_integer(data, Some(1), Some(2048), false)?.0 as u16,
        ))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_integer(data, Some(1), Some(2048), false, self.0 as i128, false)
    }
}

impl AperCodec for Pc5QosFlowIdentifier {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        Pc5QosFlowIdentifier::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("Pc5QosFlowIdentifier"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("Pc5QosFlowIdentifier"))
    }
}
// Pc5QosCharacteristics
#[derive(Clone, Debug)]
pub enum Pc5QosCharacteristics {
    NonDynamicPqi(NonDynamicPqiDescriptor),
    DynamicPqi(DynamicPqiDescriptor),
}

impl Pc5QosCharacteristics {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (idx, extended) = aper::decode::decode_choice_idx(data, 0, 2, false)?;
        if extended {
            return Err(aper::AperCodecError::new(
                "CHOICE additions not implemented",
            ));
        }
        match idx {
            0 => Ok(Self::NonDynamicPqi(NonDynamicPqiDescriptor::decode(data)?)),
            1 => Ok(Self::DynamicPqi(DynamicPqiDescriptor::decode(data)?)),
            2 => Err(AperCodecError::new(
                "Choice extension container not implemented",
            )),
            _ => Err(AperCodecError::new("Unknown choice idx")),
        }
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        match self {
            Self::NonDynamicPqi(x) => {
                aper::encode::encode_choice_idx(data, 0, 2, false, 0, false)?;
                x.encode(data)
            }
            Self::DynamicPqi(x) => {
                aper::encode::encode_choice_idx(data, 0, 2, false, 1, false)?;
                x.encode(data)
            }
        }
    }
}

impl AperCodec for Pc5QosCharacteristics {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        Pc5QosCharacteristics::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("Pc5QosCharacteristics"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("Pc5QosCharacteristics"))
    }
}
// Pc5QosParameters
#[derive(Clone, Debug)]
pub struct Pc5QosParameters {
    pub pc5_qos_characteristics: Pc5QosCharacteristics,
    pub pc5_qos_flow_bit_rates: Option<Pc5FlowBitRates>,
}

impl Pc5QosParameters {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (optionals, _extensions_present) = aper::decode::decode_sequence_header(data, true, 2)?;
        let pc5_qos_characteristics = Pc5QosCharacteristics::decode(data)?;
        let pc5_qos_flow_bit_rates = if optionals[0] {
            Some(Pc5FlowBitRates::decode(data)?)
        } else {
            None
        };

        Ok(Self {
            pc5_qos_characteristics,
            pc5_qos_flow_bit_rates,
        })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(self.pc5_qos_flow_bit_rates.is_some());
        optionals.push(false);

        aper::encode::encode_sequence_header(data, true, &optionals, false)?;
        self.pc5_qos_characteristics.encode(data)?;
        if let Some(x) = &self.pc5_qos_flow_bit_rates {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl AperCodec for Pc5QosParameters {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        Pc5QosParameters::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("Pc5QosParameters"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("Pc5QosParameters"))
    }
}
// Pc5FlowBitRates
#[derive(Clone, Debug)]
pub struct Pc5FlowBitRates {
    pub guaranteed_flow_bit_rate: BitRate,
    pub maximum_flow_bit_rate: BitRate,
}

impl Pc5FlowBitRates {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (_optionals, _extensions_present) =
            aper::decode::decode_sequence_header(data, true, 1)?;
        let guaranteed_flow_bit_rate = BitRate::decode(data)?;
        let maximum_flow_bit_rate = BitRate::decode(data)?;

        Ok(Self {
            guaranteed_flow_bit_rate,
            maximum_flow_bit_rate,
        })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(false);

        aper::encode::encode_sequence_header(data, true, &optionals, false)?;
        self.guaranteed_flow_bit_rate.encode(data)?;
        self.maximum_flow_bit_rate.encode(data)?;

        Ok(())
    }
}

impl AperCodec for Pc5FlowBitRates {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        Pc5FlowBitRates::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("Pc5FlowBitRates"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("Pc5FlowBitRates"))
    }
}
// PdcchBlindDetectionScg
#[derive(Clone, Debug)]
pub struct PdcchBlindDetectionScg(pub Vec<u8>);

impl PdcchBlindDetectionScg {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        Ok(Self(aper::decode::decode_octetstring(
            data, None, None, false,
        )?))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_octetstring(data, None, None, false, &self.0, false)
    }
}

impl AperCodec for PdcchBlindDetectionScg {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        PdcchBlindDetectionScg::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("PdcchBlindDetectionScg"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("PdcchBlindDetectionScg"))
    }
}
// PdcpSn
#[derive(Clone, Debug)]
pub struct PdcpSn(pub u16);

impl PdcpSn {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        Ok(Self(
            aper::decode::decode_integer(data, Some(0), Some(4095), false)?.0 as u16,
        ))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_integer(data, Some(0), Some(4095), false, self.0 as i128, false)
    }
}

impl AperCodec for PdcpSn {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        PdcpSn::decode_inner(data).map_err(|e: AperCodecError| e.push_context("PdcpSn"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("PdcpSn"))
    }
}
// PdcpsnLength
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum PdcpsnLength {
    TwelveBits,
    EighteenBits,
}

impl PdcpsnLength {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (idx, extended) = aper::decode::decode_enumerated(data, Some(0), Some(1), true)?;
        if extended {
            return Err(aper::AperCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| AperCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_enumerated(data, Some(0), Some(1), true, *self as i128, false)
    }
}

impl AperCodec for PdcpsnLength {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        PdcpsnLength::decode_inner(data).map_err(|e: AperCodecError| e.push_context("PdcpsnLength"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("PdcpsnLength"))
    }
}
// PduSessionId
#[derive(Clone, Debug)]
pub struct PduSessionId(pub u8);

impl PduSessionId {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        Ok(Self(
            aper::decode::decode_integer(data, Some(0), Some(255), false)?.0 as u8,
        ))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_integer(data, Some(0), Some(255), false, self.0 as i128, false)
    }
}

impl AperCodec for PduSessionId {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        PduSessionId::decode_inner(data).map_err(|e: AperCodecError| e.push_context("PduSessionId"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("PduSessionId"))
    }
}
// ReportingPeriodicityValue
#[derive(Clone, Debug)]
pub struct ReportingPeriodicityValue(pub u16);

impl ReportingPeriodicityValue {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        Ok(Self(
            aper::decode::decode_integer(data, Some(0), Some(512), true)?.0 as u16,
        ))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_integer(data, Some(0), Some(512), true, self.0 as i128, false)
    }
}

impl AperCodec for ReportingPeriodicityValue {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        ReportingPeriodicityValue::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("ReportingPeriodicityValue"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("ReportingPeriodicityValue"))
    }
}
// Periodicity
#[derive(Clone, Debug)]
pub struct Periodicity(pub u32);

impl Periodicity {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        Ok(Self(
            aper::decode::decode_integer(data, Some(0), Some(640000), true)?.0 as u32,
        ))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_integer(data, Some(0), Some(640000), true, self.0 as i128, false)
    }
}

impl AperCodec for Periodicity {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        Periodicity::decode_inner(data).map_err(|e: AperCodecError| e.push_context("Periodicity"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("Periodicity"))
    }
}
// PeriodicitySrs
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum PeriodicitySrs {
    Ms0p125,
    Ms0p25,
    Ms0p5,
    Ms0p625,
    Ms1,
    Ms1p25,
    Ms2,
    Ms2p5,
    Ms4,
    Ms5,
    Ms8,
    Ms10,
    Ms16,
    Ms20,
    Ms32,
    Ms40,
    Ms64,
    Ms80,
    Ms160,
    Ms320,
    Ms640,
    Ms1280,
    Ms2560,
    Ms5120,
    Ms10240,
}

impl PeriodicitySrs {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (idx, extended) = aper::decode::decode_enumerated(data, Some(0), Some(24), true)?;
        if extended {
            return Err(aper::AperCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| AperCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_enumerated(data, Some(0), Some(24), true, *self as i128, false)
    }
}

impl AperCodec for PeriodicitySrs {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        PeriodicitySrs::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("PeriodicitySrs"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("PeriodicitySrs"))
    }
}
// PeriodicityList
#[derive(Clone, Debug)]
pub struct PeriodicityList(pub Vec<PeriodicityListItem>);

impl PeriodicityList {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        Ok(Self({
            let length = aper::decode::decode_length_determinent(data, Some(1), Some(16), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(PeriodicityListItem::decode(data)?);
            }
            items
        }))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_length_determinent(data, Some(1), Some(16), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl AperCodec for PeriodicityList {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        PeriodicityList::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("PeriodicityList"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("PeriodicityList"))
    }
}
// PeriodicityListItem
#[derive(Clone, Debug)]
pub struct PeriodicityListItem {
    pub periodicity_srs: PeriodicitySrs,
}

impl PeriodicityListItem {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (_optionals, _extensions_present) =
            aper::decode::decode_sequence_header(data, false, 1)?;
        let periodicity_srs = PeriodicitySrs::decode(data)?;

        Ok(Self { periodicity_srs })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(false);

        aper::encode::encode_sequence_header(data, false, &optionals, false)?;
        self.periodicity_srs.encode(data)?;

        Ok(())
    }
}

impl AperCodec for PeriodicityListItem {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        PeriodicityListItem::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("PeriodicityListItem"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("PeriodicityListItem"))
    }
}
// Permutation
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum Permutation {
    Dfu,
    Ufd,
}

impl Permutation {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (idx, extended) = aper::decode::decode_enumerated(data, Some(0), Some(1), true)?;
        if extended {
            return Err(aper::AperCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| AperCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_enumerated(data, Some(0), Some(1), true, *self as i128, false)
    }
}

impl AperCodec for Permutation {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        Permutation::decode_inner(data).map_err(|e: AperCodecError| e.push_context("Permutation"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("Permutation"))
    }
}
// PhInfoMcg
#[derive(Clone, Debug)]
pub struct PhInfoMcg(pub Vec<u8>);

impl PhInfoMcg {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        Ok(Self(aper::decode::decode_octetstring(
            data, None, None, false,
        )?))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_octetstring(data, None, None, false, &self.0, false)
    }
}

impl AperCodec for PhInfoMcg {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        PhInfoMcg::decode_inner(data).map_err(|e: AperCodecError| e.push_context("PhInfoMcg"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("PhInfoMcg"))
    }
}
// PhInfoScg
#[derive(Clone, Debug)]
pub struct PhInfoScg(pub Vec<u8>);

impl PhInfoScg {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        Ok(Self(aper::decode::decode_octetstring(
            data, None, None, false,
        )?))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_octetstring(data, None, None, false, &self.0, false)
    }
}

impl AperCodec for PhInfoScg {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        PhInfoScg::decode_inner(data).map_err(|e: AperCodecError| e.push_context("PhInfoScg"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("PhInfoScg"))
    }
}
// PlmnIdentity
#[derive(Clone, Debug)]
pub struct PlmnIdentity(pub Vec<u8>);

impl PlmnIdentity {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        Ok(Self(aper::decode::decode_octetstring(
            data,
            Some(3),
            Some(3),
            false,
        )?))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_octetstring(data, Some(3), Some(3), false, &self.0, false)
    }
}

impl AperCodec for PlmnIdentity {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        PlmnIdentity::decode_inner(data).map_err(|e: AperCodecError| e.push_context("PlmnIdentity"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("PlmnIdentity"))
    }
}
// PortNumber
#[derive(Clone, Debug)]
pub struct PortNumber(pub BitString);

impl PortNumber {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        Ok(Self(aper::decode::decode_bitstring(
            data,
            Some(16),
            Some(16),
            false,
        )?))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_bitstring(data, Some(16), Some(16), false, &self.0, false)
    }
}

impl AperCodec for PortNumber {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        PortNumber::decode_inner(data).map_err(|e: AperCodecError| e.push_context("PortNumber"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("PortNumber"))
    }
}
// PosAssistanceInformation
#[derive(Clone, Debug)]
pub struct PosAssistanceInformation(pub Vec<u8>);

impl PosAssistanceInformation {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        Ok(Self(aper::decode::decode_octetstring(
            data, None, None, false,
        )?))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_octetstring(data, None, None, false, &self.0, false)
    }
}

impl AperCodec for PosAssistanceInformation {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        PosAssistanceInformation::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("PosAssistanceInformation"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("PosAssistanceInformation"))
    }
}
// PosAssistanceInformationFailureList
#[derive(Clone, Debug)]
pub struct PosAssistanceInformationFailureList(pub Vec<u8>);

impl PosAssistanceInformationFailureList {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        Ok(Self(aper::decode::decode_octetstring(
            data, None, None, false,
        )?))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_octetstring(data, None, None, false, &self.0, false)
    }
}

impl AperCodec for PosAssistanceInformationFailureList {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        PosAssistanceInformationFailureList::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("PosAssistanceInformationFailureList"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("PosAssistanceInformationFailureList"))
    }
}
// PosBroadcast
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum PosBroadcast {
    Start,
    Stop,
}

impl PosBroadcast {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (idx, extended) = aper::decode::decode_enumerated(data, Some(0), Some(1), true)?;
        if extended {
            return Err(aper::AperCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| AperCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_enumerated(data, Some(0), Some(1), true, *self as i128, false)
    }
}

impl AperCodec for PosBroadcast {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        PosBroadcast::decode_inner(data).map_err(|e: AperCodecError| e.push_context("PosBroadcast"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("PosBroadcast"))
    }
}
// PositioningBroadcastCells
#[derive(Clone, Debug)]
pub struct PositioningBroadcastCells(pub Vec<Nrcgi>);

impl PositioningBroadcastCells {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        Ok(Self({
            let length =
                aper::decode::decode_length_determinent(data, Some(1), Some(16384), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(Nrcgi::decode(data)?);
            }
            items
        }))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_length_determinent(data, Some(1), Some(16384), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl AperCodec for PositioningBroadcastCells {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        PositioningBroadcastCells::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("PositioningBroadcastCells"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("PositioningBroadcastCells"))
    }
}
// MeasurementPeriodicity
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum MeasurementPeriodicity {
    Ms120,
    Ms240,
    Ms480,
    Ms640,
    Ms1024,
    Ms2048,
    Ms5120,
    Ms10240,
    Min1,
    Min6,
    Min12,
    Min30,
}

impl MeasurementPeriodicity {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (idx, extended) = aper::decode::decode_enumerated(data, Some(0), Some(11), true)?;
        if extended {
            return Err(aper::AperCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| AperCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_enumerated(data, Some(0), Some(11), true, *self as i128, false)
    }
}

impl AperCodec for MeasurementPeriodicity {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        MeasurementPeriodicity::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("MeasurementPeriodicity"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("MeasurementPeriodicity"))
    }
}
// PosMeasurementQuantities
#[derive(Clone, Debug)]
pub struct PosMeasurementQuantities(pub Vec<PosMeasurementQuantitiesItem>);

impl PosMeasurementQuantities {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        Ok(Self({
            let length =
                aper::decode::decode_length_determinent(data, Some(1), Some(16384), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(PosMeasurementQuantitiesItem::decode(data)?);
            }
            items
        }))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_length_determinent(data, Some(1), Some(16384), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl AperCodec for PosMeasurementQuantities {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        PosMeasurementQuantities::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("PosMeasurementQuantities"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("PosMeasurementQuantities"))
    }
}
// PosMeasurementQuantitiesItem
#[derive(Clone, Debug)]
pub struct PosMeasurementQuantitiesItem {
    pub pos_measurement_type: PosMeasurementType,
    pub timing_reporting_granularity_factor: Option<u8>,
}

impl PosMeasurementQuantitiesItem {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (optionals, _extensions_present) =
            aper::decode::decode_sequence_header(data, false, 2)?;
        let pos_measurement_type = PosMeasurementType::decode(data)?;
        let timing_reporting_granularity_factor = if optionals[0] {
            Some(aper::decode::decode_integer(data, Some(0), Some(5), false)?.0 as u8)
        } else {
            None
        };

        Ok(Self {
            pos_measurement_type,
            timing_reporting_granularity_factor,
        })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(self.timing_reporting_granularity_factor.is_some());
        optionals.push(false);

        aper::encode::encode_sequence_header(data, false, &optionals, false)?;
        self.pos_measurement_type.encode(data)?;
        if let Some(x) = &self.timing_reporting_granularity_factor {
            aper::encode::encode_integer(data, Some(0), Some(5), false, *x as i128, false)?;
        }

        Ok(())
    }
}

impl AperCodec for PosMeasurementQuantitiesItem {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        PosMeasurementQuantitiesItem::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("PosMeasurementQuantitiesItem"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("PosMeasurementQuantitiesItem"))
    }
}
// PosMeasurementResult
#[derive(Clone, Debug)]
pub struct PosMeasurementResult(pub Vec<PosMeasurementResultItem>);

impl PosMeasurementResult {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        Ok(Self({
            let length =
                aper::decode::decode_length_determinent(data, Some(1), Some(16384), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(PosMeasurementResultItem::decode(data)?);
            }
            items
        }))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_length_determinent(data, Some(1), Some(16384), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl AperCodec for PosMeasurementResult {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        PosMeasurementResult::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("PosMeasurementResult"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("PosMeasurementResult"))
    }
}
// PosMeasurementResultItem
#[derive(Clone, Debug)]
pub struct PosMeasurementResultItem {
    pub measured_results_value: MeasuredResultsValue,
    pub time_stamp: TimeStamp,
    pub measurement_quality: Option<TrpMeasurementQuality>,
    pub measurement_beam_info: Option<MeasurementBeamInfo>,
}

impl PosMeasurementResultItem {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (optionals, _extensions_present) =
            aper::decode::decode_sequence_header(data, false, 3)?;
        let measured_results_value = MeasuredResultsValue::decode(data)?;
        let time_stamp = TimeStamp::decode(data)?;
        let measurement_quality = if optionals[0] {
            Some(TrpMeasurementQuality::decode(data)?)
        } else {
            None
        };
        let measurement_beam_info = if optionals[1] {
            Some(MeasurementBeamInfo::decode(data)?)
        } else {
            None
        };

        Ok(Self {
            measured_results_value,
            time_stamp,
            measurement_quality,
            measurement_beam_info,
        })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(self.measurement_quality.is_some());
        optionals.push(self.measurement_beam_info.is_some());
        optionals.push(false);

        aper::encode::encode_sequence_header(data, false, &optionals, false)?;
        self.measured_results_value.encode(data)?;
        self.time_stamp.encode(data)?;
        if let Some(x) = &self.measurement_quality {
            x.encode(data)?;
        }
        if let Some(x) = &self.measurement_beam_info {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl AperCodec for PosMeasurementResultItem {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        PosMeasurementResultItem::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("PosMeasurementResultItem"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("PosMeasurementResultItem"))
    }
}
// PosMeasurementResultList
#[derive(Clone, Debug)]
pub struct PosMeasurementResultList(pub Vec<PosMeasurementResultListItem>);

impl PosMeasurementResultList {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        Ok(Self({
            let length = aper::decode::decode_length_determinent(data, Some(1), Some(64), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(PosMeasurementResultListItem::decode(data)?);
            }
            items
        }))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_length_determinent(data, Some(1), Some(64), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl AperCodec for PosMeasurementResultList {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        PosMeasurementResultList::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("PosMeasurementResultList"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("PosMeasurementResultList"))
    }
}
// PosMeasurementResultListItem
#[derive(Clone, Debug)]
pub struct PosMeasurementResultListItem {
    pub pos_measurement_result: PosMeasurementResult,
    pub trpid: Trpid,
}

impl PosMeasurementResultListItem {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (_optionals, _extensions_present) =
            aper::decode::decode_sequence_header(data, false, 1)?;
        let pos_measurement_result = PosMeasurementResult::decode(data)?;
        let trpid = Trpid::decode(data)?;

        Ok(Self {
            pos_measurement_result,
            trpid,
        })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(false);

        aper::encode::encode_sequence_header(data, false, &optionals, false)?;
        self.pos_measurement_result.encode(data)?;
        self.trpid.encode(data)?;

        Ok(())
    }
}

impl AperCodec for PosMeasurementResultListItem {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        PosMeasurementResultListItem::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("PosMeasurementResultListItem"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("PosMeasurementResultListItem"))
    }
}
// PosMeasurementType
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum PosMeasurementType {
    GnbRxTx,
    UlSrsRsrp,
    UlAoa,
    UlRtoa,
}

impl PosMeasurementType {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (idx, extended) = aper::decode::decode_enumerated(data, Some(0), Some(3), true)?;
        if extended {
            return Err(aper::AperCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| AperCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_enumerated(data, Some(0), Some(3), true, *self as i128, false)
    }
}

impl AperCodec for PosMeasurementType {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        PosMeasurementType::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("PosMeasurementType"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("PosMeasurementType"))
    }
}
// PosReportCharacteristics
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum PosReportCharacteristics {
    Ondemand,
    Periodic,
}

impl PosReportCharacteristics {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (idx, extended) = aper::decode::decode_enumerated(data, Some(0), Some(1), true)?;
        if extended {
            return Err(aper::AperCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| AperCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_enumerated(data, Some(0), Some(1), true, *self as i128, false)
    }
}

impl AperCodec for PosReportCharacteristics {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        PosReportCharacteristics::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("PosReportCharacteristics"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("PosReportCharacteristics"))
    }
}
// PosResourceSetType
#[derive(Clone, Debug)]
pub enum PosResourceSetType {
    Periodic(PosResourceSetTypePr),
    SemiPersistent(PosResourceSetTypeSp),
    Aperiodic(PosResourceSetTypeAp),
}

impl PosResourceSetType {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (idx, extended) = aper::decode::decode_choice_idx(data, 0, 3, false)?;
        if extended {
            return Err(aper::AperCodecError::new(
                "CHOICE additions not implemented",
            ));
        }
        match idx {
            0 => Ok(Self::Periodic(PosResourceSetTypePr::decode(data)?)),
            1 => Ok(Self::SemiPersistent(PosResourceSetTypeSp::decode(data)?)),
            2 => Ok(Self::Aperiodic(PosResourceSetTypeAp::decode(data)?)),
            3 => Err(AperCodecError::new(
                "Choice extension container not implemented",
            )),
            _ => Err(AperCodecError::new("Unknown choice idx")),
        }
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        match self {
            Self::Periodic(x) => {
                aper::encode::encode_choice_idx(data, 0, 3, false, 0, false)?;
                x.encode(data)
            }
            Self::SemiPersistent(x) => {
                aper::encode::encode_choice_idx(data, 0, 3, false, 1, false)?;
                x.encode(data)
            }
            Self::Aperiodic(x) => {
                aper::encode::encode_choice_idx(data, 0, 3, false, 2, false)?;
                x.encode(data)
            }
        }
    }
}

impl AperCodec for PosResourceSetType {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        PosResourceSetType::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("PosResourceSetType"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("PosResourceSetType"))
    }
}
// PosResourceSetTypePr
#[derive(Clone, Debug)]
pub struct PosResourceSetTypePr {
    pub posperiodic_set: PosperiodicSet,
}

impl PosResourceSetTypePr {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (_optionals, _extensions_present) =
            aper::decode::decode_sequence_header(data, false, 1)?;
        let posperiodic_set = PosperiodicSet::decode(data)?;

        Ok(Self { posperiodic_set })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(false);

        aper::encode::encode_sequence_header(data, false, &optionals, false)?;
        self.posperiodic_set.encode(data)?;

        Ok(())
    }
}

impl AperCodec for PosResourceSetTypePr {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        PosResourceSetTypePr::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("PosResourceSetTypePr"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("PosResourceSetTypePr"))
    }
}
// PosResourceSetTypeSp
#[derive(Clone, Debug)]
pub struct PosResourceSetTypeSp {
    pub possemi_persistent_set: PossemiPersistentSet,
}

impl PosResourceSetTypeSp {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (_optionals, _extensions_present) =
            aper::decode::decode_sequence_header(data, false, 1)?;
        let possemi_persistent_set = PossemiPersistentSet::decode(data)?;

        Ok(Self {
            possemi_persistent_set,
        })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(false);

        aper::encode::encode_sequence_header(data, false, &optionals, false)?;
        self.possemi_persistent_set.encode(data)?;

        Ok(())
    }
}

impl AperCodec for PosResourceSetTypeSp {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        PosResourceSetTypeSp::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("PosResourceSetTypeSp"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("PosResourceSetTypeSp"))
    }
}
// PosResourceSetTypeAp
#[derive(Clone, Debug)]
pub struct PosResourceSetTypeAp {
    pub srs_resource_trigger_list: u8,
}

impl PosResourceSetTypeAp {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (_optionals, _extensions_present) =
            aper::decode::decode_sequence_header(data, false, 1)?;
        let srs_resource_trigger_list =
            aper::decode::decode_integer(data, Some(1), Some(3), false)?.0 as u8;

        Ok(Self {
            srs_resource_trigger_list,
        })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(false);

        aper::encode::encode_sequence_header(data, false, &optionals, false)?;
        aper::encode::encode_integer(
            data,
            Some(1),
            Some(3),
            false,
            self.srs_resource_trigger_list as i128,
            false,
        )?;

        Ok(())
    }
}

impl AperCodec for PosResourceSetTypeAp {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        PosResourceSetTypeAp::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("PosResourceSetTypeAp"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("PosResourceSetTypeAp"))
    }
}
// PosSrsResourceIdList
#[derive(Clone, Debug)]
pub struct PosSrsResourceIdList(pub Vec<SrsPosResourceId>);

impl PosSrsResourceIdList {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        Ok(Self({
            let length = aper::decode::decode_length_determinent(data, Some(1), Some(16), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(SrsPosResourceId::decode(data)?);
            }
            items
        }))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_length_determinent(data, Some(1), Some(16), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl AperCodec for PosSrsResourceIdList {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        PosSrsResourceIdList::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("PosSrsResourceIdList"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("PosSrsResourceIdList"))
    }
}
// PosSrsResourceItem
#[derive(Clone, Debug)]
pub struct PosSrsResourceItem {
    pub srs_pos_resource_id: SrsPosResourceId,
    pub transmission_comb_pos: TransmissionCombPos,
    pub start_position: u8,
    pub nrof_symbols: NrofSymbols,
    pub freq_domain_shift: u16,
    pub c_srs: u8,
    pub group_or_sequence_hopping: GroupOrSequenceHopping,
    pub resource_type_pos: ResourceTypePos,
    pub sequence_id: u16,
    pub spatial_relation_pos: Option<SpatialRelationPos>,
}

impl PosSrsResourceItem {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (optionals, _extensions_present) =
            aper::decode::decode_sequence_header(data, false, 2)?;
        let srs_pos_resource_id = SrsPosResourceId::decode(data)?;
        let transmission_comb_pos = TransmissionCombPos::decode(data)?;
        let start_position = aper::decode::decode_integer(data, Some(0), Some(13), false)?.0 as u8;
        let nrof_symbols = NrofSymbols::decode(data)?;
        let freq_domain_shift =
            aper::decode::decode_integer(data, Some(0), Some(268), false)?.0 as u16;
        let c_srs = aper::decode::decode_integer(data, Some(0), Some(63), false)?.0 as u8;
        let group_or_sequence_hopping = GroupOrSequenceHopping::decode(data)?;
        let resource_type_pos = ResourceTypePos::decode(data)?;
        let sequence_id = aper::decode::decode_integer(data, Some(0), Some(65535), false)?.0 as u16;
        let spatial_relation_pos = if optionals[0] {
            Some(SpatialRelationPos::decode(data)?)
        } else {
            None
        };

        Ok(Self {
            srs_pos_resource_id,
            transmission_comb_pos,
            start_position,
            nrof_symbols,
            freq_domain_shift,
            c_srs,
            group_or_sequence_hopping,
            resource_type_pos,
            sequence_id,
            spatial_relation_pos,
        })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(self.spatial_relation_pos.is_some());
        optionals.push(false);

        aper::encode::encode_sequence_header(data, false, &optionals, false)?;
        self.srs_pos_resource_id.encode(data)?;
        self.transmission_comb_pos.encode(data)?;
        aper::encode::encode_integer(
            data,
            Some(0),
            Some(13),
            false,
            self.start_position as i128,
            false,
        )?;
        self.nrof_symbols.encode(data)?;
        aper::encode::encode_integer(
            data,
            Some(0),
            Some(268),
            false,
            self.freq_domain_shift as i128,
            false,
        )?;
        aper::encode::encode_integer(data, Some(0), Some(63), false, self.c_srs as i128, false)?;
        self.group_or_sequence_hopping.encode(data)?;
        self.resource_type_pos.encode(data)?;
        aper::encode::encode_integer(
            data,
            Some(0),
            Some(65535),
            false,
            self.sequence_id as i128,
            false,
        )?;
        if let Some(x) = &self.spatial_relation_pos {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl AperCodec for PosSrsResourceItem {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        PosSrsResourceItem::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("PosSrsResourceItem"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("PosSrsResourceItem"))
    }
}
// PosSrsResourceList
#[derive(Clone, Debug)]
pub struct PosSrsResourceList(pub Vec<PosSrsResourceItem>);

impl PosSrsResourceList {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        Ok(Self({
            let length = aper::decode::decode_length_determinent(data, Some(1), Some(64), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(PosSrsResourceItem::decode(data)?);
            }
            items
        }))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_length_determinent(data, Some(1), Some(64), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl AperCodec for PosSrsResourceList {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        PosSrsResourceList::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("PosSrsResourceList"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("PosSrsResourceList"))
    }
}
// PosSrsResourceSetItem
#[derive(Clone, Debug)]
pub struct PosSrsResourceSetItem {
    pub possrs_resource_set_id: u8,
    pub poss_rs_resource_id_list: PosSrsResourceIdList,
    pub posresource_set_type: PosResourceSetType,
}

impl PosSrsResourceSetItem {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (_optionals, _extensions_present) =
            aper::decode::decode_sequence_header(data, false, 1)?;
        let possrs_resource_set_id =
            aper::decode::decode_integer(data, Some(0), Some(15), false)?.0 as u8;
        let poss_rs_resource_id_list = PosSrsResourceIdList::decode(data)?;
        let posresource_set_type = PosResourceSetType::decode(data)?;

        Ok(Self {
            possrs_resource_set_id,
            poss_rs_resource_id_list,
            posresource_set_type,
        })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(false);

        aper::encode::encode_sequence_header(data, false, &optionals, false)?;
        aper::encode::encode_integer(
            data,
            Some(0),
            Some(15),
            false,
            self.possrs_resource_set_id as i128,
            false,
        )?;
        self.poss_rs_resource_id_list.encode(data)?;
        self.posresource_set_type.encode(data)?;

        Ok(())
    }
}

impl AperCodec for PosSrsResourceSetItem {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        PosSrsResourceSetItem::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("PosSrsResourceSetItem"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("PosSrsResourceSetItem"))
    }
}
// PosSrsResourceSetList
#[derive(Clone, Debug)]
pub struct PosSrsResourceSetList(pub Vec<PosSrsResourceSetItem>);

impl PosSrsResourceSetList {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        Ok(Self({
            let length = aper::decode::decode_length_determinent(data, Some(1), Some(16), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(PosSrsResourceSetItem::decode(data)?);
            }
            items
        }))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_length_determinent(data, Some(1), Some(16), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl AperCodec for PosSrsResourceSetList {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        PosSrsResourceSetList::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("PosSrsResourceSetList"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("PosSrsResourceSetList"))
    }
}
// PrimaryPathIndication
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum PrimaryPathIndication {
    True,
    False,
}

impl PrimaryPathIndication {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (idx, extended) = aper::decode::decode_enumerated(data, Some(0), Some(1), true)?;
        if extended {
            return Err(aper::AperCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| AperCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_enumerated(data, Some(0), Some(1), true, *self as i128, false)
    }
}

impl AperCodec for PrimaryPathIndication {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        PrimaryPathIndication::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("PrimaryPathIndication"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("PrimaryPathIndication"))
    }
}
// PreEmptionCapability
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum PreEmptionCapability {
    ShallNotTriggerPreEmption,
    MayTriggerPreEmption,
}

impl PreEmptionCapability {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (idx, extended) = aper::decode::decode_enumerated(data, Some(0), Some(1), false)?;
        if extended {
            return Err(aper::AperCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| AperCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_enumerated(data, Some(0), Some(1), false, *self as i128, false)
    }
}

impl AperCodec for PreEmptionCapability {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        PreEmptionCapability::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("PreEmptionCapability"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("PreEmptionCapability"))
    }
}
// PreEmptionVulnerability
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum PreEmptionVulnerability {
    NotPreEmptable,
    PreEmptable,
}

impl PreEmptionVulnerability {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (idx, extended) = aper::decode::decode_enumerated(data, Some(0), Some(1), false)?;
        if extended {
            return Err(aper::AperCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| AperCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_enumerated(data, Some(0), Some(1), false, *self as i128, false)
    }
}

impl AperCodec for PreEmptionVulnerability {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        PreEmptionVulnerability::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("PreEmptionVulnerability"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("PreEmptionVulnerability"))
    }
}
// PriorityLevel
#[derive(Clone, Debug)]
pub struct PriorityLevel(pub u8);

impl PriorityLevel {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        Ok(Self(
            aper::decode::decode_integer(data, Some(0), Some(15), false)?.0 as u8,
        ))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_integer(data, Some(0), Some(15), false, self.0 as i128, false)
    }
}

impl AperCodec for PriorityLevel {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        PriorityLevel::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("PriorityLevel"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("PriorityLevel"))
    }
}
// ProtectedEutraResourceIndication
#[derive(Clone, Debug)]
pub struct ProtectedEutraResourceIndication(pub Vec<u8>);

impl ProtectedEutraResourceIndication {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        Ok(Self(aper::decode::decode_octetstring(
            data, None, None, false,
        )?))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_octetstring(data, None, None, false, &self.0, false)
    }
}

impl AperCodec for ProtectedEutraResourceIndication {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        ProtectedEutraResourceIndication::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("ProtectedEutraResourceIndication"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("ProtectedEutraResourceIndication"))
    }
}
// ProtectedEutraResourcesItem
#[derive(Clone, Debug)]
pub struct ProtectedEutraResourcesItem {
    pub spectrum_sharing_group_id: SpectrumSharingGroupId,
    pub eutra_cells_list: EutraCellsList,
}

impl ProtectedEutraResourcesItem {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (_optionals, _extensions_present) =
            aper::decode::decode_sequence_header(data, false, 1)?;
        let spectrum_sharing_group_id = SpectrumSharingGroupId::decode(data)?;
        let eutra_cells_list = EutraCellsList::decode(data)?;

        Ok(Self {
            spectrum_sharing_group_id,
            eutra_cells_list,
        })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(false);

        aper::encode::encode_sequence_header(data, false, &optionals, false)?;
        self.spectrum_sharing_group_id.encode(data)?;
        self.eutra_cells_list.encode(data)?;

        Ok(())
    }
}

impl AperCodec for ProtectedEutraResourcesItem {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        ProtectedEutraResourcesItem::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("ProtectedEutraResourcesItem"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("ProtectedEutraResourcesItem"))
    }
}
// PrsConfiguration
#[derive(Clone, Debug)]
pub struct PrsConfiguration {
    pub prs_resource_set_list: PrsResourceSetList,
}

impl PrsConfiguration {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (_optionals, _extensions_present) =
            aper::decode::decode_sequence_header(data, false, 1)?;
        let prs_resource_set_list = PrsResourceSetList::decode(data)?;

        Ok(Self {
            prs_resource_set_list,
        })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(false);

        aper::encode::encode_sequence_header(data, false, &optionals, false)?;
        self.prs_resource_set_list.encode(data)?;

        Ok(())
    }
}

impl AperCodec for PrsConfiguration {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        PrsConfiguration::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("PrsConfiguration"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("PrsConfiguration"))
    }
}
// PrsInformationPos
#[derive(Clone, Debug)]
pub struct PrsInformationPos {
    pub prs_id_pos: u8,
    pub prs_resource_set_id_pos: u8,
    pub prs_resource_id_pos: Option<u8>,
}

impl PrsInformationPos {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (optionals, _extensions_present) =
            aper::decode::decode_sequence_header(data, false, 2)?;
        let prs_id_pos = aper::decode::decode_integer(data, Some(0), Some(255), false)?.0 as u8;
        let prs_resource_set_id_pos =
            aper::decode::decode_integer(data, Some(0), Some(7), false)?.0 as u8;
        let prs_resource_id_pos = if optionals[0] {
            Some(aper::decode::decode_integer(data, Some(0), Some(63), false)?.0 as u8)
        } else {
            None
        };

        Ok(Self {
            prs_id_pos,
            prs_resource_set_id_pos,
            prs_resource_id_pos,
        })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(self.prs_resource_id_pos.is_some());
        optionals.push(false);

        aper::encode::encode_sequence_header(data, false, &optionals, false)?;
        aper::encode::encode_integer(
            data,
            Some(0),
            Some(255),
            false,
            self.prs_id_pos as i128,
            false,
        )?;
        aper::encode::encode_integer(
            data,
            Some(0),
            Some(7),
            false,
            self.prs_resource_set_id_pos as i128,
            false,
        )?;
        if let Some(x) = &self.prs_resource_id_pos {
            aper::encode::encode_integer(data, Some(0), Some(63), false, *x as i128, false)?;
        }

        Ok(())
    }
}

impl AperCodec for PrsInformationPos {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        PrsInformationPos::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("PrsInformationPos"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("PrsInformationPos"))
    }
}
// PotentialSpCellItem
#[derive(Clone, Debug)]
pub struct PotentialSpCellItem {
    pub potential_sp_cell_id: Nrcgi,
}

impl PotentialSpCellItem {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (_optionals, _extensions_present) =
            aper::decode::decode_sequence_header(data, true, 1)?;
        let potential_sp_cell_id = Nrcgi::decode(data)?;

        Ok(Self {
            potential_sp_cell_id,
        })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(false);

        aper::encode::encode_sequence_header(data, true, &optionals, false)?;
        self.potential_sp_cell_id.encode(data)?;

        Ok(())
    }
}

impl AperCodec for PotentialSpCellItem {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        PotentialSpCellItem::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("PotentialSpCellItem"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("PotentialSpCellItem"))
    }
}
// PrsAngleList
#[derive(Clone, Debug)]
pub struct PrsAngleList(pub Vec<PrsAngleItem>);

impl PrsAngleList {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        Ok(Self({
            let length = aper::decode::decode_length_determinent(data, Some(1), Some(64), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(PrsAngleItem::decode(data)?);
            }
            items
        }))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_length_determinent(data, Some(1), Some(64), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl AperCodec for PrsAngleList {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        PrsAngleList::decode_inner(data).map_err(|e: AperCodecError| e.push_context("PrsAngleList"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("PrsAngleList"))
    }
}
// PrsAngleItem
#[derive(Clone, Debug)]
pub struct PrsAngleItem {
    pub nr_prs_azimuth: u16,
    pub nr_prs_azimuth_fine: u8,
    pub nr_prs_elevation: u8,
    pub nr_prs_elevation_fine: u8,
}

impl PrsAngleItem {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (_optionals, _extensions_present) =
            aper::decode::decode_sequence_header(data, false, 1)?;
        let nr_prs_azimuth =
            aper::decode::decode_integer(data, Some(0), Some(359), false)?.0 as u16;
        let nr_prs_azimuth_fine =
            aper::decode::decode_integer(data, Some(0), Some(9), false)?.0 as u8;
        let nr_prs_elevation =
            aper::decode::decode_integer(data, Some(0), Some(180), false)?.0 as u8;
        let nr_prs_elevation_fine =
            aper::decode::decode_integer(data, Some(0), Some(9), false)?.0 as u8;

        Ok(Self {
            nr_prs_azimuth,
            nr_prs_azimuth_fine,
            nr_prs_elevation,
            nr_prs_elevation_fine,
        })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(false);

        aper::encode::encode_sequence_header(data, false, &optionals, false)?;
        aper::encode::encode_integer(
            data,
            Some(0),
            Some(359),
            false,
            self.nr_prs_azimuth as i128,
            false,
        )?;
        aper::encode::encode_integer(
            data,
            Some(0),
            Some(9),
            false,
            self.nr_prs_azimuth_fine as i128,
            false,
        )?;
        aper::encode::encode_integer(
            data,
            Some(0),
            Some(180),
            false,
            self.nr_prs_elevation as i128,
            false,
        )?;
        aper::encode::encode_integer(
            data,
            Some(0),
            Some(9),
            false,
            self.nr_prs_elevation_fine as i128,
            false,
        )?;

        Ok(())
    }
}

impl AperCodec for PrsAngleItem {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        PrsAngleItem::decode_inner(data).map_err(|e: AperCodecError| e.push_context("PrsAngleItem"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("PrsAngleItem"))
    }
}
// PrsMuting
#[derive(Clone, Debug)]
pub struct PrsMuting {
    pub prs_muting_option_1: PrsMutingOption1,
    pub prs_muting_option_2: PrsMutingOption2,
}

impl PrsMuting {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (_optionals, _extensions_present) =
            aper::decode::decode_sequence_header(data, false, 1)?;
        let prs_muting_option_1 = PrsMutingOption1::decode(data)?;
        let prs_muting_option_2 = PrsMutingOption2::decode(data)?;

        Ok(Self {
            prs_muting_option_1,
            prs_muting_option_2,
        })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(false);

        aper::encode::encode_sequence_header(data, false, &optionals, false)?;
        self.prs_muting_option_1.encode(data)?;
        self.prs_muting_option_2.encode(data)?;

        Ok(())
    }
}

impl AperCodec for PrsMuting {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        PrsMuting::decode_inner(data).map_err(|e: AperCodecError| e.push_context("PrsMuting"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("PrsMuting"))
    }
}
// PrsMutingOption1
#[derive(Clone, Debug)]
pub struct PrsMutingOption1 {
    pub muting_pattern: DlPrsMutingPattern,
    pub muting_bit_repetition_factor: MutingBitRepetitionFactor,
}

impl PrsMutingOption1 {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (_optionals, _extensions_present) =
            aper::decode::decode_sequence_header(data, false, 1)?;
        let muting_pattern = DlPrsMutingPattern::decode(data)?;
        let muting_bit_repetition_factor = MutingBitRepetitionFactor::decode(data)?;

        Ok(Self {
            muting_pattern,
            muting_bit_repetition_factor,
        })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(false);

        aper::encode::encode_sequence_header(data, false, &optionals, false)?;
        self.muting_pattern.encode(data)?;
        self.muting_bit_repetition_factor.encode(data)?;

        Ok(())
    }
}

impl AperCodec for PrsMutingOption1 {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        PrsMutingOption1::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("PrsMutingOption1"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("PrsMutingOption1"))
    }
}
// PrsMutingOption2
#[derive(Clone, Debug)]
pub struct PrsMutingOption2 {
    pub muting_pattern: DlPrsMutingPattern,
}

impl PrsMutingOption2 {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (_optionals, _extensions_present) =
            aper::decode::decode_sequence_header(data, false, 1)?;
        let muting_pattern = DlPrsMutingPattern::decode(data)?;

        Ok(Self { muting_pattern })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(false);

        aper::encode::encode_sequence_header(data, false, &optionals, false)?;
        self.muting_pattern.encode(data)?;

        Ok(())
    }
}

impl AperCodec for PrsMutingOption2 {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        PrsMutingOption2::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("PrsMutingOption2"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("PrsMutingOption2"))
    }
}
// PrsResourceId
#[derive(Clone, Debug)]
pub struct PrsResourceId(pub u8);

impl PrsResourceId {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        Ok(Self(
            aper::decode::decode_integer(data, Some(0), Some(63), false)?.0 as u8,
        ))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_integer(data, Some(0), Some(63), false, self.0 as i128, false)
    }
}

impl AperCodec for PrsResourceId {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        PrsResourceId::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("PrsResourceId"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("PrsResourceId"))
    }
}
// PrsResourceList
#[derive(Clone, Debug)]
pub struct PrsResourceList(pub Vec<PrsResourceItem>);

impl PrsResourceList {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        Ok(Self({
            let length = aper::decode::decode_length_determinent(data, Some(1), Some(64), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(PrsResourceItem::decode(data)?);
            }
            items
        }))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_length_determinent(data, Some(1), Some(64), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl AperCodec for PrsResourceList {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        PrsResourceList::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("PrsResourceList"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("PrsResourceList"))
    }
}
// PrsResourceItem
#[derive(Clone, Debug)]
pub struct PrsResourceItem {
    pub prs_resource_id: PrsResourceId,
    pub sequence_id: u16,
    pub re_offset: u8,
    pub resource_slot_offset: u16,
    pub resource_symbol_offset: u8,
    pub qcl_info: Option<PrsResourceQclInfo>,
}

impl PrsResourceItem {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (optionals, _extensions_present) =
            aper::decode::decode_sequence_header(data, false, 2)?;
        let prs_resource_id = PrsResourceId::decode(data)?;
        let sequence_id = aper::decode::decode_integer(data, Some(0), Some(4095), false)?.0 as u16;
        let re_offset = aper::decode::decode_integer(data, Some(0), Some(11), true)?.0 as u8;
        let resource_slot_offset =
            aper::decode::decode_integer(data, Some(0), Some(511), false)?.0 as u16;
        let resource_symbol_offset =
            aper::decode::decode_integer(data, Some(0), Some(12), false)?.0 as u8;
        let qcl_info = if optionals[0] {
            Some(PrsResourceQclInfo::decode(data)?)
        } else {
            None
        };

        Ok(Self {
            prs_resource_id,
            sequence_id,
            re_offset,
            resource_slot_offset,
            resource_symbol_offset,
            qcl_info,
        })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(self.qcl_info.is_some());
        optionals.push(false);

        aper::encode::encode_sequence_header(data, false, &optionals, false)?;
        self.prs_resource_id.encode(data)?;
        aper::encode::encode_integer(
            data,
            Some(0),
            Some(4095),
            false,
            self.sequence_id as i128,
            false,
        )?;
        aper::encode::encode_integer(data, Some(0), Some(11), true, self.re_offset as i128, false)?;
        aper::encode::encode_integer(
            data,
            Some(0),
            Some(511),
            false,
            self.resource_slot_offset as i128,
            false,
        )?;
        aper::encode::encode_integer(
            data,
            Some(0),
            Some(12),
            false,
            self.resource_symbol_offset as i128,
            false,
        )?;
        if let Some(x) = &self.qcl_info {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl AperCodec for PrsResourceItem {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        PrsResourceItem::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("PrsResourceItem"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("PrsResourceItem"))
    }
}
// PrsResourceQclInfo
#[derive(Clone, Debug)]
pub enum PrsResourceQclInfo {
    QclSourceSsb(PrsResourceQclSourceSsb),
    QclSourcePrs(PrsResourceQclSourcePrs),
}

impl PrsResourceQclInfo {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (idx, extended) = aper::decode::decode_choice_idx(data, 0, 2, false)?;
        if extended {
            return Err(aper::AperCodecError::new(
                "CHOICE additions not implemented",
            ));
        }
        match idx {
            0 => Ok(Self::QclSourceSsb(PrsResourceQclSourceSsb::decode(data)?)),
            1 => Ok(Self::QclSourcePrs(PrsResourceQclSourcePrs::decode(data)?)),
            2 => Err(AperCodecError::new(
                "Choice extension container not implemented",
            )),
            _ => Err(AperCodecError::new("Unknown choice idx")),
        }
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        match self {
            Self::QclSourceSsb(x) => {
                aper::encode::encode_choice_idx(data, 0, 2, false, 0, false)?;
                x.encode(data)
            }
            Self::QclSourcePrs(x) => {
                aper::encode::encode_choice_idx(data, 0, 2, false, 1, false)?;
                x.encode(data)
            }
        }
    }
}

impl AperCodec for PrsResourceQclInfo {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        PrsResourceQclInfo::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("PrsResourceQclInfo"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("PrsResourceQclInfo"))
    }
}
// PrsResourceQclSourceSsb
#[derive(Clone, Debug)]
pub struct PrsResourceQclSourceSsb {
    pub pci_nr: u16,
    pub ssb_index: Option<SsbIndex>,
}

impl PrsResourceQclSourceSsb {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (optionals, _extensions_present) = aper::decode::decode_sequence_header(data, true, 2)?;
        let pci_nr = aper::decode::decode_integer(data, Some(0), Some(1007), false)?.0 as u16;
        let ssb_index = if optionals[0] {
            Some(SsbIndex::decode(data)?)
        } else {
            None
        };

        Ok(Self { pci_nr, ssb_index })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(self.ssb_index.is_some());
        optionals.push(false);

        aper::encode::encode_sequence_header(data, true, &optionals, false)?;
        aper::encode::encode_integer(data, Some(0), Some(1007), false, self.pci_nr as i128, false)?;
        if let Some(x) = &self.ssb_index {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl AperCodec for PrsResourceQclSourceSsb {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        PrsResourceQclSourceSsb::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("PrsResourceQclSourceSsb"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("PrsResourceQclSourceSsb"))
    }
}
// PrsResourceQclSourcePrs
#[derive(Clone, Debug)]
pub struct PrsResourceQclSourcePrs {
    pub qcl_source_prs_resource_set_id: PrsResourceSetId,
    pub qcl_source_prs_resource_id: Option<PrsResourceId>,
}

impl PrsResourceQclSourcePrs {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (optionals, _extensions_present) =
            aper::decode::decode_sequence_header(data, false, 2)?;
        let qcl_source_prs_resource_set_id = PrsResourceSetId::decode(data)?;
        let qcl_source_prs_resource_id = if optionals[0] {
            Some(PrsResourceId::decode(data)?)
        } else {
            None
        };

        Ok(Self {
            qcl_source_prs_resource_set_id,
            qcl_source_prs_resource_id,
        })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(self.qcl_source_prs_resource_id.is_some());
        optionals.push(false);

        aper::encode::encode_sequence_header(data, false, &optionals, false)?;
        self.qcl_source_prs_resource_set_id.encode(data)?;
        if let Some(x) = &self.qcl_source_prs_resource_id {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl AperCodec for PrsResourceQclSourcePrs {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        PrsResourceQclSourcePrs::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("PrsResourceQclSourcePrs"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("PrsResourceQclSourcePrs"))
    }
}
// PrsResourceSetId
#[derive(Clone, Debug)]
pub struct PrsResourceSetId(pub u8);

impl PrsResourceSetId {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        Ok(Self(
            aper::decode::decode_integer(data, Some(0), Some(7), false)?.0 as u8,
        ))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_integer(data, Some(0), Some(7), false, self.0 as i128, false)
    }
}

impl AperCodec for PrsResourceSetId {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        PrsResourceSetId::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("PrsResourceSetId"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("PrsResourceSetId"))
    }
}
// PrsResourceSetList
#[derive(Clone, Debug)]
pub struct PrsResourceSetList(pub Vec<PrsResourceSetItem>);

impl PrsResourceSetList {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        Ok(Self({
            let length = aper::decode::decode_length_determinent(data, Some(1), Some(8), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(PrsResourceSetItem::decode(data)?);
            }
            items
        }))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_length_determinent(data, Some(1), Some(8), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl AperCodec for PrsResourceSetList {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        PrsResourceSetList::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("PrsResourceSetList"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("PrsResourceSetList"))
    }
}
// PrsResourceSetItem
#[derive(Clone, Debug)]
pub struct PrsResourceSetItem {
    pub prs_resource_set_id: PrsResourceSetId,
    pub subcarrier_spacing: SubcarrierSpacing2,
    pub pr_sbandwidth: u8,
    pub start_prb: u16,
    pub point_a: u32,
    pub comb_size: CombSize,
    pub cp_type: CpType,
    pub resource_set_periodicity: ResourceSetPeriodicity,
    pub resource_set_slot_offset: u32,
    pub resource_repetition_factor: ResourceRepetitionFactor,
    pub resource_time_gap: ResourceTimeGap,
    pub resource_numberof_symbols: ResourceNumberofSymbols,
    pub prs_muting: Option<PrsMuting>,
    pub prs_resource_transmit_power: i8,
    pub prs_resource_list: PrsResourceList,
}

impl PrsResourceSetItem {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (optionals, _extensions_present) =
            aper::decode::decode_sequence_header(data, false, 2)?;
        let prs_resource_set_id = PrsResourceSetId::decode(data)?;
        let subcarrier_spacing = SubcarrierSpacing2::decode(data)?;
        let pr_sbandwidth = aper::decode::decode_integer(data, Some(1), Some(63), false)?.0 as u8;
        let start_prb = aper::decode::decode_integer(data, Some(0), Some(2176), false)?.0 as u16;
        let point_a = aper::decode::decode_integer(data, Some(0), Some(3279165), false)?.0 as u32;
        let comb_size = CombSize::decode(data)?;
        let cp_type = CpType::decode(data)?;
        let resource_set_periodicity = ResourceSetPeriodicity::decode(data)?;
        let resource_set_slot_offset =
            aper::decode::decode_integer(data, Some(0), Some(81919), true)?.0 as u32;
        let resource_repetition_factor = ResourceRepetitionFactor::decode(data)?;
        let resource_time_gap = ResourceTimeGap::decode(data)?;
        let resource_numberof_symbols = ResourceNumberofSymbols::decode(data)?;
        let prs_muting = if optionals[0] {
            Some(PrsMuting::decode(data)?)
        } else {
            None
        };
        let prs_resource_transmit_power =
            aper::decode::decode_integer(data, Some(-60), Some(50), false)?.0 as i8;
        let prs_resource_list = PrsResourceList::decode(data)?;

        Ok(Self {
            prs_resource_set_id,
            subcarrier_spacing,
            pr_sbandwidth,
            start_prb,
            point_a,
            comb_size,
            cp_type,
            resource_set_periodicity,
            resource_set_slot_offset,
            resource_repetition_factor,
            resource_time_gap,
            resource_numberof_symbols,
            prs_muting,
            prs_resource_transmit_power,
            prs_resource_list,
        })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(self.prs_muting.is_some());
        optionals.push(false);

        aper::encode::encode_sequence_header(data, false, &optionals, false)?;
        self.prs_resource_set_id.encode(data)?;
        self.subcarrier_spacing.encode(data)?;
        aper::encode::encode_integer(
            data,
            Some(1),
            Some(63),
            false,
            self.pr_sbandwidth as i128,
            false,
        )?;
        aper::encode::encode_integer(
            data,
            Some(0),
            Some(2176),
            false,
            self.start_prb as i128,
            false,
        )?;
        aper::encode::encode_integer(
            data,
            Some(0),
            Some(3279165),
            false,
            self.point_a as i128,
            false,
        )?;
        self.comb_size.encode(data)?;
        self.cp_type.encode(data)?;
        self.resource_set_periodicity.encode(data)?;
        aper::encode::encode_integer(
            data,
            Some(0),
            Some(81919),
            true,
            self.resource_set_slot_offset as i128,
            false,
        )?;
        self.resource_repetition_factor.encode(data)?;
        self.resource_time_gap.encode(data)?;
        self.resource_numberof_symbols.encode(data)?;
        if let Some(x) = &self.prs_muting {
            x.encode(data)?;
        }
        aper::encode::encode_integer(
            data,
            Some(-60),
            Some(50),
            false,
            self.prs_resource_transmit_power as i128,
            false,
        )?;
        self.prs_resource_list.encode(data)?;

        Ok(())
    }
}

impl AperCodec for PrsResourceSetItem {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        PrsResourceSetItem::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("PrsResourceSetItem"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("PrsResourceSetItem"))
    }
}
// PwsFailedNrCgiItem
#[derive(Clone, Debug)]
pub struct PwsFailedNrCgiItem {
    pub nrcgi: Nrcgi,
    pub number_of_broadcasts: NumberOfBroadcasts,
}

impl PwsFailedNrCgiItem {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (_optionals, _extensions_present) =
            aper::decode::decode_sequence_header(data, true, 1)?;
        let nrcgi = Nrcgi::decode(data)?;
        let number_of_broadcasts = NumberOfBroadcasts::decode(data)?;

        Ok(Self {
            nrcgi,
            number_of_broadcasts,
        })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(false);

        aper::encode::encode_sequence_header(data, true, &optionals, false)?;
        self.nrcgi.encode(data)?;
        self.number_of_broadcasts.encode(data)?;

        Ok(())
    }
}

impl AperCodec for PwsFailedNrCgiItem {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        PwsFailedNrCgiItem::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("PwsFailedNrCgiItem"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("PwsFailedNrCgiItem"))
    }
}
// PwsSystemInformation
#[derive(Clone, Debug)]
pub struct PwsSystemInformation {
    pub si_btype: SibTypePws,
    pub si_bmessage: Vec<u8>,
}

impl PwsSystemInformation {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (_optionals, _extensions_present) =
            aper::decode::decode_sequence_header(data, true, 1)?;
        let si_btype = SibTypePws::decode(data)?;
        let si_bmessage = aper::decode::decode_octetstring(data, None, None, false)?;

        Ok(Self {
            si_btype,
            si_bmessage,
        })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(false);

        aper::encode::encode_sequence_header(data, true, &optionals, false)?;
        self.si_btype.encode(data)?;
        aper::encode::encode_octetstring(data, None, None, false, &self.si_bmessage, false)?;

        Ok(())
    }
}

impl AperCodec for PwsSystemInformation {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        PwsSystemInformation::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("PwsSystemInformation"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("PwsSystemInformation"))
    }
}
// PrivacyIndicator
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum PrivacyIndicator {
    ImmediateMdt,
    LoggedMdt,
}

impl PrivacyIndicator {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (idx, extended) = aper::decode::decode_enumerated(data, Some(0), Some(1), true)?;
        if extended {
            return Err(aper::AperCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| AperCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_enumerated(data, Some(0), Some(1), true, *self as i128, false)
    }
}

impl AperCodec for PrivacyIndicator {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        PrivacyIndicator::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("PrivacyIndicator"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("PrivacyIndicator"))
    }
}
// Qci
#[derive(Clone, Debug)]
pub struct Qci(pub u8);

impl Qci {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        Ok(Self(
            aper::decode::decode_integer(data, Some(0), Some(255), false)?.0 as u8,
        ))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_integer(data, Some(0), Some(255), false, self.0 as i128, false)
    }
}

impl AperCodec for Qci {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        Qci::decode_inner(data).map_err(|e: AperCodecError| e.push_context("Qci"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("Qci"))
    }
}
// QosCharacteristics
#[derive(Clone, Debug)]
pub enum QosCharacteristics {
    NonDynamic5qi(NonDynamic5qiDescriptor),
    Dynamic5qi(Dynamic5qiDescriptor),
}

impl QosCharacteristics {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (idx, extended) = aper::decode::decode_choice_idx(data, 0, 2, false)?;
        if extended {
            return Err(aper::AperCodecError::new(
                "CHOICE additions not implemented",
            ));
        }
        match idx {
            0 => Ok(Self::NonDynamic5qi(NonDynamic5qiDescriptor::decode(data)?)),
            1 => Ok(Self::Dynamic5qi(Dynamic5qiDescriptor::decode(data)?)),
            2 => Err(AperCodecError::new(
                "Choice extension container not implemented",
            )),
            _ => Err(AperCodecError::new("Unknown choice idx")),
        }
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        match self {
            Self::NonDynamic5qi(x) => {
                aper::encode::encode_choice_idx(data, 0, 2, false, 0, false)?;
                x.encode(data)
            }
            Self::Dynamic5qi(x) => {
                aper::encode::encode_choice_idx(data, 0, 2, false, 1, false)?;
                x.encode(data)
            }
        }
    }
}

impl AperCodec for QosCharacteristics {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        QosCharacteristics::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("QosCharacteristics"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("QosCharacteristics"))
    }
}
// QosFlowIdentifier
#[derive(Clone, Debug)]
pub struct QosFlowIdentifier(pub u8);

impl QosFlowIdentifier {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        Ok(Self(
            aper::decode::decode_integer(data, Some(0), Some(63), false)?.0 as u8,
        ))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_integer(data, Some(0), Some(63), false, self.0 as i128, false)
    }
}

impl AperCodec for QosFlowIdentifier {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        QosFlowIdentifier::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("QosFlowIdentifier"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("QosFlowIdentifier"))
    }
}
// QosFlowLevelQosParameters
#[derive(Clone, Debug)]
pub struct QosFlowLevelQosParameters {
    pub qos_characteristics: QosCharacteristics,
    pub ngran_allocation_retention_priority: NgranAllocationAndRetentionPriority,
    pub gbr_qos_flow_information: Option<GbrQosFlowInformation>,
    pub reflective_qos_attribute: Option<ReflectiveQosAttribute>,
}

impl QosFlowLevelQosParameters {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (optionals, _extensions_present) =
            aper::decode::decode_sequence_header(data, false, 3)?;
        let qos_characteristics = QosCharacteristics::decode(data)?;
        let ngran_allocation_retention_priority =
            NgranAllocationAndRetentionPriority::decode(data)?;
        let gbr_qos_flow_information = if optionals[0] {
            Some(GbrQosFlowInformation::decode(data)?)
        } else {
            None
        };
        let reflective_qos_attribute = if optionals[1] {
            Some(ReflectiveQosAttribute::decode(data)?)
        } else {
            None
        };

        Ok(Self {
            qos_characteristics,
            ngran_allocation_retention_priority,
            gbr_qos_flow_information,
            reflective_qos_attribute,
        })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(self.gbr_qos_flow_information.is_some());
        optionals.push(self.reflective_qos_attribute.is_some());
        optionals.push(false);

        aper::encode::encode_sequence_header(data, false, &optionals, false)?;
        self.qos_characteristics.encode(data)?;
        self.ngran_allocation_retention_priority.encode(data)?;
        if let Some(x) = &self.gbr_qos_flow_information {
            x.encode(data)?;
        }
        if let Some(x) = &self.reflective_qos_attribute {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl AperCodec for QosFlowLevelQosParameters {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        QosFlowLevelQosParameters::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("QosFlowLevelQosParameters"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("QosFlowLevelQosParameters"))
    }
}
// QosFlowMappingIndication
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum QosFlowMappingIndication {
    Ul,
    Dl,
}

impl QosFlowMappingIndication {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (idx, extended) = aper::decode::decode_enumerated(data, Some(0), Some(1), true)?;
        if extended {
            return Err(aper::AperCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| AperCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_enumerated(data, Some(0), Some(1), true, *self as i128, false)
    }
}

impl AperCodec for QosFlowMappingIndication {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        QosFlowMappingIndication::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("QosFlowMappingIndication"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("QosFlowMappingIndication"))
    }
}
// QosInformation
#[derive(Clone, Debug)]
pub enum QosInformation {
    EutranQos(EutranQos),
}

impl QosInformation {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (idx, extended) = aper::decode::decode_choice_idx(data, 0, 1, false)?;
        if extended {
            return Err(aper::AperCodecError::new(
                "CHOICE additions not implemented",
            ));
        }
        match idx {
            0 => Ok(Self::EutranQos(EutranQos::decode(data)?)),
            1 => Err(AperCodecError::new(
                "Choice extension container not implemented",
            )),
            _ => Err(AperCodecError::new("Unknown choice idx")),
        }
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        match self {
            Self::EutranQos(x) => {
                aper::encode::encode_choice_idx(data, 0, 1, false, 0, false)?;
                x.encode(data)
            }
        }
    }
}

impl AperCodec for QosInformation {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        QosInformation::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("QosInformation"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("QosInformation"))
    }
}
// QosMonitoringRequest
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum QosMonitoringRequest {
    Ul,
    Dl,
    Both,
}

impl QosMonitoringRequest {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (idx, extended) = aper::decode::decode_enumerated(data, Some(0), Some(2), true)?;
        if extended {
            return Err(aper::AperCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| AperCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_enumerated(data, Some(0), Some(2), true, *self as i128, false)
    }
}

impl AperCodec for QosMonitoringRequest {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        QosMonitoringRequest::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("QosMonitoringRequest"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("QosMonitoringRequest"))
    }
}
// QosParaSetIndex
#[derive(Clone, Debug)]
pub struct QosParaSetIndex(pub u8);

impl QosParaSetIndex {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        Ok(Self(
            aper::decode::decode_integer(data, Some(1), Some(8), true)?.0 as u8,
        ))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_integer(data, Some(1), Some(8), true, self.0 as i128, false)
    }
}

impl AperCodec for QosParaSetIndex {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        QosParaSetIndex::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("QosParaSetIndex"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("QosParaSetIndex"))
    }
}
// QosParaSetNotifyIndex
#[derive(Clone, Debug)]
pub struct QosParaSetNotifyIndex(pub u8);

impl QosParaSetNotifyIndex {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        Ok(Self(
            aper::decode::decode_integer(data, Some(0), Some(8), true)?.0 as u8,
        ))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_integer(data, Some(0), Some(8), true, self.0 as i128, false)
    }
}

impl AperCodec for QosParaSetNotifyIndex {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        QosParaSetNotifyIndex::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("QosParaSetNotifyIndex"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("QosParaSetNotifyIndex"))
    }
}
// RachConfigCommon
#[derive(Clone, Debug)]
pub struct RachConfigCommon(pub Vec<u8>);

impl RachConfigCommon {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        Ok(Self(aper::decode::decode_octetstring(
            data, None, None, false,
        )?))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_octetstring(data, None, None, false, &self.0, false)
    }
}

impl AperCodec for RachConfigCommon {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        RachConfigCommon::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("RachConfigCommon"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("RachConfigCommon"))
    }
}
// RachConfigCommonIab
#[derive(Clone, Debug)]
pub struct RachConfigCommonIab(pub Vec<u8>);

impl RachConfigCommonIab {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        Ok(Self(aper::decode::decode_octetstring(
            data, None, None, false,
        )?))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_octetstring(data, None, None, false, &self.0, false)
    }
}

impl AperCodec for RachConfigCommonIab {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        RachConfigCommonIab::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("RachConfigCommonIab"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("RachConfigCommonIab"))
    }
}
// RachReportContainer
#[derive(Clone, Debug)]
pub struct RachReportContainer(pub Vec<u8>);

impl RachReportContainer {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        Ok(Self(aper::decode::decode_octetstring(
            data, None, None, false,
        )?))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_octetstring(data, None, None, false, &self.0, false)
    }
}

impl AperCodec for RachReportContainer {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        RachReportContainer::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("RachReportContainer"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("RachReportContainer"))
    }
}
// RachReportInformationList
#[derive(Clone, Debug)]
pub struct RachReportInformationList(pub Vec<RachReportInformationItem>);

impl RachReportInformationList {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        Ok(Self({
            let length = aper::decode::decode_length_determinent(data, Some(1), Some(64), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(RachReportInformationItem::decode(data)?);
            }
            items
        }))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_length_determinent(data, Some(1), Some(64), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl AperCodec for RachReportInformationList {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        RachReportInformationList::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("RachReportInformationList"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("RachReportInformationList"))
    }
}
// RachReportInformationItem
#[derive(Clone, Debug)]
pub struct RachReportInformationItem {
    pub rach_report_container: RachReportContainer,
    pub ue_assitant_identifier: Option<GnbDuUeF1apId>,
}

impl RachReportInformationItem {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (optionals, _extensions_present) = aper::decode::decode_sequence_header(data, true, 2)?;
        let rach_report_container = RachReportContainer::decode(data)?;
        let ue_assitant_identifier = if optionals[0] {
            Some(GnbDuUeF1apId::decode(data)?)
        } else {
            None
        };

        Ok(Self {
            rach_report_container,
            ue_assitant_identifier,
        })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(self.ue_assitant_identifier.is_some());
        optionals.push(false);

        aper::encode::encode_sequence_header(data, true, &optionals, false)?;
        self.rach_report_container.encode(data)?;
        if let Some(x) = &self.ue_assitant_identifier {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl AperCodec for RachReportInformationItem {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        RachReportInformationItem::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("RachReportInformationItem"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("RachReportInformationItem"))
    }
}
// RadioResourceStatus
#[derive(Clone, Debug)]
pub struct RadioResourceStatus {
    pub ssb_area_radio_resource_status_list: SsbAreaRadioResourceStatusList,
}

impl RadioResourceStatus {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (_optionals, _extensions_present) =
            aper::decode::decode_sequence_header(data, false, 1)?;
        let ssb_area_radio_resource_status_list = SsbAreaRadioResourceStatusList::decode(data)?;

        Ok(Self {
            ssb_area_radio_resource_status_list,
        })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(false);

        aper::encode::encode_sequence_header(data, false, &optionals, false)?;
        self.ssb_area_radio_resource_status_list.encode(data)?;

        Ok(())
    }
}

impl AperCodec for RadioResourceStatus {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        RadioResourceStatus::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("RadioResourceStatus"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("RadioResourceStatus"))
    }
}
// Ranac
#[derive(Clone, Debug)]
pub struct Ranac(pub u8);

impl Ranac {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        Ok(Self(
            aper::decode::decode_integer(data, Some(0), Some(255), false)?.0 as u8,
        ))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_integer(data, Some(0), Some(255), false, self.0 as i128, false)
    }
}

impl AperCodec for Ranac {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        Ranac::decode_inner(data).map_err(|e: AperCodecError| e.push_context("Ranac"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("Ranac"))
    }
}
// RanMeasurementId
#[derive(Clone, Debug)]
pub struct RanMeasurementId(pub u32);

impl RanMeasurementId {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        Ok(Self(
            aper::decode::decode_integer(data, Some(1), Some(65536), true)?.0 as u32,
        ))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_integer(data, Some(1), Some(65536), true, self.0 as i128, false)
    }
}

impl AperCodec for RanMeasurementId {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        RanMeasurementId::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("RanMeasurementId"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("RanMeasurementId"))
    }
}
// RanUeMeasurementId
#[derive(Clone, Debug)]
pub struct RanUeMeasurementId(pub u16);

impl RanUeMeasurementId {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        Ok(Self(
            aper::decode::decode_integer(data, Some(1), Some(256), true)?.0 as u16,
        ))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_integer(data, Some(1), Some(256), true, self.0 as i128, false)
    }
}

impl AperCodec for RanUeMeasurementId {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        RanUeMeasurementId::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("RanUeMeasurementId"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("RanUeMeasurementId"))
    }
}
// Ranueid
#[derive(Clone, Debug)]
pub struct Ranueid(pub Vec<u8>);

impl Ranueid {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        Ok(Self(aper::decode::decode_octetstring(
            data,
            Some(8),
            Some(8),
            false,
        )?))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_octetstring(data, Some(8), Some(8), false, &self.0, false)
    }
}

impl AperCodec for Ranueid {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        Ranueid::decode_inner(data).map_err(|e: AperCodecError| e.push_context("Ranueid"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("Ranueid"))
    }
}
// RanuePagingIdentity
#[derive(Clone, Debug)]
pub struct RanuePagingIdentity {
    pub irnti: BitString,
}

impl RanuePagingIdentity {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (_optionals, _extensions_present) =
            aper::decode::decode_sequence_header(data, false, 1)?;
        let irnti = aper::decode::decode_bitstring(data, Some(40), Some(40), false)?;

        Ok(Self { irnti })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(false);

        aper::encode::encode_sequence_header(data, false, &optionals, false)?;
        aper::encode::encode_bitstring(data, Some(40), Some(40), false, &self.irnti, false)?;

        Ok(())
    }
}

impl AperCodec for RanuePagingIdentity {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        RanuePagingIdentity::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("RanuePagingIdentity"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("RanuePagingIdentity"))
    }
}
// RatFrequencyPriorityInformation
#[derive(Clone, Debug)]
pub enum RatFrequencyPriorityInformation {
    Endc(SubscriberProfileIDforRfp),
    Ngran(RatFrequencySelectionPriority),
}

impl RatFrequencyPriorityInformation {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (idx, extended) = aper::decode::decode_choice_idx(data, 0, 2, false)?;
        if extended {
            return Err(aper::AperCodecError::new(
                "CHOICE additions not implemented",
            ));
        }
        match idx {
            0 => Ok(Self::Endc(SubscriberProfileIDforRfp::decode(data)?)),
            1 => Ok(Self::Ngran(RatFrequencySelectionPriority::decode(data)?)),
            2 => Err(AperCodecError::new(
                "Choice extension container not implemented",
            )),
            _ => Err(AperCodecError::new("Unknown choice idx")),
        }
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        match self {
            Self::Endc(x) => {
                aper::encode::encode_choice_idx(data, 0, 2, false, 0, false)?;
                x.encode(data)
            }
            Self::Ngran(x) => {
                aper::encode::encode_choice_idx(data, 0, 2, false, 1, false)?;
                x.encode(data)
            }
        }
    }
}

impl AperCodec for RatFrequencyPriorityInformation {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        RatFrequencyPriorityInformation::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("RatFrequencyPriorityInformation"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("RatFrequencyPriorityInformation"))
    }
}
// RatFrequencySelectionPriority
#[derive(Clone, Debug)]
pub struct RatFrequencySelectionPriority(pub u16);

impl RatFrequencySelectionPriority {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        Ok(Self(
            aper::decode::decode_integer(data, Some(1), Some(256), true)?.0 as u16,
        ))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_integer(data, Some(1), Some(256), true, self.0 as i128, false)
    }
}

impl AperCodec for RatFrequencySelectionPriority {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        RatFrequencySelectionPriority::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("RatFrequencySelectionPriority"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("RatFrequencySelectionPriority"))
    }
}
// ReestablishmentIndication
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum ReestablishmentIndication {
    Reestablished,
}

impl ReestablishmentIndication {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (idx, extended) = aper::decode::decode_enumerated(data, Some(0), Some(0), true)?;
        if extended {
            return Err(aper::AperCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| AperCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_enumerated(data, Some(0), Some(0), true, *self as i128, false)
    }
}

impl AperCodec for ReestablishmentIndication {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        ReestablishmentIndication::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("ReestablishmentIndication"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("ReestablishmentIndication"))
    }
}
// ReferencePoint
#[derive(Clone, Debug)]
pub enum ReferencePoint {
    CoordinateId(CoordinateId),
    ReferencePointCoordinate(AccessPointPosition),
    ReferencePointCoordinateHa(NgranHighAccuracyAccessPointPosition),
}

impl ReferencePoint {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (idx, extended) = aper::decode::decode_choice_idx(data, 0, 3, false)?;
        if extended {
            return Err(aper::AperCodecError::new(
                "CHOICE additions not implemented",
            ));
        }
        match idx {
            0 => Ok(Self::CoordinateId(CoordinateId::decode(data)?)),
            1 => Ok(Self::ReferencePointCoordinate(AccessPointPosition::decode(
                data,
            )?)),
            2 => Ok(Self::ReferencePointCoordinateHa(
                NgranHighAccuracyAccessPointPosition::decode(data)?,
            )),
            3 => Err(AperCodecError::new(
                "Choice extension container not implemented",
            )),
            _ => Err(AperCodecError::new("Unknown choice idx")),
        }
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        match self {
            Self::CoordinateId(x) => {
                aper::encode::encode_choice_idx(data, 0, 3, false, 0, false)?;
                x.encode(data)
            }
            Self::ReferencePointCoordinate(x) => {
                aper::encode::encode_choice_idx(data, 0, 3, false, 1, false)?;
                x.encode(data)
            }
            Self::ReferencePointCoordinateHa(x) => {
                aper::encode::encode_choice_idx(data, 0, 3, false, 2, false)?;
                x.encode(data)
            }
        }
    }
}

impl AperCodec for ReferencePoint {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        ReferencePoint::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("ReferencePoint"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("ReferencePoint"))
    }
}
// ReferenceSfn
#[derive(Clone, Debug)]
pub struct ReferenceSfn(pub u16);

impl ReferenceSfn {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        Ok(Self(
            aper::decode::decode_integer(data, Some(0), Some(1023), false)?.0 as u16,
        ))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_integer(data, Some(0), Some(1023), false, self.0 as i128, false)
    }
}

impl AperCodec for ReferenceSfn {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        ReferenceSfn::decode_inner(data).map_err(|e: AperCodecError| e.push_context("ReferenceSfn"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("ReferenceSfn"))
    }
}
// ReferenceSignal
#[derive(Clone, Debug)]
pub enum ReferenceSignal {
    NzpCsiRs(NzpCsiRsResourceId),
    Ssb(Ssb),
    Srs(SrsResourceId),
    PositioningSrs(SrsPosResourceId),
    DlPrs(DlPrs),
}

impl ReferenceSignal {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (idx, extended) = aper::decode::decode_choice_idx(data, 0, 5, false)?;
        if extended {
            return Err(aper::AperCodecError::new(
                "CHOICE additions not implemented",
            ));
        }
        match idx {
            0 => Ok(Self::NzpCsiRs(NzpCsiRsResourceId::decode(data)?)),
            1 => Ok(Self::Ssb(Ssb::decode(data)?)),
            2 => Ok(Self::Srs(SrsResourceId::decode(data)?)),
            3 => Ok(Self::PositioningSrs(SrsPosResourceId::decode(data)?)),
            4 => Ok(Self::DlPrs(DlPrs::decode(data)?)),
            5 => Err(AperCodecError::new(
                "Choice extension container not implemented",
            )),
            _ => Err(AperCodecError::new("Unknown choice idx")),
        }
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        match self {
            Self::NzpCsiRs(x) => {
                aper::encode::encode_choice_idx(data, 0, 5, false, 0, false)?;
                x.encode(data)
            }
            Self::Ssb(x) => {
                aper::encode::encode_choice_idx(data, 0, 5, false, 1, false)?;
                x.encode(data)
            }
            Self::Srs(x) => {
                aper::encode::encode_choice_idx(data, 0, 5, false, 2, false)?;
                x.encode(data)
            }
            Self::PositioningSrs(x) => {
                aper::encode::encode_choice_idx(data, 0, 5, false, 3, false)?;
                x.encode(data)
            }
            Self::DlPrs(x) => {
                aper::encode::encode_choice_idx(data, 0, 5, false, 4, false)?;
                x.encode(data)
            }
        }
    }
}

impl AperCodec for ReferenceSignal {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        ReferenceSignal::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("ReferenceSignal"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("ReferenceSignal"))
    }
}
// RelativeCartesianLocation
#[derive(Clone, Debug)]
pub struct RelativeCartesianLocation {
    pub xy_zunit: XyZunit,
    pub xvalue: i32,
    pub yvalue: i32,
    pub zvalue: i16,
    pub location_uncertainty: LocationUncertainty,
}

impl RelativeCartesianLocation {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (_optionals, _extensions_present) =
            aper::decode::decode_sequence_header(data, false, 1)?;
        let xy_zunit = XyZunit::decode(data)?;
        let xvalue = aper::decode::decode_integer(data, Some(-65536), Some(65535), false)?.0 as i32;
        let yvalue = aper::decode::decode_integer(data, Some(-65536), Some(65535), false)?.0 as i32;
        let zvalue = aper::decode::decode_integer(data, Some(-32768), Some(32767), false)?.0 as i16;
        let location_uncertainty = LocationUncertainty::decode(data)?;

        Ok(Self {
            xy_zunit,
            xvalue,
            yvalue,
            zvalue,
            location_uncertainty,
        })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(false);

        aper::encode::encode_sequence_header(data, false, &optionals, false)?;
        self.xy_zunit.encode(data)?;
        aper::encode::encode_integer(
            data,
            Some(-65536),
            Some(65535),
            false,
            self.xvalue as i128,
            false,
        )?;
        aper::encode::encode_integer(
            data,
            Some(-65536),
            Some(65535),
            false,
            self.yvalue as i128,
            false,
        )?;
        aper::encode::encode_integer(
            data,
            Some(-32768),
            Some(32767),
            false,
            self.zvalue as i128,
            false,
        )?;
        self.location_uncertainty.encode(data)?;

        Ok(())
    }
}

impl AperCodec for RelativeCartesianLocation {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        RelativeCartesianLocation::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("RelativeCartesianLocation"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("RelativeCartesianLocation"))
    }
}
// RelativeGeodeticLocation
#[derive(Clone, Debug)]
pub struct RelativeGeodeticLocation {
    pub milli_arc_second_units: MilliArcSecondUnits,
    pub height_units: HeightUnits,
    pub delta_latitude: i16,
    pub delta_longitude: i16,
    pub delta_height: i16,
    pub location_uncertainty: LocationUncertainty,
}

impl RelativeGeodeticLocation {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (_optionals, _extensions_present) =
            aper::decode::decode_sequence_header(data, false, 1)?;
        let milli_arc_second_units = MilliArcSecondUnits::decode(data)?;
        let height_units = HeightUnits::decode(data)?;
        let delta_latitude =
            aper::decode::decode_integer(data, Some(-1024), Some(1023), false)?.0 as i16;
        let delta_longitude =
            aper::decode::decode_integer(data, Some(-1024), Some(1023), false)?.0 as i16;
        let delta_height =
            aper::decode::decode_integer(data, Some(-1024), Some(1023), false)?.0 as i16;
        let location_uncertainty = LocationUncertainty::decode(data)?;

        Ok(Self {
            milli_arc_second_units,
            height_units,
            delta_latitude,
            delta_longitude,
            delta_height,
            location_uncertainty,
        })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(false);

        aper::encode::encode_sequence_header(data, false, &optionals, false)?;
        self.milli_arc_second_units.encode(data)?;
        self.height_units.encode(data)?;
        aper::encode::encode_integer(
            data,
            Some(-1024),
            Some(1023),
            false,
            self.delta_latitude as i128,
            false,
        )?;
        aper::encode::encode_integer(
            data,
            Some(-1024),
            Some(1023),
            false,
            self.delta_longitude as i128,
            false,
        )?;
        aper::encode::encode_integer(
            data,
            Some(-1024),
            Some(1023),
            false,
            self.delta_height as i128,
            false,
        )?;
        self.location_uncertainty.encode(data)?;

        Ok(())
    }
}

impl AperCodec for RelativeGeodeticLocation {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        RelativeGeodeticLocation::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("RelativeGeodeticLocation"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("RelativeGeodeticLocation"))
    }
}
// ReferenceTime
#[derive(Clone, Debug)]
pub struct ReferenceTime(pub Vec<u8>);

impl ReferenceTime {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        Ok(Self(aper::decode::decode_octetstring(
            data, None, None, false,
        )?))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_octetstring(data, None, None, false, &self.0, false)
    }
}

impl AperCodec for ReferenceTime {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        ReferenceTime::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("ReferenceTime"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("ReferenceTime"))
    }
}
// RegistrationRequest
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum RegistrationRequest {
    Start,
    Stop,
    Add,
}

impl RegistrationRequest {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (idx, extended) = aper::decode::decode_enumerated(data, Some(0), Some(2), true)?;
        if extended {
            return Err(aper::AperCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| AperCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_enumerated(data, Some(0), Some(2), true, *self as i128, false)
    }
}

impl AperCodec for RegistrationRequest {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        RegistrationRequest::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("RegistrationRequest"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("RegistrationRequest"))
    }
}
// ReportCharacteristics
#[derive(Clone, Debug)]
pub struct ReportCharacteristics(pub BitString);

impl ReportCharacteristics {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        Ok(Self(aper::decode::decode_bitstring(
            data,
            Some(32),
            Some(32),
            false,
        )?))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_bitstring(data, Some(32), Some(32), false, &self.0, false)
    }
}

impl AperCodec for ReportCharacteristics {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        ReportCharacteristics::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("ReportCharacteristics"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("ReportCharacteristics"))
    }
}
// ReportingPeriodicity
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum ReportingPeriodicity {
    Ms500,
    Ms1000,
    Ms2000,
    Ms5000,
    Ms10000,
}

impl ReportingPeriodicity {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (idx, extended) = aper::decode::decode_enumerated(data, Some(0), Some(4), true)?;
        if extended {
            return Err(aper::AperCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| AperCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_enumerated(data, Some(0), Some(4), true, *self as i128, false)
    }
}

impl AperCodec for ReportingPeriodicity {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        ReportingPeriodicity::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("ReportingPeriodicity"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("ReportingPeriodicity"))
    }
}
// RequestedBandCombinationIndex
#[derive(Clone, Debug)]
pub struct RequestedBandCombinationIndex(pub Vec<u8>);

impl RequestedBandCombinationIndex {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        Ok(Self(aper::decode::decode_octetstring(
            data, None, None, false,
        )?))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_octetstring(data, None, None, false, &self.0, false)
    }
}

impl AperCodec for RequestedBandCombinationIndex {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        RequestedBandCombinationIndex::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("RequestedBandCombinationIndex"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("RequestedBandCombinationIndex"))
    }
}
// RequestedFeatureSetEntryIndex
#[derive(Clone, Debug)]
pub struct RequestedFeatureSetEntryIndex(pub Vec<u8>);

impl RequestedFeatureSetEntryIndex {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        Ok(Self(aper::decode::decode_octetstring(
            data, None, None, false,
        )?))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_octetstring(data, None, None, false, &self.0, false)
    }
}

impl AperCodec for RequestedFeatureSetEntryIndex {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        RequestedFeatureSetEntryIndex::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("RequestedFeatureSetEntryIndex"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("RequestedFeatureSetEntryIndex"))
    }
}
// RequestedPMaxFr2
#[derive(Clone, Debug)]
pub struct RequestedPMaxFr2(pub Vec<u8>);

impl RequestedPMaxFr2 {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        Ok(Self(aper::decode::decode_octetstring(
            data, None, None, false,
        )?))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_octetstring(data, None, None, false, &self.0, false)
    }
}

impl AperCodec for RequestedPMaxFr2 {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        RequestedPMaxFr2::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("RequestedPMaxFr2"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("RequestedPMaxFr2"))
    }
}
// RequestedPdcchBlindDetectionScg
#[derive(Clone, Debug)]
pub struct RequestedPdcchBlindDetectionScg(pub Vec<u8>);

impl RequestedPdcchBlindDetectionScg {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        Ok(Self(aper::decode::decode_octetstring(
            data, None, None, false,
        )?))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_octetstring(data, None, None, false, &self.0, false)
    }
}

impl AperCodec for RequestedPdcchBlindDetectionScg {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        RequestedPdcchBlindDetectionScg::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("RequestedPdcchBlindDetectionScg"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("RequestedPdcchBlindDetectionScg"))
    }
}
// RequestedSrsTransmissionCharacteristics
#[derive(Clone, Debug)]
pub struct RequestedSrsTransmissionCharacteristics {
    pub number_of_transmissions: Option<u16>,
    pub resource_type: ResourceType2,
    pub bandwidth_srs: BandwidthSrs,
    pub srs_resource_set_list: Option<SrsResourceSetList>,
    pub ssb_information: Option<SsbInformation>,
}

impl RequestedSrsTransmissionCharacteristics {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (optionals, _extensions_present) =
            aper::decode::decode_sequence_header(data, false, 4)?;
        let number_of_transmissions = if optionals[0] {
            Some(aper::decode::decode_integer(data, Some(0), Some(500), true)?.0 as u16)
        } else {
            None
        };
        let resource_type = ResourceType2::decode(data)?;
        let bandwidth_srs = BandwidthSrs::decode(data)?;
        let srs_resource_set_list = if optionals[1] {
            Some(SrsResourceSetList::decode(data)?)
        } else {
            None
        };
        let ssb_information = if optionals[2] {
            Some(SsbInformation::decode(data)?)
        } else {
            None
        };

        Ok(Self {
            number_of_transmissions,
            resource_type,
            bandwidth_srs,
            srs_resource_set_list,
            ssb_information,
        })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(self.number_of_transmissions.is_some());
        optionals.push(self.srs_resource_set_list.is_some());
        optionals.push(self.ssb_information.is_some());
        optionals.push(false);

        aper::encode::encode_sequence_header(data, false, &optionals, false)?;
        if let Some(x) = &self.number_of_transmissions {
            aper::encode::encode_integer(data, Some(0), Some(500), true, *x as i128, false)?;
        }
        self.resource_type.encode(data)?;
        self.bandwidth_srs.encode(data)?;
        if let Some(x) = &self.srs_resource_set_list {
            x.encode(data)?;
        }
        if let Some(x) = &self.ssb_information {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl AperCodec for RequestedSrsTransmissionCharacteristics {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        RequestedSrsTransmissionCharacteristics::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("RequestedSrsTransmissionCharacteristics"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("RequestedSrsTransmissionCharacteristics"))
    }
}
// RequestType
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum RequestType {
    Offer,
    Execution,
}

impl RequestType {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (idx, extended) = aper::decode::decode_enumerated(data, Some(0), Some(1), true)?;
        if extended {
            return Err(aper::AperCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| AperCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_enumerated(data, Some(0), Some(1), true, *self as i128, false)
    }
}

impl AperCodec for RequestType {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        RequestType::decode_inner(data).map_err(|e: AperCodecError| e.push_context("RequestType"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("RequestType"))
    }
}
// ResourceCoordinationEutraCellInfo
#[derive(Clone, Debug)]
pub struct ResourceCoordinationEutraCellInfo {
    pub eutra_mode_info: EutraCoexModeInfo,
    pub eutra_prach_configuration: EutraPrachConfiguration,
}

impl ResourceCoordinationEutraCellInfo {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (_optionals, _extensions_present) =
            aper::decode::decode_sequence_header(data, true, 1)?;
        let eutra_mode_info = EutraCoexModeInfo::decode(data)?;
        let eutra_prach_configuration = EutraPrachConfiguration::decode(data)?;

        Ok(Self {
            eutra_mode_info,
            eutra_prach_configuration,
        })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(false);

        aper::encode::encode_sequence_header(data, true, &optionals, false)?;
        self.eutra_mode_info.encode(data)?;
        self.eutra_prach_configuration.encode(data)?;

        Ok(())
    }
}

impl AperCodec for ResourceCoordinationEutraCellInfo {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        ResourceCoordinationEutraCellInfo::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("ResourceCoordinationEutraCellInfo"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("ResourceCoordinationEutraCellInfo"))
    }
}
// ResourceCoordinationTransferInformation
#[derive(Clone, Debug)]
pub struct ResourceCoordinationTransferInformation {
    pub m_enb_cell_id: EutraCellId,
    pub resource_coordination_eutra_cell_info: Option<ResourceCoordinationEutraCellInfo>,
}

impl ResourceCoordinationTransferInformation {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (optionals, _extensions_present) = aper::decode::decode_sequence_header(data, true, 2)?;
        let m_enb_cell_id = EutraCellId::decode(data)?;
        let resource_coordination_eutra_cell_info = if optionals[0] {
            Some(ResourceCoordinationEutraCellInfo::decode(data)?)
        } else {
            None
        };

        Ok(Self {
            m_enb_cell_id,
            resource_coordination_eutra_cell_info,
        })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(self.resource_coordination_eutra_cell_info.is_some());
        optionals.push(false);

        aper::encode::encode_sequence_header(data, true, &optionals, false)?;
        self.m_enb_cell_id.encode(data)?;
        if let Some(x) = &self.resource_coordination_eutra_cell_info {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl AperCodec for ResourceCoordinationTransferInformation {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        ResourceCoordinationTransferInformation::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("ResourceCoordinationTransferInformation"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("ResourceCoordinationTransferInformation"))
    }
}
// ResourceCoordinationTransferContainer
#[derive(Clone, Debug)]
pub struct ResourceCoordinationTransferContainer(pub Vec<u8>);

impl ResourceCoordinationTransferContainer {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        Ok(Self(aper::decode::decode_octetstring(
            data, None, None, false,
        )?))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_octetstring(data, None, None, false, &self.0, false)
    }
}

impl AperCodec for ResourceCoordinationTransferContainer {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        ResourceCoordinationTransferContainer::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("ResourceCoordinationTransferContainer"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("ResourceCoordinationTransferContainer"))
    }
}
// ResourceSetType
#[derive(Clone, Debug)]
pub enum ResourceSetType {
    Periodic(ResourceSetTypePeriodic),
    SemiPersistent(ResourceSetTypeSemiPersistent),
    Aperiodic(ResourceSetTypeAperiodic),
}

impl ResourceSetType {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (idx, extended) = aper::decode::decode_choice_idx(data, 0, 3, false)?;
        if extended {
            return Err(aper::AperCodecError::new(
                "CHOICE additions not implemented",
            ));
        }
        match idx {
            0 => Ok(Self::Periodic(ResourceSetTypePeriodic::decode(data)?)),
            1 => Ok(Self::SemiPersistent(ResourceSetTypeSemiPersistent::decode(
                data,
            )?)),
            2 => Ok(Self::Aperiodic(ResourceSetTypeAperiodic::decode(data)?)),
            3 => Err(AperCodecError::new(
                "Choice extension container not implemented",
            )),
            _ => Err(AperCodecError::new("Unknown choice idx")),
        }
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        match self {
            Self::Periodic(x) => {
                aper::encode::encode_choice_idx(data, 0, 3, false, 0, false)?;
                x.encode(data)
            }
            Self::SemiPersistent(x) => {
                aper::encode::encode_choice_idx(data, 0, 3, false, 1, false)?;
                x.encode(data)
            }
            Self::Aperiodic(x) => {
                aper::encode::encode_choice_idx(data, 0, 3, false, 2, false)?;
                x.encode(data)
            }
        }
    }
}

impl AperCodec for ResourceSetType {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        ResourceSetType::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("ResourceSetType"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("ResourceSetType"))
    }
}
// ResourceSetTypePeriodic
#[derive(Clone, Debug)]
pub struct ResourceSetTypePeriodic {
    pub periodic_set: PeriodicSet,
}

impl ResourceSetTypePeriodic {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (_optionals, _extensions_present) =
            aper::decode::decode_sequence_header(data, false, 1)?;
        let periodic_set = PeriodicSet::decode(data)?;

        Ok(Self { periodic_set })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(false);

        aper::encode::encode_sequence_header(data, false, &optionals, false)?;
        self.periodic_set.encode(data)?;

        Ok(())
    }
}

impl AperCodec for ResourceSetTypePeriodic {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        ResourceSetTypePeriodic::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("ResourceSetTypePeriodic"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("ResourceSetTypePeriodic"))
    }
}
// ResourceSetTypeSemiPersistent
#[derive(Clone, Debug)]
pub struct ResourceSetTypeSemiPersistent {
    pub semi_persistent_set: SemiPersistentSet,
}

impl ResourceSetTypeSemiPersistent {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (_optionals, _extensions_present) =
            aper::decode::decode_sequence_header(data, false, 1)?;
        let semi_persistent_set = SemiPersistentSet::decode(data)?;

        Ok(Self {
            semi_persistent_set,
        })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(false);

        aper::encode::encode_sequence_header(data, false, &optionals, false)?;
        self.semi_persistent_set.encode(data)?;

        Ok(())
    }
}

impl AperCodec for ResourceSetTypeSemiPersistent {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        ResourceSetTypeSemiPersistent::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("ResourceSetTypeSemiPersistent"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("ResourceSetTypeSemiPersistent"))
    }
}
// ResourceSetTypeAperiodic
#[derive(Clone, Debug)]
pub struct ResourceSetTypeAperiodic {
    pub srs_resource_trigger_list: u8,
    pub slotoffset: u8,
}

impl ResourceSetTypeAperiodic {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (_optionals, _extensions_present) =
            aper::decode::decode_sequence_header(data, false, 1)?;
        let srs_resource_trigger_list =
            aper::decode::decode_integer(data, Some(1), Some(3), false)?.0 as u8;
        let slotoffset = aper::decode::decode_integer(data, Some(0), Some(32), false)?.0 as u8;

        Ok(Self {
            srs_resource_trigger_list,
            slotoffset,
        })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(false);

        aper::encode::encode_sequence_header(data, false, &optionals, false)?;
        aper::encode::encode_integer(
            data,
            Some(1),
            Some(3),
            false,
            self.srs_resource_trigger_list as i128,
            false,
        )?;
        aper::encode::encode_integer(
            data,
            Some(0),
            Some(32),
            false,
            self.slotoffset as i128,
            false,
        )?;

        Ok(())
    }
}

impl AperCodec for ResourceSetTypeAperiodic {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        ResourceSetTypeAperiodic::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("ResourceSetTypeAperiodic"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("ResourceSetTypeAperiodic"))
    }
}
// RepetitionPeriod
#[derive(Clone, Debug)]
pub struct RepetitionPeriod(pub u32);

impl RepetitionPeriod {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        Ok(Self(
            aper::decode::decode_integer(data, Some(0), Some(131071), true)?.0 as u32,
        ))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_integer(data, Some(0), Some(131071), true, self.0 as i128, false)
    }
}

impl AperCodec for RepetitionPeriod {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        RepetitionPeriod::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("RepetitionPeriod"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("RepetitionPeriod"))
    }
}
// ReportingRequestType
#[derive(Clone, Debug)]
pub struct ReportingRequestType {
    pub event_type: EventType,
    pub reporting_periodicity_value: Option<ReportingPeriodicityValue>,
}

impl ReportingRequestType {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (optionals, _extensions_present) =
            aper::decode::decode_sequence_header(data, false, 2)?;
        let event_type = EventType::decode(data)?;
        let reporting_periodicity_value = if optionals[0] {
            Some(ReportingPeriodicityValue::decode(data)?)
        } else {
            None
        };

        Ok(Self {
            event_type,
            reporting_periodicity_value,
        })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(self.reporting_periodicity_value.is_some());
        optionals.push(false);

        aper::encode::encode_sequence_header(data, false, &optionals, false)?;
        self.event_type.encode(data)?;
        if let Some(x) = &self.reporting_periodicity_value {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl AperCodec for ReportingRequestType {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        ReportingRequestType::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("ReportingRequestType"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("ReportingRequestType"))
    }
}
// ResourceType
#[derive(Clone, Debug)]
pub enum ResourceType {
    Periodic(ResourceTypePeriodic),
    SemiPersistent(ResourceTypeSemiPersistent),
    Aperiodic(ResourceTypeAperiodic),
}

impl ResourceType {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (idx, extended) = aper::decode::decode_choice_idx(data, 0, 3, false)?;
        if extended {
            return Err(aper::AperCodecError::new(
                "CHOICE additions not implemented",
            ));
        }
        match idx {
            0 => Ok(Self::Periodic(ResourceTypePeriodic::decode(data)?)),
            1 => Ok(Self::SemiPersistent(ResourceTypeSemiPersistent::decode(
                data,
            )?)),
            2 => Ok(Self::Aperiodic(ResourceTypeAperiodic::decode(data)?)),
            3 => Err(AperCodecError::new(
                "Choice extension container not implemented",
            )),
            _ => Err(AperCodecError::new("Unknown choice idx")),
        }
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        match self {
            Self::Periodic(x) => {
                aper::encode::encode_choice_idx(data, 0, 3, false, 0, false)?;
                x.encode(data)
            }
            Self::SemiPersistent(x) => {
                aper::encode::encode_choice_idx(data, 0, 3, false, 1, false)?;
                x.encode(data)
            }
            Self::Aperiodic(x) => {
                aper::encode::encode_choice_idx(data, 0, 3, false, 2, false)?;
                x.encode(data)
            }
        }
    }
}

impl AperCodec for ResourceType {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        ResourceType::decode_inner(data).map_err(|e: AperCodecError| e.push_context("ResourceType"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("ResourceType"))
    }
}
// ResourceTypePeriodic
#[derive(Clone, Debug)]
pub struct ResourceTypePeriodic {
    pub periodicity: Periodicity1,
    pub offset: u16,
}

impl ResourceTypePeriodic {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (_optionals, _extensions_present) =
            aper::decode::decode_sequence_header(data, false, 1)?;
        let periodicity = Periodicity1::decode(data)?;
        let offset = aper::decode::decode_integer(data, Some(0), Some(2559), true)?.0 as u16;

        Ok(Self {
            periodicity,
            offset,
        })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(false);

        aper::encode::encode_sequence_header(data, false, &optionals, false)?;
        self.periodicity.encode(data)?;
        aper::encode::encode_integer(data, Some(0), Some(2559), true, self.offset as i128, false)?;

        Ok(())
    }
}

impl AperCodec for ResourceTypePeriodic {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        ResourceTypePeriodic::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("ResourceTypePeriodic"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("ResourceTypePeriodic"))
    }
}
// ResourceTypeSemiPersistent
#[derive(Clone, Debug)]
pub struct ResourceTypeSemiPersistent {
    pub periodicity: Periodicity2,
    pub offset: u16,
}

impl ResourceTypeSemiPersistent {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (_optionals, _extensions_present) =
            aper::decode::decode_sequence_header(data, false, 1)?;
        let periodicity = Periodicity2::decode(data)?;
        let offset = aper::decode::decode_integer(data, Some(0), Some(2559), true)?.0 as u16;

        Ok(Self {
            periodicity,
            offset,
        })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(false);

        aper::encode::encode_sequence_header(data, false, &optionals, false)?;
        self.periodicity.encode(data)?;
        aper::encode::encode_integer(data, Some(0), Some(2559), true, self.offset as i128, false)?;

        Ok(())
    }
}

impl AperCodec for ResourceTypeSemiPersistent {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        ResourceTypeSemiPersistent::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("ResourceTypeSemiPersistent"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("ResourceTypeSemiPersistent"))
    }
}
// ResourceTypeAperiodic
#[derive(Clone, Debug)]
pub struct ResourceTypeAperiodic {
    pub aperiodic_resource_type: AperiodicResourceType,
}

impl ResourceTypeAperiodic {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (_optionals, _extensions_present) =
            aper::decode::decode_sequence_header(data, false, 1)?;
        let aperiodic_resource_type = AperiodicResourceType::decode(data)?;

        Ok(Self {
            aperiodic_resource_type,
        })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(false);

        aper::encode::encode_sequence_header(data, false, &optionals, false)?;
        self.aperiodic_resource_type.encode(data)?;

        Ok(())
    }
}

impl AperCodec for ResourceTypeAperiodic {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        ResourceTypeAperiodic::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("ResourceTypeAperiodic"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("ResourceTypeAperiodic"))
    }
}
// ResourceTypePos
#[derive(Clone, Debug)]
pub enum ResourceTypePos {
    Periodic(ResourceTypePeriodicPos),
    SemiPersistent(ResourceTypeSemiPersistentPos),
    Aperiodic(ResourceTypeAperiodicPos),
}

impl ResourceTypePos {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (idx, extended) = aper::decode::decode_choice_idx(data, 0, 3, false)?;
        if extended {
            return Err(aper::AperCodecError::new(
                "CHOICE additions not implemented",
            ));
        }
        match idx {
            0 => Ok(Self::Periodic(ResourceTypePeriodicPos::decode(data)?)),
            1 => Ok(Self::SemiPersistent(ResourceTypeSemiPersistentPos::decode(
                data,
            )?)),
            2 => Ok(Self::Aperiodic(ResourceTypeAperiodicPos::decode(data)?)),
            3 => Err(AperCodecError::new(
                "Choice extension container not implemented",
            )),
            _ => Err(AperCodecError::new("Unknown choice idx")),
        }
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        match self {
            Self::Periodic(x) => {
                aper::encode::encode_choice_idx(data, 0, 3, false, 0, false)?;
                x.encode(data)
            }
            Self::SemiPersistent(x) => {
                aper::encode::encode_choice_idx(data, 0, 3, false, 1, false)?;
                x.encode(data)
            }
            Self::Aperiodic(x) => {
                aper::encode::encode_choice_idx(data, 0, 3, false, 2, false)?;
                x.encode(data)
            }
        }
    }
}

impl AperCodec for ResourceTypePos {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        ResourceTypePos::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("ResourceTypePos"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("ResourceTypePos"))
    }
}
// ResourceTypePeriodicPos
#[derive(Clone, Debug)]
pub struct ResourceTypePeriodicPos {
    pub periodicity: Periodicity3,
    pub offset: u32,
}

impl ResourceTypePeriodicPos {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (_optionals, _extensions_present) =
            aper::decode::decode_sequence_header(data, false, 1)?;
        let periodicity = Periodicity3::decode(data)?;
        let offset = aper::decode::decode_integer(data, Some(0), Some(81919), true)?.0 as u32;

        Ok(Self {
            periodicity,
            offset,
        })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(false);

        aper::encode::encode_sequence_header(data, false, &optionals, false)?;
        self.periodicity.encode(data)?;
        aper::encode::encode_integer(data, Some(0), Some(81919), true, self.offset as i128, false)?;

        Ok(())
    }
}

impl AperCodec for ResourceTypePeriodicPos {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        ResourceTypePeriodicPos::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("ResourceTypePeriodicPos"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("ResourceTypePeriodicPos"))
    }
}
// ResourceTypeSemiPersistentPos
#[derive(Clone, Debug)]
pub struct ResourceTypeSemiPersistentPos {
    pub periodicity: Periodicity4,
    pub offset: u32,
}

impl ResourceTypeSemiPersistentPos {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (_optionals, _extensions_present) =
            aper::decode::decode_sequence_header(data, false, 1)?;
        let periodicity = Periodicity4::decode(data)?;
        let offset = aper::decode::decode_integer(data, Some(0), Some(81919), true)?.0 as u32;

        Ok(Self {
            periodicity,
            offset,
        })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(false);

        aper::encode::encode_sequence_header(data, false, &optionals, false)?;
        self.periodicity.encode(data)?;
        aper::encode::encode_integer(data, Some(0), Some(81919), true, self.offset as i128, false)?;

        Ok(())
    }
}

impl AperCodec for ResourceTypeSemiPersistentPos {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        ResourceTypeSemiPersistentPos::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("ResourceTypeSemiPersistentPos"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("ResourceTypeSemiPersistentPos"))
    }
}
// ResourceTypeAperiodicPos
#[derive(Clone, Debug)]
pub struct ResourceTypeAperiodicPos {
    pub slot_offset: u8,
}

impl ResourceTypeAperiodicPos {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (_optionals, _extensions_present) =
            aper::decode::decode_sequence_header(data, false, 1)?;
        let slot_offset = aper::decode::decode_integer(data, Some(0), Some(32), false)?.0 as u8;

        Ok(Self { slot_offset })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(false);

        aper::encode::encode_sequence_header(data, false, &optionals, false)?;
        aper::encode::encode_integer(
            data,
            Some(0),
            Some(32),
            false,
            self.slot_offset as i128,
            false,
        )?;

        Ok(())
    }
}

impl AperCodec for ResourceTypeAperiodicPos {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        ResourceTypeAperiodicPos::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("ResourceTypeAperiodicPos"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("ResourceTypeAperiodicPos"))
    }
}
// RlcDuplicationInformation
#[derive(Clone, Debug)]
pub struct RlcDuplicationInformation {
    pub rlc_duplication_state_list: RlcDuplicationStateList,
    pub primary_path_indication: Option<PrimaryPathIndication>,
}

impl RlcDuplicationInformation {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (optionals, _extensions_present) =
            aper::decode::decode_sequence_header(data, false, 2)?;
        let rlc_duplication_state_list = RlcDuplicationStateList::decode(data)?;
        let primary_path_indication = if optionals[0] {
            Some(PrimaryPathIndication::decode(data)?)
        } else {
            None
        };

        Ok(Self {
            rlc_duplication_state_list,
            primary_path_indication,
        })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(self.primary_path_indication.is_some());
        optionals.push(false);

        aper::encode::encode_sequence_header(data, false, &optionals, false)?;
        self.rlc_duplication_state_list.encode(data)?;
        if let Some(x) = &self.primary_path_indication {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl AperCodec for RlcDuplicationInformation {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        RlcDuplicationInformation::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("RlcDuplicationInformation"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("RlcDuplicationInformation"))
    }
}
// RlcDuplicationStateList
#[derive(Clone, Debug)]
pub struct RlcDuplicationStateList(pub Vec<RlcDuplicationStateItem>);

impl RlcDuplicationStateList {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        Ok(Self({
            let length = aper::decode::decode_length_determinent(data, Some(1), Some(3), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(RlcDuplicationStateItem::decode(data)?);
            }
            items
        }))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_length_determinent(data, Some(1), Some(3), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl AperCodec for RlcDuplicationStateList {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        RlcDuplicationStateList::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("RlcDuplicationStateList"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("RlcDuplicationStateList"))
    }
}
// RlcDuplicationStateItem
#[derive(Clone, Debug)]
pub struct RlcDuplicationStateItem {
    pub duplication_state: DuplicationState,
}

impl RlcDuplicationStateItem {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (_optionals, _extensions_present) =
            aper::decode::decode_sequence_header(data, true, 1)?;
        let duplication_state = DuplicationState::decode(data)?;

        Ok(Self { duplication_state })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(false);

        aper::encode::encode_sequence_header(data, true, &optionals, false)?;
        self.duplication_state.encode(data)?;

        Ok(())
    }
}

impl AperCodec for RlcDuplicationStateItem {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        RlcDuplicationStateItem::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("RlcDuplicationStateItem"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("RlcDuplicationStateItem"))
    }
}
// RlcFailureIndication
#[derive(Clone, Debug)]
pub struct RlcFailureIndication {
    pub assocated_lcid: Lcid,
}

impl RlcFailureIndication {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (_optionals, _extensions_present) =
            aper::decode::decode_sequence_header(data, false, 1)?;
        let assocated_lcid = Lcid::decode(data)?;

        Ok(Self { assocated_lcid })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(false);

        aper::encode::encode_sequence_header(data, false, &optionals, false)?;
        self.assocated_lcid.encode(data)?;

        Ok(())
    }
}

impl AperCodec for RlcFailureIndication {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        RlcFailureIndication::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("RlcFailureIndication"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("RlcFailureIndication"))
    }
}
// RlcMode
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum RlcMode {
    RlcAm,
    RlcUmBidirectional,
    RlcUmUnidirectionalUl,
    RlcUmUnidirectionalDl,
}

impl RlcMode {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (idx, extended) = aper::decode::decode_enumerated(data, Some(0), Some(3), true)?;
        if extended {
            return Err(aper::AperCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| AperCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_enumerated(data, Some(0), Some(3), true, *self as i128, false)
    }
}

impl AperCodec for RlcMode {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        RlcMode::decode_inner(data).map_err(|e: AperCodecError| e.push_context("RlcMode"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("RlcMode"))
    }
}
// RlcStatus
#[derive(Clone, Debug)]
pub struct RlcStatus {
    pub reestablishment_indication: ReestablishmentIndication,
}

impl RlcStatus {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (_optionals, _extensions_present) =
            aper::decode::decode_sequence_header(data, true, 1)?;
        let reestablishment_indication = ReestablishmentIndication::decode(data)?;

        Ok(Self {
            reestablishment_indication,
        })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(false);

        aper::encode::encode_sequence_header(data, true, &optionals, false)?;
        self.reestablishment_indication.encode(data)?;

        Ok(())
    }
}

impl AperCodec for RlcStatus {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        RlcStatus::decode_inner(data).map_err(|e: AperCodecError| e.push_context("RlcStatus"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("RlcStatus"))
    }
}
// RlfReportInformationList
#[derive(Clone, Debug)]
pub struct RlfReportInformationList(pub Vec<RlfReportInformationItem>);

impl RlfReportInformationList {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        Ok(Self({
            let length = aper::decode::decode_length_determinent(data, Some(1), Some(64), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(RlfReportInformationItem::decode(data)?);
            }
            items
        }))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_length_determinent(data, Some(1), Some(64), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl AperCodec for RlfReportInformationList {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        RlfReportInformationList::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("RlfReportInformationList"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("RlfReportInformationList"))
    }
}
// RlfReportInformationItem
#[derive(Clone, Debug)]
pub struct RlfReportInformationItem {
    pub nrue_rlf_report_container: NrueRlfReportContainer,
    pub ue_assitant_identifier: Option<GnbDuUeF1apId>,
}

impl RlfReportInformationItem {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (optionals, _extensions_present) = aper::decode::decode_sequence_header(data, true, 2)?;
        let nrue_rlf_report_container = NrueRlfReportContainer::decode(data)?;
        let ue_assitant_identifier = if optionals[0] {
            Some(GnbDuUeF1apId::decode(data)?)
        } else {
            None
        };

        Ok(Self {
            nrue_rlf_report_container,
            ue_assitant_identifier,
        })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(self.ue_assitant_identifier.is_some());
        optionals.push(false);

        aper::encode::encode_sequence_header(data, true, &optionals, false)?;
        self.nrue_rlf_report_container.encode(data)?;
        if let Some(x) = &self.ue_assitant_identifier {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl AperCodec for RlfReportInformationItem {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        RlfReportInformationItem::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("RlfReportInformationItem"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("RlfReportInformationItem"))
    }
}
// RimrsDetectionStatus
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum RimrsDetectionStatus {
    RsDetected,
    RsDisappeared,
}

impl RimrsDetectionStatus {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (idx, extended) = aper::decode::decode_enumerated(data, Some(0), Some(1), true)?;
        if extended {
            return Err(aper::AperCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| AperCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_enumerated(data, Some(0), Some(1), true, *self as i128, false)
    }
}

impl AperCodec for RimrsDetectionStatus {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        RimrsDetectionStatus::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("RimrsDetectionStatus"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("RimrsDetectionStatus"))
    }
}
// RrcContainer
#[derive(Clone, Debug)]
pub struct RrcContainer(pub Vec<u8>);

impl RrcContainer {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        Ok(Self(aper::decode::decode_octetstring(
            data, None, None, false,
        )?))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_octetstring(data, None, None, false, &self.0, false)
    }
}

impl AperCodec for RrcContainer {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        RrcContainer::decode_inner(data).map_err(|e: AperCodecError| e.push_context("RrcContainer"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("RrcContainer"))
    }
}
// RrcContainerRrcSetupComplete
#[derive(Clone, Debug)]
pub struct RrcContainerRrcSetupComplete(pub Vec<u8>);

impl RrcContainerRrcSetupComplete {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        Ok(Self(aper::decode::decode_octetstring(
            data, None, None, false,
        )?))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_octetstring(data, None, None, false, &self.0, false)
    }
}

impl AperCodec for RrcContainerRrcSetupComplete {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        RrcContainerRrcSetupComplete::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("RrcContainerRrcSetupComplete"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("RrcContainerRrcSetupComplete"))
    }
}
// RrcDeliveryStatus
#[derive(Clone, Debug)]
pub struct RrcDeliveryStatus {
    pub delivery_status: PdcpSn,
    pub triggering_message: PdcpSn,
}

impl RrcDeliveryStatus {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (_optionals, _extensions_present) =
            aper::decode::decode_sequence_header(data, false, 1)?;
        let delivery_status = PdcpSn::decode(data)?;
        let triggering_message = PdcpSn::decode(data)?;

        Ok(Self {
            delivery_status,
            triggering_message,
        })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(false);

        aper::encode::encode_sequence_header(data, false, &optionals, false)?;
        self.delivery_status.encode(data)?;
        self.triggering_message.encode(data)?;

        Ok(())
    }
}

impl AperCodec for RrcDeliveryStatus {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        RrcDeliveryStatus::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("RrcDeliveryStatus"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("RrcDeliveryStatus"))
    }
}
// RrcDeliveryStatusRequest
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum RrcDeliveryStatusRequest {
    True,
}

impl RrcDeliveryStatusRequest {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (idx, extended) = aper::decode::decode_enumerated(data, Some(0), Some(0), true)?;
        if extended {
            return Err(aper::AperCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| AperCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_enumerated(data, Some(0), Some(0), true, *self as i128, false)
    }
}

impl AperCodec for RrcDeliveryStatusRequest {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        RrcDeliveryStatusRequest::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("RrcDeliveryStatusRequest"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("RrcDeliveryStatusRequest"))
    }
}
// RrcReconfigurationCompleteIndicator
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum RrcReconfigurationCompleteIndicator {
    True,
}

impl RrcReconfigurationCompleteIndicator {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (idx, extended) = aper::decode::decode_enumerated(data, Some(0), Some(0), true)?;
        if extended {
            return Err(aper::AperCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| AperCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_enumerated(data, Some(0), Some(0), true, *self as i128, false)
    }
}

impl AperCodec for RrcReconfigurationCompleteIndicator {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        RrcReconfigurationCompleteIndicator::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("RrcReconfigurationCompleteIndicator"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("RrcReconfigurationCompleteIndicator"))
    }
}
// RrcVersion
#[derive(Clone, Debug)]
pub struct RrcVersion {
    pub latest_rrc_version: BitString,
}

impl RrcVersion {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (_optionals, _extensions_present) =
            aper::decode::decode_sequence_header(data, false, 1)?;
        let latest_rrc_version = aper::decode::decode_bitstring(data, Some(3), Some(3), false)?;

        Ok(Self { latest_rrc_version })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(false);

        aper::encode::encode_sequence_header(data, false, &optionals, false)?;
        aper::encode::encode_bitstring(
            data,
            Some(3),
            Some(3),
            false,
            &self.latest_rrc_version,
            false,
        )?;

        Ok(())
    }
}

impl AperCodec for RrcVersion {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        RrcVersion::decode_inner(data).map_err(|e: AperCodecError| e.push_context("RrcVersion"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("RrcVersion"))
    }
}
// RoutingId
#[derive(Clone, Debug)]
pub struct RoutingId(pub Vec<u8>);

impl RoutingId {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        Ok(Self(aper::decode::decode_octetstring(
            data, None, None, false,
        )?))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_octetstring(data, None, None, false, &self.0, false)
    }
}

impl AperCodec for RoutingId {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        RoutingId::decode_inner(data).map_err(|e: AperCodecError| e.push_context("RoutingId"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("RoutingId"))
    }
}
// SCellFailedtoSetupItem
#[derive(Clone, Debug)]
pub struct SCellFailedtoSetupItem {
    pub s_cell_id: Nrcgi,
    pub cause: Option<Cause>,
}

impl SCellFailedtoSetupItem {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (optionals, _extensions_present) = aper::decode::decode_sequence_header(data, true, 2)?;
        let s_cell_id = Nrcgi::decode(data)?;
        let cause = if optionals[0] {
            Some(Cause::decode(data)?)
        } else {
            None
        };

        Ok(Self { s_cell_id, cause })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(self.cause.is_some());
        optionals.push(false);

        aper::encode::encode_sequence_header(data, true, &optionals, false)?;
        self.s_cell_id.encode(data)?;
        if let Some(x) = &self.cause {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl AperCodec for SCellFailedtoSetupItem {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        SCellFailedtoSetupItem::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("SCellFailedtoSetupItem"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("SCellFailedtoSetupItem"))
    }
}
// SCellFailedtoSetupModItem
#[derive(Clone, Debug)]
pub struct SCellFailedtoSetupModItem {
    pub s_cell_id: Nrcgi,
    pub cause: Option<Cause>,
}

impl SCellFailedtoSetupModItem {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (optionals, _extensions_present) = aper::decode::decode_sequence_header(data, true, 2)?;
        let s_cell_id = Nrcgi::decode(data)?;
        let cause = if optionals[0] {
            Some(Cause::decode(data)?)
        } else {
            None
        };

        Ok(Self { s_cell_id, cause })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(self.cause.is_some());
        optionals.push(false);

        aper::encode::encode_sequence_header(data, true, &optionals, false)?;
        self.s_cell_id.encode(data)?;
        if let Some(x) = &self.cause {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl AperCodec for SCellFailedtoSetupModItem {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        SCellFailedtoSetupModItem::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("SCellFailedtoSetupModItem"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("SCellFailedtoSetupModItem"))
    }
}
// SCellToBeRemovedItem
#[derive(Clone, Debug)]
pub struct SCellToBeRemovedItem {
    pub s_cell_id: Nrcgi,
}

impl SCellToBeRemovedItem {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (_optionals, _extensions_present) =
            aper::decode::decode_sequence_header(data, true, 1)?;
        let s_cell_id = Nrcgi::decode(data)?;

        Ok(Self { s_cell_id })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(false);

        aper::encode::encode_sequence_header(data, true, &optionals, false)?;
        self.s_cell_id.encode(data)?;

        Ok(())
    }
}

impl AperCodec for SCellToBeRemovedItem {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        SCellToBeRemovedItem::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("SCellToBeRemovedItem"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("SCellToBeRemovedItem"))
    }
}
// SCellToBeSetupItem
#[derive(Clone, Debug)]
pub struct SCellToBeSetupItem {
    pub s_cell_id: Nrcgi,
    pub s_cell_index: SCellIndex,
    pub s_cell_ul_configured: Option<CellUlConfigured>,
}

impl SCellToBeSetupItem {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (optionals, _extensions_present) = aper::decode::decode_sequence_header(data, true, 2)?;
        let s_cell_id = Nrcgi::decode(data)?;
        let s_cell_index = SCellIndex::decode(data)?;
        let s_cell_ul_configured = if optionals[0] {
            Some(CellUlConfigured::decode(data)?)
        } else {
            None
        };

        Ok(Self {
            s_cell_id,
            s_cell_index,
            s_cell_ul_configured,
        })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(self.s_cell_ul_configured.is_some());
        optionals.push(false);

        aper::encode::encode_sequence_header(data, true, &optionals, false)?;
        self.s_cell_id.encode(data)?;
        self.s_cell_index.encode(data)?;
        if let Some(x) = &self.s_cell_ul_configured {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl AperCodec for SCellToBeSetupItem {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        SCellToBeSetupItem::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("SCellToBeSetupItem"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("SCellToBeSetupItem"))
    }
}
// SCellToBeSetupModItem
#[derive(Clone, Debug)]
pub struct SCellToBeSetupModItem {
    pub s_cell_id: Nrcgi,
    pub s_cell_index: SCellIndex,
    pub s_cell_ul_configured: Option<CellUlConfigured>,
}

impl SCellToBeSetupModItem {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (optionals, _extensions_present) = aper::decode::decode_sequence_header(data, true, 2)?;
        let s_cell_id = Nrcgi::decode(data)?;
        let s_cell_index = SCellIndex::decode(data)?;
        let s_cell_ul_configured = if optionals[0] {
            Some(CellUlConfigured::decode(data)?)
        } else {
            None
        };

        Ok(Self {
            s_cell_id,
            s_cell_index,
            s_cell_ul_configured,
        })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(self.s_cell_ul_configured.is_some());
        optionals.push(false);

        aper::encode::encode_sequence_header(data, true, &optionals, false)?;
        self.s_cell_id.encode(data)?;
        self.s_cell_index.encode(data)?;
        if let Some(x) = &self.s_cell_ul_configured {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl AperCodec for SCellToBeSetupModItem {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        SCellToBeSetupModItem::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("SCellToBeSetupModItem"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("SCellToBeSetupModItem"))
    }
}
// SCellIndex
#[derive(Clone, Debug)]
pub struct SCellIndex(pub u8);

impl SCellIndex {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        Ok(Self(
            aper::decode::decode_integer(data, Some(1), Some(31), true)?.0 as u8,
        ))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_integer(data, Some(1), Some(31), true, self.0 as i128, false)
    }
}

impl AperCodec for SCellIndex {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        SCellIndex::decode_inner(data).map_err(|e: AperCodecError| e.push_context("SCellIndex"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("SCellIndex"))
    }
}
// ScgIndicator
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum ScgIndicator {
    Released,
}

impl ScgIndicator {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (idx, extended) = aper::decode::decode_enumerated(data, Some(0), Some(0), true)?;
        if extended {
            return Err(aper::AperCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| AperCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_enumerated(data, Some(0), Some(0), true, *self as i128, false)
    }
}

impl AperCodec for ScgIndicator {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        ScgIndicator::decode_inner(data).map_err(|e: AperCodecError| e.push_context("ScgIndicator"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("ScgIndicator"))
    }
}
// ScsSpecificCarrier
#[derive(Clone, Debug)]
pub struct ScsSpecificCarrier {
    pub offset_to_carrier: u16,
    pub subcarrier_spacing: SubcarrierSpacing3,
    pub carrier_bandwidth: u16,
}

impl ScsSpecificCarrier {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (_optionals, _extensions_present) =
            aper::decode::decode_sequence_header(data, false, 1)?;
        let offset_to_carrier =
            aper::decode::decode_integer(data, Some(0), Some(2199), true)?.0 as u16;
        let subcarrier_spacing = SubcarrierSpacing3::decode(data)?;
        let carrier_bandwidth =
            aper::decode::decode_integer(data, Some(1), Some(275), true)?.0 as u16;

        Ok(Self {
            offset_to_carrier,
            subcarrier_spacing,
            carrier_bandwidth,
        })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(false);

        aper::encode::encode_sequence_header(data, false, &optionals, false)?;
        aper::encode::encode_integer(
            data,
            Some(0),
            Some(2199),
            true,
            self.offset_to_carrier as i128,
            false,
        )?;
        self.subcarrier_spacing.encode(data)?;
        aper::encode::encode_integer(
            data,
            Some(1),
            Some(275),
            true,
            self.carrier_bandwidth as i128,
            false,
        )?;

        Ok(())
    }
}

impl AperCodec for ScsSpecificCarrier {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        ScsSpecificCarrier::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("ScsSpecificCarrier"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("ScsSpecificCarrier"))
    }
}
// SearchWindowInformation
#[derive(Clone, Debug)]
pub struct SearchWindowInformation {
    pub expected_propagation_delay: i16,
    pub delay_uncertainty: u8,
}

impl SearchWindowInformation {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (_optionals, _extensions_present) =
            aper::decode::decode_sequence_header(data, false, 1)?;
        let expected_propagation_delay =
            aper::decode::decode_integer(data, Some(-3841), Some(3841), true)?.0 as i16;
        let delay_uncertainty =
            aper::decode::decode_integer(data, Some(1), Some(246), true)?.0 as u8;

        Ok(Self {
            expected_propagation_delay,
            delay_uncertainty,
        })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(false);

        aper::encode::encode_sequence_header(data, false, &optionals, false)?;
        aper::encode::encode_integer(
            data,
            Some(-3841),
            Some(3841),
            true,
            self.expected_propagation_delay as i128,
            false,
        )?;
        aper::encode::encode_integer(
            data,
            Some(1),
            Some(246),
            true,
            self.delay_uncertainty as i128,
            false,
        )?;

        Ok(())
    }
}

impl AperCodec for SearchWindowInformation {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        SearchWindowInformation::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("SearchWindowInformation"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("SearchWindowInformation"))
    }
}
// SerialNumber
#[derive(Clone, Debug)]
pub struct SerialNumber(pub BitString);

impl SerialNumber {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        Ok(Self(aper::decode::decode_bitstring(
            data,
            Some(16),
            Some(16),
            false,
        )?))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_bitstring(data, Some(16), Some(16), false, &self.0, false)
    }
}

impl AperCodec for SerialNumber {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        SerialNumber::decode_inner(data).map_err(|e: AperCodecError| e.push_context("SerialNumber"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("SerialNumber"))
    }
}
// SibTypePws
#[derive(Clone, Debug)]
pub struct SibTypePws(pub u8);

impl SibTypePws {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        Ok(Self(
            aper::decode::decode_integer(data, Some(6), Some(8), true)?.0 as u8,
        ))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_integer(data, Some(6), Some(8), true, self.0 as i128, false)
    }
}

impl AperCodec for SibTypePws {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        SibTypePws::decode_inner(data).map_err(|e: AperCodecError| e.push_context("SibTypePws"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("SibTypePws"))
    }
}
// SelectedBandCombinationIndex
#[derive(Clone, Debug)]
pub struct SelectedBandCombinationIndex(pub Vec<u8>);

impl SelectedBandCombinationIndex {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        Ok(Self(aper::decode::decode_octetstring(
            data, None, None, false,
        )?))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_octetstring(data, None, None, false, &self.0, false)
    }
}

impl AperCodec for SelectedBandCombinationIndex {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        SelectedBandCombinationIndex::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("SelectedBandCombinationIndex"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("SelectedBandCombinationIndex"))
    }
}
// SelectedFeatureSetEntryIndex
#[derive(Clone, Debug)]
pub struct SelectedFeatureSetEntryIndex(pub Vec<u8>);

impl SelectedFeatureSetEntryIndex {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        Ok(Self(aper::decode::decode_octetstring(
            data, None, None, false,
        )?))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_octetstring(data, None, None, false, &self.0, false)
    }
}

impl AperCodec for SelectedFeatureSetEntryIndex {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        SelectedFeatureSetEntryIndex::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("SelectedFeatureSetEntryIndex"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("SelectedFeatureSetEntryIndex"))
    }
}
// CgConfigInfo
#[derive(Clone, Debug)]
pub struct CgConfigInfo(pub Vec<u8>);

impl CgConfigInfo {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        Ok(Self(aper::decode::decode_octetstring(
            data, None, None, false,
        )?))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_octetstring(data, None, None, false, &self.0, false)
    }
}

impl AperCodec for CgConfigInfo {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        CgConfigInfo::decode_inner(data).map_err(|e: AperCodecError| e.push_context("CgConfigInfo"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("CgConfigInfo"))
    }
}
// ServCellIndex
#[derive(Clone, Debug)]
pub struct ServCellIndex(pub u8);

impl ServCellIndex {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        Ok(Self(
            aper::decode::decode_integer(data, Some(0), Some(31), true)?.0 as u8,
        ))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_integer(data, Some(0), Some(31), true, self.0 as i128, false)
    }
}

impl AperCodec for ServCellIndex {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        ServCellIndex::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("ServCellIndex"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("ServCellIndex"))
    }
}
// ServingCellMo
#[derive(Clone, Debug)]
pub struct ServingCellMo(pub u8);

impl ServingCellMo {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        Ok(Self(
            aper::decode::decode_integer(data, Some(1), Some(64), true)?.0 as u8,
        ))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_integer(data, Some(1), Some(64), true, self.0 as i128, false)
    }
}

impl AperCodec for ServingCellMo {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        ServingCellMo::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("ServingCellMo"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("ServingCellMo"))
    }
}
// ServedCellInformation
#[derive(Clone, Debug)]
pub struct ServedCellInformation {
    pub nrcgi: Nrcgi,
    pub nrpci: Nrpci,
    pub five_gs_tac: Option<FiveGsTac>,
    pub configured_eps_tac: Option<ConfiguredEpsTac>,
    pub served_plmn_s: ServedPlmnSList,
    pub nr_mode_info: NrModeInfo,
    pub measurement_timing_configuration: Vec<u8>,
}

impl ServedCellInformation {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (optionals, _extensions_present) = aper::decode::decode_sequence_header(data, true, 3)?;
        let nrcgi = Nrcgi::decode(data)?;
        let nrpci = Nrpci::decode(data)?;
        let five_gs_tac = if optionals[0] {
            Some(FiveGsTac::decode(data)?)
        } else {
            None
        };
        let configured_eps_tac = if optionals[1] {
            Some(ConfiguredEpsTac::decode(data)?)
        } else {
            None
        };
        let served_plmn_s = ServedPlmnSList::decode(data)?;
        let nr_mode_info = NrModeInfo::decode(data)?;
        let measurement_timing_configuration =
            aper::decode::decode_octetstring(data, None, None, false)?;

        Ok(Self {
            nrcgi,
            nrpci,
            five_gs_tac,
            configured_eps_tac,
            served_plmn_s,
            nr_mode_info,
            measurement_timing_configuration,
        })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(self.five_gs_tac.is_some());
        optionals.push(self.configured_eps_tac.is_some());
        optionals.push(false);

        aper::encode::encode_sequence_header(data, true, &optionals, false)?;
        self.nrcgi.encode(data)?;
        self.nrpci.encode(data)?;
        if let Some(x) = &self.five_gs_tac {
            x.encode(data)?;
        }
        if let Some(x) = &self.configured_eps_tac {
            x.encode(data)?;
        }
        self.served_plmn_s.encode(data)?;
        self.nr_mode_info.encode(data)?;
        aper::encode::encode_octetstring(
            data,
            None,
            None,
            false,
            &self.measurement_timing_configuration,
            false,
        )?;

        Ok(())
    }
}

impl AperCodec for ServedCellInformation {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        ServedCellInformation::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("ServedCellInformation"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("ServedCellInformation"))
    }
}
// SfnOffset
#[derive(Clone, Debug)]
pub struct SfnOffset {
    pub sfn_time_offset: BitString,
}

impl SfnOffset {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (_optionals, _extensions_present) =
            aper::decode::decode_sequence_header(data, true, 1)?;
        let sfn_time_offset = aper::decode::decode_bitstring(data, Some(24), Some(24), false)?;

        Ok(Self { sfn_time_offset })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(false);

        aper::encode::encode_sequence_header(data, true, &optionals, false)?;
        aper::encode::encode_bitstring(
            data,
            Some(24),
            Some(24),
            false,
            &self.sfn_time_offset,
            false,
        )?;

        Ok(())
    }
}

impl AperCodec for SfnOffset {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        SfnOffset::decode_inner(data).map_err(|e: AperCodecError| e.push_context("SfnOffset"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("SfnOffset"))
    }
}
// ServedCellsToAddItem
#[derive(Clone, Debug)]
pub struct ServedCellsToAddItem {
    pub served_cell_information: ServedCellInformation,
    pub gnb_du_system_information: Option<GnbDuSystemInformation>,
}

impl ServedCellsToAddItem {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (optionals, _extensions_present) = aper::decode::decode_sequence_header(data, true, 2)?;
        let served_cell_information = ServedCellInformation::decode(data)?;
        let gnb_du_system_information = if optionals[0] {
            Some(GnbDuSystemInformation::decode(data)?)
        } else {
            None
        };

        Ok(Self {
            served_cell_information,
            gnb_du_system_information,
        })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(self.gnb_du_system_information.is_some());
        optionals.push(false);

        aper::encode::encode_sequence_header(data, true, &optionals, false)?;
        self.served_cell_information.encode(data)?;
        if let Some(x) = &self.gnb_du_system_information {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl AperCodec for ServedCellsToAddItem {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        ServedCellsToAddItem::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("ServedCellsToAddItem"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("ServedCellsToAddItem"))
    }
}
// ServedCellsToDeleteItem
#[derive(Clone, Debug)]
pub struct ServedCellsToDeleteItem {
    pub old_nrcgi: Nrcgi,
}

impl ServedCellsToDeleteItem {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (_optionals, _extensions_present) =
            aper::decode::decode_sequence_header(data, true, 1)?;
        let old_nrcgi = Nrcgi::decode(data)?;

        Ok(Self { old_nrcgi })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(false);

        aper::encode::encode_sequence_header(data, true, &optionals, false)?;
        self.old_nrcgi.encode(data)?;

        Ok(())
    }
}

impl AperCodec for ServedCellsToDeleteItem {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        ServedCellsToDeleteItem::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("ServedCellsToDeleteItem"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("ServedCellsToDeleteItem"))
    }
}
// ServedCellsToModifyItem
#[derive(Clone, Debug)]
pub struct ServedCellsToModifyItem {
    pub old_nrcgi: Nrcgi,
    pub served_cell_information: ServedCellInformation,
    pub gnb_du_system_information: Option<GnbDuSystemInformation>,
}

impl ServedCellsToModifyItem {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (optionals, _extensions_present) = aper::decode::decode_sequence_header(data, true, 2)?;
        let old_nrcgi = Nrcgi::decode(data)?;
        let served_cell_information = ServedCellInformation::decode(data)?;
        let gnb_du_system_information = if optionals[0] {
            Some(GnbDuSystemInformation::decode(data)?)
        } else {
            None
        };

        Ok(Self {
            old_nrcgi,
            served_cell_information,
            gnb_du_system_information,
        })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(self.gnb_du_system_information.is_some());
        optionals.push(false);

        aper::encode::encode_sequence_header(data, true, &optionals, false)?;
        self.old_nrcgi.encode(data)?;
        self.served_cell_information.encode(data)?;
        if let Some(x) = &self.gnb_du_system_information {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl AperCodec for ServedCellsToModifyItem {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        ServedCellsToModifyItem::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("ServedCellsToModifyItem"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("ServedCellsToModifyItem"))
    }
}
// ServedEutraCellsInformation
#[derive(Clone, Debug)]
pub struct ServedEutraCellsInformation {
    pub eutra_mode_info: EutraModeInfo,
    pub protected_eutra_resource_indication: ProtectedEutraResourceIndication,
}

impl ServedEutraCellsInformation {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (_optionals, _extensions_present) =
            aper::decode::decode_sequence_header(data, true, 1)?;
        let eutra_mode_info = EutraModeInfo::decode(data)?;
        let protected_eutra_resource_indication = ProtectedEutraResourceIndication::decode(data)?;

        Ok(Self {
            eutra_mode_info,
            protected_eutra_resource_indication,
        })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(false);

        aper::encode::encode_sequence_header(data, true, &optionals, false)?;
        self.eutra_mode_info.encode(data)?;
        self.protected_eutra_resource_indication.encode(data)?;

        Ok(())
    }
}

impl AperCodec for ServedEutraCellsInformation {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        ServedEutraCellsInformation::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("ServedEutraCellsInformation"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("ServedEutraCellsInformation"))
    }
}
// ServiceState
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum ServiceState {
    InService,
    OutOfService,
}

impl ServiceState {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (idx, extended) = aper::decode::decode_enumerated(data, Some(0), Some(1), true)?;
        if extended {
            return Err(aper::AperCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| AperCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_enumerated(data, Some(0), Some(1), true, *self as i128, false)
    }
}

impl AperCodec for ServiceState {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        ServiceState::decode_inner(data).map_err(|e: AperCodecError| e.push_context("ServiceState"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("ServiceState"))
    }
}
// ServiceStatus
#[derive(Clone, Debug)]
pub struct ServiceStatus {
    pub service_state: ServiceState,
    pub switching_off_ongoing: Option<SwitchingOffOngoing>,
}

impl ServiceStatus {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (optionals, _extensions_present) = aper::decode::decode_sequence_header(data, true, 2)?;
        let service_state = ServiceState::decode(data)?;
        let switching_off_ongoing = if optionals[0] {
            Some(SwitchingOffOngoing::decode(data)?)
        } else {
            None
        };

        Ok(Self {
            service_state,
            switching_off_ongoing,
        })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(self.switching_off_ongoing.is_some());
        optionals.push(false);

        aper::encode::encode_sequence_header(data, true, &optionals, false)?;
        self.service_state.encode(data)?;
        if let Some(x) = &self.switching_off_ongoing {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl AperCodec for ServiceStatus {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        ServiceStatus::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("ServiceStatus"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("ServiceStatus"))
    }
}
// RelativeTime1900
#[derive(Clone, Debug)]
pub struct RelativeTime1900(pub BitString);

impl RelativeTime1900 {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        Ok(Self(aper::decode::decode_bitstring(
            data,
            Some(64),
            Some(64),
            false,
        )?))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_bitstring(data, Some(64), Some(64), false, &self.0, false)
    }
}

impl AperCodec for RelativeTime1900 {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        RelativeTime1900::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("RelativeTime1900"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("RelativeTime1900"))
    }
}
// ShortDrxCycleLength
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum ShortDrxCycleLength {
    Ms2,
    Ms3,
    Ms4,
    Ms5,
    Ms6,
    Ms7,
    Ms8,
    Ms10,
    Ms14,
    Ms16,
    Ms20,
    Ms30,
    Ms32,
    Ms35,
    Ms40,
    Ms64,
    Ms80,
    Ms128,
    Ms160,
    Ms256,
    Ms320,
    Ms512,
    Ms640,
}

impl ShortDrxCycleLength {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (idx, extended) = aper::decode::decode_enumerated(data, Some(0), Some(22), true)?;
        if extended {
            return Err(aper::AperCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| AperCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_enumerated(data, Some(0), Some(22), true, *self as i128, false)
    }
}

impl AperCodec for ShortDrxCycleLength {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        ShortDrxCycleLength::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("ShortDrxCycleLength"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("ShortDrxCycleLength"))
    }
}
// ShortDrxCycleTimer
#[derive(Clone, Debug)]
pub struct ShortDrxCycleTimer(pub u8);

impl ShortDrxCycleTimer {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        Ok(Self(
            aper::decode::decode_integer(data, Some(1), Some(16), false)?.0 as u8,
        ))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_integer(data, Some(1), Some(16), false, self.0 as i128, false)
    }
}

impl AperCodec for ShortDrxCycleTimer {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        ShortDrxCycleTimer::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("ShortDrxCycleTimer"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("ShortDrxCycleTimer"))
    }
}
// Sib1Message
#[derive(Clone, Debug)]
pub struct Sib1Message(pub Vec<u8>);

impl Sib1Message {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        Ok(Self(aper::decode::decode_octetstring(
            data, None, None, false,
        )?))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_octetstring(data, None, None, false, &self.0, false)
    }
}

impl AperCodec for Sib1Message {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        Sib1Message::decode_inner(data).map_err(|e: AperCodecError| e.push_context("Sib1Message"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("Sib1Message"))
    }
}
// Sib10Message
#[derive(Clone, Debug)]
pub struct Sib10Message(pub Vec<u8>);

impl Sib10Message {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        Ok(Self(aper::decode::decode_octetstring(
            data, None, None, false,
        )?))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_octetstring(data, None, None, false, &self.0, false)
    }
}

impl AperCodec for Sib10Message {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        Sib10Message::decode_inner(data).map_err(|e: AperCodecError| e.push_context("Sib10Message"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("Sib10Message"))
    }
}
// Sib12Message
#[derive(Clone, Debug)]
pub struct Sib12Message(pub Vec<u8>);

impl Sib12Message {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        Ok(Self(aper::decode::decode_octetstring(
            data, None, None, false,
        )?))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_octetstring(data, None, None, false, &self.0, false)
    }
}

impl AperCodec for Sib12Message {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        Sib12Message::decode_inner(data).map_err(|e: AperCodecError| e.push_context("Sib12Message"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("Sib12Message"))
    }
}
// Sib13Message
#[derive(Clone, Debug)]
pub struct Sib13Message(pub Vec<u8>);

impl Sib13Message {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        Ok(Self(aper::decode::decode_octetstring(
            data, None, None, false,
        )?))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_octetstring(data, None, None, false, &self.0, false)
    }
}

impl AperCodec for Sib13Message {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        Sib13Message::decode_inner(data).map_err(|e: AperCodecError| e.push_context("Sib13Message"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("Sib13Message"))
    }
}
// Sib14Message
#[derive(Clone, Debug)]
pub struct Sib14Message(pub Vec<u8>);

impl Sib14Message {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        Ok(Self(aper::decode::decode_octetstring(
            data, None, None, false,
        )?))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_octetstring(data, None, None, false, &self.0, false)
    }
}

impl AperCodec for Sib14Message {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        Sib14Message::decode_inner(data).map_err(|e: AperCodecError| e.push_context("Sib14Message"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("Sib14Message"))
    }
}
// SItype
#[derive(Clone, Debug)]
pub struct SItype(pub u8);

impl SItype {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        Ok(Self(
            aper::decode::decode_integer(data, Some(1), Some(32), true)?.0 as u8,
        ))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_integer(data, Some(1), Some(32), true, self.0 as i128, false)
    }
}

impl AperCodec for SItype {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        SItype::decode_inner(data).map_err(|e: AperCodecError| e.push_context("SItype"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("SItype"))
    }
}
// SItypeList
#[derive(Clone, Debug)]
pub struct SItypeList(pub Vec<SItypeItem>);

impl SItypeList {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        Ok(Self({
            let length = aper::decode::decode_length_determinent(data, Some(1), Some(32), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(SItypeItem::decode(data)?);
            }
            items
        }))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_length_determinent(data, Some(1), Some(32), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl AperCodec for SItypeList {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        SItypeList::decode_inner(data).map_err(|e: AperCodecError| e.push_context("SItypeList"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("SItypeList"))
    }
}
// SItypeItem
#[derive(Clone, Debug)]
pub struct SItypeItem {
    pub s_itype: SItype,
}

impl SItypeItem {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (_optionals, _extensions_present) =
            aper::decode::decode_sequence_header(data, false, 1)?;
        let s_itype = SItype::decode(data)?;

        Ok(Self { s_itype })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(false);

        aper::encode::encode_sequence_header(data, false, &optionals, false)?;
        self.s_itype.encode(data)?;

        Ok(())
    }
}

impl AperCodec for SItypeItem {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        SItypeItem::decode_inner(data).map_err(|e: AperCodecError| e.push_context("SItypeItem"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("SItypeItem"))
    }
}
// SibtypetobeupdatedListItem
#[derive(Clone, Debug)]
pub struct SibtypetobeupdatedListItem {
    pub si_btype: u8,
    pub si_bmessage: Vec<u8>,
    pub value_tag: u8,
}

impl SibtypetobeupdatedListItem {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (_optionals, _extensions_present) =
            aper::decode::decode_sequence_header(data, true, 1)?;
        let si_btype = aper::decode::decode_integer(data, Some(2), Some(32), true)?.0 as u8;
        let si_bmessage = aper::decode::decode_octetstring(data, None, None, false)?;
        let value_tag = aper::decode::decode_integer(data, Some(0), Some(31), true)?.0 as u8;

        Ok(Self {
            si_btype,
            si_bmessage,
            value_tag,
        })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(false);

        aper::encode::encode_sequence_header(data, true, &optionals, false)?;
        aper::encode::encode_integer(data, Some(2), Some(32), true, self.si_btype as i128, false)?;
        aper::encode::encode_octetstring(data, None, None, false, &self.si_bmessage, false)?;
        aper::encode::encode_integer(data, Some(0), Some(31), true, self.value_tag as i128, false)?;

        Ok(())
    }
}

impl AperCodec for SibtypetobeupdatedListItem {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        SibtypetobeupdatedListItem::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("SibtypetobeupdatedListItem"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("SibtypetobeupdatedListItem"))
    }
}
// Sldrbid
#[derive(Clone, Debug)]
pub struct Sldrbid(pub u16);

impl Sldrbid {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        Ok(Self(
            aper::decode::decode_integer(data, Some(1), Some(512), true)?.0 as u16,
        ))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_integer(data, Some(1), Some(512), true, self.0 as i128, false)
    }
}

impl AperCodec for Sldrbid {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        Sldrbid::decode_inner(data).map_err(|e: AperCodecError| e.push_context("Sldrbid"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("Sldrbid"))
    }
}
// SldrbInformation
#[derive(Clone, Debug)]
pub struct SldrbInformation {
    pub sldrb_qos: Pc5QosParameters,
    pub flows_mapped_to_sldrb_list: FlowsMappedToSldrbList,
}

impl SldrbInformation {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (_optionals, _extensions_present) =
            aper::decode::decode_sequence_header(data, true, 0)?;
        let sldrb_qos = Pc5QosParameters::decode(data)?;
        let flows_mapped_to_sldrb_list = FlowsMappedToSldrbList::decode(data)?;

        Ok(Self {
            sldrb_qos,
            flows_mapped_to_sldrb_list,
        })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let optionals = BitVec::new();

        aper::encode::encode_sequence_header(data, true, &optionals, false)?;
        self.sldrb_qos.encode(data)?;
        self.flows_mapped_to_sldrb_list.encode(data)?;

        Ok(())
    }
}

impl AperCodec for SldrbInformation {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        SldrbInformation::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("SldrbInformation"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("SldrbInformation"))
    }
}
// SldrBsFailedToBeModifiedItem
#[derive(Clone, Debug)]
pub struct SldrBsFailedToBeModifiedItem {
    pub sldrbid: Sldrbid,
    pub cause: Option<Cause>,
}

impl SldrBsFailedToBeModifiedItem {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (optionals, _extensions_present) =
            aper::decode::decode_sequence_header(data, false, 2)?;
        let sldrbid = Sldrbid::decode(data)?;
        let cause = if optionals[0] {
            Some(Cause::decode(data)?)
        } else {
            None
        };

        Ok(Self { sldrbid, cause })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(self.cause.is_some());
        optionals.push(false);

        aper::encode::encode_sequence_header(data, false, &optionals, false)?;
        self.sldrbid.encode(data)?;
        if let Some(x) = &self.cause {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl AperCodec for SldrBsFailedToBeModifiedItem {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        SldrBsFailedToBeModifiedItem::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("SldrBsFailedToBeModifiedItem"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("SldrBsFailedToBeModifiedItem"))
    }
}
// SldrBsFailedToBeSetupItem
#[derive(Clone, Debug)]
pub struct SldrBsFailedToBeSetupItem {
    pub sldrbid: Sldrbid,
    pub cause: Option<Cause>,
}

impl SldrBsFailedToBeSetupItem {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (optionals, _extensions_present) =
            aper::decode::decode_sequence_header(data, false, 2)?;
        let sldrbid = Sldrbid::decode(data)?;
        let cause = if optionals[0] {
            Some(Cause::decode(data)?)
        } else {
            None
        };

        Ok(Self { sldrbid, cause })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(self.cause.is_some());
        optionals.push(false);

        aper::encode::encode_sequence_header(data, false, &optionals, false)?;
        self.sldrbid.encode(data)?;
        if let Some(x) = &self.cause {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl AperCodec for SldrBsFailedToBeSetupItem {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        SldrBsFailedToBeSetupItem::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("SldrBsFailedToBeSetupItem"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("SldrBsFailedToBeSetupItem"))
    }
}
// SldrBsFailedToBeSetupModItem
#[derive(Clone, Debug)]
pub struct SldrBsFailedToBeSetupModItem {
    pub sldrbid: Sldrbid,
    pub cause: Option<Cause>,
}

impl SldrBsFailedToBeSetupModItem {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (optionals, _extensions_present) =
            aper::decode::decode_sequence_header(data, false, 2)?;
        let sldrbid = Sldrbid::decode(data)?;
        let cause = if optionals[0] {
            Some(Cause::decode(data)?)
        } else {
            None
        };

        Ok(Self { sldrbid, cause })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(self.cause.is_some());
        optionals.push(false);

        aper::encode::encode_sequence_header(data, false, &optionals, false)?;
        self.sldrbid.encode(data)?;
        if let Some(x) = &self.cause {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl AperCodec for SldrBsFailedToBeSetupModItem {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        SldrBsFailedToBeSetupModItem::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("SldrBsFailedToBeSetupModItem"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("SldrBsFailedToBeSetupModItem"))
    }
}
// SldrBsModifiedItem
#[derive(Clone, Debug)]
pub struct SldrBsModifiedItem {
    pub sldrbid: Sldrbid,
}

impl SldrBsModifiedItem {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (_optionals, _extensions_present) =
            aper::decode::decode_sequence_header(data, false, 1)?;
        let sldrbid = Sldrbid::decode(data)?;

        Ok(Self { sldrbid })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(false);

        aper::encode::encode_sequence_header(data, false, &optionals, false)?;
        self.sldrbid.encode(data)?;

        Ok(())
    }
}

impl AperCodec for SldrBsModifiedItem {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        SldrBsModifiedItem::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("SldrBsModifiedItem"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("SldrBsModifiedItem"))
    }
}
// SldrBsModifiedConfItem
#[derive(Clone, Debug)]
pub struct SldrBsModifiedConfItem {
    pub sldrbid: Sldrbid,
}

impl SldrBsModifiedConfItem {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (_optionals, _extensions_present) =
            aper::decode::decode_sequence_header(data, false, 1)?;
        let sldrbid = Sldrbid::decode(data)?;

        Ok(Self { sldrbid })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(false);

        aper::encode::encode_sequence_header(data, false, &optionals, false)?;
        self.sldrbid.encode(data)?;

        Ok(())
    }
}

impl AperCodec for SldrBsModifiedConfItem {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        SldrBsModifiedConfItem::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("SldrBsModifiedConfItem"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("SldrBsModifiedConfItem"))
    }
}
// SldrBsRequiredToBeModifiedItem
#[derive(Clone, Debug)]
pub struct SldrBsRequiredToBeModifiedItem {
    pub sldrbid: Sldrbid,
}

impl SldrBsRequiredToBeModifiedItem {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (_optionals, _extensions_present) =
            aper::decode::decode_sequence_header(data, false, 1)?;
        let sldrbid = Sldrbid::decode(data)?;

        Ok(Self { sldrbid })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(false);

        aper::encode::encode_sequence_header(data, false, &optionals, false)?;
        self.sldrbid.encode(data)?;

        Ok(())
    }
}

impl AperCodec for SldrBsRequiredToBeModifiedItem {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        SldrBsRequiredToBeModifiedItem::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("SldrBsRequiredToBeModifiedItem"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("SldrBsRequiredToBeModifiedItem"))
    }
}
// SldrBsRequiredToBeReleasedItem
#[derive(Clone, Debug)]
pub struct SldrBsRequiredToBeReleasedItem {
    pub sldrbid: Sldrbid,
}

impl SldrBsRequiredToBeReleasedItem {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (_optionals, _extensions_present) =
            aper::decode::decode_sequence_header(data, false, 1)?;
        let sldrbid = Sldrbid::decode(data)?;

        Ok(Self { sldrbid })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(false);

        aper::encode::encode_sequence_header(data, false, &optionals, false)?;
        self.sldrbid.encode(data)?;

        Ok(())
    }
}

impl AperCodec for SldrBsRequiredToBeReleasedItem {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        SldrBsRequiredToBeReleasedItem::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("SldrBsRequiredToBeReleasedItem"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("SldrBsRequiredToBeReleasedItem"))
    }
}
// SldrBsSetupItem
#[derive(Clone, Debug)]
pub struct SldrBsSetupItem {
    pub sldrbid: Sldrbid,
}

impl SldrBsSetupItem {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (_optionals, _extensions_present) =
            aper::decode::decode_sequence_header(data, false, 1)?;
        let sldrbid = Sldrbid::decode(data)?;

        Ok(Self { sldrbid })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(false);

        aper::encode::encode_sequence_header(data, false, &optionals, false)?;
        self.sldrbid.encode(data)?;

        Ok(())
    }
}

impl AperCodec for SldrBsSetupItem {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        SldrBsSetupItem::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("SldrBsSetupItem"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("SldrBsSetupItem"))
    }
}
// SldrBsSetupModItem
#[derive(Clone, Debug)]
pub struct SldrBsSetupModItem {
    pub sldrbid: Sldrbid,
}

impl SldrBsSetupModItem {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (_optionals, _extensions_present) =
            aper::decode::decode_sequence_header(data, false, 1)?;
        let sldrbid = Sldrbid::decode(data)?;

        Ok(Self { sldrbid })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(false);

        aper::encode::encode_sequence_header(data, false, &optionals, false)?;
        self.sldrbid.encode(data)?;

        Ok(())
    }
}

impl AperCodec for SldrBsSetupModItem {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        SldrBsSetupModItem::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("SldrBsSetupModItem"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("SldrBsSetupModItem"))
    }
}
// SldrBsToBeModifiedItem
#[derive(Clone, Debug)]
pub struct SldrBsToBeModifiedItem {
    pub sldrbid: Sldrbid,
    pub sldrb_information: Option<SldrbInformation>,
    pub rlc_mode: Option<RlcMode>,
}

impl SldrBsToBeModifiedItem {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (optionals, _extensions_present) =
            aper::decode::decode_sequence_header(data, false, 3)?;
        let sldrbid = Sldrbid::decode(data)?;
        let sldrb_information = if optionals[0] {
            Some(SldrbInformation::decode(data)?)
        } else {
            None
        };
        let rlc_mode = if optionals[1] {
            Some(RlcMode::decode(data)?)
        } else {
            None
        };

        Ok(Self {
            sldrbid,
            sldrb_information,
            rlc_mode,
        })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(self.sldrb_information.is_some());
        optionals.push(self.rlc_mode.is_some());
        optionals.push(false);

        aper::encode::encode_sequence_header(data, false, &optionals, false)?;
        self.sldrbid.encode(data)?;
        if let Some(x) = &self.sldrb_information {
            x.encode(data)?;
        }
        if let Some(x) = &self.rlc_mode {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl AperCodec for SldrBsToBeModifiedItem {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        SldrBsToBeModifiedItem::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("SldrBsToBeModifiedItem"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("SldrBsToBeModifiedItem"))
    }
}
// SldrBsToBeReleasedItem
#[derive(Clone, Debug)]
pub struct SldrBsToBeReleasedItem {
    pub sldrbid: Sldrbid,
}

impl SldrBsToBeReleasedItem {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (_optionals, _extensions_present) =
            aper::decode::decode_sequence_header(data, false, 1)?;
        let sldrbid = Sldrbid::decode(data)?;

        Ok(Self { sldrbid })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(false);

        aper::encode::encode_sequence_header(data, false, &optionals, false)?;
        self.sldrbid.encode(data)?;

        Ok(())
    }
}

impl AperCodec for SldrBsToBeReleasedItem {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        SldrBsToBeReleasedItem::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("SldrBsToBeReleasedItem"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("SldrBsToBeReleasedItem"))
    }
}
// SldrBsToBeSetupItem
#[derive(Clone, Debug)]
pub struct SldrBsToBeSetupItem {
    pub sldrbid: Sldrbid,
    pub sldrb_information: SldrbInformation,
    pub rlc_mode: RlcMode,
}

impl SldrBsToBeSetupItem {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (_optionals, _extensions_present) =
            aper::decode::decode_sequence_header(data, false, 1)?;
        let sldrbid = Sldrbid::decode(data)?;
        let sldrb_information = SldrbInformation::decode(data)?;
        let rlc_mode = RlcMode::decode(data)?;

        Ok(Self {
            sldrbid,
            sldrb_information,
            rlc_mode,
        })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(false);

        aper::encode::encode_sequence_header(data, false, &optionals, false)?;
        self.sldrbid.encode(data)?;
        self.sldrb_information.encode(data)?;
        self.rlc_mode.encode(data)?;

        Ok(())
    }
}

impl AperCodec for SldrBsToBeSetupItem {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        SldrBsToBeSetupItem::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("SldrBsToBeSetupItem"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("SldrBsToBeSetupItem"))
    }
}
// SldrBsToBeSetupModItem
#[derive(Clone, Debug)]
pub struct SldrBsToBeSetupModItem {
    pub sldrbid: Sldrbid,
    pub sldrb_information: SldrbInformation,
    pub rlc_mode: Option<RlcMode>,
}

impl SldrBsToBeSetupModItem {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (optionals, _extensions_present) =
            aper::decode::decode_sequence_header(data, false, 2)?;
        let sldrbid = Sldrbid::decode(data)?;
        let sldrb_information = SldrbInformation::decode(data)?;
        let rlc_mode = if optionals[0] {
            Some(RlcMode::decode(data)?)
        } else {
            None
        };

        Ok(Self {
            sldrbid,
            sldrb_information,
            rlc_mode,
        })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(self.rlc_mode.is_some());
        optionals.push(false);

        aper::encode::encode_sequence_header(data, false, &optionals, false)?;
        self.sldrbid.encode(data)?;
        self.sldrb_information.encode(data)?;
        if let Some(x) = &self.rlc_mode {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl AperCodec for SldrBsToBeSetupModItem {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        SldrBsToBeSetupModItem::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("SldrBsToBeSetupModItem"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("SldrBsToBeSetupModItem"))
    }
}
// SlPhyMacRlcConfig
#[derive(Clone, Debug)]
pub struct SlPhyMacRlcConfig(pub Vec<u8>);

impl SlPhyMacRlcConfig {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        Ok(Self(aper::decode::decode_octetstring(
            data, None, None, false,
        )?))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_octetstring(data, None, None, false, &self.0, false)
    }
}

impl AperCodec for SlPhyMacRlcConfig {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        SlPhyMacRlcConfig::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("SlPhyMacRlcConfig"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("SlPhyMacRlcConfig"))
    }
}
// SlConfigDedicatedEutraInfo
#[derive(Clone, Debug)]
pub struct SlConfigDedicatedEutraInfo(pub Vec<u8>);

impl SlConfigDedicatedEutraInfo {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        Ok(Self(aper::decode::decode_octetstring(
            data, None, None, false,
        )?))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_octetstring(data, None, None, false, &self.0, false)
    }
}

impl AperCodec for SlConfigDedicatedEutraInfo {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        SlConfigDedicatedEutraInfo::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("SlConfigDedicatedEutraInfo"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("SlConfigDedicatedEutraInfo"))
    }
}
// SliceAvailableCapacity
#[derive(Clone, Debug)]
pub struct SliceAvailableCapacity {
    pub slice_available_capacity_list: SliceAvailableCapacityList,
}

impl SliceAvailableCapacity {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (_optionals, _extensions_present) =
            aper::decode::decode_sequence_header(data, false, 1)?;
        let slice_available_capacity_list = SliceAvailableCapacityList::decode(data)?;

        Ok(Self {
            slice_available_capacity_list,
        })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(false);

        aper::encode::encode_sequence_header(data, false, &optionals, false)?;
        self.slice_available_capacity_list.encode(data)?;

        Ok(())
    }
}

impl AperCodec for SliceAvailableCapacity {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        SliceAvailableCapacity::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("SliceAvailableCapacity"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("SliceAvailableCapacity"))
    }
}
// SliceAvailableCapacityList
#[derive(Clone, Debug)]
pub struct SliceAvailableCapacityList(pub Vec<SliceAvailableCapacityItem>);

impl SliceAvailableCapacityList {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        Ok(Self({
            let length = aper::decode::decode_length_determinent(data, Some(1), Some(12), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(SliceAvailableCapacityItem::decode(data)?);
            }
            items
        }))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_length_determinent(data, Some(1), Some(12), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl AperCodec for SliceAvailableCapacityList {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        SliceAvailableCapacityList::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("SliceAvailableCapacityList"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("SliceAvailableCapacityList"))
    }
}
// SliceAvailableCapacityItem
#[derive(Clone, Debug)]
pub struct SliceAvailableCapacityItem {
    pub plmn_identity: PlmnIdentity,
    pub snssai_available_capacity_list: SnssaiAvailableCapacityList,
}

impl SliceAvailableCapacityItem {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (_optionals, _extensions_present) =
            aper::decode::decode_sequence_header(data, false, 1)?;
        let plmn_identity = PlmnIdentity::decode(data)?;
        let snssai_available_capacity_list = SnssaiAvailableCapacityList::decode(data)?;

        Ok(Self {
            plmn_identity,
            snssai_available_capacity_list,
        })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(false);

        aper::encode::encode_sequence_header(data, false, &optionals, false)?;
        self.plmn_identity.encode(data)?;
        self.snssai_available_capacity_list.encode(data)?;

        Ok(())
    }
}

impl AperCodec for SliceAvailableCapacityItem {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        SliceAvailableCapacityItem::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("SliceAvailableCapacityItem"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("SliceAvailableCapacityItem"))
    }
}
// SnssaiAvailableCapacityList
#[derive(Clone, Debug)]
pub struct SnssaiAvailableCapacityList(pub Vec<SnssaiAvailableCapacityItem>);

impl SnssaiAvailableCapacityList {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        Ok(Self({
            let length = aper::decode::decode_length_determinent(data, Some(1), Some(1024), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(SnssaiAvailableCapacityItem::decode(data)?);
            }
            items
        }))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_length_determinent(data, Some(1), Some(1024), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl AperCodec for SnssaiAvailableCapacityList {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        SnssaiAvailableCapacityList::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("SnssaiAvailableCapacityList"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("SnssaiAvailableCapacityList"))
    }
}
// SnssaiAvailableCapacityItem
#[derive(Clone, Debug)]
pub struct SnssaiAvailableCapacityItem {
    pub snssai: Snssai,
    pub slice_available_capacity_value_downlink: Option<u8>,
    pub slice_available_capacity_value_uplink: Option<u8>,
}

impl SnssaiAvailableCapacityItem {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (optionals, _extensions_present) =
            aper::decode::decode_sequence_header(data, false, 3)?;
        let snssai = Snssai::decode(data)?;
        let slice_available_capacity_value_downlink = if optionals[0] {
            Some(aper::decode::decode_integer(data, Some(0), Some(100), false)?.0 as u8)
        } else {
            None
        };
        let slice_available_capacity_value_uplink = if optionals[1] {
            Some(aper::decode::decode_integer(data, Some(0), Some(100), false)?.0 as u8)
        } else {
            None
        };

        Ok(Self {
            snssai,
            slice_available_capacity_value_downlink,
            slice_available_capacity_value_uplink,
        })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(self.slice_available_capacity_value_downlink.is_some());
        optionals.push(self.slice_available_capacity_value_uplink.is_some());
        optionals.push(false);

        aper::encode::encode_sequence_header(data, false, &optionals, false)?;
        self.snssai.encode(data)?;
        if let Some(x) = &self.slice_available_capacity_value_downlink {
            aper::encode::encode_integer(data, Some(0), Some(100), false, *x as i128, false)?;
        }
        if let Some(x) = &self.slice_available_capacity_value_uplink {
            aper::encode::encode_integer(data, Some(0), Some(100), false, *x as i128, false)?;
        }

        Ok(())
    }
}

impl AperCodec for SnssaiAvailableCapacityItem {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        SnssaiAvailableCapacityItem::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("SnssaiAvailableCapacityItem"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("SnssaiAvailableCapacityItem"))
    }
}
// SliceSupportList
#[derive(Clone, Debug)]
pub struct SliceSupportList(pub Vec<SliceSupportItem>);

impl SliceSupportList {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        Ok(Self({
            let length = aper::decode::decode_length_determinent(data, Some(1), Some(1024), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(SliceSupportItem::decode(data)?);
            }
            items
        }))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_length_determinent(data, Some(1), Some(1024), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl AperCodec for SliceSupportList {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        SliceSupportList::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("SliceSupportList"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("SliceSupportList"))
    }
}
// SliceSupportItem
#[derive(Clone, Debug)]
pub struct SliceSupportItem {
    pub snssai: Snssai,
}

impl SliceSupportItem {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (_optionals, _extensions_present) =
            aper::decode::decode_sequence_header(data, false, 1)?;
        let snssai = Snssai::decode(data)?;

        Ok(Self { snssai })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(false);

        aper::encode::encode_sequence_header(data, false, &optionals, false)?;
        self.snssai.encode(data)?;

        Ok(())
    }
}

impl AperCodec for SliceSupportItem {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        SliceSupportItem::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("SliceSupportItem"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("SliceSupportItem"))
    }
}
// SliceToReportList
#[derive(Clone, Debug)]
pub struct SliceToReportList(pub Vec<SliceToReportItem>);

impl SliceToReportList {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        Ok(Self({
            let length = aper::decode::decode_length_determinent(data, Some(1), Some(12), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(SliceToReportItem::decode(data)?);
            }
            items
        }))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_length_determinent(data, Some(1), Some(12), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl AperCodec for SliceToReportList {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        SliceToReportList::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("SliceToReportList"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("SliceToReportList"))
    }
}
// SliceToReportItem
#[derive(Clone, Debug)]
pub struct SliceToReportItem {
    pub plmn_identity: PlmnIdentity,
    pub snssa_ilist: SnssaiList,
}

impl SliceToReportItem {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (_optionals, _extensions_present) =
            aper::decode::decode_sequence_header(data, false, 1)?;
        let plmn_identity = PlmnIdentity::decode(data)?;
        let snssa_ilist = SnssaiList::decode(data)?;

        Ok(Self {
            plmn_identity,
            snssa_ilist,
        })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(false);

        aper::encode::encode_sequence_header(data, false, &optionals, false)?;
        self.plmn_identity.encode(data)?;
        self.snssa_ilist.encode(data)?;

        Ok(())
    }
}

impl AperCodec for SliceToReportItem {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        SliceToReportItem::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("SliceToReportItem"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("SliceToReportItem"))
    }
}
// SlotNumber
#[derive(Clone, Debug)]
pub struct SlotNumber(pub u8);

impl SlotNumber {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        Ok(Self(
            aper::decode::decode_integer(data, Some(0), Some(79), false)?.0 as u8,
        ))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_integer(data, Some(0), Some(79), false, self.0 as i128, false)
    }
}

impl AperCodec for SlotNumber {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        SlotNumber::decode_inner(data).map_err(|e: AperCodecError| e.push_context("SlotNumber"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("SlotNumber"))
    }
}
// SnssaiList
#[derive(Clone, Debug)]
pub struct SnssaiList(pub Vec<SnssaiItem>);

impl SnssaiList {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        Ok(Self({
            let length = aper::decode::decode_length_determinent(data, Some(1), Some(1024), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(SnssaiItem::decode(data)?);
            }
            items
        }))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_length_determinent(data, Some(1), Some(1024), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl AperCodec for SnssaiList {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        SnssaiList::decode_inner(data).map_err(|e: AperCodecError| e.push_context("SnssaiList"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("SnssaiList"))
    }
}
// SnssaiItem
#[derive(Clone, Debug)]
pub struct SnssaiItem {
    pub snssai: Snssai,
}

impl SnssaiItem {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (_optionals, _extensions_present) =
            aper::decode::decode_sequence_header(data, false, 1)?;
        let snssai = Snssai::decode(data)?;

        Ok(Self { snssai })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(false);

        aper::encode::encode_sequence_header(data, false, &optionals, false)?;
        self.snssai.encode(data)?;

        Ok(())
    }
}

impl AperCodec for SnssaiItem {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        SnssaiItem::decode_inner(data).map_err(|e: AperCodecError| e.push_context("SnssaiItem"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("SnssaiItem"))
    }
}
// SlotConfigurationList
#[derive(Clone, Debug)]
pub struct SlotConfigurationList(pub Vec<SlotConfigurationItem>);

impl SlotConfigurationList {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        Ok(Self({
            let length = aper::decode::decode_length_determinent(data, Some(1), Some(5120), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(SlotConfigurationItem::decode(data)?);
            }
            items
        }))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_length_determinent(data, Some(1), Some(5120), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl AperCodec for SlotConfigurationList {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        SlotConfigurationList::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("SlotConfigurationList"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("SlotConfigurationList"))
    }
}
// SlotConfigurationItem
#[derive(Clone, Debug)]
pub struct SlotConfigurationItem {
    pub slot_index: u16,
    pub symbol_alloc_in_slot: SymbolAllocInSlot,
}

impl SlotConfigurationItem {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (_optionals, _extensions_present) =
            aper::decode::decode_sequence_header(data, false, 1)?;
        let slot_index = aper::decode::decode_integer(data, Some(0), Some(5119), true)?.0 as u16;
        let symbol_alloc_in_slot = SymbolAllocInSlot::decode(data)?;

        Ok(Self {
            slot_index,
            symbol_alloc_in_slot,
        })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(false);

        aper::encode::encode_sequence_header(data, false, &optionals, false)?;
        aper::encode::encode_integer(
            data,
            Some(0),
            Some(5119),
            true,
            self.slot_index as i128,
            false,
        )?;
        self.symbol_alloc_in_slot.encode(data)?;

        Ok(())
    }
}

impl AperCodec for SlotConfigurationItem {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        SlotConfigurationItem::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("SlotConfigurationItem"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("SlotConfigurationItem"))
    }
}
// Snssai
#[derive(Clone, Debug)]
pub struct Snssai {
    pub sst: Vec<u8>,
    pub sd: Option<Vec<u8>>,
}

impl Snssai {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (optionals, _extensions_present) =
            aper::decode::decode_sequence_header(data, false, 2)?;
        let sst = aper::decode::decode_octetstring(data, Some(1), Some(1), false)?;
        let sd = if optionals[0] {
            Some(aper::decode::decode_octetstring(
                data,
                Some(3),
                Some(3),
                false,
            )?)
        } else {
            None
        };

        Ok(Self { sst, sd })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(self.sd.is_some());
        optionals.push(false);

        aper::encode::encode_sequence_header(data, false, &optionals, false)?;
        aper::encode::encode_octetstring(data, Some(1), Some(1), false, &self.sst, false)?;
        if let Some(x) = &self.sd {
            aper::encode::encode_octetstring(data, Some(3), Some(3), false, &x, false)?;
        }

        Ok(())
    }
}

impl AperCodec for Snssai {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        Snssai::decode_inner(data).map_err(|e: AperCodecError| e.push_context("Snssai"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("Snssai"))
    }
}
// SpatialDirectionInformation
#[derive(Clone, Debug)]
pub struct SpatialDirectionInformation {
    pub nr_prs_beam_information: NrPrsBeamInformation,
}

impl SpatialDirectionInformation {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (_optionals, _extensions_present) =
            aper::decode::decode_sequence_header(data, false, 1)?;
        let nr_prs_beam_information = NrPrsBeamInformation::decode(data)?;

        Ok(Self {
            nr_prs_beam_information,
        })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(false);

        aper::encode::encode_sequence_header(data, false, &optionals, false)?;
        self.nr_prs_beam_information.encode(data)?;

        Ok(())
    }
}

impl AperCodec for SpatialDirectionInformation {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        SpatialDirectionInformation::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("SpatialDirectionInformation"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("SpatialDirectionInformation"))
    }
}
// SpatialRelationInfo
#[derive(Clone, Debug)]
pub struct SpatialRelationInfo {
    pub spatial_relationfor_resource_id: SpatialRelationforResourceId,
}

impl SpatialRelationInfo {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (_optionals, _extensions_present) =
            aper::decode::decode_sequence_header(data, false, 1)?;
        let spatial_relationfor_resource_id = SpatialRelationforResourceId::decode(data)?;

        Ok(Self {
            spatial_relationfor_resource_id,
        })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(false);

        aper::encode::encode_sequence_header(data, false, &optionals, false)?;
        self.spatial_relationfor_resource_id.encode(data)?;

        Ok(())
    }
}

impl AperCodec for SpatialRelationInfo {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        SpatialRelationInfo::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("SpatialRelationInfo"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("SpatialRelationInfo"))
    }
}
// SpatialRelationforResourceId
#[derive(Clone, Debug)]
pub struct SpatialRelationforResourceId(pub Vec<SpatialRelationforResourceIdItem>);

impl SpatialRelationforResourceId {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        Ok(Self({
            let length = aper::decode::decode_length_determinent(data, Some(1), Some(64), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(SpatialRelationforResourceIdItem::decode(data)?);
            }
            items
        }))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_length_determinent(data, Some(1), Some(64), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl AperCodec for SpatialRelationforResourceId {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        SpatialRelationforResourceId::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("SpatialRelationforResourceId"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("SpatialRelationforResourceId"))
    }
}
// SpatialRelationforResourceIdItem
#[derive(Clone, Debug)]
pub struct SpatialRelationforResourceIdItem {
    pub reference_signal: ReferenceSignal,
}

impl SpatialRelationforResourceIdItem {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (_optionals, _extensions_present) =
            aper::decode::decode_sequence_header(data, false, 1)?;
        let reference_signal = ReferenceSignal::decode(data)?;

        Ok(Self { reference_signal })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(false);

        aper::encode::encode_sequence_header(data, false, &optionals, false)?;
        self.reference_signal.encode(data)?;

        Ok(())
    }
}

impl AperCodec for SpatialRelationforResourceIdItem {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        SpatialRelationforResourceIdItem::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("SpatialRelationforResourceIdItem"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("SpatialRelationforResourceIdItem"))
    }
}
// SpatialRelationPos
#[derive(Clone, Debug)]
pub enum SpatialRelationPos {
    SsbPos(Ssb),
    PrsInformationPos(PrsInformationPos),
}

impl SpatialRelationPos {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (idx, extended) = aper::decode::decode_choice_idx(data, 0, 2, false)?;
        if extended {
            return Err(aper::AperCodecError::new(
                "CHOICE additions not implemented",
            ));
        }
        match idx {
            0 => Ok(Self::SsbPos(Ssb::decode(data)?)),
            1 => Ok(Self::PrsInformationPos(PrsInformationPos::decode(data)?)),
            2 => Err(AperCodecError::new(
                "Choice extension container not implemented",
            )),
            _ => Err(AperCodecError::new("Unknown choice idx")),
        }
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        match self {
            Self::SsbPos(x) => {
                aper::encode::encode_choice_idx(data, 0, 2, false, 0, false)?;
                x.encode(data)
            }
            Self::PrsInformationPos(x) => {
                aper::encode::encode_choice_idx(data, 0, 2, false, 1, false)?;
                x.encode(data)
            }
        }
    }
}

impl AperCodec for SpatialRelationPos {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        SpatialRelationPos::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("SpatialRelationPos"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("SpatialRelationPos"))
    }
}
// SpectrumSharingGroupId
#[derive(Clone, Debug)]
pub struct SpectrumSharingGroupId(pub u16);

impl SpectrumSharingGroupId {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        Ok(Self(
            aper::decode::decode_integer(data, Some(1), Some(256), false)?.0 as u16,
        ))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_integer(data, Some(1), Some(256), false, self.0 as i128, false)
    }
}

impl AperCodec for SpectrumSharingGroupId {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        SpectrumSharingGroupId::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("SpectrumSharingGroupId"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("SpectrumSharingGroupId"))
    }
}
// Srbid
#[derive(Clone, Debug)]
pub struct Srbid(pub u8);

impl Srbid {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        Ok(Self(
            aper::decode::decode_integer(data, Some(0), Some(3), true)?.0 as u8,
        ))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_integer(data, Some(0), Some(3), true, self.0 as i128, false)
    }
}

impl AperCodec for Srbid {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        Srbid::decode_inner(data).map_err(|e: AperCodecError| e.push_context("Srbid"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("Srbid"))
    }
}
// SrBsFailedToBeSetupItem
#[derive(Clone, Debug)]
pub struct SrBsFailedToBeSetupItem {
    pub srbid: Srbid,
    pub cause: Option<Cause>,
}

impl SrBsFailedToBeSetupItem {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (optionals, _extensions_present) = aper::decode::decode_sequence_header(data, true, 2)?;
        let srbid = Srbid::decode(data)?;
        let cause = if optionals[0] {
            Some(Cause::decode(data)?)
        } else {
            None
        };

        Ok(Self { srbid, cause })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(self.cause.is_some());
        optionals.push(false);

        aper::encode::encode_sequence_header(data, true, &optionals, false)?;
        self.srbid.encode(data)?;
        if let Some(x) = &self.cause {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl AperCodec for SrBsFailedToBeSetupItem {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        SrBsFailedToBeSetupItem::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("SrBsFailedToBeSetupItem"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("SrBsFailedToBeSetupItem"))
    }
}
// SrBsFailedToBeSetupModItem
#[derive(Clone, Debug)]
pub struct SrBsFailedToBeSetupModItem {
    pub srbid: Srbid,
    pub cause: Option<Cause>,
}

impl SrBsFailedToBeSetupModItem {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (optionals, _extensions_present) = aper::decode::decode_sequence_header(data, true, 2)?;
        let srbid = Srbid::decode(data)?;
        let cause = if optionals[0] {
            Some(Cause::decode(data)?)
        } else {
            None
        };

        Ok(Self { srbid, cause })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(self.cause.is_some());
        optionals.push(false);

        aper::encode::encode_sequence_header(data, true, &optionals, false)?;
        self.srbid.encode(data)?;
        if let Some(x) = &self.cause {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl AperCodec for SrBsFailedToBeSetupModItem {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        SrBsFailedToBeSetupModItem::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("SrBsFailedToBeSetupModItem"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("SrBsFailedToBeSetupModItem"))
    }
}
// SrBsModifiedItem
#[derive(Clone, Debug)]
pub struct SrBsModifiedItem {
    pub srbid: Srbid,
    pub lcid: Lcid,
}

impl SrBsModifiedItem {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (_optionals, _extensions_present) =
            aper::decode::decode_sequence_header(data, true, 1)?;
        let srbid = Srbid::decode(data)?;
        let lcid = Lcid::decode(data)?;

        Ok(Self { srbid, lcid })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(false);

        aper::encode::encode_sequence_header(data, true, &optionals, false)?;
        self.srbid.encode(data)?;
        self.lcid.encode(data)?;

        Ok(())
    }
}

impl AperCodec for SrBsModifiedItem {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        SrBsModifiedItem::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("SrBsModifiedItem"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("SrBsModifiedItem"))
    }
}
// SrBsRequiredToBeReleasedItem
#[derive(Clone, Debug)]
pub struct SrBsRequiredToBeReleasedItem {
    pub srbid: Srbid,
}

impl SrBsRequiredToBeReleasedItem {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (_optionals, _extensions_present) =
            aper::decode::decode_sequence_header(data, true, 1)?;
        let srbid = Srbid::decode(data)?;

        Ok(Self { srbid })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(false);

        aper::encode::encode_sequence_header(data, true, &optionals, false)?;
        self.srbid.encode(data)?;

        Ok(())
    }
}

impl AperCodec for SrBsRequiredToBeReleasedItem {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        SrBsRequiredToBeReleasedItem::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("SrBsRequiredToBeReleasedItem"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("SrBsRequiredToBeReleasedItem"))
    }
}
// SrBsSetupItem
#[derive(Clone, Debug)]
pub struct SrBsSetupItem {
    pub srbid: Srbid,
    pub lcid: Lcid,
}

impl SrBsSetupItem {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (_optionals, _extensions_present) =
            aper::decode::decode_sequence_header(data, true, 1)?;
        let srbid = Srbid::decode(data)?;
        let lcid = Lcid::decode(data)?;

        Ok(Self { srbid, lcid })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(false);

        aper::encode::encode_sequence_header(data, true, &optionals, false)?;
        self.srbid.encode(data)?;
        self.lcid.encode(data)?;

        Ok(())
    }
}

impl AperCodec for SrBsSetupItem {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        SrBsSetupItem::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("SrBsSetupItem"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("SrBsSetupItem"))
    }
}
// SrBsSetupModItem
#[derive(Clone, Debug)]
pub struct SrBsSetupModItem {
    pub srbid: Srbid,
    pub lcid: Lcid,
}

impl SrBsSetupModItem {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (_optionals, _extensions_present) =
            aper::decode::decode_sequence_header(data, true, 1)?;
        let srbid = Srbid::decode(data)?;
        let lcid = Lcid::decode(data)?;

        Ok(Self { srbid, lcid })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(false);

        aper::encode::encode_sequence_header(data, true, &optionals, false)?;
        self.srbid.encode(data)?;
        self.lcid.encode(data)?;

        Ok(())
    }
}

impl AperCodec for SrBsSetupModItem {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        SrBsSetupModItem::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("SrBsSetupModItem"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("SrBsSetupModItem"))
    }
}
// SrBsToBeReleasedItem
#[derive(Clone, Debug)]
pub struct SrBsToBeReleasedItem {
    pub srbid: Srbid,
}

impl SrBsToBeReleasedItem {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (_optionals, _extensions_present) =
            aper::decode::decode_sequence_header(data, true, 1)?;
        let srbid = Srbid::decode(data)?;

        Ok(Self { srbid })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(false);

        aper::encode::encode_sequence_header(data, true, &optionals, false)?;
        self.srbid.encode(data)?;

        Ok(())
    }
}

impl AperCodec for SrBsToBeReleasedItem {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        SrBsToBeReleasedItem::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("SrBsToBeReleasedItem"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("SrBsToBeReleasedItem"))
    }
}
// SrBsToBeSetupItem
#[derive(Clone, Debug)]
pub struct SrBsToBeSetupItem {
    pub srbid: Srbid,
    pub duplication_indication: Option<DuplicationIndication>,
}

impl SrBsToBeSetupItem {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (optionals, _extensions_present) = aper::decode::decode_sequence_header(data, true, 2)?;
        let srbid = Srbid::decode(data)?;
        let duplication_indication = if optionals[0] {
            Some(DuplicationIndication::decode(data)?)
        } else {
            None
        };

        Ok(Self {
            srbid,
            duplication_indication,
        })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(self.duplication_indication.is_some());
        optionals.push(false);

        aper::encode::encode_sequence_header(data, true, &optionals, false)?;
        self.srbid.encode(data)?;
        if let Some(x) = &self.duplication_indication {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl AperCodec for SrBsToBeSetupItem {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        SrBsToBeSetupItem::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("SrBsToBeSetupItem"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("SrBsToBeSetupItem"))
    }
}
// SrBsToBeSetupModItem
#[derive(Clone, Debug)]
pub struct SrBsToBeSetupModItem {
    pub srbid: Srbid,
    pub duplication_indication: Option<DuplicationIndication>,
}

impl SrBsToBeSetupModItem {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (optionals, _extensions_present) = aper::decode::decode_sequence_header(data, true, 2)?;
        let srbid = Srbid::decode(data)?;
        let duplication_indication = if optionals[0] {
            Some(DuplicationIndication::decode(data)?)
        } else {
            None
        };

        Ok(Self {
            srbid,
            duplication_indication,
        })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(self.duplication_indication.is_some());
        optionals.push(false);

        aper::encode::encode_sequence_header(data, true, &optionals, false)?;
        self.srbid.encode(data)?;
        if let Some(x) = &self.duplication_indication {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl AperCodec for SrBsToBeSetupModItem {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        SrBsToBeSetupModItem::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("SrBsToBeSetupModItem"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("SrBsToBeSetupModItem"))
    }
}
// SrsCarrierList
#[derive(Clone, Debug)]
pub struct SrsCarrierList(pub Vec<SrsCarrierListItem>);

impl SrsCarrierList {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        Ok(Self({
            let length = aper::decode::decode_length_determinent(data, Some(1), Some(32), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(SrsCarrierListItem::decode(data)?);
            }
            items
        }))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_length_determinent(data, Some(1), Some(32), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl AperCodec for SrsCarrierList {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        SrsCarrierList::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("SrsCarrierList"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("SrsCarrierList"))
    }
}
// SrsCarrierListItem
#[derive(Clone, Debug)]
pub struct SrsCarrierListItem {
    pub point_a: u32,
    pub uplink_channel_bw_per_scs_list: UplinkChannelBwPerScsList,
    pub active_ulbwp: ActiveUlbwp,
    pub pci: Option<Nrpci>,
}

impl SrsCarrierListItem {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (optionals, _extensions_present) =
            aper::decode::decode_sequence_header(data, false, 2)?;
        let point_a = aper::decode::decode_integer(data, Some(0), Some(3279165), false)?.0 as u32;
        let uplink_channel_bw_per_scs_list = UplinkChannelBwPerScsList::decode(data)?;
        let active_ulbwp = ActiveUlbwp::decode(data)?;
        let pci = if optionals[0] {
            Some(Nrpci::decode(data)?)
        } else {
            None
        };

        Ok(Self {
            point_a,
            uplink_channel_bw_per_scs_list,
            active_ulbwp,
            pci,
        })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(self.pci.is_some());
        optionals.push(false);

        aper::encode::encode_sequence_header(data, false, &optionals, false)?;
        aper::encode::encode_integer(
            data,
            Some(0),
            Some(3279165),
            false,
            self.point_a as i128,
            false,
        )?;
        self.uplink_channel_bw_per_scs_list.encode(data)?;
        self.active_ulbwp.encode(data)?;
        if let Some(x) = &self.pci {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl AperCodec for SrsCarrierListItem {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        SrsCarrierListItem::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("SrsCarrierListItem"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("SrsCarrierListItem"))
    }
}
// SrsConfig
#[derive(Clone, Debug)]
pub struct SrsConfig {
    pub srs_resource_list: Option<SrsResourceList>,
    pub pos_srs_resource_list: Option<PosSrsResourceList>,
    pub srs_resource_set_list: Option<SrsResourceSetList1>,
    pub pos_srs_resource_set_list: Option<PosSrsResourceSetList>,
}

impl SrsConfig {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (optionals, _extensions_present) =
            aper::decode::decode_sequence_header(data, false, 5)?;
        let srs_resource_list = if optionals[0] {
            Some(SrsResourceList::decode(data)?)
        } else {
            None
        };
        let pos_srs_resource_list = if optionals[1] {
            Some(PosSrsResourceList::decode(data)?)
        } else {
            None
        };
        let srs_resource_set_list = if optionals[2] {
            Some(SrsResourceSetList1::decode(data)?)
        } else {
            None
        };
        let pos_srs_resource_set_list = if optionals[3] {
            Some(PosSrsResourceSetList::decode(data)?)
        } else {
            None
        };

        Ok(Self {
            srs_resource_list,
            pos_srs_resource_list,
            srs_resource_set_list,
            pos_srs_resource_set_list,
        })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(self.srs_resource_list.is_some());
        optionals.push(self.pos_srs_resource_list.is_some());
        optionals.push(self.srs_resource_set_list.is_some());
        optionals.push(self.pos_srs_resource_set_list.is_some());
        optionals.push(false);

        aper::encode::encode_sequence_header(data, false, &optionals, false)?;
        if let Some(x) = &self.srs_resource_list {
            x.encode(data)?;
        }
        if let Some(x) = &self.pos_srs_resource_list {
            x.encode(data)?;
        }
        if let Some(x) = &self.srs_resource_set_list {
            x.encode(data)?;
        }
        if let Some(x) = &self.pos_srs_resource_set_list {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl AperCodec for SrsConfig {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        SrsConfig::decode_inner(data).map_err(|e: AperCodecError| e.push_context("SrsConfig"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("SrsConfig"))
    }
}
// SrsConfiguration
#[derive(Clone, Debug)]
pub struct SrsConfiguration {
    pub srs_carrier_list: SrsCarrierList,
}

impl SrsConfiguration {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (_optionals, _extensions_present) =
            aper::decode::decode_sequence_header(data, false, 1)?;
        let srs_carrier_list = SrsCarrierList::decode(data)?;

        Ok(Self { srs_carrier_list })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(false);

        aper::encode::encode_sequence_header(data, false, &optionals, false)?;
        self.srs_carrier_list.encode(data)?;

        Ok(())
    }
}

impl AperCodec for SrsConfiguration {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        SrsConfiguration::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("SrsConfiguration"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("SrsConfiguration"))
    }
}
// SrsFrequency
#[derive(Clone, Debug)]
pub struct SrsFrequency(pub u32);

impl SrsFrequency {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        Ok(Self(
            aper::decode::decode_integer(data, Some(0), Some(3279165), false)?.0 as u32,
        ))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_integer(data, Some(0), Some(3279165), false, self.0 as i128, false)
    }
}

impl AperCodec for SrsFrequency {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        SrsFrequency::decode_inner(data).map_err(|e: AperCodecError| e.push_context("SrsFrequency"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("SrsFrequency"))
    }
}
// SrsPosResourceId
#[derive(Clone, Debug)]
pub struct SrsPosResourceId(pub u8);

impl SrsPosResourceId {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        Ok(Self(
            aper::decode::decode_integer(data, Some(0), Some(63), false)?.0 as u8,
        ))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_integer(data, Some(0), Some(63), false, self.0 as i128, false)
    }
}

impl AperCodec for SrsPosResourceId {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        SrsPosResourceId::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("SrsPosResourceId"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("SrsPosResourceId"))
    }
}
// SrsResource
#[derive(Clone, Debug)]
pub struct SrsResource {
    pub srs_resource_id: SrsResourceId,
    pub nrof_srs_ports: NrofSrsPorts,
    pub transmission_comb: TransmissionComb,
    pub start_position: u8,
    pub nrof_symbols: NrofSymbols1,
    pub repetition_factor: RepetitionFactor,
    pub freq_domain_position: u8,
    pub freq_domain_shift: u16,
    pub c_srs: u8,
    pub b_srs: u8,
    pub b_hop: u8,
    pub group_or_sequence_hopping: GroupOrSequenceHopping1,
    pub resource_type: ResourceType,
    pub sequence_id: u16,
}

impl SrsResource {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (_optionals, _extensions_present) =
            aper::decode::decode_sequence_header(data, false, 1)?;
        let srs_resource_id = SrsResourceId::decode(data)?;
        let nrof_srs_ports = NrofSrsPorts::decode(data)?;
        let transmission_comb = TransmissionComb::decode(data)?;
        let start_position = aper::decode::decode_integer(data, Some(0), Some(13), false)?.0 as u8;
        let nrof_symbols = NrofSymbols1::decode(data)?;
        let repetition_factor = RepetitionFactor::decode(data)?;
        let freq_domain_position =
            aper::decode::decode_integer(data, Some(0), Some(67), false)?.0 as u8;
        let freq_domain_shift =
            aper::decode::decode_integer(data, Some(0), Some(268), false)?.0 as u16;
        let c_srs = aper::decode::decode_integer(data, Some(0), Some(63), false)?.0 as u8;
        let b_srs = aper::decode::decode_integer(data, Some(0), Some(3), false)?.0 as u8;
        let b_hop = aper::decode::decode_integer(data, Some(0), Some(3), false)?.0 as u8;
        let group_or_sequence_hopping = GroupOrSequenceHopping1::decode(data)?;
        let resource_type = ResourceType::decode(data)?;
        let sequence_id = aper::decode::decode_integer(data, Some(0), Some(1023), false)?.0 as u16;

        Ok(Self {
            srs_resource_id,
            nrof_srs_ports,
            transmission_comb,
            start_position,
            nrof_symbols,
            repetition_factor,
            freq_domain_position,
            freq_domain_shift,
            c_srs,
            b_srs,
            b_hop,
            group_or_sequence_hopping,
            resource_type,
            sequence_id,
        })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(false);

        aper::encode::encode_sequence_header(data, false, &optionals, false)?;
        self.srs_resource_id.encode(data)?;
        self.nrof_srs_ports.encode(data)?;
        self.transmission_comb.encode(data)?;
        aper::encode::encode_integer(
            data,
            Some(0),
            Some(13),
            false,
            self.start_position as i128,
            false,
        )?;
        self.nrof_symbols.encode(data)?;
        self.repetition_factor.encode(data)?;
        aper::encode::encode_integer(
            data,
            Some(0),
            Some(67),
            false,
            self.freq_domain_position as i128,
            false,
        )?;
        aper::encode::encode_integer(
            data,
            Some(0),
            Some(268),
            false,
            self.freq_domain_shift as i128,
            false,
        )?;
        aper::encode::encode_integer(data, Some(0), Some(63), false, self.c_srs as i128, false)?;
        aper::encode::encode_integer(data, Some(0), Some(3), false, self.b_srs as i128, false)?;
        aper::encode::encode_integer(data, Some(0), Some(3), false, self.b_hop as i128, false)?;
        self.group_or_sequence_hopping.encode(data)?;
        self.resource_type.encode(data)?;
        aper::encode::encode_integer(
            data,
            Some(0),
            Some(1023),
            false,
            self.sequence_id as i128,
            false,
        )?;

        Ok(())
    }
}

impl AperCodec for SrsResource {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        SrsResource::decode_inner(data).map_err(|e: AperCodecError| e.push_context("SrsResource"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("SrsResource"))
    }
}
// SrsResourceId
#[derive(Clone, Debug)]
pub struct SrsResourceId(pub u8);

impl SrsResourceId {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        Ok(Self(
            aper::decode::decode_integer(data, Some(0), Some(63), false)?.0 as u8,
        ))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_integer(data, Some(0), Some(63), false, self.0 as i128, false)
    }
}

impl AperCodec for SrsResourceId {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        SrsResourceId::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("SrsResourceId"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("SrsResourceId"))
    }
}
// SrsResourceIdList
#[derive(Clone, Debug)]
pub struct SrsResourceIdList(pub Vec<SrsResourceId>);

impl SrsResourceIdList {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        Ok(Self({
            let length = aper::decode::decode_length_determinent(data, Some(1), Some(16), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(SrsResourceId::decode(data)?);
            }
            items
        }))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_length_determinent(data, Some(1), Some(16), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl AperCodec for SrsResourceIdList {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        SrsResourceIdList::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("SrsResourceIdList"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("SrsResourceIdList"))
    }
}
// SrsResourceList
#[derive(Clone, Debug)]
pub struct SrsResourceList(pub Vec<SrsResource>);

impl SrsResourceList {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        Ok(Self({
            let length = aper::decode::decode_length_determinent(data, Some(1), Some(64), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(SrsResource::decode(data)?);
            }
            items
        }))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_length_determinent(data, Some(1), Some(64), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl AperCodec for SrsResourceList {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        SrsResourceList::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("SrsResourceList"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("SrsResourceList"))
    }
}
// SrsResourceSet
#[derive(Clone, Debug)]
pub struct SrsResourceSet {
    pub srs_resource_set_id: SrsResourceSetId,
    pub srs_resource_id_list: SrsResourceIdList,
    pub resource_set_type: ResourceSetType,
}

impl SrsResourceSet {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (_optionals, _extensions_present) =
            aper::decode::decode_sequence_header(data, false, 1)?;
        let srs_resource_set_id = SrsResourceSetId::decode(data)?;
        let srs_resource_id_list = SrsResourceIdList::decode(data)?;
        let resource_set_type = ResourceSetType::decode(data)?;

        Ok(Self {
            srs_resource_set_id,
            srs_resource_id_list,
            resource_set_type,
        })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(false);

        aper::encode::encode_sequence_header(data, false, &optionals, false)?;
        self.srs_resource_set_id.encode(data)?;
        self.srs_resource_id_list.encode(data)?;
        self.resource_set_type.encode(data)?;

        Ok(())
    }
}

impl AperCodec for SrsResourceSet {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        SrsResourceSet::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("SrsResourceSet"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("SrsResourceSet"))
    }
}
// SrsResourceSetId
#[derive(Clone, Debug)]
pub struct SrsResourceSetId(pub u8);

impl SrsResourceSetId {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        Ok(Self(
            aper::decode::decode_integer(data, Some(0), Some(15), true)?.0 as u8,
        ))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_integer(data, Some(0), Some(15), true, self.0 as i128, false)
    }
}

impl AperCodec for SrsResourceSetId {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        SrsResourceSetId::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("SrsResourceSetId"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("SrsResourceSetId"))
    }
}
// SrsResourceSetList
#[derive(Clone, Debug)]
pub struct SrsResourceSetList(pub Vec<SrsResourceSetItem>);

impl SrsResourceSetList {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        Ok(Self({
            let length = aper::decode::decode_length_determinent(data, Some(1), Some(16), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(SrsResourceSetItem::decode(data)?);
            }
            items
        }))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_length_determinent(data, Some(1), Some(16), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl AperCodec for SrsResourceSetList {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        SrsResourceSetList::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("SrsResourceSetList"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("SrsResourceSetList"))
    }
}
// SrsResourceSetItem
#[derive(Clone, Debug)]
pub struct SrsResourceSetItem {
    pub num_sr_sresourcesperset: Option<u8>,
    pub periodicity_list: Option<PeriodicityList>,
    pub spatial_relation_info: Option<SpatialRelationInfo>,
    pub pathloss_reference_info: Option<PathlossReferenceInfo>,
}

impl SrsResourceSetItem {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (optionals, _extensions_present) =
            aper::decode::decode_sequence_header(data, false, 5)?;
        let num_sr_sresourcesperset = if optionals[0] {
            Some(aper::decode::decode_integer(data, Some(1), Some(16), true)?.0 as u8)
        } else {
            None
        };
        let periodicity_list = if optionals[1] {
            Some(PeriodicityList::decode(data)?)
        } else {
            None
        };
        let spatial_relation_info = if optionals[2] {
            Some(SpatialRelationInfo::decode(data)?)
        } else {
            None
        };
        let pathloss_reference_info = if optionals[3] {
            Some(PathlossReferenceInfo::decode(data)?)
        } else {
            None
        };

        Ok(Self {
            num_sr_sresourcesperset,
            periodicity_list,
            spatial_relation_info,
            pathloss_reference_info,
        })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(self.num_sr_sresourcesperset.is_some());
        optionals.push(self.periodicity_list.is_some());
        optionals.push(self.spatial_relation_info.is_some());
        optionals.push(self.pathloss_reference_info.is_some());
        optionals.push(false);

        aper::encode::encode_sequence_header(data, false, &optionals, false)?;
        if let Some(x) = &self.num_sr_sresourcesperset {
            aper::encode::encode_integer(data, Some(1), Some(16), true, *x as i128, false)?;
        }
        if let Some(x) = &self.periodicity_list {
            x.encode(data)?;
        }
        if let Some(x) = &self.spatial_relation_info {
            x.encode(data)?;
        }
        if let Some(x) = &self.pathloss_reference_info {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl AperCodec for SrsResourceSetItem {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        SrsResourceSetItem::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("SrsResourceSetItem"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("SrsResourceSetItem"))
    }
}
// SrsResourceSetList1
#[derive(Clone, Debug)]
pub struct SrsResourceSetList1(pub Vec<SrsResourceSet>);

impl SrsResourceSetList1 {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        Ok(Self({
            let length = aper::decode::decode_length_determinent(data, Some(1), Some(16), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(SrsResourceSet::decode(data)?);
            }
            items
        }))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_length_determinent(data, Some(1), Some(16), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl AperCodec for SrsResourceSetList1 {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        SrsResourceSetList1::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("SrsResourceSetList1"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("SrsResourceSetList1"))
    }
}
// SrsResourceTrigger
#[derive(Clone, Debug)]
pub struct SrsResourceTrigger {
    pub aperiodic_srs_resource_trigger_list: AperiodicSrsResourceTriggerList,
}

impl SrsResourceTrigger {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (_optionals, _extensions_present) =
            aper::decode::decode_sequence_header(data, false, 1)?;
        let aperiodic_srs_resource_trigger_list = AperiodicSrsResourceTriggerList::decode(data)?;

        Ok(Self {
            aperiodic_srs_resource_trigger_list,
        })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(false);

        aper::encode::encode_sequence_header(data, false, &optionals, false)?;
        self.aperiodic_srs_resource_trigger_list.encode(data)?;

        Ok(())
    }
}

impl AperCodec for SrsResourceTrigger {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        SrsResourceTrigger::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("SrsResourceTrigger"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("SrsResourceTrigger"))
    }
}
// Ssb
#[derive(Clone, Debug)]
pub struct Ssb {
    pub pci_nr: Nrpci,
    pub ssb_index: Option<SsbIndex>,
}

impl Ssb {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (optionals, _extensions_present) =
            aper::decode::decode_sequence_header(data, false, 2)?;
        let pci_nr = Nrpci::decode(data)?;
        let ssb_index = if optionals[0] {
            Some(SsbIndex::decode(data)?)
        } else {
            None
        };

        Ok(Self { pci_nr, ssb_index })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(self.ssb_index.is_some());
        optionals.push(false);

        aper::encode::encode_sequence_header(data, false, &optionals, false)?;
        self.pci_nr.encode(data)?;
        if let Some(x) = &self.ssb_index {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl AperCodec for Ssb {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        Ssb::decode_inner(data).map_err(|e: AperCodecError| e.push_context("Ssb"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("Ssb"))
    }
}
// SsbFreqInfo
#[derive(Clone, Debug)]
pub struct SsbFreqInfo(pub u32);

impl SsbFreqInfo {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        Ok(Self(
            aper::decode::decode_integer(data, Some(0), Some(3279165), false)?.0 as u32,
        ))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_integer(data, Some(0), Some(3279165), false, self.0 as i128, false)
    }
}

impl AperCodec for SsbFreqInfo {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        SsbFreqInfo::decode_inner(data).map_err(|e: AperCodecError| e.push_context("SsbFreqInfo"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("SsbFreqInfo"))
    }
}
// SsbIndex
#[derive(Clone, Debug)]
pub struct SsbIndex(pub u8);

impl SsbIndex {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        Ok(Self(
            aper::decode::decode_integer(data, Some(0), Some(63), false)?.0 as u8,
        ))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_integer(data, Some(0), Some(63), false, self.0 as i128, false)
    }
}

impl AperCodec for SsbIndex {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        SsbIndex::decode_inner(data).map_err(|e: AperCodecError| e.push_context("SsbIndex"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("SsbIndex"))
    }
}
// SsbSubcarrierSpacing
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum SsbSubcarrierSpacing {
    KHz15,
    KHz30,
    KHz120,
    KHz240,
    Spare3,
    Spare2,
    Spare1,
}

impl SsbSubcarrierSpacing {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (idx, extended) = aper::decode::decode_enumerated(data, Some(0), Some(6), true)?;
        if extended {
            return Err(aper::AperCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| AperCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_enumerated(data, Some(0), Some(6), true, *self as i128, false)
    }
}

impl AperCodec for SsbSubcarrierSpacing {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        SsbSubcarrierSpacing::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("SsbSubcarrierSpacing"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("SsbSubcarrierSpacing"))
    }
}
// SsbTransmissionPeriodicity
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum SsbTransmissionPeriodicity {
    Sf10,
    Sf20,
    Sf40,
    Sf80,
    Sf160,
    Sf320,
    Sf640,
}

impl SsbTransmissionPeriodicity {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (idx, extended) = aper::decode::decode_enumerated(data, Some(0), Some(6), true)?;
        if extended {
            return Err(aper::AperCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| AperCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_enumerated(data, Some(0), Some(6), true, *self as i128, false)
    }
}

impl AperCodec for SsbTransmissionPeriodicity {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        SsbTransmissionPeriodicity::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("SsbTransmissionPeriodicity"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("SsbTransmissionPeriodicity"))
    }
}
// SsbTransmissionTimingOffset
#[derive(Clone, Debug)]
pub struct SsbTransmissionTimingOffset(pub u8);

impl SsbTransmissionTimingOffset {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        Ok(Self(
            aper::decode::decode_integer(data, Some(0), Some(127), true)?.0 as u8,
        ))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_integer(data, Some(0), Some(127), true, self.0 as i128, false)
    }
}

impl AperCodec for SsbTransmissionTimingOffset {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        SsbTransmissionTimingOffset::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("SsbTransmissionTimingOffset"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("SsbTransmissionTimingOffset"))
    }
}
// SsbTransmissionBitmap
#[derive(Clone, Debug)]
pub enum SsbTransmissionBitmap {
    ShortBitmap(BitString),
    MediumBitmap(BitString),
    LongBitmap(BitString),
}

impl SsbTransmissionBitmap {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (idx, extended) = aper::decode::decode_choice_idx(data, 0, 3, false)?;
        if extended {
            return Err(aper::AperCodecError::new(
                "CHOICE additions not implemented",
            ));
        }
        match idx {
            0 => Ok(Self::ShortBitmap(aper::decode::decode_bitstring(
                data,
                Some(4),
                Some(4),
                false,
            )?)),
            1 => Ok(Self::MediumBitmap(aper::decode::decode_bitstring(
                data,
                Some(8),
                Some(8),
                false,
            )?)),
            2 => Ok(Self::LongBitmap(aper::decode::decode_bitstring(
                data,
                Some(64),
                Some(64),
                false,
            )?)),
            3 => Err(AperCodecError::new(
                "Choice extension container not implemented",
            )),
            _ => Err(AperCodecError::new("Unknown choice idx")),
        }
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        match self {
            Self::ShortBitmap(x) => {
                aper::encode::encode_choice_idx(data, 0, 3, false, 0, false)?;
                aper::encode::encode_bitstring(data, Some(4), Some(4), false, &x, false)
            }
            Self::MediumBitmap(x) => {
                aper::encode::encode_choice_idx(data, 0, 3, false, 1, false)?;
                aper::encode::encode_bitstring(data, Some(8), Some(8), false, &x, false)
            }
            Self::LongBitmap(x) => {
                aper::encode::encode_choice_idx(data, 0, 3, false, 2, false)?;
                aper::encode::encode_bitstring(data, Some(64), Some(64), false, &x, false)
            }
        }
    }
}

impl AperCodec for SsbTransmissionBitmap {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        SsbTransmissionBitmap::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("SsbTransmissionBitmap"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("SsbTransmissionBitmap"))
    }
}
// SsbAreaCapacityValueList
#[derive(Clone, Debug)]
pub struct SsbAreaCapacityValueList(pub Vec<SsbAreaCapacityValueItem>);

impl SsbAreaCapacityValueList {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        Ok(Self({
            let length = aper::decode::decode_length_determinent(data, Some(1), Some(64), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(SsbAreaCapacityValueItem::decode(data)?);
            }
            items
        }))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_length_determinent(data, Some(1), Some(64), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl AperCodec for SsbAreaCapacityValueList {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        SsbAreaCapacityValueList::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("SsbAreaCapacityValueList"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("SsbAreaCapacityValueList"))
    }
}
// SsbAreaCapacityValueItem
#[derive(Clone, Debug)]
pub struct SsbAreaCapacityValueItem {
    pub ssb_index: u8,
    pub ssb_area_capacity_value: u8,
}

impl SsbAreaCapacityValueItem {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (_optionals, _extensions_present) =
            aper::decode::decode_sequence_header(data, false, 1)?;
        let ssb_index = aper::decode::decode_integer(data, Some(0), Some(63), false)?.0 as u8;
        let ssb_area_capacity_value =
            aper::decode::decode_integer(data, Some(0), Some(100), false)?.0 as u8;

        Ok(Self {
            ssb_index,
            ssb_area_capacity_value,
        })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(false);

        aper::encode::encode_sequence_header(data, false, &optionals, false)?;
        aper::encode::encode_integer(
            data,
            Some(0),
            Some(63),
            false,
            self.ssb_index as i128,
            false,
        )?;
        aper::encode::encode_integer(
            data,
            Some(0),
            Some(100),
            false,
            self.ssb_area_capacity_value as i128,
            false,
        )?;

        Ok(())
    }
}

impl AperCodec for SsbAreaCapacityValueItem {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        SsbAreaCapacityValueItem::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("SsbAreaCapacityValueItem"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("SsbAreaCapacityValueItem"))
    }
}
// SsbAreaRadioResourceStatusList
#[derive(Clone, Debug)]
pub struct SsbAreaRadioResourceStatusList(pub Vec<SsbAreaRadioResourceStatusItem>);

impl SsbAreaRadioResourceStatusList {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        Ok(Self({
            let length = aper::decode::decode_length_determinent(data, Some(1), Some(64), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(SsbAreaRadioResourceStatusItem::decode(data)?);
            }
            items
        }))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_length_determinent(data, Some(1), Some(64), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl AperCodec for SsbAreaRadioResourceStatusList {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        SsbAreaRadioResourceStatusList::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("SsbAreaRadioResourceStatusList"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("SsbAreaRadioResourceStatusList"))
    }
}
// SsbAreaRadioResourceStatusItem
#[derive(Clone, Debug)]
pub struct SsbAreaRadioResourceStatusItem {
    pub ssb_index: u8,
    pub ssb_area_dlgbrpr_busage: u8,
    pub ssb_area_ulgbrpr_busage: u8,
    pub ssb_area_d_lnon_gbrpr_busage: u8,
    pub ssb_area_u_lnon_gbrpr_busage: u8,
    pub ssb_area_dl_total_pr_busage: u8,
    pub ssb_area_ul_total_pr_busage: u8,
    pub d_lscheduling_pdcchcc_eusage: Option<u8>,
    pub u_lscheduling_pdcchcc_eusage: Option<u8>,
}

impl SsbAreaRadioResourceStatusItem {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (optionals, _extensions_present) =
            aper::decode::decode_sequence_header(data, false, 3)?;
        let ssb_index = aper::decode::decode_integer(data, Some(0), Some(63), false)?.0 as u8;
        let ssb_area_dlgbrpr_busage =
            aper::decode::decode_integer(data, Some(0), Some(100), false)?.0 as u8;
        let ssb_area_ulgbrpr_busage =
            aper::decode::decode_integer(data, Some(0), Some(100), false)?.0 as u8;
        let ssb_area_d_lnon_gbrpr_busage =
            aper::decode::decode_integer(data, Some(0), Some(100), false)?.0 as u8;
        let ssb_area_u_lnon_gbrpr_busage =
            aper::decode::decode_integer(data, Some(0), Some(100), false)?.0 as u8;
        let ssb_area_dl_total_pr_busage =
            aper::decode::decode_integer(data, Some(0), Some(100), false)?.0 as u8;
        let ssb_area_ul_total_pr_busage =
            aper::decode::decode_integer(data, Some(0), Some(100), false)?.0 as u8;
        let d_lscheduling_pdcchcc_eusage = if optionals[0] {
            Some(aper::decode::decode_integer(data, Some(0), Some(100), false)?.0 as u8)
        } else {
            None
        };
        let u_lscheduling_pdcchcc_eusage = if optionals[1] {
            Some(aper::decode::decode_integer(data, Some(0), Some(100), false)?.0 as u8)
        } else {
            None
        };

        Ok(Self {
            ssb_index,
            ssb_area_dlgbrpr_busage,
            ssb_area_ulgbrpr_busage,
            ssb_area_d_lnon_gbrpr_busage,
            ssb_area_u_lnon_gbrpr_busage,
            ssb_area_dl_total_pr_busage,
            ssb_area_ul_total_pr_busage,
            d_lscheduling_pdcchcc_eusage,
            u_lscheduling_pdcchcc_eusage,
        })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(self.d_lscheduling_pdcchcc_eusage.is_some());
        optionals.push(self.u_lscheduling_pdcchcc_eusage.is_some());
        optionals.push(false);

        aper::encode::encode_sequence_header(data, false, &optionals, false)?;
        aper::encode::encode_integer(
            data,
            Some(0),
            Some(63),
            false,
            self.ssb_index as i128,
            false,
        )?;
        aper::encode::encode_integer(
            data,
            Some(0),
            Some(100),
            false,
            self.ssb_area_dlgbrpr_busage as i128,
            false,
        )?;
        aper::encode::encode_integer(
            data,
            Some(0),
            Some(100),
            false,
            self.ssb_area_ulgbrpr_busage as i128,
            false,
        )?;
        aper::encode::encode_integer(
            data,
            Some(0),
            Some(100),
            false,
            self.ssb_area_d_lnon_gbrpr_busage as i128,
            false,
        )?;
        aper::encode::encode_integer(
            data,
            Some(0),
            Some(100),
            false,
            self.ssb_area_u_lnon_gbrpr_busage as i128,
            false,
        )?;
        aper::encode::encode_integer(
            data,
            Some(0),
            Some(100),
            false,
            self.ssb_area_dl_total_pr_busage as i128,
            false,
        )?;
        aper::encode::encode_integer(
            data,
            Some(0),
            Some(100),
            false,
            self.ssb_area_ul_total_pr_busage as i128,
            false,
        )?;
        if let Some(x) = &self.d_lscheduling_pdcchcc_eusage {
            aper::encode::encode_integer(data, Some(0), Some(100), false, *x as i128, false)?;
        }
        if let Some(x) = &self.u_lscheduling_pdcchcc_eusage {
            aper::encode::encode_integer(data, Some(0), Some(100), false, *x as i128, false)?;
        }

        Ok(())
    }
}

impl AperCodec for SsbAreaRadioResourceStatusItem {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        SsbAreaRadioResourceStatusItem::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("SsbAreaRadioResourceStatusItem"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("SsbAreaRadioResourceStatusItem"))
    }
}
// SsbInformation
#[derive(Clone, Debug)]
pub struct SsbInformation {
    pub ssb_information_list: SsbInformationList,
}

impl SsbInformation {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (_optionals, _extensions_present) =
            aper::decode::decode_sequence_header(data, false, 1)?;
        let ssb_information_list = SsbInformationList::decode(data)?;

        Ok(Self {
            ssb_information_list,
        })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(false);

        aper::encode::encode_sequence_header(data, false, &optionals, false)?;
        self.ssb_information_list.encode(data)?;

        Ok(())
    }
}

impl AperCodec for SsbInformation {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        SsbInformation::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("SsbInformation"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("SsbInformation"))
    }
}
// SsbInformationList
#[derive(Clone, Debug)]
pub struct SsbInformationList(pub Vec<SsbInformationItem>);

impl SsbInformationList {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        Ok(Self({
            let length = aper::decode::decode_length_determinent(data, Some(1), Some(255), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(SsbInformationItem::decode(data)?);
            }
            items
        }))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_length_determinent(data, Some(1), Some(255), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl AperCodec for SsbInformationList {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        SsbInformationList::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("SsbInformationList"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("SsbInformationList"))
    }
}
// SsbInformationItem
#[derive(Clone, Debug)]
pub struct SsbInformationItem {
    pub ssb_configuration: SsbTfConfiguration,
    pub pci_nr: Nrpci,
}

impl SsbInformationItem {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (_optionals, _extensions_present) =
            aper::decode::decode_sequence_header(data, false, 1)?;
        let ssb_configuration = SsbTfConfiguration::decode(data)?;
        let pci_nr = Nrpci::decode(data)?;

        Ok(Self {
            ssb_configuration,
            pci_nr,
        })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(false);

        aper::encode::encode_sequence_header(data, false, &optionals, false)?;
        self.ssb_configuration.encode(data)?;
        self.pci_nr.encode(data)?;

        Ok(())
    }
}

impl AperCodec for SsbInformationItem {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        SsbInformationItem::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("SsbInformationItem"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("SsbInformationItem"))
    }
}
// SsbPositionsInBurst
#[derive(Clone, Debug)]
pub enum SsbPositionsInBurst {
    ShortBitmap(BitString),
    MediumBitmap(BitString),
    LongBitmap(BitString),
}

impl SsbPositionsInBurst {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (idx, extended) = aper::decode::decode_choice_idx(data, 0, 3, false)?;
        if extended {
            return Err(aper::AperCodecError::new(
                "CHOICE additions not implemented",
            ));
        }
        match idx {
            0 => Ok(Self::ShortBitmap(aper::decode::decode_bitstring(
                data,
                Some(4),
                Some(4),
                false,
            )?)),
            1 => Ok(Self::MediumBitmap(aper::decode::decode_bitstring(
                data,
                Some(8),
                Some(8),
                false,
            )?)),
            2 => Ok(Self::LongBitmap(aper::decode::decode_bitstring(
                data,
                Some(64),
                Some(64),
                false,
            )?)),
            3 => Err(AperCodecError::new(
                "Choice extension container not implemented",
            )),
            _ => Err(AperCodecError::new("Unknown choice idx")),
        }
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        match self {
            Self::ShortBitmap(x) => {
                aper::encode::encode_choice_idx(data, 0, 3, false, 0, false)?;
                aper::encode::encode_bitstring(data, Some(4), Some(4), false, &x, false)
            }
            Self::MediumBitmap(x) => {
                aper::encode::encode_choice_idx(data, 0, 3, false, 1, false)?;
                aper::encode::encode_bitstring(data, Some(8), Some(8), false, &x, false)
            }
            Self::LongBitmap(x) => {
                aper::encode::encode_choice_idx(data, 0, 3, false, 2, false)?;
                aper::encode::encode_bitstring(data, Some(64), Some(64), false, &x, false)
            }
        }
    }
}

impl AperCodec for SsbPositionsInBurst {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        SsbPositionsInBurst::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("SsbPositionsInBurst"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("SsbPositionsInBurst"))
    }
}
// SsbTfConfiguration
#[derive(Clone, Debug)]
pub struct SsbTfConfiguration {
    pub ssb_frequency: u32,
    pub ssb_subcarrier_spacing: SsbSubcarrierSpacing1,
    pub ssb_transmit_power: i8,
    pub ssb_periodicity: SsbPeriodicity,
    pub ssb_half_frame_offset: u8,
    pub ssb_sfn_offset: u8,
    pub ssb_position_in_burst: Option<SsbPositionsInBurst>,
    pub sfn_initialisation_time: Option<RelativeTime1900>,
}

impl SsbTfConfiguration {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (optionals, _extensions_present) =
            aper::decode::decode_sequence_header(data, false, 3)?;
        let ssb_frequency =
            aper::decode::decode_integer(data, Some(0), Some(3279165), false)?.0 as u32;
        let ssb_subcarrier_spacing = SsbSubcarrierSpacing1::decode(data)?;
        let ssb_transmit_power =
            aper::decode::decode_integer(data, Some(-60), Some(50), false)?.0 as i8;
        let ssb_periodicity = SsbPeriodicity::decode(data)?;
        let ssb_half_frame_offset =
            aper::decode::decode_integer(data, Some(0), Some(1), false)?.0 as u8;
        let ssb_sfn_offset = aper::decode::decode_integer(data, Some(0), Some(15), false)?.0 as u8;
        let ssb_position_in_burst = if optionals[0] {
            Some(SsbPositionsInBurst::decode(data)?)
        } else {
            None
        };
        let sfn_initialisation_time = if optionals[1] {
            Some(RelativeTime1900::decode(data)?)
        } else {
            None
        };

        Ok(Self {
            ssb_frequency,
            ssb_subcarrier_spacing,
            ssb_transmit_power,
            ssb_periodicity,
            ssb_half_frame_offset,
            ssb_sfn_offset,
            ssb_position_in_burst,
            sfn_initialisation_time,
        })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(self.ssb_position_in_burst.is_some());
        optionals.push(self.sfn_initialisation_time.is_some());
        optionals.push(false);

        aper::encode::encode_sequence_header(data, false, &optionals, false)?;
        aper::encode::encode_integer(
            data,
            Some(0),
            Some(3279165),
            false,
            self.ssb_frequency as i128,
            false,
        )?;
        self.ssb_subcarrier_spacing.encode(data)?;
        aper::encode::encode_integer(
            data,
            Some(-60),
            Some(50),
            false,
            self.ssb_transmit_power as i128,
            false,
        )?;
        self.ssb_periodicity.encode(data)?;
        aper::encode::encode_integer(
            data,
            Some(0),
            Some(1),
            false,
            self.ssb_half_frame_offset as i128,
            false,
        )?;
        aper::encode::encode_integer(
            data,
            Some(0),
            Some(15),
            false,
            self.ssb_sfn_offset as i128,
            false,
        )?;
        if let Some(x) = &self.ssb_position_in_burst {
            x.encode(data)?;
        }
        if let Some(x) = &self.sfn_initialisation_time {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl AperCodec for SsbTfConfiguration {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        SsbTfConfiguration::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("SsbTfConfiguration"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("SsbTfConfiguration"))
    }
}
// SsbToReportList
#[derive(Clone, Debug)]
pub struct SsbToReportList(pub Vec<SsbToReportItem>);

impl SsbToReportList {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        Ok(Self({
            let length = aper::decode::decode_length_determinent(data, Some(1), Some(64), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(SsbToReportItem::decode(data)?);
            }
            items
        }))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_length_determinent(data, Some(1), Some(64), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl AperCodec for SsbToReportList {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        SsbToReportList::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("SsbToReportList"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("SsbToReportList"))
    }
}
// SsbToReportItem
#[derive(Clone, Debug)]
pub struct SsbToReportItem {
    pub ssb_index: u8,
}

impl SsbToReportItem {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (_optionals, _extensions_present) =
            aper::decode::decode_sequence_header(data, false, 1)?;
        let ssb_index = aper::decode::decode_integer(data, Some(0), Some(63), false)?.0 as u8;

        Ok(Self { ssb_index })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(false);

        aper::encode::encode_sequence_header(data, false, &optionals, false)?;
        aper::encode::encode_integer(
            data,
            Some(0),
            Some(63),
            false,
            self.ssb_index as i128,
            false,
        )?;

        Ok(())
    }
}

impl AperCodec for SsbToReportItem {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        SsbToReportItem::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("SsbToReportItem"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("SsbToReportItem"))
    }
}
// SulInformation
#[derive(Clone, Debug)]
pub struct SulInformation {
    pub sul_nrarfcn: u32,
    pub sul_transmission_bandwidth: TransmissionBandwidth,
}

impl SulInformation {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (_optionals, _extensions_present) =
            aper::decode::decode_sequence_header(data, true, 1)?;
        let sul_nrarfcn =
            aper::decode::decode_integer(data, Some(0), Some(3279165), false)?.0 as u32;
        let sul_transmission_bandwidth = TransmissionBandwidth::decode(data)?;

        Ok(Self {
            sul_nrarfcn,
            sul_transmission_bandwidth,
        })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(false);

        aper::encode::encode_sequence_header(data, true, &optionals, false)?;
        aper::encode::encode_integer(
            data,
            Some(0),
            Some(3279165),
            false,
            self.sul_nrarfcn as i128,
            false,
        )?;
        self.sul_transmission_bandwidth.encode(data)?;

        Ok(())
    }
}

impl AperCodec for SulInformation {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        SulInformation::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("SulInformation"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("SulInformation"))
    }
}
// SubcarrierSpacing
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum SubcarrierSpacing {
    KHz15,
    KHz30,
    KHz60,
    KHz120,
    KHz240,
    Spare3,
    Spare2,
    Spare1,
}

impl SubcarrierSpacing {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (idx, extended) = aper::decode::decode_enumerated(data, Some(0), Some(7), true)?;
        if extended {
            return Err(aper::AperCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| AperCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_enumerated(data, Some(0), Some(7), true, *self as i128, false)
    }
}

impl AperCodec for SubcarrierSpacing {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        SubcarrierSpacing::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("SubcarrierSpacing"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("SubcarrierSpacing"))
    }
}
// SubscriberProfileIDforRfp
#[derive(Clone, Debug)]
pub struct SubscriberProfileIDforRfp(pub u16);

impl SubscriberProfileIDforRfp {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        Ok(Self(
            aper::decode::decode_integer(data, Some(1), Some(256), true)?.0 as u16,
        ))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_integer(data, Some(1), Some(256), true, self.0 as i128, false)
    }
}

impl AperCodec for SubscriberProfileIDforRfp {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        SubscriberProfileIDforRfp::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("SubscriberProfileIDforRfp"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("SubscriberProfileIDforRfp"))
    }
}
// SulAccessIndication
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum SulAccessIndication {
    True,
}

impl SulAccessIndication {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (idx, extended) = aper::decode::decode_enumerated(data, Some(0), Some(0), true)?;
        if extended {
            return Err(aper::AperCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| AperCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_enumerated(data, Some(0), Some(0), true, *self as i128, false)
    }
}

impl AperCodec for SulAccessIndication {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        SulAccessIndication::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("SulAccessIndication"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("SulAccessIndication"))
    }
}
// SupportedSulFreqBandItem
#[derive(Clone, Debug)]
pub struct SupportedSulFreqBandItem {
    pub freq_band_indicator_nr: u16,
}

impl SupportedSulFreqBandItem {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (_optionals, _extensions_present) =
            aper::decode::decode_sequence_header(data, true, 1)?;
        let freq_band_indicator_nr =
            aper::decode::decode_integer(data, Some(1), Some(1024), true)?.0 as u16;

        Ok(Self {
            freq_band_indicator_nr,
        })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(false);

        aper::encode::encode_sequence_header(data, true, &optionals, false)?;
        aper::encode::encode_integer(
            data,
            Some(1),
            Some(1024),
            true,
            self.freq_band_indicator_nr as i128,
            false,
        )?;

        Ok(())
    }
}

impl AperCodec for SupportedSulFreqBandItem {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        SupportedSulFreqBandItem::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("SupportedSulFreqBandItem"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("SupportedSulFreqBandItem"))
    }
}
// SymbolAllocInSlot
#[derive(Clone, Debug)]
pub enum SymbolAllocInSlot {
    AllDl,
    AllUl,
    BothDlAndUl(NumDlulSymbols),
}

impl SymbolAllocInSlot {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (idx, extended) = aper::decode::decode_choice_idx(data, 0, 3, false)?;
        if extended {
            return Err(aper::AperCodecError::new(
                "CHOICE additions not implemented",
            ));
        }
        match idx {
            0 => Ok(Self::AllDl),
            1 => Ok(Self::AllUl),
            2 => Ok(Self::BothDlAndUl(NumDlulSymbols::decode(data)?)),
            3 => Err(AperCodecError::new(
                "Choice extension container not implemented",
            )),
            _ => Err(AperCodecError::new("Unknown choice idx")),
        }
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        match self {
            Self::AllDl => {
                aper::encode::encode_choice_idx(data, 0, 3, false, 0, false)?;
                Ok(())
            }
            Self::AllUl => {
                aper::encode::encode_choice_idx(data, 0, 3, false, 1, false)?;
                Ok(())
            }
            Self::BothDlAndUl(x) => {
                aper::encode::encode_choice_idx(data, 0, 3, false, 2, false)?;
                x.encode(data)
            }
        }
    }
}

impl AperCodec for SymbolAllocInSlot {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        SymbolAllocInSlot::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("SymbolAllocInSlot"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("SymbolAllocInSlot"))
    }
}
// SystemFrameNumber
#[derive(Clone, Debug)]
pub struct SystemFrameNumber(pub u16);

impl SystemFrameNumber {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        Ok(Self(
            aper::decode::decode_integer(data, Some(0), Some(1023), false)?.0 as u16,
        ))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_integer(data, Some(0), Some(1023), false, self.0 as i128, false)
    }
}

impl AperCodec for SystemFrameNumber {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        SystemFrameNumber::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("SystemFrameNumber"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("SystemFrameNumber"))
    }
}
// SystemInformationAreaId
#[derive(Clone, Debug)]
pub struct SystemInformationAreaId(pub BitString);

impl SystemInformationAreaId {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        Ok(Self(aper::decode::decode_bitstring(
            data,
            Some(24),
            Some(24),
            false,
        )?))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_bitstring(data, Some(24), Some(24), false, &self.0, false)
    }
}

impl AperCodec for SystemInformationAreaId {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        SystemInformationAreaId::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("SystemInformationAreaId"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("SystemInformationAreaId"))
    }
}
// FiveGsTac
#[derive(Clone, Debug)]
pub struct FiveGsTac(pub Vec<u8>);

impl FiveGsTac {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        Ok(Self(aper::decode::decode_octetstring(
            data,
            Some(3),
            Some(3),
            false,
        )?))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_octetstring(data, Some(3), Some(3), false, &self.0, false)
    }
}

impl AperCodec for FiveGsTac {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        FiveGsTac::decode_inner(data).map_err(|e: AperCodecError| e.push_context("FiveGsTac"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("FiveGsTac"))
    }
}
// ConfiguredEpsTac
#[derive(Clone, Debug)]
pub struct ConfiguredEpsTac(pub Vec<u8>);

impl ConfiguredEpsTac {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        Ok(Self(aper::decode::decode_octetstring(
            data,
            Some(2),
            Some(2),
            false,
        )?))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_octetstring(data, Some(2), Some(2), false, &self.0, false)
    }
}

impl AperCodec for ConfiguredEpsTac {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        ConfiguredEpsTac::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("ConfiguredEpsTac"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("ConfiguredEpsTac"))
    }
}
// TargetCellList
#[derive(Clone, Debug)]
pub struct TargetCellList(pub Vec<TargetCellListItem>);

impl TargetCellList {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        Ok(Self({
            let length = aper::decode::decode_length_determinent(data, Some(1), Some(8), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(TargetCellListItem::decode(data)?);
            }
            items
        }))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_length_determinent(data, Some(1), Some(8), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl AperCodec for TargetCellList {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        TargetCellList::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("TargetCellList"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("TargetCellList"))
    }
}
// TargetCellListItem
#[derive(Clone, Debug)]
pub struct TargetCellListItem {
    pub target_cell: Nrcgi,
}

impl TargetCellListItem {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (_optionals, _extensions_present) =
            aper::decode::decode_sequence_header(data, false, 1)?;
        let target_cell = Nrcgi::decode(data)?;

        Ok(Self { target_cell })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(false);

        aper::encode::encode_sequence_header(data, false, &optionals, false)?;
        self.target_cell.encode(data)?;

        Ok(())
    }
}

impl AperCodec for TargetCellListItem {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        TargetCellListItem::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("TargetCellListItem"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("TargetCellListItem"))
    }
}
// TddInfo
#[derive(Clone, Debug)]
pub struct TddInfo {
    pub nr_freq_info: NrFreqInfo,
    pub transmission_bandwidth: TransmissionBandwidth,
}

impl TddInfo {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (_optionals, _extensions_present) =
            aper::decode::decode_sequence_header(data, true, 1)?;
        let nr_freq_info = NrFreqInfo::decode(data)?;
        let transmission_bandwidth = TransmissionBandwidth::decode(data)?;

        Ok(Self {
            nr_freq_info,
            transmission_bandwidth,
        })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(false);

        aper::encode::encode_sequence_header(data, true, &optionals, false)?;
        self.nr_freq_info.encode(data)?;
        self.transmission_bandwidth.encode(data)?;

        Ok(())
    }
}

impl AperCodec for TddInfo {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        TddInfo::decode_inner(data).map_err(|e: AperCodecError| e.push_context("TddInfo"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("TddInfo"))
    }
}
// TddUlDlConfigCommonNr
#[derive(Clone, Debug)]
pub struct TddUlDlConfigCommonNr(pub Vec<u8>);

impl TddUlDlConfigCommonNr {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        Ok(Self(aper::decode::decode_octetstring(
            data, None, None, false,
        )?))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_octetstring(data, None, None, false, &self.0, false)
    }
}

impl AperCodec for TddUlDlConfigCommonNr {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        TddUlDlConfigCommonNr::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("TddUlDlConfigCommonNr"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("TddUlDlConfigCommonNr"))
    }
}
// TimeReferenceInformation
#[derive(Clone, Debug)]
pub struct TimeReferenceInformation {
    pub reference_time: ReferenceTime,
    pub reference_sfn: ReferenceSfn,
    pub uncertainty: Uncertainty,
    pub time_information_type: TimeInformationType,
}

impl TimeReferenceInformation {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (_optionals, _extensions_present) =
            aper::decode::decode_sequence_header(data, false, 1)?;
        let reference_time = ReferenceTime::decode(data)?;
        let reference_sfn = ReferenceSfn::decode(data)?;
        let uncertainty = Uncertainty::decode(data)?;
        let time_information_type = TimeInformationType::decode(data)?;

        Ok(Self {
            reference_time,
            reference_sfn,
            uncertainty,
            time_information_type,
        })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(false);

        aper::encode::encode_sequence_header(data, false, &optionals, false)?;
        self.reference_time.encode(data)?;
        self.reference_sfn.encode(data)?;
        self.uncertainty.encode(data)?;
        self.time_information_type.encode(data)?;

        Ok(())
    }
}

impl AperCodec for TimeReferenceInformation {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        TimeReferenceInformation::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("TimeReferenceInformation"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("TimeReferenceInformation"))
    }
}
// TimeInformationType
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum TimeInformationType {
    LocalClock,
}

impl TimeInformationType {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (idx, extended) = aper::decode::decode_enumerated(data, Some(0), Some(0), false)?;
        if extended {
            return Err(aper::AperCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| AperCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_enumerated(data, Some(0), Some(0), false, *self as i128, false)
    }
}

impl AperCodec for TimeInformationType {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        TimeInformationType::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("TimeInformationType"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("TimeInformationType"))
    }
}
// TimeStamp
#[derive(Clone, Debug)]
pub struct TimeStamp {
    pub system_frame_number: SystemFrameNumber,
    pub slot_index: TimeStampSlotIndex,
    pub measurement_time: Option<RelativeTime1900>,
}

impl TimeStamp {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (optionals, _extensions_present) =
            aper::decode::decode_sequence_header(data, false, 2)?;
        let system_frame_number = SystemFrameNumber::decode(data)?;
        let slot_index = TimeStampSlotIndex::decode(data)?;
        let measurement_time = if optionals[0] {
            Some(RelativeTime1900::decode(data)?)
        } else {
            None
        };

        Ok(Self {
            system_frame_number,
            slot_index,
            measurement_time,
        })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(self.measurement_time.is_some());
        optionals.push(false);

        aper::encode::encode_sequence_header(data, false, &optionals, false)?;
        self.system_frame_number.encode(data)?;
        self.slot_index.encode(data)?;
        if let Some(x) = &self.measurement_time {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl AperCodec for TimeStamp {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        TimeStamp::decode_inner(data).map_err(|e: AperCodecError| e.push_context("TimeStamp"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("TimeStamp"))
    }
}
// TimeStampSlotIndex
#[derive(Clone, Debug)]
pub enum TimeStampSlotIndex {
    Scs15(u8),
    Scs30(u8),
    Scs60(u8),
    Scs120(u8),
}

impl TimeStampSlotIndex {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (idx, extended) = aper::decode::decode_choice_idx(data, 0, 4, false)?;
        if extended {
            return Err(aper::AperCodecError::new(
                "CHOICE additions not implemented",
            ));
        }
        match idx {
            0 => Ok(Self::Scs15(
                aper::decode::decode_integer(data, Some(0), Some(9), false)?.0 as u8,
            )),
            1 => Ok(Self::Scs30(
                aper::decode::decode_integer(data, Some(0), Some(19), false)?.0 as u8,
            )),
            2 => Ok(Self::Scs60(
                aper::decode::decode_integer(data, Some(0), Some(39), false)?.0 as u8,
            )),
            3 => Ok(Self::Scs120(
                aper::decode::decode_integer(data, Some(0), Some(79), false)?.0 as u8,
            )),
            4 => Err(AperCodecError::new(
                "Choice extension container not implemented",
            )),
            _ => Err(AperCodecError::new("Unknown choice idx")),
        }
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        match self {
            Self::Scs15(x) => {
                aper::encode::encode_choice_idx(data, 0, 4, false, 0, false)?;
                aper::encode::encode_integer(data, Some(0), Some(9), false, *x as i128, false)
            }
            Self::Scs30(x) => {
                aper::encode::encode_choice_idx(data, 0, 4, false, 1, false)?;
                aper::encode::encode_integer(data, Some(0), Some(19), false, *x as i128, false)
            }
            Self::Scs60(x) => {
                aper::encode::encode_choice_idx(data, 0, 4, false, 2, false)?;
                aper::encode::encode_integer(data, Some(0), Some(39), false, *x as i128, false)
            }
            Self::Scs120(x) => {
                aper::encode::encode_choice_idx(data, 0, 4, false, 3, false)?;
                aper::encode::encode_integer(data, Some(0), Some(79), false, *x as i128, false)
            }
        }
    }
}

impl AperCodec for TimeStampSlotIndex {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        TimeStampSlotIndex::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("TimeStampSlotIndex"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("TimeStampSlotIndex"))
    }
}
// TimeToWait
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum TimeToWait {
    V1s,
    V2s,
    V5s,
    V10s,
    V20s,
    V60s,
}

impl TimeToWait {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (idx, extended) = aper::decode::decode_enumerated(data, Some(0), Some(5), true)?;
        if extended {
            return Err(aper::AperCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| AperCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_enumerated(data, Some(0), Some(5), true, *self as i128, false)
    }
}

impl AperCodec for TimeToWait {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        TimeToWait::decode_inner(data).map_err(|e: AperCodecError| e.push_context("TimeToWait"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("TimeToWait"))
    }
}
// TimingMeasurementQuality
#[derive(Clone, Debug)]
pub struct TimingMeasurementQuality {
    pub measurement_quality: u8,
    pub resolution: Resolution1,
}

impl TimingMeasurementQuality {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (_optionals, _extensions_present) =
            aper::decode::decode_sequence_header(data, false, 1)?;
        let measurement_quality =
            aper::decode::decode_integer(data, Some(0), Some(31), false)?.0 as u8;
        let resolution = Resolution1::decode(data)?;

        Ok(Self {
            measurement_quality,
            resolution,
        })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(false);

        aper::encode::encode_sequence_header(data, false, &optionals, false)?;
        aper::encode::encode_integer(
            data,
            Some(0),
            Some(31),
            false,
            self.measurement_quality as i128,
            false,
        )?;
        self.resolution.encode(data)?;

        Ok(())
    }
}

impl AperCodec for TimingMeasurementQuality {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        TimingMeasurementQuality::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("TimingMeasurementQuality"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("TimingMeasurementQuality"))
    }
}
// TnlAssociationUsage
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum TnlAssociationUsage {
    Ue,
    NonUe,
    Both,
}

impl TnlAssociationUsage {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (idx, extended) = aper::decode::decode_enumerated(data, Some(0), Some(2), true)?;
        if extended {
            return Err(aper::AperCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| AperCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_enumerated(data, Some(0), Some(2), true, *self as i128, false)
    }
}

impl AperCodec for TnlAssociationUsage {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        TnlAssociationUsage::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("TnlAssociationUsage"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("TnlAssociationUsage"))
    }
}
// TnlCapacityIndicator
#[derive(Clone, Debug)]
pub struct TnlCapacityIndicator {
    pub dltnl_offered_capacity: u32,
    pub dltnl_available_capacity: u8,
    pub ultnl_offered_capacity: u32,
    pub ultnl_available_capacity: u8,
}

impl TnlCapacityIndicator {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (_optionals, _extensions_present) =
            aper::decode::decode_sequence_header(data, false, 1)?;
        let dltnl_offered_capacity =
            aper::decode::decode_integer(data, Some(1), Some(16777216), true)?.0 as u32;
        let dltnl_available_capacity =
            aper::decode::decode_integer(data, Some(0), Some(100), true)?.0 as u8;
        let ultnl_offered_capacity =
            aper::decode::decode_integer(data, Some(1), Some(16777216), true)?.0 as u32;
        let ultnl_available_capacity =
            aper::decode::decode_integer(data, Some(0), Some(100), true)?.0 as u8;

        Ok(Self {
            dltnl_offered_capacity,
            dltnl_available_capacity,
            ultnl_offered_capacity,
            ultnl_available_capacity,
        })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(false);

        aper::encode::encode_sequence_header(data, false, &optionals, false)?;
        aper::encode::encode_integer(
            data,
            Some(1),
            Some(16777216),
            true,
            self.dltnl_offered_capacity as i128,
            false,
        )?;
        aper::encode::encode_integer(
            data,
            Some(0),
            Some(100),
            true,
            self.dltnl_available_capacity as i128,
            false,
        )?;
        aper::encode::encode_integer(
            data,
            Some(1),
            Some(16777216),
            true,
            self.ultnl_offered_capacity as i128,
            false,
        )?;
        aper::encode::encode_integer(
            data,
            Some(0),
            Some(100),
            true,
            self.ultnl_available_capacity as i128,
            false,
        )?;

        Ok(())
    }
}

impl AperCodec for TnlCapacityIndicator {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        TnlCapacityIndicator::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("TnlCapacityIndicator"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("TnlCapacityIndicator"))
    }
}
// TraceActivation
#[derive(Clone, Debug)]
pub struct TraceActivation {
    pub trace_id: TraceId,
    pub interfaces_to_trace: InterfacesToTrace,
    pub trace_depth: TraceDepth,
    pub trace_collection_entity_ip_address: TransportLayerAddress,
}

impl TraceActivation {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (_optionals, _extensions_present) =
            aper::decode::decode_sequence_header(data, false, 1)?;
        let trace_id = TraceId::decode(data)?;
        let interfaces_to_trace = InterfacesToTrace::decode(data)?;
        let trace_depth = TraceDepth::decode(data)?;
        let trace_collection_entity_ip_address = TransportLayerAddress::decode(data)?;

        Ok(Self {
            trace_id,
            interfaces_to_trace,
            trace_depth,
            trace_collection_entity_ip_address,
        })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(false);

        aper::encode::encode_sequence_header(data, false, &optionals, false)?;
        self.trace_id.encode(data)?;
        self.interfaces_to_trace.encode(data)?;
        self.trace_depth.encode(data)?;
        self.trace_collection_entity_ip_address.encode(data)?;

        Ok(())
    }
}

impl AperCodec for TraceActivation {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        TraceActivation::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("TraceActivation"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("TraceActivation"))
    }
}
// TraceDepth
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum TraceDepth {
    Minimum,
    Medium,
    Maximum,
    MinimumWithoutVendorSpecificExtension,
    MediumWithoutVendorSpecificExtension,
    MaximumWithoutVendorSpecificExtension,
}

impl TraceDepth {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (idx, extended) = aper::decode::decode_enumerated(data, Some(0), Some(5), true)?;
        if extended {
            return Err(aper::AperCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| AperCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_enumerated(data, Some(0), Some(5), true, *self as i128, false)
    }
}

impl AperCodec for TraceDepth {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        TraceDepth::decode_inner(data).map_err(|e: AperCodecError| e.push_context("TraceDepth"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("TraceDepth"))
    }
}
// TraceId
#[derive(Clone, Debug)]
pub struct TraceId(pub Vec<u8>);

impl TraceId {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        Ok(Self(aper::decode::decode_octetstring(
            data,
            Some(8),
            Some(8),
            false,
        )?))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_octetstring(data, Some(8), Some(8), false, &self.0, false)
    }
}

impl AperCodec for TraceId {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        TraceId::decode_inner(data).map_err(|e: AperCodecError| e.push_context("TraceId"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("TraceId"))
    }
}
// TrafficMappingInfo
#[derive(Clone, Debug)]
pub enum TrafficMappingInfo {
    IPtolayer2TrafficMappingInfo(IPtolayer2TrafficMappingInfo),
    BaPlayerBhrlCchannelMappingInfo(BaPlayerBhrlCchannelMappingInfo),
}

impl TrafficMappingInfo {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (idx, extended) = aper::decode::decode_choice_idx(data, 0, 2, false)?;
        if extended {
            return Err(aper::AperCodecError::new(
                "CHOICE additions not implemented",
            ));
        }
        match idx {
            0 => Ok(Self::IPtolayer2TrafficMappingInfo(
                IPtolayer2TrafficMappingInfo::decode(data)?,
            )),
            1 => Ok(Self::BaPlayerBhrlCchannelMappingInfo(
                BaPlayerBhrlCchannelMappingInfo::decode(data)?,
            )),
            2 => Err(AperCodecError::new(
                "Choice extension container not implemented",
            )),
            _ => Err(AperCodecError::new("Unknown choice idx")),
        }
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        match self {
            Self::IPtolayer2TrafficMappingInfo(x) => {
                aper::encode::encode_choice_idx(data, 0, 2, false, 0, false)?;
                x.encode(data)
            }
            Self::BaPlayerBhrlCchannelMappingInfo(x) => {
                aper::encode::encode_choice_idx(data, 0, 2, false, 1, false)?;
                x.encode(data)
            }
        }
    }
}

impl AperCodec for TrafficMappingInfo {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        TrafficMappingInfo::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("TrafficMappingInfo"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("TrafficMappingInfo"))
    }
}
// TransportLayerAddress
#[derive(Clone, Debug)]
pub struct TransportLayerAddress(pub BitString);

impl TransportLayerAddress {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        Ok(Self(aper::decode::decode_bitstring(
            data,
            Some(1),
            Some(160),
            true,
        )?))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_bitstring(data, Some(1), Some(160), true, &self.0, false)
    }
}

impl AperCodec for TransportLayerAddress {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        TransportLayerAddress::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("TransportLayerAddress"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("TransportLayerAddress"))
    }
}
// TransactionId
#[derive(Clone, Debug)]
pub struct TransactionId(pub u8);

impl TransactionId {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        Ok(Self(
            aper::decode::decode_integer(data, Some(0), Some(255), true)?.0 as u8,
        ))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_integer(data, Some(0), Some(255), true, self.0 as i128, false)
    }
}

impl AperCodec for TransactionId {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        TransactionId::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("TransactionId"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("TransactionId"))
    }
}
// TransmissionBandwidth
#[derive(Clone, Debug)]
pub struct TransmissionBandwidth {
    pub nrscs: Nrscs,
    pub nrnrb: Nrnrb,
}

impl TransmissionBandwidth {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (_optionals, _extensions_present) =
            aper::decode::decode_sequence_header(data, true, 1)?;
        let nrscs = Nrscs::decode(data)?;
        let nrnrb = Nrnrb::decode(data)?;

        Ok(Self { nrscs, nrnrb })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(false);

        aper::encode::encode_sequence_header(data, true, &optionals, false)?;
        self.nrscs.encode(data)?;
        self.nrnrb.encode(data)?;

        Ok(())
    }
}

impl AperCodec for TransmissionBandwidth {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        TransmissionBandwidth::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("TransmissionBandwidth"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("TransmissionBandwidth"))
    }
}
// TransmissionComb
#[derive(Clone, Debug)]
pub enum TransmissionComb {
    N2(N2),
    N4(N4),
}

impl TransmissionComb {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (idx, extended) = aper::decode::decode_choice_idx(data, 0, 2, false)?;
        if extended {
            return Err(aper::AperCodecError::new(
                "CHOICE additions not implemented",
            ));
        }
        match idx {
            0 => Ok(Self::N2(N2::decode(data)?)),
            1 => Ok(Self::N4(N4::decode(data)?)),
            2 => Err(AperCodecError::new(
                "Choice extension container not implemented",
            )),
            _ => Err(AperCodecError::new("Unknown choice idx")),
        }
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        match self {
            Self::N2(x) => {
                aper::encode::encode_choice_idx(data, 0, 2, false, 0, false)?;
                x.encode(data)
            }
            Self::N4(x) => {
                aper::encode::encode_choice_idx(data, 0, 2, false, 1, false)?;
                x.encode(data)
            }
        }
    }
}

impl AperCodec for TransmissionComb {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        TransmissionComb::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("TransmissionComb"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("TransmissionComb"))
    }
}
// TransmissionCombPos
#[derive(Clone, Debug)]
pub enum TransmissionCombPos {
    N2(N2_1),
    N4(N4_1),
    N8(N8),
}

impl TransmissionCombPos {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (idx, extended) = aper::decode::decode_choice_idx(data, 0, 3, false)?;
        if extended {
            return Err(aper::AperCodecError::new(
                "CHOICE additions not implemented",
            ));
        }
        match idx {
            0 => Ok(Self::N2(N2_1::decode(data)?)),
            1 => Ok(Self::N4(N4_1::decode(data)?)),
            2 => Ok(Self::N8(N8::decode(data)?)),
            3 => Err(AperCodecError::new(
                "Choice extension container not implemented",
            )),
            _ => Err(AperCodecError::new("Unknown choice idx")),
        }
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        match self {
            Self::N2(x) => {
                aper::encode::encode_choice_idx(data, 0, 3, false, 0, false)?;
                x.encode(data)
            }
            Self::N4(x) => {
                aper::encode::encode_choice_idx(data, 0, 3, false, 1, false)?;
                x.encode(data)
            }
            Self::N8(x) => {
                aper::encode::encode_choice_idx(data, 0, 3, false, 2, false)?;
                x.encode(data)
            }
        }
    }
}

impl AperCodec for TransmissionCombPos {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        TransmissionCombPos::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("TransmissionCombPos"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("TransmissionCombPos"))
    }
}
// TransmissionStopIndicator
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum TransmissionStopIndicator {
    True,
}

impl TransmissionStopIndicator {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (idx, extended) = aper::decode::decode_enumerated(data, Some(0), Some(0), true)?;
        if extended {
            return Err(aper::AperCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| AperCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_enumerated(data, Some(0), Some(0), true, *self as i128, false)
    }
}

impl AperCodec for TransmissionStopIndicator {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        TransmissionStopIndicator::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("TransmissionStopIndicator"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("TransmissionStopIndicator"))
    }
}
// TransportUpLayerAddressInfoToAddList
#[derive(Clone, Debug)]
pub struct TransportUpLayerAddressInfoToAddList(pub Vec<TransportUpLayerAddressInfoToAddItem>);

impl TransportUpLayerAddressInfoToAddList {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        Ok(Self({
            let length = aper::decode::decode_length_determinent(data, Some(1), Some(16), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(TransportUpLayerAddressInfoToAddItem::decode(data)?);
            }
            items
        }))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_length_determinent(data, Some(1), Some(16), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl AperCodec for TransportUpLayerAddressInfoToAddList {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        TransportUpLayerAddressInfoToAddList::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("TransportUpLayerAddressInfoToAddList"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("TransportUpLayerAddressInfoToAddList"))
    }
}
// TransportUpLayerAddressInfoToAddItem
#[derive(Clone, Debug)]
pub struct TransportUpLayerAddressInfoToAddItem {
    pub ip_sec_transport_layer_address: TransportLayerAddress,
    pub gtp_transport_layer_address_to_add: Option<GtptlAs>,
}

impl TransportUpLayerAddressInfoToAddItem {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (optionals, _extensions_present) =
            aper::decode::decode_sequence_header(data, false, 2)?;
        let ip_sec_transport_layer_address = TransportLayerAddress::decode(data)?;
        let gtp_transport_layer_address_to_add = if optionals[0] {
            Some(GtptlAs::decode(data)?)
        } else {
            None
        };

        Ok(Self {
            ip_sec_transport_layer_address,
            gtp_transport_layer_address_to_add,
        })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(self.gtp_transport_layer_address_to_add.is_some());
        optionals.push(false);

        aper::encode::encode_sequence_header(data, false, &optionals, false)?;
        self.ip_sec_transport_layer_address.encode(data)?;
        if let Some(x) = &self.gtp_transport_layer_address_to_add {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl AperCodec for TransportUpLayerAddressInfoToAddItem {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        TransportUpLayerAddressInfoToAddItem::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("TransportUpLayerAddressInfoToAddItem"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("TransportUpLayerAddressInfoToAddItem"))
    }
}
// TransportUpLayerAddressInfoToRemoveList
#[derive(Clone, Debug)]
pub struct TransportUpLayerAddressInfoToRemoveList(
    pub Vec<TransportUpLayerAddressInfoToRemoveItem>,
);

impl TransportUpLayerAddressInfoToRemoveList {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        Ok(Self({
            let length = aper::decode::decode_length_determinent(data, Some(1), Some(16), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(TransportUpLayerAddressInfoToRemoveItem::decode(data)?);
            }
            items
        }))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_length_determinent(data, Some(1), Some(16), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl AperCodec for TransportUpLayerAddressInfoToRemoveList {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        TransportUpLayerAddressInfoToRemoveList::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("TransportUpLayerAddressInfoToRemoveList"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("TransportUpLayerAddressInfoToRemoveList"))
    }
}
// TransportUpLayerAddressInfoToRemoveItem
#[derive(Clone, Debug)]
pub struct TransportUpLayerAddressInfoToRemoveItem {
    pub ip_sec_transport_layer_address: TransportLayerAddress,
    pub gtp_transport_layer_address_to_remove: Option<GtptlAs>,
}

impl TransportUpLayerAddressInfoToRemoveItem {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (optionals, _extensions_present) =
            aper::decode::decode_sequence_header(data, false, 2)?;
        let ip_sec_transport_layer_address = TransportLayerAddress::decode(data)?;
        let gtp_transport_layer_address_to_remove = if optionals[0] {
            Some(GtptlAs::decode(data)?)
        } else {
            None
        };

        Ok(Self {
            ip_sec_transport_layer_address,
            gtp_transport_layer_address_to_remove,
        })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(self.gtp_transport_layer_address_to_remove.is_some());
        optionals.push(false);

        aper::encode::encode_sequence_header(data, false, &optionals, false)?;
        self.ip_sec_transport_layer_address.encode(data)?;
        if let Some(x) = &self.gtp_transport_layer_address_to_remove {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl AperCodec for TransportUpLayerAddressInfoToRemoveItem {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        TransportUpLayerAddressInfoToRemoveItem::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("TransportUpLayerAddressInfoToRemoveItem"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("TransportUpLayerAddressInfoToRemoveItem"))
    }
}
// TransmissionActionIndicator
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum TransmissionActionIndicator {
    Stop,
}

impl TransmissionActionIndicator {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (idx, extended) = aper::decode::decode_enumerated(data, Some(0), Some(0), true)?;
        if extended {
            return Err(aper::AperCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| AperCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_enumerated(data, Some(0), Some(0), true, *self as i128, false)
    }
}

impl AperCodec for TransmissionActionIndicator {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        TransmissionActionIndicator::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("TransmissionActionIndicator"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("TransmissionActionIndicator"))
    }
}
// Trpid
#[derive(Clone, Debug)]
pub struct Trpid(pub u16);

impl Trpid {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        Ok(Self(
            aper::decode::decode_integer(data, Some(0), Some(65535), true)?.0 as u16,
        ))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_integer(data, Some(0), Some(65535), true, self.0 as i128, false)
    }
}

impl AperCodec for Trpid {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        Trpid::decode_inner(data).map_err(|e: AperCodecError| e.push_context("Trpid"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("Trpid"))
    }
}
// TrpInformation
#[derive(Clone, Debug)]
pub struct TrpInformation {
    pub trpid: Trpid,
    pub trp_information_type_response_list: TrpInformationTypeResponseList,
}

impl TrpInformation {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (_optionals, _extensions_present) =
            aper::decode::decode_sequence_header(data, false, 1)?;
        let trpid = Trpid::decode(data)?;
        let trp_information_type_response_list = TrpInformationTypeResponseList::decode(data)?;

        Ok(Self {
            trpid,
            trp_information_type_response_list,
        })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(false);

        aper::encode::encode_sequence_header(data, false, &optionals, false)?;
        self.trpid.encode(data)?;
        self.trp_information_type_response_list.encode(data)?;

        Ok(())
    }
}

impl AperCodec for TrpInformation {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        TrpInformation::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("TrpInformation"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("TrpInformation"))
    }
}
// TrpInformationItem
#[derive(Clone, Debug)]
pub struct TrpInformationItem {
    pub trp_information: TrpInformation,
}

impl TrpInformationItem {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (_optionals, _extensions_present) =
            aper::decode::decode_sequence_header(data, false, 1)?;
        let trp_information = TrpInformation::decode(data)?;

        Ok(Self { trp_information })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(false);

        aper::encode::encode_sequence_header(data, false, &optionals, false)?;
        self.trp_information.encode(data)?;

        Ok(())
    }
}

impl AperCodec for TrpInformationItem {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        TrpInformationItem::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("TrpInformationItem"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("TrpInformationItem"))
    }
}
// TrpInformationTypeItem
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum TrpInformationTypeItem {
    NrPci,
    NgRanCgi,
    Arfcn,
    PrsConfig,
    SsbConfig,
    SfnInitTime,
    SpatialDirectInfo,
    GeoCoord,
}

impl TrpInformationTypeItem {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (idx, extended) = aper::decode::decode_enumerated(data, Some(0), Some(7), true)?;
        if extended {
            return Err(aper::AperCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| AperCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_enumerated(data, Some(0), Some(7), true, *self as i128, false)
    }
}

impl AperCodec for TrpInformationTypeItem {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        TrpInformationTypeItem::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("TrpInformationTypeItem"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("TrpInformationTypeItem"))
    }
}
// TrpInformationTypeResponseList
#[derive(Clone, Debug)]
pub struct TrpInformationTypeResponseList(pub Vec<TrpInformationTypeResponseItem>);

impl TrpInformationTypeResponseList {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        Ok(Self({
            let length = aper::decode::decode_length_determinent(data, Some(1), Some(64), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(TrpInformationTypeResponseItem::decode(data)?);
            }
            items
        }))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_length_determinent(data, Some(1), Some(64), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl AperCodec for TrpInformationTypeResponseList {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        TrpInformationTypeResponseList::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("TrpInformationTypeResponseList"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("TrpInformationTypeResponseList"))
    }
}
// TrpInformationTypeResponseItem
#[derive(Clone, Debug)]
pub enum TrpInformationTypeResponseItem {
    PciNr(Nrpci),
    NgRanCgi(Nrcgi),
    Nrarfcn(u32),
    PrsConfiguration(PrsConfiguration),
    SsBinformation(SsbInformation),
    SfnInitialisationTime(RelativeTime1900),
    SpatialDirectionInformation(SpatialDirectionInformation),
    GeographicalCoordinates(GeographicalCoordinates),
}

impl TrpInformationTypeResponseItem {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (idx, extended) = aper::decode::decode_choice_idx(data, 0, 8, false)?;
        if extended {
            return Err(aper::AperCodecError::new(
                "CHOICE additions not implemented",
            ));
        }
        match idx {
            0 => Ok(Self::PciNr(Nrpci::decode(data)?)),
            1 => Ok(Self::NgRanCgi(Nrcgi::decode(data)?)),
            2 => Ok(Self::Nrarfcn(
                aper::decode::decode_integer(data, Some(0), Some(3279165), false)?.0 as u32,
            )),
            3 => Ok(Self::PrsConfiguration(PrsConfiguration::decode(data)?)),
            4 => Ok(Self::SsBinformation(SsbInformation::decode(data)?)),
            5 => Ok(Self::SfnInitialisationTime(RelativeTime1900::decode(data)?)),
            6 => Ok(Self::SpatialDirectionInformation(
                SpatialDirectionInformation::decode(data)?,
            )),
            7 => Ok(Self::GeographicalCoordinates(
                GeographicalCoordinates::decode(data)?,
            )),
            8 => Err(AperCodecError::new(
                "Choice extension container not implemented",
            )),
            _ => Err(AperCodecError::new("Unknown choice idx")),
        }
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        match self {
            Self::PciNr(x) => {
                aper::encode::encode_choice_idx(data, 0, 8, false, 0, false)?;
                x.encode(data)
            }
            Self::NgRanCgi(x) => {
                aper::encode::encode_choice_idx(data, 0, 8, false, 1, false)?;
                x.encode(data)
            }
            Self::Nrarfcn(x) => {
                aper::encode::encode_choice_idx(data, 0, 8, false, 2, false)?;
                aper::encode::encode_integer(data, Some(0), Some(3279165), false, *x as i128, false)
            }
            Self::PrsConfiguration(x) => {
                aper::encode::encode_choice_idx(data, 0, 8, false, 3, false)?;
                x.encode(data)
            }
            Self::SsBinformation(x) => {
                aper::encode::encode_choice_idx(data, 0, 8, false, 4, false)?;
                x.encode(data)
            }
            Self::SfnInitialisationTime(x) => {
                aper::encode::encode_choice_idx(data, 0, 8, false, 5, false)?;
                x.encode(data)
            }
            Self::SpatialDirectionInformation(x) => {
                aper::encode::encode_choice_idx(data, 0, 8, false, 6, false)?;
                x.encode(data)
            }
            Self::GeographicalCoordinates(x) => {
                aper::encode::encode_choice_idx(data, 0, 8, false, 7, false)?;
                x.encode(data)
            }
        }
    }
}

impl AperCodec for TrpInformationTypeResponseItem {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        TrpInformationTypeResponseItem::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("TrpInformationTypeResponseItem"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("TrpInformationTypeResponseItem"))
    }
}
// TrpList
#[derive(Clone, Debug)]
pub struct TrpList(pub Vec<TrpListItem>);

impl TrpList {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        Ok(Self({
            let length =
                aper::decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(TrpListItem::decode(data)?);
            }
            items
        }))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_length_determinent(data, Some(1), Some(65535), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl AperCodec for TrpList {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        TrpList::decode_inner(data).map_err(|e: AperCodecError| e.push_context("TrpList"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("TrpList"))
    }
}
// TrpListItem
#[derive(Clone, Debug)]
pub struct TrpListItem {
    pub trpid: Trpid,
}

impl TrpListItem {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (_optionals, _extensions_present) =
            aper::decode::decode_sequence_header(data, false, 1)?;
        let trpid = Trpid::decode(data)?;

        Ok(Self { trpid })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(false);

        aper::encode::encode_sequence_header(data, false, &optionals, false)?;
        self.trpid.encode(data)?;

        Ok(())
    }
}

impl AperCodec for TrpListItem {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        TrpListItem::decode_inner(data).map_err(|e: AperCodecError| e.push_context("TrpListItem"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("TrpListItem"))
    }
}
// TrpMeasurementQuality
#[derive(Clone, Debug)]
pub struct TrpMeasurementQuality {
    pub tr_pmeasurement_quality_item: TrpMeasurementQualityItem,
}

impl TrpMeasurementQuality {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (_optionals, _extensions_present) =
            aper::decode::decode_sequence_header(data, false, 1)?;
        let tr_pmeasurement_quality_item = TrpMeasurementQualityItem::decode(data)?;

        Ok(Self {
            tr_pmeasurement_quality_item,
        })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(false);

        aper::encode::encode_sequence_header(data, false, &optionals, false)?;
        self.tr_pmeasurement_quality_item.encode(data)?;

        Ok(())
    }
}

impl AperCodec for TrpMeasurementQuality {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        TrpMeasurementQuality::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("TrpMeasurementQuality"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("TrpMeasurementQuality"))
    }
}
// TrpMeasurementQualityItem
#[derive(Clone, Debug)]
pub enum TrpMeasurementQualityItem {
    TimingMeasurementQuality(TimingMeasurementQuality),
    AngleMeasurementQuality(AngleMeasurementQuality),
}

impl TrpMeasurementQualityItem {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (idx, extended) = aper::decode::decode_choice_idx(data, 0, 2, false)?;
        if extended {
            return Err(aper::AperCodecError::new(
                "CHOICE additions not implemented",
            ));
        }
        match idx {
            0 => Ok(Self::TimingMeasurementQuality(
                TimingMeasurementQuality::decode(data)?,
            )),
            1 => Ok(Self::AngleMeasurementQuality(
                AngleMeasurementQuality::decode(data)?,
            )),
            2 => Err(AperCodecError::new(
                "Choice extension container not implemented",
            )),
            _ => Err(AperCodecError::new("Unknown choice idx")),
        }
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        match self {
            Self::TimingMeasurementQuality(x) => {
                aper::encode::encode_choice_idx(data, 0, 2, false, 0, false)?;
                x.encode(data)
            }
            Self::AngleMeasurementQuality(x) => {
                aper::encode::encode_choice_idx(data, 0, 2, false, 1, false)?;
                x.encode(data)
            }
        }
    }
}

impl AperCodec for TrpMeasurementQualityItem {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        TrpMeasurementQualityItem::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("TrpMeasurementQualityItem"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("TrpMeasurementQualityItem"))
    }
}
// TrpMeasurementRequestList
#[derive(Clone, Debug)]
pub struct TrpMeasurementRequestList(pub Vec<TrpMeasurementRequestItem>);

impl TrpMeasurementRequestList {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        Ok(Self({
            let length = aper::decode::decode_length_determinent(data, Some(1), Some(64), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(TrpMeasurementRequestItem::decode(data)?);
            }
            items
        }))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_length_determinent(data, Some(1), Some(64), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl AperCodec for TrpMeasurementRequestList {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        TrpMeasurementRequestList::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("TrpMeasurementRequestList"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("TrpMeasurementRequestList"))
    }
}
// TrpMeasurementRequestItem
#[derive(Clone, Debug)]
pub struct TrpMeasurementRequestItem {
    pub trpid: Trpid,
    pub search_window_information: Option<SearchWindowInformation>,
}

impl TrpMeasurementRequestItem {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (optionals, _extensions_present) =
            aper::decode::decode_sequence_header(data, false, 2)?;
        let trpid = Trpid::decode(data)?;
        let search_window_information = if optionals[0] {
            Some(SearchWindowInformation::decode(data)?)
        } else {
            None
        };

        Ok(Self {
            trpid,
            search_window_information,
        })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(self.search_window_information.is_some());
        optionals.push(false);

        aper::encode::encode_sequence_header(data, false, &optionals, false)?;
        self.trpid.encode(data)?;
        if let Some(x) = &self.search_window_information {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl AperCodec for TrpMeasurementRequestItem {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        TrpMeasurementRequestItem::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("TrpMeasurementRequestItem"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("TrpMeasurementRequestItem"))
    }
}
// TrpPositionDefinitionType
#[derive(Clone, Debug)]
pub enum TrpPositionDefinitionType {
    Direct(TrpPositionDirect),
    Referenced(TrpPositionReferenced),
}

impl TrpPositionDefinitionType {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (idx, extended) = aper::decode::decode_choice_idx(data, 0, 2, false)?;
        if extended {
            return Err(aper::AperCodecError::new(
                "CHOICE additions not implemented",
            ));
        }
        match idx {
            0 => Ok(Self::Direct(TrpPositionDirect::decode(data)?)),
            1 => Ok(Self::Referenced(TrpPositionReferenced::decode(data)?)),
            2 => Err(AperCodecError::new(
                "Choice extension container not implemented",
            )),
            _ => Err(AperCodecError::new("Unknown choice idx")),
        }
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        match self {
            Self::Direct(x) => {
                aper::encode::encode_choice_idx(data, 0, 2, false, 0, false)?;
                x.encode(data)
            }
            Self::Referenced(x) => {
                aper::encode::encode_choice_idx(data, 0, 2, false, 1, false)?;
                x.encode(data)
            }
        }
    }
}

impl AperCodec for TrpPositionDefinitionType {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        TrpPositionDefinitionType::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("TrpPositionDefinitionType"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("TrpPositionDefinitionType"))
    }
}
// TrpPositionDirect
#[derive(Clone, Debug)]
pub struct TrpPositionDirect {
    pub accuracy: TrpPositionDirectAccuracy,
}

impl TrpPositionDirect {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (_optionals, _extensions_present) =
            aper::decode::decode_sequence_header(data, false, 1)?;
        let accuracy = TrpPositionDirectAccuracy::decode(data)?;

        Ok(Self { accuracy })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(false);

        aper::encode::encode_sequence_header(data, false, &optionals, false)?;
        self.accuracy.encode(data)?;

        Ok(())
    }
}

impl AperCodec for TrpPositionDirect {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        TrpPositionDirect::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("TrpPositionDirect"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("TrpPositionDirect"))
    }
}
// TrpPositionDirectAccuracy
#[derive(Clone, Debug)]
pub enum TrpPositionDirectAccuracy {
    TrpPosition(AccessPointPosition),
    TrphAposition(NgranHighAccuracyAccessPointPosition),
}

impl TrpPositionDirectAccuracy {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (idx, extended) = aper::decode::decode_choice_idx(data, 0, 2, false)?;
        if extended {
            return Err(aper::AperCodecError::new(
                "CHOICE additions not implemented",
            ));
        }
        match idx {
            0 => Ok(Self::TrpPosition(AccessPointPosition::decode(data)?)),
            1 => Ok(Self::TrphAposition(
                NgranHighAccuracyAccessPointPosition::decode(data)?,
            )),
            2 => Err(AperCodecError::new(
                "Choice extension container not implemented",
            )),
            _ => Err(AperCodecError::new("Unknown choice idx")),
        }
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        match self {
            Self::TrpPosition(x) => {
                aper::encode::encode_choice_idx(data, 0, 2, false, 0, false)?;
                x.encode(data)
            }
            Self::TrphAposition(x) => {
                aper::encode::encode_choice_idx(data, 0, 2, false, 1, false)?;
                x.encode(data)
            }
        }
    }
}

impl AperCodec for TrpPositionDirectAccuracy {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        TrpPositionDirectAccuracy::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("TrpPositionDirectAccuracy"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("TrpPositionDirectAccuracy"))
    }
}
// TrpPositionReferenced
#[derive(Clone, Debug)]
pub struct TrpPositionReferenced {
    pub reference_point: ReferencePoint,
    pub reference_point_type: TrpReferencePointType,
}

impl TrpPositionReferenced {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (_optionals, _extensions_present) =
            aper::decode::decode_sequence_header(data, false, 1)?;
        let reference_point = ReferencePoint::decode(data)?;
        let reference_point_type = TrpReferencePointType::decode(data)?;

        Ok(Self {
            reference_point,
            reference_point_type,
        })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(false);

        aper::encode::encode_sequence_header(data, false, &optionals, false)?;
        self.reference_point.encode(data)?;
        self.reference_point_type.encode(data)?;

        Ok(())
    }
}

impl AperCodec for TrpPositionReferenced {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        TrpPositionReferenced::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("TrpPositionReferenced"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("TrpPositionReferenced"))
    }
}
// TrpReferencePointType
#[derive(Clone, Debug)]
pub enum TrpReferencePointType {
    TrpPositionRelativeGeodetic(RelativeGeodeticLocation),
    TrpPositionRelativeCartesian(RelativeCartesianLocation),
}

impl TrpReferencePointType {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (idx, extended) = aper::decode::decode_choice_idx(data, 0, 2, false)?;
        if extended {
            return Err(aper::AperCodecError::new(
                "CHOICE additions not implemented",
            ));
        }
        match idx {
            0 => Ok(Self::TrpPositionRelativeGeodetic(
                RelativeGeodeticLocation::decode(data)?,
            )),
            1 => Ok(Self::TrpPositionRelativeCartesian(
                RelativeCartesianLocation::decode(data)?,
            )),
            2 => Err(AperCodecError::new(
                "Choice extension container not implemented",
            )),
            _ => Err(AperCodecError::new("Unknown choice idx")),
        }
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        match self {
            Self::TrpPositionRelativeGeodetic(x) => {
                aper::encode::encode_choice_idx(data, 0, 2, false, 0, false)?;
                x.encode(data)
            }
            Self::TrpPositionRelativeCartesian(x) => {
                aper::encode::encode_choice_idx(data, 0, 2, false, 1, false)?;
                x.encode(data)
            }
        }
    }
}

impl AperCodec for TrpReferencePointType {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        TrpReferencePointType::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("TrpReferencePointType"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("TrpReferencePointType"))
    }
}
// TypeOfError
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum TypeOfError {
    NotUnderstood,
    Missing,
}

impl TypeOfError {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (idx, extended) = aper::decode::decode_enumerated(data, Some(0), Some(1), true)?;
        if extended {
            return Err(aper::AperCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| AperCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_enumerated(data, Some(0), Some(1), true, *self as i128, false)
    }
}

impl AperCodec for TypeOfError {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        TypeOfError::decode_inner(data).map_err(|e: AperCodecError| e.push_context("TypeOfError"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("TypeOfError"))
    }
}
// TransportLayerAddressInfo
#[derive(Clone, Debug)]
pub struct TransportLayerAddressInfo {
    pub transport_up_layer_address_info_to_add_list: Option<TransportUpLayerAddressInfoToAddList>,
    pub transport_up_layer_address_info_to_remove_list:
        Option<TransportUpLayerAddressInfoToRemoveList>,
}

impl TransportLayerAddressInfo {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (optionals, _extensions_present) =
            aper::decode::decode_sequence_header(data, false, 3)?;
        let transport_up_layer_address_info_to_add_list = if optionals[0] {
            Some(TransportUpLayerAddressInfoToAddList::decode(data)?)
        } else {
            None
        };
        let transport_up_layer_address_info_to_remove_list = if optionals[1] {
            Some(TransportUpLayerAddressInfoToRemoveList::decode(data)?)
        } else {
            None
        };

        Ok(Self {
            transport_up_layer_address_info_to_add_list,
            transport_up_layer_address_info_to_remove_list,
        })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(self.transport_up_layer_address_info_to_add_list.is_some());
        optionals.push(
            self.transport_up_layer_address_info_to_remove_list
                .is_some(),
        );
        optionals.push(false);

        aper::encode::encode_sequence_header(data, false, &optionals, false)?;
        if let Some(x) = &self.transport_up_layer_address_info_to_add_list {
            x.encode(data)?;
        }
        if let Some(x) = &self.transport_up_layer_address_info_to_remove_list {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl AperCodec for TransportLayerAddressInfo {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        TransportLayerAddressInfo::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("TransportLayerAddressInfo"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("TransportLayerAddressInfo"))
    }
}
// TscAssistanceInformation
#[derive(Clone, Debug)]
pub struct TscAssistanceInformation {
    pub periodicity: Periodicity,
    pub burst_arrival_time: Option<BurstArrivalTime>,
}

impl TscAssistanceInformation {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (optionals, _extensions_present) = aper::decode::decode_sequence_header(data, true, 2)?;
        let periodicity = Periodicity::decode(data)?;
        let burst_arrival_time = if optionals[0] {
            Some(BurstArrivalTime::decode(data)?)
        } else {
            None
        };

        Ok(Self {
            periodicity,
            burst_arrival_time,
        })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(self.burst_arrival_time.is_some());
        optionals.push(false);

        aper::encode::encode_sequence_header(data, true, &optionals, false)?;
        self.periodicity.encode(data)?;
        if let Some(x) = &self.burst_arrival_time {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl AperCodec for TscAssistanceInformation {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        TscAssistanceInformation::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("TscAssistanceInformation"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("TscAssistanceInformation"))
    }
}
// TscTrafficCharacteristics
#[derive(Clone, Debug)]
pub struct TscTrafficCharacteristics {
    pub tsc_assistance_information_dl: Option<TscAssistanceInformation>,
    pub tsc_assistance_information_ul: Option<TscAssistanceInformation>,
}

impl TscTrafficCharacteristics {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (optionals, _extensions_present) = aper::decode::decode_sequence_header(data, true, 3)?;
        let tsc_assistance_information_dl = if optionals[0] {
            Some(TscAssistanceInformation::decode(data)?)
        } else {
            None
        };
        let tsc_assistance_information_ul = if optionals[1] {
            Some(TscAssistanceInformation::decode(data)?)
        } else {
            None
        };

        Ok(Self {
            tsc_assistance_information_dl,
            tsc_assistance_information_ul,
        })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(self.tsc_assistance_information_dl.is_some());
        optionals.push(self.tsc_assistance_information_ul.is_some());
        optionals.push(false);

        aper::encode::encode_sequence_header(data, true, &optionals, false)?;
        if let Some(x) = &self.tsc_assistance_information_dl {
            x.encode(data)?;
        }
        if let Some(x) = &self.tsc_assistance_information_ul {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl AperCodec for TscTrafficCharacteristics {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        TscTrafficCharacteristics::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("TscTrafficCharacteristics"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("TscTrafficCharacteristics"))
    }
}
// UacAssistanceInfo
#[derive(Clone, Debug)]
pub struct UacAssistanceInfo {
    pub uac_plmn_list: UacPlmnList,
}

impl UacAssistanceInfo {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (_optionals, _extensions_present) =
            aper::decode::decode_sequence_header(data, false, 1)?;
        let uac_plmn_list = UacPlmnList::decode(data)?;

        Ok(Self { uac_plmn_list })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(false);

        aper::encode::encode_sequence_header(data, false, &optionals, false)?;
        self.uac_plmn_list.encode(data)?;

        Ok(())
    }
}

impl AperCodec for UacAssistanceInfo {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        UacAssistanceInfo::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("UacAssistanceInfo"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("UacAssistanceInfo"))
    }
}
// UacPlmnList
#[derive(Clone, Debug)]
pub struct UacPlmnList(pub Vec<UacPlmnItem>);

impl UacPlmnList {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        Ok(Self({
            let length = aper::decode::decode_length_determinent(data, Some(1), Some(12), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(UacPlmnItem::decode(data)?);
            }
            items
        }))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_length_determinent(data, Some(1), Some(12), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl AperCodec for UacPlmnList {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        UacPlmnList::decode_inner(data).map_err(|e: AperCodecError| e.push_context("UacPlmnList"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("UacPlmnList"))
    }
}
// UacPlmnItem
#[derive(Clone, Debug)]
pub struct UacPlmnItem {
    pub plmn_identity: PlmnIdentity,
    pub uac_type_list: UacTypeList,
}

impl UacPlmnItem {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (_optionals, _extensions_present) =
            aper::decode::decode_sequence_header(data, false, 1)?;
        let plmn_identity = PlmnIdentity::decode(data)?;
        let uac_type_list = UacTypeList::decode(data)?;

        Ok(Self {
            plmn_identity,
            uac_type_list,
        })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(false);

        aper::encode::encode_sequence_header(data, false, &optionals, false)?;
        self.plmn_identity.encode(data)?;
        self.uac_type_list.encode(data)?;

        Ok(())
    }
}

impl AperCodec for UacPlmnItem {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        UacPlmnItem::decode_inner(data).map_err(|e: AperCodecError| e.push_context("UacPlmnItem"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("UacPlmnItem"))
    }
}
// UacTypeList
#[derive(Clone, Debug)]
pub struct UacTypeList(pub Vec<UacTypeItem>);

impl UacTypeList {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        Ok(Self({
            let length = aper::decode::decode_length_determinent(data, Some(1), Some(64), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(UacTypeItem::decode(data)?);
            }
            items
        }))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_length_determinent(data, Some(1), Some(64), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl AperCodec for UacTypeList {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        UacTypeList::decode_inner(data).map_err(|e: AperCodecError| e.push_context("UacTypeList"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("UacTypeList"))
    }
}
// UacTypeItem
#[derive(Clone, Debug)]
pub struct UacTypeItem {
    pub uac_reduction_indication: UacReductionIndication,
    pub uac_category_type: UacCategoryType,
}

impl UacTypeItem {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (_optionals, _extensions_present) =
            aper::decode::decode_sequence_header(data, false, 1)?;
        let uac_reduction_indication = UacReductionIndication::decode(data)?;
        let uac_category_type = UacCategoryType::decode(data)?;

        Ok(Self {
            uac_reduction_indication,
            uac_category_type,
        })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(false);

        aper::encode::encode_sequence_header(data, false, &optionals, false)?;
        self.uac_reduction_indication.encode(data)?;
        self.uac_category_type.encode(data)?;

        Ok(())
    }
}

impl AperCodec for UacTypeItem {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        UacTypeItem::decode_inner(data).map_err(|e: AperCodecError| e.push_context("UacTypeItem"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("UacTypeItem"))
    }
}
// UacCategoryType
#[derive(Clone, Debug)]
pub enum UacCategoryType {
    UaCstandardized(UacAction),
    UacOperatorDefined(UacOperatorDefined),
}

impl UacCategoryType {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (idx, extended) = aper::decode::decode_choice_idx(data, 0, 2, false)?;
        if extended {
            return Err(aper::AperCodecError::new(
                "CHOICE additions not implemented",
            ));
        }
        match idx {
            0 => Ok(Self::UaCstandardized(UacAction::decode(data)?)),
            1 => Ok(Self::UacOperatorDefined(UacOperatorDefined::decode(data)?)),
            2 => Err(AperCodecError::new(
                "Choice extension container not implemented",
            )),
            _ => Err(AperCodecError::new("Unknown choice idx")),
        }
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        match self {
            Self::UaCstandardized(x) => {
                aper::encode::encode_choice_idx(data, 0, 2, false, 0, false)?;
                x.encode(data)
            }
            Self::UacOperatorDefined(x) => {
                aper::encode::encode_choice_idx(data, 0, 2, false, 1, false)?;
                x.encode(data)
            }
        }
    }
}

impl AperCodec for UacCategoryType {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        UacCategoryType::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("UacCategoryType"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("UacCategoryType"))
    }
}
// UacOperatorDefined
#[derive(Clone, Debug)]
pub struct UacOperatorDefined {
    pub access_category: u8,
    pub access_identity: BitString,
}

impl UacOperatorDefined {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (_optionals, _extensions_present) =
            aper::decode::decode_sequence_header(data, false, 1)?;
        let access_category = aper::decode::decode_integer(data, Some(32), Some(63), true)?.0 as u8;
        let access_identity = aper::decode::decode_bitstring(data, Some(7), Some(7), false)?;

        Ok(Self {
            access_category,
            access_identity,
        })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(false);

        aper::encode::encode_sequence_header(data, false, &optionals, false)?;
        aper::encode::encode_integer(
            data,
            Some(32),
            Some(63),
            true,
            self.access_category as i128,
            false,
        )?;
        aper::encode::encode_bitstring(
            data,
            Some(7),
            Some(7),
            false,
            &self.access_identity,
            false,
        )?;

        Ok(())
    }
}

impl AperCodec for UacOperatorDefined {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        UacOperatorDefined::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("UacOperatorDefined"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("UacOperatorDefined"))
    }
}
// UacAction
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum UacAction {
    RejectNonEmergencyMoDt,
    RejectRrcCrSignalling,
    PermitEmergencySessionsAndMobileTerminatedServicesOnly,
    PermitHighPrioritySessionsAndMobileTerminatedServicesOnly,
}

impl UacAction {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (idx, extended) = aper::decode::decode_enumerated(data, Some(0), Some(3), true)?;
        if extended {
            return Err(aper::AperCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| AperCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_enumerated(data, Some(0), Some(3), true, *self as i128, false)
    }
}

impl AperCodec for UacAction {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        UacAction::decode_inner(data).map_err(|e: AperCodecError| e.push_context("UacAction"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("UacAction"))
    }
}
// UacReductionIndication
#[derive(Clone, Debug)]
pub struct UacReductionIndication(pub u8);

impl UacReductionIndication {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        Ok(Self(
            aper::decode::decode_integer(data, Some(0), Some(100), false)?.0 as u8,
        ))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_integer(data, Some(0), Some(100), false, self.0 as i128, false)
    }
}

impl AperCodec for UacReductionIndication {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        UacReductionIndication::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("UacReductionIndication"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("UacReductionIndication"))
    }
}
// UeAssociatedLogicalF1ConnectionItem
#[derive(Clone, Debug)]
pub struct UeAssociatedLogicalF1ConnectionItem {
    pub gnb_cu_ue_f1ap_id: Option<GnbCuUeF1apId>,
    pub gnb_du_ue_f1ap_id: Option<GnbDuUeF1apId>,
}

impl UeAssociatedLogicalF1ConnectionItem {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (optionals, _extensions_present) = aper::decode::decode_sequence_header(data, true, 3)?;
        let gnb_cu_ue_f1ap_id = if optionals[0] {
            Some(GnbCuUeF1apId::decode(data)?)
        } else {
            None
        };
        let gnb_du_ue_f1ap_id = if optionals[1] {
            Some(GnbDuUeF1apId::decode(data)?)
        } else {
            None
        };

        Ok(Self {
            gnb_cu_ue_f1ap_id,
            gnb_du_ue_f1ap_id,
        })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(self.gnb_cu_ue_f1ap_id.is_some());
        optionals.push(self.gnb_du_ue_f1ap_id.is_some());
        optionals.push(false);

        aper::encode::encode_sequence_header(data, true, &optionals, false)?;
        if let Some(x) = &self.gnb_cu_ue_f1ap_id {
            x.encode(data)?;
        }
        if let Some(x) = &self.gnb_du_ue_f1ap_id {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl AperCodec for UeAssociatedLogicalF1ConnectionItem {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        UeAssociatedLogicalF1ConnectionItem::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("UeAssociatedLogicalF1ConnectionItem"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("UeAssociatedLogicalF1ConnectionItem"))
    }
}
// UeAssistanceInformation
#[derive(Clone, Debug)]
pub struct UeAssistanceInformation(pub Vec<u8>);

impl UeAssistanceInformation {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        Ok(Self(aper::decode::decode_octetstring(
            data, None, None, false,
        )?))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_octetstring(data, None, None, false, &self.0, false)
    }
}

impl AperCodec for UeAssistanceInformation {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        UeAssistanceInformation::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("UeAssistanceInformation"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("UeAssistanceInformation"))
    }
}
// UeAssistanceInformationEutra
#[derive(Clone, Debug)]
pub struct UeAssistanceInformationEutra(pub Vec<u8>);

impl UeAssistanceInformationEutra {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        Ok(Self(aper::decode::decode_octetstring(
            data, None, None, false,
        )?))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_octetstring(data, None, None, false, &self.0, false)
    }
}

impl AperCodec for UeAssistanceInformationEutra {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        UeAssistanceInformationEutra::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("UeAssistanceInformationEutra"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("UeAssistanceInformationEutra"))
    }
}
// UeCapabilityRatContainerList
#[derive(Clone, Debug)]
pub struct UeCapabilityRatContainerList(pub Vec<u8>);

impl UeCapabilityRatContainerList {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        Ok(Self(aper::decode::decode_octetstring(
            data, None, None, false,
        )?))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_octetstring(data, None, None, false, &self.0, false)
    }
}

impl AperCodec for UeCapabilityRatContainerList {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        UeCapabilityRatContainerList::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("UeCapabilityRatContainerList"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("UeCapabilityRatContainerList"))
    }
}
// UeContextNotRetrievable
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum UeContextNotRetrievable {
    True,
}

impl UeContextNotRetrievable {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (idx, extended) = aper::decode::decode_enumerated(data, Some(0), Some(0), true)?;
        if extended {
            return Err(aper::AperCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| AperCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_enumerated(data, Some(0), Some(0), true, *self as i128, false)
    }
}

impl AperCodec for UeContextNotRetrievable {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        UeContextNotRetrievable::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("UeContextNotRetrievable"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("UeContextNotRetrievable"))
    }
}
// UeIdentityIndexValue
#[derive(Clone, Debug)]
pub enum UeIdentityIndexValue {
    IndexLength10(BitString),
}

impl UeIdentityIndexValue {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (idx, extended) = aper::decode::decode_choice_idx(data, 0, 1, false)?;
        if extended {
            return Err(aper::AperCodecError::new(
                "CHOICE additions not implemented",
            ));
        }
        match idx {
            0 => Ok(Self::IndexLength10(aper::decode::decode_bitstring(
                data,
                Some(10),
                Some(10),
                false,
            )?)),
            1 => Err(AperCodecError::new(
                "Choice extension container not implemented",
            )),
            _ => Err(AperCodecError::new("Unknown choice idx")),
        }
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        match self {
            Self::IndexLength10(x) => {
                aper::encode::encode_choice_idx(data, 0, 1, false, 0, false)?;
                aper::encode::encode_bitstring(data, Some(10), Some(10), false, &x, false)
            }
        }
    }
}

impl AperCodec for UeIdentityIndexValue {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        UeIdentityIndexValue::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("UeIdentityIndexValue"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("UeIdentityIndexValue"))
    }
}
// UlAoA
#[derive(Clone, Debug)]
pub struct UlAoA {
    pub azimuth_ao_a: u16,
    pub zenith_ao_a: Option<u16>,
    pub lcs_to_gcs_translation_ao_a: Option<LcsToGcsTranslationAoA>,
}

impl UlAoA {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (optionals, _extensions_present) =
            aper::decode::decode_sequence_header(data, false, 3)?;
        let azimuth_ao_a = aper::decode::decode_integer(data, Some(0), Some(3599), false)?.0 as u16;
        let zenith_ao_a = if optionals[0] {
            Some(aper::decode::decode_integer(data, Some(0), Some(1799), false)?.0 as u16)
        } else {
            None
        };
        let lcs_to_gcs_translation_ao_a = if optionals[1] {
            Some(LcsToGcsTranslationAoA::decode(data)?)
        } else {
            None
        };

        Ok(Self {
            azimuth_ao_a,
            zenith_ao_a,
            lcs_to_gcs_translation_ao_a,
        })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(self.zenith_ao_a.is_some());
        optionals.push(self.lcs_to_gcs_translation_ao_a.is_some());
        optionals.push(false);

        aper::encode::encode_sequence_header(data, false, &optionals, false)?;
        aper::encode::encode_integer(
            data,
            Some(0),
            Some(3599),
            false,
            self.azimuth_ao_a as i128,
            false,
        )?;
        if let Some(x) = &self.zenith_ao_a {
            aper::encode::encode_integer(data, Some(0), Some(1799), false, *x as i128, false)?;
        }
        if let Some(x) = &self.lcs_to_gcs_translation_ao_a {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl AperCodec for UlAoA {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        UlAoA::decode_inner(data).map_err(|e: AperCodecError| e.push_context("UlAoA"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("UlAoA"))
    }
}
// UlBhNonUpTrafficMapping
#[derive(Clone, Debug)]
pub struct UlBhNonUpTrafficMapping {
    pub ul_bh_non_up_traffic_mapping_list: UlBhNonUpTrafficMappingList,
}

impl UlBhNonUpTrafficMapping {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (_optionals, _extensions_present) =
            aper::decode::decode_sequence_header(data, false, 1)?;
        let ul_bh_non_up_traffic_mapping_list = UlBhNonUpTrafficMappingList::decode(data)?;

        Ok(Self {
            ul_bh_non_up_traffic_mapping_list,
        })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(false);

        aper::encode::encode_sequence_header(data, false, &optionals, false)?;
        self.ul_bh_non_up_traffic_mapping_list.encode(data)?;

        Ok(())
    }
}

impl AperCodec for UlBhNonUpTrafficMapping {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        UlBhNonUpTrafficMapping::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("UlBhNonUpTrafficMapping"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("UlBhNonUpTrafficMapping"))
    }
}
// UlBhNonUpTrafficMappingList
#[derive(Clone, Debug)]
pub struct UlBhNonUpTrafficMappingList(pub Vec<UlBhNonUpTrafficMappingItem>);

impl UlBhNonUpTrafficMappingList {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        Ok(Self({
            let length = aper::decode::decode_length_determinent(data, Some(1), Some(32), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(UlBhNonUpTrafficMappingItem::decode(data)?);
            }
            items
        }))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_length_determinent(data, Some(1), Some(32), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl AperCodec for UlBhNonUpTrafficMappingList {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        UlBhNonUpTrafficMappingList::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("UlBhNonUpTrafficMappingList"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("UlBhNonUpTrafficMappingList"))
    }
}
// UlBhNonUpTrafficMappingItem
#[derive(Clone, Debug)]
pub struct UlBhNonUpTrafficMappingItem {
    pub non_up_traffic_type: NonUpTrafficType,
    pub bh_info: BhInfo,
}

impl UlBhNonUpTrafficMappingItem {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (_optionals, _extensions_present) =
            aper::decode::decode_sequence_header(data, false, 1)?;
        let non_up_traffic_type = NonUpTrafficType::decode(data)?;
        let bh_info = BhInfo::decode(data)?;

        Ok(Self {
            non_up_traffic_type,
            bh_info,
        })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(false);

        aper::encode::encode_sequence_header(data, false, &optionals, false)?;
        self.non_up_traffic_type.encode(data)?;
        self.bh_info.encode(data)?;

        Ok(())
    }
}

impl AperCodec for UlBhNonUpTrafficMappingItem {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        UlBhNonUpTrafficMappingItem::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("UlBhNonUpTrafficMappingItem"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("UlBhNonUpTrafficMappingItem"))
    }
}
// UlConfiguration
#[derive(Clone, Debug)]
pub struct UlConfiguration {
    pub ulue_configuration: UlueConfiguration,
}

impl UlConfiguration {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (_optionals, _extensions_present) =
            aper::decode::decode_sequence_header(data, true, 1)?;
        let ulue_configuration = UlueConfiguration::decode(data)?;

        Ok(Self { ulue_configuration })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(false);

        aper::encode::encode_sequence_header(data, true, &optionals, false)?;
        self.ulue_configuration.encode(data)?;

        Ok(())
    }
}

impl AperCodec for UlConfiguration {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        UlConfiguration::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("UlConfiguration"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("UlConfiguration"))
    }
}
// UlRtoaMeasurement
#[derive(Clone, Debug)]
pub struct UlRtoaMeasurement {
    pub ul_rtoa_measurement_item: UlRtoaMeasurementItem,
    pub additional_path_list: Option<AdditionalPathList>,
}

impl UlRtoaMeasurement {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (optionals, _extensions_present) =
            aper::decode::decode_sequence_header(data, false, 2)?;
        let ul_rtoa_measurement_item = UlRtoaMeasurementItem::decode(data)?;
        let additional_path_list = if optionals[0] {
            Some(AdditionalPathList::decode(data)?)
        } else {
            None
        };

        Ok(Self {
            ul_rtoa_measurement_item,
            additional_path_list,
        })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(self.additional_path_list.is_some());
        optionals.push(false);

        aper::encode::encode_sequence_header(data, false, &optionals, false)?;
        self.ul_rtoa_measurement_item.encode(data)?;
        if let Some(x) = &self.additional_path_list {
            x.encode(data)?;
        }

        Ok(())
    }
}

impl AperCodec for UlRtoaMeasurement {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        UlRtoaMeasurement::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("UlRtoaMeasurement"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("UlRtoaMeasurement"))
    }
}
// UlRtoaMeasurementItem
#[derive(Clone, Debug)]
pub enum UlRtoaMeasurementItem {
    K0(u32),
    K1(u32),
    K2(u32),
    K3(u32),
    K4(u32),
    K5(u16),
}

impl UlRtoaMeasurementItem {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (idx, extended) = aper::decode::decode_choice_idx(data, 0, 6, false)?;
        if extended {
            return Err(aper::AperCodecError::new(
                "CHOICE additions not implemented",
            ));
        }
        match idx {
            0 => Ok(Self::K0(
                aper::decode::decode_integer(data, Some(0), Some(1970049), false)?.0 as u32,
            )),
            1 => Ok(Self::K1(
                aper::decode::decode_integer(data, Some(0), Some(985025), false)?.0 as u32,
            )),
            2 => Ok(Self::K2(
                aper::decode::decode_integer(data, Some(0), Some(492513), false)?.0 as u32,
            )),
            3 => Ok(Self::K3(
                aper::decode::decode_integer(data, Some(0), Some(246257), false)?.0 as u32,
            )),
            4 => Ok(Self::K4(
                aper::decode::decode_integer(data, Some(0), Some(123129), false)?.0 as u32,
            )),
            5 => Ok(Self::K5(
                aper::decode::decode_integer(data, Some(0), Some(61565), false)?.0 as u16,
            )),
            6 => Err(AperCodecError::new(
                "Choice extension container not implemented",
            )),
            _ => Err(AperCodecError::new("Unknown choice idx")),
        }
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        match self {
            Self::K0(x) => {
                aper::encode::encode_choice_idx(data, 0, 6, false, 0, false)?;
                aper::encode::encode_integer(data, Some(0), Some(1970049), false, *x as i128, false)
            }
            Self::K1(x) => {
                aper::encode::encode_choice_idx(data, 0, 6, false, 1, false)?;
                aper::encode::encode_integer(data, Some(0), Some(985025), false, *x as i128, false)
            }
            Self::K2(x) => {
                aper::encode::encode_choice_idx(data, 0, 6, false, 2, false)?;
                aper::encode::encode_integer(data, Some(0), Some(492513), false, *x as i128, false)
            }
            Self::K3(x) => {
                aper::encode::encode_choice_idx(data, 0, 6, false, 3, false)?;
                aper::encode::encode_integer(data, Some(0), Some(246257), false, *x as i128, false)
            }
            Self::K4(x) => {
                aper::encode::encode_choice_idx(data, 0, 6, false, 4, false)?;
                aper::encode::encode_integer(data, Some(0), Some(123129), false, *x as i128, false)
            }
            Self::K5(x) => {
                aper::encode::encode_choice_idx(data, 0, 6, false, 5, false)?;
                aper::encode::encode_integer(data, Some(0), Some(61565), false, *x as i128, false)
            }
        }
    }
}

impl AperCodec for UlRtoaMeasurementItem {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        UlRtoaMeasurementItem::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("UlRtoaMeasurementItem"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("UlRtoaMeasurementItem"))
    }
}
// UlSrsRsrp
#[derive(Clone, Debug)]
pub struct UlSrsRsrp(pub u8);

impl UlSrsRsrp {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        Ok(Self(
            aper::decode::decode_integer(data, Some(0), Some(126), false)?.0 as u8,
        ))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_integer(data, Some(0), Some(126), false, self.0 as i128, false)
    }
}

impl AperCodec for UlSrsRsrp {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        UlSrsRsrp::decode_inner(data).map_err(|e: AperCodecError| e.push_context("UlSrsRsrp"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("UlSrsRsrp"))
    }
}
// UlueConfiguration
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum UlueConfiguration {
    NoData,
    Shared,
    Only,
}

impl UlueConfiguration {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (idx, extended) = aper::decode::decode_enumerated(data, Some(0), Some(2), true)?;
        if extended {
            return Err(aper::AperCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| AperCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_enumerated(data, Some(0), Some(2), true, *self as i128, false)
    }
}

impl AperCodec for UlueConfiguration {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        UlueConfiguration::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("UlueConfiguration"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("UlueConfiguration"))
    }
}
// UlUpTnlInformationToUpdateListItem
#[derive(Clone, Debug)]
pub struct UlUpTnlInformationToUpdateListItem {
    pub uluptnl_information: UpTransportLayerInformation,
    pub new_uluptnl_information: Option<UpTransportLayerInformation>,
    pub bh_info: BhInfo,
}

impl UlUpTnlInformationToUpdateListItem {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (optionals, _extensions_present) = aper::decode::decode_sequence_header(data, true, 2)?;
        let uluptnl_information = UpTransportLayerInformation::decode(data)?;
        let new_uluptnl_information = if optionals[0] {
            Some(UpTransportLayerInformation::decode(data)?)
        } else {
            None
        };
        let bh_info = BhInfo::decode(data)?;

        Ok(Self {
            uluptnl_information,
            new_uluptnl_information,
            bh_info,
        })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(self.new_uluptnl_information.is_some());
        optionals.push(false);

        aper::encode::encode_sequence_header(data, true, &optionals, false)?;
        self.uluptnl_information.encode(data)?;
        if let Some(x) = &self.new_uluptnl_information {
            x.encode(data)?;
        }
        self.bh_info.encode(data)?;

        Ok(())
    }
}

impl AperCodec for UlUpTnlInformationToUpdateListItem {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        UlUpTnlInformationToUpdateListItem::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("UlUpTnlInformationToUpdateListItem"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("UlUpTnlInformationToUpdateListItem"))
    }
}
// UlUpTnlAddressToUpdateListItem
#[derive(Clone, Debug)]
pub struct UlUpTnlAddressToUpdateListItem {
    pub old_ip_adress: TransportLayerAddress,
    pub new_ip_adress: TransportLayerAddress,
}

impl UlUpTnlAddressToUpdateListItem {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (_optionals, _extensions_present) =
            aper::decode::decode_sequence_header(data, true, 1)?;
        let old_ip_adress = TransportLayerAddress::decode(data)?;
        let new_ip_adress = TransportLayerAddress::decode(data)?;

        Ok(Self {
            old_ip_adress,
            new_ip_adress,
        })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(false);

        aper::encode::encode_sequence_header(data, true, &optionals, false)?;
        self.old_ip_adress.encode(data)?;
        self.new_ip_adress.encode(data)?;

        Ok(())
    }
}

impl AperCodec for UlUpTnlAddressToUpdateListItem {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        UlUpTnlAddressToUpdateListItem::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("UlUpTnlAddressToUpdateListItem"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("UlUpTnlAddressToUpdateListItem"))
    }
}
// UluptnlInformationToBeSetupList
#[derive(Clone, Debug)]
pub struct UluptnlInformationToBeSetupList(pub Vec<UluptnlInformationToBeSetupItem>);

impl UluptnlInformationToBeSetupList {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        Ok(Self({
            let length = aper::decode::decode_length_determinent(data, Some(1), Some(2), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(UluptnlInformationToBeSetupItem::decode(data)?);
            }
            items
        }))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_length_determinent(data, Some(1), Some(2), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl AperCodec for UluptnlInformationToBeSetupList {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        UluptnlInformationToBeSetupList::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("UluptnlInformationToBeSetupList"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("UluptnlInformationToBeSetupList"))
    }
}
// UluptnlInformationToBeSetupItem
#[derive(Clone, Debug)]
pub struct UluptnlInformationToBeSetupItem {
    pub uluptnl_information: UpTransportLayerInformation,
}

impl UluptnlInformationToBeSetupItem {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (_optionals, _extensions_present) =
            aper::decode::decode_sequence_header(data, true, 1)?;
        let uluptnl_information = UpTransportLayerInformation::decode(data)?;

        Ok(Self {
            uluptnl_information,
        })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(false);

        aper::encode::encode_sequence_header(data, true, &optionals, false)?;
        self.uluptnl_information.encode(data)?;

        Ok(())
    }
}

impl AperCodec for UluptnlInformationToBeSetupItem {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        UluptnlInformationToBeSetupItem::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("UluptnlInformationToBeSetupItem"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("UluptnlInformationToBeSetupItem"))
    }
}
// Uncertainty
#[derive(Clone, Debug)]
pub struct Uncertainty(pub u16);

impl Uncertainty {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        Ok(Self(
            aper::decode::decode_integer(data, Some(0), Some(32767), true)?.0 as u16,
        ))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_integer(data, Some(0), Some(32767), true, self.0 as i128, false)
    }
}

impl AperCodec for Uncertainty {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        Uncertainty::decode_inner(data).map_err(|e: AperCodecError| e.push_context("Uncertainty"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("Uncertainty"))
    }
}
// UplinkChannelBwPerScsList
#[derive(Clone, Debug)]
pub struct UplinkChannelBwPerScsList(pub Vec<ScsSpecificCarrier>);

impl UplinkChannelBwPerScsList {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        Ok(Self({
            let length = aper::decode::decode_length_determinent(data, Some(1), Some(5), false)?;
            let mut items = vec![];
            for _ in 0..length {
                items.push(ScsSpecificCarrier::decode(data)?);
            }
            items
        }))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_length_determinent(data, Some(1), Some(5), false, self.0.len())?;
        for x in &self.0 {
            x.encode(data)?;
        }
        Ok(())
    }
}

impl AperCodec for UplinkChannelBwPerScsList {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        UplinkChannelBwPerScsList::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("UplinkChannelBwPerScsList"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("UplinkChannelBwPerScsList"))
    }
}
// UplinkTxDirectCurrentListInformation
#[derive(Clone, Debug)]
pub struct UplinkTxDirectCurrentListInformation(pub Vec<u8>);

impl UplinkTxDirectCurrentListInformation {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        Ok(Self(aper::decode::decode_octetstring(
            data, None, None, false,
        )?))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_octetstring(data, None, None, false, &self.0, false)
    }
}

impl AperCodec for UplinkTxDirectCurrentListInformation {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        UplinkTxDirectCurrentListInformation::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("UplinkTxDirectCurrentListInformation"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("UplinkTxDirectCurrentListInformation"))
    }
}
// UpTransportLayerInformation
#[derive(Clone, Debug)]
pub enum UpTransportLayerInformation {
    GtpTunnel(GtpTunnel),
}

impl UpTransportLayerInformation {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (idx, extended) = aper::decode::decode_choice_idx(data, 0, 1, false)?;
        if extended {
            return Err(aper::AperCodecError::new(
                "CHOICE additions not implemented",
            ));
        }
        match idx {
            0 => Ok(Self::GtpTunnel(GtpTunnel::decode(data)?)),
            1 => Err(AperCodecError::new(
                "Choice extension container not implemented",
            )),
            _ => Err(AperCodecError::new("Unknown choice idx")),
        }
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        match self {
            Self::GtpTunnel(x) => {
                aper::encode::encode_choice_idx(data, 0, 1, false, 0, false)?;
                x.encode(data)
            }
        }
    }
}

impl AperCodec for UpTransportLayerInformation {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        UpTransportLayerInformation::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("UpTransportLayerInformation"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("UpTransportLayerInformation"))
    }
}
// UriAddress
#[derive(Clone, Debug)]
pub struct UriAddress(pub String);

impl UriAddress {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        Ok(Self(aper::decode::decode_visible_string(
            data, None, None, false,
        )?))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_visible_string(data, None, None, false, &self.0, false)
    }
}

impl AperCodec for UriAddress {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        UriAddress::decode_inner(data).map_err(|e: AperCodecError| e.push_context("UriAddress"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("UriAddress"))
    }
}
// VictimGnbSetId
#[derive(Clone, Debug)]
pub struct VictimGnbSetId {
    pub victim_gnb_set_id: GnbSetId,
}

impl VictimGnbSetId {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (_optionals, _extensions_present) =
            aper::decode::decode_sequence_header(data, false, 1)?;
        let victim_gnb_set_id = GnbSetId::decode(data)?;

        Ok(Self { victim_gnb_set_id })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let mut optionals = BitVec::new();
        optionals.push(false);

        aper::encode::encode_sequence_header(data, false, &optionals, false)?;
        self.victim_gnb_set_id.encode(data)?;

        Ok(())
    }
}

impl AperCodec for VictimGnbSetId {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        VictimGnbSetId::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("VictimGnbSetId"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("VictimGnbSetId"))
    }
}
// VehicleUe
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum VehicleUe {
    Authorized,
    NotAuthorized,
}

impl VehicleUe {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (idx, extended) = aper::decode::decode_enumerated(data, Some(0), Some(1), true)?;
        if extended {
            return Err(aper::AperCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| AperCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_enumerated(data, Some(0), Some(1), true, *self as i128, false)
    }
}

impl AperCodec for VehicleUe {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        VehicleUe::decode_inner(data).map_err(|e: AperCodecError| e.push_context("VehicleUe"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("VehicleUe"))
    }
}
// PedestrianUe
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum PedestrianUe {
    Authorized,
    NotAuthorized,
}

impl PedestrianUe {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (idx, extended) = aper::decode::decode_enumerated(data, Some(0), Some(1), true)?;
        if extended {
            return Err(aper::AperCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| AperCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_enumerated(data, Some(0), Some(1), true, *self as i128, false)
    }
}

impl AperCodec for PedestrianUe {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        PedestrianUe::decode_inner(data).map_err(|e: AperCodecError| e.push_context("PedestrianUe"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("PedestrianUe"))
    }
}
// LatitudeSign
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum LatitudeSign {
    North,
    South,
}

impl LatitudeSign {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (idx, extended) = aper::decode::decode_enumerated(data, Some(0), Some(1), false)?;
        if extended {
            return Err(aper::AperCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| AperCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_enumerated(data, Some(0), Some(1), false, *self as i128, false)
    }
}

impl AperCodec for LatitudeSign {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        LatitudeSign::decode_inner(data).map_err(|e: AperCodecError| e.push_context("LatitudeSign"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("LatitudeSign"))
    }
}
// DirectionOfAltitude
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum DirectionOfAltitude {
    Height,
    Depth,
}

impl DirectionOfAltitude {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (idx, extended) = aper::decode::decode_enumerated(data, Some(0), Some(1), false)?;
        if extended {
            return Err(aper::AperCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| AperCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_enumerated(data, Some(0), Some(1), false, *self as i128, false)
    }
}

impl AperCodec for DirectionOfAltitude {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        DirectionOfAltitude::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("DirectionOfAltitude"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("DirectionOfAltitude"))
    }
}
// SubcarrierSpacing1
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum SubcarrierSpacing1 {
    KHz15,
    KHz30,
    KHz60,
    KHz120,
}

impl SubcarrierSpacing1 {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (idx, extended) = aper::decode::decode_enumerated(data, Some(0), Some(3), true)?;
        if extended {
            return Err(aper::AperCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| AperCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_enumerated(data, Some(0), Some(3), true, *self as i128, false)
    }
}

impl AperCodec for SubcarrierSpacing1 {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        SubcarrierSpacing1::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("SubcarrierSpacing1"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("SubcarrierSpacing1"))
    }
}
// CyclicPrefix
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum CyclicPrefix {
    Normal,
    Extended,
}

impl CyclicPrefix {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (idx, extended) = aper::decode::decode_enumerated(data, Some(0), Some(1), false)?;
        if extended {
            return Err(aper::AperCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| AperCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_enumerated(data, Some(0), Some(1), false, *self as i128, false)
    }
}

impl AperCodec for CyclicPrefix {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        CyclicPrefix::decode_inner(data).map_err(|e: AperCodecError| e.push_context("CyclicPrefix"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("CyclicPrefix"))
    }
}
// Shift7dot5kHz
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum Shift7dot5kHz {
    True,
}

impl Shift7dot5kHz {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (idx, extended) = aper::decode::decode_enumerated(data, Some(0), Some(0), true)?;
        if extended {
            return Err(aper::AperCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| AperCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_enumerated(data, Some(0), Some(0), true, *self as i128, false)
    }
}

impl AperCodec for Shift7dot5kHz {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        Shift7dot5kHz::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("Shift7dot5kHz"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("Shift7dot5kHz"))
    }
}
// Resolution
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum Resolution {
    Deg0dot1,
}

impl Resolution {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (idx, extended) = aper::decode::decode_enumerated(data, Some(0), Some(0), true)?;
        if extended {
            return Err(aper::AperCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| AperCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_enumerated(data, Some(0), Some(0), true, *self as i128, false)
    }
}

impl AperCodec for Resolution {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        Resolution::decode_inner(data).map_err(|e: AperCodecError| e.push_context("Resolution"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("Resolution"))
    }
}
// DelayCritical
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum DelayCritical {
    DelayCritical,
    NonDelayCritical,
}

impl DelayCritical {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (idx, extended) = aper::decode::decode_enumerated(data, Some(0), Some(1), false)?;
        if extended {
            return Err(aper::AperCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| AperCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_enumerated(data, Some(0), Some(1), false, *self as i128, false)
    }
}

impl AperCodec for DelayCritical {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        DelayCritical::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("DelayCritical"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("DelayCritical"))
    }
}
// ResourceType1
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum ResourceType1 {
    Gbr,
    NonGbr,
    DelayCriticalGrb,
}

impl ResourceType1 {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (idx, extended) = aper::decode::decode_enumerated(data, Some(0), Some(2), true)?;
        if extended {
            return Err(aper::AperCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| AperCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_enumerated(data, Some(0), Some(2), true, *self as i128, false)
    }
}

impl AperCodec for ResourceType1 {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        ResourceType1::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("ResourceType1"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("ResourceType1"))
    }
}
// Nrscs1
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum Nrscs1 {
    Scs15,
    Scs30,
    Scs60,
    Scs120,
}

impl Nrscs1 {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (idx, extended) = aper::decode::decode_enumerated(data, Some(0), Some(3), true)?;
        if extended {
            return Err(aper::AperCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| AperCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_enumerated(data, Some(0), Some(3), true, *self as i128, false)
    }
}

impl AperCodec for Nrscs1 {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        Nrscs1::decode_inner(data).map_err(|e: AperCodecError| e.push_context("Nrscs1"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("Nrscs1"))
    }
}
// Nrcp
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum Nrcp {
    Normal,
    Extended,
}

impl Nrcp {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (idx, extended) = aper::decode::decode_enumerated(data, Some(0), Some(1), true)?;
        if extended {
            return Err(aper::AperCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| AperCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_enumerated(data, Some(0), Some(1), true, *self as i128, false)
    }
}

impl AperCodec for Nrcp {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        Nrcp::decode_inner(data).map_err(|e: AperCodecError| e.push_context("Nrcp"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("Nrcp"))
    }
}
// NrdlulTxPeriodicity
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum NrdlulTxPeriodicity {
    Ms0p5,
    Ms0p625,
    Ms1,
    Ms1p25,
    Ms2,
    Ms2p5,
    Ms3,
    Ms4,
    Ms5,
    Ms10,
    Ms20,
    Ms40,
    Ms60,
    Ms80,
    Ms100,
    Ms120,
    Ms140,
    Ms160,
}

impl NrdlulTxPeriodicity {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (idx, extended) = aper::decode::decode_enumerated(data, Some(0), Some(17), true)?;
        if extended {
            return Err(aper::AperCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| AperCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_enumerated(data, Some(0), Some(17), true, *self as i128, false)
    }
}

impl AperCodec for NrdlulTxPeriodicity {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        NrdlulTxPeriodicity::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("NrdlulTxPeriodicity"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("NrdlulTxPeriodicity"))
    }
}
// Msg1scs
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum Msg1scs {
    Scs15,
    Scs30,
    Scs60,
    Scs120,
}

impl Msg1scs {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (idx, extended) = aper::decode::decode_enumerated(data, Some(0), Some(3), true)?;
        if extended {
            return Err(aper::AperCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| AperCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_enumerated(data, Some(0), Some(3), true, *self as i128, false)
    }
}

impl AperCodec for Msg1scs {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        Msg1scs::decode_inner(data).map_err(|e: AperCodecError| e.push_context("Msg1scs"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("Msg1scs"))
    }
}
// RestrictedSetConfig
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum RestrictedSetConfig {
    UnrestrictedSet,
    RestrictedSetTypeA,
    RestrictedSetTypeB,
}

impl RestrictedSetConfig {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (idx, extended) = aper::decode::decode_enumerated(data, Some(0), Some(2), true)?;
        if extended {
            return Err(aper::AperCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| AperCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_enumerated(data, Some(0), Some(2), true, *self as i128, false)
    }
}

impl AperCodec for RestrictedSetConfig {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        RestrictedSetConfig::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("RestrictedSetConfig"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("RestrictedSetConfig"))
    }
}
// Msg1fdm
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum Msg1fdm {
    One,
    Two,
    Four,
    Eight,
}

impl Msg1fdm {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (idx, extended) = aper::decode::decode_enumerated(data, Some(0), Some(3), true)?;
        if extended {
            return Err(aper::AperCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| AperCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_enumerated(data, Some(0), Some(3), true, *self as i128, false)
    }
}

impl AperCodec for Msg1fdm {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        Msg1fdm::decode_inner(data).map_err(|e: AperCodecError| e.push_context("Msg1fdm"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("Msg1fdm"))
    }
}
// SsbPerRachOccasion
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum SsbPerRachOccasion {
    OneEighth,
    OneFourth,
    OneHalf,
    One,
    Two,
    Four,
    Eight,
    Sixteen,
}

impl SsbPerRachOccasion {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (idx, extended) = aper::decode::decode_enumerated(data, Some(0), Some(7), true)?;
        if extended {
            return Err(aper::AperCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| AperCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_enumerated(data, Some(0), Some(7), true, *self as i128, false)
    }
}

impl AperCodec for SsbPerRachOccasion {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        SsbPerRachOccasion::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("SsbPerRachOccasion"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("SsbPerRachOccasion"))
    }
}
// PosperiodicSet
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum PosperiodicSet {
    True,
}

impl PosperiodicSet {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (idx, extended) = aper::decode::decode_enumerated(data, Some(0), Some(0), true)?;
        if extended {
            return Err(aper::AperCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| AperCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_enumerated(data, Some(0), Some(0), true, *self as i128, false)
    }
}

impl AperCodec for PosperiodicSet {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        PosperiodicSet::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("PosperiodicSet"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("PosperiodicSet"))
    }
}
// PossemiPersistentSet
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum PossemiPersistentSet {
    True,
}

impl PossemiPersistentSet {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (idx, extended) = aper::decode::decode_enumerated(data, Some(0), Some(0), true)?;
        if extended {
            return Err(aper::AperCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| AperCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_enumerated(data, Some(0), Some(0), true, *self as i128, false)
    }
}

impl AperCodec for PossemiPersistentSet {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        PossemiPersistentSet::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("PossemiPersistentSet"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("PossemiPersistentSet"))
    }
}
// NrofSymbols
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum NrofSymbols {
    N1,
    N2,
    N4,
    N8,
    N12,
}

impl NrofSymbols {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (idx, extended) = aper::decode::decode_enumerated(data, Some(0), Some(4), false)?;
        if extended {
            return Err(aper::AperCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| AperCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_enumerated(data, Some(0), Some(4), false, *self as i128, false)
    }
}

impl AperCodec for NrofSymbols {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        NrofSymbols::decode_inner(data).map_err(|e: AperCodecError| e.push_context("NrofSymbols"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("NrofSymbols"))
    }
}
// GroupOrSequenceHopping
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum GroupOrSequenceHopping {
    Neither,
    GroupHopping,
    SequenceHopping,
}

impl GroupOrSequenceHopping {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (idx, extended) = aper::decode::decode_enumerated(data, Some(0), Some(2), false)?;
        if extended {
            return Err(aper::AperCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| AperCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_enumerated(data, Some(0), Some(2), false, *self as i128, false)
    }
}

impl AperCodec for GroupOrSequenceHopping {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        GroupOrSequenceHopping::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("GroupOrSequenceHopping"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("GroupOrSequenceHopping"))
    }
}
// MutingBitRepetitionFactor
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum MutingBitRepetitionFactor {
    Rf1,
    Rf2,
    Rf4,
    Rf8,
}

impl MutingBitRepetitionFactor {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (idx, extended) = aper::decode::decode_enumerated(data, Some(0), Some(3), true)?;
        if extended {
            return Err(aper::AperCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| AperCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_enumerated(data, Some(0), Some(3), true, *self as i128, false)
    }
}

impl AperCodec for MutingBitRepetitionFactor {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        MutingBitRepetitionFactor::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("MutingBitRepetitionFactor"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("MutingBitRepetitionFactor"))
    }
}
// SubcarrierSpacing2
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum SubcarrierSpacing2 {
    KHz15,
    KHz30,
    KHz60,
    KHz120,
}

impl SubcarrierSpacing2 {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (idx, extended) = aper::decode::decode_enumerated(data, Some(0), Some(3), true)?;
        if extended {
            return Err(aper::AperCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| AperCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_enumerated(data, Some(0), Some(3), true, *self as i128, false)
    }
}

impl AperCodec for SubcarrierSpacing2 {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        SubcarrierSpacing2::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("SubcarrierSpacing2"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("SubcarrierSpacing2"))
    }
}
// CombSize
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum CombSize {
    N2,
    N4,
    N6,
    N12,
}

impl CombSize {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (idx, extended) = aper::decode::decode_enumerated(data, Some(0), Some(3), true)?;
        if extended {
            return Err(aper::AperCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| AperCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_enumerated(data, Some(0), Some(3), true, *self as i128, false)
    }
}

impl AperCodec for CombSize {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        CombSize::decode_inner(data).map_err(|e: AperCodecError| e.push_context("CombSize"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("CombSize"))
    }
}
// CpType
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum CpType {
    Normal,
    Extended,
}

impl CpType {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (idx, extended) = aper::decode::decode_enumerated(data, Some(0), Some(1), true)?;
        if extended {
            return Err(aper::AperCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| AperCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_enumerated(data, Some(0), Some(1), true, *self as i128, false)
    }
}

impl AperCodec for CpType {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        CpType::decode_inner(data).map_err(|e: AperCodecError| e.push_context("CpType"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("CpType"))
    }
}
// ResourceSetPeriodicity
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum ResourceSetPeriodicity {
    N4,
    N5,
    N8,
    N10,
    N16,
    N20,
    N32,
    N40,
    N64,
    N80,
    N160,
    N320,
    N640,
    N1280,
    N2560,
    N5120,
    N10240,
    N20480,
    N40960,
    N81920,
}

impl ResourceSetPeriodicity {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (idx, extended) = aper::decode::decode_enumerated(data, Some(0), Some(19), true)?;
        if extended {
            return Err(aper::AperCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| AperCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_enumerated(data, Some(0), Some(19), true, *self as i128, false)
    }
}

impl AperCodec for ResourceSetPeriodicity {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        ResourceSetPeriodicity::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("ResourceSetPeriodicity"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("ResourceSetPeriodicity"))
    }
}
// ResourceRepetitionFactor
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum ResourceRepetitionFactor {
    Rf1,
    Rf2,
    Rf4,
    Rf6,
    Rf8,
    Rf16,
    Rf32,
}

impl ResourceRepetitionFactor {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (idx, extended) = aper::decode::decode_enumerated(data, Some(0), Some(6), true)?;
        if extended {
            return Err(aper::AperCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| AperCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_enumerated(data, Some(0), Some(6), true, *self as i128, false)
    }
}

impl AperCodec for ResourceRepetitionFactor {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        ResourceRepetitionFactor::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("ResourceRepetitionFactor"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("ResourceRepetitionFactor"))
    }
}
// ResourceTimeGap
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum ResourceTimeGap {
    Tg1,
    Tg2,
    Tg4,
    Tg8,
    Tg16,
    Tg32,
}

impl ResourceTimeGap {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (idx, extended) = aper::decode::decode_enumerated(data, Some(0), Some(5), true)?;
        if extended {
            return Err(aper::AperCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| AperCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_enumerated(data, Some(0), Some(5), true, *self as i128, false)
    }
}

impl AperCodec for ResourceTimeGap {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        ResourceTimeGap::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("ResourceTimeGap"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("ResourceTimeGap"))
    }
}
// ResourceNumberofSymbols
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum ResourceNumberofSymbols {
    N2,
    N4,
    N6,
    N12,
}

impl ResourceNumberofSymbols {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (idx, extended) = aper::decode::decode_enumerated(data, Some(0), Some(3), true)?;
        if extended {
            return Err(aper::AperCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| AperCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_enumerated(data, Some(0), Some(3), true, *self as i128, false)
    }
}

impl AperCodec for ResourceNumberofSymbols {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        ResourceNumberofSymbols::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("ResourceNumberofSymbols"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("ResourceNumberofSymbols"))
    }
}
// ReflectiveQosAttribute
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum ReflectiveQosAttribute {
    SubjectTo,
}

impl ReflectiveQosAttribute {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (idx, extended) = aper::decode::decode_enumerated(data, Some(0), Some(0), true)?;
        if extended {
            return Err(aper::AperCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| AperCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_enumerated(data, Some(0), Some(0), true, *self as i128, false)
    }
}

impl AperCodec for ReflectiveQosAttribute {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        ReflectiveQosAttribute::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("ReflectiveQosAttribute"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("ReflectiveQosAttribute"))
    }
}
// XyZunit
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum XyZunit {
    Mm,
    Cm,
    Dm,
}

impl XyZunit {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (idx, extended) = aper::decode::decode_enumerated(data, Some(0), Some(2), true)?;
        if extended {
            return Err(aper::AperCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| AperCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_enumerated(data, Some(0), Some(2), true, *self as i128, false)
    }
}

impl AperCodec for XyZunit {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        XyZunit::decode_inner(data).map_err(|e: AperCodecError| e.push_context("XyZunit"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("XyZunit"))
    }
}
// MilliArcSecondUnits
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum MilliArcSecondUnits {
    Zerodot03,
    Zerodot3,
    Three,
}

impl MilliArcSecondUnits {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (idx, extended) = aper::decode::decode_enumerated(data, Some(0), Some(2), true)?;
        if extended {
            return Err(aper::AperCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| AperCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_enumerated(data, Some(0), Some(2), true, *self as i128, false)
    }
}

impl AperCodec for MilliArcSecondUnits {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        MilliArcSecondUnits::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("MilliArcSecondUnits"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("MilliArcSecondUnits"))
    }
}
// HeightUnits
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum HeightUnits {
    Mm,
    Cm,
    M,
}

impl HeightUnits {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (idx, extended) = aper::decode::decode_enumerated(data, Some(0), Some(2), true)?;
        if extended {
            return Err(aper::AperCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| AperCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_enumerated(data, Some(0), Some(2), true, *self as i128, false)
    }
}

impl AperCodec for HeightUnits {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        HeightUnits::decode_inner(data).map_err(|e: AperCodecError| e.push_context("HeightUnits"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("HeightUnits"))
    }
}
// ResourceType2
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum ResourceType2 {
    Periodic,
    SemiPersistent,
    Aperiodic,
}

impl ResourceType2 {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (idx, extended) = aper::decode::decode_enumerated(data, Some(0), Some(2), true)?;
        if extended {
            return Err(aper::AperCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| AperCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_enumerated(data, Some(0), Some(2), true, *self as i128, false)
    }
}

impl AperCodec for ResourceType2 {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        ResourceType2::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("ResourceType2"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("ResourceType2"))
    }
}
// PeriodicSet
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum PeriodicSet {
    True,
}

impl PeriodicSet {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (idx, extended) = aper::decode::decode_enumerated(data, Some(0), Some(0), true)?;
        if extended {
            return Err(aper::AperCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| AperCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_enumerated(data, Some(0), Some(0), true, *self as i128, false)
    }
}

impl AperCodec for PeriodicSet {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        PeriodicSet::decode_inner(data).map_err(|e: AperCodecError| e.push_context("PeriodicSet"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("PeriodicSet"))
    }
}
// SemiPersistentSet
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum SemiPersistentSet {
    True,
}

impl SemiPersistentSet {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (idx, extended) = aper::decode::decode_enumerated(data, Some(0), Some(0), true)?;
        if extended {
            return Err(aper::AperCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| AperCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_enumerated(data, Some(0), Some(0), true, *self as i128, false)
    }
}

impl AperCodec for SemiPersistentSet {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        SemiPersistentSet::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("SemiPersistentSet"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("SemiPersistentSet"))
    }
}
// Periodicity1
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum Periodicity1 {
    Slot1,
    Slot2,
    Slot4,
    Slot5,
    Slot8,
    Slot10,
    Slot16,
    Slot20,
    Slot32,
    Slot40,
    Slot64,
    Slot80,
    Slot160,
    Slot320,
    Slot640,
    Slot1280,
    Slot2560,
}

impl Periodicity1 {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (idx, extended) = aper::decode::decode_enumerated(data, Some(0), Some(16), true)?;
        if extended {
            return Err(aper::AperCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| AperCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_enumerated(data, Some(0), Some(16), true, *self as i128, false)
    }
}

impl AperCodec for Periodicity1 {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        Periodicity1::decode_inner(data).map_err(|e: AperCodecError| e.push_context("Periodicity1"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("Periodicity1"))
    }
}
// Periodicity2
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum Periodicity2 {
    Slot1,
    Slot2,
    Slot4,
    Slot5,
    Slot8,
    Slot10,
    Slot16,
    Slot20,
    Slot32,
    Slot40,
    Slot64,
    Slot80,
    Slot160,
    Slot320,
    Slot640,
    Slot1280,
    Slot2560,
}

impl Periodicity2 {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (idx, extended) = aper::decode::decode_enumerated(data, Some(0), Some(16), true)?;
        if extended {
            return Err(aper::AperCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| AperCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_enumerated(data, Some(0), Some(16), true, *self as i128, false)
    }
}

impl AperCodec for Periodicity2 {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        Periodicity2::decode_inner(data).map_err(|e: AperCodecError| e.push_context("Periodicity2"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("Periodicity2"))
    }
}
// AperiodicResourceType
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum AperiodicResourceType {
    True,
}

impl AperiodicResourceType {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (idx, extended) = aper::decode::decode_enumerated(data, Some(0), Some(0), true)?;
        if extended {
            return Err(aper::AperCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| AperCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_enumerated(data, Some(0), Some(0), true, *self as i128, false)
    }
}

impl AperCodec for AperiodicResourceType {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        AperiodicResourceType::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("AperiodicResourceType"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("AperiodicResourceType"))
    }
}
// Periodicity3
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum Periodicity3 {
    Slot1,
    Slot2,
    Slot4,
    Slot5,
    Slot8,
    Slot10,
    Slot16,
    Slot20,
    Slot32,
    Slot40,
    Slot64,
    Slot80,
    Slot160,
    Slot320,
    Slot640,
    Slot1280,
    Slot2560,
    Slot5120,
    Slot10240,
    Slot40960,
    Slot81920,
}

impl Periodicity3 {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (idx, extended) = aper::decode::decode_enumerated(data, Some(0), Some(20), true)?;
        if extended {
            return Err(aper::AperCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| AperCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_enumerated(data, Some(0), Some(20), true, *self as i128, false)
    }
}

impl AperCodec for Periodicity3 {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        Periodicity3::decode_inner(data).map_err(|e: AperCodecError| e.push_context("Periodicity3"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("Periodicity3"))
    }
}
// Periodicity4
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum Periodicity4 {
    Slot1,
    Slot2,
    Slot4,
    Slot5,
    Slot8,
    Slot10,
    Slot16,
    Slot20,
    Slot32,
    Slot40,
    Slot64,
    Slot80,
    Slot160,
    Slot320,
    Slot640,
    Slot1280,
    Slot2560,
    Slot5120,
    Slot10240,
    Slot40960,
    Slot81920,
}

impl Periodicity4 {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (idx, extended) = aper::decode::decode_enumerated(data, Some(0), Some(20), true)?;
        if extended {
            return Err(aper::AperCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| AperCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_enumerated(data, Some(0), Some(20), true, *self as i128, false)
    }
}

impl AperCodec for Periodicity4 {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        Periodicity4::decode_inner(data).map_err(|e: AperCodecError| e.push_context("Periodicity4"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("Periodicity4"))
    }
}
// SubcarrierSpacing3
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum SubcarrierSpacing3 {
    KHz15,
    KHz30,
    KHz60,
    KHz120,
}

impl SubcarrierSpacing3 {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (idx, extended) = aper::decode::decode_enumerated(data, Some(0), Some(3), true)?;
        if extended {
            return Err(aper::AperCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| AperCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_enumerated(data, Some(0), Some(3), true, *self as i128, false)
    }
}

impl AperCodec for SubcarrierSpacing3 {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        SubcarrierSpacing3::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("SubcarrierSpacing3"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("SubcarrierSpacing3"))
    }
}
// SwitchingOffOngoing
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum SwitchingOffOngoing {
    True,
}

impl SwitchingOffOngoing {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (idx, extended) = aper::decode::decode_enumerated(data, Some(0), Some(0), true)?;
        if extended {
            return Err(aper::AperCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| AperCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_enumerated(data, Some(0), Some(0), true, *self as i128, false)
    }
}

impl AperCodec for SwitchingOffOngoing {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        SwitchingOffOngoing::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("SwitchingOffOngoing"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("SwitchingOffOngoing"))
    }
}
// NrofSrsPorts
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum NrofSrsPorts {
    Port1,
    Ports2,
    Ports4,
}

impl NrofSrsPorts {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (idx, extended) = aper::decode::decode_enumerated(data, Some(0), Some(2), false)?;
        if extended {
            return Err(aper::AperCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| AperCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_enumerated(data, Some(0), Some(2), false, *self as i128, false)
    }
}

impl AperCodec for NrofSrsPorts {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        NrofSrsPorts::decode_inner(data).map_err(|e: AperCodecError| e.push_context("NrofSrsPorts"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("NrofSrsPorts"))
    }
}
// NrofSymbols1
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum NrofSymbols1 {
    N1,
    N2,
    N4,
}

impl NrofSymbols1 {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (idx, extended) = aper::decode::decode_enumerated(data, Some(0), Some(2), false)?;
        if extended {
            return Err(aper::AperCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| AperCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_enumerated(data, Some(0), Some(2), false, *self as i128, false)
    }
}

impl AperCodec for NrofSymbols1 {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        NrofSymbols1::decode_inner(data).map_err(|e: AperCodecError| e.push_context("NrofSymbols1"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("NrofSymbols1"))
    }
}
// RepetitionFactor
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum RepetitionFactor {
    N1,
    N2,
    N4,
}

impl RepetitionFactor {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (idx, extended) = aper::decode::decode_enumerated(data, Some(0), Some(2), false)?;
        if extended {
            return Err(aper::AperCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| AperCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_enumerated(data, Some(0), Some(2), false, *self as i128, false)
    }
}

impl AperCodec for RepetitionFactor {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        RepetitionFactor::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("RepetitionFactor"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("RepetitionFactor"))
    }
}
// GroupOrSequenceHopping1
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum GroupOrSequenceHopping1 {
    Neither,
    GroupHopping,
    SequenceHopping,
}

impl GroupOrSequenceHopping1 {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (idx, extended) = aper::decode::decode_enumerated(data, Some(0), Some(2), false)?;
        if extended {
            return Err(aper::AperCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| AperCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_enumerated(data, Some(0), Some(2), false, *self as i128, false)
    }
}

impl AperCodec for GroupOrSequenceHopping1 {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        GroupOrSequenceHopping1::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("GroupOrSequenceHopping1"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("GroupOrSequenceHopping1"))
    }
}
// SsbSubcarrierSpacing1
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum SsbSubcarrierSpacing1 {
    KHz15,
    KHz30,
    KHz60,
    KHz120,
    KHz240,
}

impl SsbSubcarrierSpacing1 {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (idx, extended) = aper::decode::decode_enumerated(data, Some(0), Some(4), true)?;
        if extended {
            return Err(aper::AperCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| AperCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_enumerated(data, Some(0), Some(4), true, *self as i128, false)
    }
}

impl AperCodec for SsbSubcarrierSpacing1 {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        SsbSubcarrierSpacing1::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("SsbSubcarrierSpacing1"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("SsbSubcarrierSpacing1"))
    }
}
// SsbPeriodicity
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum SsbPeriodicity {
    Ms5,
    Ms10,
    Ms20,
    Ms40,
    Ms80,
    Ms160,
}

impl SsbPeriodicity {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (idx, extended) = aper::decode::decode_enumerated(data, Some(0), Some(5), true)?;
        if extended {
            return Err(aper::AperCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| AperCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_enumerated(data, Some(0), Some(5), true, *self as i128, false)
    }
}

impl AperCodec for SsbPeriodicity {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        SsbPeriodicity::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("SsbPeriodicity"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("SsbPeriodicity"))
    }
}
// Resolution1
#[derive(Clone, Debug, Copy, TryFromPrimitive)]
#[repr(u8)]
pub enum Resolution1 {
    M0dot1,
    M1,
    M10,
    M30,
}

impl Resolution1 {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (idx, extended) = aper::decode::decode_enumerated(data, Some(0), Some(3), true)?;
        if extended {
            return Err(aper::AperCodecError::new("Extended enum not implemented"));
        }
        Self::try_from(idx as u8).map_err(|_| AperCodecError::new("Unknown enum variant"))
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        aper::encode::encode_enumerated(data, Some(0), Some(3), true, *self as i128, false)
    }
}

impl AperCodec for Resolution1 {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        Resolution1::decode_inner(data).map_err(|e: AperCodecError| e.push_context("Resolution1"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("Resolution1"))
    }
}
// N2
#[derive(Clone, Debug)]
pub struct N2 {
    pub comb_offset_n_2: u8,
    pub cyclic_shift_n_2: u8,
}

impl N2 {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (_optionals, _extensions_present) =
            aper::decode::decode_sequence_header(data, false, 0)?;
        let comb_offset_n_2 = aper::decode::decode_integer(data, Some(0), Some(1), false)?.0 as u8;
        let cyclic_shift_n_2 = aper::decode::decode_integer(data, Some(0), Some(7), false)?.0 as u8;

        Ok(Self {
            comb_offset_n_2,
            cyclic_shift_n_2,
        })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let optionals = BitVec::new();

        aper::encode::encode_sequence_header(data, false, &optionals, false)?;
        aper::encode::encode_integer(
            data,
            Some(0),
            Some(1),
            false,
            self.comb_offset_n_2 as i128,
            false,
        )?;
        aper::encode::encode_integer(
            data,
            Some(0),
            Some(7),
            false,
            self.cyclic_shift_n_2 as i128,
            false,
        )?;

        Ok(())
    }
}

impl AperCodec for N2 {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        N2::decode_inner(data).map_err(|e: AperCodecError| e.push_context("N2"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("N2"))
    }
}
// N4
#[derive(Clone, Debug)]
pub struct N4 {
    pub comb_offset_n_4: u8,
    pub cyclic_shift_n_4: u8,
}

impl N4 {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (_optionals, _extensions_present) =
            aper::decode::decode_sequence_header(data, false, 0)?;
        let comb_offset_n_4 = aper::decode::decode_integer(data, Some(0), Some(3), false)?.0 as u8;
        let cyclic_shift_n_4 =
            aper::decode::decode_integer(data, Some(0), Some(11), false)?.0 as u8;

        Ok(Self {
            comb_offset_n_4,
            cyclic_shift_n_4,
        })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let optionals = BitVec::new();

        aper::encode::encode_sequence_header(data, false, &optionals, false)?;
        aper::encode::encode_integer(
            data,
            Some(0),
            Some(3),
            false,
            self.comb_offset_n_4 as i128,
            false,
        )?;
        aper::encode::encode_integer(
            data,
            Some(0),
            Some(11),
            false,
            self.cyclic_shift_n_4 as i128,
            false,
        )?;

        Ok(())
    }
}

impl AperCodec for N4 {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        N4::decode_inner(data).map_err(|e: AperCodecError| e.push_context("N4"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("N4"))
    }
}
// N2_1
#[derive(Clone, Debug)]
pub struct N2_1 {
    pub comb_offset_n_2: u8,
    pub cyclic_shift_n_2: u8,
}

impl N2_1 {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (_optionals, _extensions_present) =
            aper::decode::decode_sequence_header(data, false, 0)?;
        let comb_offset_n_2 = aper::decode::decode_integer(data, Some(0), Some(1), false)?.0 as u8;
        let cyclic_shift_n_2 = aper::decode::decode_integer(data, Some(0), Some(7), false)?.0 as u8;

        Ok(Self {
            comb_offset_n_2,
            cyclic_shift_n_2,
        })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let optionals = BitVec::new();

        aper::encode::encode_sequence_header(data, false, &optionals, false)?;
        aper::encode::encode_integer(
            data,
            Some(0),
            Some(1),
            false,
            self.comb_offset_n_2 as i128,
            false,
        )?;
        aper::encode::encode_integer(
            data,
            Some(0),
            Some(7),
            false,
            self.cyclic_shift_n_2 as i128,
            false,
        )?;

        Ok(())
    }
}

impl AperCodec for N2_1 {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        N2_1::decode_inner(data).map_err(|e: AperCodecError| e.push_context("N2_1"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("N2_1"))
    }
}
// N4_1
#[derive(Clone, Debug)]
pub struct N4_1 {
    pub comb_offset_n_4: u8,
    pub cyclic_shift_n_4: u8,
}

impl N4_1 {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (_optionals, _extensions_present) =
            aper::decode::decode_sequence_header(data, false, 0)?;
        let comb_offset_n_4 = aper::decode::decode_integer(data, Some(0), Some(3), false)?.0 as u8;
        let cyclic_shift_n_4 =
            aper::decode::decode_integer(data, Some(0), Some(11), false)?.0 as u8;

        Ok(Self {
            comb_offset_n_4,
            cyclic_shift_n_4,
        })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let optionals = BitVec::new();

        aper::encode::encode_sequence_header(data, false, &optionals, false)?;
        aper::encode::encode_integer(
            data,
            Some(0),
            Some(3),
            false,
            self.comb_offset_n_4 as i128,
            false,
        )?;
        aper::encode::encode_integer(
            data,
            Some(0),
            Some(11),
            false,
            self.cyclic_shift_n_4 as i128,
            false,
        )?;

        Ok(())
    }
}

impl AperCodec for N4_1 {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        N4_1::decode_inner(data).map_err(|e: AperCodecError| e.push_context("N4_1"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("N4_1"))
    }
}
// N8
#[derive(Clone, Debug)]
pub struct N8 {
    pub comb_offset_n_8: u8,
    pub cyclic_shift_n_8: u8,
}

impl N8 {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (_optionals, _extensions_present) =
            aper::decode::decode_sequence_header(data, false, 0)?;
        let comb_offset_n_8 = aper::decode::decode_integer(data, Some(0), Some(7), false)?.0 as u8;
        let cyclic_shift_n_8 = aper::decode::decode_integer(data, Some(0), Some(5), false)?.0 as u8;

        Ok(Self {
            comb_offset_n_8,
            cyclic_shift_n_8,
        })
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        let optionals = BitVec::new();

        aper::encode::encode_sequence_header(data, false, &optionals, false)?;
        aper::encode::encode_integer(
            data,
            Some(0),
            Some(7),
            false,
            self.comb_offset_n_8 as i128,
            false,
        )?;
        aper::encode::encode_integer(
            data,
            Some(0),
            Some(5),
            false,
            self.cyclic_shift_n_8 as i128,
            false,
        )?;

        Ok(())
    }
}

impl AperCodec for N8 {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        N8::decode_inner(data).map_err(|e: AperCodecError| e.push_context("N8"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("N8"))
    }
}
