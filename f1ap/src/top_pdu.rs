// Autogenerated from F1AP-PDU-Descriptions.asn
use super::pdu::*;
use crate::common::Criticality;
use anyhow::Result;
use asn1_codecs::aper::{self, AperCodec, AperCodecData, AperCodecError};
use async_trait::async_trait;
use net::{AperSerde, Procedure, RequestError, RequestProvider};
use slog::Logger;

// F1apPdu
#[derive(Clone, Debug)]
pub enum F1apPdu {
    InitiatingMessage(InitiatingMessage),
    SuccessfulOutcome(SuccessfulOutcome),
    UnsuccessfulOutcome(UnsuccessfulOutcome),
}

impl F1apPdu {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (idx, extended) = aper::decode::decode_choice_idx(data, 0, 3, false)?;
        if extended {
            return Err(aper::AperCodecError::new(
                "CHOICE additions not implemented",
            ));
        }
        match idx {
            0 => Ok(Self::InitiatingMessage(InitiatingMessage::decode(data)?)),
            1 => Ok(Self::SuccessfulOutcome(SuccessfulOutcome::decode(data)?)),
            2 => Ok(Self::UnsuccessfulOutcome(UnsuccessfulOutcome::decode(
                data,
            )?)),
            3 => Err(AperCodecError::new(
                "Choice extension container not implemented",
            )),
            _ => Err(AperCodecError::new("Unknown choice idx")),
        }
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        match self {
            Self::InitiatingMessage(x) => {
                aper::encode::encode_choice_idx(data, 0, 3, false, 0, false)?;
                x.encode(data)
            }
            Self::SuccessfulOutcome(x) => {
                aper::encode::encode_choice_idx(data, 0, 3, false, 1, false)?;
                x.encode(data)
            }
            Self::UnsuccessfulOutcome(x) => {
                aper::encode::encode_choice_idx(data, 0, 3, false, 2, false)?;
                x.encode(data)
            }
        }
    }
}

impl AperCodec for F1apPdu {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        F1apPdu::decode_inner(data).map_err(|e: AperCodecError| e.push_context("F1apPdu"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("F1apPdu"))
    }
}
pub struct ResetProcedure {}

#[async_trait]
impl Procedure for ResetProcedure {
    type TopPdu = F1apPdu;
    type Request = Reset;
    type Success = ResetAcknowledge;
    type Failure = ();
    const CODE: u8 = 0;

    async fn call_provider<T: RequestProvider<Self>>(
        provider: &T,
        req: Reset,
        logger: &Logger,
    ) -> Option<F1apPdu> {
        match <T as RequestProvider<ResetProcedure>>::request(provider, req, logger).await {
            Ok(x) => Some(F1apPdu::SuccessfulOutcome(
                SuccessfulOutcome::ResetAcknowledge(x),
            )),
            Err(_) => todo!(),
        }
    }

    fn encode_request(r: Self::Request) -> Result<Vec<u8>, AperCodecError> {
        F1apPdu::InitiatingMessage(InitiatingMessage::Reset(r)).into_bytes()
    }

    fn decode_response(bytes: &[u8]) -> Result<Self::Success, RequestError<Self::Failure>> {
        let response_pdu = Self::TopPdu::from_bytes(bytes)?;
        match response_pdu {
            F1apPdu::SuccessfulOutcome(SuccessfulOutcome::ResetAcknowledge(x)) => Ok(x),

            _ => Err(RequestError::Other("Unexpected pdu contents".to_string())),
        }
    }
}

pub struct F1SetupProcedure {}

#[async_trait]
impl Procedure for F1SetupProcedure {
    type TopPdu = F1apPdu;
    type Request = F1SetupRequest;
    type Success = F1SetupResponse;
    type Failure = F1SetupFailure;
    const CODE: u8 = 1;

    async fn call_provider<T: RequestProvider<Self>>(
        provider: &T,
        req: F1SetupRequest,
        logger: &Logger,
    ) -> Option<F1apPdu> {
        match <T as RequestProvider<F1SetupProcedure>>::request(provider, req, logger).await {
            Ok(x) => Some(F1apPdu::SuccessfulOutcome(
                SuccessfulOutcome::F1SetupResponse(x),
            )),
            Err(_) => todo!(),
        }
    }

    fn encode_request(r: Self::Request) -> Result<Vec<u8>, AperCodecError> {
        F1apPdu::InitiatingMessage(InitiatingMessage::F1SetupRequest(r)).into_bytes()
    }

    fn decode_response(bytes: &[u8]) -> Result<Self::Success, RequestError<Self::Failure>> {
        let response_pdu = Self::TopPdu::from_bytes(bytes)?;
        match response_pdu {
            F1apPdu::SuccessfulOutcome(SuccessfulOutcome::F1SetupResponse(x)) => Ok(x),
            F1apPdu::UnsuccessfulOutcome(UnsuccessfulOutcome::F1SetupFailure(x)) => {
                Err(RequestError::UnsuccessfulOutcome(x))
            }
            _ => Err(RequestError::Other("Unexpected pdu contents".to_string())),
        }
    }
}

pub struct GnbDuConfigurationUpdateProcedure {}

#[async_trait]
impl Procedure for GnbDuConfigurationUpdateProcedure {
    type TopPdu = F1apPdu;
    type Request = GnbDuConfigurationUpdate;
    type Success = GnbDuConfigurationUpdateAcknowledge;
    type Failure = GnbDuConfigurationUpdateFailure;
    const CODE: u8 = 3;

    async fn call_provider<T: RequestProvider<Self>>(
        provider: &T,
        req: GnbDuConfigurationUpdate,
        logger: &Logger,
    ) -> Option<F1apPdu> {
        match <T as RequestProvider<GnbDuConfigurationUpdateProcedure>>::request(
            provider, req, logger,
        )
        .await
        {
            Ok(x) => Some(F1apPdu::SuccessfulOutcome(
                SuccessfulOutcome::GnbDuConfigurationUpdateAcknowledge(x),
            )),
            Err(_) => todo!(),
        }
    }

    fn encode_request(r: Self::Request) -> Result<Vec<u8>, AperCodecError> {
        F1apPdu::InitiatingMessage(InitiatingMessage::GnbDuConfigurationUpdate(r)).into_bytes()
    }

    fn decode_response(bytes: &[u8]) -> Result<Self::Success, RequestError<Self::Failure>> {
        let response_pdu = Self::TopPdu::from_bytes(bytes)?;
        match response_pdu {
            F1apPdu::SuccessfulOutcome(SuccessfulOutcome::GnbDuConfigurationUpdateAcknowledge(
                x,
            )) => Ok(x),
            F1apPdu::UnsuccessfulOutcome(UnsuccessfulOutcome::GnbDuConfigurationUpdateFailure(
                x,
            )) => Err(RequestError::UnsuccessfulOutcome(x)),
            _ => Err(RequestError::Other("Unexpected pdu contents".to_string())),
        }
    }
}

pub struct GnbCuConfigurationUpdateProcedure {}

#[async_trait]
impl Procedure for GnbCuConfigurationUpdateProcedure {
    type TopPdu = F1apPdu;
    type Request = GnbCuConfigurationUpdate;
    type Success = GnbCuConfigurationUpdateAcknowledge;
    type Failure = GnbCuConfigurationUpdateFailure;
    const CODE: u8 = 4;

    async fn call_provider<T: RequestProvider<Self>>(
        provider: &T,
        req: GnbCuConfigurationUpdate,
        logger: &Logger,
    ) -> Option<F1apPdu> {
        match <T as RequestProvider<GnbCuConfigurationUpdateProcedure>>::request(
            provider, req, logger,
        )
        .await
        {
            Ok(x) => Some(F1apPdu::SuccessfulOutcome(
                SuccessfulOutcome::GnbCuConfigurationUpdateAcknowledge(x),
            )),
            Err(_) => todo!(),
        }
    }

    fn encode_request(r: Self::Request) -> Result<Vec<u8>, AperCodecError> {
        F1apPdu::InitiatingMessage(InitiatingMessage::GnbCuConfigurationUpdate(r)).into_bytes()
    }

    fn decode_response(bytes: &[u8]) -> Result<Self::Success, RequestError<Self::Failure>> {
        let response_pdu = Self::TopPdu::from_bytes(bytes)?;
        match response_pdu {
            F1apPdu::SuccessfulOutcome(SuccessfulOutcome::GnbCuConfigurationUpdateAcknowledge(
                x,
            )) => Ok(x),
            F1apPdu::UnsuccessfulOutcome(UnsuccessfulOutcome::GnbCuConfigurationUpdateFailure(
                x,
            )) => Err(RequestError::UnsuccessfulOutcome(x)),
            _ => Err(RequestError::Other("Unexpected pdu contents".to_string())),
        }
    }
}

pub struct UeContextSetupProcedure {}

#[async_trait]
impl Procedure for UeContextSetupProcedure {
    type TopPdu = F1apPdu;
    type Request = UeContextSetupRequest;
    type Success = UeContextSetupResponse;
    type Failure = UeContextSetupFailure;
    const CODE: u8 = 5;

    async fn call_provider<T: RequestProvider<Self>>(
        provider: &T,
        req: UeContextSetupRequest,
        logger: &Logger,
    ) -> Option<F1apPdu> {
        match <T as RequestProvider<UeContextSetupProcedure>>::request(provider, req, logger).await
        {
            Ok(x) => Some(F1apPdu::SuccessfulOutcome(
                SuccessfulOutcome::UeContextSetupResponse(x),
            )),
            Err(_) => todo!(),
        }
    }

    fn encode_request(r: Self::Request) -> Result<Vec<u8>, AperCodecError> {
        F1apPdu::InitiatingMessage(InitiatingMessage::UeContextSetupRequest(r)).into_bytes()
    }

    fn decode_response(bytes: &[u8]) -> Result<Self::Success, RequestError<Self::Failure>> {
        let response_pdu = Self::TopPdu::from_bytes(bytes)?;
        match response_pdu {
            F1apPdu::SuccessfulOutcome(SuccessfulOutcome::UeContextSetupResponse(x)) => Ok(x),
            F1apPdu::UnsuccessfulOutcome(UnsuccessfulOutcome::UeContextSetupFailure(x)) => {
                Err(RequestError::UnsuccessfulOutcome(x))
            }
            _ => Err(RequestError::Other("Unexpected pdu contents".to_string())),
        }
    }
}

pub struct UeContextReleaseProcedure {}

#[async_trait]
impl Procedure for UeContextReleaseProcedure {
    type TopPdu = F1apPdu;
    type Request = UeContextReleaseCommand;
    type Success = UeContextReleaseComplete;
    type Failure = ();
    const CODE: u8 = 6;

    async fn call_provider<T: RequestProvider<Self>>(
        provider: &T,
        req: UeContextReleaseCommand,
        logger: &Logger,
    ) -> Option<F1apPdu> {
        match <T as RequestProvider<UeContextReleaseProcedure>>::request(provider, req, logger)
            .await
        {
            Ok(x) => Some(F1apPdu::SuccessfulOutcome(
                SuccessfulOutcome::UeContextReleaseComplete(x),
            )),
            Err(_) => todo!(),
        }
    }

    fn encode_request(r: Self::Request) -> Result<Vec<u8>, AperCodecError> {
        F1apPdu::InitiatingMessage(InitiatingMessage::UeContextReleaseCommand(r)).into_bytes()
    }

    fn decode_response(bytes: &[u8]) -> Result<Self::Success, RequestError<Self::Failure>> {
        let response_pdu = Self::TopPdu::from_bytes(bytes)?;
        match response_pdu {
            F1apPdu::SuccessfulOutcome(SuccessfulOutcome::UeContextReleaseComplete(x)) => Ok(x),

            _ => Err(RequestError::Other("Unexpected pdu contents".to_string())),
        }
    }
}

pub struct UeContextModificationProcedure {}

#[async_trait]
impl Procedure for UeContextModificationProcedure {
    type TopPdu = F1apPdu;
    type Request = UeContextModificationRequest;
    type Success = UeContextModificationResponse;
    type Failure = UeContextModificationFailure;
    const CODE: u8 = 7;

    async fn call_provider<T: RequestProvider<Self>>(
        provider: &T,
        req: UeContextModificationRequest,
        logger: &Logger,
    ) -> Option<F1apPdu> {
        match <T as RequestProvider<UeContextModificationProcedure>>::request(provider, req, logger)
            .await
        {
            Ok(x) => Some(F1apPdu::SuccessfulOutcome(
                SuccessfulOutcome::UeContextModificationResponse(x),
            )),
            Err(_) => todo!(),
        }
    }

    fn encode_request(r: Self::Request) -> Result<Vec<u8>, AperCodecError> {
        F1apPdu::InitiatingMessage(InitiatingMessage::UeContextModificationRequest(r)).into_bytes()
    }

    fn decode_response(bytes: &[u8]) -> Result<Self::Success, RequestError<Self::Failure>> {
        let response_pdu = Self::TopPdu::from_bytes(bytes)?;
        match response_pdu {
            F1apPdu::SuccessfulOutcome(SuccessfulOutcome::UeContextModificationResponse(x)) => {
                Ok(x)
            }
            F1apPdu::UnsuccessfulOutcome(UnsuccessfulOutcome::UeContextModificationFailure(x)) => {
                Err(RequestError::UnsuccessfulOutcome(x))
            }
            _ => Err(RequestError::Other("Unexpected pdu contents".to_string())),
        }
    }
}

pub struct UeContextModificationRequiredProcedure {}

#[async_trait]
impl Procedure for UeContextModificationRequiredProcedure {
    type TopPdu = F1apPdu;
    type Request = UeContextModificationRequired;
    type Success = UeContextModificationConfirm;
    type Failure = UeContextModificationRefuse;
    const CODE: u8 = 8;

    async fn call_provider<T: RequestProvider<Self>>(
        provider: &T,
        req: UeContextModificationRequired,
        logger: &Logger,
    ) -> Option<F1apPdu> {
        match <T as RequestProvider<UeContextModificationRequiredProcedure>>::request(
            provider, req, logger,
        )
        .await
        {
            Ok(x) => Some(F1apPdu::SuccessfulOutcome(
                SuccessfulOutcome::UeContextModificationConfirm(x),
            )),
            Err(_) => todo!(),
        }
    }

    fn encode_request(r: Self::Request) -> Result<Vec<u8>, AperCodecError> {
        F1apPdu::InitiatingMessage(InitiatingMessage::UeContextModificationRequired(r)).into_bytes()
    }

    fn decode_response(bytes: &[u8]) -> Result<Self::Success, RequestError<Self::Failure>> {
        let response_pdu = Self::TopPdu::from_bytes(bytes)?;
        match response_pdu {
            F1apPdu::SuccessfulOutcome(SuccessfulOutcome::UeContextModificationConfirm(x)) => Ok(x),
            F1apPdu::UnsuccessfulOutcome(UnsuccessfulOutcome::UeContextModificationRefuse(x)) => {
                Err(RequestError::UnsuccessfulOutcome(x))
            }
            _ => Err(RequestError::Other("Unexpected pdu contents".to_string())),
        }
    }
}

pub struct WriteReplaceWarningProcedure {}

#[async_trait]
impl Procedure for WriteReplaceWarningProcedure {
    type TopPdu = F1apPdu;
    type Request = WriteReplaceWarningRequest;
    type Success = WriteReplaceWarningResponse;
    type Failure = ();
    const CODE: u8 = 20;

    async fn call_provider<T: RequestProvider<Self>>(
        provider: &T,
        req: WriteReplaceWarningRequest,
        logger: &Logger,
    ) -> Option<F1apPdu> {
        match <T as RequestProvider<WriteReplaceWarningProcedure>>::request(provider, req, logger)
            .await
        {
            Ok(x) => Some(F1apPdu::SuccessfulOutcome(
                SuccessfulOutcome::WriteReplaceWarningResponse(x),
            )),
            Err(_) => todo!(),
        }
    }

    fn encode_request(r: Self::Request) -> Result<Vec<u8>, AperCodecError> {
        F1apPdu::InitiatingMessage(InitiatingMessage::WriteReplaceWarningRequest(r)).into_bytes()
    }

    fn decode_response(bytes: &[u8]) -> Result<Self::Success, RequestError<Self::Failure>> {
        let response_pdu = Self::TopPdu::from_bytes(bytes)?;
        match response_pdu {
            F1apPdu::SuccessfulOutcome(SuccessfulOutcome::WriteReplaceWarningResponse(x)) => Ok(x),

            _ => Err(RequestError::Other("Unexpected pdu contents".to_string())),
        }
    }
}

pub struct PwsCancelProcedure {}

#[async_trait]
impl Procedure for PwsCancelProcedure {
    type TopPdu = F1apPdu;
    type Request = PwsCancelRequest;
    type Success = PwsCancelResponse;
    type Failure = ();
    const CODE: u8 = 21;

    async fn call_provider<T: RequestProvider<Self>>(
        provider: &T,
        req: PwsCancelRequest,
        logger: &Logger,
    ) -> Option<F1apPdu> {
        match <T as RequestProvider<PwsCancelProcedure>>::request(provider, req, logger).await {
            Ok(x) => Some(F1apPdu::SuccessfulOutcome(
                SuccessfulOutcome::PwsCancelResponse(x),
            )),
            Err(_) => todo!(),
        }
    }

    fn encode_request(r: Self::Request) -> Result<Vec<u8>, AperCodecError> {
        F1apPdu::InitiatingMessage(InitiatingMessage::PwsCancelRequest(r)).into_bytes()
    }

    fn decode_response(bytes: &[u8]) -> Result<Self::Success, RequestError<Self::Failure>> {
        let response_pdu = Self::TopPdu::from_bytes(bytes)?;
        match response_pdu {
            F1apPdu::SuccessfulOutcome(SuccessfulOutcome::PwsCancelResponse(x)) => Ok(x),

            _ => Err(RequestError::Other("Unexpected pdu contents".to_string())),
        }
    }
}

pub struct ErrorIndicationProcedure {}

#[async_trait]
impl Procedure for ErrorIndicationProcedure {
    type TopPdu = F1apPdu;
    type Request = ErrorIndication;
    type Success = ();
    type Failure = ();
    const CODE: u8 = 2;

    async fn call_provider<T: RequestProvider<Self>>(
        provider: &T,
        req: ErrorIndication,
        logger: &Logger,
    ) -> Option<F1apPdu> {
        match <T as RequestProvider<ErrorIndicationProcedure>>::request(provider, req, logger).await
        {
            Ok(_) => None,
            Err(_) => todo!(),
        }
    }

    fn encode_request(r: Self::Request) -> Result<Vec<u8>, AperCodecError> {
        F1apPdu::InitiatingMessage(InitiatingMessage::ErrorIndication(r)).into_bytes()
    }

    fn decode_response(_bytes: &[u8]) -> Result<Self::Success, RequestError<Self::Failure>> {
        Err(RequestError::Other(
            "No response is defined for ErrorIndication!".to_string(),
        ))
    }
}

pub struct UeContextReleaseRequestProcedure {}

#[async_trait]
impl Procedure for UeContextReleaseRequestProcedure {
    type TopPdu = F1apPdu;
    type Request = UeContextReleaseRequest;
    type Success = ();
    type Failure = ();
    const CODE: u8 = 10;

    async fn call_provider<T: RequestProvider<Self>>(
        provider: &T,
        req: UeContextReleaseRequest,
        logger: &Logger,
    ) -> Option<F1apPdu> {
        match <T as RequestProvider<UeContextReleaseRequestProcedure>>::request(
            provider, req, logger,
        )
        .await
        {
            Ok(_) => None,
            Err(_) => todo!(),
        }
    }

    fn encode_request(r: Self::Request) -> Result<Vec<u8>, AperCodecError> {
        F1apPdu::InitiatingMessage(InitiatingMessage::UeContextReleaseRequest(r)).into_bytes()
    }

    fn decode_response(_bytes: &[u8]) -> Result<Self::Success, RequestError<Self::Failure>> {
        Err(RequestError::Other(
            "No response is defined for UeContextReleaseRequest!".to_string(),
        ))
    }
}

pub struct InitialUlRrcMessageTransferProcedure {}

#[async_trait]
impl Procedure for InitialUlRrcMessageTransferProcedure {
    type TopPdu = F1apPdu;
    type Request = InitialUlRrcMessageTransfer;
    type Success = ();
    type Failure = ();
    const CODE: u8 = 11;

    async fn call_provider<T: RequestProvider<Self>>(
        provider: &T,
        req: InitialUlRrcMessageTransfer,
        logger: &Logger,
    ) -> Option<F1apPdu> {
        match <T as RequestProvider<InitialUlRrcMessageTransferProcedure>>::request(
            provider, req, logger,
        )
        .await
        {
            Ok(_) => None,
            Err(_) => todo!(),
        }
    }

    fn encode_request(r: Self::Request) -> Result<Vec<u8>, AperCodecError> {
        F1apPdu::InitiatingMessage(InitiatingMessage::InitialUlRrcMessageTransfer(r)).into_bytes()
    }

    fn decode_response(_bytes: &[u8]) -> Result<Self::Success, RequestError<Self::Failure>> {
        Err(RequestError::Other(
            "No response is defined for InitialUlRrcMessageTransfer!".to_string(),
        ))
    }
}

pub struct DlRrcMessageTransferProcedure {}

#[async_trait]
impl Procedure for DlRrcMessageTransferProcedure {
    type TopPdu = F1apPdu;
    type Request = DlRrcMessageTransfer;
    type Success = ();
    type Failure = ();
    const CODE: u8 = 12;

    async fn call_provider<T: RequestProvider<Self>>(
        provider: &T,
        req: DlRrcMessageTransfer,
        logger: &Logger,
    ) -> Option<F1apPdu> {
        match <T as RequestProvider<DlRrcMessageTransferProcedure>>::request(provider, req, logger)
            .await
        {
            Ok(_) => None,
            Err(_) => todo!(),
        }
    }

    fn encode_request(r: Self::Request) -> Result<Vec<u8>, AperCodecError> {
        F1apPdu::InitiatingMessage(InitiatingMessage::DlRrcMessageTransfer(r)).into_bytes()
    }

    fn decode_response(_bytes: &[u8]) -> Result<Self::Success, RequestError<Self::Failure>> {
        Err(RequestError::Other(
            "No response is defined for DlRrcMessageTransfer!".to_string(),
        ))
    }
}

pub struct UlRrcMessageTransferProcedure {}

#[async_trait]
impl Procedure for UlRrcMessageTransferProcedure {
    type TopPdu = F1apPdu;
    type Request = UlRrcMessageTransfer;
    type Success = ();
    type Failure = ();
    const CODE: u8 = 13;

    async fn call_provider<T: RequestProvider<Self>>(
        provider: &T,
        req: UlRrcMessageTransfer,
        logger: &Logger,
    ) -> Option<F1apPdu> {
        match <T as RequestProvider<UlRrcMessageTransferProcedure>>::request(provider, req, logger)
            .await
        {
            Ok(_) => None,
            Err(_) => todo!(),
        }
    }

    fn encode_request(r: Self::Request) -> Result<Vec<u8>, AperCodecError> {
        F1apPdu::InitiatingMessage(InitiatingMessage::UlRrcMessageTransfer(r)).into_bytes()
    }

    fn decode_response(_bytes: &[u8]) -> Result<Self::Success, RequestError<Self::Failure>> {
        Err(RequestError::Other(
            "No response is defined for UlRrcMessageTransfer!".to_string(),
        ))
    }
}

pub struct UeInactivityNotificationProcedure {}

#[async_trait]
impl Procedure for UeInactivityNotificationProcedure {
    type TopPdu = F1apPdu;
    type Request = UeInactivityNotification;
    type Success = ();
    type Failure = ();
    const CODE: u8 = 15;

    async fn call_provider<T: RequestProvider<Self>>(
        provider: &T,
        req: UeInactivityNotification,
        logger: &Logger,
    ) -> Option<F1apPdu> {
        match <T as RequestProvider<UeInactivityNotificationProcedure>>::request(
            provider, req, logger,
        )
        .await
        {
            Ok(_) => None,
            Err(_) => todo!(),
        }
    }

    fn encode_request(r: Self::Request) -> Result<Vec<u8>, AperCodecError> {
        F1apPdu::InitiatingMessage(InitiatingMessage::UeInactivityNotification(r)).into_bytes()
    }

    fn decode_response(_bytes: &[u8]) -> Result<Self::Success, RequestError<Self::Failure>> {
        Err(RequestError::Other(
            "No response is defined for UeInactivityNotification!".to_string(),
        ))
    }
}

pub struct GnbDuResourceCoordinationProcedure {}

#[async_trait]
impl Procedure for GnbDuResourceCoordinationProcedure {
    type TopPdu = F1apPdu;
    type Request = GnbDuResourceCoordinationRequest;
    type Success = GnbDuResourceCoordinationResponse;
    type Failure = ();
    const CODE: u8 = 16;

    async fn call_provider<T: RequestProvider<Self>>(
        provider: &T,
        req: GnbDuResourceCoordinationRequest,
        logger: &Logger,
    ) -> Option<F1apPdu> {
        match <T as RequestProvider<GnbDuResourceCoordinationProcedure>>::request(
            provider, req, logger,
        )
        .await
        {
            Ok(x) => Some(F1apPdu::SuccessfulOutcome(
                SuccessfulOutcome::GnbDuResourceCoordinationResponse(x),
            )),
            Err(_) => todo!(),
        }
    }

    fn encode_request(r: Self::Request) -> Result<Vec<u8>, AperCodecError> {
        F1apPdu::InitiatingMessage(InitiatingMessage::GnbDuResourceCoordinationRequest(r))
            .into_bytes()
    }

    fn decode_response(bytes: &[u8]) -> Result<Self::Success, RequestError<Self::Failure>> {
        let response_pdu = Self::TopPdu::from_bytes(bytes)?;
        match response_pdu {
            F1apPdu::SuccessfulOutcome(SuccessfulOutcome::GnbDuResourceCoordinationResponse(x)) => {
                Ok(x)
            }

            _ => Err(RequestError::Other("Unexpected pdu contents".to_string())),
        }
    }
}

pub struct SystemInformationDeliveryProcedure {}

#[async_trait]
impl Procedure for SystemInformationDeliveryProcedure {
    type TopPdu = F1apPdu;
    type Request = SystemInformationDeliveryCommand;
    type Success = ();
    type Failure = ();
    const CODE: u8 = 17;

    async fn call_provider<T: RequestProvider<Self>>(
        provider: &T,
        req: SystemInformationDeliveryCommand,
        logger: &Logger,
    ) -> Option<F1apPdu> {
        match <T as RequestProvider<SystemInformationDeliveryProcedure>>::request(
            provider, req, logger,
        )
        .await
        {
            Ok(_) => None,
            Err(_) => todo!(),
        }
    }

    fn encode_request(r: Self::Request) -> Result<Vec<u8>, AperCodecError> {
        F1apPdu::InitiatingMessage(InitiatingMessage::SystemInformationDeliveryCommand(r))
            .into_bytes()
    }

    fn decode_response(_bytes: &[u8]) -> Result<Self::Success, RequestError<Self::Failure>> {
        Err(RequestError::Other(
            "No response is defined for SystemInformationDeliveryCommand!".to_string(),
        ))
    }
}

pub struct PagingProcedure {}

#[async_trait]
impl Procedure for PagingProcedure {
    type TopPdu = F1apPdu;
    type Request = Paging;
    type Success = ();
    type Failure = ();
    const CODE: u8 = 18;

    async fn call_provider<T: RequestProvider<Self>>(
        provider: &T,
        req: Paging,
        logger: &Logger,
    ) -> Option<F1apPdu> {
        match <T as RequestProvider<PagingProcedure>>::request(provider, req, logger).await {
            Ok(_) => None,
            Err(_) => todo!(),
        }
    }

    fn encode_request(r: Self::Request) -> Result<Vec<u8>, AperCodecError> {
        F1apPdu::InitiatingMessage(InitiatingMessage::Paging(r)).into_bytes()
    }

    fn decode_response(_bytes: &[u8]) -> Result<Self::Success, RequestError<Self::Failure>> {
        Err(RequestError::Other(
            "No response is defined for Paging!".to_string(),
        ))
    }
}

pub struct NotifyProcedure {}

#[async_trait]
impl Procedure for NotifyProcedure {
    type TopPdu = F1apPdu;
    type Request = Notify;
    type Success = ();
    type Failure = ();
    const CODE: u8 = 19;

    async fn call_provider<T: RequestProvider<Self>>(
        provider: &T,
        req: Notify,
        logger: &Logger,
    ) -> Option<F1apPdu> {
        match <T as RequestProvider<NotifyProcedure>>::request(provider, req, logger).await {
            Ok(_) => None,
            Err(_) => todo!(),
        }
    }

    fn encode_request(r: Self::Request) -> Result<Vec<u8>, AperCodecError> {
        F1apPdu::InitiatingMessage(InitiatingMessage::Notify(r)).into_bytes()
    }

    fn decode_response(_bytes: &[u8]) -> Result<Self::Success, RequestError<Self::Failure>> {
        Err(RequestError::Other(
            "No response is defined for Notify!".to_string(),
        ))
    }
}

pub struct NetworkAccessRateReductionProcedure {}

#[async_trait]
impl Procedure for NetworkAccessRateReductionProcedure {
    type TopPdu = F1apPdu;
    type Request = NetworkAccessRateReduction;
    type Success = ();
    type Failure = ();
    const CODE: u8 = 27;

    async fn call_provider<T: RequestProvider<Self>>(
        provider: &T,
        req: NetworkAccessRateReduction,
        logger: &Logger,
    ) -> Option<F1apPdu> {
        match <T as RequestProvider<NetworkAccessRateReductionProcedure>>::request(
            provider, req, logger,
        )
        .await
        {
            Ok(_) => None,
            Err(_) => todo!(),
        }
    }

    fn encode_request(r: Self::Request) -> Result<Vec<u8>, AperCodecError> {
        F1apPdu::InitiatingMessage(InitiatingMessage::NetworkAccessRateReduction(r)).into_bytes()
    }

    fn decode_response(_bytes: &[u8]) -> Result<Self::Success, RequestError<Self::Failure>> {
        Err(RequestError::Other(
            "No response is defined for NetworkAccessRateReduction!".to_string(),
        ))
    }
}

pub struct PwsRestartIndicationProcedure {}

#[async_trait]
impl Procedure for PwsRestartIndicationProcedure {
    type TopPdu = F1apPdu;
    type Request = PwsRestartIndication;
    type Success = ();
    type Failure = ();
    const CODE: u8 = 22;

    async fn call_provider<T: RequestProvider<Self>>(
        provider: &T,
        req: PwsRestartIndication,
        logger: &Logger,
    ) -> Option<F1apPdu> {
        match <T as RequestProvider<PwsRestartIndicationProcedure>>::request(provider, req, logger)
            .await
        {
            Ok(_) => None,
            Err(_) => todo!(),
        }
    }

    fn encode_request(r: Self::Request) -> Result<Vec<u8>, AperCodecError> {
        F1apPdu::InitiatingMessage(InitiatingMessage::PwsRestartIndication(r)).into_bytes()
    }

    fn decode_response(_bytes: &[u8]) -> Result<Self::Success, RequestError<Self::Failure>> {
        Err(RequestError::Other(
            "No response is defined for PwsRestartIndication!".to_string(),
        ))
    }
}

pub struct PwsFailureIndicationProcedure {}

#[async_trait]
impl Procedure for PwsFailureIndicationProcedure {
    type TopPdu = F1apPdu;
    type Request = PwsFailureIndication;
    type Success = ();
    type Failure = ();
    const CODE: u8 = 23;

    async fn call_provider<T: RequestProvider<Self>>(
        provider: &T,
        req: PwsFailureIndication,
        logger: &Logger,
    ) -> Option<F1apPdu> {
        match <T as RequestProvider<PwsFailureIndicationProcedure>>::request(provider, req, logger)
            .await
        {
            Ok(_) => None,
            Err(_) => todo!(),
        }
    }

    fn encode_request(r: Self::Request) -> Result<Vec<u8>, AperCodecError> {
        F1apPdu::InitiatingMessage(InitiatingMessage::PwsFailureIndication(r)).into_bytes()
    }

    fn decode_response(_bytes: &[u8]) -> Result<Self::Success, RequestError<Self::Failure>> {
        Err(RequestError::Other(
            "No response is defined for PwsFailureIndication!".to_string(),
        ))
    }
}

pub struct GnbDuStatusIndicationProcedure {}

#[async_trait]
impl Procedure for GnbDuStatusIndicationProcedure {
    type TopPdu = F1apPdu;
    type Request = GnbDuStatusIndication;
    type Success = ();
    type Failure = ();
    const CODE: u8 = 24;

    async fn call_provider<T: RequestProvider<Self>>(
        provider: &T,
        req: GnbDuStatusIndication,
        logger: &Logger,
    ) -> Option<F1apPdu> {
        match <T as RequestProvider<GnbDuStatusIndicationProcedure>>::request(provider, req, logger)
            .await
        {
            Ok(_) => None,
            Err(_) => todo!(),
        }
    }

    fn encode_request(r: Self::Request) -> Result<Vec<u8>, AperCodecError> {
        F1apPdu::InitiatingMessage(InitiatingMessage::GnbDuStatusIndication(r)).into_bytes()
    }

    fn decode_response(_bytes: &[u8]) -> Result<Self::Success, RequestError<Self::Failure>> {
        Err(RequestError::Other(
            "No response is defined for GnbDuStatusIndication!".to_string(),
        ))
    }
}

pub struct RrcDeliveryReportProcedure {}

#[async_trait]
impl Procedure for RrcDeliveryReportProcedure {
    type TopPdu = F1apPdu;
    type Request = RrcDeliveryReport;
    type Success = ();
    type Failure = ();
    const CODE: u8 = 25;

    async fn call_provider<T: RequestProvider<Self>>(
        provider: &T,
        req: RrcDeliveryReport,
        logger: &Logger,
    ) -> Option<F1apPdu> {
        match <T as RequestProvider<RrcDeliveryReportProcedure>>::request(provider, req, logger)
            .await
        {
            Ok(_) => None,
            Err(_) => todo!(),
        }
    }

    fn encode_request(r: Self::Request) -> Result<Vec<u8>, AperCodecError> {
        F1apPdu::InitiatingMessage(InitiatingMessage::RrcDeliveryReport(r)).into_bytes()
    }

    fn decode_response(_bytes: &[u8]) -> Result<Self::Success, RequestError<Self::Failure>> {
        Err(RequestError::Other(
            "No response is defined for RrcDeliveryReport!".to_string(),
        ))
    }
}

pub struct F1RemovalProcedure {}

#[async_trait]
impl Procedure for F1RemovalProcedure {
    type TopPdu = F1apPdu;
    type Request = F1RemovalRequest;
    type Success = F1RemovalResponse;
    type Failure = F1RemovalFailure;
    const CODE: u8 = 26;

    async fn call_provider<T: RequestProvider<Self>>(
        provider: &T,
        req: F1RemovalRequest,
        logger: &Logger,
    ) -> Option<F1apPdu> {
        match <T as RequestProvider<F1RemovalProcedure>>::request(provider, req, logger).await {
            Ok(x) => Some(F1apPdu::SuccessfulOutcome(
                SuccessfulOutcome::F1RemovalResponse(x),
            )),
            Err(_) => todo!(),
        }
    }

    fn encode_request(r: Self::Request) -> Result<Vec<u8>, AperCodecError> {
        F1apPdu::InitiatingMessage(InitiatingMessage::F1RemovalRequest(r)).into_bytes()
    }

    fn decode_response(bytes: &[u8]) -> Result<Self::Success, RequestError<Self::Failure>> {
        let response_pdu = Self::TopPdu::from_bytes(bytes)?;
        match response_pdu {
            F1apPdu::SuccessfulOutcome(SuccessfulOutcome::F1RemovalResponse(x)) => Ok(x),
            F1apPdu::UnsuccessfulOutcome(UnsuccessfulOutcome::F1RemovalFailure(x)) => {
                Err(RequestError::UnsuccessfulOutcome(x))
            }
            _ => Err(RequestError::Other("Unexpected pdu contents".to_string())),
        }
    }
}

pub struct TraceStartProcedure {}

#[async_trait]
impl Procedure for TraceStartProcedure {
    type TopPdu = F1apPdu;
    type Request = TraceStart;
    type Success = ();
    type Failure = ();
    const CODE: u8 = 28;

    async fn call_provider<T: RequestProvider<Self>>(
        provider: &T,
        req: TraceStart,
        logger: &Logger,
    ) -> Option<F1apPdu> {
        match <T as RequestProvider<TraceStartProcedure>>::request(provider, req, logger).await {
            Ok(_) => None,
            Err(_) => todo!(),
        }
    }

    fn encode_request(r: Self::Request) -> Result<Vec<u8>, AperCodecError> {
        F1apPdu::InitiatingMessage(InitiatingMessage::TraceStart(r)).into_bytes()
    }

    fn decode_response(_bytes: &[u8]) -> Result<Self::Success, RequestError<Self::Failure>> {
        Err(RequestError::Other(
            "No response is defined for TraceStart!".to_string(),
        ))
    }
}

pub struct DeactivateTraceProcedure {}

#[async_trait]
impl Procedure for DeactivateTraceProcedure {
    type TopPdu = F1apPdu;
    type Request = DeactivateTrace;
    type Success = ();
    type Failure = ();
    const CODE: u8 = 29;

    async fn call_provider<T: RequestProvider<Self>>(
        provider: &T,
        req: DeactivateTrace,
        logger: &Logger,
    ) -> Option<F1apPdu> {
        match <T as RequestProvider<DeactivateTraceProcedure>>::request(provider, req, logger).await
        {
            Ok(_) => None,
            Err(_) => todo!(),
        }
    }

    fn encode_request(r: Self::Request) -> Result<Vec<u8>, AperCodecError> {
        F1apPdu::InitiatingMessage(InitiatingMessage::DeactivateTrace(r)).into_bytes()
    }

    fn decode_response(_bytes: &[u8]) -> Result<Self::Success, RequestError<Self::Failure>> {
        Err(RequestError::Other(
            "No response is defined for DeactivateTrace!".to_string(),
        ))
    }
}

pub struct DuCuRadioInformationTransferProcedure {}

#[async_trait]
impl Procedure for DuCuRadioInformationTransferProcedure {
    type TopPdu = F1apPdu;
    type Request = DuCuRadioInformationTransfer;
    type Success = ();
    type Failure = ();
    const CODE: u8 = 30;

    async fn call_provider<T: RequestProvider<Self>>(
        provider: &T,
        req: DuCuRadioInformationTransfer,
        logger: &Logger,
    ) -> Option<F1apPdu> {
        match <T as RequestProvider<DuCuRadioInformationTransferProcedure>>::request(
            provider, req, logger,
        )
        .await
        {
            Ok(_) => None,
            Err(_) => todo!(),
        }
    }

    fn encode_request(r: Self::Request) -> Result<Vec<u8>, AperCodecError> {
        F1apPdu::InitiatingMessage(InitiatingMessage::DuCuRadioInformationTransfer(r)).into_bytes()
    }

    fn decode_response(_bytes: &[u8]) -> Result<Self::Success, RequestError<Self::Failure>> {
        Err(RequestError::Other(
            "No response is defined for DuCuRadioInformationTransfer!".to_string(),
        ))
    }
}

pub struct CuDuRadioInformationTransferProcedure {}

#[async_trait]
impl Procedure for CuDuRadioInformationTransferProcedure {
    type TopPdu = F1apPdu;
    type Request = CuDuRadioInformationTransfer;
    type Success = ();
    type Failure = ();
    const CODE: u8 = 31;

    async fn call_provider<T: RequestProvider<Self>>(
        provider: &T,
        req: CuDuRadioInformationTransfer,
        logger: &Logger,
    ) -> Option<F1apPdu> {
        match <T as RequestProvider<CuDuRadioInformationTransferProcedure>>::request(
            provider, req, logger,
        )
        .await
        {
            Ok(_) => None,
            Err(_) => todo!(),
        }
    }

    fn encode_request(r: Self::Request) -> Result<Vec<u8>, AperCodecError> {
        F1apPdu::InitiatingMessage(InitiatingMessage::CuDuRadioInformationTransfer(r)).into_bytes()
    }

    fn decode_response(_bytes: &[u8]) -> Result<Self::Success, RequestError<Self::Failure>> {
        Err(RequestError::Other(
            "No response is defined for CuDuRadioInformationTransfer!".to_string(),
        ))
    }
}

pub struct BapMappingConfigurationProcedure {}

#[async_trait]
impl Procedure for BapMappingConfigurationProcedure {
    type TopPdu = F1apPdu;
    type Request = BapMappingConfiguration;
    type Success = BapMappingConfigurationAcknowledge;
    type Failure = BapMappingConfigurationFailure;
    const CODE: u8 = 32;

    async fn call_provider<T: RequestProvider<Self>>(
        provider: &T,
        req: BapMappingConfiguration,
        logger: &Logger,
    ) -> Option<F1apPdu> {
        match <T as RequestProvider<BapMappingConfigurationProcedure>>::request(
            provider, req, logger,
        )
        .await
        {
            Ok(x) => Some(F1apPdu::SuccessfulOutcome(
                SuccessfulOutcome::BapMappingConfigurationAcknowledge(x),
            )),
            Err(_) => todo!(),
        }
    }

    fn encode_request(r: Self::Request) -> Result<Vec<u8>, AperCodecError> {
        F1apPdu::InitiatingMessage(InitiatingMessage::BapMappingConfiguration(r)).into_bytes()
    }

    fn decode_response(bytes: &[u8]) -> Result<Self::Success, RequestError<Self::Failure>> {
        let response_pdu = Self::TopPdu::from_bytes(bytes)?;
        match response_pdu {
            F1apPdu::SuccessfulOutcome(SuccessfulOutcome::BapMappingConfigurationAcknowledge(
                x,
            )) => Ok(x),
            F1apPdu::UnsuccessfulOutcome(UnsuccessfulOutcome::BapMappingConfigurationFailure(
                x,
            )) => Err(RequestError::UnsuccessfulOutcome(x)),
            _ => Err(RequestError::Other("Unexpected pdu contents".to_string())),
        }
    }
}

pub struct GnbDuResourceConfigurationProcedure {}

#[async_trait]
impl Procedure for GnbDuResourceConfigurationProcedure {
    type TopPdu = F1apPdu;
    type Request = GnbDuResourceConfiguration;
    type Success = GnbDuResourceConfigurationAcknowledge;
    type Failure = GnbDuResourceConfigurationFailure;
    const CODE: u8 = 33;

    async fn call_provider<T: RequestProvider<Self>>(
        provider: &T,
        req: GnbDuResourceConfiguration,
        logger: &Logger,
    ) -> Option<F1apPdu> {
        match <T as RequestProvider<GnbDuResourceConfigurationProcedure>>::request(
            provider, req, logger,
        )
        .await
        {
            Ok(x) => Some(F1apPdu::SuccessfulOutcome(
                SuccessfulOutcome::GnbDuResourceConfigurationAcknowledge(x),
            )),
            Err(_) => todo!(),
        }
    }

    fn encode_request(r: Self::Request) -> Result<Vec<u8>, AperCodecError> {
        F1apPdu::InitiatingMessage(InitiatingMessage::GnbDuResourceConfiguration(r)).into_bytes()
    }

    fn decode_response(bytes: &[u8]) -> Result<Self::Success, RequestError<Self::Failure>> {
        let response_pdu = Self::TopPdu::from_bytes(bytes)?;
        match response_pdu {
            F1apPdu::SuccessfulOutcome(
                SuccessfulOutcome::GnbDuResourceConfigurationAcknowledge(x),
            ) => Ok(x),
            F1apPdu::UnsuccessfulOutcome(
                UnsuccessfulOutcome::GnbDuResourceConfigurationFailure(x),
            ) => Err(RequestError::UnsuccessfulOutcome(x)),
            _ => Err(RequestError::Other("Unexpected pdu contents".to_string())),
        }
    }
}

pub struct IabtnlAddressAllocationProcedure {}

#[async_trait]
impl Procedure for IabtnlAddressAllocationProcedure {
    type TopPdu = F1apPdu;
    type Request = IabtnlAddressRequest;
    type Success = IabtnlAddressResponse;
    type Failure = IabtnlAddressFailure;
    const CODE: u8 = 34;

    async fn call_provider<T: RequestProvider<Self>>(
        provider: &T,
        req: IabtnlAddressRequest,
        logger: &Logger,
    ) -> Option<F1apPdu> {
        match <T as RequestProvider<IabtnlAddressAllocationProcedure>>::request(
            provider, req, logger,
        )
        .await
        {
            Ok(x) => Some(F1apPdu::SuccessfulOutcome(
                SuccessfulOutcome::IabtnlAddressResponse(x),
            )),
            Err(_) => todo!(),
        }
    }

    fn encode_request(r: Self::Request) -> Result<Vec<u8>, AperCodecError> {
        F1apPdu::InitiatingMessage(InitiatingMessage::IabtnlAddressRequest(r)).into_bytes()
    }

    fn decode_response(bytes: &[u8]) -> Result<Self::Success, RequestError<Self::Failure>> {
        let response_pdu = Self::TopPdu::from_bytes(bytes)?;
        match response_pdu {
            F1apPdu::SuccessfulOutcome(SuccessfulOutcome::IabtnlAddressResponse(x)) => Ok(x),
            F1apPdu::UnsuccessfulOutcome(UnsuccessfulOutcome::IabtnlAddressFailure(x)) => {
                Err(RequestError::UnsuccessfulOutcome(x))
            }
            _ => Err(RequestError::Other("Unexpected pdu contents".to_string())),
        }
    }
}

pub struct IabupConfigurationUpdateProcedure {}

#[async_trait]
impl Procedure for IabupConfigurationUpdateProcedure {
    type TopPdu = F1apPdu;
    type Request = IabupConfigurationUpdateRequest;
    type Success = IabupConfigurationUpdateResponse;
    type Failure = IabupConfigurationUpdateFailure;
    const CODE: u8 = 35;

    async fn call_provider<T: RequestProvider<Self>>(
        provider: &T,
        req: IabupConfigurationUpdateRequest,
        logger: &Logger,
    ) -> Option<F1apPdu> {
        match <T as RequestProvider<IabupConfigurationUpdateProcedure>>::request(
            provider, req, logger,
        )
        .await
        {
            Ok(x) => Some(F1apPdu::SuccessfulOutcome(
                SuccessfulOutcome::IabupConfigurationUpdateResponse(x),
            )),
            Err(_) => todo!(),
        }
    }

    fn encode_request(r: Self::Request) -> Result<Vec<u8>, AperCodecError> {
        F1apPdu::InitiatingMessage(InitiatingMessage::IabupConfigurationUpdateRequest(r))
            .into_bytes()
    }

    fn decode_response(bytes: &[u8]) -> Result<Self::Success, RequestError<Self::Failure>> {
        let response_pdu = Self::TopPdu::from_bytes(bytes)?;
        match response_pdu {
            F1apPdu::SuccessfulOutcome(SuccessfulOutcome::IabupConfigurationUpdateResponse(x)) => {
                Ok(x)
            }
            F1apPdu::UnsuccessfulOutcome(UnsuccessfulOutcome::IabupConfigurationUpdateFailure(
                x,
            )) => Err(RequestError::UnsuccessfulOutcome(x)),
            _ => Err(RequestError::Other("Unexpected pdu contents".to_string())),
        }
    }
}

pub struct ResourceStatusReportingInitiationProcedure {}

#[async_trait]
impl Procedure for ResourceStatusReportingInitiationProcedure {
    type TopPdu = F1apPdu;
    type Request = ResourceStatusRequest;
    type Success = ResourceStatusResponse;
    type Failure = ResourceStatusFailure;
    const CODE: u8 = 36;

    async fn call_provider<T: RequestProvider<Self>>(
        provider: &T,
        req: ResourceStatusRequest,
        logger: &Logger,
    ) -> Option<F1apPdu> {
        match <T as RequestProvider<ResourceStatusReportingInitiationProcedure>>::request(
            provider, req, logger,
        )
        .await
        {
            Ok(x) => Some(F1apPdu::SuccessfulOutcome(
                SuccessfulOutcome::ResourceStatusResponse(x),
            )),
            Err(_) => todo!(),
        }
    }

    fn encode_request(r: Self::Request) -> Result<Vec<u8>, AperCodecError> {
        F1apPdu::InitiatingMessage(InitiatingMessage::ResourceStatusRequest(r)).into_bytes()
    }

    fn decode_response(bytes: &[u8]) -> Result<Self::Success, RequestError<Self::Failure>> {
        let response_pdu = Self::TopPdu::from_bytes(bytes)?;
        match response_pdu {
            F1apPdu::SuccessfulOutcome(SuccessfulOutcome::ResourceStatusResponse(x)) => Ok(x),
            F1apPdu::UnsuccessfulOutcome(UnsuccessfulOutcome::ResourceStatusFailure(x)) => {
                Err(RequestError::UnsuccessfulOutcome(x))
            }
            _ => Err(RequestError::Other("Unexpected pdu contents".to_string())),
        }
    }
}

pub struct ResourceStatusReportingProcedure {}

#[async_trait]
impl Procedure for ResourceStatusReportingProcedure {
    type TopPdu = F1apPdu;
    type Request = ResourceStatusUpdate;
    type Success = ();
    type Failure = ();
    const CODE: u8 = 37;

    async fn call_provider<T: RequestProvider<Self>>(
        provider: &T,
        req: ResourceStatusUpdate,
        logger: &Logger,
    ) -> Option<F1apPdu> {
        match <T as RequestProvider<ResourceStatusReportingProcedure>>::request(
            provider, req, logger,
        )
        .await
        {
            Ok(_) => None,
            Err(_) => todo!(),
        }
    }

    fn encode_request(r: Self::Request) -> Result<Vec<u8>, AperCodecError> {
        F1apPdu::InitiatingMessage(InitiatingMessage::ResourceStatusUpdate(r)).into_bytes()
    }

    fn decode_response(_bytes: &[u8]) -> Result<Self::Success, RequestError<Self::Failure>> {
        Err(RequestError::Other(
            "No response is defined for ResourceStatusUpdate!".to_string(),
        ))
    }
}

pub struct AccessAndMobilityIndicationProcedure {}

#[async_trait]
impl Procedure for AccessAndMobilityIndicationProcedure {
    type TopPdu = F1apPdu;
    type Request = AccessAndMobilityIndication;
    type Success = ();
    type Failure = ();
    const CODE: u8 = 38;

    async fn call_provider<T: RequestProvider<Self>>(
        provider: &T,
        req: AccessAndMobilityIndication,
        logger: &Logger,
    ) -> Option<F1apPdu> {
        match <T as RequestProvider<AccessAndMobilityIndicationProcedure>>::request(
            provider, req, logger,
        )
        .await
        {
            Ok(_) => None,
            Err(_) => todo!(),
        }
    }

    fn encode_request(r: Self::Request) -> Result<Vec<u8>, AperCodecError> {
        F1apPdu::InitiatingMessage(InitiatingMessage::AccessAndMobilityIndication(r)).into_bytes()
    }

    fn decode_response(_bytes: &[u8]) -> Result<Self::Success, RequestError<Self::Failure>> {
        Err(RequestError::Other(
            "No response is defined for AccessAndMobilityIndication!".to_string(),
        ))
    }
}

pub struct ReferenceTimeInformationReportingControlProcedure {}

#[async_trait]
impl Procedure for ReferenceTimeInformationReportingControlProcedure {
    type TopPdu = F1apPdu;
    type Request = ReferenceTimeInformationReportingControl;
    type Success = ();
    type Failure = ();
    const CODE: u8 = 58;

    async fn call_provider<T: RequestProvider<Self>>(
        provider: &T,
        req: ReferenceTimeInformationReportingControl,
        logger: &Logger,
    ) -> Option<F1apPdu> {
        match <T as RequestProvider<ReferenceTimeInformationReportingControlProcedure>>::request(
            provider, req, logger,
        )
        .await
        {
            Ok(_) => None,
            Err(_) => todo!(),
        }
    }

    fn encode_request(r: Self::Request) -> Result<Vec<u8>, AperCodecError> {
        F1apPdu::InitiatingMessage(InitiatingMessage::ReferenceTimeInformationReportingControl(
            r,
        ))
        .into_bytes()
    }

    fn decode_response(_bytes: &[u8]) -> Result<Self::Success, RequestError<Self::Failure>> {
        Err(RequestError::Other(
            "No response is defined for ReferenceTimeInformationReportingControl!".to_string(),
        ))
    }
}

pub struct ReferenceTimeInformationReportProcedure {}

#[async_trait]
impl Procedure for ReferenceTimeInformationReportProcedure {
    type TopPdu = F1apPdu;
    type Request = ReferenceTimeInformationReport;
    type Success = ();
    type Failure = ();
    const CODE: u8 = 57;

    async fn call_provider<T: RequestProvider<Self>>(
        provider: &T,
        req: ReferenceTimeInformationReport,
        logger: &Logger,
    ) -> Option<F1apPdu> {
        match <T as RequestProvider<ReferenceTimeInformationReportProcedure>>::request(
            provider, req, logger,
        )
        .await
        {
            Ok(_) => None,
            Err(_) => todo!(),
        }
    }

    fn encode_request(r: Self::Request) -> Result<Vec<u8>, AperCodecError> {
        F1apPdu::InitiatingMessage(InitiatingMessage::ReferenceTimeInformationReport(r))
            .into_bytes()
    }

    fn decode_response(_bytes: &[u8]) -> Result<Self::Success, RequestError<Self::Failure>> {
        Err(RequestError::Other(
            "No response is defined for ReferenceTimeInformationReport!".to_string(),
        ))
    }
}

pub struct AccessSuccessProcedure {}

#[async_trait]
impl Procedure for AccessSuccessProcedure {
    type TopPdu = F1apPdu;
    type Request = AccessSuccess;
    type Success = ();
    type Failure = ();
    const CODE: u8 = 39;

    async fn call_provider<T: RequestProvider<Self>>(
        provider: &T,
        req: AccessSuccess,
        logger: &Logger,
    ) -> Option<F1apPdu> {
        match <T as RequestProvider<AccessSuccessProcedure>>::request(provider, req, logger).await {
            Ok(_) => None,
            Err(_) => todo!(),
        }
    }

    fn encode_request(r: Self::Request) -> Result<Vec<u8>, AperCodecError> {
        F1apPdu::InitiatingMessage(InitiatingMessage::AccessSuccess(r)).into_bytes()
    }

    fn decode_response(_bytes: &[u8]) -> Result<Self::Success, RequestError<Self::Failure>> {
        Err(RequestError::Other(
            "No response is defined for AccessSuccess!".to_string(),
        ))
    }
}

pub struct CellTrafficTraceProcedure {}

#[async_trait]
impl Procedure for CellTrafficTraceProcedure {
    type TopPdu = F1apPdu;
    type Request = CellTrafficTrace;
    type Success = ();
    type Failure = ();
    const CODE: u8 = 40;

    async fn call_provider<T: RequestProvider<Self>>(
        provider: &T,
        req: CellTrafficTrace,
        logger: &Logger,
    ) -> Option<F1apPdu> {
        match <T as RequestProvider<CellTrafficTraceProcedure>>::request(provider, req, logger)
            .await
        {
            Ok(_) => None,
            Err(_) => todo!(),
        }
    }

    fn encode_request(r: Self::Request) -> Result<Vec<u8>, AperCodecError> {
        F1apPdu::InitiatingMessage(InitiatingMessage::CellTrafficTrace(r)).into_bytes()
    }

    fn decode_response(_bytes: &[u8]) -> Result<Self::Success, RequestError<Self::Failure>> {
        Err(RequestError::Other(
            "No response is defined for CellTrafficTrace!".to_string(),
        ))
    }
}

pub struct PositioningAssistanceInformationControlProcedure {}

#[async_trait]
impl Procedure for PositioningAssistanceInformationControlProcedure {
    type TopPdu = F1apPdu;
    type Request = PositioningAssistanceInformationControl;
    type Success = ();
    type Failure = ();
    const CODE: u8 = 42;

    async fn call_provider<T: RequestProvider<Self>>(
        provider: &T,
        req: PositioningAssistanceInformationControl,
        logger: &Logger,
    ) -> Option<F1apPdu> {
        match <T as RequestProvider<PositioningAssistanceInformationControlProcedure>>::request(
            provider, req, logger,
        )
        .await
        {
            Ok(_) => None,
            Err(_) => todo!(),
        }
    }

    fn encode_request(r: Self::Request) -> Result<Vec<u8>, AperCodecError> {
        F1apPdu::InitiatingMessage(InitiatingMessage::PositioningAssistanceInformationControl(
            r,
        ))
        .into_bytes()
    }

    fn decode_response(_bytes: &[u8]) -> Result<Self::Success, RequestError<Self::Failure>> {
        Err(RequestError::Other(
            "No response is defined for PositioningAssistanceInformationControl!".to_string(),
        ))
    }
}

pub struct PositioningAssistanceInformationFeedbackProcedure {}

#[async_trait]
impl Procedure for PositioningAssistanceInformationFeedbackProcedure {
    type TopPdu = F1apPdu;
    type Request = PositioningAssistanceInformationFeedback;
    type Success = ();
    type Failure = ();
    const CODE: u8 = 43;

    async fn call_provider<T: RequestProvider<Self>>(
        provider: &T,
        req: PositioningAssistanceInformationFeedback,
        logger: &Logger,
    ) -> Option<F1apPdu> {
        match <T as RequestProvider<PositioningAssistanceInformationFeedbackProcedure>>::request(
            provider, req, logger,
        )
        .await
        {
            Ok(_) => None,
            Err(_) => todo!(),
        }
    }

    fn encode_request(r: Self::Request) -> Result<Vec<u8>, AperCodecError> {
        F1apPdu::InitiatingMessage(InitiatingMessage::PositioningAssistanceInformationFeedback(
            r,
        ))
        .into_bytes()
    }

    fn decode_response(_bytes: &[u8]) -> Result<Self::Success, RequestError<Self::Failure>> {
        Err(RequestError::Other(
            "No response is defined for PositioningAssistanceInformationFeedback!".to_string(),
        ))
    }
}

pub struct PositioningMeasurementExchangeProcedure {}

#[async_trait]
impl Procedure for PositioningMeasurementExchangeProcedure {
    type TopPdu = F1apPdu;
    type Request = PositioningMeasurementRequest;
    type Success = PositioningMeasurementResponse;
    type Failure = PositioningMeasurementFailure;
    const CODE: u8 = 41;

    async fn call_provider<T: RequestProvider<Self>>(
        provider: &T,
        req: PositioningMeasurementRequest,
        logger: &Logger,
    ) -> Option<F1apPdu> {
        match <T as RequestProvider<PositioningMeasurementExchangeProcedure>>::request(
            provider, req, logger,
        )
        .await
        {
            Ok(x) => Some(F1apPdu::SuccessfulOutcome(
                SuccessfulOutcome::PositioningMeasurementResponse(x),
            )),
            Err(_) => todo!(),
        }
    }

    fn encode_request(r: Self::Request) -> Result<Vec<u8>, AperCodecError> {
        F1apPdu::InitiatingMessage(InitiatingMessage::PositioningMeasurementRequest(r)).into_bytes()
    }

    fn decode_response(bytes: &[u8]) -> Result<Self::Success, RequestError<Self::Failure>> {
        let response_pdu = Self::TopPdu::from_bytes(bytes)?;
        match response_pdu {
            F1apPdu::SuccessfulOutcome(SuccessfulOutcome::PositioningMeasurementResponse(x)) => {
                Ok(x)
            }
            F1apPdu::UnsuccessfulOutcome(UnsuccessfulOutcome::PositioningMeasurementFailure(x)) => {
                Err(RequestError::UnsuccessfulOutcome(x))
            }
            _ => Err(RequestError::Other("Unexpected pdu contents".to_string())),
        }
    }
}

pub struct PositioningMeasurementReportProcedure {}

#[async_trait]
impl Procedure for PositioningMeasurementReportProcedure {
    type TopPdu = F1apPdu;
    type Request = PositioningMeasurementReport;
    type Success = ();
    type Failure = ();
    const CODE: u8 = 44;

    async fn call_provider<T: RequestProvider<Self>>(
        provider: &T,
        req: PositioningMeasurementReport,
        logger: &Logger,
    ) -> Option<F1apPdu> {
        match <T as RequestProvider<PositioningMeasurementReportProcedure>>::request(
            provider, req, logger,
        )
        .await
        {
            Ok(_) => None,
            Err(_) => todo!(),
        }
    }

    fn encode_request(r: Self::Request) -> Result<Vec<u8>, AperCodecError> {
        F1apPdu::InitiatingMessage(InitiatingMessage::PositioningMeasurementReport(r)).into_bytes()
    }

    fn decode_response(_bytes: &[u8]) -> Result<Self::Success, RequestError<Self::Failure>> {
        Err(RequestError::Other(
            "No response is defined for PositioningMeasurementReport!".to_string(),
        ))
    }
}

pub struct PositioningMeasurementAbortProcedure {}

#[async_trait]
impl Procedure for PositioningMeasurementAbortProcedure {
    type TopPdu = F1apPdu;
    type Request = PositioningMeasurementAbort;
    type Success = ();
    type Failure = ();
    const CODE: u8 = 45;

    async fn call_provider<T: RequestProvider<Self>>(
        provider: &T,
        req: PositioningMeasurementAbort,
        logger: &Logger,
    ) -> Option<F1apPdu> {
        match <T as RequestProvider<PositioningMeasurementAbortProcedure>>::request(
            provider, req, logger,
        )
        .await
        {
            Ok(_) => None,
            Err(_) => todo!(),
        }
    }

    fn encode_request(r: Self::Request) -> Result<Vec<u8>, AperCodecError> {
        F1apPdu::InitiatingMessage(InitiatingMessage::PositioningMeasurementAbort(r)).into_bytes()
    }

    fn decode_response(_bytes: &[u8]) -> Result<Self::Success, RequestError<Self::Failure>> {
        Err(RequestError::Other(
            "No response is defined for PositioningMeasurementAbort!".to_string(),
        ))
    }
}

pub struct PositioningMeasurementFailureIndicationProcedure {}

#[async_trait]
impl Procedure for PositioningMeasurementFailureIndicationProcedure {
    type TopPdu = F1apPdu;
    type Request = PositioningMeasurementFailureIndication;
    type Success = ();
    type Failure = ();
    const CODE: u8 = 46;

    async fn call_provider<T: RequestProvider<Self>>(
        provider: &T,
        req: PositioningMeasurementFailureIndication,
        logger: &Logger,
    ) -> Option<F1apPdu> {
        match <T as RequestProvider<PositioningMeasurementFailureIndicationProcedure>>::request(
            provider, req, logger,
        )
        .await
        {
            Ok(_) => None,
            Err(_) => todo!(),
        }
    }

    fn encode_request(r: Self::Request) -> Result<Vec<u8>, AperCodecError> {
        F1apPdu::InitiatingMessage(InitiatingMessage::PositioningMeasurementFailureIndication(
            r,
        ))
        .into_bytes()
    }

    fn decode_response(_bytes: &[u8]) -> Result<Self::Success, RequestError<Self::Failure>> {
        Err(RequestError::Other(
            "No response is defined for PositioningMeasurementFailureIndication!".to_string(),
        ))
    }
}

pub struct PositioningMeasurementUpdateProcedure {}

#[async_trait]
impl Procedure for PositioningMeasurementUpdateProcedure {
    type TopPdu = F1apPdu;
    type Request = PositioningMeasurementUpdate;
    type Success = ();
    type Failure = ();
    const CODE: u8 = 47;

    async fn call_provider<T: RequestProvider<Self>>(
        provider: &T,
        req: PositioningMeasurementUpdate,
        logger: &Logger,
    ) -> Option<F1apPdu> {
        match <T as RequestProvider<PositioningMeasurementUpdateProcedure>>::request(
            provider, req, logger,
        )
        .await
        {
            Ok(_) => None,
            Err(_) => todo!(),
        }
    }

    fn encode_request(r: Self::Request) -> Result<Vec<u8>, AperCodecError> {
        F1apPdu::InitiatingMessage(InitiatingMessage::PositioningMeasurementUpdate(r)).into_bytes()
    }

    fn decode_response(_bytes: &[u8]) -> Result<Self::Success, RequestError<Self::Failure>> {
        Err(RequestError::Other(
            "No response is defined for PositioningMeasurementUpdate!".to_string(),
        ))
    }
}

pub struct TrpInformationExchangeProcedure {}

#[async_trait]
impl Procedure for TrpInformationExchangeProcedure {
    type TopPdu = F1apPdu;
    type Request = TrpInformationRequest;
    type Success = TrpInformationResponse;
    type Failure = TrpInformationFailure;
    const CODE: u8 = 48;

    async fn call_provider<T: RequestProvider<Self>>(
        provider: &T,
        req: TrpInformationRequest,
        logger: &Logger,
    ) -> Option<F1apPdu> {
        match <T as RequestProvider<TrpInformationExchangeProcedure>>::request(
            provider, req, logger,
        )
        .await
        {
            Ok(x) => Some(F1apPdu::SuccessfulOutcome(
                SuccessfulOutcome::TrpInformationResponse(x),
            )),
            Err(_) => todo!(),
        }
    }

    fn encode_request(r: Self::Request) -> Result<Vec<u8>, AperCodecError> {
        F1apPdu::InitiatingMessage(InitiatingMessage::TrpInformationRequest(r)).into_bytes()
    }

    fn decode_response(bytes: &[u8]) -> Result<Self::Success, RequestError<Self::Failure>> {
        let response_pdu = Self::TopPdu::from_bytes(bytes)?;
        match response_pdu {
            F1apPdu::SuccessfulOutcome(SuccessfulOutcome::TrpInformationResponse(x)) => Ok(x),
            F1apPdu::UnsuccessfulOutcome(UnsuccessfulOutcome::TrpInformationFailure(x)) => {
                Err(RequestError::UnsuccessfulOutcome(x))
            }
            _ => Err(RequestError::Other("Unexpected pdu contents".to_string())),
        }
    }
}

pub struct PositioningInformationExchangeProcedure {}

#[async_trait]
impl Procedure for PositioningInformationExchangeProcedure {
    type TopPdu = F1apPdu;
    type Request = PositioningInformationRequest;
    type Success = PositioningInformationResponse;
    type Failure = PositioningInformationFailure;
    const CODE: u8 = 49;

    async fn call_provider<T: RequestProvider<Self>>(
        provider: &T,
        req: PositioningInformationRequest,
        logger: &Logger,
    ) -> Option<F1apPdu> {
        match <T as RequestProvider<PositioningInformationExchangeProcedure>>::request(
            provider, req, logger,
        )
        .await
        {
            Ok(x) => Some(F1apPdu::SuccessfulOutcome(
                SuccessfulOutcome::PositioningInformationResponse(x),
            )),
            Err(_) => todo!(),
        }
    }

    fn encode_request(r: Self::Request) -> Result<Vec<u8>, AperCodecError> {
        F1apPdu::InitiatingMessage(InitiatingMessage::PositioningInformationRequest(r)).into_bytes()
    }

    fn decode_response(bytes: &[u8]) -> Result<Self::Success, RequestError<Self::Failure>> {
        let response_pdu = Self::TopPdu::from_bytes(bytes)?;
        match response_pdu {
            F1apPdu::SuccessfulOutcome(SuccessfulOutcome::PositioningInformationResponse(x)) => {
                Ok(x)
            }
            F1apPdu::UnsuccessfulOutcome(UnsuccessfulOutcome::PositioningInformationFailure(x)) => {
                Err(RequestError::UnsuccessfulOutcome(x))
            }
            _ => Err(RequestError::Other("Unexpected pdu contents".to_string())),
        }
    }
}

pub struct PositioningActivationProcedure {}

#[async_trait]
impl Procedure for PositioningActivationProcedure {
    type TopPdu = F1apPdu;
    type Request = PositioningActivationRequest;
    type Success = PositioningActivationResponse;
    type Failure = PositioningActivationFailure;
    const CODE: u8 = 50;

    async fn call_provider<T: RequestProvider<Self>>(
        provider: &T,
        req: PositioningActivationRequest,
        logger: &Logger,
    ) -> Option<F1apPdu> {
        match <T as RequestProvider<PositioningActivationProcedure>>::request(provider, req, logger)
            .await
        {
            Ok(x) => Some(F1apPdu::SuccessfulOutcome(
                SuccessfulOutcome::PositioningActivationResponse(x),
            )),
            Err(_) => todo!(),
        }
    }

    fn encode_request(r: Self::Request) -> Result<Vec<u8>, AperCodecError> {
        F1apPdu::InitiatingMessage(InitiatingMessage::PositioningActivationRequest(r)).into_bytes()
    }

    fn decode_response(bytes: &[u8]) -> Result<Self::Success, RequestError<Self::Failure>> {
        let response_pdu = Self::TopPdu::from_bytes(bytes)?;
        match response_pdu {
            F1apPdu::SuccessfulOutcome(SuccessfulOutcome::PositioningActivationResponse(x)) => {
                Ok(x)
            }
            F1apPdu::UnsuccessfulOutcome(UnsuccessfulOutcome::PositioningActivationFailure(x)) => {
                Err(RequestError::UnsuccessfulOutcome(x))
            }
            _ => Err(RequestError::Other("Unexpected pdu contents".to_string())),
        }
    }
}

pub struct PositioningDeactivationProcedure {}

#[async_trait]
impl Procedure for PositioningDeactivationProcedure {
    type TopPdu = F1apPdu;
    type Request = PositioningDeactivation;
    type Success = ();
    type Failure = ();
    const CODE: u8 = 51;

    async fn call_provider<T: RequestProvider<Self>>(
        provider: &T,
        req: PositioningDeactivation,
        logger: &Logger,
    ) -> Option<F1apPdu> {
        match <T as RequestProvider<PositioningDeactivationProcedure>>::request(
            provider, req, logger,
        )
        .await
        {
            Ok(_) => None,
            Err(_) => todo!(),
        }
    }

    fn encode_request(r: Self::Request) -> Result<Vec<u8>, AperCodecError> {
        F1apPdu::InitiatingMessage(InitiatingMessage::PositioningDeactivation(r)).into_bytes()
    }

    fn decode_response(_bytes: &[u8]) -> Result<Self::Success, RequestError<Self::Failure>> {
        Err(RequestError::Other(
            "No response is defined for PositioningDeactivation!".to_string(),
        ))
    }
}

pub struct ECidMeasurementInitiationProcedure {}

#[async_trait]
impl Procedure for ECidMeasurementInitiationProcedure {
    type TopPdu = F1apPdu;
    type Request = ECidMeasurementInitiationRequest;
    type Success = ECidMeasurementInitiationResponse;
    type Failure = ECidMeasurementInitiationFailure;
    const CODE: u8 = 52;

    async fn call_provider<T: RequestProvider<Self>>(
        provider: &T,
        req: ECidMeasurementInitiationRequest,
        logger: &Logger,
    ) -> Option<F1apPdu> {
        match <T as RequestProvider<ECidMeasurementInitiationProcedure>>::request(
            provider, req, logger,
        )
        .await
        {
            Ok(x) => Some(F1apPdu::SuccessfulOutcome(
                SuccessfulOutcome::ECidMeasurementInitiationResponse(x),
            )),
            Err(_) => todo!(),
        }
    }

    fn encode_request(r: Self::Request) -> Result<Vec<u8>, AperCodecError> {
        F1apPdu::InitiatingMessage(InitiatingMessage::ECidMeasurementInitiationRequest(r))
            .into_bytes()
    }

    fn decode_response(bytes: &[u8]) -> Result<Self::Success, RequestError<Self::Failure>> {
        let response_pdu = Self::TopPdu::from_bytes(bytes)?;
        match response_pdu {
            F1apPdu::SuccessfulOutcome(SuccessfulOutcome::ECidMeasurementInitiationResponse(x)) => {
                Ok(x)
            }
            F1apPdu::UnsuccessfulOutcome(
                UnsuccessfulOutcome::ECidMeasurementInitiationFailure(x),
            ) => Err(RequestError::UnsuccessfulOutcome(x)),
            _ => Err(RequestError::Other("Unexpected pdu contents".to_string())),
        }
    }
}

pub struct ECidMeasurementFailureIndicationProcedure {}

#[async_trait]
impl Procedure for ECidMeasurementFailureIndicationProcedure {
    type TopPdu = F1apPdu;
    type Request = ECidMeasurementFailureIndication;
    type Success = ();
    type Failure = ();
    const CODE: u8 = 53;

    async fn call_provider<T: RequestProvider<Self>>(
        provider: &T,
        req: ECidMeasurementFailureIndication,
        logger: &Logger,
    ) -> Option<F1apPdu> {
        match <T as RequestProvider<ECidMeasurementFailureIndicationProcedure>>::request(
            provider, req, logger,
        )
        .await
        {
            Ok(_) => None,
            Err(_) => todo!(),
        }
    }

    fn encode_request(r: Self::Request) -> Result<Vec<u8>, AperCodecError> {
        F1apPdu::InitiatingMessage(InitiatingMessage::ECidMeasurementFailureIndication(r))
            .into_bytes()
    }

    fn decode_response(_bytes: &[u8]) -> Result<Self::Success, RequestError<Self::Failure>> {
        Err(RequestError::Other(
            "No response is defined for ECidMeasurementFailureIndication!".to_string(),
        ))
    }
}

pub struct ECidMeasurementReportProcedure {}

#[async_trait]
impl Procedure for ECidMeasurementReportProcedure {
    type TopPdu = F1apPdu;
    type Request = ECidMeasurementReport;
    type Success = ();
    type Failure = ();
    const CODE: u8 = 54;

    async fn call_provider<T: RequestProvider<Self>>(
        provider: &T,
        req: ECidMeasurementReport,
        logger: &Logger,
    ) -> Option<F1apPdu> {
        match <T as RequestProvider<ECidMeasurementReportProcedure>>::request(provider, req, logger)
            .await
        {
            Ok(_) => None,
            Err(_) => todo!(),
        }
    }

    fn encode_request(r: Self::Request) -> Result<Vec<u8>, AperCodecError> {
        F1apPdu::InitiatingMessage(InitiatingMessage::ECidMeasurementReport(r)).into_bytes()
    }

    fn decode_response(_bytes: &[u8]) -> Result<Self::Success, RequestError<Self::Failure>> {
        Err(RequestError::Other(
            "No response is defined for ECidMeasurementReport!".to_string(),
        ))
    }
}

pub struct ECidMeasurementTerminationProcedure {}

#[async_trait]
impl Procedure for ECidMeasurementTerminationProcedure {
    type TopPdu = F1apPdu;
    type Request = ECidMeasurementTerminationCommand;
    type Success = ();
    type Failure = ();
    const CODE: u8 = 55;

    async fn call_provider<T: RequestProvider<Self>>(
        provider: &T,
        req: ECidMeasurementTerminationCommand,
        logger: &Logger,
    ) -> Option<F1apPdu> {
        match <T as RequestProvider<ECidMeasurementTerminationProcedure>>::request(
            provider, req, logger,
        )
        .await
        {
            Ok(_) => None,
            Err(_) => todo!(),
        }
    }

    fn encode_request(r: Self::Request) -> Result<Vec<u8>, AperCodecError> {
        F1apPdu::InitiatingMessage(InitiatingMessage::ECidMeasurementTerminationCommand(r))
            .into_bytes()
    }

    fn decode_response(_bytes: &[u8]) -> Result<Self::Success, RequestError<Self::Failure>> {
        Err(RequestError::Other(
            "No response is defined for ECidMeasurementTerminationCommand!".to_string(),
        ))
    }
}

pub struct PositioningInformationUpdateProcedure {}

#[async_trait]
impl Procedure for PositioningInformationUpdateProcedure {
    type TopPdu = F1apPdu;
    type Request = PositioningInformationUpdate;
    type Success = ();
    type Failure = ();
    const CODE: u8 = 56;

    async fn call_provider<T: RequestProvider<Self>>(
        provider: &T,
        req: PositioningInformationUpdate,
        logger: &Logger,
    ) -> Option<F1apPdu> {
        match <T as RequestProvider<PositioningInformationUpdateProcedure>>::request(
            provider, req, logger,
        )
        .await
        {
            Ok(_) => None,
            Err(_) => todo!(),
        }
    }

    fn encode_request(r: Self::Request) -> Result<Vec<u8>, AperCodecError> {
        F1apPdu::InitiatingMessage(InitiatingMessage::PositioningInformationUpdate(r)).into_bytes()
    }

    fn decode_response(_bytes: &[u8]) -> Result<Self::Success, RequestError<Self::Failure>> {
        Err(RequestError::Other(
            "No response is defined for PositioningInformationUpdate!".to_string(),
        ))
    }
}

#[derive(Clone, Debug)]
pub enum InitiatingMessage {
    Reset(Reset),
    F1SetupRequest(F1SetupRequest),
    GnbDuConfigurationUpdate(GnbDuConfigurationUpdate),
    GnbCuConfigurationUpdate(GnbCuConfigurationUpdate),
    UeContextSetupRequest(UeContextSetupRequest),
    UeContextReleaseCommand(UeContextReleaseCommand),
    UeContextModificationRequest(UeContextModificationRequest),
    UeContextModificationRequired(UeContextModificationRequired),
    WriteReplaceWarningRequest(WriteReplaceWarningRequest),
    PwsCancelRequest(PwsCancelRequest),
    ErrorIndication(ErrorIndication),
    UeContextReleaseRequest(UeContextReleaseRequest),
    InitialUlRrcMessageTransfer(InitialUlRrcMessageTransfer),
    DlRrcMessageTransfer(DlRrcMessageTransfer),
    UlRrcMessageTransfer(UlRrcMessageTransfer),
    UeInactivityNotification(UeInactivityNotification),
    GnbDuResourceCoordinationRequest(GnbDuResourceCoordinationRequest),
    SystemInformationDeliveryCommand(SystemInformationDeliveryCommand),
    Paging(Paging),
    Notify(Notify),
    NetworkAccessRateReduction(NetworkAccessRateReduction),
    PwsRestartIndication(PwsRestartIndication),
    PwsFailureIndication(PwsFailureIndication),
    GnbDuStatusIndication(GnbDuStatusIndication),
    RrcDeliveryReport(RrcDeliveryReport),
    F1RemovalRequest(F1RemovalRequest),
    TraceStart(TraceStart),
    DeactivateTrace(DeactivateTrace),
    DuCuRadioInformationTransfer(DuCuRadioInformationTransfer),
    CuDuRadioInformationTransfer(CuDuRadioInformationTransfer),
    BapMappingConfiguration(BapMappingConfiguration),
    GnbDuResourceConfiguration(GnbDuResourceConfiguration),
    IabtnlAddressRequest(IabtnlAddressRequest),
    IabupConfigurationUpdateRequest(IabupConfigurationUpdateRequest),
    ResourceStatusRequest(ResourceStatusRequest),
    ResourceStatusUpdate(ResourceStatusUpdate),
    AccessAndMobilityIndication(AccessAndMobilityIndication),
    ReferenceTimeInformationReportingControl(ReferenceTimeInformationReportingControl),
    ReferenceTimeInformationReport(ReferenceTimeInformationReport),
    AccessSuccess(AccessSuccess),
    CellTrafficTrace(CellTrafficTrace),
    PositioningAssistanceInformationControl(PositioningAssistanceInformationControl),
    PositioningAssistanceInformationFeedback(PositioningAssistanceInformationFeedback),
    PositioningMeasurementRequest(PositioningMeasurementRequest),
    PositioningMeasurementReport(PositioningMeasurementReport),
    PositioningMeasurementAbort(PositioningMeasurementAbort),
    PositioningMeasurementFailureIndication(PositioningMeasurementFailureIndication),
    PositioningMeasurementUpdate(PositioningMeasurementUpdate),
    TrpInformationRequest(TrpInformationRequest),
    PositioningInformationRequest(PositioningInformationRequest),
    PositioningActivationRequest(PositioningActivationRequest),
    PositioningDeactivation(PositioningDeactivation),
    ECidMeasurementInitiationRequest(ECidMeasurementInitiationRequest),
    ECidMeasurementFailureIndication(ECidMeasurementFailureIndication),
    ECidMeasurementReport(ECidMeasurementReport),
    ECidMeasurementTerminationCommand(ECidMeasurementTerminationCommand),
    PositioningInformationUpdate(PositioningInformationUpdate),
}

impl InitiatingMessage {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (id, _ext) = aper::decode::decode_integer(data, Some(0), Some(255), false)?;
        let _ = Criticality::decode(data)?;
        match id {
            0 => Ok(Self::Reset(Reset::decode(data)?)),
            1 => Ok(Self::F1SetupRequest(F1SetupRequest::decode(data)?)),
            3 => Ok(Self::GnbDuConfigurationUpdate(
                GnbDuConfigurationUpdate::decode(data)?,
            )),
            4 => Ok(Self::GnbCuConfigurationUpdate(
                GnbCuConfigurationUpdate::decode(data)?,
            )),
            5 => Ok(Self::UeContextSetupRequest(UeContextSetupRequest::decode(
                data,
            )?)),
            6 => Ok(Self::UeContextReleaseCommand(
                UeContextReleaseCommand::decode(data)?,
            )),
            7 => Ok(Self::UeContextModificationRequest(
                UeContextModificationRequest::decode(data)?,
            )),
            8 => Ok(Self::UeContextModificationRequired(
                UeContextModificationRequired::decode(data)?,
            )),
            20 => Ok(Self::WriteReplaceWarningRequest(
                WriteReplaceWarningRequest::decode(data)?,
            )),
            21 => Ok(Self::PwsCancelRequest(PwsCancelRequest::decode(data)?)),
            2 => Ok(Self::ErrorIndication(ErrorIndication::decode(data)?)),
            10 => Ok(Self::UeContextReleaseRequest(
                UeContextReleaseRequest::decode(data)?,
            )),
            11 => Ok(Self::InitialUlRrcMessageTransfer(
                InitialUlRrcMessageTransfer::decode(data)?,
            )),
            12 => Ok(Self::DlRrcMessageTransfer(DlRrcMessageTransfer::decode(
                data,
            )?)),
            13 => Ok(Self::UlRrcMessageTransfer(UlRrcMessageTransfer::decode(
                data,
            )?)),
            15 => Ok(Self::UeInactivityNotification(
                UeInactivityNotification::decode(data)?,
            )),
            16 => Ok(Self::GnbDuResourceCoordinationRequest(
                GnbDuResourceCoordinationRequest::decode(data)?,
            )),
            17 => Ok(Self::SystemInformationDeliveryCommand(
                SystemInformationDeliveryCommand::decode(data)?,
            )),
            18 => Ok(Self::Paging(Paging::decode(data)?)),
            19 => Ok(Self::Notify(Notify::decode(data)?)),
            27 => Ok(Self::NetworkAccessRateReduction(
                NetworkAccessRateReduction::decode(data)?,
            )),
            22 => Ok(Self::PwsRestartIndication(PwsRestartIndication::decode(
                data,
            )?)),
            23 => Ok(Self::PwsFailureIndication(PwsFailureIndication::decode(
                data,
            )?)),
            24 => Ok(Self::GnbDuStatusIndication(GnbDuStatusIndication::decode(
                data,
            )?)),
            25 => Ok(Self::RrcDeliveryReport(RrcDeliveryReport::decode(data)?)),
            26 => Ok(Self::F1RemovalRequest(F1RemovalRequest::decode(data)?)),
            28 => Ok(Self::TraceStart(TraceStart::decode(data)?)),
            29 => Ok(Self::DeactivateTrace(DeactivateTrace::decode(data)?)),
            30 => Ok(Self::DuCuRadioInformationTransfer(
                DuCuRadioInformationTransfer::decode(data)?,
            )),
            31 => Ok(Self::CuDuRadioInformationTransfer(
                CuDuRadioInformationTransfer::decode(data)?,
            )),
            32 => Ok(Self::BapMappingConfiguration(
                BapMappingConfiguration::decode(data)?,
            )),
            33 => Ok(Self::GnbDuResourceConfiguration(
                GnbDuResourceConfiguration::decode(data)?,
            )),
            34 => Ok(Self::IabtnlAddressRequest(IabtnlAddressRequest::decode(
                data,
            )?)),
            35 => Ok(Self::IabupConfigurationUpdateRequest(
                IabupConfigurationUpdateRequest::decode(data)?,
            )),
            36 => Ok(Self::ResourceStatusRequest(ResourceStatusRequest::decode(
                data,
            )?)),
            37 => Ok(Self::ResourceStatusUpdate(ResourceStatusUpdate::decode(
                data,
            )?)),
            38 => Ok(Self::AccessAndMobilityIndication(
                AccessAndMobilityIndication::decode(data)?,
            )),
            58 => Ok(Self::ReferenceTimeInformationReportingControl(
                ReferenceTimeInformationReportingControl::decode(data)?,
            )),
            57 => Ok(Self::ReferenceTimeInformationReport(
                ReferenceTimeInformationReport::decode(data)?,
            )),
            39 => Ok(Self::AccessSuccess(AccessSuccess::decode(data)?)),
            40 => Ok(Self::CellTrafficTrace(CellTrafficTrace::decode(data)?)),
            42 => Ok(Self::PositioningAssistanceInformationControl(
                PositioningAssistanceInformationControl::decode(data)?,
            )),
            43 => Ok(Self::PositioningAssistanceInformationFeedback(
                PositioningAssistanceInformationFeedback::decode(data)?,
            )),
            41 => Ok(Self::PositioningMeasurementRequest(
                PositioningMeasurementRequest::decode(data)?,
            )),
            44 => Ok(Self::PositioningMeasurementReport(
                PositioningMeasurementReport::decode(data)?,
            )),
            45 => Ok(Self::PositioningMeasurementAbort(
                PositioningMeasurementAbort::decode(data)?,
            )),
            46 => Ok(Self::PositioningMeasurementFailureIndication(
                PositioningMeasurementFailureIndication::decode(data)?,
            )),
            47 => Ok(Self::PositioningMeasurementUpdate(
                PositioningMeasurementUpdate::decode(data)?,
            )),
            48 => Ok(Self::TrpInformationRequest(TrpInformationRequest::decode(
                data,
            )?)),
            49 => Ok(Self::PositioningInformationRequest(
                PositioningInformationRequest::decode(data)?,
            )),
            50 => Ok(Self::PositioningActivationRequest(
                PositioningActivationRequest::decode(data)?,
            )),
            51 => Ok(Self::PositioningDeactivation(
                PositioningDeactivation::decode(data)?,
            )),
            52 => Ok(Self::ECidMeasurementInitiationRequest(
                ECidMeasurementInitiationRequest::decode(data)?,
            )),
            53 => Ok(Self::ECidMeasurementFailureIndication(
                ECidMeasurementFailureIndication::decode(data)?,
            )),
            54 => Ok(Self::ECidMeasurementReport(ECidMeasurementReport::decode(
                data,
            )?)),
            55 => Ok(Self::ECidMeasurementTerminationCommand(
                ECidMeasurementTerminationCommand::decode(data)?,
            )),
            56 => Ok(Self::PositioningInformationUpdate(
                PositioningInformationUpdate::decode(data)?,
            )),
            x => {
                return Err(aper::AperCodecError::new(format!(
                    "Unrecognised procedure code {}",
                    x
                )))
            }
        }
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        match self {
            Self::Reset(x) => {
                aper::encode::encode_integer(data, Some(0), Some(255), false, 0, false)?;
                Criticality::Reject.encode(data)?;
                x.encode(data)?;
            }
            Self::F1SetupRequest(x) => {
                aper::encode::encode_integer(data, Some(0), Some(255), false, 1, false)?;
                Criticality::Reject.encode(data)?;
                x.encode(data)?;
            }
            Self::GnbDuConfigurationUpdate(x) => {
                aper::encode::encode_integer(data, Some(0), Some(255), false, 3, false)?;
                Criticality::Reject.encode(data)?;
                x.encode(data)?;
            }
            Self::GnbCuConfigurationUpdate(x) => {
                aper::encode::encode_integer(data, Some(0), Some(255), false, 4, false)?;
                Criticality::Reject.encode(data)?;
                x.encode(data)?;
            }
            Self::UeContextSetupRequest(x) => {
                aper::encode::encode_integer(data, Some(0), Some(255), false, 5, false)?;
                Criticality::Reject.encode(data)?;
                x.encode(data)?;
            }
            Self::UeContextReleaseCommand(x) => {
                aper::encode::encode_integer(data, Some(0), Some(255), false, 6, false)?;
                Criticality::Reject.encode(data)?;
                x.encode(data)?;
            }
            Self::UeContextModificationRequest(x) => {
                aper::encode::encode_integer(data, Some(0), Some(255), false, 7, false)?;
                Criticality::Reject.encode(data)?;
                x.encode(data)?;
            }
            Self::UeContextModificationRequired(x) => {
                aper::encode::encode_integer(data, Some(0), Some(255), false, 8, false)?;
                Criticality::Reject.encode(data)?;
                x.encode(data)?;
            }
            Self::WriteReplaceWarningRequest(x) => {
                aper::encode::encode_integer(data, Some(0), Some(255), false, 20, false)?;
                Criticality::Reject.encode(data)?;
                x.encode(data)?;
            }
            Self::PwsCancelRequest(x) => {
                aper::encode::encode_integer(data, Some(0), Some(255), false, 21, false)?;
                Criticality::Reject.encode(data)?;
                x.encode(data)?;
            }
            Self::ErrorIndication(x) => {
                aper::encode::encode_integer(data, Some(0), Some(255), false, 2, false)?;
                Criticality::Ignore.encode(data)?;
                x.encode(data)?;
            }
            Self::UeContextReleaseRequest(x) => {
                aper::encode::encode_integer(data, Some(0), Some(255), false, 10, false)?;
                Criticality::Ignore.encode(data)?;
                x.encode(data)?;
            }
            Self::InitialUlRrcMessageTransfer(x) => {
                aper::encode::encode_integer(data, Some(0), Some(255), false, 11, false)?;
                Criticality::Ignore.encode(data)?;
                x.encode(data)?;
            }
            Self::DlRrcMessageTransfer(x) => {
                aper::encode::encode_integer(data, Some(0), Some(255), false, 12, false)?;
                Criticality::Ignore.encode(data)?;
                x.encode(data)?;
            }
            Self::UlRrcMessageTransfer(x) => {
                aper::encode::encode_integer(data, Some(0), Some(255), false, 13, false)?;
                Criticality::Ignore.encode(data)?;
                x.encode(data)?;
            }
            Self::UeInactivityNotification(x) => {
                aper::encode::encode_integer(data, Some(0), Some(255), false, 15, false)?;
                Criticality::Ignore.encode(data)?;
                x.encode(data)?;
            }
            Self::GnbDuResourceCoordinationRequest(x) => {
                aper::encode::encode_integer(data, Some(0), Some(255), false, 16, false)?;
                Criticality::Reject.encode(data)?;
                x.encode(data)?;
            }
            Self::SystemInformationDeliveryCommand(x) => {
                aper::encode::encode_integer(data, Some(0), Some(255), false, 17, false)?;
                Criticality::Ignore.encode(data)?;
                x.encode(data)?;
            }
            Self::Paging(x) => {
                aper::encode::encode_integer(data, Some(0), Some(255), false, 18, false)?;
                Criticality::Ignore.encode(data)?;
                x.encode(data)?;
            }
            Self::Notify(x) => {
                aper::encode::encode_integer(data, Some(0), Some(255), false, 19, false)?;
                Criticality::Ignore.encode(data)?;
                x.encode(data)?;
            }
            Self::NetworkAccessRateReduction(x) => {
                aper::encode::encode_integer(data, Some(0), Some(255), false, 27, false)?;
                Criticality::Ignore.encode(data)?;
                x.encode(data)?;
            }
            Self::PwsRestartIndication(x) => {
                aper::encode::encode_integer(data, Some(0), Some(255), false, 22, false)?;
                Criticality::Ignore.encode(data)?;
                x.encode(data)?;
            }
            Self::PwsFailureIndication(x) => {
                aper::encode::encode_integer(data, Some(0), Some(255), false, 23, false)?;
                Criticality::Ignore.encode(data)?;
                x.encode(data)?;
            }
            Self::GnbDuStatusIndication(x) => {
                aper::encode::encode_integer(data, Some(0), Some(255), false, 24, false)?;
                Criticality::Ignore.encode(data)?;
                x.encode(data)?;
            }
            Self::RrcDeliveryReport(x) => {
                aper::encode::encode_integer(data, Some(0), Some(255), false, 25, false)?;
                Criticality::Ignore.encode(data)?;
                x.encode(data)?;
            }
            Self::F1RemovalRequest(x) => {
                aper::encode::encode_integer(data, Some(0), Some(255), false, 26, false)?;
                Criticality::Reject.encode(data)?;
                x.encode(data)?;
            }
            Self::TraceStart(x) => {
                aper::encode::encode_integer(data, Some(0), Some(255), false, 28, false)?;
                Criticality::Ignore.encode(data)?;
                x.encode(data)?;
            }
            Self::DeactivateTrace(x) => {
                aper::encode::encode_integer(data, Some(0), Some(255), false, 29, false)?;
                Criticality::Ignore.encode(data)?;
                x.encode(data)?;
            }
            Self::DuCuRadioInformationTransfer(x) => {
                aper::encode::encode_integer(data, Some(0), Some(255), false, 30, false)?;
                Criticality::Ignore.encode(data)?;
                x.encode(data)?;
            }
            Self::CuDuRadioInformationTransfer(x) => {
                aper::encode::encode_integer(data, Some(0), Some(255), false, 31, false)?;
                Criticality::Ignore.encode(data)?;
                x.encode(data)?;
            }
            Self::BapMappingConfiguration(x) => {
                aper::encode::encode_integer(data, Some(0), Some(255), false, 32, false)?;
                Criticality::Reject.encode(data)?;
                x.encode(data)?;
            }
            Self::GnbDuResourceConfiguration(x) => {
                aper::encode::encode_integer(data, Some(0), Some(255), false, 33, false)?;
                Criticality::Reject.encode(data)?;
                x.encode(data)?;
            }
            Self::IabtnlAddressRequest(x) => {
                aper::encode::encode_integer(data, Some(0), Some(255), false, 34, false)?;
                Criticality::Reject.encode(data)?;
                x.encode(data)?;
            }
            Self::IabupConfigurationUpdateRequest(x) => {
                aper::encode::encode_integer(data, Some(0), Some(255), false, 35, false)?;
                Criticality::Reject.encode(data)?;
                x.encode(data)?;
            }
            Self::ResourceStatusRequest(x) => {
                aper::encode::encode_integer(data, Some(0), Some(255), false, 36, false)?;
                Criticality::Reject.encode(data)?;
                x.encode(data)?;
            }
            Self::ResourceStatusUpdate(x) => {
                aper::encode::encode_integer(data, Some(0), Some(255), false, 37, false)?;
                Criticality::Ignore.encode(data)?;
                x.encode(data)?;
            }
            Self::AccessAndMobilityIndication(x) => {
                aper::encode::encode_integer(data, Some(0), Some(255), false, 38, false)?;
                Criticality::Ignore.encode(data)?;
                x.encode(data)?;
            }
            Self::ReferenceTimeInformationReportingControl(x) => {
                aper::encode::encode_integer(data, Some(0), Some(255), false, 58, false)?;
                Criticality::Ignore.encode(data)?;
                x.encode(data)?;
            }
            Self::ReferenceTimeInformationReport(x) => {
                aper::encode::encode_integer(data, Some(0), Some(255), false, 57, false)?;
                Criticality::Ignore.encode(data)?;
                x.encode(data)?;
            }
            Self::AccessSuccess(x) => {
                aper::encode::encode_integer(data, Some(0), Some(255), false, 39, false)?;
                Criticality::Ignore.encode(data)?;
                x.encode(data)?;
            }
            Self::CellTrafficTrace(x) => {
                aper::encode::encode_integer(data, Some(0), Some(255), false, 40, false)?;
                Criticality::Ignore.encode(data)?;
                x.encode(data)?;
            }
            Self::PositioningAssistanceInformationControl(x) => {
                aper::encode::encode_integer(data, Some(0), Some(255), false, 42, false)?;
                Criticality::Ignore.encode(data)?;
                x.encode(data)?;
            }
            Self::PositioningAssistanceInformationFeedback(x) => {
                aper::encode::encode_integer(data, Some(0), Some(255), false, 43, false)?;
                Criticality::Ignore.encode(data)?;
                x.encode(data)?;
            }
            Self::PositioningMeasurementRequest(x) => {
                aper::encode::encode_integer(data, Some(0), Some(255), false, 41, false)?;
                Criticality::Reject.encode(data)?;
                x.encode(data)?;
            }
            Self::PositioningMeasurementReport(x) => {
                aper::encode::encode_integer(data, Some(0), Some(255), false, 44, false)?;
                Criticality::Ignore.encode(data)?;
                x.encode(data)?;
            }
            Self::PositioningMeasurementAbort(x) => {
                aper::encode::encode_integer(data, Some(0), Some(255), false, 45, false)?;
                Criticality::Ignore.encode(data)?;
                x.encode(data)?;
            }
            Self::PositioningMeasurementFailureIndication(x) => {
                aper::encode::encode_integer(data, Some(0), Some(255), false, 46, false)?;
                Criticality::Ignore.encode(data)?;
                x.encode(data)?;
            }
            Self::PositioningMeasurementUpdate(x) => {
                aper::encode::encode_integer(data, Some(0), Some(255), false, 47, false)?;
                Criticality::Ignore.encode(data)?;
                x.encode(data)?;
            }
            Self::TrpInformationRequest(x) => {
                aper::encode::encode_integer(data, Some(0), Some(255), false, 48, false)?;
                Criticality::Reject.encode(data)?;
                x.encode(data)?;
            }
            Self::PositioningInformationRequest(x) => {
                aper::encode::encode_integer(data, Some(0), Some(255), false, 49, false)?;
                Criticality::Reject.encode(data)?;
                x.encode(data)?;
            }
            Self::PositioningActivationRequest(x) => {
                aper::encode::encode_integer(data, Some(0), Some(255), false, 50, false)?;
                Criticality::Reject.encode(data)?;
                x.encode(data)?;
            }
            Self::PositioningDeactivation(x) => {
                aper::encode::encode_integer(data, Some(0), Some(255), false, 51, false)?;
                Criticality::Ignore.encode(data)?;
                x.encode(data)?;
            }
            Self::ECidMeasurementInitiationRequest(x) => {
                aper::encode::encode_integer(data, Some(0), Some(255), false, 52, false)?;
                Criticality::Reject.encode(data)?;
                x.encode(data)?;
            }
            Self::ECidMeasurementFailureIndication(x) => {
                aper::encode::encode_integer(data, Some(0), Some(255), false, 53, false)?;
                Criticality::Ignore.encode(data)?;
                x.encode(data)?;
            }
            Self::ECidMeasurementReport(x) => {
                aper::encode::encode_integer(data, Some(0), Some(255), false, 54, false)?;
                Criticality::Ignore.encode(data)?;
                x.encode(data)?;
            }
            Self::ECidMeasurementTerminationCommand(x) => {
                aper::encode::encode_integer(data, Some(0), Some(255), false, 55, false)?;
                Criticality::Ignore.encode(data)?;
                x.encode(data)?;
            }
            Self::PositioningInformationUpdate(x) => {
                aper::encode::encode_integer(data, Some(0), Some(255), false, 56, false)?;
                Criticality::Ignore.encode(data)?;
                x.encode(data)?;
            }
        }
        Ok(())
    }
}

impl AperCodec for InitiatingMessage {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        InitiatingMessage::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("InitiatingMessage"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("InitiatingMessage"))
    }
}

#[derive(Clone, Debug)]
pub enum SuccessfulOutcome {
    ResetAcknowledge(ResetAcknowledge),
    F1SetupResponse(F1SetupResponse),
    GnbDuConfigurationUpdateAcknowledge(GnbDuConfigurationUpdateAcknowledge),
    GnbCuConfigurationUpdateAcknowledge(GnbCuConfigurationUpdateAcknowledge),
    UeContextSetupResponse(UeContextSetupResponse),
    UeContextReleaseComplete(UeContextReleaseComplete),
    UeContextModificationResponse(UeContextModificationResponse),
    UeContextModificationConfirm(UeContextModificationConfirm),
    WriteReplaceWarningResponse(WriteReplaceWarningResponse),
    PwsCancelResponse(PwsCancelResponse),
    GnbDuResourceCoordinationResponse(GnbDuResourceCoordinationResponse),
    F1RemovalResponse(F1RemovalResponse),
    BapMappingConfigurationAcknowledge(BapMappingConfigurationAcknowledge),
    GnbDuResourceConfigurationAcknowledge(GnbDuResourceConfigurationAcknowledge),
    IabtnlAddressResponse(IabtnlAddressResponse),
    IabupConfigurationUpdateResponse(IabupConfigurationUpdateResponse),
    ResourceStatusResponse(ResourceStatusResponse),
    PositioningMeasurementResponse(PositioningMeasurementResponse),
    TrpInformationResponse(TrpInformationResponse),
    PositioningInformationResponse(PositioningInformationResponse),
    PositioningActivationResponse(PositioningActivationResponse),
    ECidMeasurementInitiationResponse(ECidMeasurementInitiationResponse),
}

impl SuccessfulOutcome {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (id, _ext) = aper::decode::decode_integer(data, Some(0), Some(255), false)?;
        let _ = Criticality::decode(data)?;
        match id {
            0 => Ok(Self::ResetAcknowledge(ResetAcknowledge::decode(data)?)),
            1 => Ok(Self::F1SetupResponse(F1SetupResponse::decode(data)?)),
            3 => Ok(Self::GnbDuConfigurationUpdateAcknowledge(
                GnbDuConfigurationUpdateAcknowledge::decode(data)?,
            )),
            4 => Ok(Self::GnbCuConfigurationUpdateAcknowledge(
                GnbCuConfigurationUpdateAcknowledge::decode(data)?,
            )),
            5 => Ok(Self::UeContextSetupResponse(
                UeContextSetupResponse::decode(data)?,
            )),
            6 => Ok(Self::UeContextReleaseComplete(
                UeContextReleaseComplete::decode(data)?,
            )),
            7 => Ok(Self::UeContextModificationResponse(
                UeContextModificationResponse::decode(data)?,
            )),
            8 => Ok(Self::UeContextModificationConfirm(
                UeContextModificationConfirm::decode(data)?,
            )),
            20 => Ok(Self::WriteReplaceWarningResponse(
                WriteReplaceWarningResponse::decode(data)?,
            )),
            21 => Ok(Self::PwsCancelResponse(PwsCancelResponse::decode(data)?)),
            16 => Ok(Self::GnbDuResourceCoordinationResponse(
                GnbDuResourceCoordinationResponse::decode(data)?,
            )),
            26 => Ok(Self::F1RemovalResponse(F1RemovalResponse::decode(data)?)),
            32 => Ok(Self::BapMappingConfigurationAcknowledge(
                BapMappingConfigurationAcknowledge::decode(data)?,
            )),
            33 => Ok(Self::GnbDuResourceConfigurationAcknowledge(
                GnbDuResourceConfigurationAcknowledge::decode(data)?,
            )),
            34 => Ok(Self::IabtnlAddressResponse(IabtnlAddressResponse::decode(
                data,
            )?)),
            35 => Ok(Self::IabupConfigurationUpdateResponse(
                IabupConfigurationUpdateResponse::decode(data)?,
            )),
            36 => Ok(Self::ResourceStatusResponse(
                ResourceStatusResponse::decode(data)?,
            )),
            41 => Ok(Self::PositioningMeasurementResponse(
                PositioningMeasurementResponse::decode(data)?,
            )),
            48 => Ok(Self::TrpInformationResponse(
                TrpInformationResponse::decode(data)?,
            )),
            49 => Ok(Self::PositioningInformationResponse(
                PositioningInformationResponse::decode(data)?,
            )),
            50 => Ok(Self::PositioningActivationResponse(
                PositioningActivationResponse::decode(data)?,
            )),
            52 => Ok(Self::ECidMeasurementInitiationResponse(
                ECidMeasurementInitiationResponse::decode(data)?,
            )),
            x => {
                return Err(aper::AperCodecError::new(format!(
                    "Unrecognised procedure code {}",
                    x
                )))
            }
        }
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        match self {
            Self::ResetAcknowledge(x) => {
                aper::encode::encode_integer(data, Some(0), Some(255), false, 0, false)?;
                Criticality::Reject.encode(data)?;
                x.encode(data)?;
            }
            Self::F1SetupResponse(x) => {
                aper::encode::encode_integer(data, Some(0), Some(255), false, 1, false)?;
                Criticality::Reject.encode(data)?;
                x.encode(data)?;
            }
            Self::GnbDuConfigurationUpdateAcknowledge(x) => {
                aper::encode::encode_integer(data, Some(0), Some(255), false, 3, false)?;
                Criticality::Reject.encode(data)?;
                x.encode(data)?;
            }
            Self::GnbCuConfigurationUpdateAcknowledge(x) => {
                aper::encode::encode_integer(data, Some(0), Some(255), false, 4, false)?;
                Criticality::Reject.encode(data)?;
                x.encode(data)?;
            }
            Self::UeContextSetupResponse(x) => {
                aper::encode::encode_integer(data, Some(0), Some(255), false, 5, false)?;
                Criticality::Reject.encode(data)?;
                x.encode(data)?;
            }
            Self::UeContextReleaseComplete(x) => {
                aper::encode::encode_integer(data, Some(0), Some(255), false, 6, false)?;
                Criticality::Reject.encode(data)?;
                x.encode(data)?;
            }
            Self::UeContextModificationResponse(x) => {
                aper::encode::encode_integer(data, Some(0), Some(255), false, 7, false)?;
                Criticality::Reject.encode(data)?;
                x.encode(data)?;
            }
            Self::UeContextModificationConfirm(x) => {
                aper::encode::encode_integer(data, Some(0), Some(255), false, 8, false)?;
                Criticality::Reject.encode(data)?;
                x.encode(data)?;
            }
            Self::WriteReplaceWarningResponse(x) => {
                aper::encode::encode_integer(data, Some(0), Some(255), false, 20, false)?;
                Criticality::Reject.encode(data)?;
                x.encode(data)?;
            }
            Self::PwsCancelResponse(x) => {
                aper::encode::encode_integer(data, Some(0), Some(255), false, 21, false)?;
                Criticality::Reject.encode(data)?;
                x.encode(data)?;
            }
            Self::GnbDuResourceCoordinationResponse(x) => {
                aper::encode::encode_integer(data, Some(0), Some(255), false, 16, false)?;
                Criticality::Reject.encode(data)?;
                x.encode(data)?;
            }
            Self::F1RemovalResponse(x) => {
                aper::encode::encode_integer(data, Some(0), Some(255), false, 26, false)?;
                Criticality::Reject.encode(data)?;
                x.encode(data)?;
            }
            Self::BapMappingConfigurationAcknowledge(x) => {
                aper::encode::encode_integer(data, Some(0), Some(255), false, 32, false)?;
                Criticality::Reject.encode(data)?;
                x.encode(data)?;
            }
            Self::GnbDuResourceConfigurationAcknowledge(x) => {
                aper::encode::encode_integer(data, Some(0), Some(255), false, 33, false)?;
                Criticality::Reject.encode(data)?;
                x.encode(data)?;
            }
            Self::IabtnlAddressResponse(x) => {
                aper::encode::encode_integer(data, Some(0), Some(255), false, 34, false)?;
                Criticality::Reject.encode(data)?;
                x.encode(data)?;
            }
            Self::IabupConfigurationUpdateResponse(x) => {
                aper::encode::encode_integer(data, Some(0), Some(255), false, 35, false)?;
                Criticality::Reject.encode(data)?;
                x.encode(data)?;
            }
            Self::ResourceStatusResponse(x) => {
                aper::encode::encode_integer(data, Some(0), Some(255), false, 36, false)?;
                Criticality::Reject.encode(data)?;
                x.encode(data)?;
            }
            Self::PositioningMeasurementResponse(x) => {
                aper::encode::encode_integer(data, Some(0), Some(255), false, 41, false)?;
                Criticality::Reject.encode(data)?;
                x.encode(data)?;
            }
            Self::TrpInformationResponse(x) => {
                aper::encode::encode_integer(data, Some(0), Some(255), false, 48, false)?;
                Criticality::Reject.encode(data)?;
                x.encode(data)?;
            }
            Self::PositioningInformationResponse(x) => {
                aper::encode::encode_integer(data, Some(0), Some(255), false, 49, false)?;
                Criticality::Reject.encode(data)?;
                x.encode(data)?;
            }
            Self::PositioningActivationResponse(x) => {
                aper::encode::encode_integer(data, Some(0), Some(255), false, 50, false)?;
                Criticality::Reject.encode(data)?;
                x.encode(data)?;
            }
            Self::ECidMeasurementInitiationResponse(x) => {
                aper::encode::encode_integer(data, Some(0), Some(255), false, 52, false)?;
                Criticality::Reject.encode(data)?;
                x.encode(data)?;
            }
        }
        Ok(())
    }
}

impl AperCodec for SuccessfulOutcome {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        SuccessfulOutcome::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("SuccessfulOutcome"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("SuccessfulOutcome"))
    }
}

#[derive(Clone, Debug)]
pub enum UnsuccessfulOutcome {
    F1SetupFailure(F1SetupFailure),
    GnbDuConfigurationUpdateFailure(GnbDuConfigurationUpdateFailure),
    GnbCuConfigurationUpdateFailure(GnbCuConfigurationUpdateFailure),
    UeContextSetupFailure(UeContextSetupFailure),
    UeContextModificationFailure(UeContextModificationFailure),
    UeContextModificationRefuse(UeContextModificationRefuse),
    F1RemovalFailure(F1RemovalFailure),
    BapMappingConfigurationFailure(BapMappingConfigurationFailure),
    GnbDuResourceConfigurationFailure(GnbDuResourceConfigurationFailure),
    IabtnlAddressFailure(IabtnlAddressFailure),
    IabupConfigurationUpdateFailure(IabupConfigurationUpdateFailure),
    ResourceStatusFailure(ResourceStatusFailure),
    PositioningMeasurementFailure(PositioningMeasurementFailure),
    TrpInformationFailure(TrpInformationFailure),
    PositioningInformationFailure(PositioningInformationFailure),
    PositioningActivationFailure(PositioningActivationFailure),
    ECidMeasurementInitiationFailure(ECidMeasurementInitiationFailure),
}

impl UnsuccessfulOutcome {
    fn decode_inner(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        let (id, _ext) = aper::decode::decode_integer(data, Some(0), Some(255), false)?;
        let _ = Criticality::decode(data)?;
        match id {
            1 => Ok(Self::F1SetupFailure(F1SetupFailure::decode(data)?)),
            3 => Ok(Self::GnbDuConfigurationUpdateFailure(
                GnbDuConfigurationUpdateFailure::decode(data)?,
            )),
            4 => Ok(Self::GnbCuConfigurationUpdateFailure(
                GnbCuConfigurationUpdateFailure::decode(data)?,
            )),
            5 => Ok(Self::UeContextSetupFailure(UeContextSetupFailure::decode(
                data,
            )?)),
            7 => Ok(Self::UeContextModificationFailure(
                UeContextModificationFailure::decode(data)?,
            )),
            8 => Ok(Self::UeContextModificationRefuse(
                UeContextModificationRefuse::decode(data)?,
            )),
            26 => Ok(Self::F1RemovalFailure(F1RemovalFailure::decode(data)?)),
            32 => Ok(Self::BapMappingConfigurationFailure(
                BapMappingConfigurationFailure::decode(data)?,
            )),
            33 => Ok(Self::GnbDuResourceConfigurationFailure(
                GnbDuResourceConfigurationFailure::decode(data)?,
            )),
            34 => Ok(Self::IabtnlAddressFailure(IabtnlAddressFailure::decode(
                data,
            )?)),
            35 => Ok(Self::IabupConfigurationUpdateFailure(
                IabupConfigurationUpdateFailure::decode(data)?,
            )),
            36 => Ok(Self::ResourceStatusFailure(ResourceStatusFailure::decode(
                data,
            )?)),
            41 => Ok(Self::PositioningMeasurementFailure(
                PositioningMeasurementFailure::decode(data)?,
            )),
            48 => Ok(Self::TrpInformationFailure(TrpInformationFailure::decode(
                data,
            )?)),
            49 => Ok(Self::PositioningInformationFailure(
                PositioningInformationFailure::decode(data)?,
            )),
            50 => Ok(Self::PositioningActivationFailure(
                PositioningActivationFailure::decode(data)?,
            )),
            52 => Ok(Self::ECidMeasurementInitiationFailure(
                ECidMeasurementInitiationFailure::decode(data)?,
            )),
            x => {
                return Err(aper::AperCodecError::new(format!(
                    "Unrecognised procedure code {}",
                    x
                )))
            }
        }
    }
    fn encode_inner(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        match self {
            Self::F1SetupFailure(x) => {
                aper::encode::encode_integer(data, Some(0), Some(255), false, 1, false)?;
                Criticality::Reject.encode(data)?;
                x.encode(data)?;
            }
            Self::GnbDuConfigurationUpdateFailure(x) => {
                aper::encode::encode_integer(data, Some(0), Some(255), false, 3, false)?;
                Criticality::Reject.encode(data)?;
                x.encode(data)?;
            }
            Self::GnbCuConfigurationUpdateFailure(x) => {
                aper::encode::encode_integer(data, Some(0), Some(255), false, 4, false)?;
                Criticality::Reject.encode(data)?;
                x.encode(data)?;
            }
            Self::UeContextSetupFailure(x) => {
                aper::encode::encode_integer(data, Some(0), Some(255), false, 5, false)?;
                Criticality::Reject.encode(data)?;
                x.encode(data)?;
            }
            Self::UeContextModificationFailure(x) => {
                aper::encode::encode_integer(data, Some(0), Some(255), false, 7, false)?;
                Criticality::Reject.encode(data)?;
                x.encode(data)?;
            }
            Self::UeContextModificationRefuse(x) => {
                aper::encode::encode_integer(data, Some(0), Some(255), false, 8, false)?;
                Criticality::Reject.encode(data)?;
                x.encode(data)?;
            }
            Self::F1RemovalFailure(x) => {
                aper::encode::encode_integer(data, Some(0), Some(255), false, 26, false)?;
                Criticality::Reject.encode(data)?;
                x.encode(data)?;
            }
            Self::BapMappingConfigurationFailure(x) => {
                aper::encode::encode_integer(data, Some(0), Some(255), false, 32, false)?;
                Criticality::Reject.encode(data)?;
                x.encode(data)?;
            }
            Self::GnbDuResourceConfigurationFailure(x) => {
                aper::encode::encode_integer(data, Some(0), Some(255), false, 33, false)?;
                Criticality::Reject.encode(data)?;
                x.encode(data)?;
            }
            Self::IabtnlAddressFailure(x) => {
                aper::encode::encode_integer(data, Some(0), Some(255), false, 34, false)?;
                Criticality::Reject.encode(data)?;
                x.encode(data)?;
            }
            Self::IabupConfigurationUpdateFailure(x) => {
                aper::encode::encode_integer(data, Some(0), Some(255), false, 35, false)?;
                Criticality::Reject.encode(data)?;
                x.encode(data)?;
            }
            Self::ResourceStatusFailure(x) => {
                aper::encode::encode_integer(data, Some(0), Some(255), false, 36, false)?;
                Criticality::Reject.encode(data)?;
                x.encode(data)?;
            }
            Self::PositioningMeasurementFailure(x) => {
                aper::encode::encode_integer(data, Some(0), Some(255), false, 41, false)?;
                Criticality::Reject.encode(data)?;
                x.encode(data)?;
            }
            Self::TrpInformationFailure(x) => {
                aper::encode::encode_integer(data, Some(0), Some(255), false, 48, false)?;
                Criticality::Reject.encode(data)?;
                x.encode(data)?;
            }
            Self::PositioningInformationFailure(x) => {
                aper::encode::encode_integer(data, Some(0), Some(255), false, 49, false)?;
                Criticality::Reject.encode(data)?;
                x.encode(data)?;
            }
            Self::PositioningActivationFailure(x) => {
                aper::encode::encode_integer(data, Some(0), Some(255), false, 50, false)?;
                Criticality::Reject.encode(data)?;
                x.encode(data)?;
            }
            Self::ECidMeasurementInitiationFailure(x) => {
                aper::encode::encode_integer(data, Some(0), Some(255), false, 52, false)?;
                Criticality::Reject.encode(data)?;
                x.encode(data)?;
            }
        }
        Ok(())
    }
}

impl AperCodec for UnsuccessfulOutcome {
    type Output = Self;
    fn decode(data: &mut AperCodecData) -> Result<Self, AperCodecError> {
        UnsuccessfulOutcome::decode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("UnsuccessfulOutcome"))
    }
    fn encode(&self, data: &mut AperCodecData) -> Result<(), AperCodecError> {
        self.encode_inner(data)
            .map_err(|e: AperCodecError| e.push_context("UnsuccessfulOutcome"))
    }
}
